<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classparallel_1_1DistributedTriangulationBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel::DistributedTriangulationBase&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceparallel.html">parallel</a></li><li class="navelem"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html">DistributedTriangulationBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="classparallel_1_1DistributedTriangulationBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="distributed_2tria__base_8h_source.html">deal.II/distributed/tria_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structparallel_1_1DistributedTriangulationBase_1_1CellAttachedData.html">CellAttachedData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html">DataTransfer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb254bd3c238056d5c44627167944253"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:acb254bd3c238056d5c44627167944253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c98433e1e221ee65731e81345a72546"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a7c98433e1e221ee65731e81345a72546">CellStatus</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td></tr>
<tr class="separator:a7c98433e1e221ee65731e81345a72546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb254bd3c238056d5c44627167944253"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:acb254bd3c238056d5c44627167944253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c98433e1e221ee65731e81345a72546"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a7c98433e1e221ee65731e81345a72546">CellStatus</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td></tr>
<tr class="separator:a7c98433e1e221ee65731e81345a72546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb254bd3c238056d5c44627167944253"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:acb254bd3c238056d5c44627167944253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c98433e1e221ee65731e81345a72546"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a7c98433e1e221ee65731e81345a72546">CellStatus</a> = typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td></tr>
<tr class="separator:a7c98433e1e221ee65731e81345a72546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c836c1e503743e8073eb615603aab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga08c836c1e503743e8073eb615603aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c836c1e503743e8073eb615603aab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga08c836c1e503743e8073eb615603aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c836c1e503743e8073eb615603aab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga08c836c1e503743e8073eb615603aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a1a25af910eb1418cf9719953b0c330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6a1a25af910eb1418cf9719953b0c330">DistributedTriangulationBase</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a>, const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a>=(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>), const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a>=false)</td></tr>
<tr class="separator:a6a1a25af910eb1418cf9719953b0c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6c7f53d060c63005b005e7638d2219"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear</a> () override</td></tr>
<tr class="separator:a0f6c7f53d060c63005b005e7638d2219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac958319402a5301d2dde94f1c6e8c78a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a> (const std::string &amp;filename) const =0</td></tr>
<tr class="separator:ac958319402a5301d2dde94f1c6e8c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7ad9fd72720414a8c983acee58142"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> autopartition=true)=0</td></tr>
<tr class="separator:ad5a7ad9fd72720414a8c983acee58142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a95528832932bf2fad380f8098367"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach</a> (const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;pack_callback, const <a class="el" href="classbool.html">bool</a> returns_variable_size_data)</td></tr>
<tr class="separator:acb1a95528832932bf2fad380f8098367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack</a> (const unsigned <a class="el" href="classint.html">int</a> handle, const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;unpack_callback)</td></tr>
<tr class="separator:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1a25af910eb1418cf9719953b0c330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6a1a25af910eb1418cf9719953b0c330">DistributedTriangulationBase</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a>, const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a>=(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>), const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a>=false)</td></tr>
<tr class="separator:a6a1a25af910eb1418cf9719953b0c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b346b087dd89464415ecb7d2775a61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">clear</a> () override</td></tr>
<tr class="separator:af8b346b087dd89464415ecb7d2775a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac958319402a5301d2dde94f1c6e8c78a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a> (const std::string &amp;filename) const =0</td></tr>
<tr class="separator:ac958319402a5301d2dde94f1c6e8c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7ad9fd72720414a8c983acee58142"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> autopartition=true)=0</td></tr>
<tr class="separator:ad5a7ad9fd72720414a8c983acee58142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a95528832932bf2fad380f8098367"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach</a> (const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;pack_callback, const <a class="el" href="classbool.html">bool</a> returns_variable_size_data)</td></tr>
<tr class="separator:acb1a95528832932bf2fad380f8098367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack</a> (const unsigned <a class="el" href="classint.html">int</a> handle, const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;unpack_callback)</td></tr>
<tr class="separator:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1a25af910eb1418cf9719953b0c330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6a1a25af910eb1418cf9719953b0c330">DistributedTriangulationBase</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a>, const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a>=(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>), const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a>=false)</td></tr>
<tr class="separator:a6a1a25af910eb1418cf9719953b0c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b346b087dd89464415ecb7d2775a61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">clear</a> () override</td></tr>
<tr class="separator:af8b346b087dd89464415ecb7d2775a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac958319402a5301d2dde94f1c6e8c78a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a> (const std::string &amp;filename) const =0</td></tr>
<tr class="separator:ac958319402a5301d2dde94f1c6e8c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7ad9fd72720414a8c983acee58142"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> autopartition=true)=0</td></tr>
<tr class="separator:ad5a7ad9fd72720414a8c983acee58142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a95528832932bf2fad380f8098367"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach</a> (const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;pack_callback, const <a class="el" href="classbool.html">bool</a> returns_variable_size_data)</td></tr>
<tr class="separator:acb1a95528832932bf2fad380f8098367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack</a> (const unsigned <a class="el" href="classint.html">int</a> handle, const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;unpack_callback)</td></tr>
<tr class="separator:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e42ca28e9e64c2f292c7cf5d6cb4e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad6e42ca28e9e64c2f292c7cf5d6cb4e5">get_communicator</a> () const override</td></tr>
<tr class="separator:ad6e42ca28e9e64c2f292c7cf5d6cb4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b606a3f26f71603f7759dc16d33db9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a77b606a3f26f71603f7759dc16d33db9">get_communicator</a> () const override</td></tr>
<tr class="separator:a77b606a3f26f71603f7759dc16d33db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b606a3f26f71603f7759dc16d33db9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a77b606a3f26f71603f7759dc16d33db9">get_communicator</a> () const override</td></tr>
<tr class="separator:a77b606a3f26f71603f7759dc16d33db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2bf98c3056379a2b132ad62266f780"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0a2bf98c3056379a2b132ad62266f780">get_communicator</a> () const</td></tr>
<tr class="separator:a0a2bf98c3056379a2b132ad62266f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8f9bfda5524458e6fb8ebe54e9c491fc">is_multilevel_hierarchy_constructed</a> () const=0</td></tr>
<tr class="separator:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8f9bfda5524458e6fb8ebe54e9c491fc">is_multilevel_hierarchy_constructed</a> () const=0</td></tr>
<tr class="separator:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8f9bfda5524458e6fb8ebe54e9c491fc">is_multilevel_hierarchy_constructed</a> () const=0</td></tr>
<tr class="separator:a8f9bfda5524458e6fb8ebe54e9c491fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc11d84b1e73511844762ad8c111053"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#afcc11d84b1e73511844762ad8c111053">copy_triangulation</a> (const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;old_tria) override</td></tr>
<tr class="separator:afcc11d84b1e73511844762ad8c111053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba82cc28f325167d0950150e23cf037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a7ba82cc28f325167d0950150e23cf037">copy_triangulation</a> (const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;old_tria) override</td></tr>
<tr class="separator:a7ba82cc28f325167d0950150e23cf037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba82cc28f325167d0950150e23cf037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a7ba82cc28f325167d0950150e23cf037">copy_triangulation</a> (const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;old_tria) override</td></tr>
<tr class="separator:a7ba82cc28f325167d0950150e23cf037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2bf1d34aacdba358add7fd59b32822"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1f2bf1d34aacdba358add7fd59b32822">copy_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria)</td></tr>
<tr class="separator:a1f2bf1d34aacdba358add7fd59b32822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e904416671ca175093274144e49439"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells</a> () const</td></tr>
<tr class="separator:a74e904416671ca175093274144e49439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e904416671ca175093274144e49439"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells</a> () const</td></tr>
<tr class="separator:a74e904416671ca175093274144e49439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e904416671ca175093274144e49439"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells</a> () const</td></tr>
<tr class="separator:a74e904416671ca175093274144e49439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fedf8c5b9488f5f82dfbe3d04c3bc0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a0fedf8c5b9488f5f82dfbe3d04c3bc0f">n_global_active_cells</a> () const override</td></tr>
<tr class="separator:a0fedf8c5b9488f5f82dfbe3d04c3bc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">n_global_active_cells</a> () const override</td></tr>
<tr class="separator:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">n_global_active_cells</a> () const override</td></tr>
<tr class="separator:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad3703ebbac4468e07b74c3ca595747"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a0ad3703ebbac4468e07b74c3ca595747">memory_consumption</a> () const override</td></tr>
<tr class="separator:a0ad3703ebbac4468e07b74c3ca595747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8baa2e614b9868460a7a0f3cbc6d3de"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad8baa2e614b9868460a7a0f3cbc6d3de">memory_consumption</a> () const override</td></tr>
<tr class="separator:ad8baa2e614b9868460a7a0f3cbc6d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8baa2e614b9868460a7a0f3cbc6d3de"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad8baa2e614b9868460a7a0f3cbc6d3de">memory_consumption</a> () const override</td></tr>
<tr class="separator:ad8baa2e614b9868460a7a0f3cbc6d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6247bd25858eeed99445f2eb810b9c"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels</a> () const override</td></tr>
<tr class="separator:a5e6247bd25858eeed99445f2eb810b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels</a> () const override</td></tr>
<tr class="separator:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels</a> () const override</td></tr>
<tr class="separator:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b129156d89f37482d2095de5751d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain</a> () const override</td></tr>
<tr class="separator:a41b129156d89f37482d2095de5751d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b129156d89f37482d2095de5751d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain</a> () const override</td></tr>
<tr class="separator:a41b129156d89f37482d2095de5751d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b129156d89f37482d2095de5751d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain</a> () const override</td></tr>
<tr class="separator:a41b129156d89f37482d2095de5751d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d26a19ae0d8cf91473a647f381364"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a182d26a19ae0d8cf91473a647f381364">ghost_owners</a> () const</td></tr>
<tr class="separator:a182d26a19ae0d8cf91473a647f381364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a5e24708aa6563bf529cd8a10ca0cbe12">ghost_owners</a> () const</td></tr>
<tr class="separator:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a5e24708aa6563bf529cd8a10ca0cbe12">ghost_owners</a> () const</td></tr>
<tr class="separator:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08420b1432082185edaaf83dbc8b4bee"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a08420b1432082185edaaf83dbc8b4bee">level_ghost_owners</a> () const</td></tr>
<tr class="separator:a08420b1432082185edaaf83dbc8b4bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff00f28a17583c0316af55b04b139e3"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#abff00f28a17583c0316af55b04b139e3">level_ghost_owners</a> () const</td></tr>
<tr class="separator:abff00f28a17583c0316af55b04b139e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff00f28a17583c0316af55b04b139e3"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#abff00f28a17583c0316af55b04b139e3">level_ghost_owners</a> () const</td></tr>
<tr class="separator:abff00f28a17583c0316af55b04b139e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6d84acdf8908f48fb236e2c2d47a17"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#abe6d84acdf8908f48fb236e2c2d47a17">global_active_cell_index_partitioner</a> () const</td></tr>
<tr class="separator:abe6d84acdf8908f48fb236e2c2d47a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a640568c9b7f4b50cf45b5c52a8420b05">global_active_cell_index_partitioner</a> () const</td></tr>
<tr class="separator:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a640568c9b7f4b50cf45b5c52a8420b05">global_active_cell_index_partitioner</a> () const</td></tr>
<tr class="separator:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3160e66fd9d88da46c47ce55524d656f"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a3160e66fd9d88da46c47ce55524d656f">global_level_cell_index_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3160e66fd9d88da46c47ce55524d656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8513533c19e088ed8303ea50198b9920"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8513533c19e088ed8303ea50198b9920">global_level_cell_index_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a8513533c19e088ed8303ea50198b9920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8513533c19e088ed8303ea50198b9920"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8513533c19e088ed8303ea50198b9920">global_level_cell_index_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a8513533c19e088ed8303ea50198b9920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0952d4737bd402994bc398cfa64a25"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">compute_vertices_with_ghost_neighbors</a> () const</td></tr>
<tr class="separator:a7f0952d4737bd402994bc398cfa64a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba526138718ef72dc1593c16e2cca7b"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a1ba526138718ef72dc1593c16e2cca7b">compute_vertices_with_ghost_neighbors</a> () const</td></tr>
<tr class="separator:a1ba526138718ef72dc1593c16e2cca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba526138718ef72dc1593c16e2cca7b"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a1ba526138718ef72dc1593c16e2cca7b">compute_vertices_with_ghost_neighbors</a> () const</td></tr>
<tr class="separator:a1ba526138718ef72dc1593c16e2cca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668fa9fc088a3986cfaefe328d6d2f25"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a668fa9fc088a3986cfaefe328d6d2f25">get_boundary_ids</a> () const override</td></tr>
<tr class="separator:a668fa9fc088a3986cfaefe328d6d2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1acf0c97fceec538c4552ee300213c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a1e1acf0c97fceec538c4552ee300213c">get_boundary_ids</a> () const override</td></tr>
<tr class="separator:a1e1acf0c97fceec538c4552ee300213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1acf0c97fceec538c4552ee300213c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a1e1acf0c97fceec538c4552ee300213c">get_boundary_ids</a> () const override</td></tr>
<tr class="separator:a1e1acf0c97fceec538c4552ee300213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a0d3cc6653496e5bebf32220ac4160"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a63a0d3cc6653496e5bebf32220ac4160">get_boundary_ids</a> () const</td></tr>
<tr class="separator:a63a0d3cc6653496e5bebf32220ac4160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04b7e2c65169692ae8805a085c2f7ca"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#af04b7e2c65169692ae8805a085c2f7ca">get_manifold_ids</a> () const override</td></tr>
<tr class="separator:af04b7e2c65169692ae8805a085c2f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f63aebdfa85dc769c1503c00670a7e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a51f63aebdfa85dc769c1503c00670a7e">get_manifold_ids</a> () const override</td></tr>
<tr class="separator:a51f63aebdfa85dc769c1503c00670a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f63aebdfa85dc769c1503c00670a7e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a51f63aebdfa85dc769c1503c00670a7e">get_manifold_ids</a> () const override</td></tr>
<tr class="separator:a51f63aebdfa85dc769c1503c00670a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41320ae1978763a1b83608e10408d68f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga41320ae1978763a1b83608e10408d68f">get_manifold_ids</a> () const</td></tr>
<tr class="separator:ga41320ae1978763a1b83608e10408d68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad63df2c11257f1e6fb482e4f9ea4589f">communicate_locally_moved_vertices</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;vertex_locally_moved)</td></tr>
<tr class="separator:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad63df2c11257f1e6fb482e4f9ea4589f">communicate_locally_moved_vertices</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;vertex_locally_moved)</td></tr>
<tr class="separator:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad63df2c11257f1e6fb482e4f9ea4589f">communicate_locally_moved_vertices</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;vertex_locally_moved)</td></tr>
<tr class="separator:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672f6e3ed2cc4377f804f0cdc4e19dd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a672f6e3ed2cc4377f804f0cdc4e19dd6">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a672f6e3ed2cc4377f804f0cdc4e19dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444acc0f6dd7a7fed2c657921a643800"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a444acc0f6dd7a7fed2c657921a643800">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a444acc0f6dd7a7fed2c657921a643800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2131fc63fb23e2e7eabb570b1e852e4a">get_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number) const</td></tr>
<tr class="separator:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga2131fc63fb23e2e7eabb570b1e852e4a">get_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number) const</td></tr>
<tr class="separator:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga2131fc63fb23e2e7eabb570b1e852e4a">get_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number) const</td></tr>
<tr class="separator:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eeef6a38fa053814433870a9c35a0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:ab2eeef6a38fa053814433870a9c35a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7accd2c69ad73912e4198443f186a5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7accd2c69ad73912e4198443f186a5e">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data)</td></tr>
<tr class="separator:af7accd2c69ad73912e4198443f186a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b191fa3249c9c3641492b6eedebf456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a1b191fa3249c9c3641492b6eedebf456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data)</td></tr>
<tr class="separator:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b191fa3249c9c3641492b6eedebf456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a1b191fa3249c9c3641492b6eedebf456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data)</td></tr>
<tr class="separator:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada18f9251ebb60ac0200eafeeddb78c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ada18f9251ebb60ac0200eafeeddb78c5">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:ada18f9251ebb60ac0200eafeeddb78c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbee6e665998c3e4a745cd7836df364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:abbbee6e665998c3e4a745cd7836df364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbee6e665998c3e4a745cd7836df364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:abbbee6e665998c3e4a745cd7836df364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77387c20bfe3e8fbe76ed7bbedeb3258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77387c20bfe3e8fbe76ed7bbedeb3258">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:a77387c20bfe3e8fbe76ed7bbedeb3258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9451a3cba24ac884dad5337be35286d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9451a3cba24ac884dad5337be35286d1">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:a9451a3cba24ac884dad5337be35286d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d94fc740577f178189d939e09486b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d94fc740577f178189d939e09486b79">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:a8d94fc740577f178189d939e09486b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f664cd903c4a7d36cfcf59edf77d23"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a79f664cd903c4a7d36cfcf59edf77d23">n_quads</a> () const</td></tr>
<tr class="separator:a79f664cd903c4a7d36cfcf59edf77d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e9cf2d0847dfc5fac2d9d9c39917ad"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a68e9cf2d0847dfc5fac2d9d9c39917ad">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a68e9cf2d0847dfc5fac2d9d9c39917ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43cc09475a962c64cf81b66bbc6063"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afa43cc09475a962c64cf81b66bbc6063">n_quads</a> () const</td></tr>
<tr class="separator:afa43cc09475a962c64cf81b66bbc6063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f759946225da01083c7788aba9a51a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab5f759946225da01083c7788aba9a51a">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:ab5f759946225da01083c7788aba9a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94898f00b04cdd9f446b2781d7c0dcc8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a94898f00b04cdd9f446b2781d7c0dcc8">n_quads</a> () const</td></tr>
<tr class="separator:a94898f00b04cdd9f446b2781d7c0dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2538b067fac8ad5c6e5f8bf8fae06"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae0b2538b067fac8ad5c6e5f8bf8fae06">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:ae0b2538b067fac8ad5c6e5f8bf8fae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfabc61a0635b5f0448e645e7944f4"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05dfabc61a0635b5f0448e645e7944f4">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a05dfabc61a0635b5f0448e645e7944f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb2a1aef23adff709c2fa112bfe870"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab9bb2a1aef23adff709c2fa112bfe870">n_active_quads</a> () const</td></tr>
<tr class="separator:ab9bb2a1aef23adff709c2fa112bfe870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a33c09d9402a8425583058d7f9d44ce"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7a33c09d9402a8425583058d7f9d44ce">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a7a33c09d9402a8425583058d7f9d44ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e29455eadbe8231a65da04eb0567d6"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80e29455eadbe8231a65da04eb0567d6">n_active_quads</a> () const</td></tr>
<tr class="separator:a80e29455eadbe8231a65da04eb0567d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f45d56e9d6679fcd0f8d793a5ecb891"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f45d56e9d6679fcd0f8d793a5ecb891">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a2f45d56e9d6679fcd0f8d793a5ecb891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff5c5e5aadf633944e2e6c7c7c7767"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40ff5c5e5aadf633944e2e6c7c7c7767">n_active_quads</a> () const</td></tr>
<tr class="separator:a40ff5c5e5aadf633944e2e6c7c7c7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d198aebd80535ad593e5133a8812ee"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac0d198aebd80535ad593e5133a8812ee">n_hexs</a> () const</td></tr>
<tr class="separator:ac0d198aebd80535ad593e5133a8812ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2699445c877451375c6128d44c90c9e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af2699445c877451375c6128d44c90c9e">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af2699445c877451375c6128d44c90c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fef4d5635144af728710f4e2783902"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a23fef4d5635144af728710f4e2783902">n_active_hexs</a> () const</td></tr>
<tr class="separator:a23fef4d5635144af728710f4e2783902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d8b81ff513c945250ddff5c6df54cd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a04d8b81ff513c945250ddff5c6df54cd">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a04d8b81ff513c945250ddff5c6df54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e3826a32b12684e8e4ff94a23a648"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5d6e3826a32b12684e8e4ff94a23a648">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:a5d6e3826a32b12684e8e4ff94a23a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b710ab15cf74994c3f33e4f4d17e95"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4b710ab15cf74994c3f33e4f4d17e95">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa4b710ab15cf74994c3f33e4f4d17e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a107913a2a6858ec87704accdff065f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3a107913a2a6858ec87704accdff065f">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:a3a107913a2a6858ec87704accdff065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ade3550e213fc07d713a28b489a9a6e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7ade3550e213fc07d713a28b489a9a6e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a7ade3550e213fc07d713a28b489a9a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb21a22bf29351cf42cfb335e82760"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afacb21a22bf29351cf42cfb335e82760">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:afacb21a22bf29351cf42cfb335e82760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f495bae2139d10563cf878da49bbb6"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad9f495bae2139d10563cf878da49bbb6">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:ad9f495bae2139d10563cf878da49bbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cac92589b83a46980c84338e4d32e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f1cac92589b83a46980c84338e4d32e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a2f1cac92589b83a46980c84338e4d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e1ddd6af8ce2f148dc2e471262cf8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a41e1ddd6af8ce2f148dc2e471262cf8c">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a41e1ddd6af8ce2f148dc2e471262cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70ff6a8fffd9c8f4074fb6f06f708c5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab70ff6a8fffd9c8f4074fb6f06f708c5">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:ab70ff6a8fffd9c8f4074fb6f06f708c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49642521d7ce41aea4fd882332f47f82"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a49642521d7ce41aea4fd882332f47f82">n_raw_quads</a> () const</td></tr>
<tr class="separator:a49642521d7ce41aea4fd882332f47f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc73e5f4491b310f3a65441be139513"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0bc73e5f4491b310f3a65441be139513">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a0bc73e5f4491b310f3a65441be139513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf5b1fd0f6f9753145821d9ff46101a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cf5b1fd0f6f9753145821d9ff46101a">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a5cf5b1fd0f6f9753145821d9ff46101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec203ac31c6102d901e205bd774362"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aeaec203ac31c6102d901e205bd774362">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:aeaec203ac31c6102d901e205bd774362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882c905333d176ffdcb5cd79f2e7a51e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a882c905333d176ffdcb5cd79f2e7a51e">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a882c905333d176ffdcb5cd79f2e7a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aefd8ddbf96799abebb6c05dced569329"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aefd8ddbf96799abebb6c05dced569329">dimension</a> = dim</td></tr>
<tr class="separator:aefd8ddbf96799abebb6c05dced569329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efe5cf75298c557be424d758bd79ec2"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4efe5cf75298c557be424d758bd79ec2">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a4efe5cf75298c557be424d758bd79ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae36be1617767da4972eb996d9325902f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> = typename std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> &gt;</td></tr>
<tr class="separator:ae36be1617767da4972eb996d9325902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36be1617767da4972eb996d9325902f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> = typename std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> &gt;</td></tr>
<tr class="separator:ae36be1617767da4972eb996d9325902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36be1617767da4972eb996d9325902f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> = typename std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> &gt;</td></tr>
<tr class="separator:ae36be1617767da4972eb996d9325902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a53caa007ddc9229fa461a0fd925482ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a53caa007ddc9229fa461a0fd925482ae">save_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const std::string &amp;filename) const</td></tr>
<tr class="separator:a53caa007ddc9229fa461a0fd925482ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef794a63c63ff09e2c1c231998083f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#aeef794a63c63ff09e2c1c231998083f2">load_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const unsigned <a class="el" href="classint.html">int</a> local_num_cells, const std::string &amp;filename, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_fixed, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_variable)</td></tr>
<tr class="separator:aeef794a63c63ff09e2c1c231998083f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe86d32d73e4c12d1e505739b3662a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">update_cell_relations</a> ()=0</td></tr>
<tr class="separator:a74fe86d32d73e4c12d1e505739b3662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53caa007ddc9229fa461a0fd925482ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a53caa007ddc9229fa461a0fd925482ae">save_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const std::string &amp;filename) const</td></tr>
<tr class="separator:a53caa007ddc9229fa461a0fd925482ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef794a63c63ff09e2c1c231998083f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#aeef794a63c63ff09e2c1c231998083f2">load_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const unsigned <a class="el" href="classint.html">int</a> local_num_cells, const std::string &amp;filename, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_fixed, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_variable)</td></tr>
<tr class="separator:aeef794a63c63ff09e2c1c231998083f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe86d32d73e4c12d1e505739b3662a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">update_cell_relations</a> ()=0</td></tr>
<tr class="separator:a74fe86d32d73e4c12d1e505739b3662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53caa007ddc9229fa461a0fd925482ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a53caa007ddc9229fa461a0fd925482ae">save_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const std::string &amp;filename) const</td></tr>
<tr class="separator:a53caa007ddc9229fa461a0fd925482ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef794a63c63ff09e2c1c231998083f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#aeef794a63c63ff09e2c1c231998083f2">load_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const unsigned <a class="el" href="classint.html">int</a> local_num_cells, const std::string &amp;filename, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_fixed, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_variable)</td></tr>
<tr class="separator:aeef794a63c63ff09e2c1c231998083f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe86d32d73e4c12d1e505739b3662a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">update_cell_relations</a> ()=0</td></tr>
<tr class="separator:a74fe86d32d73e4c12d1e505739b3662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5944f1ce4588d3215ae5b63c503e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a95e5944f1ce4588d3215ae5b63c503e0">update_number_cache</a> ()</td></tr>
<tr class="separator:a95e5944f1ce4588d3215ae5b63c503e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab5164a6fb30048f0ce5e81f67b60285f">update_number_cache</a> ()</td></tr>
<tr class="separator:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab5164a6fb30048f0ce5e81f67b60285f">update_number_cache</a> ()</td></tr>
<tr class="separator:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a10cf6c4bfa4a3d00d8c76792d1b9872a">update_reference_cells</a> () override</td></tr>
<tr class="separator:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a10cf6c4bfa4a3d00d8c76792d1b9872a">update_reference_cells</a> () override</td></tr>
<tr class="separator:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a10cf6c4bfa4a3d00d8c76792d1b9872a">update_reference_cells</a> () override</td></tr>
<tr class="separator:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#adac35d252ab3fcbcdc675d6ac526b24c">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#adac35d252ab3fcbcdc675d6ac526b24c">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#adac35d252ab3fcbcdc675d6ac526b24c">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abedea312211487def114beb5e06f1394"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#abedea312211487def114beb5e06f1394">local_cell_relations</a></td></tr>
<tr class="separator:abedea312211487def114beb5e06f1394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5979f543c847e88743216cb5986f7107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structparallel_1_1DistributedTriangulationBase_1_1CellAttachedData.html">CellAttachedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a5979f543c847e88743216cb5986f7107">cell_attached_data</a></td></tr>
<tr class="separator:a5979f543c847e88743216cb5986f7107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd423107278fb82665a4a64f0a6da6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html">DataTransfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#afd423107278fb82665a4a64f0a6da6d2">data_transfer</a></td></tr>
<tr class="separator:afd423107278fb82665a4a64f0a6da6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55959d63f6a4e18cae86f005df8605ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a></td></tr>
<tr class="separator:a55959d63f6a4e18cae86f005df8605ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#addf7a809217fa1eb11b8c06c49b1b2cb">my_subdomain</a></td></tr>
<tr class="separator:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25846dd7a465319119e91f44d77ae0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a25846dd7a465319119e91f44d77ae0b1">n_subdomains</a></td></tr>
<tr class="separator:a25846dd7a465319119e91f44d77ae0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29d4b50a16239861deb2bb07bc6089"><td class="memItemLeft" align="right" valign="top">NumberCache&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#aad29d4b50a16239861deb2bb07bc6089">number_cache</a></td></tr>
<tr class="separator:aad29d4b50a16239861deb2bb07bc6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> = ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> = ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> = ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mesh refinement @{</h2></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4fbb207303ec7f5ef758821ecd8cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:ac8b4fbb207303ec7f5ef758821ecd8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa3177e0e43ab0cf243215d284a35a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:ab9fa3177e0e43ab0cf243215d284a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf55199c30b0330cf9bf98e2582078e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:abf55199c30b0330cf9bf98e2582078e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Information about the triangulation @{</h2></td></tr>
<tr class="memitem:a584733c8499dbd140694bfe04e0963ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a> () const</td></tr>
<tr class="separator:a584733c8499dbd140694bfe04e0963ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd960d483675c4eb2c538529350e56b"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a> () const</td></tr>
<tr class="separator:aafd960d483675c4eb2c538529350e56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ea82a097d8317c98fa422307aff874"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a> () const</td></tr>
<tr class="separator:a44ea82a097d8317c98fa422307aff874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18ca78a1810d5dcdd214a56d9518025"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af18ca78a1810d5dcdd214a56d9518025">has_hanging_nodes</a> () const</td></tr>
<tr class="separator:af18ca78a1810d5dcdd214a56d9518025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cc3b953d71fe4081fa8f88820f034"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">has_hanging_nodes</a> () const</td></tr>
<tr class="separator:a935cc3b953d71fe4081fa8f88820f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e5de61b90fd6b9ee1bf02bfc355085"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">get_used_vertices</a> () const</td></tr>
<tr class="separator:ac0e5de61b90fd6b9ee1bf02bfc355085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc17a0a6b88aaba602e9888fce580b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#adc17a0a6b88aaba602e9888fce580b0c">get_triangulation</a> ()</td></tr>
<tr class="separator:adc17a0a6b88aaba602e9888fce580b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal information about the number of objects @{</h2></td></tr>
<tr class="memitem:a141e0408c89056ac6e179fc363f3d63e"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a141e0408c89056ac6e179fc363f3d63e">memory_consumption</a> () const</td></tr>
<tr class="separator:a141e0408c89056ac6e179fc363f3d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a2f0c10f7a8cd32d961e9367173685047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf04756b28dae69194870812acaf941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#adbf04756b28dae69194870812acaf941">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:adbf04756b28dae69194870812acaf941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27ce1c3232500c3d29b8a4a5cc9cf2"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abb27ce1c3232500c3d29b8a4a5cc9cf2">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:abb27ce1c3232500c3d29b8a4a5cc9cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd81b27e783924976ef8efa51bc7d76"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7dd81b27e783924976ef8efa51bc7d76">get_reference_cells</a> () const</td></tr>
<tr class="separator:a7dd81b27e783924976ef8efa51bc7d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exceptions @{</h2></td></tr>
<tr class="memitem:ac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:ac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffcc4c67b130ba9c64694d62fb551a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac5ffcc4c67b130ba9c64694d62fb551a">reference_cells</a></td></tr>
<tr class="separator:ac5ffcc4c67b130ba9c64694d62fb551a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; of a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>, but this <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> &quot;&lt;&lt; &quot;that is only allowed if the <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; of a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>, but this <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> &quot;&lt;&lt; &quot;that is only allowed if the <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> via &quot; &quot;<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> via &quot; &quot;<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b7c7321a76da1e83d9ee675fccd408"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1Policy.html">internal::TriangulationImplementation::Policy</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61b7c7321a76da1e83d9ee675fccd408">policy</a></td></tr>
<tr class="separator:a61b7c7321a76da1e83d9ee675fccd408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df2a6c22d5cfef72c97dc5f917ce794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3df2a6c22d5cfef72c97dc5f917ce794">periodic_face_pairs_level_0</a></td></tr>
<tr class="separator:a3df2a6c22d5cfef72c97dc5f917ce794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b72eb3c091c808ac088ee5b64cd676"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a83b72eb3c091c808ac088ee5b64cd676">periodic_face_map</a></td></tr>
<tr class="separator:a83b72eb3c091c808ac088ee5b64cd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2556bec2fb7f32b9d384664118fedb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7f2556bec2fb7f32b9d384664118fedb">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:a7f2556bec2fb7f32b9d384664118fedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:af9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac7df85e0ac685224e16e800ca3c87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3ac7df85e0ac685224e16e800ca3c87">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:af3ac7df85e0ac685224e16e800ca3c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:a20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions for internal use @{</h2></td></tr>
<tr class="memitem:a5977e64adfde9e63f274be77bb34dddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a5977e64adfde9e63f274be77bb34dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5977e64adfde9e63f274be77bb34dddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a5977e64adfde9e63f274be77bb34dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099dd8d123778fdadd882415d639d1b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a099dd8d123778fdadd882415d639d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099dd8d123778fdadd882415d639d1b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a099dd8d123778fdadd882415d639d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7bc0b40113139b244a54591e9d53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> = typename IteratorSelector::raw_line_iterator</td></tr>
<tr class="separator:a0e0f7bc0b40113139b244a54591e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7bc0b40113139b244a54591e9d53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> = typename IteratorSelector::raw_line_iterator</td></tr>
<tr class="separator:a0e0f7bc0b40113139b244a54591e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80735fd291dca4e5f958ee5876289aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> = typename IteratorSelector::raw_quad_iterator</td></tr>
<tr class="separator:a80735fd291dca4e5f958ee5876289aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80735fd291dca4e5f958ee5876289aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> = typename IteratorSelector::raw_quad_iterator</td></tr>
<tr class="separator:a80735fd291dca4e5f958ee5876289aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be382ff40558d007dd767a1288dc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> = typename IteratorSelector::raw_hex_iterator</td></tr>
<tr class="separator:ac2be382ff40558d007dd767a1288dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be382ff40558d007dd767a1288dc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> = typename IteratorSelector::raw_hex_iterator</td></tr>
<tr class="separator:ac2be382ff40558d007dd767a1288dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a4c703d5b4a6aab6d987c49c66611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a286a4c703d5b4a6aab6d987c49c66611">begin_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a286a4c703d5b4a6aab6d987c49c66611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a45bb19508b89ac6ed237b14bf7a506ef">begin_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ded01b76d89248739107dd430d3d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a69ded01b76d89248739107dd430d3d70">end_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a69ded01b76d89248739107dd430d3d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cbfc1e5187c6ad0a47d1b616f9f5149">end_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hex iterator functions for internal use @{</h2></td></tr>
<tr class="memitem:a6cc6c258d1ca9769fed554c717a64a62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6cc6c258d1ca9769fed554c717a64a62">levels</a></td></tr>
<tr class="separator:a6cc6c258d1ca9769fed554c717a64a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a3b87911c0427d5bc0523c53670910"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac3a3b87911c0427d5bc0523c53670910">faces</a></td></tr>
<tr class="separator:ac3a3b87911c0427d5bc0523c53670910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045b7d42762b613f8159f68f2c9814e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab045b7d42762b613f8159f68f2c9814e">vertices</a></td></tr>
<tr class="separator:ab045b7d42762b613f8159f68f2c9814e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19199dd313e595a112e6f1939d48b33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab19199dd313e595a112e6f1939d48b33">vertices_used</a></td></tr>
<tr class="separator:ab19199dd313e595a112e6f1939d48b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc9daec6e95b744482c2322ffbf6a8f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>, std::unique_ptr&lt; const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9cc9daec6e95b744482c2322ffbf6a8f">manifold</a></td></tr>
<tr class="separator:a9cc9daec6e95b744482c2322ffbf6a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc6feb50966969856aa359f6fa316a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12dc6feb50966969856aa359f6fa316a">anisotropic_refinement</a></td></tr>
<tr class="separator:a12dc6feb50966969856aa359f6fa316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55287cc4c709190b521fd98a4f5e02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a></td></tr>
<tr class="separator:a5c55287cc4c709190b521fd98a4f5e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78417baf0aa881f922344f24d3d4e62a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a78417baf0aa881f922344f24d3d4e62a">vertex_to_boundary_id_map_1d</a></td></tr>
<tr class="separator:a78417baf0aa881f922344f24d3d4e62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206e641c648868eaec4985fc6f0596be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a206e641c648868eaec4985fc6f0596be">vertex_to_manifold_id_map_1d</a></td></tr>
<tr class="separator:a206e641c648868eaec4985fc6f0596be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33a8577a7f7bbd5fd9ae1ddb2f5b132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad33a8577a7f7bbd5fd9ae1ddb2f5b132">begin_raw_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:ad33a8577a7f7bbd5fd9ae1ddb2f5b132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26795906ff2742c5f2109113b79d6744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26795906ff2742c5f2109113b79d6744">begin_raw_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a26795906ff2742c5f2109113b79d6744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936c5704f475d6929fd77fa47e980dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a936c5704f475d6929fd77fa47e980dc9">begin_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a936c5704f475d6929fd77fa47e980dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae764c732cc0de8322257d13912552b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae764c732cc0de8322257d13912552b8">begin_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:aae764c732cc0de8322257d13912552b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa8df823fb13004972571c3a1b3af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3ffa8df823fb13004972571c3a1b3af4">begin_active_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a3ffa8df823fb13004972571c3a1b3af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e876cdf1cdae06aa793cc5081b4fe31">begin_active_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a0c51731b66a58f91530ab630633b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4d1a0c51731b66a58f91530ab630633b">end_hex</a> () const</td></tr>
<tr class="separator:a4d1a0c51731b66a58f91530ab630633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd003c8d0a9d5839488ee2ad1313703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aadd003c8d0a9d5839488ee2ad1313703">end_hex</a> () const</td></tr>
<tr class="separator:aadd003c8d0a9d5839488ee2ad1313703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c164ad82da9629eab01f90ef2a360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af42c164ad82da9629eab01f90ef2a360">reset_policy</a> ()</td></tr>
<tr class="separator:af42c164ad82da9629eab01f90ef2a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c164ad82da9629eab01f90ef2a360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af42c164ad82da9629eab01f90ef2a360">reset_policy</a> ()</td></tr>
<tr class="separator:af42c164ad82da9629eab01f90ef2a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a365332f11d26e60c46a1f9bbb3e5e1c1">reset_active_cell_indices</a> ()</td></tr>
<tr class="separator:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a365332f11d26e60c46a1f9bbb3e5e1c1">reset_active_cell_indices</a> ()</td></tr>
<tr class="separator:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76af9cf5bbd5811b3f6ee8ca03ac8df6">reset_cell_vertex_indices_cache</a> ()</td></tr>
<tr class="separator:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76af9cf5bbd5811b3f6ee8ca03ac8df6">reset_cell_vertex_indices_cache</a> ()</td></tr>
<tr class="separator:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce4adddb4d040bda3239840519b70e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acce4adddb4d040bda3239840519b70e4">execute_refinement</a> ()</td></tr>
<tr class="separator:acce4adddb4d040bda3239840519b70e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73cdc08e502d9a140a625184526b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a73cdc08e502d9a140a625184526b89">execute_refinement</a> ()</td></tr>
<tr class="separator:a8a73cdc08e502d9a140a625184526b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01ec1d50a410f7cc29c543b212edefc"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> coarse_cell_id) const</td></tr>
<tr class="separator:af01ec1d50a410f7cc29c543b212edefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01ec1d50a410f7cc29c543b212edefc"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> coarse_cell_id) const</td></tr>
<tr class="separator:af01ec1d50a410f7cc29c543b212edefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef633762716a14deb9a4dcda02a26f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">coarse_cell_index_to_coarse_cell_id</a> (const unsigned <a class="el" href="classint.html">int</a> coarse_cell_index) const</td></tr>
<tr class="separator:a9ef633762716a14deb9a4dcda02a26f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef633762716a14deb9a4dcda02a26f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">coarse_cell_index_to_coarse_cell_id</a> (const unsigned <a class="el" href="classint.html">int</a> coarse_cell_index) const</td></tr>
<tr class="separator:a9ef633762716a14deb9a4dcda02a26f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mesh refinement</h2></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf55199c30b0330cf9bf98e2582078e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:abf55199c30b0330cf9bf98e2582078e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Information about the triangulation</h2></td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cc3b953d71fe4081fa8f88820f034"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">has_hanging_nodes</a> () const</td></tr>
<tr class="separator:a935cc3b953d71fe4081fa8f88820f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal information about the number of objects</h2></td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exceptions</h2></td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; of a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>, but this <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> &quot;&lt;&lt; &quot;that is only allowed if the <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> via &quot; &quot;<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:af9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:a20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions for internal use</h2></td></tr>
<tr class="memitem:a5977e64adfde9e63f274be77bb34dddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a5977e64adfde9e63f274be77bb34dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099dd8d123778fdadd882415d639d1b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a099dd8d123778fdadd882415d639d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7bc0b40113139b244a54591e9d53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> = typename IteratorSelector::raw_line_iterator</td></tr>
<tr class="separator:a0e0f7bc0b40113139b244a54591e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80735fd291dca4e5f958ee5876289aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> = typename IteratorSelector::raw_quad_iterator</td></tr>
<tr class="separator:a80735fd291dca4e5f958ee5876289aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be382ff40558d007dd767a1288dc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> = typename IteratorSelector::raw_hex_iterator</td></tr>
<tr class="separator:ac2be382ff40558d007dd767a1288dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a45bb19508b89ac6ed237b14bf7a506ef">begin_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cbfc1e5187c6ad0a47d1b616f9f5149">end_raw</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hex iterator functions for internal use</h2></td></tr>
<tr class="memitem:a26795906ff2742c5f2109113b79d6744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26795906ff2742c5f2109113b79d6744">begin_raw_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a26795906ff2742c5f2109113b79d6744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae764c732cc0de8322257d13912552b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae764c732cc0de8322257d13912552b8">begin_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:aae764c732cc0de8322257d13912552b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e876cdf1cdae06aa793cc5081b4fe31">begin_active_hex</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd003c8d0a9d5839488ee2ad1313703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aadd003c8d0a9d5839488ee2ad1313703">end_hex</a> () const</td></tr>
<tr class="separator:aadd003c8d0a9d5839488ee2ad1313703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c164ad82da9629eab01f90ef2a360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af42c164ad82da9629eab01f90ef2a360">reset_policy</a> ()</td></tr>
<tr class="separator:af42c164ad82da9629eab01f90ef2a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a365332f11d26e60c46a1f9bbb3e5e1c1">reset_active_cell_indices</a> ()</td></tr>
<tr class="separator:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76af9cf5bbd5811b3f6ee8ca03ac8df6">reset_cell_vertex_indices_cache</a> ()</td></tr>
<tr class="separator:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73cdc08e502d9a140a625184526b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a73cdc08e502d9a140a625184526b89">execute_refinement</a> ()</td></tr>
<tr class="separator:a8a73cdc08e502d9a140a625184526b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01ec1d50a410f7cc29c543b212edefc"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> coarse_cell_id) const</td></tr>
<tr class="separator:af01ec1d50a410f7cc29c543b212edefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef633762716a14deb9a4dcda02a26f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">coarse_cell_index_to_coarse_cell_id</a> (const unsigned <a class="el" href="classint.html">int</a> coarse_cell_index) const</td></tr>
<tr class="separator:a9ef633762716a14deb9a4dcda02a26f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</h3>

<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">is_parallel_distributed(const ::Triangulation&lt;dim,spacedim&gt; &amp;tria)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">dynamic_cast&lt;</span>const</div>
<div class="line">                  <a class="code" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase&lt;dim,spacedim&gt;</a>*<span class="keyword">&gt;</span></div>
<div class="line">                 (&amp;tria)</div>
<div class="line">     != <span class="keyword">nullptr</span>)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A base class for distributed triangulations, i.e., triangulations that do not store all cells on all processors. This implies that not every detail of a triangulation may be known on each processor. In particular, you have to expect that triangulations of classes derived from this one only store some of the active cells (namely, the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">locally owned cells</a>), along with <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a> and possibly <a class="el" href="DEALGlossary.html#GlossArtificialCell">artificial cells</a>. In contrast to the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, it is certain that the classes derived from the current class will not store the entire triangulation as long as it has a large enough number of cells. (The difference to <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> is that the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> is derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, but not from the current class.) The distinction is not large in practice: Everything that is difficult for parallel distributed triangulation is generally also difficult for any other kind of parallel triangulation classes; however, this intermediate base class allows to further differentiate between the different kinds of classes providing parallel mesh functionality.</p>
<p>This class can, then, be used to test whether a pointer or reference to a triangulation object refers to any kind of parallel triangulation, or whether the triangulation is in fact parallel distributed. In other words, one could write a function like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">is_parallel_distributed(const ::Triangulation&lt;dim,spacedim&gt; &amp;tria)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">dynamic_cast&lt;</span>const</div>
<div class="line">                  <a class="code" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase&lt;dim,spacedim&gt;</a>*<span class="keyword">&gt;</span></div>
<div class="line">                 (&amp;tria)</div>
<div class="line">     != <span class="keyword">nullptr</span>)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00414">414</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acb254bd3c238056d5c44627167944253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb254bd3c238056d5c44627167944253">&#9670;&nbsp;</a></span>cell_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00438">438</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a7c98433e1e221ee65731e81345a72546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c98433e1e221ee65731e81345a72546">&#9670;&nbsp;</a></span>CellStatus <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00441">441</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ae36be1617767da4972eb996d9325902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36be1617767da4972eb996d9325902f">&#9670;&nbsp;</a></span>cell_relation_t <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> =  typename std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary data structure for assigning a CellStatus to a deal.II cell iterator. For an extensive description of the former, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00691">691</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="acb254bd3c238056d5c44627167944253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb254bd3c238056d5c44627167944253">&#9670;&nbsp;</a></span>cell_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2distributed_2tria__base_8h_source.html#l00462">462</a> of file <a class="el" href="origin_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a7c98433e1e221ee65731e81345a72546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c98433e1e221ee65731e81345a72546">&#9670;&nbsp;</a></span>CellStatus <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2distributed_2tria__base_8h_source.html#l00465">465</a> of file <a class="el" href="origin_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ae36be1617767da4972eb996d9325902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36be1617767da4972eb996d9325902f">&#9670;&nbsp;</a></span>cell_relation_t <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> =  typename std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary data structure for assigning a CellStatus to a deal.II cell iterator. For an extensive description of the former, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p class="definition">Definition at line <a class="el" href="origin_2distributed_2tria__base_8h_source.html#l00701">701</a> of file <a class="el" href="origin_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="acb254bd3c238056d5c44627167944253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb254bd3c238056d5c44627167944253">&#9670;&nbsp;</a></span>cell_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2distributed_2tria__base_8h_source.html#l00438">438</a> of file <a class="el" href="translator_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a7c98433e1e221ee65731e81345a72546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c98433e1e221ee65731e81345a72546">&#9670;&nbsp;</a></span>CellStatus <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> =  typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2distributed_2tria__base_8h_source.html#l00441">441</a> of file <a class="el" href="translator_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ae36be1617767da4972eb996d9325902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36be1617767da4972eb996d9325902f">&#9670;&nbsp;</a></span>cell_relation_t <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> =  typename std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary data structure for assigning a CellStatus to a deal.II cell iterator. For an extensive description of the former, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p class="definition">Definition at line <a class="el" href="translator_2distributed_2tria__base_8h_source.html#l00691">691</a> of file <a class="el" href="translator_2distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ac6506c3f82279eed1dd2ee7f1ea66dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6506c3f82279eed1dd2ee7f1ea66dc7">&#9670;&nbsp;</a></span>IteratorSelector <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> =  ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal alias to make the definition of the iterator classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01042">1042</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac6506c3f82279eed1dd2ee7f1ea66dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6506c3f82279eed1dd2ee7f1ea66dc7">&#9670;&nbsp;</a></span>IteratorSelector <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> =  ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal alias to make the definition of the iterator classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l01129">1129</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac6506c3f82279eed1dd2ee7f1ea66dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6506c3f82279eed1dd2ee7f1ea66dc7">&#9670;&nbsp;</a></span>IteratorSelector <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> =  ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal alias to make the definition of the iterator classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l01042">1042</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01236">1236</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l01361">1361</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l01236">1236</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5977e64adfde9e63f274be77bb34dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5977e64adfde9e63f274be77bb34dddc">&#9670;&nbsp;</a></span>raw_cell_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles. Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03450">3450</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5977e64adfde9e63f274be77bb34dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5977e64adfde9e63f274be77bb34dddc">&#9670;&nbsp;</a></span>raw_cell_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles.</p>
<p>Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03609">3609</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5977e64adfde9e63f274be77bb34dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5977e64adfde9e63f274be77bb34dddc">&#9670;&nbsp;</a></span>raw_cell_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles. Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03450">3450</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad39637491c7d7e9f7bc4b7ea40a0d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39637491c7d7e9f7bc4b7ea40a0d72b">&#9670;&nbsp;</a></span>raw_face_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03452">3452</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad39637491c7d7e9f7bc4b7ea40a0d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39637491c7d7e9f7bc4b7ea40a0d72b">&#9670;&nbsp;</a></span>raw_face_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03611">3611</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad39637491c7d7e9f7bc4b7ea40a0d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39637491c7d7e9f7bc4b7ea40a0d72b">&#9670;&nbsp;</a></span>raw_face_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03452">3452</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a099dd8d123778fdadd882415d639d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099dd8d123778fdadd882415d639d1b4">&#9670;&nbsp;</a></span>raw_vertex_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03454">3454</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a099dd8d123778fdadd882415d639d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099dd8d123778fdadd882415d639d1b4">&#9670;&nbsp;</a></span>raw_vertex_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03613">3613</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a099dd8d123778fdadd882415d639d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099dd8d123778fdadd882415d639d1b4">&#9670;&nbsp;</a></span>raw_vertex_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03454">3454</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0e0f7bc0b40113139b244a54591e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7bc0b40113139b244a54591e9d53">&#9670;&nbsp;</a></span>raw_line_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> =  typename IteratorSelector::raw_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03455">3455</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0e0f7bc0b40113139b244a54591e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7bc0b40113139b244a54591e9d53">&#9670;&nbsp;</a></span>raw_line_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> =  typename IteratorSelector::raw_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03614">3614</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0e0f7bc0b40113139b244a54591e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7bc0b40113139b244a54591e9d53">&#9670;&nbsp;</a></span>raw_line_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> =  typename IteratorSelector::raw_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03455">3455</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a80735fd291dca4e5f958ee5876289aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80735fd291dca4e5f958ee5876289aa4">&#9670;&nbsp;</a></span>raw_quad_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> =  typename IteratorSelector::raw_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03456">3456</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a80735fd291dca4e5f958ee5876289aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80735fd291dca4e5f958ee5876289aa4">&#9670;&nbsp;</a></span>raw_quad_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> =  typename IteratorSelector::raw_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03615">3615</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a80735fd291dca4e5f958ee5876289aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80735fd291dca4e5f958ee5876289aa4">&#9670;&nbsp;</a></span>raw_quad_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> =  typename IteratorSelector::raw_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03456">3456</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac2be382ff40558d007dd767a1288dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be382ff40558d007dd767a1288dc1e">&#9670;&nbsp;</a></span>raw_hex_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> =  typename IteratorSelector::raw_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03457">3457</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac2be382ff40558d007dd767a1288dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be382ff40558d007dd767a1288dc1e">&#9670;&nbsp;</a></span>raw_hex_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> =  typename IteratorSelector::raw_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l03616">3616</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac2be382ff40558d007dd767a1288dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be382ff40558d007dd767a1288dc1e">&#9670;&nbsp;</a></span>raw_hex_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> =  typename IteratorSelector::raw_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l03457">3457</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01050">1050</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2grid_2tria_8h_source.html#l01136">1136</a> of file <a class="el" href="origin_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt=""/>
</div>
<p>It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aead167078e3ebf2d96e05ce6098e2baf8a">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea821cd647539c7343ff71eebba39e51cf">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea2150fa8c3dcff932d0140826b44772b0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened. The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea648fb5fd0611ce0a10c0692a80fd9127"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined. However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements. The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a> .</p>
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea18787ae7f5d8f0a67b8a1d9c3d51e472">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening). The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (&lsquo;chain reaction&rsquo;...). This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag. Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae63af337827ec8b60fed8ce7fbef4ab4"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea7497a6b2ae4564bccc513e8fa79da4e2">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeac1907e91bbef5ad7c5ac41d632a5e997"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aead4e195fce03509b8e873fc1c077199be"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2grid_2tria_8h_source.html#l01050">1050</a> of file <a class="el" href="translator_2grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a1a25af910eb1418cf9719953b0c330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1a25af910eb1418cf9719953b0c330">&#9670;&nbsp;</a></span>DistributedTriangulationBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html">DistributedTriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code>(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,&#160;spacedim&gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00663">663</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a6a1a25af910eb1418cf9719953b0c330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1a25af910eb1418cf9719953b0c330">&#9670;&nbsp;</a></span>DistributedTriangulationBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html">DistributedTriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code>(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="a6a1a25af910eb1418cf9719953b0c330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1a25af910eb1418cf9719953b0c330">&#9670;&nbsp;</a></span>DistributedTriangulationBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html">DistributedTriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code>(::<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea698da8b45beeca5fe6c563d265a30bce">none</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0f6c7f53d060c63005b005e7638d2219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6c7f53d060c63005b005e7638d2219">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data. Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00680">680</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ac958319402a5301d2dde94f1c6e8c78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac958319402a5301d2dde94f1c6e8c78a">&#9670;&nbsp;</a></span>save() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the triangulation into the given file. This file needs to be reachable from all nodes in the computation on a shared network file system. See the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class on how to store solution vectors into this file. Additional cell-based data can be saved using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#adcb26c6f27ccce2ec0468bf084392e16">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad5a7ad9fd72720414a8c983acee58142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a7ad9fd72720414a8c983acee58142">&#9670;&nbsp;</a></span>load() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>autopartition</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the triangulation saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> back in. Cell-based data that was saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> can be read in with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> after calling <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a93071279fd26cd54e8bc98e4fab8e399">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acb1a95528832932bf2fad380f8098367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a95528832932bf2fad380f8098367">&#9670;&nbsp;</a></span>register_data_attach() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>returns_variable_size_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a function that can be used to attach data of fixed size to cells. This is useful for two purposes: (i) Upon refinement and coarsening of a triangulation ( <em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation::execute_coarsening_and_refinement()</a>), one needs to be able to store one or more data vectors per cell that characterizes the solution values on the cell so that this data can then be transferred to the new owning processor of the cell (or its parent/children) when the mesh is re-partitioned; (ii) when serializing a computation to a file, it is necessary to attach data to cells so that it can be saved ( <em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a>) along with the cell's other information and, if necessary, later be reloaded from disk with a different subdivision of cells among the processors. The way this function works is that it allows any number of interest parties to register their intent to attach data to cells. One example of classes that do this is <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> where each <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object that works on the current <a class="el" href="classTriangulation.html">Triangulation</a> object then needs to register its intent. Each of these parties registers a callback function (the first argument here, <code>pack_callback</code>) that will be called whenever the triangulation's <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> functions are called. The current function then returns an integer handle that corresponds to the number of data set that the callback provided here will attach. While this number could be given a precise meaning, this is not important: You will never actually have to do anything with this number except return it to the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> function. In other words, each interested party (i.e., the caller of the current function) needs to store their respective returned handle for later use when unpacking data in the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>. Whenever <code>pack_callback</code> is then called by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> on a given cell, it receives a number of arguments. In particular, the first argument passed to the callback indicates the cell for which it is supposed to attach data. This is always an active cell. The second, CellStatus, argument provided to the callback function will tell you if the given cell will be coarsened, refined, or will persist as is. (This status may be different than the refinement or coarsening flags set on that cell, to accommodate things such as the "one hanging node per edge" rule.). These flags need to be read in context with the p4est quadrant they belong to, as their relations are gathered in local_cell_relations. Specifically, the values for this argument mean the following:</p>
<ul>
<li><code>CELL_PERSIST</code>: The cell won't be refined/coarsened, but might be moved to a different processor. If this is the case, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking wherever this cell may land.</li>
<li><code>CELL_REFINE</code>: This cell will be refined into 4 or 8 cells (in 2d and 3d, respectively). However, because these children don't exist yet, you cannot access them at the time when the callback is called. Thus, in local_cell_relations, the corresponding p4est quadrants of the children cells are linked to the deal.II cell which is going to be refined. To be specific, only the very first child is marked with <code>CELL_REFINE</code>, whereas the others will be marked with <code>CELL_INVALID</code>, which indicates that these cells will be ignored by default during the packing or unpacking process. This ensures that data is only transferred once onto or from the parent cell. If the callback is called with <code>CELL_REFINE</code>, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking in a way so that it can then be transferred to the children of the cell that will then be available. In other words, if the data the callback will want to pack up corresponds to a finite element field, then the prolongation from parent to (new) children will have to happen during unpacking.</li>
<li><code>CELL_COARSEN</code>: The children of this cell will be coarsened into the given cell. These children still exist, so if this is the value given to the callback as second argument, the callback will want to transfer data from the children to the current parent cell and pack it up so that it can later be unpacked again on a cell that then no longer has any children (and may also be located on a different processor). In other words, if the data the callback will want to pack up corresponds to a finite element field, then it will need to do the restriction from children to parent at this point.</li>
<li><code>CELL_INVALID</code>: See <code>CELL_REFINE</code>. <dl class="section note"><dt>Note</dt><dd>If this function is used for serialization of data using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>, then the cell status argument with which the callback is called will always be <code>CELL_PERSIST</code>. The callback function is expected to return a memory chunk of the format <code>std::vector&lt;char&gt;</code>, representing the packed data on a certain cell. The second parameter <code>returns_variable_size_data</code> indicates whether the returned size of the memory region from the callback function varies by cell (<code>=true</code>) or stays constant on each one throughout the whole domain (<code>=false</code>). </dd>
<dd>
The purpose of this function is to register intent to attach data for a single, subsequent call to <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. Consequently, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> all forget the registered callbacks once these callbacks have been called, and you will have to re-register them with a triangulation if you want them to be active for another call to these functions. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00763">763</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a6fbdf11dcfacd414a8936e6d26fecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdf11dcfacd414a8936e6d26fecb76">&#9670;&nbsp;</a></span>notify_ready_to_unpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the opposite of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. It is called <em>after</em> the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>/load() functions are done when classes and functions that have previously attached data to a triangulation for either transfer to other processors, across mesh refinement, or serialization of data to a file are ready to receive that data back. The important part about this process is that the triangulation cannot do this right away from the end of <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> via a previously attached callback function (as the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> function does) because the classes that eventually want the data back may need to do some setup between the point in time where the mesh has been recreated and when the data can actually be received. An example is the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class that can really only receive the data once not only the mesh is completely available again on the current processor, but only after a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been reinitialized and distributed degrees of freedom. In other words, there is typically a significant amount of set up that needs to happen in user space before the classes that can receive data attached to cell are ready to actually do so. When they are, they use the current function to tell the triangulation object that now is the time when they are ready by calling the current function. The supplied callback function is then called for each newly locally owned cell. The first argument to the callback is an iterator that designates the cell; the second argument indicates the status of the cell in question; and the third argument localizes a memory area by two iterators that contains the data that was previously saved from the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. The CellStatus will indicate if the cell was refined, coarsened, or persisted unchanged. The <code>cell_iterator</code> argument to the callback will then either be an active, locally owned cell (if the cell was not refined), or the immediate parent if it was refined during <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. Therefore, contrary to during <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>, you can now access the children if the status is <code>CELL_REFINE</code> but no longer for callbacks with status <code>CELL_COARSEN</code>. The first argument to this function, <code>handle</code>, corresponds to the return value of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. (The precise meaning of what the numeric value of this handle is supposed to represent is neither important, nor should you try to use it for anything other than transmit information between a call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> to the corresponding call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.) </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00792">792</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a53caa007ddc9229fa461a0fd925482ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53caa007ddc9229fa461a0fd925482ae">&#9670;&nbsp;</a></span>save_attached_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save additional cell-attached data into the given file. The first arguments are used to determine the offsets where to write buffers to. Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a> . </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00692">692</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="aeef794a63c63ff09e2c1c231998083f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef794a63c63ff09e2c1c231998083f2">&#9670;&nbsp;</a></span>load_attached_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>local_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load additional cell-attached data from the given file, if any was saved. The first arguments are used to determine the offsets where to read buffers from. Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a> . </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00728">728</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a74fe86d32d73e4c12d1e505739b3662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe86d32d73e4c12d1e505739b3662a">&#9670;&nbsp;</a></span>update_cell_relations() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::update_cell_relations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function to record the CellStatus of currently active cells that are locally owned. This information is mandatory to transfer data between meshes during adaptation or serialization, e.g., using <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>. Relations will be stored in the private member local_cell_relations. For an extensive description of CellStatus, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a1e1bad787089afe8c644dc4032c1a80c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af8b346b087dd89464415ecb7d2775a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b346b087dd89464415ecb7d2775a61">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ac958319402a5301d2dde94f1c6e8c78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac958319402a5301d2dde94f1c6e8c78a">&#9670;&nbsp;</a></span>save() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the triangulation into the given file. This file needs to be reachable from all nodes in the computation on a shared network file system. See the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class on how to store solution vectors into this file. Additional cell-based data can be saved using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#adcb26c6f27ccce2ec0468bf084392e16">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad5a7ad9fd72720414a8c983acee58142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a7ad9fd72720414a8c983acee58142">&#9670;&nbsp;</a></span>load() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>autopartition</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the triangulation saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> back in. Cell-based data that was saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> can be read in with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> after calling <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a93071279fd26cd54e8bc98e4fab8e399">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acb1a95528832932bf2fad380f8098367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a95528832932bf2fad380f8098367">&#9670;&nbsp;</a></span>register_data_attach() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>returns_variable_size_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a function that can be used to attach data of fixed size to cells. This is useful for two purposes: (i) Upon refinement and coarsening of a triangulation (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation::execute_coarsening_and_refinement()</a>), one needs to be able to store one or more data vectors per cell that characterizes the solution values on the cell so that this data can then be transferred to the new owning processor of the cell (or its parent/children) when the mesh is re-partitioned; (ii) when serializing a computation to a file, it is necessary to attach data to cells so that it can be saved (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a>) along with the cell's other information and, if necessary, later be reloaded from disk with a different subdivision of cells among the processors.</p>
<p>The way this function works is that it allows any number of interest parties to register their intent to attach data to cells. One example of classes that do this is <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> where each <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object that works on the current <a class="el" href="classTriangulation.html">Triangulation</a> object then needs to register its intent. Each of these parties registers a callback function (the first argument here, <code>pack_callback</code>) that will be called whenever the triangulation's <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> functions are called.</p>
<p>The current function then returns an integer handle that corresponds to the number of data set that the callback provided here will attach. While this number could be given a precise meaning, this is not important: You will never actually have to do anything with this number except return it to the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> function. In other words, each interested party (i.e., the caller of the current function) needs to store their respective returned handle for later use when unpacking data in the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.</p>
<p>Whenever <code>pack_callback</code> is then called by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> on a given cell, it receives a number of arguments. In particular, the first argument passed to the callback indicates the cell for which it is supposed to attach data. This is always an active cell.</p>
<p>The second, CellStatus, argument provided to the callback function will tell you if the given cell will be coarsened, refined, or will persist as is. (This status may be different than the refinement or coarsening flags set on that cell, to accommodate things such as the "one hanging node per edge" rule.). These flags need to be read in context with the p4est quadrant they belong to, as their relations are gathered in local_cell_relations.</p>
<p>Specifically, the values for this argument mean the following:</p>
<ul>
<li><code>CELL_PERSIST</code>: The cell won't be refined/coarsened, but might be moved to a different processor. If this is the case, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking wherever this cell may land.</li>
<li><code>CELL_REFINE</code>: This cell will be refined into 4 or 8 cells (in 2d and 3d, respectively). However, because these children don't exist yet, you cannot access them at the time when the callback is called. Thus, in local_cell_relations, the corresponding p4est quadrants of the children cells are linked to the deal.II cell which is going to be refined. To be specific, only the very first child is marked with <code>CELL_REFINE</code>, whereas the others will be marked with <code>CELL_INVALID</code>, which indicates that these cells will be ignored by default during the packing or unpacking process. This ensures that data is only transferred once onto or from the parent cell. If the callback is called with <code>CELL_REFINE</code>, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking in a way so that it can then be transferred to the children of the cell that will then be available. In other words, if the data the callback will want to pack up corresponds to a finite element field, then the prolongation from parent to (new) children will have to happen during unpacking.</li>
<li><code>CELL_COARSEN</code>: The children of this cell will be coarsened into the given cell. These children still exist, so if this is the value given to the callback as second argument, the callback will want to transfer data from the children to the current parent cell and pack it up so that it can later be unpacked again on a cell that then no longer has any children (and may also be located on a different processor). In other words, if the data the callback will want to pack up corresponds to a finite element field, then it will need to do the restriction from children to parent at this point.</li>
<li><code>CELL_INVALID</code>: See <code>CELL_REFINE</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If this function is used for serialization of data using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>, then the cell status argument with which the callback is called will always be <code>CELL_PERSIST</code>.</dd></dl>
<p>The callback function is expected to return a memory chunk of the format <code>std::vector&lt;char&gt;</code>, representing the packed data on a certain cell.</p>
<p>The second parameter <code>returns_variable_size_data</code> indicates whether the returned size of the memory region from the callback function varies by cell (<code>=true</code>) or stays constant on each one throughout the whole domain (<code>=false</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The purpose of this function is to register intent to attach data for a single, subsequent call to <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. Consequently, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> all forget the registered callbacks once these callbacks have been called, and you will have to re-register them with a triangulation if you want them to be active for another call to these functions. </dd></dl>

</div>
</div>
<a id="a6fbdf11dcfacd414a8936e6d26fecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdf11dcfacd414a8936e6d26fecb76">&#9670;&nbsp;</a></span>notify_ready_to_unpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the opposite of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. It is called <em>after</em> the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>/load() functions are done when classes and functions that have previously attached data to a triangulation for either transfer to other processors, across mesh refinement, or serialization of data to a file are ready to receive that data back. The important part about this process is that the triangulation cannot do this right away from the end of <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> via a previously attached callback function (as the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> function does) because the classes that eventually want the data back may need to do some setup between the point in time where the mesh has been recreated and when the data can actually be received. An example is the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class that can really only receive the data once not only the mesh is completely available again on the current processor, but only after a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been reinitialized and distributed degrees of freedom. In other words, there is typically a significant amount of set up that needs to happen in user space before the classes that can receive data attached to cell are ready to actually do so. When they are, they use the current function to tell the triangulation object that now is the time when they are ready by calling the current function.</p>
<p>The supplied callback function is then called for each newly locally owned cell. The first argument to the callback is an iterator that designates the cell; the second argument indicates the status of the cell in question; and the third argument localizes a memory area by two iterators that contains the data that was previously saved from the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>.</p>
<p>The CellStatus will indicate if the cell was refined, coarsened, or persisted unchanged. The <code>cell_iterator</code> argument to the callback will then either be an active, locally owned cell (if the cell was not refined), or the immediate parent if it was refined during <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. Therefore, contrary to during <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>, you can now access the children if the status is <code>CELL_REFINE</code> but no longer for callbacks with status <code>CELL_COARSEN</code>.</p>
<p>The first argument to this function, <code>handle</code>, corresponds to the return value of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. (The precise meaning of what the numeric value of this handle is supposed to represent is neither important, nor should you try to use it for anything other than transmit information between a call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> to the corresponding call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.) </p>

</div>
</div>
<a id="a53caa007ddc9229fa461a0fd925482ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53caa007ddc9229fa461a0fd925482ae">&#9670;&nbsp;</a></span>save_attached_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save additional cell-attached data into the given file. The first arguments are used to determine the offsets where to write buffers to.</p>
<p>Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a>. </p>

</div>
</div>
<a id="aeef794a63c63ff09e2c1c231998083f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef794a63c63ff09e2c1c231998083f2">&#9670;&nbsp;</a></span>load_attached_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>local_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load additional cell-attached data from the given file, if any was saved. The first arguments are used to determine the offsets where to read buffers from.</p>
<p>Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a>. </p>

</div>
</div>
<a id="a74fe86d32d73e4c12d1e505739b3662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe86d32d73e4c12d1e505739b3662a">&#9670;&nbsp;</a></span>update_cell_relations() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::update_cell_relations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function to record the CellStatus of currently active cells that are locally owned. This information is mandatory to transfer data between meshes during adaptation or serialization, e.g., using <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>.</p>
<p>Relations will be stored in the private member local_cell_relations. For an extensive description of CellStatus, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a1e1bad787089afe8c644dc4032c1a80c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af8b346b087dd89464415ecb7d2775a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b346b087dd89464415ecb7d2775a61">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data. Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ac958319402a5301d2dde94f1c6e8c78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac958319402a5301d2dde94f1c6e8c78a">&#9670;&nbsp;</a></span>save() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the triangulation into the given file. This file needs to be reachable from all nodes in the computation on a shared network file system. See the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class on how to store solution vectors into this file. Additional cell-based data can be saved using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#adcb26c6f27ccce2ec0468bf084392e16">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9186695f01421cb4795f79fb5e4f515c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a8f278fed90462d4727a4842365e46bd2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad5a7ad9fd72720414a8c983acee58142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a7ad9fd72720414a8c983acee58142">&#9670;&nbsp;</a></span>load() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>autopartition</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the triangulation saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> back in. Cell-based data that was saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> can be read in with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> after calling <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a93071279fd26cd54e8bc98e4fab8e399">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad50f706f68cd03c4cdd8604d41e19f2e">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1f5797d8abcb7dade785134171be27d1">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acb1a95528832932bf2fad380f8098367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a95528832932bf2fad380f8098367">&#9670;&nbsp;</a></span>register_data_attach() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>returns_variable_size_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a function that can be used to attach data of fixed size to cells. This is useful for two purposes: (i) Upon refinement and coarsening of a triangulation ( <em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation::execute_coarsening_and_refinement()</a>), one needs to be able to store one or more data vectors per cell that characterizes the solution values on the cell so that this data can then be transferred to the new owning processor of the cell (or its parent/children) when the mesh is re-partitioned; (ii) when serializing a computation to a file, it is necessary to attach data to cells so that it can be saved ( <em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a>) along with the cell's other information and, if necessary, later be reloaded from disk with a different subdivision of cells among the processors. The way this function works is that it allows any number of interest parties to register their intent to attach data to cells. One example of classes that do this is <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> where each <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object that works on the current <a class="el" href="classTriangulation.html">Triangulation</a> object then needs to register its intent. Each of these parties registers a callback function (the first argument here, <code>pack_callback</code>) that will be called whenever the triangulation's <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> functions are called. The current function then returns an integer handle that corresponds to the number of data set that the callback provided here will attach. While this number could be given a precise meaning, this is not important: You will never actually have to do anything with this number except return it to the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> function. In other words, each interested party (i.e., the caller of the current function) needs to store their respective returned handle for later use when unpacking data in the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>. Whenever <code>pack_callback</code> is then called by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> on a given cell, it receives a number of arguments. In particular, the first argument passed to the callback indicates the cell for which it is supposed to attach data. This is always an active cell. The second, CellStatus, argument provided to the callback function will tell you if the given cell will be coarsened, refined, or will persist as is. (This status may be different than the refinement or coarsening flags set on that cell, to accommodate things such as the "one hanging node per edge" rule.). These flags need to be read in context with the p4est quadrant they belong to, as their relations are gathered in local_cell_relations. Specifically, the values for this argument mean the following:</p>
<ul>
<li><code>CELL_PERSIST</code>: The cell won't be refined/coarsened, but might be moved to a different processor. If this is the case, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking wherever this cell may land.</li>
<li><code>CELL_REFINE</code>: This cell will be refined into 4 or 8 cells (in 2d and 3d, respectively). However, because these children don't exist yet, you cannot access them at the time when the callback is called. Thus, in local_cell_relations, the corresponding p4est quadrants of the children cells are linked to the deal.II cell which is going to be refined. To be specific, only the very first child is marked with <code>CELL_REFINE</code>, whereas the others will be marked with <code>CELL_INVALID</code>, which indicates that these cells will be ignored by default during the packing or unpacking process. This ensures that data is only transferred once onto or from the parent cell. If the callback is called with <code>CELL_REFINE</code>, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking in a way so that it can then be transferred to the children of the cell that will then be available. In other words, if the data the callback will want to pack up corresponds to a finite element field, then the prolongation from parent to (new) children will have to happen during unpacking.</li>
<li><code>CELL_COARSEN</code>: The children of this cell will be coarsened into the given cell. These children still exist, so if this is the value given to the callback as second argument, the callback will want to transfer data from the children to the current parent cell and pack it up so that it can later be unpacked again on a cell that then no longer has any children (and may also be located on a different processor). In other words, if the data the callback will want to pack up corresponds to a finite element field, then it will need to do the restriction from children to parent at this point.</li>
<li><code>CELL_INVALID</code>: See <code>CELL_REFINE</code>. <dl class="section note"><dt>Note</dt><dd>If this function is used for serialization of data using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>, then the cell status argument with which the callback is called will always be <code>CELL_PERSIST</code>. The callback function is expected to return a memory chunk of the format <code>std::vector&lt;char&gt;</code>, representing the packed data on a certain cell. The second parameter <code>returns_variable_size_data</code> indicates whether the returned size of the memory region from the callback function varies by cell (<code>=true</code>) or stays constant on each one throughout the whole domain (<code>=false</code>). </dd>
<dd>
The purpose of this function is to register intent to attach data for a single, subsequent call to <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a>. Consequently, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>, and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> all forget the registered callbacks once these callbacks have been called, and you will have to re-register them with a triangulation if you want them to be active for another call to these functions. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a6fbdf11dcfacd414a8936e6d26fecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdf11dcfacd414a8936e6d26fecb76">&#9670;&nbsp;</a></span>notify_ready_to_unpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the opposite of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. It is called <em>after</em> the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save()</a>/load() functions are done when classes and functions that have previously attached data to a triangulation for either transfer to other processors, across mesh refinement, or serialization of data to a file are ready to receive that data back. The important part about this process is that the triangulation cannot do this right away from the end of <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load()</a> via a previously attached callback function (as the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> function does) because the classes that eventually want the data back may need to do some setup between the point in time where the mesh has been recreated and when the data can actually be received. An example is the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class that can really only receive the data once not only the mesh is completely available again on the current processor, but only after a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been reinitialized and distributed degrees of freedom. In other words, there is typically a significant amount of set up that needs to happen in user space before the classes that can receive data attached to cell are ready to actually do so. When they are, they use the current function to tell the triangulation object that now is the time when they are ready by calling the current function. The supplied callback function is then called for each newly locally owned cell. The first argument to the callback is an iterator that designates the cell; the second argument indicates the status of the cell in question; and the third argument localizes a memory area by two iterators that contains the data that was previously saved from the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. The CellStatus will indicate if the cell was refined, coarsened, or persisted unchanged. The <code>cell_iterator</code> argument to the callback will then either be an active, locally owned cell (if the cell was not refined), or the immediate parent if it was refined during <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. Therefore, contrary to during <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>, you can now access the children if the status is <code>CELL_REFINE</code> but no longer for callbacks with status <code>CELL_COARSEN</code>. The first argument to this function, <code>handle</code>, corresponds to the return value of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. (The precise meaning of what the numeric value of this handle is supposed to represent is neither important, nor should you try to use it for anything other than transmit information between a call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> to the corresponding call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.) </p>

</div>
</div>
<a id="a53caa007ddc9229fa461a0fd925482ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53caa007ddc9229fa461a0fd925482ae">&#9670;&nbsp;</a></span>save_attached_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save additional cell-attached data into the given file. The first arguments are used to determine the offsets where to write buffers to. Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">save</a> . </p>

</div>
</div>
<a id="aeef794a63c63ff09e2c1c231998083f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef794a63c63ff09e2c1c231998083f2">&#9670;&nbsp;</a></span>load_attached_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>local_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load additional cell-attached data from the given file, if any was saved. The first arguments are used to determine the offsets where to read buffers from. Called by <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">load</a> . </p>

</div>
</div>
<a id="a74fe86d32d73e4c12d1e505739b3662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe86d32d73e4c12d1e505739b3662a">&#9670;&nbsp;</a></span>update_cell_relations() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::update_cell_relations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function to record the CellStatus of currently active cells that are locally owned. This information is mandatory to transfer data between meshes during adaptation or serialization, e.g., using <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>. Relations will be stored in the private member local_cell_relations. For an extensive description of CellStatus, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a1e1bad787089afe8c644dc4032c1a80c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad131df81fdfddf64a5e4c5d75e96166b">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abda848d8b4b084e20428beaa488dbc63">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad6e42ca28e9e64c2f292c7cf5d6cb4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e42ca28e9e64c2f292c7cf5d6cb4e5">&#9670;&nbsp;</a></span>get_communicator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00140">140</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a77b606a3f26f71603f7759dc16d33db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b606a3f26f71603f7759dc16d33db9">&#9670;&nbsp;</a></span>get_communicator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. </p>

</div>
</div>
<a id="a77b606a3f26f71603f7759dc16d33db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b606a3f26f71603f7759dc16d33db9">&#9670;&nbsp;</a></span>get_communicator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. </p>

</div>
</div>
<a id="a0a2bf98c3056379a2b132ad62266f780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2bf98c3056379a2b132ad62266f780">&#9670;&nbsp;</a></span>get_communicator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. In the case of a serial <a class="el" href="classTriangulation.html">Triangulation</a> object, MPI_COMM_SELF is returned. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10124">10124</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8f9bfda5524458e6fb8ebe54e9c491fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9bfda5524458e6fb8ebe54e9c491fc">&#9670;&nbsp;</a></span>is_multilevel_hierarchy_constructed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::is_multilevel_hierarchy_constructed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if multilevel hierarchy is supported and has been constructed. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#adbf502e5250d2fbd03f9681cfd12c355">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="a8f9bfda5524458e6fb8ebe54e9c491fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9bfda5524458e6fb8ebe54e9c491fc">&#9670;&nbsp;</a></span>is_multilevel_hierarchy_constructed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::is_multilevel_hierarchy_constructed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if multilevel hierarchy is supported and has been constructed. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#adbf502e5250d2fbd03f9681cfd12c355">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="a8f9bfda5524458e6fb8ebe54e9c491fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9bfda5524458e6fb8ebe54e9c491fc">&#9670;&nbsp;</a></span>is_multilevel_hierarchy_constructed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::is_multilevel_hierarchy_constructed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if multilevel hierarchy is supported and has been constructed. </p>

<p>Implemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#adbf502e5250d2fbd03f9681cfd12c355">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="afcc11d84b1e73511844762ad8c111053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc11d84b1e73511844762ad8c111053">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class. </p><dl class="section note"><dt>Note</dt><dd>This function copies the cells, but not the communicator, of the source triangulation. In other words, the resulting triangulation will operate on the communicator it was constructed with. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a32dee27541d4a63c275046f6e4bdec3b">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00065">65</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a7ba82cc28f325167d0950150e23cf037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba82cc28f325167d0950150e23cf037">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class.</p>
<dl class="section note"><dt>Note</dt><dd>This function copies the cells, but not the communicator, of the source triangulation. In other words, the resulting triangulation will operate on the communicator it was constructed with. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a32dee27541d4a63c275046f6e4bdec3b">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="a7ba82cc28f325167d0950150e23cf037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba82cc28f325167d0950150e23cf037">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class. </p><dl class="section note"><dt>Note</dt><dd>This function copies the cells, but not the communicator, of the source triangulation. In other words, the resulting triangulation will operate on the communicator it was constructed with. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a32dee27541d4a63c275046f6e4bdec3b">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="a1f2bf1d34aacdba358add7fd59b32822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2bf1d34aacdba358add7fd59b32822">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy <code>other_tria</code> to this triangulation. This operation is not cheap, so you should be careful with using this. We do not implement this function as a copy constructor, since it makes it easier to maintain collections of triangulations if you can assign them values later on. Keep in mind that this function also copies the pointer to the boundary descriptor previously set by the <code>set_manifold</code> function. You must therefore also guarantee that the <a class="el" href="classManifold.html">Manifold</a> objects describing the boundary have a lifetime at least as long as the copied triangulation. This triangulation must be empty beforehand. The function is made <code>virtual</code> since some derived classes might want to disable or extend the functionality of this function. </p><dl class="section note"><dt>Note</dt><dd>Calling this function triggers the 'copy' signal on other_tria, i.e. the triangulation being copied <em>from</em>. It also triggers the 'create' signal of the current triangulation. See the section on signals in the general documentation for more information. </dd>
<dd>
The list of connections to signals is not copied from the old to the new triangulation since these connections were established to monitor how the old triangulation changes, not how any triangulation it may be copied to changes. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#ae37332be2f3fab7e7299c75a9bb5b95f">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a62d8ee4421ec25e3408f15613a7a9b3f">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a62d8ee4421ec25e3408f15613a7a9b3f">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10335">10335</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a74e904416671ca175093274144e49439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e904416671ca175093274144e49439">&#9670;&nbsp;</a></span>n_locally_owned_active_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_locally_owned_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of active cells in the triangulation that are locally owned, i.e. that have a subdomain_id equal to <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a>. Note that there may be more active cells in the triangulation stored on the present processor, such as for example ghost cells, or cells further away from the locally owned block of cells but that are needed to ensure that the triangulation that stores this processor's set of active cells still remains balanced with respect to the 2:1 size ratio of adjacent cells. As a consequence of the remark above, the result of this function is always smaller or equal to the result of the function with the same name in the <a class="el" href="classTriangulation.html">Triangulation</a> base class, which includes the active ghost and artificial cells (see also <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a> ). </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00119">119</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a74e904416671ca175093274144e49439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e904416671ca175093274144e49439">&#9670;&nbsp;</a></span>n_locally_owned_active_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_locally_owned_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of active cells in the triangulation that are locally owned, i.e. that have a subdomain_id equal to <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a>. Note that there may be more active cells in the triangulation stored on the present processor, such as for example ghost cells, or cells further away from the locally owned block of cells but that are needed to ensure that the triangulation that stores this processor's set of active cells still remains balanced with respect to the 2:1 size ratio of adjacent cells.</p>
<p>As a consequence of the remark above, the result of this function is always smaller or equal to the result of the function with the same name in the <a class="el" href="classTriangulation.html">Triangulation</a> base class, which includes the active ghost and artificial cells (see also <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). </p>

</div>
</div>
<a id="a74e904416671ca175093274144e49439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e904416671ca175093274144e49439">&#9670;&nbsp;</a></span>n_locally_owned_active_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_locally_owned_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of active cells in the triangulation that are locally owned, i.e. that have a subdomain_id equal to <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a>. Note that there may be more active cells in the triangulation stored on the present processor, such as for example ghost cells, or cells further away from the locally owned block of cells but that are needed to ensure that the triangulation that stores this processor's set of active cells still remains balanced with respect to the 2:1 size ratio of adjacent cells. As a consequence of the remark above, the result of this function is always smaller or equal to the result of the function with the same name in the <a class="el" href="classTriangulation.html">Triangulation</a> base class, which includes the active ghost and artificial cells (see also <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a> ). </p>

</div>
</div>
<a id="a0fedf8c5b9488f5f82dfbe3d04c3bc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fedf8c5b9488f5f82dfbe3d04c3bc0f">&#9670;&nbsp;</a></span>n_global_active_cells() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum over all processors of the number of active cells owned by each processor. This equals the overall number of active cells in the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00133">133</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a46548d5ed479030dbc75d8fbb2b68d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46548d5ed479030dbc75d8fbb2b68d11">&#9670;&nbsp;</a></span>n_global_active_cells() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum over all processors of the number of active cells owned by each processor. This equals the overall number of active cells in the triangulation. </p>

</div>
</div>
<a id="a46548d5ed479030dbc75d8fbb2b68d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46548d5ed479030dbc75d8fbb2b68d11">&#9670;&nbsp;</a></span>n_global_active_cells() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum over all processors of the number of active cells owned by each processor. This equals the overall number of active cells in the triangulation. </p>

</div>
</div>
<a id="a584733c8499dbd140694bfe04e0963ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584733c8499dbd140694bfe04e0963ca">&#9670;&nbsp;</a></span>n_global_active_cells() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae14ceee29a2b3250216bf79a5c1c565c">types::global_cell_index</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. For the current class, this is the same as <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells()</a>. However, the function may be overloaded in derived classes (e.g., in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>) where it may return a value greater than the number of active cells reported by the triangulation object on the current processor. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12652">12652</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a0ad3703ebbac4468e07b74c3ca595747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad3703ebbac4468e07b74c3ca595747">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption in bytes. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af3462af3709c558b158e3a1abba439ad">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00090">90</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ad8baa2e614b9868460a7a0f3cbc6d3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8baa2e614b9868460a7a0f3cbc6d3de">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption in bytes. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af3462af3709c558b158e3a1abba439ad">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="ad8baa2e614b9868460a7a0f3cbc6d3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8baa2e614b9868460a7a0f3cbc6d3de">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption in bytes. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af3462af3709c558b158e3a1abba439ad">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>.</p>

</div>
</div>
<a id="a141e0408c89056ac6e179fc363f3d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141e0408c89056ac6e179fc363f3d63e">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. This function is made virtual, since a triangulation object might be accessed through a pointer to this base class, even if the actual object is a derived class. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af3462af3709c558b158e3a1abba439ad">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l15188">15188</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5e6247bd25858eeed99445f2eb810b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6247bd25858eeed99445f2eb810b9c">&#9670;&nbsp;</a></span>n_global_levels() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global maximum level. This may be bigger than the number <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">Triangulation::n_levels()</a> (a function in this class's base class) returns if the current processor only stores cells in parts of the domain that are not very refined, but if other processors store cells in more deeply refined parts of the domain. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00126">126</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ab94c22b8116e1b5f4284ae01b221a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94c22b8116e1b5f4284ae01b221a2e2">&#9670;&nbsp;</a></span>n_global_levels() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global maximum level. This may be bigger than the number <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">Triangulation::n_levels()</a> (a function in this class's base class) returns if the current processor only stores cells in parts of the domain that are not very refined, but if other processors store cells in more deeply refined parts of the domain. </p>

</div>
</div>
<a id="ab94c22b8116e1b5f4284ae01b221a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94c22b8116e1b5f4284ae01b221a2e2">&#9670;&nbsp;</a></span>n_global_levels() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global maximum level. This may be bigger than the number <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">Triangulation::n_levels()</a> (a function in this class's base class) returns if the current processor only stores cells in parts of the domain that are not very refined, but if other processors store cells in more deeply refined parts of the domain. </p>

</div>
</div>
<a id="aafd960d483675c4eb2c538529350e56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd960d483675c4eb2c538529350e56b">&#9670;&nbsp;</a></span>n_global_levels() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in use. This function is equivalent to <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> for a serial <a class="el" href="classTriangulation.html">Triangulation</a>, but gives the maximum of <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> over all processors for a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and therefore can be larger than <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </p>

</div>
</div>
<a id="a41b129156d89f37482d2095de5751d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b129156d89f37482d2095de5751d9c">&#9670;&nbsp;</a></span>locally_owned_subdomain() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::locally_owned_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the subdomain id of those cells that are owned by the current processor. All cells in the triangulation that do not have this subdomain id are either owned by another processor or have children that only exist on other processors. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00320">320</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a41b129156d89f37482d2095de5751d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b129156d89f37482d2095de5751d9c">&#9670;&nbsp;</a></span>locally_owned_subdomain() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::locally_owned_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the subdomain id of those cells that are owned by the current processor. All cells in the triangulation that do not have this subdomain id are either owned by another processor or have children that only exist on other processors. </p>

</div>
</div>
<a id="a41b129156d89f37482d2095de5751d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b129156d89f37482d2095de5751d9c">&#9670;&nbsp;</a></span>locally_owned_subdomain() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::locally_owned_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the subdomain id of those cells that are owned by the current processor. All cells in the triangulation that do not have this subdomain id are either owned by another processor or have children that only exist on other processors. </p>

</div>
</div>
<a id="a44ea82a097d8317c98fa422307aff874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ea82a097d8317c98fa422307aff874">&#9670;&nbsp;</a></span>locally_owned_subdomain() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::locally_owned_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function always returns <code>invalid_subdomain_id</code> but is there for compatibility with the derived <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code> class. For distributed parallel triangulations this function returns the subdomain id of those cells that are owned by the current processor. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13256">13256</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a182d26a19ae0d8cf91473a647f381364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d26a19ae0d8cf91473a647f381364">&#9670;&nbsp;</a></span>ghost_owners() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one ghost cell adjacent to the cells of the local processor. In other words, this is the set of <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">subdomain_id()</a> for all ghost cells. The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00329">329</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a5e24708aa6563bf529cd8a10ca0cbe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e24708aa6563bf529cd8a10ca0cbe12">&#9670;&nbsp;</a></span>ghost_owners() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one ghost cell adjacent to the cells of the local processor. In other words, this is the set of <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">subdomain_id()</a> for all ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p>

</div>
</div>
<a id="a5e24708aa6563bf529cd8a10ca0cbe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e24708aa6563bf529cd8a10ca0cbe12">&#9670;&nbsp;</a></span>ghost_owners() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one ghost cell adjacent to the cells of the local processor. In other words, this is the set of <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">subdomain_id()</a> for all ghost cells. The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p>

</div>
</div>
<a id="a08420b1432082185edaaf83dbc8b4bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08420b1432082185edaaf83dbc8b4bee">&#9670;&nbsp;</a></span>level_ghost_owners() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::level_ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one level ghost cell adjacent to our cells used in geometric multigrid. In other words, this is the set of level_subdomain_id() for all level ghost cells. The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p><dl class="section note"><dt>Note</dt><dd>The level ghost owners can only be determined if the multigrid ownership has been assigned (by setting the construct_multigrid_hierarchy flag at construction time), otherwise the returned set will be empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00338">338</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="abff00f28a17583c0316af55b04b139e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff00f28a17583c0316af55b04b139e3">&#9670;&nbsp;</a></span>level_ghost_owners() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::level_ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one level ghost cell adjacent to our cells used in geometric multigrid. In other words, this is the set of level_subdomain_id() for all level ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The level ghost owners can only be determined if the multigrid ownership has been assigned (by setting the construct_multigrid_hierarchy flag at construction time), otherwise the returned set will be empty. </dd></dl>

</div>
</div>
<a id="abff00f28a17583c0316af55b04b139e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff00f28a17583c0316af55b04b139e3">&#9670;&nbsp;</a></span>level_ghost_owners() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::level_ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one level ghost cell adjacent to our cells used in geometric multigrid. In other words, this is the set of level_subdomain_id() for all level ghost cells. The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p><dl class="section note"><dt>Note</dt><dd>The level ghost owners can only be determined if the multigrid ownership has been assigned (by setting the construct_multigrid_hierarchy flag at construction time), otherwise the returned set will be empty. </dd></dl>

</div>
</div>
<a id="abe6d84acdf8908f48fb236e2c2d47a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6d84acdf8908f48fb236e2c2d47a17">&#9670;&nbsp;</a></span>global_active_cell_index_partitioner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_active_cell_index_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the active level of the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00644">644</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a640568c9b7f4b50cf45b5c52a8420b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640568c9b7f4b50cf45b5c52a8420b05">&#9670;&nbsp;</a></span>global_active_cell_index_partitioner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_active_cell_index_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the active level of the triangulation. </p>

</div>
</div>
<a id="a640568c9b7f4b50cf45b5c52a8420b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640568c9b7f4b50cf45b5c52a8420b05">&#9670;&nbsp;</a></span>global_active_cell_index_partitioner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_active_cell_index_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the active level of the triangulation. </p>

</div>
</div>
<a id="a3160e66fd9d88da46c47ce55524d656f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3160e66fd9d88da46c47ce55524d656f">&#9670;&nbsp;</a></span>global_level_cell_index_partitioner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_level_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the given <code>level</code> of the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00651">651</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a8513533c19e088ed8303ea50198b9920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8513533c19e088ed8303ea50198b9920">&#9670;&nbsp;</a></span>global_level_cell_index_partitioner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_level_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the given <code>level</code> of the triangulation. </p>

</div>
</div>
<a id="a8513533c19e088ed8303ea50198b9920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8513533c19e088ed8303ea50198b9920">&#9670;&nbsp;</a></span>global_level_cell_index_partitioner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_level_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the given <code>level</code> of the triangulation. </p>

</div>
</div>
<a id="a7f0952d4737bd402994bc398cfa64a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0952d4737bd402994bc398cfa64a25">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::compute_vertices_with_ghost_neighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a map that, for each vertex, lists all the processors whose subdomains are adjacent to that vertex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__manifold.html#ga7f6d5b53684824212c789514167fd326">GridTools::compute_vertices_with_ghost_neighbors()</a> instead of <a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">parallel::TriangulationBase::compute_vertices_with_ghost_neighbors()</a>.</dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00347">347</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a1ba526138718ef72dc1593c16e2cca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba526138718ef72dc1593c16e2cca7b">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt; &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::compute_vertices_with_ghost_neighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a map that, for each vertex, lists all the processors whose subdomains are adjacent to that vertex.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000108">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__manifold.html#ga7f6d5b53684824212c789514167fd326">GridTools::compute_vertices_with_ghost_neighbors()</a> instead of <a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">parallel::TriangulationBase::compute_vertices_with_ghost_neighbors()</a>. </dd></dl>

</div>
</div>
<a id="a1ba526138718ef72dc1593c16e2cca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba526138718ef72dc1593c16e2cca7b">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&gt; &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::compute_vertices_with_ghost_neighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a map that, for each vertex, lists all the processors whose subdomains are adjacent to that vertex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000205">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__manifold.html#ga7f6d5b53684824212c789514167fd326">GridTools::compute_vertices_with_ghost_neighbors()</a> instead of <a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">parallel::TriangulationBase::compute_vertices_with_ghost_neighbors()</a>.</dd></dl>

</div>
</div>
<a id="a668fa9fc088a3986cfaefe328d6d2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668fa9fc088a3986cfaefe328d6d2f25">&#9670;&nbsp;</a></span>get_boundary_ids() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    " </p><dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00357">357</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a1e1acf0c97fceec538c4552ee300213c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1acf0c97fceec538c4552ee300213c">&#9670;&nbsp;</a></span>get_boundary_ids() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    "</p>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

</div>
</div>
<a id="a1e1acf0c97fceec538c4552ee300213c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1acf0c97fceec538c4552ee300213c">&#9670;&nbsp;</a></span>get_boundary_ids() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    " </p><dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

</div>
</div>
<a id="a63a0d3cc6653496e5bebf32220ac4160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a0d3cc6653496e5bebf32220ac4160">&#9670;&nbsp;</a></span>get_boundary_ids() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    " </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10282">10282</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af04b7e2c65169692ae8805a085c2f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04b7e2c65169692ae8805a085c2f7ca">&#9670;&nbsp;</a></span>get_manifold_ids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_manifold_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classTriangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    " </p><dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00368">368</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a51f63aebdfa85dc769c1503c00670a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f63aebdfa85dc769c1503c00670a7e">&#9670;&nbsp;</a></span>get_manifold_ids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_manifold_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classTriangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    "</p>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

</div>
</div>
<a id="a51f63aebdfa85dc769c1503c00670a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f63aebdfa85dc769c1503c00670a7e">&#9670;&nbsp;</a></span>get_manifold_ids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_manifold_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classTriangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one). @ @ "    " </p><dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

</div>
</div>
<a id="ad63df2c11257f1e6fb482e4f9ea4589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63df2c11257f1e6fb482e4f9ea4589f">&#9670;&nbsp;</a></span>communicate_locally_moved_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::communicate_locally_moved_vertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_locally_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When vertices have been moved locally, for example using code like </p><div class="fragment"><div class="line">cell-&gt;vertex(0) = new_location;</div>
</div><!-- fragment --><p> then this function can be used to update the location of vertices between MPI processes. All the vertices that have been moved and might be in the ghost layer of a process have to be reported in the <code>vertex_locally_moved</code> argument. This ensures that that part of the information that has to be send between processes is actually sent. Additionally, it is quite important that vertices on the boundary between processes are reported on exactly one process (e.g. the one with the highest id). Otherwise we could expect undesirable results if multiple processes move a vertex differently. A typical strategy is to let processor \(i\) move those vertices that are adjacent to cells whose owners include processor \(i\) but no other processor \(j\) with \(j&lt;i\) ; in other words, for vertices at the boundary of a subdomain, the processor with the lowest subdomain id "owns" a vertex. </p><dl class="section note"><dt>Note</dt><dd>It only makes sense to move vertices that are either located on locally owned cells or on cells in the ghost layer. This is because you can be sure that these vertices indeed exist on the finest mesh aggregated over all processors, whereas vertices on artificial cells but not at least in the ghost layer may or may not exist on the globally finest mesh. Consequently, the <code>vertex_locally_moved</code> argument may not contain vertices that aren't at least on ghost cells. </dd>
<dd>
This function moves vertices in such a way that on every processor, the vertices of every locally owned and ghost cell is consistent with the corresponding location of these cells on other processors. On the other hand, the locations of artificial cells will in general be wrong since artificial cells may or may not exist on other processors and consequently it is not possible to determine their location in any way. This is not usually a problem since one never does anything on artificial cells. However, it may lead to problems if the mesh with moved vertices is refined in a later step. If that's what you want to do, the right way to do it is to save the offset applied to every vertex, call this function, and before refining or coarsening the mesh apply the opposite offset and call this function again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_locally_moved</td><td>A bitmap indicating which vertices have been moved. The size of this array must be equal to <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> and must be a subset of those vertices flagged by <a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">GridTools::get_locally_owned_vertices()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>This function is used, for example, in <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00594">594</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ad63df2c11257f1e6fb482e4f9ea4589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63df2c11257f1e6fb482e4f9ea4589f">&#9670;&nbsp;</a></span>communicate_locally_moved_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::communicate_locally_moved_vertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_locally_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When vertices have been moved locally, for example using code like </p><div class="fragment"><div class="line">cell-&gt;vertex(0) = new_location;</div>
</div><!-- fragment --><p> then this function can be used to update the location of vertices between MPI processes.</p>
<p>All the vertices that have been moved and might be in the ghost layer of a process have to be reported in the <code>vertex_locally_moved</code> argument. This ensures that that part of the information that has to be send between processes is actually sent. Additionally, it is quite important that vertices on the boundary between processes are reported on exactly one process (e.g. the one with the highest id). Otherwise we could expect undesirable results if multiple processes move a vertex differently. A typical strategy is to let processor \(i\) move those vertices that are adjacent to cells whose owners include processor \(i\) but no other processor \(j\) with \(j&lt;i\); in other words, for vertices at the boundary of a subdomain, the processor with the lowest subdomain id "owns" a vertex.</p>
<dl class="section note"><dt>Note</dt><dd>It only makes sense to move vertices that are either located on locally owned cells or on cells in the ghost layer. This is because you can be sure that these vertices indeed exist on the finest mesh aggregated over all processors, whereas vertices on artificial cells but not at least in the ghost layer may or may not exist on the globally finest mesh. Consequently, the <code>vertex_locally_moved</code> argument may not contain vertices that aren't at least on ghost cells.</dd>
<dd>
This function moves vertices in such a way that on every processor, the vertices of every locally owned and ghost cell is consistent with the corresponding location of these cells on other processors. On the other hand, the locations of artificial cells will in general be wrong since artificial cells may or may not exist on other processors and consequently it is not possible to determine their location in any way. This is not usually a problem since one never does anything on artificial cells. However, it may lead to problems if the mesh with moved vertices is refined in a later step. If that's what you want to do, the right way to do it is to save the offset applied to every vertex, call this function, and before refining or coarsening the mesh apply the opposite offset and call this function again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_locally_moved</td><td>A bitmap indicating which vertices have been moved. The size of this array must be equal to <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> and must be a subset of those vertices flagged by <a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">GridTools::get_locally_owned_vertices()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>This function is used, for example, in <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>. </dd></dl>

</div>
</div>
<a id="ad63df2c11257f1e6fb482e4f9ea4589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63df2c11257f1e6fb482e4f9ea4589f">&#9670;&nbsp;</a></span>communicate_locally_moved_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::communicate_locally_moved_vertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_locally_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When vertices have been moved locally, for example using code like </p><div class="fragment"><div class="line">cell-&gt;vertex(0) = new_location;</div>
</div><!-- fragment --><p> then this function can be used to update the location of vertices between MPI processes. All the vertices that have been moved and might be in the ghost layer of a process have to be reported in the <code>vertex_locally_moved</code> argument. This ensures that that part of the information that has to be send between processes is actually sent. Additionally, it is quite important that vertices on the boundary between processes are reported on exactly one process (e.g. the one with the highest id). Otherwise we could expect undesirable results if multiple processes move a vertex differently. A typical strategy is to let processor \(i\) move those vertices that are adjacent to cells whose owners include processor \(i\) but no other processor \(j\) with \(j&lt;i\) ; in other words, for vertices at the boundary of a subdomain, the processor with the lowest subdomain id "owns" a vertex. </p><dl class="section note"><dt>Note</dt><dd>It only makes sense to move vertices that are either located on locally owned cells or on cells in the ghost layer. This is because you can be sure that these vertices indeed exist on the finest mesh aggregated over all processors, whereas vertices on artificial cells but not at least in the ghost layer may or may not exist on the globally finest mesh. Consequently, the <code>vertex_locally_moved</code> argument may not contain vertices that aren't at least on ghost cells. </dd>
<dd>
This function moves vertices in such a way that on every processor, the vertices of every locally owned and ghost cell is consistent with the corresponding location of these cells on other processors. On the other hand, the locations of artificial cells will in general be wrong since artificial cells may or may not exist on other processors and consequently it is not possible to determine their location in any way. This is not usually a problem since one never does anything on artificial cells. However, it may lead to problems if the mesh with moved vertices is refined in a later step. If that's what you want to do, the right way to do it is to save the offset applied to every vertex, call this function, and before refining or coarsening the mesh apply the opposite offset and call this function again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_locally_moved</td><td>A bitmap indicating which vertices have been moved. The size of this array must be equal to <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> and must be a subset of those vertices flagged by <a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">GridTools::get_locally_owned_vertices()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>This function is used, for example, in <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>. </dd></dl>

</div>
</div>
<a id="a95e5944f1ce4588d3215ae5b63c503e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e5944f1ce4588d3215ae5b63c503e0">&#9670;&nbsp;</a></span>update_number_cache() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the number_cache variable after mesh creation or refinement. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00148">148</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ab5164a6fb30048f0ce5e81f67b60285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5164a6fb30048f0ce5e81f67b60285f">&#9670;&nbsp;</a></span>update_number_cache() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the number_cache variable after mesh creation or refinement. </p>

</div>
</div>
<a id="ab5164a6fb30048f0ce5e81f67b60285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5164a6fb30048f0ce5e81f67b60285f">&#9670;&nbsp;</a></span>update_number_cache() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the number_cache variable after mesh creation or refinement. </p>

</div>
</div>
<a id="a10cf6c4bfa4a3d00d8c76792d1b9872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cf6c4bfa4a3d00d8c76792d1b9872a">&#9670;&nbsp;</a></span>update_reference_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Update the internal reference_cells vector. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a700a1e92c8e08c3765a603b04834c0eb">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00293">293</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a10cf6c4bfa4a3d00d8c76792d1b9872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cf6c4bfa4a3d00d8c76792d1b9872a">&#9670;&nbsp;</a></span>update_reference_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Update the internal reference_cells vector. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a700a1e92c8e08c3765a603b04834c0eb">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a10cf6c4bfa4a3d00d8c76792d1b9872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cf6c4bfa4a3d00d8c76792d1b9872a">&#9670;&nbsp;</a></span>update_reference_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Update the internal reference_cells vector. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a700a1e92c8e08c3765a603b04834c0eb">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="adac35d252ab3fcbcdc675d6ac526b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac35d252ab3fcbcdc675d6ac526b24c">&#9670;&nbsp;</a></span>reset_global_cell_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::reset_global_cell_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global active cell indices and global level cell indices. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00379">379</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="adac35d252ab3fcbcdc675d6ac526b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac35d252ab3fcbcdc675d6ac526b24c">&#9670;&nbsp;</a></span>reset_global_cell_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::reset_global_cell_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global active cell indices and global level cell indices. </p>

</div>
</div>
<a id="adac35d252ab3fcbcdc675d6ac526b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac35d252ab3fcbcdc675d6ac526b24c">&#9670;&nbsp;</a></span>reset_global_cell_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::reset_global_cell_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global active cell indices and global level cell indices. </p>

</div>
</div>
<a id="a672f6e3ed2cc4377f804f0cdc4e19dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672f6e3ed2cc4377f804f0cdc4e19dd6">&#9670;&nbsp;</a></span>set_mesh_smoothing() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10133">10133</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a444acc0f6dd7a7fed2c657921a643800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444acc0f6dd7a7fed2c657921a643800">&#9670;&nbsp;</a></span>get_mesh_smoothing() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10145">10145</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="ga9f9d720f5fbdcdf3dcbb445feefbdb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">&#9670;&nbsp;</a></span>set_manifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a manifold object to a certain part of the triangulation. If an object with manifold number <code>number</code> is refined, this object is used to find the location of new vertices (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>A copy of <code>manifold_object</code> is created using <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt;dim, spacedim&gt;::clone()</a> and stored internally.</p>
<p>It is possible to remove or replace a <a class="el" href="classManifold.html">Manifold</a> object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a manifold object is done by <a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold()</a>. This operation then replaces the manifold object given before by a straight manifold approximation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga9f9d720f5fbdcdf3dcbb445feefbdb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">&#9670;&nbsp;</a></span>set_manifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a manifold object to a certain part of the triangulation. If an object with manifold number <code>number</code> is refined, this object is used to find the location of new vertices (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations. A copy of <code>manifold_object</code> is created using <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt;dim,   spacedim&gt;::clone()</a> and stored internally. It is possible to remove or replace a <a class="el" href="classManifold.html">Manifold</a> object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a manifold object is done by <a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold()</a>. This operation then replaces the manifold object given before by a straight manifold approximation. @ @ "    " </p>

</div>
</div>
<a id="ga644a2152b8f5a6902afdc503d163d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644a2152b8f5a6902afdc503d163d950">&#9670;&nbsp;</a></span>reset_manifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset those parts of the triangulation with the given <code>manifold_number</code> to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This is the default state of a non-curved triangulation, and undoes assignment of a different <a class="el" href="classManifold.html">Manifold</a> object by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga644a2152b8f5a6902afdc503d163d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644a2152b8f5a6902afdc503d163d950">&#9670;&nbsp;</a></span>reset_manifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset those parts of the triangulation with the given <code>manifold_number</code> to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This is the default state of a non-curved triangulation, and undoes assignment of a different <a class="el" href="classManifold.html">Manifold</a> object by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>. @ @ "    " </p>

</div>
</div>
<a id="gaaacb68636e7fc0b399310e570a4d7dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacb68636e7fc0b399310e570a4d7dd6">&#9670;&nbsp;</a></span>reset_all_manifolds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_all_manifolds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset all parts of the triangulation, regardless of their manifold_id, to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This undoes assignment of all <a class="el" href="classManifold.html">Manifold</a> objects by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaaacb68636e7fc0b399310e570a4d7dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacb68636e7fc0b399310e570a4d7dd6">&#9670;&nbsp;</a></span>reset_all_manifolds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_all_manifolds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset all parts of the triangulation, regardless of their manifold_id, to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This undoes assignment of all <a class="el" href="classManifold.html">Manifold</a> objects by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>. @ @ "    " </p>

</div>
</div>
<a id="gae2acfbef517fd03855c4b371f3e182f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2acfbef517fd03855c4b371f3e182f7">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all cells and faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gae2acfbef517fd03855c4b371f3e182f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2acfbef517fd03855c4b371f3e182f7">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all cells and faces to the given argument. @ @ "    " </p>

</div>
</div>
<a id="ga1f1ea841946c94c079388ecf9ad2c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1ea841946c94c079388ecf9ad2c00c">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaa4e0af28512cb5f9cc8cb3b95a38c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e0af28512cb5f9cc8cb3b95a38c669">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces and edges with given boundary_id <code>b_id</code> to the given manifold_id <code>number</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga1f1ea841946c94c079388ecf9ad2c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1ea841946c94c079388ecf9ad2c00c">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces to the given argument. @ @ "    " </p>

</div>
</div>
<a id="gaa4e0af28512cb5f9cc8cb3b95a38c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e0af28512cb5f9cc8cb3b95a38c669">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces and edges with given boundary_id <code>b_id</code> to the given manifold_id <code>number</code>. @ @ "    " </p>

</div>
</div>
<a id="ga2131fc63fb23e2e7eabb570b1e852e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2131fc63fb23e2e7eabb570b1e852e4a">&#9670;&nbsp;</a></span>get_manifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to a <a class="el" href="classManifold.html">Manifold</a> object used for this triangulation. <code>number</code> is the same as in <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If no manifold could be found, the default flat manifold is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga2131fc63fb23e2e7eabb570b1e852e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2131fc63fb23e2e7eabb570b1e852e4a">&#9670;&nbsp;</a></span>get_manifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to a <a class="el" href="classManifold.html">Manifold</a> object used for this triangulation. <code>number</code> is the same as in <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a>. </p><dl class="section note"><dt>Note</dt><dd>If no manifold could be found, the default flat manifold is returned. @ @ "    " </dd></dl>

</div>
</div>
<a id="ab2eeef6a38fa053814433870a9c35a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eeef6a38fa053814433870a9c35a0c">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise. <dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_19.html">step-19</a> . </dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>. </dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>
</li>
</ul>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a2500bed9b06d583cf45ec08b3030176c">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10446">10446</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af7accd2c69ad73912e4198443f186a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7accd2c69ad73912e4198443f186a5e">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from the provided <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>. </p><dl class="section note"><dt>Note</dt><dd>Don't forget to attach the manifolds with <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a> before calling this function if manifolds are needed. </dd>
<dd>
The namespace <a class="el" href="namespaceTriangulationDescription_1_1Utilities.html">TriangulationDescription::Utilities</a> contains functions to create <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">construction_data</td><td>The data needed for this process. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aac4d2ddacfa33d03341c12c9417e18bb">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10632">10632</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1b191fa3249c9c3641492b6eedebf456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b191fa3249c9c3641492b6eedebf456">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.). The result of calling this function is a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>.</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind DistortedCellList. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_19.html">step-19</a>.</dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a2500bed9b06d583cf45ec08b3030176c">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa80c37d5d647831736e40e4ffb0e0ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c37d5d647831736e40e4ffb0e0ee2">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from the provided <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Don't forget to attach the manifolds with <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a> before calling this function if manifolds are needed.</dd>
<dd>
The namespace <a class="el" href="namespaceTriangulationDescription_1_1Utilities.html">TriangulationDescription::Utilities</a> contains functions to create <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">construction_data</td><td>The data needed for this process. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aac4d2ddacfa33d03341c12c9417e18bb">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1b191fa3249c9c3641492b6eedebf456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b191fa3249c9c3641492b6eedebf456">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise. <dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_19.html">step-19</a> . </dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>. </dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>
</li>
</ul>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a2500bed9b06d583cf45ec08b3030176c">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa80c37d5d647831736e40e4ffb0e0ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c37d5d647831736e40e4ffb0e0ee2">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from the provided <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>. </p><dl class="section note"><dt>Note</dt><dd>Don't forget to attach the manifolds with <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a> before calling this function if manifolds are needed. </dd>
<dd>
The namespace <a class="el" href="namespaceTriangulationDescription_1_1Utilities.html">TriangulationDescription::Utilities</a> contains functions to create <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">construction_data</td><td>The data needed for this process. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aac4d2ddacfa33d03341c12c9417e18bb">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ada18f9251ebb60ac0200eafeeddb78c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada18f9251ebb60ac0200eafeeddb78c5">&#9670;&nbsp;</a></span>create_triangulation_compatibility() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a>. </p><dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#a6b899ec3d023c5ef02e574bf353db05b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10401">10401</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abbbee6e665998c3e4a745cd7836df364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbee6e665998c3e4a745cd7836df364">&#9670;&nbsp;</a></span>create_triangulation_compatibility() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#a6b899ec3d023c5ef02e574bf353db05b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abbbee6e665998c3e4a745cd7836df364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbee6e665998c3e4a745cd7836df364">&#9670;&nbsp;</a></span>create_triangulation_compatibility() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a>. </p><dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#a6b899ec3d023c5ef02e574bf353db05b">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> . This function throws an exception if dim equals spacedim. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10753">10753</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>.</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> . This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10765">10765</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\) . The <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10781">10781</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\).</p>
<p>The <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\) . The <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times. In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10794">10794</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times.</p>
<p>In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times. In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ac8b4fbb207303ec7f5ef758821ecd8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4fbb207303ec7f5ef758821ecd8cb">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute both refinement and coarsening of the triangulation. The function resets all refinement and coarsening flags to false. It uses the user flags for internal purposes. They will therefore be overwritten by undefined content. To allow user programs to fix up these cells if that is desired, this function after completing all other work may throw an exception of type DistortedCellList that contains a list of those cells that have been refined and have at least one child that is distorted. The function does not create such an exception if no cells have created distorted children. Note that for the check for distorted cells to happen, the <code>check_for_distorted_cells</code> flag has to be specified upon creation of a triangulation object. See the general docs for more information. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing its work. See the section on signals in the general documentation of this class. </dd>
<dd>
If the boundary description is sufficiently irregular, it can happen that some of the children produced by mesh refinement are distorted (see the extensive discussion on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>). </dd>
<dd>
This function is <code>virtual</code> to allow derived classes to insert hooks, such as saving refinement flags and the like (see e.g. the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> class). </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aec12e88eafa064447a0813bad8258bca">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13312">13312</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaedd900205c1879d8d9ef6ffe7d1a554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedd900205c1879d8d9ef6ffe7d1a554">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute both refinement and coarsening of the triangulation.</p>
<p>The function resets all refinement and coarsening flags to false. It uses the user flags for internal purposes. They will therefore be overwritten by undefined content.</p>
<p>To allow user programs to fix up these cells if that is desired, this function after completing all other work may throw an exception of type DistortedCellList that contains a list of those cells that have been refined and have at least one child that is distorted. The function does not create such an exception if no cells have created distorted children. Note that for the check for distorted cells to happen, the <code>check_for_distorted_cells</code> flag has to be specified upon creation of a triangulation object.</p>
<p>See the general docs for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing its work. See the section on signals in the general documentation of this class.</dd>
<dd>
If the boundary description is sufficiently irregular, it can happen that some of the children produced by mesh refinement are distorted (see the extensive discussion on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>).</dd>
<dd>
This function is <code>virtual</code> to allow derived classes to insert hooks, such as saving refinement flags and the like (see e.g. the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> class). </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aec12e88eafa064447a0813bad8258bca">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aaedd900205c1879d8d9ef6ffe7d1a554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedd900205c1879d8d9ef6ffe7d1a554">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute both refinement and coarsening of the triangulation. The function resets all refinement and coarsening flags to false. It uses the user flags for internal purposes. They will therefore be overwritten by undefined content. To allow user programs to fix up these cells if that is desired, this function after completing all other work may throw an exception of type DistortedCellList that contains a list of those cells that have been refined and have at least one child that is distorted. The function does not create such an exception if no cells have created distorted children. Note that for the check for distorted cells to happen, the <code>check_for_distorted_cells</code> flag has to be specified upon creation of a triangulation object. See the general docs for more information. </p><dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing its work. See the section on signals in the general documentation of this class. </dd>
<dd>
If the boundary description is sufficiently irregular, it can happen that some of the children produced by mesh refinement are distorted (see the extensive discussion on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>). </dd>
<dd>
This function is <code>virtual</code> to allow derived classes to insert hooks, such as saving refinement flags and the like (see e.g. the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> class). </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#aec12e88eafa064447a0813bad8258bca">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab9fa3177e0e43ab0cf243215d284a35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fa3177e0e43ab0cf243215d284a35a">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing. Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement. See the general doc of this class for more information on smoothing upon refinement. Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc. The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged. The function returns whether some cells' flagging has been changed in the process. This function uses the user flags, so store them if you still need them afterwards. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l14102">14102</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abf55199c30b0330cf9bf98e2582078e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf55199c30b0330cf9bf98e2582078e1">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing.</p>
<p>Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement.</p>
<p>See the general doc of this class for more information on smoothing upon refinement.</p>
<p>Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc.</p>
<p>The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged.</p>
<p>The function returns whether some cells' flagging has been changed in the process.</p>
<p>This function uses the user flags, so store them if you still need them afterwards. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abf55199c30b0330cf9bf98e2582078e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf55199c30b0330cf9bf98e2582078e1">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing. Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement. See the general doc of this class for more information on smoothing upon refinement. Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc. The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged. The function returns whether some cells' flagging has been changed in the process. This function uses the user flags, so store them if you still need them afterwards. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a77387c20bfe3e8fbe76ed7bbedeb3258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77387c20bfe3e8fbe76ed7bbedeb3258">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13859">13859</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a9451a3cba24ac884dad5337be35286d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9451a3cba24ac884dad5337be35286d1">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13878">13878</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8d94fc740577f178189d939e09486b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d94fc740577f178189d939e09486b79">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13897">13897</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10831">10831</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10814">10814</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10845">10845</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10856">10856</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10900">10900</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10883">10883</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10914">10914</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10928">10928</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10948">10948</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11119">11119</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11130">11130</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11148">11148</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11179">11179</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11197">11197</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11030">11030</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11249">11249</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11234">11234</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11263">11263</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11277">11277</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11070">11070</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11372">11372</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11353">11353</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11386">11386</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11400">11400</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11110">11110</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11441">11441</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11422">11422</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a></p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11455">11455</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11469">11469</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10991">10991</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11491">11491</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11523">11523</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="abcc8b79020416280c10e4ccde2ee8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc8b79020416280c10e4ccde2ee8454">&#9670;&nbsp;</a></span>save_user_pointers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11747">11747</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abcc8b79020416280c10e4ccde2ee8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc8b79020416280c10e4ccde2ee8454">&#9670;&nbsp;</a></span>save_user_pointers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abcc8b79020416280c10e4ccde2ee8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc8b79020416280c10e4ccde2ee8454">&#9670;&nbsp;</a></span>save_user_pointers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a8087e84b3b755bcb31767c574342ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087e84b3b755bcb31767c574342ac0a">&#9670;&nbsp;</a></span>load_user_pointers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#abcc8b79020416280c10e4ccde2ee8454">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11778">11778</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8087e84b3b755bcb31767c574342ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087e84b3b755bcb31767c574342ac0a">&#9670;&nbsp;</a></span>load_user_pointers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#abcc8b79020416280c10e4ccde2ee8454">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8087e84b3b755bcb31767c574342ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087e84b3b755bcb31767c574342ac0a">&#9670;&nbsp;</a></span>load_user_pointers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#abcc8b79020416280c10e4ccde2ee8454">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11603">11603</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11617">11617</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11631">11631</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11649">11649</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11666">11666</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11684">11684</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a42e0bbc9eac6e707667dad2fe528c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e0bbc9eac6e707667dad2fe528c178">&#9670;&nbsp;</a></span>save_user_pointers_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11815">11815</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a42e0bbc9eac6e707667dad2fe528c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e0bbc9eac6e707667dad2fe528c178">&#9670;&nbsp;</a></span>save_user_pointers_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a42e0bbc9eac6e707667dad2fe528c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e0bbc9eac6e707667dad2fe528c178">&#9670;&nbsp;</a></span>save_user_pointers_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="aab55095dab9f1be46f088d6d29d016ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55095dab9f1be46f088d6d29d016ba">&#9670;&nbsp;</a></span>load_user_pointers_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11829">11829</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aab55095dab9f1be46f088d6d29d016ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55095dab9f1be46f088d6d29d016ba">&#9670;&nbsp;</a></span>load_user_pointers_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="aab55095dab9f1be46f088d6d29d016ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55095dab9f1be46f088d6d29d016ba">&#9670;&nbsp;</a></span>load_user_pointers_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a1d1157e5796770a8997fb722b6621921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1157e5796770a8997fb722b6621921">&#9670;&nbsp;</a></span>save_user_pointers_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11844">11844</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1d1157e5796770a8997fb722b6621921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1157e5796770a8997fb722b6621921">&#9670;&nbsp;</a></span>save_user_pointers_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1d1157e5796770a8997fb722b6621921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1157e5796770a8997fb722b6621921">&#9670;&nbsp;</a></span>save_user_pointers_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a6fadda245a0bef85ae6b957d6154a884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fadda245a0bef85ae6b957d6154a884">&#9670;&nbsp;</a></span>load_user_pointers_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11862">11862</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a6fadda245a0bef85ae6b957d6154a884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fadda245a0bef85ae6b957d6154a884">&#9670;&nbsp;</a></span>load_user_pointers_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a6fadda245a0bef85ae6b957d6154a884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fadda245a0bef85ae6b957d6154a884">&#9670;&nbsp;</a></span>load_user_pointers_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a7d8a16ce49cd4b12a65e5fde012b38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8a16ce49cd4b12a65e5fde012b38e6">&#9670;&nbsp;</a></span>save_user_pointers_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11879">11879</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7d8a16ce49cd4b12a65e5fde012b38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8a16ce49cd4b12a65e5fde012b38e6">&#9670;&nbsp;</a></span>save_user_pointers_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7d8a16ce49cd4b12a65e5fde012b38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8a16ce49cd4b12a65e5fde012b38e6">&#9670;&nbsp;</a></span>save_user_pointers_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="a8e9198f6d3a8dedb19db011e99903863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9198f6d3a8dedb19db011e99903863">&#9670;&nbsp;</a></span>load_user_pointers_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11897">11897</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8e9198f6d3a8dedb19db011e99903863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9198f6d3a8dedb19db011e99903863">&#9670;&nbsp;</a></span>load_user_pointers_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8e9198f6d3a8dedb19db011e99903863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9198f6d3a8dedb19db011e99903863">&#9670;&nbsp;</a></span>load_user_pointers_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a id="ae4bd2787b33fb53f9ba3d18dc81efa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bd2787b33fb53f9ba3d18dc81efa2d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11938">11938</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a9388e821c728eab8d0e699d0ca112482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9388e821c728eab8d0e699d0ca112482">&#9670;&nbsp;</a></span>begin_active() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     cell!=tria.end_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     ++cell)</div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11958">11958</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     cell!=tria.end_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     ++cell)</div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     cell!=tria.end_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     ++cell)</div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afdbd22694fb7591e822577a8f8a90de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbd22694fb7591e822577a8f8a90de9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12049">12049</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a18e972554cd983b4771284f5ab674ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e972554cd983b4771284f5ab674ec0">&#9670;&nbsp;</a></span>end() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12089">12089</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab78be6b63b91b6e4be3ff252b93502f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78be6b63b91b6e4be3ff252b93502f5">&#9670;&nbsp;</a></span>end_active() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12118">12118</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a1a8e886767303b776351e42658e454c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8e886767303b776351e42658e454c0">&#9670;&nbsp;</a></span>last() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11978">11978</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="ae5ffe405f6f0c86d5d9e66e4d761e123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ffe405f6f0c86d5d9e66e4d761e123">&#9670;&nbsp;</a></span>last_active() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12003">12003</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a8e9110402bf44868c370b537e0be51e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9110402bf44868c370b537e0be51e8">&#9670;&nbsp;</a></span>create_cell_iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classTriangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object. If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12024">12024</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classTriangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object.</p>
<p>If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classTriangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object. If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="a984fd41d16b98b2cc294b6c02be749e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984fd41d16b98b2cc294b6c02be749e6">&#9670;&nbsp;</a></span>begin_face() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12191">12191</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="a0ee2e715fcc37e080dcda8d0592bfac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee2e715fcc37e080dcda8d0592bfac8">&#9670;&nbsp;</a></span>begin_active_face() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12212">12212</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="a06c3cfd3c53bb076d841f5acab6e3165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c3cfd3c53bb076d841f5acab6e3165">&#9670;&nbsp;</a></span>end_face() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12233">12233</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">&#9670;&nbsp;</a></span>active_face_iterators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active faces that make up this triangulation. This function is the face version of <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>, and allows one to write code like, e.g.,</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>;</div>
<div class="line">...</div>
<div class="line">for (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_face_iterators())</div>
<div class="line">  face-&gt;set_manifold_id(42);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#a0ee2e715fcc37e080dcda8d0592bfac8">begin_active_face()</a>, this-&gt;<a class="el" href="classTriangulation.html#a06c3cfd3c53bb076d841f5acab6e3165">end_face()</a>)</code> </dd></dl>

</div>
</div>
<a id="ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">&#9670;&nbsp;</a></span>active_face_iterators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active faces that make up this triangulation. This function is the face version of <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>, and allows one to write code like, e.g., </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>;</div>
<div class="line">...</div>
<div class="line">for (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_face_iterators())</div>
<div class="line">  face-&gt;set_manifold_id(42);</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#a0ee2e715fcc37e080dcda8d0592bfac8">begin_active_face()</a>, this-&gt;<a class="el" href="classTriangulation.html#a06c3cfd3c53bb076d841f5acab6e3165">end_face()</a>)</code> </dd></dl>

</div>
</div>
<a id="accd5b4e70bf81894b68f2ccccbb88beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd5b4e70bf81894b68f2ccccbb88beb">&#9670;&nbsp;</a></span>begin_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12266">12266</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="ac9087fcf06d41d13a739ae592c257f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9087fcf06d41d13a739ae592c257f1a">&#9670;&nbsp;</a></span>begin_active_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#accd5b4e70bf81894b68f2ccccbb88beb">begin_vertex()</a> and <a class="el" href="classTriangulation.html#ac9087fcf06d41d13a739ae592c257f1a">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12283">12283</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#accd5b4e70bf81894b68f2ccccbb88beb">begin_vertex()</a> and <a class="el" href="classTriangulation.html#ac9087fcf06d41d13a739ae592c257f1a">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#accd5b4e70bf81894b68f2ccccbb88beb">begin_vertex()</a> and <a class="el" href="classTriangulation.html#ac9087fcf06d41d13a739ae592c257f1a">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a3f2d301f656e50a8fb72a96a9df020fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2d301f656e50a8fb72a96a9df020fe">&#9670;&nbsp;</a></span>end_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12293">12293</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12789">12789</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12827">12827</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12837">12837</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12845">12845</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13002">13002</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13010">13010</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a79f664cd903c4a7d36cfcf59edf77d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f664cd903c4a7d36cfcf59edf77d23">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12856">12856</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a68e9cf2d0847dfc5fac2d9d9c39917ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e9cf2d0847dfc5fac2d9d9c39917ad">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12864">12864</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afa43cc09475a962c64cf81b66bbc6063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa43cc09475a962c64cf81b66bbc6063">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12905">12905</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab5f759946225da01083c7788aba9a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f759946225da01083c7788aba9a51a">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12913">12913</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a94898f00b04cdd9f446b2781d7c0dcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94898f00b04cdd9f446b2781d7c0dcc8">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12953">12953</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ae0b2538b067fac8ad5c6e5f8bf8fae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2538b067fac8ad5c6e5f8bf8fae06">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12961">12961</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13069">13069</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13077">13077</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a05dfabc61a0635b5f0448e645e7944f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dfabc61a0635b5f0448e645e7944f4">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12888">12888</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab9bb2a1aef23adff709c2fa112bfe870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bb2a1aef23adff709c2fa112bfe870">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12896">12896</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7a33c09d9402a8425583058d7f9d44ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a33c09d9402a8425583058d7f9d44ce">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12937">12937</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a80e29455eadbe8231a65da04eb0567d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e29455eadbe8231a65da04eb0567d6">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12945">12945</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2f45d56e9d6679fcd0f8d793a5ecb891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f45d56e9d6679fcd0f8d793a5ecb891">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12985">12985</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a40ff5c5e5aadf633944e2e6c7c7c7767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff5c5e5aadf633944e2e6c7c7c7767">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12993">12993</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13088">13088</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13097">13097</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ac0d198aebd80535ad593e5133a8812ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d198aebd80535ad593e5133a8812ee">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13131">13131</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af2699445c877451375c6128d44c90c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2699445c877451375c6128d44c90c9e">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13140">13140</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13114">13114</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13123">13123</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a23fef4d5635144af728710f4e2783902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fef4d5635144af728710f4e2783902">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13160">13160</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a04d8b81ff513c945250ddff5c6df54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d8b81ff513c945250ddff5c6df54cd">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13169">13169</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12637">12637</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12738">12738</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12645">12645</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12758">12758</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12661">12661</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12699">12699</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation. </p><dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think</dd></dl>
<ul>
<li>for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero</li>
<li>making the number of levels equal to one.) </li>
</ul>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think &ndash; for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero &ndash; making the number of levels equal to one.) </dd></dl>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation. </p><dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think</dd></dl>
<ul>
<li>for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero</li>
<li>making the number of levels equal to one.) </li>
</ul>

</div>
</div>
<a id="af18ca78a1810d5dcdd214a56d9518025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18ca78a1810d5dcdd214a56d9518025">&#9670;&nbsp;</a></span>has_hanging_nodes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes. The function is made virtual since the result can be interpreted in different ways, depending on whether the triangulation lives only on a single processor, or may be distributed as done in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see there for a description of what the function is supposed to do in the parallel context). </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a11677987ca8ad5bcc4ab77e8916dcc62">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12777">12777</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a935cc3b953d71fe4081fa8f88820f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cc3b953d71fe4081fa8f88820f034">&#9670;&nbsp;</a></span>has_hanging_nodes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes.</p>
<p>The function is made virtual since the result can be interpreted in different ways, depending on whether the triangulation lives only on a single processor, or may be distributed as done in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see there for a description of what the function is supposed to do in the parallel context). </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a11677987ca8ad5bcc4ab77e8916dcc62">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a935cc3b953d71fe4081fa8f88820f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cc3b953d71fe4081fa8f88820f034">&#9670;&nbsp;</a></span>has_hanging_nodes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes. The function is made virtual since the result can be interpreted in different ways, depending on whether the triangulation lives only on a single processor, or may be distributed as done in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see there for a description of what the function is supposed to do in the parallel context). </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a11677987ca8ad5bcc4ab77e8916dcc62">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">get_used_vertices()</a>. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">get_used_vertices()</a>. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">get_used_vertices()</a>. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13180">13180</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="ac0e5de61b90fd6b9ee1bf02bfc355085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e5de61b90fd6b9ee1bf02bfc355085">&#9670;&nbsp;</a></span>get_used_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13189">13189</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined. In one space dimension, two is returned. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13223">13223</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined. In one space dimension, two is returned. </p>

</div>
</div>
<a id="a5d6e3826a32b12684e8e4ff94a23a648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e3826a32b12684e8e4ff94a23a648">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13198">13198</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa4b710ab15cf74994c3f33e4f4d17e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b710ab15cf74994c3f33e4f4d17e95">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13207">13207</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a3a107913a2a6858ec87704accdff065f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a107913a2a6858ec87704accdff065f">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13215">13215</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="adc17a0a6b88aaba602e9888fce580b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc17a0a6b88aaba602e9888fce580b0c">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13265">13265</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object.</p>
<p>This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12813">12813</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12798">12798</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13050">13050</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a7ade3550e213fc07d713a28b489a9a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ade3550e213fc07d713a28b489a9a6e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12872">12872</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afacb21a22bf29351cf42cfb335e82760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb21a22bf29351cf42cfb335e82760">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12921">12921</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ad9f495bae2139d10563cf878da49bbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f495bae2139d10563cf878da49bbb6">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12969">12969</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2f1cac92589b83a46980c84338e4d32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1cac92589b83a46980c84338e4d32e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13021">13021</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a41e1ddd6af8ce2f148dc2e471262cf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e1ddd6af8ce2f148dc2e471262cf8c">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13031">13031</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab70ff6a8fffd9c8f4074fb6f06f708c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70ff6a8fffd9c8f4074fb6f06f708c5">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13040">13040</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a49642521d7ce41aea4fd882332f47f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49642521d7ce41aea4fd882332f47f82">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13060">13060</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13106">13106</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a0bc73e5f4491b310f3a65441be139513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc73e5f4491b310f3a65441be139513">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12880">12880</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5cf5b1fd0f6f9753145821d9ff46101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf5b1fd0f6f9753145821d9ff46101a">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12929">12929</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aeaec203ac31c6102d901e205bd774362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaec203ac31c6102d901e205bd774362">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12977">12977</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a882c905333d176ffdcb5cd79f2e7a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882c905333d176ffdcb5cd79f2e7a51e">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13151">13151</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12718">12718</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12680">12680</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices. </p><dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a2f0c10f7a8cd32d961e9367173685047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c10f7a8cd32d961e9367173685047">&#9670;&nbsp;</a></span>save() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p><dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f72d5fbb277ec65dbe0382ae72a929">&#9670;&nbsp;</a></span>load() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Throw away the previous content. </p><dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class. </dd>
<dd>
This function calls the <a class="el" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="adbf04756b28dae69194870812acaf941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf04756b28dae69194870812acaf941">&#9670;&nbsp;</a></span>add_periodicity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodicity_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries. The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>. For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and <a class="el" href="step_45.html">step-45</a> . </p><dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classTriangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13283">13283</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and <a class="el" href="step_45.html">step-45</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classTriangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries. The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>. For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and <a class="el" href="step_45.html">step-45</a> . </p><dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classTriangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="abb27ce1c3232500c3d29b8a4a5cc9cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb27ce1c3232500c3d29b8a4a5cc9cf2">&#9670;&nbsp;</a></span>get_periodic_face_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13303">13303</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::pair&lt;std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::pair&lt;std::pair&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="a7dd81b27e783924976ef8efa51bc7d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd81b27e783924976ef8efa51bc7d76">&#9670;&nbsp;</a></span>get_reference_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13504">13504</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13513">13513</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="gafc78a1322a1040b8601290e52f2cc532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc78a1322a1040b8601290e52f2cc532">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidLevel&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are requesting information from refinement <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; of a&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less *than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga8c118c9eb467d05ebe068651b74002ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c118c9eb467d05ebe068651b74002ab">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcTriangulationNotEmpty&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are trying to perform an operation on a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> &quot;&lt;&lt; &quot;that is only allowed if the <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> is currently empty. &quot;&lt;&lt; &quot;&#160;</td>
          <td class="paramname"><em>However</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function raising this exception can only operate on an empty <a class="el" href="classTriangulation.html">Triangulation</a>, i.e., a <a class="el" href="classTriangulation.html">Triangulation</a> without grid cells. </p>

</div>
</div>
<a id="gafc78a1322a1040b8601290e52f2cc532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc78a1322a1040b8601290e52f2cc532">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidLevel&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are requesting information from refinement <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; of a&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less *than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga8c118c9eb467d05ebe068651b74002ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c118c9eb467d05ebe068651b74002ab">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcTriangulationNotEmpty&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are trying to perform an operation on a <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> &quot;&lt;&lt; &quot;that is only allowed if the <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> is currently empty. &quot;&lt;&lt; &quot;&#160;</td>
          <td class="paramname"><em>However</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function raising this exception can only operate on an empty <a class="el" href="classTriangulation.html">Triangulation</a>, i.e., a <a class="el" href="classTriangulation.html">Triangulation</a> without grid cells. </p>

</div>
</div>
<a id="ga966384346b2c7308b814ab09065d0470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966384346b2c7308b814ab09065d0470">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcGridReadError&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trying to re-read a grid, an error occurred. </p>

</div>
</div>
<a id="gaafa031bdac9392e3cdaa7ecf87171335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa031bdac9392e3cdaa7ecf87171335">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcFacesHaveNoLevel&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNonOrientableTriangulation&lt; dim, spacedim &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga966384346b2c7308b814ab09065d0470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966384346b2c7308b814ab09065d0470">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcGridReadError&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trying to re-read a grid, an error occurred. </p>

</div>
</div>
<a id="gaafa031bdac9392e3cdaa7ecf87171335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa031bdac9392e3cdaa7ecf87171335">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcFacesHaveNoLevel&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNonOrientableTriangulation&lt; dim, spacedim &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga391a9a406c14d6830d2ccbf0c59b429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391a9a406c14d6830d2ccbf0c59b429b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcEmptyLevel&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do something on <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> is empty.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The triangulation level you accessed is empty. </p>

</div>
</div>
<a id="ga9880263a1f12cd1dfecf45ac55c75c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9880263a1f12cd1dfecf45ac55c75c8b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcBoundaryIdNotFound&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;!&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception</p>
<p>Requested boundary_id not found </p>

</div>
</div>
<a id="ga391a9a406c14d6830d2ccbf0c59b429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391a9a406c14d6830d2ccbf0c59b429b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcEmptyLevel&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do something on <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> is empty.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The triangulation level you accessed is empty. </p>

</div>
</div>
<a id="ga9880263a1f12cd1dfecf45ac55c75c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9880263a1f12cd1dfecf45ac55c75c8b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcBoundaryIdNotFound&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;!&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception Requested boundary_id not found </p>

</div>
</div>
<a id="ga95a456ec8242cdf9109491510534f13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a456ec8242cdf9109491510534f13d">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInconsistentCoarseningFlags&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;A cell is flagged for&#160;</td>
          <td class="paramname"><em>coarsening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> via &quot; &quot;<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>() beforehand!&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga95a456ec8242cdf9109491510534f13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a456ec8242cdf9109491510534f13d">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInconsistentCoarseningFlags&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;A cell is flagged for&#160;</td>
          <td class="paramname"><em>coarsening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your <a class="el" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a> via &quot; &quot;<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>() beforehand!&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a7f2556bec2fb7f32b9d384664118fedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2556bec2fb7f32b9d384664118fedb">&#9670;&nbsp;</a></span>write_bool_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::write_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a bool vector to the given stream, writing a pre- and a postfix magic number. The vector is written in an almost binary format, i.e. the bool flags are packed but the data is written as ASCII text. The flags are stored in a binary format: for each <code>true</code>, a <code>1</code> bit is stored, a <code>0</code> bit otherwise. The bits are stored as <code>unsigned char</code>, thus avoiding endianness. They are written to <code>out</code> in plain text, thus amounting to 3.6 bits in the output per bits in the input on the average. Other information (magic numbers and number of elements of the input vector) is stored as plain text as well. The format should therefore be interplatform compatible. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l15115">15115</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af9e3e5c077024f40355432c771ccf541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3e5c077024f40355432c771ccf541">&#9670;&nbsp;</a></span>write_bool_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::write_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a bool vector to the given stream, writing a pre- and a postfix magic number. The vector is written in an almost binary format, i.e. the bool flags are packed but the data is written as ASCII text.</p>
<p>The flags are stored in a binary format: for each <code>true</code>, a <code>1</code> bit is stored, a <code>0</code> bit otherwise. The bits are stored as <code>unsigned char</code>, thus avoiding endianness. They are written to <code>out</code> in plain text, thus amounting to 3.6 bits in the output per bits in the input on the average. Other information (magic numbers and number of elements of the input vector) is stored as plain text as well. The format should therefore be interplatform compatible. </p>

</div>
</div>
<a id="af9e3e5c077024f40355432c771ccf541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3e5c077024f40355432c771ccf541">&#9670;&nbsp;</a></span>write_bool_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::write_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a bool vector to the given stream, writing a pre- and a postfix magic number. The vector is written in an almost binary format, i.e. the bool flags are packed but the data is written as ASCII text. The flags are stored in a binary format: for each <code>true</code>, a <code>1</code> bit is stored, a <code>0</code> bit otherwise. The bits are stored as <code>unsigned char</code>, thus avoiding endianness. They are written to <code>out</code> in plain text, thus amounting to 3.6 bits in the output per bits in the input on the average. Other information (magic numbers and number of elements of the input vector) is stored as plain text as well. The format should therefore be interplatform compatible. </p>

</div>
</div>
<a id="af3ac7df85e0ac685224e16e800ca3c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ac7df85e0ac685224e16e800ca3c87">&#9670;&nbsp;</a></span>read_bool_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::read_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-read a vector of bools previously written by <code>write_bool_vector</code> and compare with the magic numbers. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l15150">15150</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a20c92032e652bdafdfd7624a55aa2866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c92032e652bdafdfd7624a55aa2866">&#9670;&nbsp;</a></span>read_bool_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::read_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-read a vector of bools previously written by <code>write_bool_vector</code> and compare with the magic numbers. </p>

</div>
</div>
<a id="a20c92032e652bdafdfd7624a55aa2866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c92032e652bdafdfd7624a55aa2866">&#9670;&nbsp;</a></span>read_bool_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::read_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-read a vector of bools previously written by <code>write_bool_vector</code> and compare with the magic numbers. </p>

</div>
</div>
<a id="a609fee9e79ae50f4c348a39838c7eb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fee9e79ae50f4c348a39838c7eb0c">&#9670;&nbsp;</a></span>update_periodic_face_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::update_periodic_face_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recreate information about periodic neighbors from periodic_face_pairs_level_0. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13424">13424</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a609fee9e79ae50f4c348a39838c7eb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fee9e79ae50f4c348a39838c7eb0c">&#9670;&nbsp;</a></span>update_periodic_face_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::update_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recreate information about periodic neighbors from periodic_face_pairs_level_0. </p>

</div>
</div>
<a id="a609fee9e79ae50f4c348a39838c7eb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fee9e79ae50f4c348a39838c7eb0c">&#9670;&nbsp;</a></span>update_periodic_face_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::update_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recreate information about periodic neighbors from periodic_face_pairs_level_0. </p>

</div>
</div>
<a id="a286a4c703d5b4a6aab6d987c49c66611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286a4c703d5b4a6aab6d987c49c66611">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l11918">11918</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a45bb19508b89ac6ed237b14bf7a506ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb19508b89ac6ed237b14bf7a506ef">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

</div>
</div>
<a id="a45bb19508b89ac6ed237b14bf7a506ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb19508b89ac6ed237b14bf7a506ef">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

</div>
</div>
<a id="a69ded01b76d89248739107dd430d3d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ded01b76d89248739107dd430d3d70">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12060">12060</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5cbfc1e5187c6ad0a47d1b616f9f5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc1e5187c6ad0a47d1b616f9f5149">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p>

</div>
</div>
<a id="a5cbfc1e5187c6ad0a47d1b616f9f5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc1e5187c6ad0a47d1b616f9f5149">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a></code>. </p>

</div>
</div>
<a id="ab62d06de4164ee70ebaaa32b113fea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62d06de4164ee70ebaaa32b113fea5d">&#9670;&nbsp;</a></span>begin_raw_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12308">12308</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af97878288a5eca64303abe53572ea159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97878288a5eca64303abe53572ea159">&#9670;&nbsp;</a></span>begin_raw_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

</div>
</div>
<a id="af97878288a5eca64303abe53572ea159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97878288a5eca64303abe53572ea159">&#9670;&nbsp;</a></span>begin_raw_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

</div>
</div>
<a id="ab7ece762ccc53ef7fe17c019028c9fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ece762ccc53ef7fe17c019028c9fbb">&#9670;&nbsp;</a></span>begin_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12348">12348</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa50f2b3deed6e5f99e91768266df1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f2b3deed6e5f99e91768266df1d6e">&#9670;&nbsp;</a></span>begin_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aa50f2b3deed6e5f99e91768266df1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f2b3deed6e5f99e91768266df1d6e">&#9670;&nbsp;</a></span>begin_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aa2f5b63f1c1f2cc3de33e7090b5b9a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f5b63f1c1f2cc3de33e7090b5b9a1c">&#9670;&nbsp;</a></span>begin_active_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12364">12364</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8d3efa7416e6b56419ffab72ac227a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3efa7416e6b56419ffab72ac227a4a">&#9670;&nbsp;</a></span>begin_active_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a8d3efa7416e6b56419ffab72ac227a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3efa7416e6b56419ffab72ac227a4a">&#9670;&nbsp;</a></span>begin_active_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ac99fe20c8e7fac22cf7e3586a3ec058d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99fe20c8e7fac22cf7e3586a3ec058d">&#9670;&nbsp;</a></span>end_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12380">12380</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5cf640d5b174cae0f46e415c3fe39db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf640d5b174cae0f46e415c3fe39db2">&#9670;&nbsp;</a></span>end_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a5cf640d5b174cae0f46e415c3fe39db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf640d5b174cae0f46e415c3fe39db2">&#9670;&nbsp;</a></span>end_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a28622ea8cac645ed43483ed87d34da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28622ea8cac645ed43483ed87d34da86">&#9670;&nbsp;</a></span>begin_raw_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for \(dim&gt;2\) no level argument must be given. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12394">12394</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a52db7f90cd64a56e55383bef561aa7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db7f90cd64a56e55383bef561aa7d1">&#9670;&nbsp;</a></span>begin_raw_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for \(dim&gt;2\) no level argument must be given.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a52db7f90cd64a56e55383bef561aa7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db7f90cd64a56e55383bef561aa7d1">&#9670;&nbsp;</a></span>begin_raw_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for \(dim&gt;2\) no level argument must be given. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aeb662e82deeb043072138ff87c9b78d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb662e82deeb043072138ff87c9b78d7">&#9670;&nbsp;</a></span>begin_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12448">12448</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a09ee8cea6762ae96b484436de70b3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ee8cea6762ae96b484436de70b3983">&#9670;&nbsp;</a></span>begin_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a09ee8cea6762ae96b484436de70b3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ee8cea6762ae96b484436de70b3983">&#9670;&nbsp;</a></span>begin_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aeebbba11c9e4f692dcdac48f657bed47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebbba11c9e4f692dcdac48f657bed47">&#9670;&nbsp;</a></span>begin_active_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12464">12464</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a169e053e788e4d1b6abf7fb7cee6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169e053e788e4d1b6abf7fb7cee6ba3c">&#9670;&nbsp;</a></span>begin_active_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a169e053e788e4d1b6abf7fb7cee6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169e053e788e4d1b6abf7fb7cee6ba3c">&#9670;&nbsp;</a></span>begin_active_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a8f7a245c70857e61f2ccf349fc03d38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7a245c70857e61f2ccf349fc03d38e">&#9670;&nbsp;</a></span>end_quad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12480">12480</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa4f723b45ffdd6bfefec560fd333dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f723b45ffdd6bfefec560fd333dadf">&#9670;&nbsp;</a></span>end_quad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="aa4f723b45ffdd6bfefec560fd333dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f723b45ffdd6bfefec560fd333dadf">&#9670;&nbsp;</a></span>end_quad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="ad33a8577a7f7bbd5fd9ae1ddb2f5b132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33a8577a7f7bbd5fd9ae1ddb2f5b132">&#9670;&nbsp;</a></span>begin_raw_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexes, a past-the-end iterator is returned. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12493">12493</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a26795906ff2742c5f2109113b79d6744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26795906ff2742c5f2109113b79d6744">&#9670;&nbsp;</a></span>begin_raw_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexes, a past-the-end iterator is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a26795906ff2742c5f2109113b79d6744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26795906ff2742c5f2109113b79d6744">&#9670;&nbsp;</a></span>begin_raw_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexes, a past-the-end iterator is returned. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a936c5704f475d6929fd77fa47e980dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936c5704f475d6929fd77fa47e980dc9">&#9670;&nbsp;</a></span>begin_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12539">12539</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aae764c732cc0de8322257d13912552b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae764c732cc0de8322257d13912552b8">&#9670;&nbsp;</a></span>begin_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aae764c732cc0de8322257d13912552b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae764c732cc0de8322257d13912552b8">&#9670;&nbsp;</a></span>begin_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a3ffa8df823fb13004972571c3a1b3af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa8df823fb13004972571c3a1b3af4">&#9670;&nbsp;</a></span>begin_active_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12555">12555</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a1e876cdf1cdae06aa793cc5081b4fe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e876cdf1cdae06aa793cc5081b4fe31">&#9670;&nbsp;</a></span>begin_active_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a1e876cdf1cdae06aa793cc5081b4fe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e876cdf1cdae06aa793cc5081b4fe31">&#9670;&nbsp;</a></span>begin_active_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>. </p><dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a4d1a0c51731b66a58f91530ab630633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1a0c51731b66a58f91530ab630633b">&#9670;&nbsp;</a></span>end_hex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12571">12571</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aadd003c8d0a9d5839488ee2ad1313703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd003c8d0a9d5839488ee2ad1313703">&#9670;&nbsp;</a></span>end_hex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="aadd003c8d0a9d5839488ee2ad1313703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd003c8d0a9d5839488ee2ad1313703">&#9670;&nbsp;</a></span>end_hex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0ea3487d046b34de4ee8f60abf1b2">&#9670;&nbsp;</a></span>clear_despite_subscriptions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions. Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classTriangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a> function). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13527">13527</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0ea3487d046b34de4ee8f60abf1b2">&#9670;&nbsp;</a></span>clear_despite_subscriptions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions.</p>
<p>Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classTriangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a> function). </p>

</div>
</div>
<a id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0ea3487d046b34de4ee8f60abf1b2">&#9670;&nbsp;</a></span>clear_despite_subscriptions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions. Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classTriangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation()</a> function). </p>

</div>
</div>
<a id="af42c164ad82da9629eab01f90ef2a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c164ad82da9629eab01f90ef2a360">&#9670;&nbsp;</a></span>reset_policy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_policy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset triangulation policy. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10420">10420</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af42c164ad82da9629eab01f90ef2a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c164ad82da9629eab01f90ef2a360">&#9670;&nbsp;</a></span>reset_policy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset triangulation policy. </p>

</div>
</div>
<a id="af42c164ad82da9629eab01f90ef2a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c164ad82da9629eab01f90ef2a360">&#9670;&nbsp;</a></span>reset_policy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset triangulation policy. </p>

</div>
</div>
<a id="a365332f11d26e60c46a1f9bbb3e5e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365332f11d26e60c46a1f9bbb3e5e1c1">&#9670;&nbsp;</a></span>reset_active_cell_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_active_cell_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For all cells, set the active cell indices so that active cells know the how many-th active cell they are, and all other cells have an invalid value. This function is called after mesh creation, refinement, and serialization. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13362">13362</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a365332f11d26e60c46a1f9bbb3e5e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365332f11d26e60c46a1f9bbb3e5e1c1">&#9670;&nbsp;</a></span>reset_active_cell_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_active_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For all cells, set the active cell indices so that active cells know the how many-th active cell they are, and all other cells have an invalid value. This function is called after mesh creation, refinement, and serialization. </p>

</div>
</div>
<a id="a365332f11d26e60c46a1f9bbb3e5e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365332f11d26e60c46a1f9bbb3e5e1c1">&#9670;&nbsp;</a></span>reset_active_cell_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_active_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For all cells, set the active cell indices so that active cells know the how many-th active cell they are, and all other cells have an invalid value. This function is called after mesh creation, refinement, and serialization. </p>

</div>
</div>
<a id="a76af9cf5bbd5811b3f6ee8ca03ac8df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af9cf5bbd5811b3f6ee8ca03ac8df6">&#9670;&nbsp;</a></span>reset_cell_vertex_indices_cache() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_cell_vertex_indices_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cache for the cells' vertex indices. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13401">13401</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a76af9cf5bbd5811b3f6ee8ca03ac8df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af9cf5bbd5811b3f6ee8ca03ac8df6">&#9670;&nbsp;</a></span>reset_cell_vertex_indices_cache() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_cell_vertex_indices_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cache for the cells' vertex indices. </p>

</div>
</div>
<a id="a76af9cf5bbd5811b3f6ee8ca03ac8df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af9cf5bbd5811b3f6ee8ca03ac8df6">&#9670;&nbsp;</a></span>reset_cell_vertex_indices_cache() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_cell_vertex_indices_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cache for the cells' vertex indices. </p>

</div>
</div>
<a id="acce4adddb4d040bda3239840519b70e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce4adddb4d040bda3239840519b70e4">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement. Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>. The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13544">13544</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a8a73cdc08e502d9a140a625184526b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73cdc08e502d9a140a625184526b89">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement.</p>
<p>Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>.</p>
<p>The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

</div>
</div>
<a id="a8a73cdc08e502d9a140a625184526b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73cdc08e502d9a140a625184526b89">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement. Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>. The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

</div>
</div>
<a id="afeebb271c1406d688a1ffb802a7bb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebb271c1406d688a1ffb802a7bb509">&#9670;&nbsp;</a></span>execute_coarsening() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13574">13574</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afeebb271c1406d688a1ffb802a7bb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebb271c1406d688a1ffb802a7bb509">&#9670;&nbsp;</a></span>execute_coarsening() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

</div>
</div>
<a id="afeebb271c1406d688a1ffb802a7bb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebb271c1406d688a1ffb802a7bb509">&#9670;&nbsp;</a></span>execute_coarsening() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

</div>
</div>
<a id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc87bf8f3793947ba51f2da20b8442">&#9670;&nbsp;</a></span>fix_coarsen_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13651">13651</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc87bf8f3793947ba51f2da20b8442">&#9670;&nbsp;</a></span>fix_coarsen_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

</div>
</div>
<a id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc87bf8f3793947ba51f2da20b8442">&#9670;&nbsp;</a></span>fix_coarsen_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

</div>
</div>
<a id="af01ec1d50a410f7cc29c543b212edefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01ec1d50a410f7cc29c543b212edefc">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9bd9ef5e0a4369e7fe9d060e90b240be">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af01ec1d50a410f7cc29c543b212edefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01ec1d50a410f7cc29c543b212edefc">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9bd9ef5e0a4369e7fe9d060e90b240be">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af01ec1d50a410f7cc29c543b212edefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01ec1d50a410f7cc29c543b212edefc">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9bd9ef5e0a4369e7fe9d060e90b240be">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9ef633762716a14deb9a4dcda02a26f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef633762716a14deb9a4dcda02a26f0">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a99bec3e6866a7939a47dff10fc3d700a">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9ef633762716a14deb9a4dcda02a26f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef633762716a14deb9a4dcda02a26f0">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a99bec3e6866a7939a47dff10fc3d700a">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9ef633762716a14deb9a4dcda02a26f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef633762716a14deb9a4dcda02a26f0">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a2e556f90fb175c1b053e6d7861753521">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a99bec3e6866a7939a47dff10fc3d700a">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abedea312211487def114beb5e06f1394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedea312211487def114beb5e06f1394">&#9670;&nbsp;</a></span>local_cell_relations</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> &gt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::local_cell_relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of pairs, each containing a deal.II cell iterator and its respective CellStatus. To update its contents, use the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">update_cell_relations()</a> member function. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00699">699</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a5979f543c847e88743216cb5986f7107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5979f543c847e88743216cb5986f7107">&#9670;&nbsp;</a></span>cell_attached_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structparallel_1_1DistributedTriangulationBase_1_1CellAttachedData.html">CellAttachedData</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::cell_attached_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00736">736</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="afd423107278fb82665a4a64f0a6da6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd423107278fb82665a4a64f0a6da6d2">&#9670;&nbsp;</a></span>data_transfer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html">DataTransfer</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::data_transfer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00887">887</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a55959d63f6a4e18cae86f005df8605ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55959d63f6a4e18cae86f005df8605ec">&#9670;&nbsp;</a></span>mpi_communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MPI communicator to be used for the triangulation. We create a unique communicator for this class, which is a duplicate of the one passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00299">299</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="addf7a809217fa1eb11b8c06c49b1b2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf7a809217fa1eb11b8c06c49b1b2cb">&#9670;&nbsp;</a></span>my_subdomain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::my_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subdomain id to be used for the current processor. This is the MPI rank. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00306">306</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a25846dd7a465319119e91f44d77ae0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25846dd7a465319119e91f44d77ae0b1">&#9670;&nbsp;</a></span>n_subdomains</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_subdomains</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total number of subdomains (or the size of the MPI communicator). </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00312">312</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aad29d4b50a16239861deb2bb07bc6089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29d4b50a16239861deb2bb07bc6089">&#9670;&nbsp;</a></span>number_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberCache <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria__base_8h_source.html#l00369">369</a> of file <a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aefd8ddbf96799abebb6c05dced569329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8ddbf96799abebb6c05dced569329">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01389">1389</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a4efe5cf75298c557be424d758bd79ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efe5cf75298c557be424d758bd79ec2">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01395">1395</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f601f63a6d1bd8e205edd93cbae3">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals for the various actions that a triangulation can do to itself. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02069">2069</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac9474a14d0e8429412c82450013bde67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9474a14d0e8429412c82450013bde67">&#9670;&nbsp;</a></span>smooth_grid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::smooth_grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do some smoothing in the process of refining the triangulation. See the general doc of this class for more information about this. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03353">3353</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac5ffcc4c67b130ba9c64694d62fb551a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ffcc4c67b130ba9c64694d62fb551a">&#9670;&nbsp;</a></span>reference_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> caching all reference-cell types of the given triangulation (also in the distributed case). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03360">3360</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a61b7c7321a76da1e83d9ee675fccd408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b7c7321a76da1e83d9ee675fccd408">&#9670;&nbsp;</a></span>policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1Policy.html">internal::TriangulationImplementation::Policy</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::policy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy with the Triangulation-specific tasks related to creation, refinement, and coarsening. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03416">3416</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a3df2a6c22d5cfef72c97dc5f917ce794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df2a6c22d5cfef72c97dc5f917ce794">&#9670;&nbsp;</a></span>periodic_face_pairs_level_0</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::periodic_face_pairs_level_0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classTriangulation.html#adbf04756b28dae69194870812acaf941">add_periodicity()</a> is called, this variable stores the given periodic face pairs on level 0 for later access during the identification of ghost cells for the multigrid hierarchy and for setting up the periodic_face_map. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03426">3426</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a83b72eb3c091c808ac088ee5b64cd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b72eb3c091c808ac088ee5b64cd676">&#9670;&nbsp;</a></span>periodic_face_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::periodic_face_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classTriangulation.html#adbf04756b28dae69194870812acaf941">add_periodicity()</a> is called, this variable stores the active periodic face pairs. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03435">3435</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a6cc6c258d1ca9769fed554c717a64a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6c258d1ca9769fed554c717a64a62">&#9670;&nbsp;</a></span>levels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a> &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of pointers pointing to the objects storing the cell data on the different levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03799">3799</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac3a3b87911c0427d5bc0523c53670910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a3b87911c0427d5bc0523c53670910">&#9670;&nbsp;</a></span>faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the faces of the triangulation. In 1d this contains nothing, in 2D it contains data concerning lines and in 3D quads and lines. All of these have no level and are therefore treated separately. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03808">3808</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ab045b7d42762b613f8159f68f2c9814e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab045b7d42762b613f8159f68f2c9814e">&#9670;&nbsp;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of the vertices of this triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03815">3815</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ab19199dd313e595a112e6f1939d48b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19199dd313e595a112e6f1939d48b33">&#9670;&nbsp;</a></span>vertices_used</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices_used</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array storing a bit-pattern which vertices are used. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03821">3821</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a9cc9daec6e95b744482c2322ffbf6a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc9daec6e95b744482c2322ffbf6a8f">&#9670;&nbsp;</a></span>manifold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>, std::unique_ptr&lt; const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collection of manifold objects. We store only objects, which are not of type <a class="el" href="classFlatManifold.html">FlatManifold</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03829">3829</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a12dc6feb50966969856aa359f6fa316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dc6feb50966969856aa359f6fa316a">&#9670;&nbsp;</a></span>anisotropic_refinement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::anisotropic_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether anisotropic refinement took place. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03835">3835</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5c55287cc4c709190b521fd98a4f5e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55287cc4c709190b521fd98a4f5e02">&#9670;&nbsp;</a></span>check_for_distorted_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::check_for_distorted_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that determines whether we are to check for distorted cells upon creation and refinement of a mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03843">3843</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a78417baf0aa881f922344f24d3d4e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78417baf0aa881f922344f24d3d4e62a">&#9670;&nbsp;</a></span>vertex_to_boundary_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_boundary_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the boundary indicator. This field is only used in 1d. We have this field because we store boundary indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces. The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>) were not a pointer. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03871">3871</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a206e641c648868eaec4985fc6f0596be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206e641c648868eaec4985fc6f0596be">&#9670;&nbsp;</a></span>vertex_to_manifold_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_manifold_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the manifold indicator. This field is only used in 1d. We have this field because we store manifold indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classManifold.html">Manifold</a> objects are pretty useless for points since they are neither refined nor are their interiors mapped. We nevertheless allow storing manifold ids for points to be consistent in dimension-independent programs. The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id</a>) were not a pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03892">3892</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/distributed/<a class="el" href="distributed_2tria__base_8h_source.html">tria_base.h</a></li>
<li>source/distributed/<a class="el" href="tria__base_8cc_source.html">tria_base.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassparallel_1_1DistributedTriangulationBase_html"><div class="ttname"><a href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2tria__base_8h_source.html#l00414">tria_base.h:414</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="agrid__out_8cc_html_a9082f945c1d289684d0bcd51ee08e11e"><div class="ttname"><a href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a></div><div class="ttdeci">unsigned int level</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04590">grid_out.cc:4590</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_aa78f707e9416892e3e018027ffab1c80"><div class="ttname"><a href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a></div><div class="ttdeci">const typename ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
