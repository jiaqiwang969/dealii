<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classOpenCASCADE_1_1NURBSPatchManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a></li><li class="navelem"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classOpenCASCADE_1_1NURBSPatchManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo; <a class="el" href="group__manifold.html">Manifold description for triangulations</a> &#124; <a class="el" href="group__OpenCASCADE.html">@{</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="opencascade_2manifold__lib_8h_source.html">deal.II/opencascade/manifold_lib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac844216636fd82cc577adcd00b82dacb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#ac844216636fd82cc577adcd00b82dacb">NURBSPatchManifold</a> (const TopoDS_Face &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, const <a class="el" href="classdouble.html">double</a> <a class="el" href="group__OpenCASCADE.html#ga3b9a62230af2a543ab4d7eaa5d7a14ad">tolerance</a>=1e-7)</td></tr>
<tr class="separator:ac844216636fd82cc577adcd00b82dacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12158c433d4cf738f7e23c9098944a74"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a12158c433d4cf738f7e23c9098944a74">clone</a> () const override</td></tr>
<tr class="separator:a12158c433d4cf738f7e23c9098944a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf74fe66865783bde0a35f3114fc52e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;space_point) const override</td></tr>
<tr class="separator:a8bf74fe66865783bde0a35f3114fc52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcf127166f5b71c53463baade215661"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:a8fcf127166f5b71c53463baade215661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a83e84a777832df72c19d8f8929db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#acf3a83e84a777832df72c19d8f8929db">push_forward_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:acf3a83e84a777832df72c19d8f8929db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac844216636fd82cc577adcd00b82dacb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gac844216636fd82cc577adcd00b82dacb">NURBSPatchManifold</a> (const TopoDS_Face &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, const <a class="el" href="classdouble.html">double</a> <a class="el" href="group__OpenCASCADE.html#ga3b9a62230af2a543ab4d7eaa5d7a14ad">tolerance</a>=1e-7)</td></tr>
<tr class="separator:gac844216636fd82cc577adcd00b82dacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9690eb5f128777a17fb27909ab6053c3"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#ga9690eb5f128777a17fb27909ab6053c3">clone</a> () const override</td></tr>
<tr class="separator:ga9690eb5f128777a17fb27909ab6053c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad312e12ce4e067d9e3b6a21d92b6d04e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gad312e12ce4e067d9e3b6a21d92b6d04e">pull_back</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;space_point) const override</td></tr>
<tr class="separator:gad312e12ce4e067d9e3b6a21d92b6d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33902191e436b7735588309a95e7bae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gaf33902191e436b7735588309a95e7bae">push_forward</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:gaf33902191e436b7735588309a95e7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b504c65fc43ba09803d3a7f82ea0cc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#ga1b504c65fc43ba09803d3a7f82ea0cc8">push_forward_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:ga1b504c65fc43ba09803d3a7f82ea0cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844216636fd82cc577adcd00b82dacb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#ac844216636fd82cc577adcd00b82dacb">NURBSPatchManifold</a> (const TopoDS_Face &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, const <a class="el" href="classdouble.html">double</a> <a class="el" href="group__OpenCASCADE.html#ga3b9a62230af2a543ab4d7eaa5d7a14ad">tolerance</a>=1e-7)</td></tr>
<tr class="separator:ac844216636fd82cc577adcd00b82dacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9690eb5f128777a17fb27909ab6053c3"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a9690eb5f128777a17fb27909ab6053c3">clone</a> () const override</td></tr>
<tr class="separator:a9690eb5f128777a17fb27909ab6053c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad312e12ce4e067d9e3b6a21d92b6d04e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#ad312e12ce4e067d9e3b6a21d92b6d04e">pull_back</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;space_point) const override</td></tr>
<tr class="separator:ad312e12ce4e067d9e3b6a21d92b6d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33902191e436b7735588309a95e7bae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#af33902191e436b7735588309a95e7bae">push_forward</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:af33902191e436b7735588309a95e7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b504c65fc43ba09803d3a7f82ea0cc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a1b504c65fc43ba09803d3a7f82ea0cc8">push_forward_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:a1b504c65fc43ba09803d3a7f82ea0cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af255b3dfb6c1f38eaece0e995a85ec86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const override</td></tr>
<tr class="separator:af255b3dfb6c1f38eaece0e995a85ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24f5adae12f44a702406ca361bc3abf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const override</td></tr>
<tr class="separator:ab24f5adae12f44a702406ca361bc3abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24f5adae12f44a702406ca361bc3abf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const override</td></tr>
<tr class="separator:ab24f5adae12f44a702406ca361bc3abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9207f06d5bd518383353ebee3f046c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a1e9207f06d5bd518383353ebee3f046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e15b3d972cee2d6ed0661e9b6cc33"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a0f8e15b3d972cee2d6ed0661e9b6cc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e15b3d972cee2d6ed0661e9b6cc33"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a0f8e15b3d972cee2d6ed0661e9b6cc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e53bca8079f105415141b556111ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ac43e53bca8079f105415141b556111ae">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:ac43e53bca8079f105415141b556111ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999ef4b52e2c7d8e0abcb6c83bd27ae1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:a999ef4b52e2c7d8e0abcb6c83bd27ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999ef4b52e2c7d8e0abcb6c83bd27ae1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:a999ef4b52e2c7d8e0abcb6c83bd27ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713fbbf4271f9539bb2406f7029ab239"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a> (const <a class="el" href="classPoint.html">Point</a>&lt; chartdim &gt; &amp;chart_point) const=0</td></tr>
<tr class="separator:a713fbbf4271f9539bb2406f7029ab239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6141f9a6780c6c271c73cb1c74e5b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, chartdim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a9f6141f9a6780c6c271c73cb1c74e5b4">push_forward_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; chartdim &gt; &amp;chart_point) const</td></tr>
<tr class="separator:a9f6141f9a6780c6c271c73cb1c74e5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9577b9723c8d6fb8481ca99daec95682"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:a9577b9723c8d6fb8481ca99daec95682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac57666eb157e97353a7c2d18d1ef91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:a6ac57666eb157e97353a7c2d18d1ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac57666eb157e97353a7c2d18d1ef91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:a6ac57666eb157e97353a7c2d18d1ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5684d6440642e8ec40ed840a7f381b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, chartdim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ab5684d6440642e8ec40ed840a7f381b5">get_periodicity</a> () const</td></tr>
<tr class="separator:ab5684d6440642e8ec40ed840a7f381b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c7552ea8aba4a2d4ca284f1f62552"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, chartdim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a1d3c7552ea8aba4a2d4ca284f1f62552">get_periodicity</a> () const</td></tr>
<tr class="separator:a1d3c7552ea8aba4a2d4ca284f1f62552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c7552ea8aba4a2d4ca284f1f62552"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, chartdim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a1d3c7552ea8aba4a2d4ca284f1f62552">get_periodicity</a> () const</td></tr>
<tr class="separator:a1d3c7552ea8aba4a2d4ca284f1f62552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f1d301d7950f55b59e1c2982dfe942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a73f1d301d7950f55b59e1c2982dfe942">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a73f1d301d7950f55b59e1c2982dfe942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1adb7e5b4a0feeeef7f9ec087e23d376">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7186dfb0ea938abda62e962d5f867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4bd7186dfb0ea938abda62e962d5f867">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a4bd7186dfb0ea938abda62e962d5f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada653729888b24eb140a382512167163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ada653729888b24eb140a382512167163">get_new_point_on_hex</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:ada653729888b24eb140a382512167163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a38fc3f140d54aa80195831a27c499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae6a38fc3f140d54aa80195831a27c499">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:ae6a38fc3f140d54aa80195831a27c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba395b8edbb4703d2e77689266436f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9bba395b8edbb4703d2e77689266436f">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a9bba395b8edbb4703d2e77689266436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6859a4858667c7d37838276c8e8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4dd6859a4858667c7d37838276c8e8b2">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a4dd6859a4858667c7d37838276c8e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ae5e689877ac0d06b08b33f718caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a464ae5e689877ac0d06b08b33f718caa">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:a464ae5e689877ac0d06b08b33f718caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b06b088819df6a9305d0009495d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ad95b06b088819df6a9305d0009495d3d">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:ad95b06b088819df6a9305d0009495d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944375afbf9370708422e520c6969e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae944375afbf9370708422e520c6969e5">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:ae944375afbf9370708422e520c6969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3477908d71618cfc0c2de81e8ad474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1e3477908d71618cfc0c2de81e8ad474">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;<a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a>, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:a1e3477908d71618cfc0c2de81e8ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1f3ad2d605b6e0a016e31ce8205ff665"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a1f3ad2d605b6e0a016e31ce8205ff665">get_uv_bounds</a> () const</td></tr>
<tr class="separator:a1f3ad2d605b6e0a016e31ce8205ff665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0962e1fe1eca3f6a06a197e2c33393c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gad0962e1fe1eca3f6a06a197e2c33393c">get_uv_bounds</a> () const</td></tr>
<tr class="separator:gad0962e1fe1eca3f6a06a197e2c33393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0962e1fe1eca3f6a06a197e2c33393c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#ad0962e1fe1eca3f6a06a197e2c33393c">get_uv_bounds</a> () const</td></tr>
<tr class="separator:ad0962e1fe1eca3f6a06a197e2c33393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:gab09bd0ec1b3a4c4a711ac3b3a32abc5d"><td class="memItemLeft" align="right" valign="top">TopoDS_Face&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gab09bd0ec1b3a4c4a711ac3b3a32abc5d">face</a></td></tr>
<tr class="separator:gab09bd0ec1b3a4c4a711ac3b3a32abc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b9a62230af2a543ab4d7eaa5d7a14ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#ga3b9a62230af2a543ab4d7eaa5d7a14ad">tolerance</a></td></tr>
<tr class="separator:ga3b9a62230af2a543ab4d7eaa5d7a14ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a135ea318fa52e685c30d4cd038a017ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; chartdim, chartdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a135ea318fa52e685c30d4cd038a017ac">sub_manifold</a></td></tr>
<tr class="separator:a135ea318fa52e685c30d4cd038a017ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br />
class OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="classManifold.html">Manifold</a> description for the face of a CAD imported using <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a>. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8h_source.html#l00359">359</a> of file <a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself. For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00271">271</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II-origin_2grid_2manifold_8h_source.html#l00307">307</a> of file <a class="el" href="include_2deal_8II-origin_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself. For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II-translator_2grid_2manifold_8h_source.html#l00271">271</a> of file <a class="el" href="include_2deal_8II-translator_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac844216636fd82cc577adcd00b82dacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844216636fd82cc577adcd00b82dacb">&#9670;&nbsp;</a></span>NURBSPatchManifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a> </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor takes an <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> TopoDS_Face <code>face</code> and an optional <code>tolerance</code>. This class uses the interval <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> variables u, v to describe the manifold. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00440">440</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="ac844216636fd82cc577adcd00b82dacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844216636fd82cc577adcd00b82dacb">&#9670;&nbsp;</a></span>NURBSPatchManifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a> </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor takes an <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> TopoDS_Face <code>face</code> and an optional <code>tolerance</code>. This class uses the interval <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> variables u, v to describe the manifold. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a12158c433d4cf738f7e23c9098944a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12158c433d4cf738f7e23c9098944a74">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::clone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone the current <a class="el" href="classManifold.html">Manifold</a>. </p>

<p>Implements <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00450">450</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a8bf74fe66865783bde0a35f3114fc52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf74fe66865783bde0a35f3114fc52e">&#9670;&nbsp;</a></span>pull_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::pull_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pull back the given point from the Euclidean space. Will return the uv coordinates associated with the point <code>space_point</code>. </p>

<p>Implements <a class="el" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">ChartManifold&lt; dim, spacedim, 2 &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00460">460</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a8fcf127166f5b71c53463baade215661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcf127166f5b71c53463baade215661">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <code>chart_point</code> in the uv coordinate system, this method returns the Euclidean coordinates associated. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00476">476</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="acf3a83e84a777832df72c19d8f8929db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3a83e84a777832df72c19d8f8929db">&#9670;&nbsp;</a></span>push_forward_gradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, 2, spacedim &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::push_forward_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point in the spacedim dimensional Euclidean space, this method returns the derivatives of the function \(F\) that maps from the uv coordinate system to the Euclidean coordinate system. In other words, it is a matrix of size \(\text{spacedim}\times\text{chartdim}\) . This function is used in the computations required by the <a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">get_tangent_vector()</a> function. Refer to the general documentation of this class for more information. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00486">486</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a1f3ad2d605b6e0a016e31ce8205ff665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3ad2d605b6e0a016e31ce8205ff665">&#9670;&nbsp;</a></span>get_uv_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::get_uv_bounds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a tuple representing the minimum and maximum values of u and v. Precisely, it returns (u_min, u_max, v_min, v_max) </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8cc_source.html#l00517">517</a> of file <a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a9690eb5f128777a17fb27909ab6053c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9690eb5f128777a17fb27909ab6053c3">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone the current <a class="el" href="classManifold.html">Manifold</a>. </p>

<p>Implements <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad312e12ce4e067d9e3b6a21d92b6d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad312e12ce4e067d9e3b6a21d92b6d04e">&#9670;&nbsp;</a></span>pull_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;2&gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::pull_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pull back the given point from the Euclidean space. Will return the uv coordinates associated with the point <code>space_point</code>. </p>

<p>Implements <a class="el" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">ChartManifold&lt; dim, spacedim, 2 &gt;</a>.</p>

</div>
</div>
<a id="af33902191e436b7735588309a95e7bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33902191e436b7735588309a95e7bae">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <code>chart_point</code> in the uv coordinate system, this method returns the Euclidean coordinates associated. </p>

</div>
</div>
<a id="a1b504c65fc43ba09803d3a7f82ea0cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b504c65fc43ba09803d3a7f82ea0cc8">&#9670;&nbsp;</a></span>push_forward_gradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, 2, spacedim&gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::push_forward_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point in the spacedim dimensional Euclidean space, this method returns the derivatives of the function \(F\) that maps from the uv coordinate system to the Euclidean coordinate system. In other words, it is a matrix of size \(\text{spacedim}\times\text{chartdim}\) . This function is used in the computations required by the <a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">get_tangent_vector()</a> function. Refer to the general documentation of this class for more information. </p>

</div>
</div>
<a id="ad0962e1fe1eca3f6a06a197e2c33393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0962e1fe1eca3f6a06a197e2c33393c">&#9670;&nbsp;</a></span>get_uv_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>&lt; dim, spacedim &gt;::get_uv_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a tuple representing the minimum and maximum values of u and v. Precisely, it returns (u_min, u_max, v_min, v_max) </p>

</div>
</div>
<a id="af255b3dfb6c1f38eaece0e995a85ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af255b3dfb6c1f38eaece0e995a85ec86">&#9670;&nbsp;</a></span>get_intermediate_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00984">984</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab24f5adae12f44a702406ca361bc3abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24f5adae12f44a702406ca361bc3abf">&#9670;&nbsp;</a></span>get_intermediate_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab24f5adae12f44a702406ca361bc3abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24f5adae12f44a702406ca361bc3abf">&#9670;&nbsp;</a></span>get_intermediate_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1e9207f06d5bd518383353ebee3f046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9207f06d5bd518383353ebee3f046c">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00999">999</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a0f8e15b3d972cee2d6ed0661e9b6cc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8e15b3d972cee2d6ed0661e9b6cc33">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0f8e15b3d972cee2d6ed0661e9b6cc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8e15b3d972cee2d6ed0661e9b6cc33">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac43e53bca8079f105415141b556111ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43e53bca8079f105415141b556111ae">&#9670;&nbsp;</a></span>get_new_points() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>. The implementation of this function first transforms the <code>surrounding_points</code> to the chart space by calling <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a>. Then, new points are computed on the chart by usual interpolation according to the given <code>weights</code>, which are finally transformed to the image space by <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a>. This implementation can be much more efficient for computing multiple new points from the same surrounding points than separate calls to <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> in case the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> operation is expensive. This is because <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is only called once for the surrounding points and the interpolation is done for all given weights using this set of points. Often, <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is also more expensive than <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> because the former might involve some kind of Newton iteration in non-trivial manifolds. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01020">1020</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a999ef4b52e2c7d8e0abcb6c83bd27ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999ef4b52e2c7d8e0abcb6c83bd27ae1">&#9670;&nbsp;</a></span>get_new_points() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>The implementation of this function first transforms the <code>surrounding_points</code> to the chart space by calling <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a>. Then, new points are computed on the chart by usual interpolation according to the given <code>weights</code>, which are finally transformed to the image space by <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a>.</p>
<p>This implementation can be much more efficient for computing multiple new points from the same surrounding points than separate calls to <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> in case the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> operation is expensive. This is because <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is only called once for the surrounding points and the interpolation is done for all given weights using this set of points. Often, <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is also more expensive than <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> because the former might involve some kind of Newton iteration in non-trivial manifolds. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a999ef4b52e2c7d8e0abcb6c83bd27ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999ef4b52e2c7d8e0abcb6c83bd27ae1">&#9670;&nbsp;</a></span>get_new_points() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>. The implementation of this function first transforms the <code>surrounding_points</code> to the chart space by calling <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a>. Then, new points are computed on the chart by usual interpolation according to the given <code>weights</code>, which are finally transformed to the image space by <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a>. This implementation can be much more efficient for computing multiple new points from the same surrounding points than separate calls to <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> in case the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> operation is expensive. This is because <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is only called once for the surrounding points and the interpolation is done for all given weights using this set of points. Often, <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8bf74fe66865783bde0a35f3114fc52e">pull_back()</a> is also more expensive than <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> because the former might involve some kind of Newton iteration in non-trivial manifolds. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a713fbbf4271f9539bb2406f7029ab239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713fbbf4271f9539bb2406f7029ab239">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; chartdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point in the chartdim dimensional Euclidean space, this method returns a point on the manifold embedded in the spacedim Euclidean space. Refer to the general documentation of this class for more information. </p>

</div>
</div>
<a id="a9f6141f9a6780c6c271c73cb1c74e5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6141f9a6780c6c271c73cb1c74e5b4">&#9670;&nbsp;</a></span>push_forward_gradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, chartdim, spacedim &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::push_forward_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; chartdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point in the chartdim dimensional Euclidean space, this method returns the derivatives of the function \(F\) that maps from the chartdim-dimensional to the spacedim-dimensional space. In other words, it is a matrix of size \(\text{spacedim}\times\text{chartdim}\) . This function is used in the computations required by the <a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">get_tangent_vector()</a> function. Since not all users of the <a class="el" href="classManifold.html">Manifold</a> class interface will require calling that function, the current function is implemented but will trigger an exception whenever called. This allows derived classes to avoid implementing the push_forward_gradient function if this functionality is not needed in the user program. Refer to the general documentation of this class for more information. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01049">1049</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9577b9723c8d6fb8481ca99daec95682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9577b9723c8d6fb8481ca99daec95682">&#9670;&nbsp;</a></span>get_tangent_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\) , is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\) . See the documentation of the <a class="el" href="classManifold.html">Manifold</a> class and of <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a> for a more detailed description. For the current class, we assume that this geodesic is the image under the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> operation of a straight line of the pre-images of <code>x1</code> and <code>x2</code> (where pre-images are computed by pulling back the locations <code>x1</code> and <code>x2</code>). In other words, if these preimages are \(\xi_1=F^{-1}(\mathbf x_1), \xi_2=F^{-1}(\mathbf x_2)\) , then the geodesic in preimage (the chartdim-dimensional Euclidean) space is </p><p class="formulaDsp">
\begin{align*} \zeta(t) &amp;= \xi_1 + t (\xi_2-\xi_1) \\ &amp;= F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right] \end{align*}
</p>
<p> In image space, i.e., in the space in which we operate, this leads to the curve </p><p class="formulaDsp">
\begin{align*} \mathbf s(t) &amp;= F(\zeta(t)) \\ &amp;= F(\xi_1 + t (\xi_2-\xi_1)) \\ &amp;= F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right). \end{align*}
</p>
<p> What the current function is supposed to return is \(\mathbf s&#39;(0)\) . By the chain rule, this is equal to </p><p class="formulaDsp">
\begin{align*} \mathbf s&#39;(0) &amp;= \frac{d}{dt}\left. F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right) \right|_{t=0} \\ &amp;= \nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) \left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]. \end{align*}
</p>
<p> This formula may then have to be slightly modified by considering any periodicity that was assumed in the call to the constructor. Thus, the computation of tangent vectors also requires the implementation of <em>derivatives</em> \(\nabla_\xi F(\xi)\) of the push-forward mapping. Here, \(F^{-1}(\mathbf x_2)-F^{-1}(\mathbf x_1)\) is a chartdim-dimensional vector, and \(\nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) = \nabla_\xi F\left(\xi_1\right)\) is a spacedim-times-chartdim-dimensional matrix. Consequently, and as desired, the operation results in a spacedim-dimensional vector.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated.</td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01062">1062</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a6ac57666eb157e97353a7c2d18d1ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac57666eb157e97353a7c2d18d1ef91">&#9670;&nbsp;</a></span>get_tangent_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). See the documentation of the <a class="el" href="classManifold.html">Manifold</a> class and of <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a> for a more detailed description.</p>
<p>For the current class, we assume that this geodesic is the image under the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> operation of a straight line of the pre-images of <code>x1</code> and <code>x2</code> (where pre-images are computed by pulling back the locations <code>x1</code> and <code>x2</code>). In other words, if these preimages are \(\xi_1=F^{-1}(\mathbf x_1), \xi_2=F^{-1}(\mathbf x_2)\), then the geodesic in preimage (the chartdim-dimensional Euclidean) space is </p><p class="formulaDsp">
\begin{align*} \zeta(t) &amp;= \xi_1 + t (\xi_2-\xi_1) \\ &amp;= F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right] \end{align*}
</p>
<p> In image space, i.e., in the space in which we operate, this leads to the curve </p><p class="formulaDsp">
\begin{align*} \mathbf s(t) &amp;= F(\zeta(t)) \\ &amp;= F(\xi_1 + t (\xi_2-\xi_1)) \\ &amp;= F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right). \end{align*}
</p>
<p> What the current function is supposed to return is \(\mathbf s&#39;(0)\). By the chain rule, this is equal to </p><p class="formulaDsp">
\begin{align*} \mathbf s&#39;(0) &amp;= \frac{d}{dt}\left. F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right) \right|_{t=0} \\ &amp;= \nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) \left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]. \end{align*}
</p>
<p> This formula may then have to be slightly modified by considering any periodicity that was assumed in the call to the constructor.</p>
<p>Thus, the computation of tangent vectors also requires the implementation of <em>derivatives</em> \(\nabla_\xi F(\xi)\) of the push-forward mapping. Here, \(F^{-1}(\mathbf x_2)-F^{-1}(\mathbf x_1)\) is a chartdim-dimensional vector, and \(\nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) = \nabla_\xi F\left(\xi_1\right)\) is a spacedim-times-chartdim-dimensional matrix. Consequently, and as desired, the operation results in a spacedim-dimensional vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6ac57666eb157e97353a7c2d18d1ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac57666eb157e97353a7c2d18d1ef91">&#9670;&nbsp;</a></span>get_tangent_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\) , is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\) . See the documentation of the <a class="el" href="classManifold.html">Manifold</a> class and of <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a> for a more detailed description. For the current class, we assume that this geodesic is the image under the <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a8fcf127166f5b71c53463baade215661">push_forward()</a> operation of a straight line of the pre-images of <code>x1</code> and <code>x2</code> (where pre-images are computed by pulling back the locations <code>x1</code> and <code>x2</code>). In other words, if these preimages are \(\xi_1=F^{-1}(\mathbf x_1), \xi_2=F^{-1}(\mathbf x_2)\) , then the geodesic in preimage (the chartdim-dimensional Euclidean) space is </p><p class="formulaDsp">
\begin{align*} \zeta(t) &amp;= \xi_1 + t (\xi_2-\xi_1) \\ &amp;= F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right] \end{align*}
</p>
<p> In image space, i.e., in the space in which we operate, this leads to the curve </p><p class="formulaDsp">
\begin{align*} \mathbf s(t) &amp;= F(\zeta(t)) \\ &amp;= F(\xi_1 + t (\xi_2-\xi_1)) \\ &amp;= F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right). \end{align*}
</p>
<p> What the current function is supposed to return is \(\mathbf s&#39;(0)\) . By the chain rule, this is equal to </p><p class="formulaDsp">
\begin{align*} \mathbf s&#39;(0) &amp;= \frac{d}{dt}\left. F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right) \right|_{t=0} \\ &amp;= \nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) \left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]. \end{align*}
</p>
<p> This formula may then have to be slightly modified by considering any periodicity that was assumed in the call to the constructor. Thus, the computation of tangent vectors also requires the implementation of <em>derivatives</em> \(\nabla_\xi F(\xi)\) of the push-forward mapping. Here, \(F^{-1}(\mathbf x_2)-F^{-1}(\mathbf x_1)\) is a chartdim-dimensional vector, and \(\nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) = \nabla_\xi F\left(\xi_1\right)\) is a spacedim-times-chartdim-dimensional matrix. Consequently, and as desired, the operation results in a spacedim-dimensional vector.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated.</td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab5684d6440642e8ec40ed840a7f381b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5684d6440642e8ec40ed840a7f381b5">&#9670;&nbsp;</a></span>get_periodicity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, chartdim &gt; &amp; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_periodicity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity associated with the submanifold. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01094">1094</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1d3c7552ea8aba4a2d4ca284f1f62552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3c7552ea8aba4a2d4ca284f1f62552">&#9670;&nbsp;</a></span>get_periodicity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, chartdim&gt;&amp; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_periodicity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity associated with the submanifold. </p>

</div>
</div>
<a id="a1d3c7552ea8aba4a2d4ca284f1f62552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3c7552ea8aba4a2d4ca284f1f62552">&#9670;&nbsp;</a></span>get_periodicity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, chartdim&gt;&amp; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::get_periodicity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity associated with the submanifold. </p>

</div>
</div>
<a id="a29c25e5d735160e0d846aab01d918e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c25e5d735160e0d846aab01d918e86">&#9670;&nbsp;</a></span>project_to_manifold() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself. This class is used by the default implementation of the function <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called. If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a436f8e7fa132333ae5ed0d6f1b3f04f6">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a2c823dd4ef420dfd0de8e097d2be2bf2">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#gaf3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#ac7b0d16828cc077c45a2bd26b1d6544d">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00040">40</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af0163e726b6c4af36638d889fb3afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0163e726b6c4af36638d889fb3afed4">&#9670;&nbsp;</a></span>project_to_manifold() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a436f8e7fa132333ae5ed0d6f1b3f04f6">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a2c823dd4ef420dfd0de8e097d2be2bf2">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#gaf3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#ac7b0d16828cc077c45a2bd26b1d6544d">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>.</p>

</div>
</div>
<a id="af0163e726b6c4af36638d889fb3afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0163e726b6c4af36638d889fb3afed4">&#9670;&nbsp;</a></span>project_to_manifold() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself. This class is used by the default implementation of the function <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called. If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a436f8e7fa132333ae5ed0d6f1b3f04f6">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a2c823dd4ef420dfd0de8e097d2be2bf2">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#gaf3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#ac7b0d16828cc077c45a2bd26b1d6544d">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a82dd72513bdbf529746f0b5dd95a9e33">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>.</p>

</div>
</div>
<a id="af518522b81bdfe059b88bb557f7a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af518522b81bdfe059b88bb557f7a60ba">&#9670;&nbsp;</a></span>get_new_point_on_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary). The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00318">318</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9be8b4b185d2469dcdfff826ff854cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8b4b185d2469dcdfff826ff854cd7">&#9670;&nbsp;</a></span>get_new_point_on_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a9be8b4b185d2469dcdfff826ff854cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8b4b185d2469dcdfff826ff854cd7">&#9670;&nbsp;</a></span>get_new_point_on_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary). The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a59a7a18b04151504883074c24108266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a7a18b04151504883074c24108266f">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions. This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>. The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00332">332</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a6f18f34e5f98fea7cbd40bd3245f0aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18f34e5f98fea7cbd40bd3245f0aee">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a6f18f34e5f98fea7cbd40bd3245f0aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18f34e5f98fea7cbd40bd3245f0aee">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions. This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>. The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a73f1d301d7950f55b59e1c2982dfe942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f1d301d7950f55b59e1c2982dfe942">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00419">419</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1adb7e5b4a0feeeef7f9ec087e23d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adb7e5b4a0feeeef7f9ec087e23d376">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00430">430</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4bd7186dfb0ea938abda62e962d5f867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7186dfb0ea938abda62e962d5f867">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00441">441</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8d8365135405a1f057020d84a315ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8365135405a1f057020d84a315ffa6">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions. This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>. The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00452">452</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a87b1f7a138589989fe84984e12f3d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1f7a138589989fe84984e12f3d945">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a87b1f7a138589989fe84984e12f3d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1f7a138589989fe84984e12f3d945">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions. This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>. The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a2435189636100bbef4fe9fba823da2a5">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="ada653729888b24eb140a382512167163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada653729888b24eb140a382512167163">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00463">463</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab79c3a0f002136b483b50722ea6690d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c3a0f002136b483b50722ea6690d9">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00346">346</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a238d0f0a7f973ff25f4cab4ec21e9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d0f0a7f973ff25f4cab4ec21e9b56">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a238d0f0a7f973ff25f4cab4ec21e9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d0f0a7f973ff25f4cab4ec21e9b56">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="ae6a38fc3f140d54aa80195831a27c499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a38fc3f140d54aa80195831a27c499">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00386">386</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9bba395b8edbb4703d2e77689266436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bba395b8edbb4703d2e77689266436f">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00397">397</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4dd6859a4858667c7d37838276c8e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6859a4858667c7d37838276c8e8b2">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00408">408</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af36b25e230fefc6eb32d53cb6e69cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b25e230fefc6eb32d53cb6e69cbba">&#9670;&nbsp;</a></span>get_new_point_on_cell() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00366">366</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a39e9a7899b69fbe5fdf7961f9c4c7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9a7899b69fbe5fdf7961f9c4c7374">&#9670;&nbsp;</a></span>get_new_point_on_cell() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a39e9a7899b69fbe5fdf7961f9c4c7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9a7899b69fbe5fdf7961f9c4c7374">&#9670;&nbsp;</a></span>get_new_point_on_cell() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a8f737627dc946fb68c097d6ec83419d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f737627dc946fb68c097d6ec83419d4">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.) This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation. The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself). </p><dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#adb333bd42dfb3e7bd933b0f1b9ada0d9">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#af0a55c0cb5c01a8f334c8ea7e5bf49ed">PolarManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00239">239</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af0087568e69730a3acc7b42535ab3337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0087568e69730a3acc7b42535ab3337">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#adb333bd42dfb3e7bd933b0f1b9ada0d9">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#af0a55c0cb5c01a8f334c8ea7e5bf49ed">PolarManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af0087568e69730a3acc7b42535ab3337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0087568e69730a3acc7b42535ab3337">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.) This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation. The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself). </p><dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>, <a class="el" href="classFlatManifold.html#a86baeb3d0dd5fc240a4d9f80ff8deb63">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#adb333bd42dfb3e7bd933b0f1b9ada0d9">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#af0a55c0cb5c01a8f334c8ea7e5bf49ed">PolarManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a464ae5e689877ac0d06b08b33f718caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464ae5e689877ac0d06b08b33f718caa">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00145">145</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ad95b06b088819df6a9305d0009495d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95b06b088819df6a9305d0009495d3d">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00166">166</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a2f8317a03ab0c13971ff53bcb38b49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8317a03ab0c13971ff53bcb38b49e9">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward. This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex. Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00303">303</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a684ad0b97b0f225eb4eb7ee04ab41d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ad0b97b0f225eb4eb7ee04ab41d7e">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

</div>
</div>
<a id="a684ad0b97b0f225eb4eb7ee04ab41d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ad0b97b0f225eb4eb7ee04ab41d7e">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward. This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex. Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

</div>
</div>
<a id="ae944375afbf9370708422e520c6969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944375afbf9370708422e520c6969e5">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00251">251</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1e3477908d71618cfc0c2de81e8ad474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3477908d71618cfc0c2de81e8ad474">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00273">273</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a135ea318fa52e685c30d4cd038a017ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ea318fa52e685c30d4cd038a017ac">&#9670;&nbsp;</a></span>sub_manifold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; chartdim, chartdim &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, spacedim, chartdim &gt;::sub_manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The sub_manifold object is used to compute the average of the points in the chart coordinates system. In an ideal world, it would have type FlatManifold&lt;dim,chartdim&gt;. However, this would instantiate cases where dim&gt;spacedim, which leads to invalid situations. We instead use &lt;chartdim,chartdim&gt;, which is (i) always valid, and (ii) does not matter at all since the first (dim) argument of manifolds is, in fact, ignored as far as manifold functionality is concerned. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l01650">1650</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/opencascade/<a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a></li>
<li>source/opencascade/<a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
