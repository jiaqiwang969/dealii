<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataPostprocessorVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataPostprocessorVector&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataPostprocessorVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessorVector&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output This module collects the classes used for reading</a> &raquo; <a class="el" href="group__output.html">Graphical output deal.II generates three types of output:</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2data__postprocessor_8h_source.html">deal.II/numerics/data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessorVector&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a81bbf4fb831c7f87d3fd5cd0a1f0934d">DataPostprocessorVector</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;<a class="el" href="classDataPostprocessorVector.html#ae0e5c52611834f93716241b34d8fd85d">name</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html#ab5d251ebd553d365c5d97be5bc86ea87">update_flags</a>)</td></tr>
<tr class="separator:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350aec4ea84ab349ce6813f4a76d75cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a350aec4ea84ab349ce6813f4a76d75cb">get_names</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a350aec4ea84ab349ce6813f4a76d75cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54b87c6838f11069cdee5cc387f8959"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#ad54b87c6838f11069cdee5cc387f8959">get_data_component_interpretation</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:ad54b87c6838f11069cdee5cc387f8959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448822561480fa0ed83e94c8953c0ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a448822561480fa0ed83e94c8953c0ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a81bbf4fb831c7f87d3fd5cd0a1f0934d">DataPostprocessorVector</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;<a class="el" href="classDataPostprocessorVector.html#ae0e5c52611834f93716241b34d8fd85d">name</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html#ab5d251ebd553d365c5d97be5bc86ea87">update_flags</a>)</td></tr>
<tr class="separator:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6a2bca455092fc9d4c93fb35f8641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a12e6a2bca455092fc9d4c93fb35f8641">get_names</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a12e6a2bca455092fc9d4c93fb35f8641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007b3b1aae1b6976ad0f64950d42ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a3007b3b1aae1b6976ad0f64950d42ace">get_data_component_interpretation</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a3007b3b1aae1b6976ad0f64950d42ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04081244eaff01b9757af281ca8123b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a04081244eaff01b9757af281ca8123b2">get_needed_update_flags</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a04081244eaff01b9757af281ca8123b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a81bbf4fb831c7f87d3fd5cd0a1f0934d">DataPostprocessorVector</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;<a class="el" href="classDataPostprocessorVector.html#ae0e5c52611834f93716241b34d8fd85d">name</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html#ab5d251ebd553d365c5d97be5bc86ea87">update_flags</a>)</td></tr>
<tr class="separator:a81bbf4fb831c7f87d3fd5cd0a1f0934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6a2bca455092fc9d4c93fb35f8641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a12e6a2bca455092fc9d4c93fb35f8641">get_names</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a12e6a2bca455092fc9d4c93fb35f8641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007b3b1aae1b6976ad0f64950d42ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a3007b3b1aae1b6976ad0f64950d42ace">get_data_component_interpretation</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a3007b3b1aae1b6976ad0f64950d42ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04081244eaff01b9757af281ca8123b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#a04081244eaff01b9757af281ca8123b2">get_needed_update_flags</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a04081244eaff01b9757af281ca8123b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a3a2cd25375af88b518b489b3f47ad0d4">evaluate_scalar_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a3a2cd25375af88b518b489b3f47ad0d4">evaluate_scalar_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba57b598d24d64365d469a854271c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a1ba57b598d24d64365d469a854271c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1bbafe00fba18dd906adc1e1dec29b25">evaluate_vector_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1bbafe00fba18dd906adc1e1dec29b25">evaluate_vector_field</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;input_data, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;computed_quantities) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae0e5c52611834f93716241b34d8fd85d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#ae0e5c52611834f93716241b34d8fd85d">name</a></td></tr>
<tr class="separator:ae0e5c52611834f93716241b34d8fd85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d251ebd553d365c5d97be5bc86ea87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorVector.html#ab5d251ebd553d365c5d97be5bc86ea87">update_flags</a></td></tr>
<tr class="separator:ab5d251ebd553d365c5d97be5bc86ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, std::string, std::string,&lt;&lt; &quot;Object <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg2&lt;&lt; &quot; is still <a class="el" href="kinsol__0_8txt.html#a19e73f3d7e2bbefc4ec076d97de80570">used</a> <a class="el" href="data__out__dof__data__0_8txt.html#a17832850ea240be223f45ca3fc9e3ad8">by</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\<a class="el" href="tensor__polynomials__base__0_8txt.html#afdd52dfdef2425462b558c76cd7a3c49">n\n</a>&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> <a class="el" href="any__data__0_8txt.html#ac7bd1b0fa154f30c162b019580dacc97">entry</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> Frequently Asked Questions <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> &quot;&lt;&lt; &quot;<a class="el" href="petsc__matrix__base__0_8txt.html#aeb98faf2dc1f3bc185b173eaba26928b">deal.II</a> (linked <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="matrix__free__0_8txt.html#a415c819fcc6f671265057640dc18ad44">from</a> http://www.dealii.org/) <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> &quot;&lt;&lt; &quot;<a class="el" href="vector__tools__constraints__0_8txt.html#a5bb8955c98135fbb60012ceeee4b7839">a</a> lot <a class="el" href="petsc__matrix__base__0_8txt.html#a91d0bc46add3efe5a167829805522d28">more</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a> <a class="el" href="data__postprocessor__0_8txt.html#a232fd208d0a301873073f51d8474883a">on</a> what <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="vector__tools__integrate__difference__0_8txt.html#a314323b5102f87ea7e2b4a1aba773b82">error</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a767c487cfadd1a8705c06e38b12838d5">means</a> <a class="el" href="histogram__0_8txt.html#a289e95579c441f9a994ce0a00f5a114a">and</a> &quot;&lt;&lt; &quot;<a class="el" href="fe__poly__tensor__0_8txt.html#a698742fc4e3c5d9a3746b1a9703c1045">how</a> <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> fix <a class="el" href="vector__0_8txt.html#a32dac5cdfac1128c9e998de82a6f4d51">programs</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="function__restriction__0_8txt.html#a79f2798b238440d7e1841d2cf4711885">which</a> <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">object</a> <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> cannot <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a> unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, std::string, std::string,&lt;&lt; &quot;Object <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg2&lt;&lt; &quot; is still <a class="el" href="kinsol__0_8txt.html#a19e73f3d7e2bbefc4ec076d97de80570">used</a> <a class="el" href="data__out__dof__data__0_8txt.html#a17832850ea240be223f45ca3fc9e3ad8">by</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\<a class="el" href="tensor__polynomials__base__0_8txt.html#afdd52dfdef2425462b558c76cd7a3c49">n\n</a>&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> <a class="el" href="any__data__0_8txt.html#ac7bd1b0fa154f30c162b019580dacc97">entry</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> Frequently Asked Questions <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> &quot;&lt;&lt; &quot;<a class="el" href="petsc__matrix__base__0_8txt.html#aeb98faf2dc1f3bc185b173eaba26928b">deal.II</a> (linked <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="matrix__free__0_8txt.html#a415c819fcc6f671265057640dc18ad44">from</a> http://www.dealii.org/) <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> &quot;&lt;&lt; &quot;<a class="el" href="vector__tools__constraints__0_8txt.html#a5bb8955c98135fbb60012ceeee4b7839">a</a> lot <a class="el" href="petsc__matrix__base__0_8txt.html#a91d0bc46add3efe5a167829805522d28">more</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a> <a class="el" href="data__postprocessor__0_8txt.html#a232fd208d0a301873073f51d8474883a">on</a> what <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="vector__tools__integrate__difference__0_8txt.html#a314323b5102f87ea7e2b4a1aba773b82">error</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a767c487cfadd1a8705c06e38b12838d5">means</a> <a class="el" href="histogram__0_8txt.html#a289e95579c441f9a994ce0a00f5a114a">and</a> &quot;&lt;&lt; &quot;<a class="el" href="fe__poly__tensor__0_8txt.html#a698742fc4e3c5d9a3746b1a9703c1045">how</a> <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> fix <a class="el" href="vector__0_8txt.html#a32dac5cdfac1128c9e998de82a6f4d51">programs</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="function__restriction__0_8txt.html#a79f2798b238440d7e1841d2cf4711885">which</a> <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">object</a> <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> cannot <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a> unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
class DataPostprocessorVector&lt; dim &gt;</h3>

<p>This class provides a simpler interface to the functionality offered by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class in case one wants to compute only a single vector quantity (defined as having exactly <code>dim</code> components) from the finite element field passed to the <a class="el" href="classDataOut.html">DataOut</a> class. For this particular case, it is clear what the returned value of <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor::get_data_component_interpretation()</a> should be and we pass the values returned by <a class="el" href="classDataPostprocessorVector.html#a350aec4ea84ab349ce6813f4a76d75cb">get_names()</a> and <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags()</a> to the constructor so that derived classes do not have to implement these functions by hand. All derived classes have to do is implement a constructor and overload either <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> as discussed in the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class's documentation. An example of how the closely related class <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> is used can be found in <a class="el" href="step_29.html">step-29</a> . An example of how the <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> class can be used is found in the documentation of that class.</p>
<h3>An example </h3>
<p>A common example of what one wants to do with postprocessors is to visualize not just the value of the solution, but the gradient. This is, in fact, precisely what <a class="el" href="step_19.html">step-19</a> needs, and it consequently uses the code below almost verbatim. Let's, for simplicity, assume that you have only a scalar solution. In fact, because it's readily available, let us simply take the <a class="el" href="step_6.html">step-6</a> solver to produce such a scalar solution. The gradient is a vector (with exactly <code>dim</code> components), so the current class fits the bill to produce the gradient through postprocessing. Then, the following code snippet implements everything you need to have to visualize the gradient:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>GradientPostprocessor : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">GradientPostprocessor ()</div>
<div class="line">  :</div>
<div class="line">  <span class="comment">// call the constructor of the base class. call the variable to</span></div>
<div class="line">  <span class="comment">// be output &quot;grad_u&quot; and make sure that DataOut provides us</span></div>
<div class="line">  <span class="comment">// with the gradients:</span></div>
<div class="line">  <a class="code" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt; (<span class="stringliteral">&quot;grad_u&quot;</span>,</div>
<div class="line">                                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">virtual</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field</a></div>
<div class="line">(<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar&lt;dim&gt;</a> &amp;input_data,</div>
<div class="line"> <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="comment">// ensure that there really are as many output slots</span></div>
<div class="line">  <span class="comment">// as there are points at which DataOut provides the</span></div>
<div class="line">  <span class="comment">// gradients:</span></div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (input_data.<a class="code" href="structDataPostprocessorInputs_1_1Scalar.html#a43cf8ae15e93c88dc41aed35b42eadd3">solution_gradients</a>.size(),</div>
<div class="line">                   computed_quantities.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// then loop over all of these inputs:</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>=0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>&lt;input_data.<a class="code" href="structDataPostprocessorInputs_1_1Scalar.html#a43cf8ae15e93c88dc41aed35b42eadd3">solution_gradients</a>.size(); ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// ensure that each output slot has exactly &#39;dim&#39;</span></div>
<div class="line">      <span class="comment">// components (as should be expected, given that we</span></div>
<div class="line">      <span class="comment">// want to create vector-valued outputs), and copy the</span></div>
<div class="line">      <span class="comment">// gradients of the solution at the evaluation points</span></div>
<div class="line">      <span class="comment">// into the output slots:</span></div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (computed_quantities[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">        computed_quantities[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>]</div>
<div class="line">          = input_data.<a class="code" href="structDataPostprocessorInputs_1_1Scalar.html#a43cf8ae15e93c88dc41aed35b42eadd3">solution_gradients</a>[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>];</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">};</div>
</div><!-- fragment --><p> The only thing that is necessary is to add another output to the call of DataOut::add_vector() in the <code><a class="el" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run()</a></code> function of the <code><a class="el" href="classStep6.html">Step6</a></code> class of that example program. The corresponding code snippet would then look like this (where we also use VTU as the file format to output the data):</p>
<div class="fragment"><div class="line">GradientPostprocessor&lt;dim&gt; gradient_postprocessor;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, gradient_postprocessor);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> ();</div>
<div class="line"> </div>
<div class="line">std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a> (<span class="stringliteral">&quot;solution.vtu&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
</div><!-- fragment --><p>This leads to the following output for the solution and the gradients (you may want to compare with the solution shown in the results section of <a class="el" href="step_6.html">step-6</a> ; the current data is generated on a coarser mesh for simplicity): </p><div class="image">
<img src="data_postprocessor_vector_0.png" alt=""/>
<div class="caption">
<div class="image">
<img src="data_postprocessor_vector_1.png" alt=""/>
</div>
 In the second image, the background color corresponds to the magnitude of the gradient vector and the vector glyphs to the gradient itself. It may be surprising at first to see that from each vertex, multiple vectors originate, going in different directions. But that is because the solution is only continuous: in general, the gradient is discontinuous across edges, and so the multiple vectors originating from each vertex simply represent the differing gradients of the solution at each adjacent cell. The output above above namely, the gradient \(\nabla u\) of the solution solution corresponds to the temperature gradient if one interpreted @ref step_6 "step-6" as solving a steady-state heat transfer problem. It is very small in the central part of the domain because in @ref step_6 "step-6" we are solving an equation that has a coefficient \(a(\mathbf x)\) that is large in the central part and small on the outside. This can be thought as a material that conducts heat well, and consequently the temperature gradient is small. On the other hand, the "heat flux" corresponds to the quantity \(a(\mathbf x) \nabla u(\mathbf x)\) . For the solution of that equation, the flux should be continuous across the interface. This is easily verified by the following modification of the postprocessor: @code template int class HeatFluxPostprocessor : public DataPostprocessorVector&lt;dim&gt; { public: HeatFluxPostprocessor () : // like above, but now also make sure that <a class="el" href="classDataOut.html">DataOut</a> provides // us with coordinates of the evaluation points: DataPostprocessorVector&lt;dim&gt; ("heat_flux", update_gradients | update_quadrature_points) {} virtual void evaluate_scalar_field (const DataPostprocessorInputs::Scalar&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { AssertDimension (computed_quantities[p].<a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a>, dim); for (unsigned int d=0; d&lt;dim; ++d) // like above, but also multiply the gradients with // the coefficient evaluated at the current point: computed_quantities[p][d] = coefficient (input_data.evaluation_points[p]) input_data.solution_gradients[p][d]; } } }; @endcode With this postprocessor, we get the following picture of the heat flux: <div class="image">
<img src="data_postprocessor_vector_2.png" alt=""/>
</div>
 As the background color shows, the gradient times the coefficient is now a continuous function. There are (large) vectors around the interface where the coefficient jumps (at half the distance between the center of the disk to the perimeter) that seem to point in the wrong direction; this is an artifact of the fact that the solution has a discontinuous gradient at these points and that the numerical solution on the current grid does not adequately resolve this interface. This, however, is not important to the current discussion.  h3 Extension to the gradients of vector-valued problems h3 The example above uses a scalar solution and its gradient as an example. On the other hand, one may want to do something similar for the gradient of a vector-valued displacement field (such as the strain or stress of a displacement field, like those computed in @ref step_8 "step-8" , @ref step_17 "step-17" , @ref step_18 "step-18" , or @ref step_44 "step-44" ). In that case, the solution is already vector valued and the stress is a (symmetric) tensor. deal.II does not currently support outputting tensor-valued quantities, but they can of course be output as a collection of scalar-valued components of the tensor. This can be facilitated using the <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> class. The documentation of that class contains an example. This class provides a simpler interface to the functionality offered by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class in case one wants to compute only a single vector quantity (defined as having exactly <code>dim</code> components) from the finite element field passed to the <a class="el" href="classDataOut.html">DataOut</a> class. For this particular case, it is clear what the returned value of <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor::get_data_component_interpretation()</a> should be and we pass the values returned by <a class="el" href="classDataPostprocessorVector.html#a350aec4ea84ab349ce6813f4a76d75cb">get_names()</a> and <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags()</a> to the constructor so that derived classes do not have to implement these functions by hand. All derived classes have to do is implement a constructor and overload either <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> as discussed in the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class's documentation. An example of how the closely related class <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> is used can be found in @ref step_29 "step-29". An example of how the <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> class can be used is found in the documentation of that class. h3 An example h3 A common example of what one wants to do with postprocessors is to visualize not just the value of the solution, but the gradient. This is, in fact, precisely what @ref step_19 "step-19" needs, and it consequently uses the code below almost verbatim. Let's, for simplicity, assume that you have only a scalar solution. In fact, because it's readily available, let us simply take the @ref step_6 "step-6" solver to produce such a scalar solution. The gradient is a vector (with exactly <code>dim</code> components), so the current class fits the bill to produce the gradient through postprocessing. Then, the following code snippet implements everything you need to have to visualize the gradient: @code template int class GradientPostprocessor : public DataPostprocessorVector&lt;dim&gt; { public: GradientPostprocessor () : // call the constructor of the base class. call the variable to // be output "grad_u" and make sure that <a class="el" href="classDataOut.html">DataOut</a> provides us // with the gradients: DataPostprocessorVector&lt;dim&gt; ("grad_u", update_gradients) {}  virtual void evaluate_scalar_field (const DataPostprocessorInputs::Scalar&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { // ensure that there really are as many output slots // as there are points at which <a class="el" href="classDataOut.html">DataOut</a> provides the // gradients: AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  // then loop over all of these inputs: for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { // ensure that each output slot has exactly 'dim' // components (as should be expected, given that we // want to create vector-valued outputs), and copy the // gradients of the solution at the evaluation points // into the output slots: AssertDimension (computed_quantities[p].<a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a>, dim); for (unsigned int d=0; d&lt;dim; ++d) computed_quantities[p][d] = input_data.solution_gradients[p][d]; } } }; @endcode The only thing that is necessary is to add another output to the call of DataOut::add_vector() in the <code><a class="el" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run()</a></code> function of the <code><a class="el" href="classStep6.html">Step6</a></code> class of that example program. The corresponding code snippet would then look like this (where we also use VTU as the file format to output the data): @code GradientPostprocessor&lt;dim&gt; gradient_postprocessor;  <a class="el" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; data_out.attach_dof_handler (dof_handler); data_out.add_data_vector (solution, "solution"); data_out.add_data_vector (solution, gradient_postprocessor); data_out.build_patches ();  std::ofstream output ("solution.vtu"); data_out.write_vtu (output); @endcode This leads to the following output for the solution and the gradients (you may want to compare with the solution shown in the results section of @ref step_6 "step-6"; the current data is generated on a coarser mesh for simplicity): <div class="image">
<img src="data_postprocessor_vector_0.png" alt=""/>
</div>
 <div class="image">
<img src="data_postprocessor_vector_1.png" alt=""/>
</div>
 In the second image, the background color corresponds to the magnitude of the gradient vector and the vector glyphs to the gradient itself. It may be surprising at first to see that from each vertex, multiple vectors originate, going in different directions. But that is because the solution is only continuous: in general, the gradient is discontinuous across edges, and so the multiple vectors originating from each vertex simply represent the differing gradients of the solution at each adjacent cell. The output above &ndash; namely, the gradient \(\nabla u\) of the solution &ndash; corresponds to the temperature gradient if one interpreted @ref step_6 "step-6" as solving a steady-state heat transfer problem. It is very small in the central part of the domain because in @ref step_6 "step-6" we are solving an equation that has a coefficient \(a(\mathbf x)\) that is large in the central part and small on the outside. This can be thought as a material that conducts heat well, and consequently the temperature gradient is small. On the other hand, the "heat flux" corresponds to the quantity \(a(\mathbf x) \nabla u(\mathbf x)\). For the solution of that equation, the flux should be continuous across the interface. This is easily verified by the following modification of the postprocessor: @code template int class HeatFluxPostprocessor : public DataPostprocessorVector&lt;dim&gt; { public: HeatFluxPostprocessor () : // like above, but now also make sure that <a class="el" href="classDataOut.html">DataOut</a> provides // us with coordinates of the evaluation points: DataPostprocessorVector&lt;dim&gt; ("heat_flux", update_gradients | update_quadrature_points) {}  virtual void evaluate_scalar_field (const DataPostprocessorInputs::Scalar&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { AssertDimension (computed_quantities[p].<a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a>, dim); for (unsigned int d=0; d&lt;dim; ++d) // like above, but also multiply the gradients with // the coefficient evaluated at the current point: computed_quantities[p][d] = coefficient (input_data.evaluation_points[p]) * input_data.solution_gradients[p][d]; } } }; @endcode With this postprocessor, we get the following picture of the heat flux: <div class="image">
<img src="data_postprocessor_vector_2.png" alt=""/>
</div>
 As the background color shows, the gradient times the coefficient is now a continuous function. There are (large) vectors around the interface where the coefficient jumps (at half the distance between the center of the disk to the perimeter) that seem to point in the wrong direction; this is an artifact of the fact that the solution has a discontinuous gradient at these points and that the numerical solution on the current grid does not adequately resolve this interface. This, however, is not important to the current discussion. h3 Extension to the gradients of vector-valued problems h3 The example above uses a scalar solution and its gradient as an example. On the other hand, one may want to do something similar for the gradient of a vector-valued displacement field (such as the strain or stress of a displacement field, like those computed in @ref step_8 "step-8", @ref step_17 "step-17", @ref step_18 "step-18", or @ref step_44 "step-44"). In that case, the solution is already vector valued and the stress is a (symmetric) tensor. deal.II does not currently support outputting tensor-valued quantities, but they can of course be output as a collection of scalar-valued components of the tensor. This can be facilitated using the <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> class. The documentation of that class contains an example. </div></div>

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l00833">833</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a81bbf4fb831c7f87d3fd5cd0a1f0934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bbf4fb831c7f87d3fd5cd0a1f0934d">&#9670;&nbsp;</a></span>DataPostprocessorVector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::<a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files.</td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00099">99</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a81bbf4fb831c7f87d3fd5cd0a1f0934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bbf4fb831c7f87d3fd5cd0a1f0934d">&#9670;&nbsp;</a></span>DataPostprocessorVector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::<a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files. </td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81bbf4fb831c7f87d3fd5cd0a1f0934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bbf4fb831c7f87d3fd5cd0a1f0934d">&#9670;&nbsp;</a></span>DataPostprocessorVector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::<a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files.</td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a350aec4ea84ab349ce6813f4a76d75cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350aec4ea84ab349ce6813f4a76d75cb">&#9670;&nbsp;</a></span>get_names() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::string &gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00110">110</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="ad54b87c6838f11069cdee5cc387f8959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54b87c6838f11069cdee5cc387f8959">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_data_component_interpretation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00119">119</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a448822561480fa0ed83e94c8953c0ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448822561480fa0ed83e94c8953c0ae7">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_needed_update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00128">128</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a12e6a2bca455092fc9d4c93fb35f8641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e6a2bca455092fc9d4c93fb35f8641">&#9670;&nbsp;</a></span>get_names() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;std::string&gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a3007b3b1aae1b6976ad0f64950d42ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3007b3b1aae1b6976ad0f64950d42ace">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a04081244eaff01b9757af281ca8123b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04081244eaff01b9757af281ca8123b2">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a12e6a2bca455092fc9d4c93fb35f8641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e6a2bca455092fc9d4c93fb35f8641">&#9670;&nbsp;</a></span>get_names() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;std::string&gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a3007b3b1aae1b6976ad0f64950d42ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3007b3b1aae1b6976ad0f64950d42ace">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a04081244eaff01b9757af281ca8123b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04081244eaff01b9757af281ca8123b2">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a07ebcf764cf911c6d78f21c32ea1d2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ebcf764cf911c6d78f21c32ea1d2d0">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function. The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data</p>
<ul>
<li>in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state. This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </li>
</ul>

<p>Reimplemented in <a class="el" href="classStep19_1_1ElectricFieldPostprocessor.html#af2ddd057a3ba7a473365063096f82b69">Step19::ElectricFieldPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00026">26</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a3a2cd25375af88b518b489b3f47ad0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2cd25375af88b518b489b3f47ad0d4">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function.</p>
<p>The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data &ndash; in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state.</p>
<p>This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </p>

<p>Reimplemented in <a class="el" href="classStep19_1_1ElectricFieldPostprocessor.html#af2ddd057a3ba7a473365063096f82b69">Step19::ElectricFieldPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a3a2cd25375af88b518b489b3f47ad0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2cd25375af88b518b489b3f47ad0d4">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function. The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data</p>
<ul>
<li>in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state. This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </li>
</ul>

<p>Reimplemented in <a class="el" href="classStep19_1_1ElectricFieldPostprocessor.html#af2ddd057a3ba7a473365063096f82b69">Step19::ElectricFieldPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a1ba57b598d24d64365d469a854271c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba57b598d24d64365d469a854271c68">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

<p>Reimplemented in <a class="el" href="classStep32_1_1BoussinesqFlowProblem_1_1Postprocessor.html#af59eda5009ba8cc97addae7bfb05c912">Step32::BoussinesqFlowProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ab42b41fd08efc777196bde20437c6635">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ac57f3e6465809755e6ed91a2c0c07b2d">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexPhase.html#abd971a929cbda4a29ddaf88f90716ec6">Step58::DataPostprocessors::ComplexPhase&lt; dim &gt;</a>, <a class="el" href="classStep33_1_1EulerEquations_1_1Postprocessor.html#a94a51ccee44f0bdf99dff9e6c4050878">Step33::EulerEquations&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexAmplitude.html#a76fbb91a8c5b9081b9de13029faee090">Step58::DataPostprocessors::ComplexAmplitude&lt; dim &gt;</a>, and <a class="el" href="classStep29_1_1ComputeIntensity.html#abc596d26cc9435a19135c2110d05946a">Step29::ComputeIntensity&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00037">37</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a1bbafe00fba18dd906adc1e1dec29b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbafe00fba18dd906adc1e1dec29b25">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

<p>Reimplemented in <a class="el" href="classStep32_1_1BoussinesqFlowProblem_1_1Postprocessor.html#af59eda5009ba8cc97addae7bfb05c912">Step32::BoussinesqFlowProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ab42b41fd08efc777196bde20437c6635">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ac57f3e6465809755e6ed91a2c0c07b2d">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexPhase.html#abd971a929cbda4a29ddaf88f90716ec6">Step58::DataPostprocessors::ComplexPhase&lt; dim &gt;</a>, <a class="el" href="classStep33_1_1EulerEquations_1_1Postprocessor.html#a94a51ccee44f0bdf99dff9e6c4050878">Step33::EulerEquations&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexAmplitude.html#a76fbb91a8c5b9081b9de13029faee090">Step58::DataPostprocessors::ComplexAmplitude&lt; dim &gt;</a>, and <a class="el" href="classStep29_1_1ComputeIntensity.html#abc596d26cc9435a19135c2110d05946a">Step29::ComputeIntensity&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a1bbafe00fba18dd906adc1e1dec29b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbafe00fba18dd906adc1e1dec29b25">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

<p>Reimplemented in <a class="el" href="classStep32_1_1BoussinesqFlowProblem_1_1Postprocessor.html#af59eda5009ba8cc97addae7bfb05c912">Step32::BoussinesqFlowProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ab42b41fd08efc777196bde20437c6635">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classEuler__DG_1_1EulerProblem_1_1Postprocessor.html#ac57f3e6465809755e6ed91a2c0c07b2d">Euler_DG::EulerProblem&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexPhase.html#abd971a929cbda4a29ddaf88f90716ec6">Step58::DataPostprocessors::ComplexPhase&lt; dim &gt;</a>, <a class="el" href="classStep33_1_1EulerEquations_1_1Postprocessor.html#a94a51ccee44f0bdf99dff9e6c4050878">Step33::EulerEquations&lt; dim &gt;::Postprocessor</a>, <a class="el" href="classStep58_1_1DataPostprocessors_1_1ComplexAmplitude.html#a76fbb91a8c5b9081b9de13029faee090">Step58::DataPostprocessors::ComplexAmplitude&lt; dim &gt;</a>, and <a class="el" href="classStep29_1_1ComputeIntensity.html#abc596d26cc9435a19135c2110d05946a">Step29::ComputeIntensity&lt; dim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae0e5c52611834f93716241b34d8fd85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e5c52611834f93716241b34d8fd85d">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies of the two arguments given to the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l00889">889</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<a id="ab5d251ebd553d365c5d97be5bc86ea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d251ebd553d365c5d97be5bc86ea87">&#9670;&nbsp;</a></span>update_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l00890">890</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
<li>source/numerics/<a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassDataPostprocessorVector_html"><div class="ttname"><a href="classDataPostprocessorVector.html">DataPostprocessorVector</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00833">data_postprocessor.h:833</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_afec1b694405cadb2d251275096ad3563"><div class="ttname"><a href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data output</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00059">distributed_0.txt:59</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Scalar_html_a43cf8ae15e93c88dc41aed35b42eadd3"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Scalar.html#a43cf8ae15e93c88dc41aed35b42eadd3">DataPostprocessorInputs::Scalar::solution_gradients</a></div><div class="ttdeci">std::vector&lt; Tensor&lt; 1, spacedim &gt; &gt; solution_gradients</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00264">data_postprocessor.h:264</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_a93c780f93105e0daaa76c6c43694b4ae"><div class="ttname"><a href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a></div><div class="ttdeci">void write_vtu(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07232">data_out_base.cc:7232</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="anumerical__algorithms__0_8txt_html_a852a1e245dd2de4943eeb66beeaf65b1"><div class="ttname"><a href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">vector</a></div><div class="ttdeci">****This module groups a diverse set of classes that generally implement some sort of numerical algorithm on top all the basic and finite element classes in the library They are generally unconnected to each other *Some of the like KellyErrorEstimator and act on solutions already and compute derived quantities in the first two or help transferring a set of vectors from one mesh to another *The namespaces and VectorTools provide an assortment of such as creating a Laplace projecting or interpolating a function onto the present finite element etc The difference to the functions in the DoFTools and FETools functions is that they work on the DoFTools functions only act on a given DoFHandler object without reference to a data vector</div><div class="ttdef"><b>Definition:</b> <a href="numerical__algorithms__0_8txt_source.html#l00008">numerical_algorithms_0.txt:8</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Scalar_html"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00241">data_postprocessor.h:241</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga9442b63275c9ef3fab29bc222831c49c"><div class="ttname"><a href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a></div><div class="ttdeci">#define AssertDimension(dim1, dim2)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01749">exceptions.h:1749</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassDataPostprocessor_html_a07ebcf764cf911c6d78f21c32ea1d2d0"><div class="ttname"><a href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field</a></div><div class="ttdeci">virtual void evaluate_scalar_field(const DataPostprocessorInputs::Scalar&lt; dim &gt; &amp;input_data, std::vector&lt; Vector&lt; double &gt;&gt; &amp;computed_quantities) const</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8cc_source.html#l00026">data_postprocessor.cc:26</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="afunction__0_8txt_html_a4f780342f2d5d632f82cf7fd90158a66"><div class="ttname"><a href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a></div><div class="ttdeci">it defaults to i e the first component **Return all components of a vector valued function at a given point&lt; tt &gt; values&lt;/tt &gt; shall have the right size i e **Set&lt; tt &gt; values&lt;/tt &gt; to the point values of the specified component of the function at the&lt; tt &gt; points&lt;/tt &gt; It is assumed that&lt; tt &gt; values&lt;/tt &gt; already has the right size</div><div class="ttdef"><b>Definition:</b> <a href="function__0_8txt_source.html#l00052">function_0.txt:52</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
