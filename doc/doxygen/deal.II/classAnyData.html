<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classAnyData.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: AnyData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAnyData-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AnyData Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="algorithms_2any__data_8h_source.html">deal.II/algorithms/any_data.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AnyData:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad957320a535faed4175468bd0c765850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#ad957320a535faed4175468bd0c765850">AnyData</a> ()=default</td></tr>
<tr class="memdesc:ad957320a535faed4175468bd0c765850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty object.  <a href="classAnyData.html#ad957320a535faed4175468bd0c765850">More...</a><br /></td></tr>
<tr class="separator:ad957320a535faed4175468bd0c765850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a> (type <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a>, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a5949f684f8ce7ccce9d45e65af32580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new data object.  <a href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">More...</a><br /></td></tr>
<tr class="separator:a5949f684f8ce7ccce9d45e65af32580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43273f02653f364163ede364d2f29d97"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a43273f02653f364163ede364d2f29d97"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a43273f02653f364163ede364d2f29d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident.  <a href="classAnyData.html#a43273f02653f364163ede364d2f29d97">More...</a><br /></td></tr>
<tr class="separator:a43273f02653f364163ede364d2f29d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82d2937c524aa75857180b88fca34b1"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ac82d2937c524aa75857180b88fca34b1"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ac82d2937c524aa75857180b88fca34b1">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:ac82d2937c524aa75857180b88fca34b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2e0522f7e4f244395d3f25981a75f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a21b2e0522f7e4f244395d3f25981a75f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a21b2e0522f7e4f244395d3f25981a75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned.  <a href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f">More...</a><br /></td></tr>
<tr class="separator:a21b2e0522f7e4f244395d3f25981a75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ffef0112889ff54d74020fd60892d9"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ac8ffef0112889ff54d74020fd60892d9"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ac8ffef0112889ff54d74020fd60892d9">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:ac8ffef0112889ff54d74020fd60892d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#ac8ffef0112889ff54d74020fd60892d9">More...</a><br /></td></tr>
<tr class="separator:ac8ffef0112889ff54d74020fd60892d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5f3e927f4a549ad50dfba9881cb5e1b9">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a5f3e927f4a549ad50dfba9881cb5e1b9">More...</a><br /></td></tr>
<tr class="separator:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#afdff7cb5c4ad6acb67becbb0c0ef44ea">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#afdff7cb5c4ad6acb67becbb0c0ef44ea">More...</a><br /></td></tr>
<tr class="separator:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c3060ecb24b17b4fbb19c297a5186"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a027c3060ecb24b17b4fbb19c297a5186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of object at index.  <a href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">More...</a><br /></td></tr>
<tr class="separator:a027c3060ecb24b17b4fbb19c297a5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad957320a535faed4175468bd0c765850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#ad957320a535faed4175468bd0c765850">AnyData</a> ()=default</td></tr>
<tr class="memdesc:ad957320a535faed4175468bd0c765850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty object.  <a href="classAnyData.html#ad957320a535faed4175468bd0c765850">More...</a><br /></td></tr>
<tr class="separator:ad957320a535faed4175468bd0c765850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a> (type <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a>, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a5949f684f8ce7ccce9d45e65af32580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new data object.  <a href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">More...</a><br /></td></tr>
<tr class="separator:a5949f684f8ce7ccce9d45e65af32580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data.  <a href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">More...</a><br /></td></tr>
<tr class="separator:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5dbb69e8c6746bacdfbf052adeb0a14f">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:aebe567605387d6b3001a0152bec9c6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions.  <a href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">More...</a><br /></td></tr>
<tr class="separator:aebe567605387d6b3001a0152bec9c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">More...</a><br /></td></tr>
<tr class="separator:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a8be2d338e4468cc7c880bef7b96145cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">More...</a><br /></td></tr>
<tr class="separator:a8be2d338e4468cc7c880bef7b96145cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a6a0d816391ae9e016fbd2b9c39bae732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">More...</a><br /></td></tr>
<tr class="separator:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a114aae577fb1ab8addf8d2484171cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of object at index.  <a href="classAnyData.html#a114aae577fb1ab8addf8d2484171cc3a">More...</a><br /></td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca2472f512372a3dd791ed954bab75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">DeclException1</a> (<a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>, std::string,&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;)</td></tr>
<tr class="memdesc:a85ca2472f512372a3dd791ed954bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">More...</a><br /></td></tr>
<tr class="separator:a85ca2472f512372a3dd791ed954bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">DeclException2</a> (<a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>, std::string, std::string,&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;)</td></tr>
<tr class="memdesc:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">More...</a><br /></td></tr>
<tr class="separator:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aa2275d6bf2fbc5379573bd24d7211a61">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad957320a535faed4175468bd0c765850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#ad957320a535faed4175468bd0c765850">AnyData</a> ()=default</td></tr>
<tr class="memdesc:ad957320a535faed4175468bd0c765850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty object.  <a href="classAnyData.html#ad957320a535faed4175468bd0c765850">More...</a><br /></td></tr>
<tr class="separator:ad957320a535faed4175468bd0c765850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a> (type <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a>, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a5949f684f8ce7ccce9d45e65af32580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new data object.  <a href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">More...</a><br /></td></tr>
<tr class="separator:a5949f684f8ce7ccce9d45e65af32580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident.  <a href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">More...</a><br /></td></tr>
<tr class="separator:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5dbb69e8c6746bacdfbf052adeb0a14f">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:aebe567605387d6b3001a0152bec9c6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned.  <a href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">More...</a><br /></td></tr>
<tr class="separator:aebe567605387d6b3001a0152bec9c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">More...</a><br /></td></tr>
<tr class="separator:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a8be2d338e4468cc7c880bef7b96145cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">More...</a><br /></td></tr>
<tr class="separator:a8be2d338e4468cc7c880bef7b96145cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a6a0d816391ae9e016fbd2b9c39bae732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">More...</a><br /></td></tr>
<tr class="separator:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a114aae577fb1ab8addf8d2484171cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of object at index.  <a href="classAnyData.html#a114aae577fb1ab8addf8d2484171cc3a">More...</a><br /></td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca2472f512372a3dd791ed954bab75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">DeclException1</a> (<a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>, std::string,&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;)</td></tr>
<tr class="memdesc:a85ca2472f512372a3dd791ed954bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">More...</a><br /></td></tr>
<tr class="separator:a85ca2472f512372a3dd791ed954bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">DeclException2</a> (<a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>, std::string, std::string,&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;)</td></tr>
<tr class="memdesc:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">More...</a><br /></td></tr>
<tr class="separator:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aa2275d6bf2fbc5379573bd24d7211a61">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a> (std::string arg1)</td></tr>
<tr class="memdesc:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">More...</a><br /></td></tr>
<tr class="separator:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04d4dd43302af21cbd506c1910adeff"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="memdesc:gad04d4dd43302af21cbd506c1910adeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">More...</a><br /></td></tr>
<tr class="separator:gad04d4dd43302af21cbd506c1910adeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1bf38524189d47d6569cbd99f279dc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b1bf38524189d47d6569cbd99f279dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aabd758e5edb9aa0b8f61162095d2eea5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::any &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aabd758e5edb9aa0b8f61162095d2eea5">data</a></td></tr>
<tr class="memdesc:aabd758e5edb9aa0b8f61162095d2eea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stored data.  <a href="classAnyData.html#aabd758e5edb9aa0b8f61162095d2eea5">More...</a><br /></td></tr>
<tr class="separator:aabd758e5edb9aa0b8f61162095d2eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ec93276969816ae67877ee760aa416"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a83ec93276969816ae67877ee760aa416">names</a></td></tr>
<tr class="memdesc:a83ec93276969816ae67877ee760aa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names of the stored data.  <a href="classAnyData.html#a83ec93276969816ae67877ee760aa416">More...</a><br /></td></tr>
<tr class="separator:a83ec93276969816ae67877ee760aa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Store any amount of any type of data accessible by an identifier string. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>GK: Deprecate access to <a class="el" href="classAnyData.html">AnyData</a> by index and change to a map.</dd></dl>
<p>Store any amount of any type of data accessible by an identifier string.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>GK: Deprecate access to <a class="el" href="classAnyData.html">AnyData</a> by index and change to a map. </dd></dl>
<p>Store any amount of any type of data accessible by an identifier string. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>GK: Deprecate access to <a class="el" href="classAnyData.html">AnyData</a> by index and change to a map.</dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00038">38</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad957320a535faed4175468bd0c765850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad957320a535faed4175468bd0c765850">&#9670;&nbsp;</a></span>AnyData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::AnyData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for empty object. </p>

</div>
</div>
<a id="ad957320a535faed4175468bd0c765850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad957320a535faed4175468bd0c765850">&#9670;&nbsp;</a></span>AnyData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::AnyData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for empty object. </p>

</div>
</div>
<a id="ad957320a535faed4175468bd0c765850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad957320a535faed4175468bd0c765850">&#9670;&nbsp;</a></span>AnyData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::AnyData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for empty object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00227">227</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5949f684f8ce7ccce9d45e65af32580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949f684f8ce7ccce9d45e65af32580c">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::add </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new data object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00436">436</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00445">445</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00355">355</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00366">366</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00378">378</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a43273f02653f364163ede364d2f29d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43273f02653f364163ede364d2f29d97">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00389">389</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="ac82d2937c524aa75857180b88fca34b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82d2937c524aa75857180b88fca34b1">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00403">403</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a21b2e0522f7e4f244395d3f25981a75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b2e0522f7e4f244395d3f25981a75f">&#9670;&nbsp;</a></span>try_read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00418">418</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00236">236</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00248">248</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00262">262</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="ac8ffef0112889ff54d74020fd60892d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ffef0112889ff54d74020fd60892d9">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00276">276</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5f3e927f4a549ad50dfba9881cb5e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3e927f4a549ad50dfba9881cb5e1b9">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00290">290</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="afdff7cb5c4ad6acb67becbb0c0ef44ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdff7cb5c4ad6acb67becbb0c0ef44ea">&#9670;&nbsp;</a></span>try_read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00304">304</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a027c3060ecb24b17b4fbb19c297a5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c3060ecb24b17b4fbb19c297a5186">&#9670;&nbsp;</a></span>name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AnyData::name </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of object at index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00315">315</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00336">336</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00323">323</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00347">347</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00457">457</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5949f684f8ce7ccce9d45e65af32580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949f684f8ce7ccce9d45e65af32580c">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::add </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new data object. </p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to stored data object by name. </p>
<p>Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. </p>
<p>Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name. </p>
<p>For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

</div>
</div>
<a id="a8da271ab2d9e4f8b9f9a2fc554b6423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da271ab2d9e4f8b9f9a2fc554b6423a">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. </p>
<p>If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

</div>
</div>
<a id="a5dbb69e8c6746bacdfbf052adeb0a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbb69e8c6746bacdfbf052adeb0a14f">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

</div>
</div>
<a id="aebe567605387d6b3001a0152bec9c6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe567605387d6b3001a0152bec9c6dd">&#9670;&nbsp;</a></span>try_read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. </p>
<p>This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

</div>
</div>
<a id="af0b46ccd9afa63924bf5df7d9a3f3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b46ccd9afa63924bf5df7d9a3f3543">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

</div>
</div>
<a id="a8be2d338e4468cc7c880bef7b96145cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be2d338e4468cc7c880bef7b96145cf">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

</div>
</div>
<a id="a6a0d816391ae9e016fbd2b9c39bae732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d816391ae9e016fbd2b9c39bae732">&#9670;&nbsp;</a></span>try_read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of object at index. </p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index of a named object. </p>
<p>Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find index of a named object. </p>
<p>Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

</div>
</div>
<a id="a85ca2472f512372a3dd791ed954bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca2472f512372a3dd791ed954bab75">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object. </p>

</div>
</div>
<a id="a61ed0e0c2cee64500104f14edb7bb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed0e0c2cee64500104f14edb7bb4ea">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The requested type and the stored type are different. </p>

</div>
</div>
<a id="aa2275d6bf2fbc5379573bd24d7211a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2275d6bf2fbc5379573bd24d7211a61">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception indicating that a function expected a vector to have a certain name, but we store a different name in that position. </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5949f684f8ce7ccce9d45e65af32580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949f684f8ce7ccce9d45e65af32580c">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::add </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new data object. </p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

</div>
</div>
<a id="a8da271ab2d9e4f8b9f9a2fc554b6423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da271ab2d9e4f8b9f9a2fc554b6423a">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

</div>
</div>
<a id="a5dbb69e8c6746bacdfbf052adeb0a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbb69e8c6746bacdfbf052adeb0a14f">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

</div>
</div>
<a id="aebe567605387d6b3001a0152bec9c6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe567605387d6b3001a0152bec9c6dd">&#9670;&nbsp;</a></span>try_read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

</div>
</div>
<a id="af0b46ccd9afa63924bf5df7d9a3f3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b46ccd9afa63924bf5df7d9a3f3543">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

</div>
</div>
<a id="a8be2d338e4468cc7c880bef7b96145cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be2d338e4468cc7c880bef7b96145cf">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

</div>
</div>
<a id="a6a0d816391ae9e016fbd2b9c39bae732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d816391ae9e016fbd2b9c39bae732">&#9670;&nbsp;</a></span>try_read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of object at index. </p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

</div>
</div>
<a id="a85ca2472f512372a3dd791ed954bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca2472f512372a3dd791ed954bab75">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object. </p>

</div>
</div>
<a id="a61ed0e0c2cee64500104f14edb7bb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed0e0c2cee64500104f14edb7bb4ea">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The requested type and the stored type are different. </p>

</div>
</div>
<a id="aa2275d6bf2fbc5379573bd24d7211a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2275d6bf2fbc5379573bd24d7211a61">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception indicating that a function expected a vector to have a certain name, but we store a different name in that position. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aabd758e5edb9aa0b8f61162095d2eea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd758e5edb9aa0b8f61162095d2eea5">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::any &gt; AnyData::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The stored data. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00221">221</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a83ec93276969816ae67877ee760aa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ec93276969816ae67877ee760aa416">&#9670;&nbsp;</a></span>names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; AnyData::names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The names of the stored data. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00223">223</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/algorithms/<a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
