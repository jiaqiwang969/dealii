<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structGeometryInfo_3_010_01_4.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GeometryInfo&lt; 0 &gt; Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structGeometryInfo_3_010_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GeometryInfo&lt; 0 &gt; Struct Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a> &#124; <a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2geometry__info_8h_source.html">deal.II/base/geometry_info.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a729177bef0f761e78c047f6f4d4068d0"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a729177bef0f761e78c047f6f4d4068d0">face_indices</a> ()</td></tr>
<tr class="separator:a729177bef0f761e78c047f6f4d4068d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a43f5e06a7f78cd02551e155d612e4eb8">n_children</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;refinement_case)</td></tr>
<tr class="separator:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a620b2a110dabe4b2e744ab47593c8aa5">vertex_indices</a> ()</td></tr>
<tr class="separator:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a4812a970618d9a3e8a2441c75d78f9d7">face_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb37631fb21d083cc01976c7e846b4d"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#abeb37631fb21d083cc01976c7e846b4d">face_to_cell_lines</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:abeb37631fb21d083cc01976c7e846b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729177bef0f761e78c047f6f4d4068d0"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a729177bef0f761e78c047f6f4d4068d0">face_indices</a> ()</td></tr>
<tr class="separator:a729177bef0f761e78c047f6f4d4068d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a43f5e06a7f78cd02551e155d612e4eb8">n_children</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;refinement_case)</td></tr>
<tr class="separator:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a620b2a110dabe4b2e744ab47593c8aa5">vertex_indices</a> ()</td></tr>
<tr class="separator:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a4812a970618d9a3e8a2441c75d78f9d7">face_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb37631fb21d083cc01976c7e846b4d"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#abeb37631fb21d083cc01976c7e846b4d">face_to_cell_lines</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:abeb37631fb21d083cc01976c7e846b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729177bef0f761e78c047f6f4d4068d0"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a729177bef0f761e78c047f6f4d4068d0">face_indices</a> ()</td></tr>
<tr class="separator:a729177bef0f761e78c047f6f4d4068d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a43f5e06a7f78cd02551e155d612e4eb8">n_children</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;refinement_case)</td></tr>
<tr class="separator:a43f5e06a7f78cd02551e155d612e4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a620b2a110dabe4b2e744ab47593c8aa5">vertex_indices</a> ()</td></tr>
<tr class="separator:a620b2a110dabe4b2e744ab47593c8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a4812a970618d9a3e8a2441c75d78f9d7">face_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a4812a970618d9a3e8a2441c75d78f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb37631fb21d083cc01976c7e846b4d"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#abeb37631fb21d083cc01976c7e846b4d">face_to_cell_lines</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:abeb37631fb21d083cc01976c7e846b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa44c204ff01441f8f720e920df15e803"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#aa44c204ff01441f8f720e920df15e803">max_children_per_cell</a> = 1</td></tr>
<tr class="separator:aa44c204ff01441f8f720e920df15e803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf057e2a19ee1ded244f00087c318873"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#abf057e2a19ee1ded244f00087c318873">faces_per_cell</a> = 0</td></tr>
<tr class="separator:abf057e2a19ee1ded244f00087c318873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab204ab8cf931ff1fbccdabfafad936c6"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#ab204ab8cf931ff1fbccdabfafad936c6">max_children_per_face</a> = 0</td></tr>
<tr class="separator:ab204ab8cf931ff1fbccdabfafad936c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5da3cd821d7bac8840dcce8c8b8146c"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> = 1</td></tr>
<tr class="separator:af5da3cd821d7bac8840dcce8c8b8146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee4a9c2cffa82a6a73578b2a5c5018f"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a3ee4a9c2cffa82a6a73578b2a5c5018f">vertices_per_face</a> = 0</td></tr>
<tr class="separator:a3ee4a9c2cffa82a6a73578b2a5c5018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17d993003cf51f32cf0516e34dcfaa"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a0c17d993003cf51f32cf0516e34dcfaa">lines_per_face</a> = 0</td></tr>
<tr class="separator:a0c17d993003cf51f32cf0516e34dcfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c6b934d390bae124345aaf5e5f2fe7"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#aa0c6b934d390bae124345aaf5e5f2fe7">quads_per_face</a> = 0</td></tr>
<tr class="separator:aa0c6b934d390bae124345aaf5e5f2fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe58a2d30ed40ef3480245fdce791cb5"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#afe58a2d30ed40ef3480245fdce791cb5">lines_per_cell</a> = 0</td></tr>
<tr class="separator:afe58a2d30ed40ef3480245fdce791cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2240dcb17b9e3151d7e09d68adc2181d"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a2240dcb17b9e3151d7e09d68adc2181d">quads_per_cell</a> = 0</td></tr>
<tr class="separator:a2240dcb17b9e3151d7e09d68adc2181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772e41935f45a02733102906f8c5fb08"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a772e41935f45a02733102906f8c5fb08">hexes_per_cell</a> = 0</td></tr>
<tr class="separator:a772e41935f45a02733102906f8c5fb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c829af3e2cf30b1387a9d0f86beee4"><td class="memItemLeft" align="right" valign="top">static const std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#ac6c829af3e2cf30b1387a9d0f86beee4">ucd_to_deal</a> = {{0}}</td></tr>
<tr class="separator:ac6c829af3e2cf30b1387a9d0f86beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e022286daa2179ee4897ce9c5e6c1f"><td class="memItemLeft" align="right" valign="top">static const std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo_3_010_01_4.html#a53e022286daa2179ee4897ce9c5e6c1f">dx_to_deal</a> = {{0}}</td></tr>
<tr class="separator:a53e022286daa2179ee4897ce9c5e6c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a description of zero-dimensional cells. It has been superseded by the <a class="el" href="classReferenceCell.html">ReferenceCell</a> class</p>
<ul>
<li>see there for more information. Topological description of zero dimensional cells, i.e. points. This class might not look too useful but often is if in a certain dimension we would like to enquire information about objects with dimension one lower than the present, e.g. about faces. This class contains as static members information on vertices and faces of a <code>dim-dimensional</code> grid cell. The interface is the same for all dimensions. If a value is of no use in a low dimensional cell, it is (correctly) set to zero, e.g. <a class="el" href="structGeometryInfo_3_010_01_4.html#ab204ab8cf931ff1fbccdabfafad936c6">max_children_per_face</a> in 1d. This information should always replace hard-coded numbers of vertices, neighbors and so on, since it can be used dimension independently.</li>
</ul>
<p>This class provides a description of zero-dimensional cells. It has been superseded by the <a class="el" href="classReferenceCell.html">ReferenceCell</a> class &ndash; see there for more information.</p>
<p>Topological description of zero dimensional cells, i.e. points. This class might not look too useful but often is if in a certain dimension we would like to enquire information about objects with dimension one lower than the present, e.g. about faces.</p>
<p>This class contains as static members information on vertices and faces of a <code>dim-dimensional</code> grid cell. The interface is the same for all dimensions. If a value is of no use in a low dimensional cell, it is (correctly) set to zero, e.g. <a class="el" href="structGeometryInfo_3_010_01_4.html#ab204ab8cf931ff1fbccdabfafad936c6">max_children_per_face</a> in 1d.</p>
<p>This information should always replace hard-coded numbers of vertices, neighbors and so on, since it can be used dimension independently. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01628">1628</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a729177bef0f761e78c047f6f4d4068d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729177bef0f761e78c047f6f4d4068d0">&#9670;&nbsp;</a></span>face_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 0&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>faces_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> face_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_index)-&gt;at_boundary())</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all faces of all cells, with <code>face_index</code> taking on all valid indices. Of course, since this class is for the case <code>dim==0</code>, the returned object is actually an empty array. </p>

</div>
</div>
<a id="a43f5e06a7f78cd02551e155d612e4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f5e06a7f78cd02551e155d612e4eb8">&#9670;&nbsp;</a></span>n_children() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::n_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of children of a cell (or face) refined with <code>ref_case</code>. Since we are concerned here with points, the number of children is equal to one. </p>

</div>
</div>
<a id="a620b2a110dabe4b2e744ab47593c8aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b2a110dabe4b2e744ab47593c8aa5">&#9670;&nbsp;</a></span>vertex_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>vertices_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertex_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;vertex(vertex_index) satisfies some condition)</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all vertices of all cells, with <code>vertex_index</code> taking on all valid indices. Of course, since this class is for the case <code>dim==0</code>, the returned object is a array with just one entry: zero. That's because an of dimension zero is really just a single point, corresponding to a vertex itself. </p>

</div>
</div>
<a id="a4812a970618d9a3e8a2441c75d78f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812a970618d9a3e8a2441c75d78f9d7">&#9670;&nbsp;</a></span>face_to_cell_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face vertex number to cell vertex number, i.e. give the cell vertex number of the <code>vertex</code>th vertex of face <code>face</code>, e.g. <code>GeometryInfo&lt;2&gt;::face_to_cell_vertices(3,0)=2</code>, see the image under point N4 in the 2d section of this class's documentation. Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation). In 2d only <code>face_flip</code> is considered. See this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article for more information. As the children of a cell are ordered according to the vertices of the cell, this call is passed down to the child_cell_on_face() function. Hence this function is simply a wrapper of child_cell_on_face() giving it a suggestive name. Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<a id="abeb37631fb21d083cc01976c7e846b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb37631fb21d083cc01976c7e846b4d">&#9670;&nbsp;</a></span>face_to_cell_lines() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face line number to cell line number, i.e. give the cell line number of the <code>line</code>th line of face <code>face</code>, e.g. <code>GeometryInfo&lt;3&gt;::face_to_cell_lines(5,0)=4</code>. Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation) and has no effect in 2d. Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<a id="a729177bef0f761e78c047f6f4d4068d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729177bef0f761e78c047f6f4d4068d0">&#9670;&nbsp;</a></span>face_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 0&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>faces_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> face_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_index)-&gt;at_boundary())</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all faces of all cells, with <code>face_index</code> taking on all valid indices.</p>
<p>Of course, since this class is for the case <code>dim==0</code>, the returned object is actually an empty array. </p>

</div>
</div>
<a id="a43f5e06a7f78cd02551e155d612e4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f5e06a7f78cd02551e155d612e4eb8">&#9670;&nbsp;</a></span>n_children() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::n_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of children of a cell (or face) refined with <code>ref_case</code>. Since we are concerned here with points, the number of children is equal to one. </p>

</div>
</div>
<a id="a620b2a110dabe4b2e744ab47593c8aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b2a110dabe4b2e744ab47593c8aa5">&#9670;&nbsp;</a></span>vertex_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>vertices_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertex_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;vertex(vertex_index) satisfies some condition)</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all vertices of all cells, with <code>vertex_index</code> taking on all valid indices.</p>
<p>Of course, since this class is for the case <code>dim==0</code>, the returned object is a array with just one entry: zero. That's because an of dimension zero is really just a single point, corresponding to a vertex itself. </p>

</div>
</div>
<a id="a4812a970618d9a3e8a2441c75d78f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812a970618d9a3e8a2441c75d78f9d7">&#9670;&nbsp;</a></span>face_to_cell_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face vertex number to cell vertex number, i.e. give the cell vertex number of the <code>vertex</code>th vertex of face <code>face</code>, e.g. <code>GeometryInfo&lt;2&gt;::face_to_cell_vertices(3,0)=2</code>, see the image under point N4 in the 2d section of this class's documentation.</p>
<p>Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation). In 2d only <code>face_flip</code> is considered. See this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article for more information.</p>
<p>As the children of a cell are ordered according to the vertices of the cell, this call is passed down to the child_cell_on_face() function. Hence this function is simply a wrapper of child_cell_on_face() giving it a suggestive name.</p>
<p>Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<a id="abeb37631fb21d083cc01976c7e846b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb37631fb21d083cc01976c7e846b4d">&#9670;&nbsp;</a></span>face_to_cell_lines() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face line number to cell line number, i.e. give the cell line number of the <code>line</code>th line of face <code>face</code>, e.g. <code>GeometryInfo&lt;3&gt;::face_to_cell_lines(5,0)=4</code>.</p>
<p>Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation) and has no effect in 2d.</p>
<p>Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<a id="a729177bef0f761e78c047f6f4d4068d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729177bef0f761e78c047f6f4d4068d0">&#9670;&nbsp;</a></span>face_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 0&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>faces_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> face_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_index)-&gt;at_boundary())</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all faces of all cells, with <code>face_index</code> taking on all valid indices. Of course, since this class is for the case <code>dim==0</code>, the returned object is actually an empty array. </p>

</div>
</div>
<a id="a43f5e06a7f78cd02551e155d612e4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f5e06a7f78cd02551e155d612e4eb8">&#9670;&nbsp;</a></span>n_children() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::n_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of children of a cell (or face) refined with <code>ref_case</code>. Since we are concerned here with points, the number of children is equal to one. </p>

</div>
</div>
<a id="a620b2a110dabe4b2e744ab47593c8aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b2a110dabe4b2e744ab47593c8aa5">&#9670;&nbsp;</a></span>vertex_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>vertices_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertex_indices</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;vertex(vertex_index) satisfies some condition)</div>
<div class="line">      ... <span class="keywordflow">do</span> something ...</div>
</div><!-- fragment --><p> Here, we are looping over all vertices of all cells, with <code>vertex_index</code> taking on all valid indices. Of course, since this class is for the case <code>dim==0</code>, the returned object is a array with just one entry: zero. That's because an of dimension zero is really just a single point, corresponding to a vertex itself. </p>

</div>
</div>
<a id="a4812a970618d9a3e8a2441c75d78f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812a970618d9a3e8a2441c75d78f9d7">&#9670;&nbsp;</a></span>face_to_cell_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face vertex number to cell vertex number, i.e. give the cell vertex number of the <code>vertex</code>th vertex of face <code>face</code>, e.g. <code>GeometryInfo&lt;2&gt;::face_to_cell_vertices(3,0)=2</code>, see the image under point N4 in the 2d section of this class's documentation. Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation). In 2d only <code>face_flip</code> is considered. See this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article for more information. As the children of a cell are ordered according to the vertices of the cell, this call is passed down to the child_cell_on_face() function. Hence this function is simply a wrapper of child_cell_on_face() giving it a suggestive name. Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<a id="abeb37631fb21d083cc01976c7e846b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb37631fb21d083cc01976c7e846b4d">&#9670;&nbsp;</a></span>face_to_cell_lines() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::face_to_cell_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face line number to cell line number, i.e. give the cell line number of the <code>line</code>th line of face <code>face</code>, e.g. <code>GeometryInfo&lt;3&gt;::face_to_cell_lines(5,0)=4</code>. Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation) and has no effect in 2d. Of course, since this class is for the case <code>dim==0</code>, this function is not implemented. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa44c204ff01441f8f720e920df15e803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44c204ff01441f8f720e920df15e803">&#9670;&nbsp;</a></span>max_children_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::max_children_per_cell = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of children of a cell, i.e. the number of children of an isotropically refined cell. If a cell is refined anisotropically, the actual number of children may be less than the value given here. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01636">1636</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="abf057e2a19ee1ded244f00087c318873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf057e2a19ee1ded244f00087c318873">&#9670;&nbsp;</a></span>faces_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::faces_per_cell = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of faces a cell has. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01642">1642</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="ab204ab8cf931ff1fbccdabfafad936c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab204ab8cf931ff1fbccdabfafad936c6">&#9670;&nbsp;</a></span>max_children_per_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::max_children_per_face = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of children of a refined face, i.e. the number of children of an isotropically refined face. If a cell is refined anisotropically, the actual number of children may be less than the value given here. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01669">1669</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="af5da3cd821d7bac8840dcce8c8b8146c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5da3cd821d7bac8840dcce8c8b8146c">&#9670;&nbsp;</a></span>vertices_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::vertices_per_cell = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vertices a cell has. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01684">1684</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a3ee4a9c2cffa82a6a73578b2a5c5018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee4a9c2cffa82a6a73578b2a5c5018f">&#9670;&nbsp;</a></span>vertices_per_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::vertices_per_face = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vertices each face has. Since this is not useful in one dimension, we provide a useless number (in the hope that a compiler may warn when it sees constructs like <code>for (i=0; i&lt;vertices_per_face; ++i)</code>, at least if <code>i</code> is an <code>unsigned int</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01750">1750</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a0c17d993003cf51f32cf0516e34dcfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c17d993003cf51f32cf0516e34dcfaa">&#9670;&nbsp;</a></span>lines_per_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::lines_per_face = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines each face has. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01756">1756</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aa0c6b934d390bae124345aaf5e5f2fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c6b934d390bae124345aaf5e5f2fe7">&#9670;&nbsp;</a></span>quads_per_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::quads_per_face = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads on each face. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01762">1762</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="afe58a2d30ed40ef3480245fdce791cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe58a2d30ed40ef3480245fdce791cb5">&#9670;&nbsp;</a></span>lines_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::lines_per_cell = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines of a cell. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01768">1768</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a2240dcb17b9e3151d7e09d68adc2181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2240dcb17b9e3151d7e09d68adc2181d">&#9670;&nbsp;</a></span>quads_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::quads_per_cell = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quadrilaterals of a cell. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01774">1774</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a772e41935f45a02733102906f8c5fb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772e41935f45a02733102906f8c5fb08">&#9670;&nbsp;</a></span>hexes_per_cell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::hexes_per_cell = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexahedra of a cell. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01780">1780</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="ac6c829af3e2cf30b1387a9d0f86beee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c829af3e2cf30b1387a9d0f86beee4">&#9670;&nbsp;</a></span>ucd_to_deal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::<a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::ucd_to_deal = {{0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rearrange vertices for UCD output. For a cell being written in UCD format, each entry in this field contains the number of a vertex in <code>deal.II</code> that corresponds to the UCD numbering at this location. Typical example: write a cell and arrange the vertices, such that UCD understands them. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div>
<div class="line">out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo_3_010_01_4.html#ac6c829af3e2cf30b1387a9d0f86beee4">ucd_to_deal</a>[i]);</div>
</div><!-- fragment --><p> As the vertex numbering in deal.II versions &lt;= 5.1 happened to coincide with the UCD numbering, this field can also be used like a old_to_lexicographic mapping. </p>

<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01797">1797</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a53e022286daa2179ee4897ce9c5e6c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e022286daa2179ee4897ce9c5e6c1f">&#9670;&nbsp;</a></span>dx_to_deal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::<a class="el" href="structGeometryInfo_3_010_01_4.html#af5da3cd821d7bac8840dcce8c8b8146c">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 0 &gt;::dx_to_deal = {{0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rearrange vertices for OpenDX output. For a cell being written in OpenDX format, each entry in this field contains the number of a vertex in <code>deal.II</code> that corresponds to the DX numbering at this location. Typical example: write a cell and arrange the vertices, such that OpenDX understands them. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div>
<div class="line">out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo_3_010_01_4.html#a53e022286daa2179ee4897ce9c5e6c1f">dx_to_deal</a>[i]);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="base_2geometry__info_8h_source.html#l01812">1812</a> of file <a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="base_2geometry__info_8h_source.html">geometry_info.h</a></li>
<li>source/base/<a class="el" href="geometry__info_8cc_source.html">geometry_info.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructGeometryInfo_3_010_01_4_html_ac6c829af3e2cf30b1387a9d0f86beee4"><div class="ttname"><a href="structGeometryInfo_3_010_01_4.html#ac6c829af3e2cf30b1387a9d0f86beee4">GeometryInfo&lt; 0 &gt;::ucd_to_deal</a></div><div class="ttdeci">static const std::array&lt; unsigned int, vertices_per_cell &gt; ucd_to_deal</div><div class="ttdef"><b>Definition:</b> <a href="base_2geometry__info_8h_source.html#l01797">geometry_info.h:1797</a></div></div>
<div class="ttc" id="astructGeometryInfo_html"><div class="ttname"><a href="structGeometryInfo.html">GeometryInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2geometry__info_8h_source.html#l01602">geometry_info.h:1602</a></div></div>
<div class="ttc" id="astructGeometryInfo_3_010_01_4_html_a53e022286daa2179ee4897ce9c5e6c1f"><div class="ttname"><a href="structGeometryInfo_3_010_01_4.html#a53e022286daa2179ee4897ce9c5e6c1f">GeometryInfo&lt; 0 &gt;::dx_to_deal</a></div><div class="ttdeci">static const std::array&lt; unsigned int, vertices_per_cell &gt; dx_to_deal</div><div class="ttdef"><b>Definition:</b> <a href="base_2geometry__info_8h_source.html#l01812">geometry_info.h:1812</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_aa78f707e9416892e3e018027ffab1c80"><div class="ttname"><a href="p4est__wrappers_8cc.html#aa78f707e9416892e3e018027ffab1c80">triangulation</a></div><div class="ttdeci">const typename ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
