<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMeshWorker.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MeshWorker Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MeshWorker Namespace Reference<div class="ingroups"><a class="el" href="group__Integrators.html">Integrators A collection of namespaces and functions</a> &raquo; <a class="el" href="group__MeshWorker.html">The MeshWorker interface A collection of classes and</a> &#124; <a class="el" href="group__Integrators.html">Integrators A collection of namespaces and functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceMeshWorker_1_1Assembler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker_1_1Assembler.html">Assembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceMeshWorker_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalResults.html">LocalResults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1MGVectorData.html">MGVectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorData.html">VectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorDataBase.html">VectorDataBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorSelector.html">VectorSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2cf962dca26399f5c73dbab4a5f9b9e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a2cf962dca26399f5c73dbab4a5f9b9e8">CellWorkerFunctionType</a> = <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:a2cf962dca26399f5c73dbab4a5f9b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a9151f97d6c26b7d0cd479b9a395a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a39a9151f97d6c26b7d0cd479b9a395a8">CopierFunctionType</a> = <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:a39a9151f97d6c26b7d0cd479b9a395a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15a4a2de1fffa0ca0d982478cb2e020"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ad15a4a2de1fffa0ca0d982478cb2e020">BoundaryWorkerFunctionType</a> = <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:ad15a4a2de1fffa0ca0d982478cb2e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13181f6a38f5fde7bb34301533f8c0ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a13181f6a38f5fde7bb34301533f8c0ba">FaceWorkerFunctionType</a> = <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:a13181f6a38f5fde7bb34301533f8c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces
<br />
 }</td></tr>
<tr class="separator:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces
<br />
 }</td></tr>
<tr class="separator:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2">work_on_boundary</a> = assemble_boundary_faces
<br />
 }</td></tr>
<tr class="separator:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abee7f2d38b6b84d702e141f9d9bb4e3f"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:abee7f2d38b6b84d702e141f9d9bb4e3f"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#abee7f2d38b6b84d702e141f9d9bb4e3f">operator&lt;&lt;</a> (StreamType &amp;<a class="el" href="kinsol__0_8txt.html#aef7db8db372670631e9759ab5a3941aa">s</a>, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> u)</td></tr>
<tr class="separator:abee7f2d38b6b84d702e141f9d9bb4e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc968cec1e4b2fb3b0819f3efc28bd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:adc968cec1e4b2fb3b0819f3efc28bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6c6d3cc27b8ea4d8e3566a2ca26bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a8b6c6d3cc27b8ea4d8e3566a2ca26bc2">operator|=</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:a8b6c6d3cc27b8ea4d8e3566a2ca26bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc19087b9caae698288a2b088a07e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#abc19087b9caae698288a2b088a07e2da">operator&amp;</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:abc19087b9caae698288a2b088a07e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c4ba3378cc89c4945f07b97b01ed87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#af5c4ba3378cc89c4945f07b97b01ed87">operator&amp;=</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:af5c4ba3378cc89c4945f07b97b01ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplParams" colspan="2">template&lt;class INFOBOX , class DOFINFO , int dim, int spacedim, class ITERATOR &gt; </td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action</a> (ITERATOR <a class="el" href="vector__tools__point__value__0_8txt.html#a8e9328f1f25ef75085320c149b93bb42">cell</a>, <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, DOFINFO &gt; &amp;dof_info, INFOBOX &amp;info, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;loop_control)</td></tr>
<tr class="separator:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class DOFINFO , class INFOBOX , class ASSEMBLER , class ITERATOR &gt; </td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop</a> (ITERATOR <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">begin</a>, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#afd9d8ed92a81e47388f0f4666beb0712">end</a>, DOFINFO &amp;dinfo, INFOBOX &amp;info, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, ASSEMBLER &amp;assembler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ASSEMBLER &gt; </td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop</a> (ITERATOR <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">begin</a>, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#afd9d8ed92a81e47388f0f4666beb0712">end</a>, <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_info, <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="base_2bounding__box__0_8txt.html#af37935e4c84062243619eb336c9068ad">box</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;integrator, ASSEMBLER &amp;assembler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">begin</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#afd9d8ed92a81e47388f0f4666beb0712">end</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#a2cf962dca26399f5c73dbab4a5f9b9e8">CellWorkerFunctionType</a> &amp;cell_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CopierType &amp;<a class="el" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="grid__out__0_8txt.html#a510770d87baebda8326f66e6ab84dc84">flags</a>=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#ad15a4a2de1fffa0ca0d982478cb2e020">BoundaryWorkerFunctionType</a> &amp;boundary_worker=<a class="el" href="namespaceMeshWorker.html#ad15a4a2de1fffa0ca0d982478cb2e020">BoundaryWorkerFunctionType</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#a13181f6a38f5fde7bb34301533f8c0ba">FaceWorkerFunctionType</a> &amp;face_worker=<a class="el" href="namespaceMeshWorker.html#a13181f6a38f5fde7bb34301533f8c0ba">FaceWorkerFunctionType</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gae1cf14f6f8ff8f5e1f168c19ad4979b9">mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;cell_worker, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;<a class="el" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="grid__out__0_8txt.html#a510770d87baebda8326f66e6ab84dc84">flags</a>=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;boundary_worker=<a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;face_worker=<a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> chunk_size=8)</td></tr>
<tr class="separator:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass &gt; </td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gab233c65f7c758c094edbf9a0b5687d5e">mesh_loop</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">begin</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; CellIteratorType &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#afd9d8ed92a81e47388f0f4666beb0712">end</a>, MainClass &amp;main_class, void(MainClass::*cell_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*<a class="el" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="grid__out__0_8txt.html#a510770d87baebda8326f66e6ab84dc84">flags</a>=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a>, void(MainClass::*boundary_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>, void(MainClass::*face_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> chunk_size=8)</td></tr>
<tr class="separator:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga47cf9870f0e4e1952e77d7c77a560998">mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, MainClass &amp;main_class, void(MainClass::*cell_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*<a class="el" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="grid__out__0_8txt.html#a510770d87baebda8326f66e6ab84dc84">flags</a>=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb">assemble_own_cells</a>, void(MainClass::*boundary_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>, void(MainClass::*face_worker)(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of functions and classes for the mesh loops that are an ubiquitous part of each finite element program. The workhorse of this namespace is the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> function, which implements a completely generic loop over all mesh cells. Since the calls to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> are error-prone due to its generality, for many applications it is advisable to derive a class from <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a> and use the less general <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> instead. The <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> depends on certain objects handed to it as arguments. These objects are of two types, <code>info</code> objects like <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a> and <a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a> and worker objects like LocalWorker and IntegrationWorker. Worker objects usually do two different jobs: first, they compute the local contribution of a cell or face to the global operation. Second, they assemble this local contribution into the global result, whether a functional, a form or a bilinear form. While the first job is particular to the problem being solved, the second is generic and only depends on the data structures. Therefore, base classes for workers assembling into global data are provided in the namespace <a class="el" href="namespaceMeshWorker_1_1Assembler.html">Assembler</a>. </p><h3>Template argument types</h3>
<p>The functions <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a> take some arguments which are template parameters. Let us list the minimum requirements for these classes here and describe their properties. </p><h4>ITERATOR</h4>
<p>Any object that has an <code><a class="el" href="structSynchronousIterators.html#a574336a8166e3537d57c0d677df48ce9">operator++()</a></code> and points to a <a class="el" href="classTriaAccessor.html">TriaAccessor</a> or derived class. </p><h4>DOFINFO</h4>
<p>For an example implementation, refer to the class template <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>. In order to work with <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a> and <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a>, DOFINFO needs to follow the following interface.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DOFINFO</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  DOFINFO();</div>
<div class="line">  DOFINFO(<span class="keyword">const</span> DOFINFO&amp;);</div>
<div class="line">  DOFINFO&amp; <a class="code" href="chunk__sparse__matrix__0_8txt.html#aa747ba884f098177e9bf2b2422a461a9">operator=</a>(<span class="keyword">const</span> DOFINFO&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>, <span class="keyword">const</span> FaceIt&amp; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="petsc__matrix__base__0_8txt.html#a5a1b8b75c93e6ea5e27829c4fe862a8e">n</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>, <span class="keyword">const</span> FaceIt&amp; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="petsc__matrix__base__0_8txt.html#a5a1b8b75c93e6ea5e27829c4fe862a8e">n</a>,</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">friend</span> <span class="keyword">template</span> <span class="keyword">class </span>DoFInfoBox&lt;int dim, DOFINFO&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The three private functions are called by <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a> and should not be needed elsewhere. Obviously, they can be made public and then the friend declaration at the end may be missing. Additionally, you will need at least one public constructor. Furthermore DOFINFO is pretty useless yet: functions to interface with INTEGRATIONINFO and ASSEMBLER are needed. DOFINFO objects are gathered in a <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>. In those objects, we store the results of local operations on each cell and its faces. Once all this information has been gathered, an ASSEMBLER is used to assemble it into global data. </p><h4>INFOBOX</h4>
<p>This type is exemplified in <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>. It collects the input data for actions on cells and faces in INFO objects (see below). It provides the following interface to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFOBOX</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div>
<div class="line">  <span class="keywordtype">void</span> post_cell(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div>
<div class="line">  <span class="keywordtype">void</span> post_faces(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div>
<div class="line"> </div>
<div class="line">  INFO <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>;</div>
<div class="line">  INFO <a class="code" href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a>;</div>
<div class="line">  INFO <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>;</div>
<div class="line">  INFO <a class="code" href="fe_2fe__0_8txt.html#abdc8bcc6101c2a1038ee126062582fb2">subface</a>;</div>
<div class="line">  INFO <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The main purpose of this class is gathering the five INFO objects, which contain the temporary data used on each cell or face. The requirements on these objects are listed below. Here, we only note that there need to be these 5 objects with the names listed above. The two function templates are call back functions called in <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a>. The first is called before the faces are worked on, the second after the faces. </p><h4>INFO</h4>
<p>See <a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a> for an example of these objects. They contain the temporary data needed on each cell or face to compute the result. The <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> only uses the interface</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFO</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> DOFINFO&amp; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">};</div>
</div><!-- fragment --><h3>Simplified interfaces</h3>
<p>Since the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> is fairly general, a specialization <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> is available, which is a wrapper around <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> with a simplified interface. The <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> function loop takes most of the information that it needs to pass to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> from an <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a> object. Its use is explained in <a class="el" href="step_12.html">step-12</a> , but in short it requires functions that do the local integration on a cell, interior or boundary face, and it needs an object (called "assembler") that copies these local contributions into the global matrix and right hand side objects. Before we can run the integration loop, we have to initialize several data structures in our IntegrationWorker and assembler objects. For instance, we have to decide on the quadrature rule or we may need more than the default update flags.</p>
<p>A collection of functions and classes for the mesh loops that are an ubiquitous part of each finite element program.</p>
<p>The workhorse of this namespace is the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> function, which implements a completely generic loop over all mesh cells. Since the calls to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> are error-prone due to its generality, for many applications it is advisable to derive a class from <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a> and use the less general <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> instead.</p>
<p>The <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> depends on certain objects handed to it as arguments. These objects are of two types, <code>info</code> objects like <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a> and <a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a> and worker objects like LocalWorker and IntegrationWorker.</p>
<p>Worker objects usually do two different jobs: first, they compute the local contribution of a cell or face to the global operation. Second, they assemble this local contribution into the global result, whether a functional, a form or a bilinear form. While the first job is particular to the problem being solved, the second is generic and only depends on the data structures. Therefore, base classes for workers assembling into global data are provided in the namespace <a class="el" href="namespaceMeshWorker_1_1Assembler.html">Assembler</a>.</p>
<h3>Template argument types</h3>
<p>The functions <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a> take some arguments which are template parameters. Let us list the minimum requirements for these classes here and describe their properties.</p>
<h4>ITERATOR</h4>
<p>Any object that has an <code><a class="el" href="structSynchronousIterators.html#a574336a8166e3537d57c0d677df48ce9">operator++()</a></code> and points to a <a class="el" href="classTriaAccessor.html">TriaAccessor</a> or derived class.</p>
<h4>DOFINFO</h4>
<p>For an example implementation, refer to the class template <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>. In order to work with <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a> and <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a>, DOFINFO needs to follow the following interface. </p><div class="fragment"><div class="line"><span class="keyword">class </span>DOFINFO</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    DOFINFO();</div>
<div class="line">    DOFINFO(<span class="keyword">const</span> DOFINFO&amp;);</div>
<div class="line">    DOFINFO&amp; <a class="code" href="chunk__sparse__matrix__0_8txt.html#aa747ba884f098177e9bf2b2422a461a9">operator=</a>(<span class="keyword">const</span> DOFINFO&amp;);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>, <span class="keyword">const</span> FaceIt&amp; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="petsc__matrix__base__0_8txt.html#a5a1b8b75c93e6ea5e27829c4fe862a8e">n</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>, <span class="keyword">const</span> FaceIt&amp; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="petsc__matrix__base__0_8txt.html#a5a1b8b75c93e6ea5e27829c4fe862a8e">n</a>,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">template</span> <span class="keyword">class </span>DoFInfoBox&lt;int dim, DOFINFO&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The three private functions are called by <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a> and should not be needed elsewhere. Obviously, they can be made public and then the friend declaration at the end may be missing.</p>
<p>Additionally, you will need at least one public constructor. Furthermore DOFINFO is pretty useless yet: functions to interface with INTEGRATIONINFO and ASSEMBLER are needed.</p>
<p>DOFINFO objects are gathered in a <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>. In those objects, we store the results of local operations on each cell and its faces. Once all this information has been gathered, an ASSEMBLER is used to assemble it into global data.</p>
<h4>INFOBOX</h4>
<p>This type is exemplified in <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>. It collects the input data for actions on cells and faces in INFO objects (see below). It provides the following interface to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFOBOX</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div>
<div class="line">    <span class="keywordtype">void</span> post_cell(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div>
<div class="line">    <span class="keywordtype">void</span> post_faces(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div>
<div class="line"> </div>
<div class="line">    INFO <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>;</div>
<div class="line">    INFO <a class="code" href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a>;</div>
<div class="line">    INFO <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>;</div>
<div class="line">    INFO <a class="code" href="fe_2fe__0_8txt.html#abdc8bcc6101c2a1038ee126062582fb2">subface</a>;</div>
<div class="line">    INFO <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The main purpose of this class is gathering the five INFO objects, which contain the temporary data used on each cell or face. The requirements on these objects are listed below. Here, we only note that there need to be these 5 objects with the names listed above.</p>
<p>The two function templates are call back functions called in <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a>. The first is called before the faces are worked on, the second after the faces.</p>
<h4>INFO</h4>
<p>See <a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a> for an example of these objects. They contain the temporary data needed on each cell or face to compute the result. The <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> only uses the interface</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFO</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> DOFINFO&amp; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">};</div>
</div><!-- fragment --><h3>Simplified interfaces</h3>
<p>Since the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> is fairly general, a specialization <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> is available, which is a wrapper around <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> with a simplified interface.</p>
<p>The <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a> function loop takes most of the information that it needs to pass to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> from an <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a> object. Its use is explained in <a class="el" href="step_12.html">step-12</a>, but in short it requires functions that do the local integration on a cell, interior or boundary face, and it needs an object (called "assembler") that copies these local contributions into the global matrix and right hand side objects.</p>
<p>Before we can run the integration loop, we have to initialize several data structures in our IntegrationWorker and assembler objects. For instance, we have to decide on the quadrature rule or we may need more than the default update flags. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a2cf962dca26399f5c73dbab4a5f9b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf962dca26399f5c73dbab4a5f9b9e8">&#9670;&nbsp;</a></span>CellWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt; <a class="el" href="namespaceMeshWorker.html#a2cf962dca26399f5c73dbab4a5f9b9e8">MeshWorker::CellWorkerFunctionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This alias introduces a friendly and short name for the function type for the cell worker used in <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a>. </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2mesh__loop_8h_source.html#l00113">113</a> of file <a class="el" href="meshworker_2mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="a39a9151f97d6c26b7d0cd479b9a395a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a9151f97d6c26b7d0cd479b9a395a8">&#9670;&nbsp;</a></span>CopierFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt; <a class="el" href="namespaceMeshWorker.html#a39a9151f97d6c26b7d0cd479b9a395a8">MeshWorker::CopierFunctionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This alias introduces a friendly and short name for the function type for the cell worker used in <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a>. </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2mesh__loop_8h_source.html#l00120">120</a> of file <a class="el" href="meshworker_2mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="ad15a4a2de1fffa0ca0d982478cb2e020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15a4a2de1fffa0ca0d982478cb2e020">&#9670;&nbsp;</a></span>BoundaryWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt; <a class="el" href="namespaceMeshWorker.html#ad15a4a2de1fffa0ca0d982478cb2e020">MeshWorker::BoundaryWorkerFunctionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This alias introduces a friendly and short name for the function type for the boundary worker used in <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a>. </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2mesh__loop_8h_source.html#l00131">131</a> of file <a class="el" href="meshworker_2mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="a13181f6a38f5fde7bb34301533f8c0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13181f6a38f5fde7bb34301533f8c0ba">&#9670;&nbsp;</a></span>FaceWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> CellIteratorBaseType &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt; <a class="el" href="namespaceMeshWorker.html#a13181f6a38f5fde7bb34301533f8c0ba">MeshWorker::FaceWorkerFunctionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This alias introduces a friendly and short name for the function type for the face worker used in <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a>. </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2mesh__loop_8h_source.html#l00146">146</a> of file <a class="el" href="meshworker_2mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac7a9db8b34d398d7d398d1e8809874aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9db8b34d398d7d398d1e8809874aa">&#9670;&nbsp;</a></span>AssembleFlags <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">MeshWorker::AssembleFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function, telling that function which elements need to be assembled. You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|(AssembleFlags,AssembleFlags)</a></code> . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00039">39</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="ac7a9db8b34d398d7d398d1e8809874aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9db8b34d398d7d398d1e8809874aa">&#9670;&nbsp;</a></span>AssembleFlags <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">MeshWorker::AssembleFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function, telling that function which elements need to be assembled.</p>
<p>You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|(AssembleFlags,AssembleFlags)</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2meshworker_2assemble__flags_8h_source.html#l00039">39</a> of file <a class="el" href="origin_2meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="ac7a9db8b34d398d7d398d1e8809874aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9db8b34d398d7d398d1e8809874aa">&#9670;&nbsp;</a></span>AssembleFlags <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">MeshWorker::AssembleFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function, telling that function which elements need to be assembled. You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|(AssembleFlags,AssembleFlags)</a></code> . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaaef43e840340be39d80ad697d3d86806"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>Do Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacb8627085561cee8b7af9d74320696eb"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>Assemble on locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaad00e20305de96e6683585f72011896e1"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>Assemble on ghost cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa1ee3d7bd913bcce2a80dee5223f77b2c"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each face only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28d216871216dcdfbcd0e58ca9b774a1"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>Assemble on interior faces between two locally owned cells, visiting each interior face twice, once from each of the two adjacent cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaa5f85375bfc73e8b324dbeaa9cee8905"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell, making sure that only one of the processes will assemble these faces (from the finer side or the process with the lower mpi rank). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa28b1b2dd7a47524030bfbda9217f7044"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>Assemble on faces between a locally owned cell and a ghost cell. Both processes will assemble these faces. Note that they are never assembled from both sides on a single process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa883d91104d154f16c67a4ea50da3fac5"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>Assemble on boundary faces of the locally owned cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47f654bea6128d636d2785c60d3e8193"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>By default we assemble cell integrals before face integrals. If this flag is specified, cells will be assembled after faces and boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa351d0de1537d6b9070502bbe707c208c"></a>work_on_cells&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work on cells is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa0733c7beecc9ba6cd24000df563df4cf"></a>work_on_faces&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa7f61f2c0241768e257bd93d6b672dca2"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>Combination of flags to determine if any work is done on the boundary faces. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2meshworker_2assemble__flags_8h_source.html#l00039">39</a> of file <a class="el" href="translator_2meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abee7f2d38b6b84d702e141f9d9bb4e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee7f2d38b6b84d702e141f9d9bb4e3f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">MeshWorker::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator which outputs assemble flags as a set of or'd text values. <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00127">127</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="adc968cec1e4b2fb3b0819f3efc28bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc968cec1e4b2fb3b0819f3efc28bd0d">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">MeshWorker::operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <code>operator |</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type AssembleFlags. <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00158">158</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="a8b6c6d3cc27b8ea4d8e3566a2ca26bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6c6d3cc27b8ea4d8e3566a2ca26bc2">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">MeshWorker::operator</a>|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which sets the bits from the second argument also in the first one. <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00173">173</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="abc19087b9caae698288a2b088a07e2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19087b9caae698288a2b088a07e2da">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">MeshWorker::operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are set in the first as well as the second argument. This operator exists since if it did not then the result of the bit-and <code>operator &amp;</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type AssembleFlags. <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00189">189</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="af5c4ba3378cc89c4945f07b97b01ed87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c4ba3378cc89c4945f07b97b01ed87">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">MeshWorker::operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which clears all the bits in the first argument if they are not also set in the second argument. <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="meshworker_2assemble__flags_8h_source.html#l00203">203</a> of file <a class="el" href="meshworker_2assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="afe_2fe__0_8txt_html_ad1bbe5407fe459d8e4e71ba7ed9f7428"><div class="ttname"><a href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a></div><div class="ttdeci">it is possible that some of them are in turn constrained leading to longer chains of constraints that the AffineConstraints class will eventually have to sort this is of no concern for the FiniteElement and derived classes since they only act locally on one cell and its immediate neighbor</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__0_8txt_source.html#l00123">fe_0.txt:123</a></div></div>
<div class="ttc" id="afe_2fe__0_8txt_html_abdc8bcc6101c2a1038ee126062582fb2"><div class="ttname"><a href="fe_2fe__0_8txt.html#abdc8bcc6101c2a1038ee126062582fb2">subface</a></div><div class="ttdeci">which ones need to be filled is determined by the update flags stored inside the[2.x.453] object **Use the version taking a[2.x.455] argument **This function is the equivalent to[2.x.456] but for the children of faces of cells See there for an extensive discussion of its purpose It is called by[2.x.457][2.x.458] cell The cell of the triangulation for which this function is to compute a mapping from the reference cell to[2.x.459] face_no The number of the face we are currently indexed among the faces of the cell specified by the previous argument[2.x.460] sub_no The number of the subface</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__0_8txt_source.html#l00562">fe_0.txt:562</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_a138febc7b9c140e5ea6f80e2ce7b44ef"><div class="ttname"><a href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a></div><div class="ttdeci">for&lt; tt &gt;&lt; tt &gt;&lt; tt &gt; etc The actual location of these points on the patch will be computed by a multilinear transformation from the vertices given for this patch For cells at the boundary</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00011">data_out_base_0.txt:11</a></div></div>
<div class="ttc" id="amapping__info__0_8txt_html_aaed09e22b1fee38bd2273caeedfb0e90"><div class="ttname"><a href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a></div><div class="ttdeci">*An enum to identify various types of cells and faces The most general type is what we typically compute in the FEValues context but for many geometries we can save significant storage ***The cell or face is Cartesian **The cell or face can be described with an affine mapping **The face is i the normal factor on a face is the same on all quadrature points This type is not assigned for cells **There is no special information available for compressing the representation of the object under consideration **Definition of a structure that stores all cached data related to the evaluated geometry from the mapping In order to support hp adaptivity and compressed storage length can be different for different rows it allows to jump at the data of individual rows similar to compressed row storage in sparse matrices We have two different start indices for fields with different sizes The first category of offsets are the indices for Jacobians of the transformation from unit to real second JxW and normal vectors We keep separate arrays for all these data structures because a user code might access only some of them In such a one array will be gone through in a contiguous order with access to all which makes it easy for the processor to prefetch data Having all data in a single array would require some strides in the access which is much more complicated for the processor to called which contains the quadrature weights and permutations of how to go through quadrature points in case of face data The latter comes in a vector for the support of hp with several data fields for the individual quadrature formulas ***Constructor Does nothing **Set up the lengths in the various members of this struct **Set up the lengths in the various members of this struct **Returns the memory consumption in bytes **Number of quadrature points applied on the given cell or face **Original one dimensional quadrature formula applied on the given cell or face **Quadrature formula applied on the given cell or face **Quadrature weights separated by dimension for use in specific situations **A cached vector of quadrature weights in the given number the evaluation of basis functions is not in the correct order if a face is not in the standard orientation to a given element This data structure is used to re order the data evaluated on quadrature points to represent the correct order **A class describing the layout of the sections in the[2.x.2] field and also includes some data that depends on the number of quadrature points in the hp context such as the inner quadrature formula and re indexing for faces that are not in the standard orientation **Collection of quadrature formulae applied on the given face *Only filled for since faces might be quadrilateral or triangle shaped **Stores the index offset into the arrays[2.x.4][2.x.5][2.x.6] and the second derivatives Note that affine cells have shorter fields of where the others have lengths equal to the number of quadrature points of the given cell **The storage of the Jacobian i the inverse and transposed Jacobians of the transformation from the unit to the real cell Indexed by[2.x.9] Contains two fields for access from both sides for interior but the default only the upper diagonal and diagonal part are needed The first index runs through the starting with the diagonal and then continuing row i and so on The second index is the spatial coordinate Indexed by[2.x.12] Contains two fields for access from both sides for interior but the default including a compression scheme for Cartesian cells where we do not need to store the full data on all points Indexed by *[2.x.16] *Clears all data fields except the descriptor vector **Returns the quadrature index for a given number of quadrature points If not in hp mode or if the index is not this function always returns index this function does not check whether the given degree is actually present **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **Returns the memory consumption in bytes **The class that stores all geometry dependent data related with cell interiors for use in the matrix free class ***Compute the information in the given cells and faces The cells are specified by the level and the index within the a mapping and several quadrature formulas are given **Update the information in the given cells and faces that is the result of a change in the given mapping keeping the quadrature formulas and other unknowns unchanged This call is only valid if[2.x.20] has been called before **Return the type of a given cell as detected during initialization **Clear all data fields in this class **Return the memory consumption of this class in bytes **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **The given update flags for computing the geometry on the cells **The given update flags for computing the geometry on the boundary faces **The given update flags for computing the geometry on the interior faces **The given update flags for computing the geometry on the faces for cell centric loops **Stores whether a cell is has constant transform data() or is whether it represents an affine whether it is a flat face where the normal vector is the same throughout the or is following the[2.x.21] variable for the cell types **The pointer to the underlying[2.x.22] object **The pointer to the first entry of mapping_collection **Reference cell type related to each quadrature and active quadrature index **Internal function to compute the geometry for the case the mapping is a MappingQ and a single quadrature formula per i it uses a polynomial description of the cell especially when several different quadrature formulas are and consumes less memory[2.x.23] tria The triangulation to be used for setup[2.x.24] cells The actual cells of the triangulation to be worked given as a tuple of the level and index within the level as used in the main initialization of the class ::x faces The description of the connectivity from faces to cells as filled in the MatrixFree class **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Helper function to determine which update flags must be set in the internal functions to initialize all data as requested by the user **A helper class to extract either cell or face data from mapping info for use in FEEvaluationBase **A class that is used to compare floating point c</div><div class="ttdef"><b>Definition:</b> <a href="mapping__info__0_8txt_source.html#l00116">mapping_info_0.txt:116</a></div></div>
<div class="ttc" id="anamespaceinternal_html_a38181f4582ff69679bda7d8e31c37291"><div class="ttname"><a href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">internal::reinit</a></div><div class="ttdeci">void reinit(MatrixBlock&lt; MatrixType &gt; &amp;v, const BlockSparsityPattern &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="lac_2matrix__block_8h_source.html#l00656">matrix_block.h:656</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_add141cdc4d28d06d71948acb7f0c7150"><div class="ttname"><a href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a></div><div class="ttdeci">each of these vectors has[2.x.174] elements containing the values of the[2.x.175] velocities and the one pressure at a quadrature point *We can use these values to then construct other things like residuals the construct is a bit awkward we have a[2.x.176] s</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00155">vector_valued_0.txt:155</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a4874d3f2becad91b2bdda53a5539ff54"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a></div><div class="ttdeci">pow(2x+1, y)` and computing the derivatives `diff(f, x)` and `diff(f, y)`. At this point there is no assumption of what `x` and `y` represent f</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_adad35057b6e70ae37d4abe7878683d90"><div class="ttname"><a href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per the child indices of the child cells adjacent to face</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="achunk__sparse__matrix__0_8txt_html_aa747ba884f098177e9bf2b2422a461a9"><div class="ttname"><a href="chunk__sparse__matrix__0_8txt.html#aa747ba884f098177e9bf2b2422a461a9">operator=</a></div><div class="ttdeci">namespace in which we declare iterators over the elements of sparse matrices ***General template for sparse matrix accessors The first template argument denotes the underlying numeric the second the constness of the matrix The general template is not only the specializations for the two possible values of the second template argument the interface listed here only serves as a template provided since doxygen does not link the specializations **Value of this matrix entry **Value of this matrix entry **Return a reference to the matrix into which this accessor points Note that in the present this is a constant reference **Accessor class for constant matrices used in the const_iterators This class builds on the accessor classes used for sparsity patterns to loop over all nonzero entries and only adds the accessor functions to gain access to the actual value stored at a certain location **Typedef for the this is a constant reference **Pointer to the matrix we use **Make the advance function of the base class available **Accessor class for non constant matrices used in the iterators This class builds on the accessor classes used for sparsity patterns to loop over all nonzero entries and only adds the accessor functions to gain access to the actual value stored at a certain location **Reference class This is what the accessor class returns when you call the i e you can read and write you can add and multiply to but since the matrix does not give away the address of this matrix we have to go through functions to do all this The constructor takes a pointer to an accessor object that describes which element of the matrix it points to This creates an ambiguity when one writes code like iterator since the right hand side is an integer that can both be converted to a&lt; tt &gt; adding another overload operator=(int) doesn 't seem to cure the problem. We avoid it</div></div>
<div class="ttc" id="apetsc__matrix__base__0_8txt_html_a5a1b8b75c93e6ea5e27829c4fe862a8e"><div class="ttname"><a href="petsc__matrix__base__0_8txt.html#a5a1b8b75c93e6ea5e27829c4fe862a8e">n</a></div><div class="ttdeci">local_size()&lt;/tt &gt;. *[0.x.57] *Return whether[2.x.13] is in the local range or not, see also local_range(). *[0.x.58] *Return a reference to the MPI communicator object in use with this matrix. This function has to be implemented in derived classes. *[0.x.59] *Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern n</div><div class="ttdef"><b>Definition:</b> <a href="petsc__matrix__base__0_8txt_source.html#l00127">petsc_matrix_base_0.txt:127</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
