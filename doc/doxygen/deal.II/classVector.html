<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Vector&lt; Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Vector&lt; Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe_2mapping__q1__eulerian_8h_source.html">deal.II/fe/mapping_q1_eulerian.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Vector&lt; Number &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af239d5c3249bbed95fbabec1d17b9827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> = Number</td></tr>
<tr class="separator:af239d5c3249bbed95fbabec1d17b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8006e49918faaffeccd151669d0934"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:acb8006e49918faaffeccd151669d0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace73f5502652dce7656ae891ddcc43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:adace73f5502652dce7656ae891ddcc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a89720422deb00992571e3e7cf1ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:a3b7a89720422deb00992571e3e7cf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5927fb109e04d1d4988dae5c910fc32d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:a5927fb109e04d1d4988dae5c910fc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02452a5983fd0e8c956ab9278213bd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td></tr>
<tr class="separator:a02452a5983fd0e8c956ab9278213bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf239d5c3249bbed95fbabec1d17b9827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> = Number</td></tr>
<tr class="separator:gaf239d5c3249bbed95fbabec1d17b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1be85b8a5e0669f9034cf8e4421a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga0a1be85b8a5e0669f9034cf8e4421a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8006e49918faaffeccd151669d0934"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:gacb8006e49918faaffeccd151669d0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadace73f5502652dce7656ae891ddcc43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gadace73f5502652dce7656ae891ddcc43">reference</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:gadace73f5502652dce7656ae891ddcc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7a89720422deb00992571e3e7cf1ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3b7a89720422deb00992571e3e7cf1ce">const_reference</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:ga3b7a89720422deb00992571e3e7cf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5927fb109e04d1d4988dae5c910fc32d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga5927fb109e04d1d4988dae5c910fc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02452a5983fd0e8c956ab9278213bd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td></tr>
<tr class="separator:ga02452a5983fd0e8c956ab9278213bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239d5c3249bbed95fbabec1d17b9827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> = Number</td></tr>
<tr class="separator:af239d5c3249bbed95fbabec1d17b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8006e49918faaffeccd151669d0934"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:acb8006e49918faaffeccd151669d0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace73f5502652dce7656ae891ddcc43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:adace73f5502652dce7656ae891ddcc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a89720422deb00992571e3e7cf1ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:a3b7a89720422deb00992571e3e7cf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5927fb109e04d1d4988dae5c910fc32d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:a5927fb109e04d1d4988dae5c910fc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02452a5983fd0e8c956ab9278213bd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td></tr>
<tr class="separator:a02452a5983fd0e8c956ab9278213bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a947f5b79fbf762a1d1070f44509dc3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a947f5b79fbf762a1d1070f44509dc3b9">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>) const</td></tr>
<tr class="separator:a947f5b79fbf762a1d1070f44509dc3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic object handling</div></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a55f3a1869eafb7680e44c3fe5c0f6d39">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466762a351e7d9c48c05705730070e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac466762a351e7d9c48c05705730070e3">Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ac466762a351e7d9c48c05705730070e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9b9f407c4064e4d83796c5f5149aa1c0">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#afb43a268341d826272c4255b46b4b14b">Vector</a> (const std::initializer_list&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:afb43a268341d826272c4255b46b4b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6478b634eb646ffaa11f6f82b91d92a9">Vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1bb6efe58ff7587ec88b542fe705bba6">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2de475367d8e8440fc32564a9178216f">Vector</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n)</td></tr>
<tr class="separator:a2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#af441b2c23134f8e6e08c833f918888a2">Vector</a> (const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator last)</td></tr>
<tr class="separator:af441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9a2ad8f9f15b0fa4b207fe053c81c050">~Vector</a> () override=default</td></tr>
<tr class="separator:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cada4763b8e5a45eea3825a379f4d1a79f">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99737189c3f716cf97cb1aba667ff7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a99737189c3f716cf97cb1aba667ff7b2">grow_or_shrink</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N)</td></tr>
<tr class="separator:a99737189c3f716cf97cb1aba667ff7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae296943fe1f9cc5ada1d98761d0a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abae296943fe1f9cc5ada1d98761d0a19">apply_givens_rotation</a> (const std::array&lt; Number, 3 &gt; &amp;csr, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> k)</td></tr>
<tr class="separator:abae296943fe1f9cc5ada1d98761d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a4724e0d85120bda42159be96c493a702">reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9818314bd7dc4e66849559f429e06151">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9e835da7c35928e87f425f41ba30c2f1">operator=</a> (const Number s)</td></tr>
<tr class="separator:a9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5cd12a193b97aa945190a9ce19a81e18">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aba516443a99330968b4dbda6d12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae5aba516443a99330968b4dbda6d12ac">operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ae5aba516443a99330968b4dbda6d12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aa40c43480e8d2c50d0bb0a13421b7264">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5b25ae266b150f897762592e56e5e649">operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a75e25dfec5386326daa1e3a7eea06c6c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d21d0e4ddcd2e645180487745e56692">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a7a226204eb09ef133f124ad2137c17f4">operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a082ee1076dfadf9933073247e56e80c7">operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:ga5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga55f3a1869eafb7680e44c3fe5c0f6d39">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac466762a351e7d9c48c05705730070e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac466762a351e7d9c48c05705730070e3">Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:gac466762a351e7d9c48c05705730070e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9b9f407c4064e4d83796c5f5149aa1c0">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb43a268341d826272c4255b46b4b14b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gafb43a268341d826272c4255b46b4b14b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafb43a268341d826272c4255b46b4b14b">Vector</a> (const std::initializer_list&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:gafb43a268341d826272c4255b46b4b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6478b634eb646ffaa11f6f82b91d92a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6478b634eb646ffaa11f6f82b91d92a9">Vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ga6478b634eb646ffaa11f6f82b91d92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1bb6efe58ff7587ec88b542fe705bba6">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:ga1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2de475367d8e8440fc32564a9178216f">Vector</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n)</td></tr>
<tr class="separator:ga2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf441b2c23134f8e6e08c833f918888a2">Vector</a> (const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator last)</td></tr>
<tr class="separator:gaf441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9a2ad8f9f15b0fa4b207fe053c81c050">~Vector</a> () override=default</td></tr>
<tr class="separator:ga9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cada4763b8e5a45eea3825a379f4d1a79f">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:ga8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99737189c3f716cf97cb1aba667ff7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga99737189c3f716cf97cb1aba667ff7b2">grow_or_shrink</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N)</td></tr>
<tr class="separator:ga99737189c3f716cf97cb1aba667ff7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae296943fe1f9cc5ada1d98761d0a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabae296943fe1f9cc5ada1d98761d0a19">apply_givens_rotation</a> (const std::array&lt; Number, 3 &gt; &amp;csr, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> k)</td></tr>
<tr class="separator:gabae296943fe1f9cc5ada1d98761d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4724e0d85120bda42159be96c493a702">reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9818314bd7dc4e66849559f429e06151">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9e835da7c35928e87f425f41ba30c2f1">operator=</a> (const Number s)</td></tr>
<tr class="separator:ga9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5cd12a193b97aa945190a9ce19a81e18">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5aba516443a99330968b4dbda6d12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae5aba516443a99330968b4dbda6d12ac">operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:gae5aba516443a99330968b4dbda6d12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa40c43480e8d2c50d0bb0a13421b7264">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5b25ae266b150f897762592e56e5e649">operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e25dfec5386326daa1e3a7eea06c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga75e25dfec5386326daa1e3a7eea06c6c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ga75e25dfec5386326daa1e3a7eea06c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d21d0e4ddcd2e645180487745e56692">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:ga4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7a226204eb09ef133f124ad2137c17f4">operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:ga7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga082ee1076dfadf9933073247e56e80c7">operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:ga082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a55f3a1869eafb7680e44c3fe5c0f6d39">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466762a351e7d9c48c05705730070e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac466762a351e7d9c48c05705730070e3">Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ac466762a351e7d9c48c05705730070e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9b9f407c4064e4d83796c5f5149aa1c0">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#afb43a268341d826272c4255b46b4b14b">Vector</a> (const std::initializer_list&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:afb43a268341d826272c4255b46b4b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6478b634eb646ffaa11f6f82b91d92a9">Vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1bb6efe58ff7587ec88b542fe705bba6">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2de475367d8e8440fc32564a9178216f">Vector</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n)</td></tr>
<tr class="separator:a2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#af441b2c23134f8e6e08c833f918888a2">Vector</a> (const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator last)</td></tr>
<tr class="separator:af441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9a2ad8f9f15b0fa4b207fe053c81c050">~Vector</a> () override=default</td></tr>
<tr class="separator:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cada4763b8e5a45eea3825a379f4d1a79f">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99737189c3f716cf97cb1aba667ff7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a99737189c3f716cf97cb1aba667ff7b2">grow_or_shrink</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N)</td></tr>
<tr class="separator:a99737189c3f716cf97cb1aba667ff7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae296943fe1f9cc5ada1d98761d0a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abae296943fe1f9cc5ada1d98761d0a19">apply_givens_rotation</a> (const std::array&lt; Number, 3 &gt; &amp;csr, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> k)</td></tr>
<tr class="separator:abae296943fe1f9cc5ada1d98761d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a4724e0d85120bda42159be96c493a702">reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9818314bd7dc4e66849559f429e06151">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9e835da7c35928e87f425f41ba30c2f1">operator=</a> (const Number s)</td></tr>
<tr class="separator:a9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5cd12a193b97aa945190a9ce19a81e18">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aba516443a99330968b4dbda6d12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae5aba516443a99330968b4dbda6d12ac">operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ae5aba516443a99330968b4dbda6d12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aa40c43480e8d2c50d0bb0a13421b7264">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5b25ae266b150f897762592e56e5e649">operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a75e25dfec5386326daa1e3a7eea06c6c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d21d0e4ddcd2e645180487745e56692">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a7a226204eb09ef133f124ad2137c17f4">operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a082ee1076dfadf9933073247e56e80c7">operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar products, norms and related operations</div></td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2371854d97a2f717da3170b72e2a58e8">operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:a2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aad5a995087a003f81fa5b74513e13677">norm_sqr</a> () const</td></tr>
<tr class="separator:aad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a33d47f6cd8a2b9ec62f133e7d303b745">mean_value</a> () const</td></tr>
<tr class="separator:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a> () const</td></tr>
<tr class="separator:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a708e76373444e3b1d12dbee72f5d32b9">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> p) const</td></tr>
<tr class="separator:a708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a> () const</td></tr>
<tr class="separator:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3659971dfc5e53759da2be27d702d078">add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2371854d97a2f717da3170b72e2a58e8">operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:ga2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaad5a995087a003f81fa5b74513e13677">norm_sqr</a> () const</td></tr>
<tr class="separator:gaad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga33d47f6cd8a2b9ec62f133e7d303b745">mean_value</a> () const</td></tr>
<tr class="separator:ga33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeaa8fc05dd5a8a8f9560a5de096ebb4e">l1_norm</a> () const</td></tr>
<tr class="separator:gaeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a> () const</td></tr>
<tr class="separator:ga8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga708e76373444e3b1d12dbee72f5d32b9">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> p) const</td></tr>
<tr class="separator:ga708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a> () const</td></tr>
<tr class="separator:ga9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3659971dfc5e53759da2be27d702d078">add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:ga3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2371854d97a2f717da3170b72e2a58e8">operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:a2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aad5a995087a003f81fa5b74513e13677">norm_sqr</a> () const</td></tr>
<tr class="separator:aad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a33d47f6cd8a2b9ec62f133e7d303b745">mean_value</a> () const</td></tr>
<tr class="separator:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a> () const</td></tr>
<tr class="separator:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a708e76373444e3b1d12dbee72f5d32b9">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> p) const</td></tr>
<tr class="separator:a708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a> () const</td></tr>
<tr class="separator:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3659971dfc5e53759da2be27d702d078">add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access</div></td></tr>
<tr class="memitem:a46010ca9f43c93431f7ee66817e670ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a46010ca9f43c93431f7ee66817e670ca">data</a> ()</td></tr>
<tr class="separator:a46010ca9f43c93431f7ee66817e670ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24916f568e015cc783628a2c9664c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a24916f568e015cc783628a2c9664c666">data</a> () const</td></tr>
<tr class="separator:a24916f568e015cc783628a2c9664c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a> ()</td></tr>
<tr class="separator:af34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a710df6df8902b609158fa277f216d146">begin</a> () const</td></tr>
<tr class="separator:a710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a> ()</td></tr>
<tr class="separator:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abc9d45917e1f6cd2ba60dc4aef430ce9">end</a> () const</td></tr>
<tr class="separator:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad3af32d65459fad49b43d41ec7e848c3">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:ad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1268a6b336ee46bd8b2ac746cbe82643">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5c137f6bd56f1fad54a13a8cc46f5b12">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d7bafc88c457dbc2e7db6a533d35391">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ae406cc28ed782932504a186ba1c5f9e8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>) const</td></tr>
<tr class="separator:ae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a079ae7a1b9cf454549e0925103208cc5">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:a079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46010ca9f43c93431f7ee66817e670ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga46010ca9f43c93431f7ee66817e670ca">data</a> ()</td></tr>
<tr class="separator:ga46010ca9f43c93431f7ee66817e670ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24916f568e015cc783628a2c9664c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga24916f568e015cc783628a2c9664c666">data</a> () const</td></tr>
<tr class="separator:ga24916f568e015cc783628a2c9664c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf34b888fe493ef2ed188179de69ad7ed">begin</a> ()</td></tr>
<tr class="separator:gaf34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga710df6df8902b609158fa277f216d146">begin</a> () const</td></tr>
<tr class="separator:ga710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7a2a770cb19d3e5b0b69b08ffc88184f">end</a> ()</td></tr>
<tr class="separator:ga7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabc9d45917e1f6cd2ba60dc4aef430ce9">end</a> () const</td></tr>
<tr class="separator:gabc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad3af32d65459fad49b43d41ec7e848c3">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:gad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1268a6b336ee46bd8b2ac746cbe82643">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:ga1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5c137f6bd56f1fad54a13a8cc46f5b12">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:ga5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d7bafc88c457dbc2e7db6a533d35391">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:ga4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae406cc28ed782932504a186ba1c5f9e8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>) const</td></tr>
<tr class="separator:gae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga079ae7a1b9cf454549e0925103208cc5">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:ga079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46010ca9f43c93431f7ee66817e670ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a46010ca9f43c93431f7ee66817e670ca">data</a> ()</td></tr>
<tr class="separator:a46010ca9f43c93431f7ee66817e670ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24916f568e015cc783628a2c9664c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a24916f568e015cc783628a2c9664c666">data</a> () const</td></tr>
<tr class="separator:a24916f568e015cc783628a2c9664c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a> ()</td></tr>
<tr class="separator:af34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a710df6df8902b609158fa277f216d146">begin</a> () const</td></tr>
<tr class="separator:a710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a> ()</td></tr>
<tr class="separator:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abc9d45917e1f6cd2ba60dc4aef430ce9">end</a> () const</td></tr>
<tr class="separator:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad3af32d65459fad49b43d41ec7e848c3">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:ad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1268a6b336ee46bd8b2ac746cbe82643">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5c137f6bd56f1fad54a13a8cc46f5b12">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d7bafc88c457dbc2e7db6a533d35391">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ae406cc28ed782932504a186ba1c5f9e8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>) const</td></tr>
<tr class="separator:ae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a079ae7a1b9cf454549e0925103208cc5">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:a079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification of vectors</div></td></tr>
<tr class="memitem:a0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0b2abb4f2a3a722b30165373ea982a50">operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a603f91549c76b084a88e47d8824997ab">operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:a10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aeb5a1e611de68e9631791cebf3736c86">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:aeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#acd1770cabeceaf722763742cdc1e10ba">add</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n_elements, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *indices, const OtherNumber *<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:acd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2b264924f2c8dc130e0be826f40e0da0">add</a> (const Number s)</td></tr>
<tr class="separator:a2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a141369afc3169fc80597a7d70fa7b7a6">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aae0643f15938ef8dc4727d90405cf83f">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:aae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7126299241702719e409f59c0ec07d51">sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2d2bb04de50473779d407149dec7be9f">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4f3e7e9460e7395dd67b95e61dd87d37">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4263fde23b0a636562ca9751d51b5e4a">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:a4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:aa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a0a3d0f3f7fb1a7d6196a0def1bacf371">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5feedb1e66657dcc91855748c936879a">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:a5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ab59511c3b4ce9b3fe8454c8657234a25">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a> () const</td></tr>
<tr class="separator:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0b2abb4f2a3a722b30165373ea982a50">operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga603f91549c76b084a88e47d8824997ab">operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga10b0336c485e36c7b4b105dd2a926002">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:ga10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gaeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeb5a1e611de68e9631791cebf3736c86">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:gaeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gacd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gacd1770cabeceaf722763742cdc1e10ba">add</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n_elements, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *indices, const OtherNumber *<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:gacd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2b264924f2c8dc130e0be826f40e0da0">add</a> (const Number s)</td></tr>
<tr class="separator:ga2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga141369afc3169fc80597a7d70fa7b7a6">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:ga141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaae0643f15938ef8dc4727d90405cf83f">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:gaae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7126299241702719e409f59c0ec07d51">sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2d2bb04de50473779d407149dec7be9f">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4f3e7e9460e7395dd67b95e61dd87d37">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:ga4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4263fde23b0a636562ca9751d51b5e4a">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:ga4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa956ed8a13546e788464672e88057b65">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:gaa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a3d0f3f7fb1a7d6196a0def1bacf371">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5feedb1e66657dcc91855748c936879a">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:ga5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab59511c3b4ce9b3fe8454c8657234a25">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a> () const</td></tr>
<tr class="separator:gae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0b2abb4f2a3a722b30165373ea982a50">operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a603f91549c76b084a88e47d8824997ab">operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:a10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aeb5a1e611de68e9631791cebf3736c86">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:aeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#acd1770cabeceaf722763742cdc1e10ba">add</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n_elements, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *indices, const OtherNumber *<a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>)</td></tr>
<tr class="separator:acd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2b264924f2c8dc130e0be826f40e0da0">add</a> (const Number s)</td></tr>
<tr class="separator:a2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a141369afc3169fc80597a7d70fa7b7a6">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aae0643f15938ef8dc4727d90405cf83f">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:aae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7126299241702719e409f59c0ec07d51">sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2d2bb04de50473779d407149dec7be9f">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4f3e7e9460e7395dd67b95e61dd87d37">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4263fde23b0a636562ca9751d51b5e4a">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:a4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:aa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a0a3d0f3f7fb1a7d6196a0def1bacf371">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5feedb1e66657dcc91855748c936879a">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:a5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ab59511c3b4ce9b3fe8454c8657234a25">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a> () const</td></tr>
<tr class="separator:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output</div></td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31f18ed7d00d429247dc3127ba496e42">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a57d77409b8591a13d5ee10c2e705593a">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9c9b9333d11630bf0fc82a7957e0d1c1">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a75b54cfee3d921a467f2ca126b54">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a6121484e53939ed6ad6024141ee0cd50">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a6121484e53939ed6ad6024141ee0cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:ga4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga31f18ed7d00d429247dc3127ba496e42">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga57d77409b8591a13d5ee10c2e705593a">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9c9b9333d11630bf0fc82a7957e0d1c1">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3b7a75b54cfee3d921a467f2ca126b54">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6121484e53939ed6ad6024141ee0cd50"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga6121484e53939ed6ad6024141ee0cd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6121484e53939ed6ad6024141ee0cd50">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga6121484e53939ed6ad6024141ee0cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31f18ed7d00d429247dc3127ba496e42">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a57d77409b8591a13d5ee10c2e705593a">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9c9b9333d11630bf0fc82a7957e0d1c1">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a75b54cfee3d921a467f2ca126b54">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a6121484e53939ed6ad6024141ee0cd50">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a6121484e53939ed6ad6024141ee0cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a14359ecc2fbab6f70b322e53b1d1fd19">swap</a> (<a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1885633ec0ef8fc398d6a28a226d6176"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename MemorySpace &gt; </td></tr>
<tr class="memitem:a1885633ec0ef8fc398d6a28a226d6176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a1885633ec0ef8fc398d6a28a226d6176">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;v)</td></tr>
<tr class="separator:a1885633ec0ef8fc398d6a28a226d6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2e52ed1088f622c49c50dc4bf9638863">swap</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a2e52ed1088f622c49c50dc4bf9638863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cffd135b29b32a9d77a1bcdef4b95a">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga809f9fb92ff19a343c238f3de52416e2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:ga809f9fb92ff19a343c238f3de52416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Information about the object</h2></td></tr>
<tr class="memitem:gadc4d5e3c9046ec45d663831b83d715d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a></td></tr>
<tr class="separator:gadc4d5e3c9046ec45d663831b83d715d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d95f14f1f91b1363ba6cb6e15b621b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga98d95f14f1f91b1363ba6cb6e15b621b">thread_loop_partitioner</a></td></tr>
<tr class="separator:ga98d95f14f1f91b1363ba6cb6e15b621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga879f896329da9659f538e8dc9d386087">Vector</a></td></tr>
<tr class="separator:ga879f896329da9659f538e8dc9d386087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga21bdbe031534857b865272b4e986b830">in_local_range</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> global_index) const</td></tr>
<tr class="separator:ga21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaac6b216c32fbf2cddb2466a8033ad3e6">locally_owned_elements</a> () const</td></tr>
<tr class="separator:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dcfa5c77bdd426603386c0844149ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size</a> () const</td></tr>
<tr class="separator:ga81dcfa5c77bdd426603386c0844149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad2508c8f07d54ab6a69fba59daf6df2c">locally_owned_size</a> () const</td></tr>
<tr class="separator:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca33f52511daa54531089f98b316458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0ca33f52511daa54531089f98b316458">has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga0ca33f52511daa54531089f98b316458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga21bdbe031534857b865272b4e986b830">in_local_range</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> global_index) const</td></tr>
<tr class="separator:ga21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaac6b216c32fbf2cddb2466a8033ad3e6">locally_owned_elements</a> () const</td></tr>
<tr class="separator:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dcfa5c77bdd426603386c0844149ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size</a> () const</td></tr>
<tr class="separator:ga81dcfa5c77bdd426603386c0844149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad2508c8f07d54ab6a69fba59daf6df2c">locally_owned_size</a> () const</td></tr>
<tr class="separator:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca33f52511daa54531089f98b316458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0ca33f52511daa54531089f98b316458">has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga0ca33f52511daa54531089f98b316458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga21bdbe031534857b865272b4e986b830">in_local_range</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> global_index) const</td></tr>
<tr class="separator:ga21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaac6b216c32fbf2cddb2466a8033ad3e6">locally_owned_elements</a> () const</td></tr>
<tr class="separator:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dcfa5c77bdd426603386c0844149ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size</a> () const</td></tr>
<tr class="separator:ga81dcfa5c77bdd426603386c0844149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad2508c8f07d54ab6a69fba59daf6df2c">locally_owned_size</a> () const</td></tr>
<tr class="separator:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca33f52511daa54531089f98b316458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0ca33f52511daa54531089f98b316458">has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga0ca33f52511daa54531089f98b316458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab49b815c8f8e5394cd0ed96a687270c">maybe_reset_thread_partitioner</a> ()</td></tr>
<tr class="separator:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga27b879d09291ecb28bb0ea39d7a181b6">do_reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> new_size, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries, const <a class="el" href="classbool.html">bool</a> reset_partitioner)</td></tr>
<tr class="separator:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab49b815c8f8e5394cd0ed96a687270c">maybe_reset_thread_partitioner</a> ()</td></tr>
<tr class="separator:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga27b879d09291ecb28bb0ea39d7a181b6">do_reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> new_size, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries, const <a class="el" href="classbool.html">bool</a> reset_partitioner)</td></tr>
<tr class="separator:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab49b815c8f8e5394cd0ed96a687270c">maybe_reset_thread_partitioner</a> ()</td></tr>
<tr class="separator:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga27b879d09291ecb28bb0ea39d7a181b6">do_reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> new_size, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries, const <a class="el" href="classbool.html">bool</a> reset_partitioner)</td></tr>
<tr class="separator:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number&gt;<br />
class Vector&lt; Number &gt;</h3>

<p>A class that represents a vector of numerical elements. As for the other classes, in the <a class="el" href="group__Vectors.html">Vector classes</a> group, this class has a substantial number of member functions. These include:</p>
<ul>
<li>functions that initialize the vector or change its size;</li>
<li>functions that compute properties of the vector, such as a variety of norms;</li>
<li>functions that allow reading from or writing to individual elements of the vector;</li>
<li>functions that implement algebraic operations for vectors, such as addition of vectors; and</li>
<li>functions that allow inputting and outputting the data stored by vectors. In contrast to the C++ standard library class <code>std::vector</code>, this class intends to implement not simply an array that allows access to its elements, but indeed a vector that is a member of the mathematical concept of a "vector space" suitable for numerical computations.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code> &lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<p>A class that represents a vector of numerical elements. As for the other classes, in the <a class="el" href="group__Vectors.html">Vector classes</a> group, this class has a substantial number of member functions. These include:</p><ul>
<li>functions that initialize the vector or change its size;</li>
<li>functions that compute properties of the vector, such as a variety of norms;</li>
<li>functions that allow reading from or writing to individual elements of the vector;</li>
<li>functions that implement algebraic operations for vectors, such as addition of vectors; and</li>
<li>functions that allow inputting and outputting the data stored by vectors.</li>
</ul>
<p>In contrast to the C++ standard library class <code>std::vector</code>, this class intends to implement not simply an array that allows access to its elements, but indeed a vector that is a member of the mathematical concept of a "vector space" suitable for numerical computations.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual). </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2mapping__q1__eulerian_8h_source.html#l00032">32</a> of file <a class="el" href="fe_2mapping__q1__eulerian_8h_source.html">mapping_q1_eulerian.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af239d5c3249bbed95fbabec1d17b9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af239d5c3249bbed95fbabec1d17b9827">&#9670;&nbsp;</a></span>value_type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00137">137</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a8f7ef5265cbcae4d30f7e3fcde61a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ef5265cbcae4d30f7e3fcde61a7f9">&#9670;&nbsp;</a></span>pointer <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00138">138</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a0a1be85b8a5e0669f9034cf8e4421a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1be85b8a5e0669f9034cf8e4421a11">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00139">139</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="acb8006e49918faaffeccd151669d0934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8006e49918faaffeccd151669d0934">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00140">140</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a31d7e7b4278a3fa08a6e5ceec3deb0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d7e7b4278a3fa08a6e5ceec3deb0fb">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00141">141</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="adace73f5502652dce7656ae891ddcc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace73f5502652dce7656ae891ddcc43">&#9670;&nbsp;</a></span>reference <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00142">142</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a3b7a89720422deb00992571e3e7cf1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a89720422deb00992571e3e7cf1ce">&#9670;&nbsp;</a></span>const_reference <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00143">143</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a5927fb109e04d1d4988dae5c910fc32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5927fb109e04d1d4988dae5c910fc32d">&#9670;&nbsp;</a></span>size_type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00144">144</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a02452a5983fd0e8c956ab9278213bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02452a5983fd0e8c956ab9278213bd2c">&#9670;&nbsp;</a></span>real_type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers. This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00155">155</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="af239d5c3249bbed95fbabec1d17b9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af239d5c3249bbed95fbabec1d17b9827">&#9670;&nbsp;</a></span>value_type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00137">137</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a8f7ef5265cbcae4d30f7e3fcde61a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ef5265cbcae4d30f7e3fcde61a7f9">&#9670;&nbsp;</a></span>pointer <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00138">138</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a0a1be85b8a5e0669f9034cf8e4421a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1be85b8a5e0669f9034cf8e4421a11">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00139">139</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="acb8006e49918faaffeccd151669d0934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8006e49918faaffeccd151669d0934">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00140">140</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a31d7e7b4278a3fa08a6e5ceec3deb0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d7e7b4278a3fa08a6e5ceec3deb0fb">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00141">141</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="adace73f5502652dce7656ae891ddcc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace73f5502652dce7656ae891ddcc43">&#9670;&nbsp;</a></span>reference <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00142">142</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a3b7a89720422deb00992571e3e7cf1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a89720422deb00992571e3e7cf1ce">&#9670;&nbsp;</a></span>const_reference <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00143">143</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a5927fb109e04d1d4988dae5c910fc32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5927fb109e04d1d4988dae5c910fc32d">&#9670;&nbsp;</a></span>size_type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00144">144</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a02452a5983fd0e8c956ab9278213bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02452a5983fd0e8c956ab9278213bd2c">&#9670;&nbsp;</a></span>real_type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers. This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="translator_2lac_2vector_8h_source.html#l00155">155</a> of file <a class="el" href="translator_2lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="a55f3a1869eafb7680e44c3fe5c0f6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3a1869eafb7680e44c3fe5c0f6d39">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector, and copies all elements. We would like to make this constructor explicit, but standard containers insist on using it implicitly. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ac466762a351e7d9c48c05705730070e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac466762a351e7d9c48c05705730070e3">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>. </p>

</div>
</div>
<a id="a9b9f407c4064e4d83796c5f5149aa1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9f407c4064e4d83796c5f5149aa1c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a vector of another data type. This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="afb43a268341d826272c4255b46b4b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb43a268341d826272c4255b46b4b14b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking an object of type <code>std::initializer_list</code>. This constructor can be used to initialize a vector using a brace-enclosed list of numbers, such as in the following example: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> v({1,2,3});</div>
</div><!-- fragment --><p> This creates a vector of size 3, whose (double precision) elements have values 1.0, 2.0, and 3.0. This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="a6478b634eb646ffaa11f6f82b91d92a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6478b634eb646ffaa11f6f82b91d92a9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a PETSc vector class. This copy constructor is only available if PETSc was detected during configuration time. Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a1bb6efe58ff7587ec88b542fe705bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb6efe58ff7587ec88b542fe705bba6">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time. </p><dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code> ) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero. The constructor is made explicit to avoid accidents like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classVector.html">Vector</a> &lt;number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

</div>
</div>
<a id="af441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function is there in analogy to the <code>std::vector</code> class. </p>

</div>
</div>
<a id="a9a2ad8f9f15b0fa4b207fe053c81c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ad8f9f15b0fa4b207fe053c81c050">&#9670;&nbsp;</a></span>~Vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, deallocates memory. Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="a55f3a1869eafb7680e44c3fe5c0f6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3a1869eafb7680e44c3fe5c0f6d39">&#9670;&nbsp;</a></span>Vector() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector, and copies all elements. We would like to make this constructor explicit, but standard containers insist on using it implicitly. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ac466762a351e7d9c48c05705730070e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac466762a351e7d9c48c05705730070e3">&#9670;&nbsp;</a></span>Vector() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>. </p>

</div>
</div>
<a id="a9b9f407c4064e4d83796c5f5149aa1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9f407c4064e4d83796c5f5149aa1c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a vector of another data type. This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="afb43a268341d826272c4255b46b4b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb43a268341d826272c4255b46b4b14b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking an object of type <code>std::initializer_list</code>. This constructor can be used to initialize a vector using a brace-enclosed list of numbers, such as in the following example: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> v({1,2,3});</div>
</div><!-- fragment --><p> This creates a vector of size 3, whose (double precision) elements have values 1.0, 2.0, and 3.0. This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="a6478b634eb646ffaa11f6f82b91d92a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6478b634eb646ffaa11f6f82b91d92a9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a PETSc vector class. This copy constructor is only available if PETSc was detected during configuration time. Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a1bb6efe58ff7587ec88b542fe705bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb6efe58ff7587ec88b542fe705bba6">&#9670;&nbsp;</a></span>Vector() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time. </p><dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code> ) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero. The constructor is made explicit to avoid accidents like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classVector.html">Vector</a> &lt;number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

</div>
</div>
<a id="af441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function is there in analogy to the <code>std::vector</code> class. </p>

</div>
</div>
<a id="a9a2ad8f9f15b0fa4b207fe053c81c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ad8f9f15b0fa4b207fe053c81c050">&#9670;&nbsp;</a></span>~Vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, deallocates memory. Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8740c5534b6dbc31f4f1503a5e2a10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740c5534b6dbc31f4f1503a5e2a10a3">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cada4763b8e5a45eea3825a379f4d1a79f">VectorOperation::unknown</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the parallel vector classes. For the parallel vector wrapper class, this function compresses the underlying representation of the vector, i.e. flushes the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it. However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="ac4a4dbef7dd65ef8ad35ae56b57d7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a4dbef7dd65ef8ad35ae56b57d7c05">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension of the vector to <code>N</code>. The reserved memory for this vector remains unchanged if possible, to make things faster; this may waste some memory, so keep this in mind. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>reinit(0)</code> and then <code>reinit(N)</code>. This cited behavior is analogous to that of the standard library containers. If <code>omit_zeroing_entries</code> is false, the vector is filled by zeros. Otherwise, the elements are left an unspecified state. This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a99737189c3f716cf97cb1aba667ff7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99737189c3f716cf97cb1aba667ff7b2">&#9670;&nbsp;</a></span>grow_or_shrink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::grow_or_shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but will preserve the values of vector upon resizing. If we new size is bigger, we will have </p><p class="formulaDsp">
\[ \mathbf V \rightarrow \left( \begin{array}{c} \mathbf V \\ \mathbf 0 \end{array} \right) \]
</p>
<p> whereas if the desired size is smaller, then </p><p class="formulaDsp">
\[ \left( \begin{array}{c} \mathbf V_1 \\ \mathbf V_2 \end{array} \right) \rightarrow \mathbf V_1 \]
</p>
 
</div>
</div>
<a id="abae296943fe1f9cc5ada1d98761d0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae296943fe1f9cc5ada1d98761d0a19">&#9670;&nbsp;</a></span>apply_givens_rotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::apply_givens_rotation </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Number, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>csr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <a href="https://en.wikipedia.org/wiki/Givens_rotation">Givens rotation</a> <code>csr</code> (a triplet of cosine, sine and radius, see <a class="el" href="namespaceUtilities_1_1LinearAlgebra.html#a33aa7919799a8f798916c463aa88096a">Utilities::LinearAlgebra::givens_rotation()</a>) to the vector in the plane spanned by the <code>i'th</code> and <code>k'th</code> unit vectors. </p>

</div>
</div>
<a id="a4724e0d85120bda42159be96c493a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724e0d85120bda42159be96c493a702">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <code>reinit</code> function. The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>. </p>

</div>
</div>
<a id="a9818314bd7dc4e66849559f429e06151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818314bd7dc4e66849559f429e06151">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around. This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a9e835da7c35928e87f425f41ba30c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e835da7c35928e87f425f41ba30c2f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>. Since the semantics of assigning a scalar to a vector are not immediately clear, this operator should really only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. Assigning other values is deprecated and may be disallowed in the future. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5cd12a193b97aa945190a9ce19a81e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd12a193b97aa945190a9ce19a81e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae5aba516443a99330968b4dbda6d12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aba516443a99330968b4dbda6d12ac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the internal data of the vector <code>v</code> and resets <code>v</code> to the state it would have after being newly default-constructed. </p>

</div>
</div>
<a id="aa40c43480e8d2c50d0bb0a13421b7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c43480e8d2c50d0bb0a13421b7264">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5b25ae266b150f897762592e56e5e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b25ae266b150f897762592e56e5e649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for assigning a block vector to a regular vector. </p>

</div>
</div>
<a id="a75e25dfec5386326daa1e3a7eea06c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e25dfec5386326daa1e3a7eea06c6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time. Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a4d21d0e4ddcd2e645180487745e56692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21d0e4ddcd2e645180487745e56692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a (sequential or parallel, depending on the underlying compiler) Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time. </p><dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code> ) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a7a226204eb09ef133f124ad2137c17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a226204eb09ef133f124ad2137c17f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a082ee1076dfadf9933073247e56e80c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ee1076dfadf9933073247e56e80c7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a2371854d97a2f717da3170b72e2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371854d97a2f717da3170b72e2a58e8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. The return type is the underlying type of <code>this</code> vector, so the return type and the accuracy with which it the result is computed depend on the order of the arguments of this vector. For complex vectors, the scalar product is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aad5a995087a003f81fa5b74513e13677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5a995087a003f81fa5b74513e13677">&#9670;&nbsp;</a></span>norm_sqr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) -norm. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a33d47f6cd8a2b9ec62f133e7d303b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d47f6cd8a2b9ec62f133e7d303b745">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aeaa8fc05dd5a8a8f9560a5de096ebb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8fc05dd5a8a8f9560a5de096ebb4e">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\) -norm of the vector. The sum of the absolute values. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a8ee1b8309a7a9ecf109c8a7116733ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee1b8309a7a9ecf109c8a7116733ef8">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\) -norm of the vector. The square root of the sum of the squares of the elements. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a708e76373444e3b1d12dbee72f5d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708e76373444e3b1d12dbee72f5d32b9">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\) -norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a9f6b7f7afb05aaff7e1ab8f9942b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b7f7afb05aaff7e1ab8f9942b6dae">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="a3659971dfc5e53759da2be27d702d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659971dfc5e53759da2be27d702d078">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value =<span class="keyword">this</span> W;</div>
</div><!-- fragment --><p> The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>). For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a46010ca9f43c93431f7ee66817e670ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46010ca9f43c93431f7ee66817e670ca">&#9670;&nbsp;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the underlying data buffer. </p>

</div>
</div>
<a id="a24916f568e015cc783628a2c9664c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24916f568e015cc783628a2c9664c666">&#9670;&nbsp;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the underlying data buffer. </p>

</div>
</div>
<a id="af34b888fe493ef2ed188179de69ad7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34b888fe493ef2ed188179de69ad7ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classVector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the elements of this vector. </p>

</div>
</div>
<a id="a710df6df8902b609158fa277f216d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710df6df8902b609158fa277f216d146">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the vectors. </p>

</div>
</div>
<a id="a7a2a770cb19d3e5b0b69b08ffc88184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2a770cb19d3e5b0b69b08ffc88184f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="abc9d45917e1f6cd2ba60dc4aef430ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9d45917e1f6cd2ba60dc4aef430ce9">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="ad3af32d65459fad49b43d41ec7e848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3af32d65459fad49b43d41ec7e848c3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. </p>

</div>
</div>
<a id="a1268a6b336ee46bd8b2ac746cbe82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1268a6b336ee46bd8b2ac746cbe82643">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. </p>

</div>
</div>
<a id="a5c137f6bd56f1fad54a13a8cc46f5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c137f6bd56f1fad54a13a8cc46f5b12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. Exactly the same as operator(). </p>

</div>
</div>
<a id="a4d7bafc88c457dbc2e7db6a533d35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7bafc88c457dbc2e7db6a533d35391">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. Exactly the same as operator(). </p>

</div>
</div>
<a id="ae406cc28ed782932504a186ba1c5f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae406cc28ed782932504a186ba1c5f9e8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second. If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; indices.size(); ++i)</div>
<div class="line">  <a class="code" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>[i] = v[indices[i]];</div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="a079ae7a1b9cf454549e0925103208cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ae7a1b9cf454549e0925103208cc5">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument. If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div>
<div class="line">OutputIterator  values_p  = values_begin;</div>
<div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div>
<div class="line">  {</div>
<div class="line">   values_p = v[*indices_p];</div>
<div class="line">    ++indices_p;</div>
<div class="line">    ++values_p;</div>
<div class="line">  }</div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="a0b2abb4f2a3a722b30165373ea982a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2abb4f2a3a722b30165373ea982a50">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a603f91549c76b084a88e47d8824997ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f91549c76b084a88e47d8824997ab">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a10b0336c485e36c7b4b105dd2a926002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b0336c485e36c7b4b105dd2a926002">&#9670;&nbsp;</a></span>add() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="aeb5a1e611de68e9631791cebf3736c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5a1e611de68e9631791cebf3736c86">&#9670;&nbsp;</a></span>add() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="acd1770cabeceaf722763742cdc1e10ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1770cabeceaf722763742cdc1e10ba">&#9670;&nbsp;</a></span>add() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add()</a></code> functions above. </p>

</div>
</div>
<a id="a2b264924f2c8dc130e0be826f40e0da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b264924f2c8dc130e0be826f40e0da0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a141369afc3169fc80597a7d70fa7b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141369afc3169fc80597a7d70fa7b7a6">&#9670;&nbsp;</a></span>add() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aae0643f15938ef8dc4727d90405cf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0643f15938ef8dc4727d90405cf83f">&#9670;&nbsp;</a></span>add() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a7126299241702719e409f59c0ec07d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126299241702719e409f59c0ec07d51">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a2d2bb04de50473779d407149dec7be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bb04de50473779d407149dec7be9f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code>*this = s*(*this)+a*V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4f3e7e9460e7395dd67b95e61dd87d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e7e9460e7395dd67b95e61dd87d37">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4263fde23b0a636562ca9751d51b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263fde23b0a636562ca9751d51b5e4a">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa956ed8a13546e788464672e88057b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956ed8a13546e788464672e88057b65">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a0a3d0f3f7fb1a7d6196a0def1bacf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d0f3f7fb1a7d6196a0def1bacf371">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="a5feedb1e66657dcc91855748c936879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feedb1e66657dcc91855748c936879a">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ab59511c3b4ce9b3fe8454c8657234a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59511c3b4ce9b3fe8454c8657234a25">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p>

</div>
</div>
<a id="ae50dd04b204d8ebf6be467c3ebe2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50dd04b204d8ebf6be467c3ebe2234f">&#9670;&nbsp;</a></span>update_ghost_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

</div>
</div>
<a id="a31f18ed7d00d429247dc3127ba496e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f18ed7d00d429247dc3127ba496e42">&#9670;&nbsp;</a></span>block_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="a57d77409b8591a13d5ee10c2e705593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d77409b8591a13d5ee10c2e705593a">&#9670;&nbsp;</a></span>block_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted. The vector is resized if necessary. A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="a9c9b9333d11630bf0fc82a7957e0d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9b9333d11630bf0fc82a7957e0d1c1">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a3b7a75b54cfee3d921a467f2ca126b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a75b54cfee3d921a467f2ca126b54">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a6121484e53939ed6ad6024141ee0cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121484e53939ed6ad6024141ee0cd50">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a8740c5534b6dbc31f4f1503a5e2a10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740c5534b6dbc31f4f1503a5e2a10a3">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cada4763b8e5a45eea3825a379f4d1a79f">VectorOperation::unknown</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the parallel vector classes. For the parallel vector wrapper class, this function compresses the underlying representation of the vector, i.e. flushes the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it. However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="ac4a4dbef7dd65ef8ad35ae56b57d7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a4dbef7dd65ef8ad35ae56b57d7c05">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension of the vector to <code>N</code>. The reserved memory for this vector remains unchanged if possible, to make things faster; this may waste some memory, so keep this in mind. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>reinit(0)</code> and then <code>reinit(N)</code>. This cited behavior is analogous to that of the standard library containers. If <code>omit_zeroing_entries</code> is false, the vector is filled by zeros. Otherwise, the elements are left an unspecified state. This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a99737189c3f716cf97cb1aba667ff7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99737189c3f716cf97cb1aba667ff7b2">&#9670;&nbsp;</a></span>grow_or_shrink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::grow_or_shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but will preserve the values of vector upon resizing. If we new size is bigger, we will have </p><p class="formulaDsp">
\[ \mathbf V \rightarrow \left( \begin{array}{c} \mathbf V \\ \mathbf 0 \end{array} \right) \]
</p>
<p> whereas if the desired size is smaller, then </p><p class="formulaDsp">
\[ \left( \begin{array}{c} \mathbf V_1 \\ \mathbf V_2 \end{array} \right) \rightarrow \mathbf V_1 \]
</p>
 
</div>
</div>
<a id="abae296943fe1f9cc5ada1d98761d0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae296943fe1f9cc5ada1d98761d0a19">&#9670;&nbsp;</a></span>apply_givens_rotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::apply_givens_rotation </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Number, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>csr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <a href="https://en.wikipedia.org/wiki/Givens_rotation">Givens rotation</a> <code>csr</code> (a triplet of cosine, sine and radius, see <a class="el" href="namespaceUtilities_1_1LinearAlgebra.html#a33aa7919799a8f798916c463aa88096a">Utilities::LinearAlgebra::givens_rotation()</a>) to the vector in the plane spanned by the <code>i'th</code> and <code>k'th</code> unit vectors. </p>

</div>
</div>
<a id="a4724e0d85120bda42159be96c493a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724e0d85120bda42159be96c493a702">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <code>reinit</code> function. The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>. </p>

</div>
</div>
<a id="a9818314bd7dc4e66849559f429e06151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818314bd7dc4e66849559f429e06151">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around. This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a9e835da7c35928e87f425f41ba30c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e835da7c35928e87f425f41ba30c2f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>. Since the semantics of assigning a scalar to a vector are not immediately clear, this operator should really only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. Assigning other values is deprecated and may be disallowed in the future. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5cd12a193b97aa945190a9ce19a81e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd12a193b97aa945190a9ce19a81e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae5aba516443a99330968b4dbda6d12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aba516443a99330968b4dbda6d12ac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the internal data of the vector <code>v</code> and resets <code>v</code> to the state it would have after being newly default-constructed. </p>

</div>
</div>
<a id="aa40c43480e8d2c50d0bb0a13421b7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c43480e8d2c50d0bb0a13421b7264">&#9670;&nbsp;</a></span>operator=() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5b25ae266b150f897762592e56e5e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b25ae266b150f897762592e56e5e649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for assigning a block vector to a regular vector. </p>

</div>
</div>
<a id="a75e25dfec5386326daa1e3a7eea06c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e25dfec5386326daa1e3a7eea06c6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time. Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a4d21d0e4ddcd2e645180487745e56692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21d0e4ddcd2e645180487745e56692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a (sequential or parallel, depending on the underlying compiler) Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time. </p><dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code> ) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a7a226204eb09ef133f124ad2137c17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a226204eb09ef133f124ad2137c17f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a082ee1076dfadf9933073247e56e80c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ee1076dfadf9933073247e56e80c7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a2371854d97a2f717da3170b72e2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371854d97a2f717da3170b72e2a58e8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. The return type is the underlying type of <code>this</code> vector, so the return type and the accuracy with which it the result is computed depend on the order of the arguments of this vector. For complex vectors, the scalar product is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aad5a995087a003f81fa5b74513e13677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5a995087a003f81fa5b74513e13677">&#9670;&nbsp;</a></span>norm_sqr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) -norm. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a33d47f6cd8a2b9ec62f133e7d303b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d47f6cd8a2b9ec62f133e7d303b745">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aeaa8fc05dd5a8a8f9560a5de096ebb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8fc05dd5a8a8f9560a5de096ebb4e">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\) -norm of the vector. The sum of the absolute values. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a8ee1b8309a7a9ecf109c8a7116733ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee1b8309a7a9ecf109c8a7116733ef8">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\) -norm of the vector. The square root of the sum of the squares of the elements. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a708e76373444e3b1d12dbee72f5d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708e76373444e3b1d12dbee72f5d32b9">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\) -norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a9f6b7f7afb05aaff7e1ab8f9942b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b7f7afb05aaff7e1ab8f9942b6dae">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="a3659971dfc5e53759da2be27d702d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659971dfc5e53759da2be27d702d078">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value =<span class="keyword">this</span> W;</div>
</div><!-- fragment --><p> The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>). For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a46010ca9f43c93431f7ee66817e670ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46010ca9f43c93431f7ee66817e670ca">&#9670;&nbsp;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the underlying data buffer. </p>

</div>
</div>
<a id="a24916f568e015cc783628a2c9664c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24916f568e015cc783628a2c9664c666">&#9670;&nbsp;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the underlying data buffer. </p>

</div>
</div>
<a id="af34b888fe493ef2ed188179de69ad7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34b888fe493ef2ed188179de69ad7ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classVector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the elements of this vector. </p>

</div>
</div>
<a id="a710df6df8902b609158fa277f216d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710df6df8902b609158fa277f216d146">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the vectors. </p>

</div>
</div>
<a id="a7a2a770cb19d3e5b0b69b08ffc88184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2a770cb19d3e5b0b69b08ffc88184f">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="abc9d45917e1f6cd2ba60dc4aef430ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9d45917e1f6cd2ba60dc4aef430ce9">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="ad3af32d65459fad49b43d41ec7e848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3af32d65459fad49b43d41ec7e848c3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. </p>

</div>
</div>
<a id="a1268a6b336ee46bd8b2ac746cbe82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1268a6b336ee46bd8b2ac746cbe82643">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. </p>

</div>
</div>
<a id="a5c137f6bd56f1fad54a13a8cc46f5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c137f6bd56f1fad54a13a8cc46f5b12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. Exactly the same as operator(). </p>

</div>
</div>
<a id="a4d7bafc88c457dbc2e7db6a533d35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7bafc88c457dbc2e7db6a533d35391">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. Exactly the same as operator(). </p>

</div>
</div>
<a id="ae406cc28ed782932504a186ba1c5f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae406cc28ed782932504a186ba1c5f9e8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second. If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; indices.size(); ++i)</div>
<div class="line">  <a class="code" href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">values</a>[i] = v[indices[i]];</div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="a079ae7a1b9cf454549e0925103208cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ae7a1b9cf454549e0925103208cc5">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument. If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div>
<div class="line">OutputIterator  values_p  = values_begin;</div>
<div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div>
<div class="line">  {</div>
<div class="line">   values_p = v[*indices_p];</div>
<div class="line">    ++indices_p;</div>
<div class="line">    ++values_p;</div>
<div class="line">  }</div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="a0b2abb4f2a3a722b30165373ea982a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2abb4f2a3a722b30165373ea982a50">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a603f91549c76b084a88e47d8824997ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f91549c76b084a88e47d8824997ab">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a10b0336c485e36c7b4b105dd2a926002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b0336c485e36c7b4b105dd2a926002">&#9670;&nbsp;</a></span>add() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="aeb5a1e611de68e9631791cebf3736c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5a1e611de68e9631791cebf3736c86">&#9670;&nbsp;</a></span>add() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="acd1770cabeceaf722763742cdc1e10ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1770cabeceaf722763742cdc1e10ba">&#9670;&nbsp;</a></span>add() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add()</a></code> functions above. </p>

</div>
</div>
<a id="a2b264924f2c8dc130e0be826f40e0da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b264924f2c8dc130e0be826f40e0da0">&#9670;&nbsp;</a></span>add() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a141369afc3169fc80597a7d70fa7b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141369afc3169fc80597a7d70fa7b7a6">&#9670;&nbsp;</a></span>add() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aae0643f15938ef8dc4727d90405cf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0643f15938ef8dc4727d90405cf83f">&#9670;&nbsp;</a></span>add() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a7126299241702719e409f59c0ec07d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126299241702719e409f59c0ec07d51">&#9670;&nbsp;</a></span>sadd() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a2d2bb04de50473779d407149dec7be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bb04de50473779d407149dec7be9f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code>*this = s*(*this)+a*V</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4f3e7e9460e7395dd67b95e61dd87d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e7e9460e7395dd67b95e61dd87d37">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4263fde23b0a636562ca9751d51b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263fde23b0a636562ca9751d51b5e4a">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa956ed8a13546e788464672e88057b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956ed8a13546e788464672e88057b65">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a0a3d0f3f7fb1a7d6196a0def1bacf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d0f3f7fb1a7d6196a0def1bacf371">&#9670;&nbsp;</a></span>scale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="a5feedb1e66657dcc91855748c936879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feedb1e66657dcc91855748c936879a">&#9670;&nbsp;</a></span>equ() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ab59511c3b4ce9b3fe8454c8657234a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59511c3b4ce9b3fe8454c8657234a25">&#9670;&nbsp;</a></span>equ() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p>

</div>
</div>
<a id="ae50dd04b204d8ebf6be467c3ebe2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50dd04b204d8ebf6be467c3ebe2234f">&#9670;&nbsp;</a></span>update_ghost_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

</div>
</div>
<a id="a31f18ed7d00d429247dc3127ba496e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f18ed7d00d429247dc3127ba496e42">&#9670;&nbsp;</a></span>block_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="a57d77409b8591a13d5ee10c2e705593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d77409b8591a13d5ee10c2e705593a">&#9670;&nbsp;</a></span>block_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted. The vector is resized if necessary. A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="a9c9b9333d11630bf0fc82a7957e0d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9b9333d11630bf0fc82a7957e0d1c1">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a3b7a75b54cfee3d921a467f2ca126b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a75b54cfee3d921a467f2ca126b54">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a6121484e53939ed6ad6024141ee0cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121484e53939ed6ad6024141ee0cd50">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a947f5b79fbf762a1d1070f44509dc3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947f5b79fbf762a1d1070f44509dc3b9">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>real_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8cc_source.html#l00082">82</a> of file <a class="el" href="vector_8cc_source.html">vector.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a14359ecc2fbab6f70b322e53b1d1fd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14359ecc2fbab6f70b322e53b1d1fd19">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="lac_2cuda__vector_8h_source.html#l00395">395</a> of file <a class="el" href="lac_2cuda__vector_8h_source.html">cuda_vector.h</a>.</p>

</div>
</div>
<a id="a1885633ec0ef8fc398d6a28a226d6176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1885633ec0ef8fc398d6a28a226d6176">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="lac_2la__parallel__vector_8h_source.html#l01751">1751</a> of file <a class="el" href="lac_2la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2e52ed1088f622c49c50dc4bf9638863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e52ed1088f622c49c50dc4bf9638863">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="lac_2read__write__vector_8h_source.html#l01135">1135</a> of file <a class="el" href="lac_2read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="fe_2mapping__q1__eulerian_8h_source.html">mapping_q1_eulerian.h</a></li>
<li>include/deal.II/lac/<a class="el" href="lac_2vector_8h_source.html">vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="lac_2cuda__vector_8h_source.html">cuda_vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="lac_2la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="lac_2read__write__vector_8h_source.html">read_write_vector.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="agroup__Vectors_html_gadc4d5e3c9046ec45d663831b83d715d1"><div class="ttname"><a href="group__Vectors.html#gadc4d5e3c9046ec45d663831b83d715d1">Vector::values</a></div><div class="ttdeci">AlignedVector&lt; Number &gt; values</div><div class="ttdef"><b>Definition:</b> <a href="lac_2vector_8h_source.html#l01026">vector.h:1026</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_aee5ef58d11434eb1d6a665e64bf17292"><div class="ttname"><a href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">LAPACKSupport::V</a></div><div class="ttdeci">static const char V</div><div class="ttdef"><b>Definition:</b> <a href="lac_2lapack__support_8h_source.html#l00192">lapack_support.h:192</a></div></div>
<div class="ttc" id="aclassVector_html_a10b0336c485e36c7b4b105dd2a926002"><div class="ttname"><a href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">Vector::add</a></div><div class="ttdeci">void add(const std::vector&lt; size_type &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;values)</div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
