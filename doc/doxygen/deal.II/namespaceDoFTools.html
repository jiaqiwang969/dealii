<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFTools Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom This module groups classes and namespaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDoFTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>
<br />
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>
<br />
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">always</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9">nonzero</a>
<br />
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a495fa975b1d6b81f0875bf641f266ce5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a495fa975b1d6b81f0875bf641f266ce5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a495fa975b1d6b81f0875bf641f266ce5">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>)</td></tr>
<tr class="separator:a495fa975b1d6b81f0875bf641f266ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85610f8869cebbc3be41aed240ea4b0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab85610f8869cebbc3be41aed240ea4b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab85610f8869cebbc3be41aed240ea4b0">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>)</td></tr>
<tr class="separator:ab85610f8869cebbc3be41aed240ea4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730347c0582a281b1fbea079d7906e6a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a730347c0582a281b1fbea079d7906e6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a730347c0582a281b1fbea079d7906e6a">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor)</td></tr>
<tr class="separator:a730347c0582a281b1fbea079d7906e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DoF couplings @{</h2></td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a4d7f078a8e828165a7a1ca42570fec22">convert_couplings_to_blocks</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;table_by_component, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;tables_by_block)</td></tr>
<tr class="separator:a4d7f078a8e828165a7a1ca42570fec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad2c28189ed143dc13fd899c32e62cbcf">dof_couplings_from_component_couplings</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e19a58dc4282f650a822c2f8450c76"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab3e19a58dc4282f650a822c2f8450c76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab3e19a58dc4282f650a822c2f8450c76">dof_couplings_from_component_couplings</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:ab3e19a58dc4282f650a822c2f8450c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Periodic boundary conditions @{</h2></td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator , typename number &gt; </td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;face_1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;face_2, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> <a class="el" href="fe_2fe__0_8txt.html#a656979c5d80ded568c257b16be98d547">face_orientation</a>=<a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> <a class="el" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a>=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> <a class="el" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a>=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;first_vector_components=<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor=1.)</td></tr>
<tr class="separator:a929249499b1e5624728d212e90a8e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7025d513a21d3d3804f89fdc9c3824a9">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;first_vector_components=<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor=1.)</td></tr>
<tr class="separator:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename number &gt; </td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a918a8dc3733662a03c0113296567564f">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;first_vector_components=<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor=1.)</td></tr>
<tr class="separator:a918a8dc3733662a03c0113296567564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aaa354b2b7e406e68c04c6e6ea07931f2">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor=1.)</td></tr>
<tr class="separator:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afa423b8e89505de76ca7d2ca0f53faa1">make_periodicity_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;<a class="el" href="fe_2fe__0_8txt.html#af3bc4a15e53bc3798f8af7412b219413">constraints</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> periodicity_factor=1.)</td></tr>
<tr class="separator:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DoF indices on patches of cells Create structures containing a large set of degrees of freedom for small patches of cells. The resulting objects can be used in RelaxationBlockSOR and related classes to implement Schwarz preconditioners and smoothers, where the subdomains consist of small numbers of cells only.</h2></td></tr>
<tr class="memitem:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aba4315ae585ff3b55ba9e6d2c26825a3">get_dofs_on_patch</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &amp;<a class="el" href="data__out__base__0_8txt.html#abff8270fbbbb0d3e9f0aeb14d7e3eec8">patch</a>)</td></tr>
<tr class="separator:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b18f331c186af35076459ff79fd86"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a976b18f331c186af35076459ff79fd86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a976b18f331c186af35076459ff79fd86">get_dofs_on_patch</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;<a class="el" href="data__out__base__0_8txt.html#abff8270fbbbb0d3e9f0aeb14d7e3eec8">patch</a>)</td></tr>
<tr class="separator:a976b18f331c186af35076459ff79fd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">make_cell_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;selected_dofs={}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> offset=0)</td></tr>
<tr class="separator:a43ee44769769065bc594d1730477a4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947b3175eb0d455cd2e875df09c9385"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7947b3175eb0d455cd2e875df09c9385"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7947b3175eb0d455cd2e875df09c9385">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> interior_dofs_only, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> boundary_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> level_boundary_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> single_cell_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> invert_vertex_mapping=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:a7947b3175eb0d455cd2e875df09c9385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300fb13f111c1292fa146b8eb756274"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4300fb13f111c1292fa146b8eb756274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a4300fb13f111c1292fa146b8eb756274">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classBlockMask.html">BlockMask</a> &amp;exclude_boundary_dofs=<a class="el" href="classBlockMask.html">BlockMask</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> boundary_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> level_boundary_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> single_cell_patches=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> invert_vertex_mapping=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:a4300fb13f111c1292fa146b8eb756274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a97fef09370d666eccd7f811d6df8d748">make_child_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> interior_dofs_only, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> boundary_dofs=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:a97fef09370d666eccd7f811d6df8d748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab270041c339a188ba4cb050f0c561737">make_single_patch</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> interior_dofs_only=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:ab270041c339a188ba4cb050f0c561737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Counting degrees of freedom and related functions @{</h2></td></tr>
<tr class="memitem:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">count_dofs_per_fe_component</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> vector_valued_once=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;target_component={})</td></tr>
<tr class="separator:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">count_dofs_per_fe_block</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;target_block=<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;())</td></tr>
<tr class="separator:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3e30887d7a90dc1422a9bb9e90ee1a05">get_active_fe_indices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;active_fe_indices)</td></tr>
<tr class="separator:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">count_dofs_on_patch</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &amp;<a class="el" href="data__out__base__0_8txt.html#abff8270fbbbb0d3e9f0aeb14d7e3eec8">patch</a>)</td></tr>
<tr class="separator:acf3d202ccd39aea458a476dd0928fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a99d249bd0c6f5ccb1ea86d498fd7e936">count_dofs_on_patch</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;<a class="el" href="data__out__base__0_8txt.html#abff8270fbbbb0d3e9f0aeb14d7e3eec8">patch</a>)</td></tr>
<tr class="separator:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions that return different DoF mappings @{</h2></td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>)</td></tr>
<tr class="separator:aa243d4c45775077c674ef6800e5ce215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2e367cf4d8590470cc136bec082b216b">map_dof_to_boundary_indices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>)</td></tr>
<tr class="separator:a2e367cf4d8590470cc136bec082b216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a5514e4f59ea659f63953d62ca429eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a8d68b6352f00a6e6c26eb728040284e6">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a8d68b6352f00a6e6c26eb728040284e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a297ef923ee03f234fc09ee4dcdd01140">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a297ef923ee03f234fc09ee4dcdd01140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad18da75343daf4b14fa0588445627eab">map_dofs_to_support_points</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a1e0120f991abf85a9a8ace8cb30b2093">mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ad18da75343daf4b14fa0588445627eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class Comp &gt; </td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3540ceb577e65414bde1b6b14808da2c">map_support_points_to_dofs</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, Comp &gt; &amp;point_to_index_map)</td></tr>
<tr class="separator:a3540ceb577e65414bde1b6b14808da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous @{</h2></td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a952f50bcd4f8fbb09924626ecc60c605">distribute_cell_to_dof_vector</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof_handler, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;cell_data, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;dof_data, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0)</td></tr>
<tr class="separator:a952f50bcd4f8fbb09924626ecc60c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">write_gnuplot_dof_support_point_info</a> (std::ostream &amp;<a class="el" href="la__parallel__block__vector__0_8txt.html#a38646e394cbb4630086107945fff0c2f">out</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;support_points)</td></tr>
<tr class="separator:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">make_zero_boundary_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> boundary_id, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;zero_boundary_constraints, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga326f0868782800e5fa9d8e90c9cef135">make_zero_boundary_constraints</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;dof, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;zero_boundary_constraints, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="point__value__history__0_8txt.html#a9e19016beb99fb379a024ac97f30eaf8">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga326f0868782800e5fa9d8e90c9cef135"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities. </p><h3>Setting up sparsity patterns</h3>
<p>When assembling system matrices, the entries are usually of the form \(a_{ij} = a(\phi_i, \phi_j)\) , where \(a\) is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those \(a_{ij}\) only, which are nonzero, which is the same as to say that the basis functions \(\phi_i\) and \(\phi_j\) have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell. There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.</p>
<h3>DoF numberings on boundaries</h3>
<p>When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with. What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a> if the dof is not on the boundary. With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. We need this mapping, for example, to build the mass matrix on the boundary (for this, see <a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">make_boundary_sparsity_pattern()</a> function, the corresponding section below, as well as the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace documentation). Actually, there are two <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed. Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>, as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. (As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy. It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the <a class="el" href="classFiniteElement.html">FiniteElement</a> class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)</p>
<h3>Setting up sparsity patterns for boundary matrices</h3>
<p>In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non- homogeneous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function (described above). The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace, the creation of the sparsity pattern is done by the <a class="el" href="dof__tools__0_8txt.html#a975b1e20aa2a3b31570940d09dacc62e">create_boundary_sparsity_pattern()</a> function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function. It then builds the sparsity pattern corresponding to integrals like \(\int_\Gamma \varphi_{b2d(i)} \varphi_{b2d(j)} dx\) , where \(i\) and \(j\) are indices into the matrix, and \(b2d(i)\) is the global DoF number of a degree of freedom sitting on a boundary (i.e., \(b2d\) is the inverse of the mapping returned by <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function).</p>
<p>This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities.</p>
<h3>Setting up sparsity patterns</h3>
<p>When assembling system matrices, the entries are usually of the form \(a_{ij} = a(\phi_i, \phi_j)\), where \(a\) is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those \(a_{ij}\) only, which are nonzero, which is the same as to say that the basis functions \(\phi_i\) and \(\phi_j\) have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell. There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.</p>
<h3>DoF numberings on boundaries</h3>
<p>When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with.</p>
<p>What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a> if the dof is not on the boundary.</p>
<p>With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. We need this mapping, for example, to build the mass matrix on the boundary (for this, see <a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">make_boundary_sparsity_pattern()</a> function, the corresponding section below, as well as the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace documentation).</p>
<p>Actually, there are two <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed.</p>
<p>Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>, as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>.</p>
<p>(As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy. It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the <a class="el" href="classFiniteElement.html">FiniteElement</a> class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)</p>
<h3>Setting up sparsity patterns for boundary matrices</h3>
<p>In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non- homogeneous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function (described above).</p>
<p>The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace, the creation of the sparsity pattern is done by the <a class="el" href="dof__tools__0_8txt.html#a975b1e20aa2a3b31570940d09dacc62e">create_boundary_sparsity_pattern()</a> function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function. It then builds the sparsity pattern corresponding to integrals like \(\int_\Gamma \varphi_{b2d(i)} \varphi_{b2d(j)} dx\), where \(i\) and \(j\) are indices into the matrix, and \(b2d(i)\) is the global DoF number of a degree of freedom sitting on a boundary (i.e., \(b2d\) is the inverse of the mapping returned by <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function). </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad31df71a29dd76de9b4ab241b2527160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df71a29dd76de9b4ab241b2527160">&#9670;&nbsp;</a></span>Coupling <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The flags used in tables by certain <code>make_*_pattern</code> functions to describe whether two components of the solution couple in the bilinear forms corresponding to cell or face terms. An example of using these flags is shown in the introduction of <a class="el" href="step_46.html">step-46</a> . In the descriptions of the individual elements below, remember that these flags are used as elements of tables of size <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> times <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> where each element indicates whether two components do or do not couple. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__tools_8h_source.html#l00210">210</a> of file <a class="el" href="dofs_2dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<a id="ad31df71a29dd76de9b4ab241b2527160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df71a29dd76de9b4ab241b2527160">&#9670;&nbsp;</a></span>Coupling <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The flags used in tables by certain <code>make_*_pattern</code> functions to describe whether two components of the solution couple in the bilinear forms corresponding to cell or face terms. An example of using these flags is shown in the introduction of <a class="el" href="step_46.html">step-46</a>.</p>
<p>In the descriptions of the individual elements below, remember that these flags are used as elements of tables of size <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> times <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> where each element indicates whether two components do or do not couple. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2dofs_2dof__tools_8h_source.html#l00226">226</a> of file <a class="el" href="origin_2dofs_2dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<a id="ad31df71a29dd76de9b4ab241b2527160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df71a29dd76de9b4ab241b2527160">&#9670;&nbsp;</a></span>Coupling <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The flags used in tables by certain <code>make_*_pattern</code> functions to describe whether two components of the solution couple in the bilinear forms corresponding to cell or face terms. An example of using these flags is shown in the introduction of <a class="el" href="step_46.html">step-46</a> . In the descriptions of the individual elements below, remember that these flags are used as elements of tables of size <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> times <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> where each element indicates whether two components do or do not couple. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a31206e30ead2b25c903cbc37a785c8c9"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2dofs_2dof__tools_8h_source.html#l00210">210</a> of file <a class="el" href="translator_2dofs_2dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4d7f078a8e828165a7a1ca42570fec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7f078a8e828165a7a1ca42570fec22">&#9670;&nbsp;</a></span>convert_couplings_to_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::convert_couplings_to_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table_by_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tables_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a coupling table from the user friendly organization by components to the organization by blocks. The return vector will be initialized to the correct length inside this function. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02358">2358</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad2c28189ed143dc13fd899c32e62cbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c28189ed143dc13fd899c32e62cbcf">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a finite element and a table how the vector components of it couple with each other, compute and return a table that describes how the individual shape functions couple with each other. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00708">708</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ab3e19a58dc4282f650a822c2f8450c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e19a58dc4282f650a822c2f8450c76">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above for a collection of finite elements, returning a collection of tables. The function currently treats DoFTools::Couplings::nonzero the same as DoFTools::Couplings::always . </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00749">749</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="a929249499b1e5624728d212e90a8e037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929249499b1e5624728d212e90a8e037">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &amp;&#160;</td>
          <td class="paramname"><em>face_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code><a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;unsigned&#160;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>. Given a pair of not necessarily active boundary faces <code>face_1</code> and <code>face_2</code>, this functions constrains all DoFs associated with the boundary described by <code>face_1</code> to the respective DoFs of the boundary described by <code>face_2</code>. More precisely: If <code>face_1</code> and <code>face_2</code> are both active faces it adds the DoFs of <code>face_1</code> to the list of constrained DoFs in <code>constraints</code> and adds entries to constrain them to the corresponding values of the DoFs on <code>face_2</code>. This happens on a purely algebraic level, meaning, the global DoF with (local face) index <code>i</code> on <code>face_1</code> gets constraint to the DoF with (local face) index <code>i</code> on <code>face_2</code> (possibly corrected for orientation, see below). Otherwise, if <code>face_1</code> and <code>face_2</code> are not active faces, this function loops recursively over the children of <code>face_1</code> and <code>face_2</code>. If only one of the two faces is active, then we recursively iterate over the children of the non-active ones and make sure that the solution function on the refined side equals that on the non-refined face in much the same way as we enforce hanging node constraints at places where differently refined cells come together. (However, unlike hanging nodes, we do not enforce the requirement that there be only a difference of one refinement level between the two sides of the domain you would like to be periodic). This routine only constrains DoFs that are not already constrained. If this routine encounters a DoF that already is constrained (for instance by Dirichlet boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens. The flags in the <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ) denote which components of the finite element space shall be constrained with periodic boundary conditions. If it is left as specified by the default value all components are constrained. If it is different from the default value, it is assumed that the number of entries equals the number of components of the finite element. This can be used to enforce periodicity in only one variable in a system of equations. <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> describe an orientation that should be applied to <code>face_1</code> prior to matching and constraining DoFs. This has nothing to do with the actual orientation of the given faces in their respective cells (which for boundary faces is always the default) but instead how you want to see periodicity to be enforced. For example, by using these flags, you can enforce a condition of the kind \(u(0,y)=u(1,1-y)\) (i.e., a Moebius band) or in 3d a twisted torus. More precisely, these flags match local face DoF indices in the following manner: In 2d: <code>face_orientation</code> must always be <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>; this implies e.g. for <code>Q1</code>: </p><div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  1                1</div>
<div class="line">  |        &lt;--&gt;    |</div>
<div class="line">  0                0</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1</div>
<div class="line"> </div>
<div class="line">  (Numbers <a class="code" href="laoperators__0_8txt.html#adb1fe2e68343594471e91a43c52b9a67">denote</a> <a class="code" href="block__info__0_8txt.html#a6e40fe1b2d784c06fbd9ad45ce139aac">local</a> <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> <a class="code" href="dof__renumbering__0_8txt.html#a834d5d19e92acf763e40c9176a517db4">DoF</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>.)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  0                1</div>
<div class="line">  |        &lt;--&gt;    |</div>
<div class="line">  1                0</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 1 &lt;-&gt; 0, 0 &lt;-&gt; 1</div>
</div><!-- fragment --><p> And similarly for the case of Q1 in 3d: </p><div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  2</div>
<div class="line"> </div>
<div class="line">- 3            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">  |   |    &lt;--&gt;    |   |</div>
<div class="line">  0</div>
<div class="line"> </div>
<div class="line">- 1            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1, 2 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line">  (Numbers <a class="code" href="laoperators__0_8txt.html#adb1fe2e68343594471e91a43c52b9a67">denote</a> <a class="code" href="block__info__0_8txt.html#a6e40fe1b2d784c06fbd9ad45ce139aac">local</a> <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> <a class="code" href="dof__renumbering__0_8txt.html#a834d5d19e92acf763e40c9176a517db4">DoF</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>.)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  1</div>
<div class="line"> </div>
<div class="line">- 3            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">  |   |    &lt;--&gt;    |   |</div>
<div class="line">  0</div>
<div class="line"> </div>
<div class="line">- 2            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  1</div>
<div class="line"> </div>
<div class="line">- 0            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">  |   |    &lt;--&gt;    |   |</div>
<div class="line">  3</div>
<div class="line"> </div>
<div class="line">- 2            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 3 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 0 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">  face1:           face2:</div>
<div class="line"> </div>
<div class="line">  0</div>
<div class="line"> </div>
<div class="line">- 2            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">  |   |    &lt;--&gt;    |   |</div>
<div class="line">  1</div>
<div class="line"> </div>
<div class="line">- 3            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
<div class="line"> </div>
<div class="line">  Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 1 &lt;-&gt; 0, 3 &lt;-&gt; 1, 0 &lt;-&gt; 2, 2 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a> any <a class="code" href="grid__out__0_8txt.html#a4764aa6a9ff4cc355ec2f8982984495a">combination</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a5abb1355f897601e766edb6b0ae168e8">that</a>...</div>
</div><!-- fragment --><p> Optionally a matrix <code>matrix</code> along with a std::vector <code>first_vector_components</code> can be specified that describes how DoFs on <code>face_1</code> should be modified prior to constraining to the DoFs of <code>face_2</code>. Here, two declarations are possible: If the std::vector <code>first_vector_components</code> is non empty the matrix is interpreted as a <code>dim</code> \(\times\) <code>dim</code> rotation matrix that is applied to all vector valued blocks listed in <code>first_vector_components</code> of the <a class="el" href="classFESystem.html">FESystem</a>. If <code>first_vector_components</code> is empty the matrix is interpreted as an interpolation matrix with size no_face_dofs \(\times\) no_face_dofs. This function makes sure that identity constraints don't create cycles in <code>constraints</code>. <code>periodicity_factor</code> can be used to implement Bloch periodic conditions (a.k.a. phase shift periodic conditions) of the form \(\psi(\mathbf{r})=e^{-i\mathbf{k}\cdot\mathbf{r}}u(\mathbf{r})\) where \(u\) is periodic with the same periodicity as the crystal lattice and \(\mathbf{k}\) is the wavevector, see <a href="https://en.wikipedia.org/wiki/Bloch_wave">https://en.wikipedia.org/wiki/Bloch_wave</a>. The solution at <code>face_2</code> is equal to the solution at <code>face_1</code> times <code>periodicity_factor</code>. For example, if the solution at <code>face_1</code> is \(\psi(0)\) and \(\mathbf{d}\) is the corresponding point on <code>face_2</code>, then the solution at <code>face_2</code> should be \(\psi(d) = \psi(0)e^{-i \mathbf{k}\cdot \mathbf{d}}\) . This condition can be implemented using \(\mathrm{periodicity\_factor}=e^{-i \mathbf{k}\cdot \mathbf{d}}\) . Detailed information can be found in the see <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a>.</p>
<p>Insert the (algebraic) constraints due to periodic boundary conditions into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>.</p>
<p>Given a pair of not necessarily active boundary faces <code>face_1</code> and <code>face_2</code>, this functions constrains all DoFs associated with the boundary described by <code>face_1</code> to the respective DoFs of the boundary described by <code>face_2</code>. More precisely:</p>
<p>If <code>face_1</code> and <code>face_2</code> are both active faces it adds the DoFs of <code>face_1</code> to the list of constrained DoFs in <code>constraints</code> and adds entries to constrain them to the corresponding values of the DoFs on <code>face_2</code>. This happens on a purely algebraic level, meaning, the global DoF with (local face) index <code>i</code> on <code>face_1</code> gets constraint to the DoF with (local face) index <code>i</code> on <code>face_2</code> (possibly corrected for orientation, see below).</p>
<p>Otherwise, if <code>face_1</code> and <code>face_2</code> are not active faces, this function loops recursively over the children of <code>face_1</code> and <code>face_2</code>. If only one of the two faces is active, then we recursively iterate over the children of the non-active ones and make sure that the solution function on the refined side equals that on the non-refined face in much the same way as we enforce hanging node constraints at places where differently refined cells come together. (However, unlike hanging nodes, we do not enforce the requirement that there be only a difference of one refinement level between the two sides of the domain you would like to be periodic).</p>
<p>This routine only constrains DoFs that are not already constrained. If this routine encounters a DoF that already is constrained (for instance by Dirichlet boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<p>The flags in the <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) denote which components of the finite element space shall be constrained with periodic boundary conditions. If it is left as specified by the default value all components are constrained. If it is different from the default value, it is assumed that the number of entries equals the number of components of the finite element. This can be used to enforce periodicity in only one variable in a system of equations.</p>
<p><code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> describe an orientation that should be applied to <code>face_1</code> prior to matching and constraining DoFs. This has nothing to do with the actual orientation of the given faces in their respective cells (which for boundary faces is always the default) but instead how you want to see periodicity to be enforced. For example, by using these flags, you can enforce a condition of the kind \(u(0,y)=u(1,1-y)\) (i.e., a Moebius band) or in 3d a twisted torus. More precisely, these flags match local face DoF indices in the following manner:</p>
<p>In 2d: <code>face_orientation</code> must always be <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>; this implies e.g. for <code>Q1</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    1                1</div>
<div class="line">    |        &lt;--&gt;    |</div>
<div class="line">    0                0</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1</div>
<div class="line"> </div>
<div class="line">    (Numbers <a class="code" href="laoperators__0_8txt.html#adb1fe2e68343594471e91a43c52b9a67">denote</a> <a class="code" href="block__info__0_8txt.html#a6e40fe1b2d784c06fbd9ad45ce139aac">local</a> <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> <a class="code" href="dof__renumbering__0_8txt.html#a834d5d19e92acf763e40c9176a517db4">DoF</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>.)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    0                1</div>
<div class="line">    |        &lt;--&gt;    |</div>
<div class="line">    1                0</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 1 &lt;-&gt; 0, 0 &lt;-&gt; 1</div>
</div><!-- fragment --><p>And similarly for the case of Q1 in 3d:</p>
<div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    2 - 3            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    0 - 1            0 - 1</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1, 2 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line">    (Numbers <a class="code" href="laoperators__0_8txt.html#adb1fe2e68343594471e91a43c52b9a67">denote</a> <a class="code" href="block__info__0_8txt.html#a6e40fe1b2d784c06fbd9ad45ce139aac">local</a> <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> <a class="code" href="dof__renumbering__0_8txt.html#a834d5d19e92acf763e40c9176a517db4">DoF</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>.)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    1 - 3            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    0 - 2            0 - 1</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 0 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">false</span>:</div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    1 - 0            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    3 - 2            0 - 1</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 3 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 0 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a> = <span class="keyword">true</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a> = <span class="keyword">false</span>, <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a> = <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">    face1:           face2:</div>
<div class="line"> </div>
<div class="line">    0 - 2            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    1 - 3            0 - 1</div>
<div class="line"> </div>
<div class="line">    Resulting <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>: 1 &lt;-&gt; 0, 3 &lt;-&gt; 1, 0 &lt;-&gt; 2, 2 &lt;-&gt; 3</div>
<div class="line"> </div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a> any <a class="code" href="grid__out__0_8txt.html#a4764aa6a9ff4cc355ec2f8982984495a">combination</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a5abb1355f897601e766edb6b0ae168e8">that</a>...</div>
</div><!-- fragment --><p>Optionally a matrix <code>matrix</code> along with a std::vector <code>first_vector_components</code> can be specified that describes how DoFs on <code>face_1</code> should be modified prior to constraining to the DoFs of <code>face_2</code>. Here, two declarations are possible: If the std::vector <code>first_vector_components</code> is non empty the matrix is interpreted as a <code>dim</code> \(\times\) <code>dim</code> rotation matrix that is applied to all vector valued blocks listed in <code>first_vector_components</code> of the <a class="el" href="classFESystem.html">FESystem</a>. If <code>first_vector_components</code> is empty the matrix is interpreted as an interpolation matrix with size no_face_dofs \(\times\) no_face_dofs.</p>
<p>This function makes sure that identity constraints don't create cycles in <code>constraints</code>.</p>
<p><code>periodicity_factor</code> can be used to implement Bloch periodic conditions (a.k.a. phase shift periodic conditions) of the form \(\psi(\mathbf{r})=e^{-i\mathbf{k}\cdot\mathbf{r}}u(\mathbf{r})\) where \(u\) is periodic with the same periodicity as the crystal lattice and \(\mathbf{k}\) is the wavevector, see <a href="https://en.wikipedia.org/wiki/Bloch_wave">https://en.wikipedia.org/wiki/Bloch_wave</a>. The solution at <code>face_2</code> is equal to the solution at <code>face_1</code> times <code>periodicity_factor</code>. For example, if the solution at <code>face_1</code> is \(\psi(0)\) and \(\mathbf{d}\) is the corresponding point on <code>face_2</code>, then the solution at <code>face_2</code> should be \(\psi(d) = \psi(0)e^{-i \mathbf{k}\cdot \mathbf{d}}\). This condition can be implemented using \(\mathrm{periodicity\_factor}=e^{-i \mathbf{k}\cdot \mathbf{d}}\).</p>
<p>Detailed information can be found in the see <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a>. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02288">2288</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="a7025d513a21d3d3804f89fdc9c3824a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7025d513a21d3d3804f89fdc9c3824a9">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;unsigned&#160;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>. This is the main high level interface for above low level variant of <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a>. It takes a std::vector <code>periodic_faces</code> as argument and applies above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> on each entry. <code>periodic_faces</code> can be created by <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>. </p><dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity</a> has to be called before calling this function.. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> <a class="el" href="histogram__0_8txt.html#a289e95579c441f9a994ce0a00f5a114a">and</a> <a class="el" href="step_45.html">step-45</a> <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> <a class="el" href="glossary__0_8txt.html#a26101cb65a540bcf4fbc81c2db3ba2df">further</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02532">2532</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="a918a8dc3733662a03c0113296567564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918a8dc3733662a03c0113296567564f">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;&#160;unsigned&#160;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000113">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000210">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>

</div>
</div>
<a id="aaa354b2b7e406e68c04c6e6ea07931f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa354b2b7e406e68c04c6e6ea07931f2">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> <code>constraints</code>. This function serves as a high level interface for the <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> function. Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>. This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a>. More precisely, faces with coordinates only differing in the <code>direction</code> component are identified. If this matching is successful it constrains all DoFs associated with the 'first' boundary to the respective DoFs of the 'second' boundary respecting the relative orientation of the two faces. </p><dl class="section note"><dt>Note</dt><dd>This function is a convenience wrapper. It internally calls <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> with the supplied parameters and feeds the output to above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> variant. If you need more functionality use <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> directly. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> <a class="el" href="glossary__0_8txt.html#a26101cb65a540bcf4fbc81c2db3ba2df">further</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a>. </dd></dl>

</div>
</div>
<a id="afa423b8e89505de76ca7d2ca0f53faa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa423b8e89505de76ca7d2ca0f53faa1">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of make_periodicity_constraints only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>. Instead of defining a 'first' and 'second' boundary with the help of two boundary_ids this function defines a 'left' boundary as all faces with local face index <code>2*dimension</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*dimension+1</code> and boundary indicator <code>b_id</code>. Faces with coordinates only differing in the <code>direction</code> component are identified. </p><dl class="section note"><dt>Note</dt><dd>This version of make_periodicity_constraints will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>. </dd>
<dd>
This function is a convenience wrapper. It internally calls <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> with the supplied parameters and feeds the output to above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> variant. If you need more functionality use <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> directly. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> <a class="el" href="glossary__0_8txt.html#a26101cb65a540bcf4fbc81c2db3ba2df">further</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02606">2606</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="aed6928cb7bdb5a85e8670d6bd5c90e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6928cb7bdb5a85e8670d6bd5c90e24">&#9670;&nbsp;</a></span>extract_hanging_node_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_hanging_node_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classIndexSet.html">IndexSet</a> describing all dofs that will be constrained by interface constraints, i.e. all hanging nodes. In case of a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> only locally relevant dofs are considered. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01019">1019</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a45f4d01f1c4c6337e4be6f10a81fbdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f4d01f1c4c6337e4be6f10a81fbdab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the (locally owned) indices of the degrees of freedom belonging to certain vector components of a vector-valued finite element. The <code>component_mask</code> defines which components or blocks of an <a class="el" href="classFESystem.html">FESystem</a> or vector-valued element are to be extracted from the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof</code>. The entries in the output object then correspond to degrees of freedom belonging to these components. If the finite element under consideration is not primitive, i.e., some or all of its shape functions are non-zero in more than one vector component (which holds, for example, for <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> or <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements), then shape functions cannot be associated with a single vector component. In this case, if <em> one </em> shape vector component of this element is flagged in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ), then this is equivalent to selecting <em> all </em> vector components corresponding to this non-primitive base element.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask that states which components you want to select. The size of this mask must be compatible with the number of components in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns.</dd></dl>
<p>Extract the (locally owned) indices of the degrees of freedom belonging to certain vector components of a vector-valued finite element. The <code>component_mask</code> defines which components or blocks of an <a class="el" href="classFESystem.html">FESystem</a> or vector-valued element are to be extracted from the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof</code>. The entries in the output object then correspond to degrees of freedom belonging to these components.</p>
<p>If the finite element under consideration is not primitive, i.e., some or all of its shape functions are non-zero in more than one vector component (which holds, for example, for <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> or <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements), then shape functions cannot be associated with a single vector component. In this case, if <em>one</em> shape vector component of this element is flagged in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), then this is equivalent to selecting <em>all</em> vector components corresponding to this non-primitive base element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask that states which components you want to select. The size of this mask must be compatible with the number of components in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00393">393</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a63ec0cf2cf5feceaddf484a5d72126ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ec0cf2cf5feceaddf484a5d72126ab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent to the <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs()</a> functions above except that the selection of which degrees of freedom to extract is not done based on components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> ) but instead based on whether they are part of a particular block (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> ). Consequently, the second argument is not a <a class="el" href="classComponentMask.html">ComponentMask</a> but a <a class="el" href="classBlockMask.html">BlockMask</a> object.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_mask</td><td>A mask that states which blocks you want to select. The size of this mask must be compatible with the number of blocks in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary entry on block masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns.</dd></dl>
<p>This function is the equivalent to the <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs()</a> functions above except that the selection of which degrees of freedom to extract is not done based on components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a>) but instead based on whether they are part of a particular block (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a>). Consequently, the second argument is not a <a class="el" href="classComponentMask.html">ComponentMask</a> but a <a class="el" href="classBlockMask.html">BlockMask</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_mask</td><td>A mask that states which blocks you want to select. The size of this mask must be compatible with the number of blocks in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary entry on block masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00434">434</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a86b041e2441000ccd13f2dad06537678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b041e2441000ccd13f2dad06537678">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00480">480</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="af4f492fd7f9f9511f3b5c38dc5d9fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f492fd7f9f9511f3b5c38dc5d9fefa">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00537">537</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a06b3c33925c1a1f15de20deda20b4d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b3c33925c1a1f15de20deda20b4d21">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the last non-default-valued parameter which contains <code>true</code> if a degree of freedom is at the boundary and belongs to one of the selected components, and <code>false</code> otherwise. By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list, then all boundary indicators are accepted. The size of <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ) shall equal the number of components in the finite element used by <code>dof</code>. The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array are overwritten. Using the usual convention, if a shape function is non-zero in more than one component (i.e. it is non-primitive), then the element in the component mask is used that corresponds to the first non-zero components. Elements in the mask corresponding to later components are ignored. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>This function will not work for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. The reasons is that the output argument <code>selected_dofs</code> has to have a length equal to <em>all</em> global degrees of freedom. Consequently, this does not scale to very large problems, and this is also why the function is deprecated. If you need the functionality of this function for parallel triangulations, then you need to use the other <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs()</a> function that returns its information via an <a class="el" href="classIndexSet.html">IndexSet</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected_dofs</td><td>A vector of booleans that is returned and for which an element will be <code>true</code> if the corresponding index is a degree of freedom that is located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non- empty list, then the function only considers boundary faces with the boundary indicators listed in this argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the last non-default-valued parameter which contains <code>true</code> if a degree of freedom is at the boundary and belongs to one of the selected components, and <code>false</code> otherwise.</p>
<p>By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list, then all boundary indicators are accepted.</p>
<p>The size of <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) shall equal the number of components in the finite element used by <code>dof</code>. The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array are overwritten.</p>
<p>Using the usual convention, if a shape function is non-zero in more than one component (i.e. it is non-primitive), then the element in the component mask is used that corresponds to the first non-zero components. Elements in the mask corresponding to later components are ignored.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>This function will not work for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. The reasons is that the output argument <code>selected_dofs</code> has to have a length equal to <em>all</em> global degrees of freedom. Consequently, this does not scale to very large problems, and this is also why the function is deprecated. If you need the functionality of this function for parallel triangulations, then you need to use the other <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs()</a> function that returns its information via an <a class="el" href="classIndexSet.html">IndexSet</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected_dofs</td><td>A vector of booleans that is returned and for which an element will be <code>true</code> if the corresponding index is a degree of freedom that is located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non- empty list, then the function only considers boundary faces with the boundary indicators listed in this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the last non-default-valued parameter which contains <code>true</code> if a degree of freedom is at the boundary and belongs to one of the selected components, and <code>false</code> otherwise. By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list, then all boundary indicators are accepted. The size of <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ) shall equal the number of components in the finite element used by <code>dof</code>. The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array are overwritten. Using the usual convention, if a shape function is non-zero in more than one component (i.e. it is non-primitive), then the element in the component mask is used that corresponds to the first non-zero components. Elements in the mask corresponding to later components are ignored. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000211">Deprecated:</a></b></dt><dd>This function will not work for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. The reasons is that the output argument <code>selected_dofs</code> has to have a length equal to <em>all</em> global degrees of freedom. Consequently, this does not scale to very large problems, and this is also why the function is deprecated. If you need the functionality of this function for parallel triangulations, then you need to use the other <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs()</a> function that returns its information via an <a class="el" href="classIndexSet.html">IndexSet</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected_dofs</td><td>A vector of booleans that is returned and for which an element will be <code>true</code> if the corresponding index is a degree of freedom that is located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non- empty list, then the function only considers boundary faces with the boundary indicators listed in this argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00553">553</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a05eb3b759a0491c2087cf3befcc39cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eb3b759a0491c2087cf3befcc39cc4">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the form of an <a class="el" href="classIndexSet.html">IndexSet</a> that contains those entries that correspond to these selected degrees of freedom, i.e., which are at the boundary and belong to one of the selected components. By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list (the default), then all boundary indicators are accepted. This function is used in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_15.html">step-15</a> , for example.</p>
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the form of an <a class="el" href="classIndexSet.html">IndexSet</a> that contains those entries that correspond to these selected degrees of freedom, i.e., which are at the boundary and belong to one of the selected components.</p>
<p>By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list (the default), then all boundary indicators are accepted.</p>
<p>This function is used in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_15.html">step-15</a>, for example.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classDoFHandler.html">DoFHandler</a> object is defined on a parallel <a class="el" href="classTriangulation.html">Triangulation</a> object, then the computed index set will contain only those degrees of freedom on the boundary that belong to the locally relevant set (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>), i.e., the function only considers faces of locally owned and ghost cells, but not of artificial cells.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). If left at the default, the component mask indicates that all vector components of the finite element should be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non-empty list, then the function only considers boundary faces with the boundary indicators listed in this argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain the indices of degrees of freedom that are located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00594">594</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a905daad9c1cf1db522610811cd555b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905daad9c1cf1db522610811cd555b56">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as the previous function, except that it returns its information via the third argument. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use the previous function instead.</dd></dl>
<p>The same as the previous function, except that it returns its information via the third argument.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>Use the previous function instead. </dd></dl>
<p>The same as the previous function, except that it returns its information via the third argument. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000212">Deprecated:</a></b></dt><dd>Use the previous function instead.</dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00580">580</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a8b97e816b29ecf963370a9d8b349828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b97e816b29ecf963370a9d8b349828f">&#9670;&nbsp;</a></span>extract_dofs_with_support_on_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs_with_support_on_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code><a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt;<a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">extract_boundary_dofs()</a> function but it extracts those degrees of freedom whose shape functions are nonzero on at least part of the selected boundary. For continuous elements, this is exactly the set of shape functions whose degrees of freedom are defined on boundary faces. On the other hand, if the finite element in used is a discontinuous element, all degrees of freedom are defined in the inside of cells and consequently none would be boundary degrees of freedom. Several of those would have shape functions that are nonzero on the boundary, however. This function therefore extracts all those for which the <a class="el" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">FiniteElement::has_support_on_face</a> function says that it is nonzero on any face on one of the selected boundary parts. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00722">722</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a097aa54937055733af934542b5c76e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097aa54937055733af934542b5c76e35">&#9670;&nbsp;</a></span>extract_dofs_with_support_contained_within()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs_with_support_contained_within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;<a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all indices of shape functions such that their support is entirely contained within the cells for which the <code>predicate</code> is <code>true</code> . The result is returned as an <a class="el" href="classIndexSet.html">IndexSet</a>. Consider the following FE space where predicate returns <code>true</code> for all cells on the left half of the domain: </p><div class="image">
<img src="extract_dofs_with_support_contained_within.png" alt=""/>
<div class="caption">
This functions will return the union of all DoF indices on those cells minus DoF 11, 13, 2 and 0; the result will be [9,10], 12, [14,38]. In the image above the returned DoFs are separated from the rest by the red line Essentially, the question this functions answers is the following: Given a subdomain with associated DoFs, what is the largest subset of these DoFs that are allowed to be non-zero such that after calling AffineConstraints::distribute() the resulting solution vector will have support only within the given domain. Here, <code>constraints</code> is the AffineConstraints container containing hanging nodes constraints. In case of parallel::distributed::Triangulation <code>predicate</code> will be called only for locally owned and ghost cells. The resulting index set may contain DoFs that are associated with the locally owned or ghost cells, but are not owned by the current MPI core.</div></div>
<p>Extract all indices of shape functions such that their support is entirely contained within the cells for which the <code>predicate</code> is <code>true</code>. The result is returned as an <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Consider the following FE space where predicate returns <code>true</code> for all cells on the left half of the domain:</p>
<div class="image">
<img src="extract_dofs_with_support_contained_within.png" alt=""/>
</div>
<p>This functions will return the union of all DoF indices on those cells minus DoF 11, 13, 2 and 0; the result will be <code>[9,10], 12, [14,38]</code>. In the image above the returned DoFs are separated from the rest by the red line</p>
<p>Essentially, the question this functions answers is the following: Given a subdomain with associated DoFs, what is the largest subset of these DoFs that are allowed to be non-zero such that after calling <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> the resulting solution vector will have support only within the given domain. Here, <code>constraints</code> is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container containing hanging nodes constraints.</p>
<p>In case of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> <code>predicate</code> will be called only for locally owned and ghost cells. The resulting index set may contain DoFs that are associated with the locally owned or ghost cells, but are not owned by the current MPI core. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00804">804</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="afc96893388fe1a55c6ae5ae19ba52c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc96893388fe1a55c6ae5ae19ba52c6d">&#9670;&nbsp;</a></span>extract_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_constant_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector that represents the constant modes of the <a class="el" href="classDoFHandler.html">DoFHandler</a> for the components chosen by <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ). The constant modes on a discretization are the null space of a Laplace operator on the selected components with Neumann boundary conditions applied. The null space is a necessary ingredient for obtaining a good AMG preconditioner when using the class <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. Since the ML AMG package only works on algebraic properties of the respective matrix, it has no chance to detect whether the matrix comes from a scalar or a vector valued problem. However, a near null space supplies exactly the needed information about the components placement of vector components within the matrix. The null space (or rather, the constant modes) is provided by the finite element underlying the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and for most elements, the null space will consist of as many vectors as there are true arguments in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ), each of which will be one in one vector component and zero in all others. However, the representation of the constant function for e.g. <a class="el" href="classFE__DGP.html">FE_DGP</a> is different (the first component on each element one, all other components zero), and some scalar elements may even have two constant modes (<a class="el" href="classFE__Q__DG0.html">FE_Q_DG0</a>). Therefore, we store this object in a vector of vectors, where the outer vector contains the collection of the actual constant modes on the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Each inner vector has as many components as there are (locally owned) degrees of freedom in the selected components. Note that any matrix associated with this null space must have been constructed using the same <code>component_mask</code> argument, since the numbering of DoFs is done relative to the selected dofs, not to all dofs. The main reason for this program is the use of the null space with the AMG preconditioner.</p>
<p>Extract a vector that represents the constant modes of the <a class="el" href="classDoFHandler.html">DoFHandler</a> for the components chosen by <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). The constant modes on a discretization are the null space of a Laplace operator on the selected components with Neumann boundary conditions applied. The null space is a necessary ingredient for obtaining a good AMG preconditioner when using the class <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. Since the ML AMG package only works on algebraic properties of the respective matrix, it has no chance to detect whether the matrix comes from a scalar or a vector valued problem. However, a near null space supplies exactly the needed information about the components placement of vector components within the matrix. The null space (or rather, the constant modes) is provided by the finite element underlying the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and for most elements, the null space will consist of as many vectors as there are true arguments in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), each of which will be one in one vector component and zero in all others. However, the representation of the constant function for e.g. <a class="el" href="classFE__DGP.html">FE_DGP</a> is different (the first component on each element one, all other components zero), and some scalar elements may even have two constant modes (<a class="el" href="classFE__Q__DG0.html">FE_Q_DG0</a>). Therefore, we store this object in a vector of vectors, where the outer vector contains the collection of the actual constant modes on the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Each inner vector has as many components as there are (locally owned) degrees of freedom in the selected components. Note that any matrix associated with this null space must have been constructed using the same <code>component_mask</code> argument, since the numbering of DoFs is done relative to the selected dofs, not to all dofs.</p>
<p>The main reason for this program is the use of the null space with the AMG preconditioner. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01227">1227</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a6f9a91bfa884faa7a62acc8ff789f40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a91bfa884faa7a62acc8ff789f40e">&#9670;&nbsp;</a></span>extract_subdomain_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_subdomain_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all those degrees of freedom which are on cells with the given subdomain id. Note that DoFs on faces can belong to cells with differing subdomain ids, so the sets of flagged degrees of freedom are not mutually exclusive for different subdomain ids. If you want to get a unique association of degree of freedom with subdomains, use the <code>get_subdomain_association</code> function. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01028">1028</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a5f745d25d2397a91dc65b9158b8d77a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f745d25d2397a91dc65b9158b8d77a6">&#9670;&nbsp;</a></span>extract_locally_active_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is a superset of <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> and contains all DoF indices that live on all locally owned cells (including on the interface to ghost cells). However, it does not contain the DoF indices that are exclusively defined on ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>). The degrees of freedom identified by this function equal those obtained from the <a class="el" href="namespaceDoFTools.html#a0a84027251b470f94bcaf1f00e04e722">dof_indices_with_subdomain_association()</a> function when called with the locally owned subdomain id. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01062">1062</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="af778defeb024f32c1e3500963936639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af778defeb024f32c1e3500963936639f">&#9670;&nbsp;</a></span>extract_locally_active_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_level_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above but for a certain (multigrid-)level. This function returns all DoF indices that live on all locally owned cells (including on the interface to ghost cells) on the given level. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01097">1097</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="acad7e0841b9046eaafddc4c617ab1d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7e0841b9046eaafddc4c617ab1d9d">&#9670;&nbsp;</a></span>extract_locally_relevant_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is the union of <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> and the DoF indices on all ghost cells. In essence, it is the DoF indices on all cells that are not artificial (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>). </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01133">1133</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a6378e20da50d4bda1050db19ce43d5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6378e20da50d4bda1050db19ce43d5ed">&#9670;&nbsp;</a></span>locally_owned_dofs_per_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_owned_dofs_per_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of locally owned DoF indices for each component within the mask that are owned by the current processor. For components disabled by the mask, an empty <a class="el" href="classIndexSet.html">IndexSet</a> is returned. For a scalar <a class="el" href="classDoFHandler.html">DoFHandler</a> built on a sequential triangulation, the return vector contains a single complete <a class="el" href="classIndexSet.html">IndexSet</a> with all DoF indices. If the mask contains all components (which also corresponds to the default value), then the union of the returned index sets equlas what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00446">446</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a180d7118ecf27d72afbfecb7978c5e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180d7118ecf27d72afbfecb7978c5e09">&#9670;&nbsp;</a></span>locally_owned_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_owned_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each processor, determine the set of locally owned degrees of freedom as an <a class="el" href="classIndexSet.html">IndexSet</a>. This function then returns a vector of index sets, where the vector has size equal to the number of MPI processes that participate in the DoF handler object. The function can be used for objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. It will not work for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since for such triangulations we do not have information about all cells of the triangulation available locally, and consequently can not say anything definitive about the degrees of freedom active on other processors' locally owned cells. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01337">1337</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="aa2f9b39d216419f46312417550dbdd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f9b39d216419f46312417550dbdd20">&#9670;&nbsp;</a></span>locally_relevant_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_relevant_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each processor, determine the set of locally relevant degrees of freedom as an <a class="el" href="classIndexSet.html">IndexSet</a>. This function then returns a vector of index sets, where the vector has size equal to the number of MPI processes that participate in the DoF handler object. The function can be used for objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. It will not work for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since for such triangulations we do not have information about all cells of the triangulation available locally, and consequently can not say anything definitive about the degrees of freedom active on other processors' locally owned cells. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01432">1432</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a1fef7be07cf379b661646e39b9354e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef7be07cf379b661646e39b9354e17">&#9670;&nbsp;</a></span>extract_locally_relevant_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_level_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">extract_locally_relevant_dofs()</a> but for multigrid DoFs for the given <code>level</code>. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01175">1175</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a0429b3117b2ab1f5a1fd0d55de26ad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429b3117b2ab1f5a1fd0d55de26ad81">&#9670;&nbsp;</a></span>get_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each degree of freedom, return in the output array to which subdomain (as given by the <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code> function) it belongs. The output array is supposed to have the right size already when calling this function. Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. In these cases, we assign them to the process with the smaller subdomain id. This may lead to different numbers of degrees of freedom in partitions, even if the number of cells is perfectly equidistributed. While this is regrettable, it is not a problem in practice since the number of degrees of freedom on partition boundaries is asymptotically vanishing as we refine the mesh as long as the number of partitions is kept constant. This function returns the association of each DoF with one subdomain. If you are looking for the association of each <em>cell</em> with a subdomain, either query the <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code> function, or use the <code><a class="el" href="namespaceGridTools.html#ac41d959ae1723a898b616c3320241ffe">GridTools::get_subdomain_association</a></code> function. Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01508">1508</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ac704c6d311cd0f289d625427e03708ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac704c6d311cd0f289d625427e03708ac">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index. Note that there may be rare cases where cells with the given <code>subdomain</code> index exist, but none of its degrees of freedom are actually associated with it. In that case, the returned value will be zero. This function will generate an exception if there are no cells with the given <code>subdomain</code> index. This function returns the number of DoFs associated with one subdomain. If you are looking for the association of <em>cells</em> with this subdomain, use the <code><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a></code> function. Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01604">1604</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad38e53eb1c27d67f5e341399356edb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e53eb1c27d67f5e341399356edb55">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_dofs_on_subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index. This function does what the previous one does except that it splits the result among the vector components of the finite element in use by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. The last argument (which must have a length equal to the number of vector components) will therefore store how many degrees of freedom of each vector component are associated with the given subdomain. Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01680">1680</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a0a84027251b470f94bcaf1f00e04e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84027251b470f94bcaf1f00e04e722">&#9670;&nbsp;</a></span>dof_indices_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::dof_indices_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a set of indices that denotes the degrees of freedom that live on the given subdomain, i.e. that are on cells owned by the current processor. Note that this includes the ones that this subdomain "owns" (i.e. the ones for which <a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">get_subdomain_association()</a> returns a value equal to the subdomain given here and that are selected by the <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> function) but also all of those that sit on the boundary between the given subdomain and other subdomain. In essence, degrees of freedom that sit on boundaries between subdomain will be in the index sets returned by this function for more than one subdomain. Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01621">1621</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="aba4315ae585ff3b55ba9e6d2c26825a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4315ae585ff3b55ba9e6d2c26825a3">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of degrees of freedom that live on a set of cells (i.e., a patch) described by the argument. Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. While <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a> can be used to determine the size of these local problems, so that one can assemble the local system and then solve it, it is still necessary to provide a mapping between the global indices of the degrees of freedom that live on the patch and a local enumeration. This function provides such a local enumeration by returning the set of degrees of freedom that live on the patch. Since this set is returned in the form of a std::vector, one can also think of it as a mapping </p><div class="fragment"><div class="line"><a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div>
<div class="line"> </div>
<div class="line">-&gt; <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">global_dof_index</a></div>
</div><!-- fragment --><p> where <code>i</code> is an index into the returned vector (i.e., a the <em>local</em> index of a degree of freedom on the patch) and <code>global_dof_index</code> is the global index of a degree of freedom located on the patch. The array returned has size equal to <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a>. </p><dl class="section note"><dt>Note</dt><dd>The array returned is sorted by global DoF index. Consequently, if one considers the index into this array a local DoF index, then the local system that results retains the block structure of the global system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim,   spacedim&gt;::active_cell_iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of those global degrees of freedom located on the patch, as defined above. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells.</dd></dl>
<p>Return the set of degrees of freedom that live on a set of cells (i.e., a patch) described by the argument.</p>
<p>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. While <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a> can be used to determine the size of these local problems, so that one can assemble the local system and then solve it, it is still necessary to provide a mapping between the global indices of the degrees of freedom that live on the patch and a local enumeration. This function provides such a local enumeration by returning the set of degrees of freedom that live on the patch.</p>
<p>Since this set is returned in the form of a std::vector, one can also think of it as a mapping </p><div class="fragment"><div class="line"><a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> -&gt; <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">global_dof_index</a></div>
</div><!-- fragment --><p> where <code>i</code> is an index into the returned vector (i.e., a the <em>local</em> index of a degree of freedom on the patch) and <code>global_dof_index</code> is the global index of a degree of freedom located on the patch. The array returned has size equal to <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The array returned is sorted by global DoF index. Consequently, if one considers the index into this array a local DoF index, then the local system that results retains the block structure of the global system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim, spacedim&gt;::active_cell_iterator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of those global degrees of freedom located on the patch, as defined above.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02775">2775</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a976b18f331c186af35076459ff79fd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976b18f331c186af35076459ff79fd86">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000213">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>

</div>
</div>
<a id="a43ee44769769065bc594d1730477a4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee44769769065bc594d1730477a4b9">&#9670;&nbsp;</a></span>make_cell_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_cell_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a sparsity pattern, which lists the degrees of freedom associated to each cell on the given level. This pattern can be used in <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a> classes as block list for additive and multiplicative Schwarz methods. The row index in this pattern is the cell index resulting from standard iteration through a level of the <a class="el" href="classTriangulation.html">Triangulation</a>. For a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, only locally owned cells are entered. The sparsity pattern is resized in this function to contain as many rows as there are locally owned cells on a given level, as many columns as there are degrees of freedom on this level. <code>selected_dofs</code> is a vector indexed by the local degrees of freedom on a cell. If it is used, only such dofs are entered into the block list which are selected. This allows for instance the exclusion of components or of dofs on the boundary. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02411">2411</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a7947b3175eb0d455cd2e875df09c9385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947b3175eb0d455cd2e875df09c9385">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every vertex on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with the adjacent cells. This data structure is a matrix with as many rows as there are vertices on a given level, as many columns as there are degrees of freedom on this level, and entries that are either true or false. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size. The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_patches</code> for non- essential boundary conditions. This function returns the <code>vertex_mapping</code>, that contains the mapping from the vertex indices to the block indices of the <code>block_list</code>. For vertices that do not lead to a vertex patch, the entry in <code>vertex_mapping</code> contains the value <code>invalid_unsigned_int</code>. If <code>invert_vertex_mapping</code> is set to <code>true</code>, then the <code>vertex_mapping</code> is inverted such that it contains the mapping from the block indices to the corresponding vertex indices. </p><ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored. </li>
<li><code>dof_handler</code>: the multilevel dof handler providing the topology operated on. </li>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type. </li>
<li><code>boundary_patches</code>: include patches around vertices at the boundary of the domain. If not, only patches around interior vertices will be generated. </li>
<li><code>level_boundary_patches</code>: same for refinement edges towards coarser cells. </li>
<li><code>single_cell_patches</code>: if not true, patches containing a single cell are eliminated. </li>
<li><code>invert_vertex_mapping</code>: if true, then the return value contains one vertex index for each block; if false, then the return value contains one block index or <code>invalid_unsigned_int</code> for each vertex. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02570">2570</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a4300fb13f111c1292fa146b8eb756274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300fb13f111c1292fa146b8eb756274">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>exclude_boundary_dofs</em> = <code><a class="el" href="classBlockMask.html">BlockMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but allows boundary dofs on blocks to be excluded individually. This is helpful if you want to use, for example, Taylor Hood elements as it allows you to not include the boundary DoFs for the velocity block on the patches while also letting you include the boundary DoFs for the pressure block. For each patch of cells around a vertex, collect all of the interior degrees of freedom of the patch and disregard those on the boundary of the patch if the boolean value for the corresponding block in the <a class="el" href="classBlockMask.html">BlockMask</a> of <code>exclude_boundary_dofs</code> is false. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02593">2593</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a97fef09370d666eccd7f811d6df8d748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fef09370d666eccd7f811d6df8d748">&#9670;&nbsp;</a></span>make_child_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_child_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_dofs</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every cell on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with children of this cell. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object. The function thus creates a sparsity pattern which in each row (with rows corresponding to the cells on this level) lists the degrees of freedom associated to the cells that are the children of this cell. The DoF indices used here are level dof indices of a multilevel hierarchy, i.e., they may be associated with children that are not themselves active. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size. The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_dofs</code> for non- essential boundary conditions. </p><ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored. </li>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on. </li>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type. </li>
<li><code>boundary_dofs</code>: include degrees of freedom, which would have excluded by <code>interior_dofs_only</code>, but are lying on the boundary of the domain, and thus need smoothing. This parameter has no effect if <code>interior_dofs_only</code> is false. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02502">2502</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ab270041c339a188ba4cb050f0c561737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270041c339a188ba4cb050f0c561737">&#9670;&nbsp;</a></span>make_single_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_single_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a block list with only a single patch, which in turn contains all degrees of freedom on the given level. This function is mostly a closure on level 0 for functions like <a class="el" href="namespaceDoFTools.html#a97fef09370d666eccd7f811d6df8d748">make_child_patches()</a> and <a class="el" href="namespaceDoFTools.html#a7947b3175eb0d455cd2e875df09c9385">make_vertex_patches()</a>, which may produce an empty patch list. </p><ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored. </li>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on. </li>
<li><code>level</code> The grid level used for building the list. </li>
<li><code>interior_dofs_only</code>: if true, exclude degrees of freedom on the boundary of the domain. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02457">2457</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a956ac5c6aab03ec1c04f1ad955301db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ac5c6aab03ec1c04f1ad955301db9">&#9670;&nbsp;</a></span>count_dofs_per_fe_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; DoFTools::count_dofs_per_fe_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>vector_valued_once</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom out of the total number belong to each component. If the number of components the finite element has is one (i.e. you only have one scalar variable), then the number in this component obviously equals the total number of degrees of freedom. Otherwise, the sum of the DoFs in all the components needs to equal the total number. However, the last statement does not hold true if the finite element is not primitive, i.e. some or all of its shape functions are non-zero in more than one vector component. This applies, for example, to the Nedelec or Raviart-Thomas elements. In this case, a degree of freedom is counted in each component in which it is non-zero, so that the sum mentioned above is greater than the total number of degrees of freedom. This behavior can be switched off by the optional parameter <code>vector_valued_once</code>. If this is <code>true</code>, the number of components of a nonprimitive vector valued element is collected only in the first component. All other components will have a count of zero. The additional optional argument <code>target_component</code> allows for a re- sorting and grouping of components. To this end, it contains for each component the component number it shall be counted as. Having the same number entered several times sums up several components as the same. One of the applications of this argument is when you want to form block matrices and vectors, but want to pack several components into the same block (for example, when you have <code>dim</code> velocities and one pressure, to put all velocities into one block, and the pressure into another). The result is returned in <code>dofs_per_component</code>. Note that the size of <code>dofs_per_component</code> needs to be enough to hold all the indices specified in <code>target_component</code>. If this is not the case, an assertion is thrown. The indices not targeted by target_components are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01851">1851</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a796721b56b3a90e4e3973c7caae4c3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796721b56b3a90e4e3973c7caae4c3d8">&#9670;&nbsp;</a></span>count_dofs_per_fe_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; DoFTools::count_dofs_per_fe_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_block</em> = <code><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;unsigned&#160;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the degrees of freedom in each block. This function is similar to <a class="el" href="namespaceMGTools.html#ae5631c4421ffde9e2107d9f7884a1b41">count_dofs_per_component()</a>, with the difference that the counting is done by blocks. See <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> in the glossary for details. Again the vectors are assumed to have the correct size before calling this function. If this is not the case, an assertion is thrown. This function is used in the <a class="el" href="step_22.html">step-22</a> , <a class="el" href="step_31.html">step-31</a> , and <a class="el" href="step_32.html">step-32</a> tutorial programs, among others. </p><dl class="section pre"><dt>Precondition</dt><dd>The dofs_per_block variable has as many components as the finite element used by the dof_handler argument has blocks, or alternatively as many blocks as are enumerated in the target_blocks argument if given.</dd></dl>
<p>Count the degrees of freedom in each block. This function is similar to <a class="el" href="namespaceMGTools.html#ae5631c4421ffde9e2107d9f7884a1b41">count_dofs_per_component()</a>, with the difference that the counting is done by blocks. See <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> in the glossary for details. Again the vectors are assumed to have the correct size before calling this function. If this is not the case, an assertion is thrown.</p>
<p>This function is used in the <a class="el" href="step_22.html">step-22</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_32.html">step-32</a> tutorial programs, among others.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dofs_per_block variable has as many components as the finite element used by the dof_handler argument has blocks, or alternatively as many blocks as are enumerated in the target_blocks argument if given. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01943">1943</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a3e30887d7a90dc1422a9bb9e90ee1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e30887d7a90dc1422a9bb9e90ee1a05">&#9670;&nbsp;</a></span>get_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_fe_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell of a <a class="el" href="classDoFHandler.html">DoFHandler</a>, extract the active finite element index and fill the vector given as second argument. This vector is assumed to have as many entries as there are active cells. For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects without hp-capabilities given as first argument, the returned vector will consist of only zeros, indicating that all cells use the same finite element. In hp-mode, the values may be different, though. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01322">1322</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="acf3d202ccd39aea458a476dd0928fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d202ccd39aea458a476dd0928fb15">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom live on a set of cells (i.e., a patch) described by the argument. Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. This function is then useful in setting up the size of the linear system used to solve the local problem on the patch around a cell. The function <a class="el" href="namespaceDoFTools.html#aba4315ae585ff3b55ba9e6d2c26825a3">DoFTools::get_dofs_on_patch()</a> will then help to make the connection between global degrees of freedom and the local ones.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degrees of freedom associated with the cells of this patch. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells.</dd></dl>
<p>Count how many degrees of freedom live on a set of cells (i.e., a patch) described by the argument.</p>
<p>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. This function is then useful in setting up the size of the linear system used to solve the local problem on the patch around a cell. The function <a class="el" href="namespaceDoFTools.html#aba4315ae585ff3b55ba9e6d2c26825a3">DoFTools::get_dofs_on_patch()</a> will then help to make the connection between global degrees of freedom and the local ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type DoFHandler&lt;dim, spacedim&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degrees of freedom associated with the cells of this patch.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02744">2744</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a99d249bd0c6f5ccb1ea86d498fd7e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d249bd0c6f5ccb1ea86d498fd7e936">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>
<p>The same as above. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000214">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument.</dd></dl>

</div>
</div>
<a id="aa243d4c45775077c674ef6800e5ce215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243d4c45775077c674ef6800e5ce215">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mapping from degree of freedom indices to the index of that degree of freedom on the boundary. After this operation, <code>mapping[dof]</code> gives the index of the degree of freedom with global number <code>dof</code> in the list of degrees of freedom on the boundary. If the degree of freedom requested is not on the boundary, the value of <code>mapping[dof]</code> is <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. This function is mainly used when setting up matrices and vectors on the boundary from the trial functions, which have global numbers, while the matrices and vectors use numbers of the trial functions local to the boundary. Prior content of <code>mapping</code> is deleted. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02032">2032</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a2e367cf4d8590470cc136bec082b216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e367cf4d8590470cc136bec082b216b">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function, except that only those parts of the boundary are considered for which the boundary indicator is listed in the second argument. See the general doc of this class for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02074">2074</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a5514e4f59ea659f63953d62ca429eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5514e4f59ea659f63953d62ca429eaff">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) for all the degrees of freedom handled by this DoF handler object. This function, of course, only works if the finite element object used by the DoF handler object actually provides support points, i.e. no edge elements or the like. Otherwise, an exception is thrown. </p><dl class="section pre"><dt>Precondition</dt><dd>The given array must have a length of as many elements as there are degrees of freedom. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The precondition to this function that the output argument needs to have size equal to the total number of degrees of freedom makes this function unsuitable for the case that the given <a class="el" href="classDoFHandler.html">DoFHandler</a> object derives from a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object (or any of the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). Consequently, this function will produce an error if called with such a <a class="el" href="classDoFHandler.html">DoFHandler</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>A vector that stores the corresponding location of the dofs in real space coordinates. Previous content of this object is deleted in this function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An optional component mask that restricts the components from which the support points are extracted.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a list of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) for all the degrees of freedom handled by this DoF handler object. This function, of course, only works if the finite element object used by the DoF handler object actually provides support points, i.e. no edge elements or the like. Otherwise, an exception is thrown.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given array must have a length of as many elements as there are degrees of freedom.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The precondition to this function that the output argument needs to have size equal to the total number of degrees of freedom makes this function unsuitable for the case that the given <a class="el" href="classDoFHandler.html">DoFHandler</a> object derives from a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object (or any of the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). Consequently, this function will produce an error if called with such a <a class="el" href="classDoFHandler.html">DoFHandler</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>A vector that stores the corresponding location of the dofs in real space coordinates. Previous content of this object is deleted in this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An optional component mask that restricts the components from which the support points are extracted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02222">2222</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a8d68b6352f00a6e6c26eb728040284e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d68b6352f00a6e6c26eb728040284e6">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp-case. </p>

</div>
</div>
<a id="a297ef923ee03f234fc09ee4dcdd01140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ef923ee03f234fc09ee4dcdd01140">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a version of the above map_dofs_to_support_points function that doesn't simply return a vector of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) with one entry for each global degree of freedom, but instead a map that maps from the DoFs index to its location. The point of this function is that it is also usable in cases where the <a class="el" href="classDoFHandler.html">DoFHandler</a> is based on a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object (or any of the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). In such cases, each processor will not be able to determine the support point location of all DoFs, and worse no processor may be able to hold a vector that would contain the locations of all DoFs even if they were known. As a consequence, this function constructs a map from those DoFs for which we can know the locations (namely, those DoFs that are locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>) to their locations.</p>
<p>For non-distributed triangulations, the map returned as <code>support_points</code> is of course dense, i.e., every DoF is to be found in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>A map that for every locally relevant DoF index contains the corresponding location in real space coordinates. Previous content of this object is deleted in this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An optional component mask that restricts the components from which the support points are extracted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02273">2273</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad18da75343daf4b14fa0588445627eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18da75343daf4b14fa0588445627eab">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp-case. </p>

</div>
</div>
<a id="a3540ceb577e65414bde1b6b14808da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540ceb577e65414bde1b6b14808da2c">&#9670;&nbsp;</a></span>map_support_points_to_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_support_points_to_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_to_index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the opposite function to the one above. It generates a map where the keys are the support points of the degrees of freedom, while the values are the DoF indices. For a definition of support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>. Since there is no natural order in the space of points (except for the 1d case), you have to provide a map with an explicitly specified comparator object. This function is therefore templatized on the comparator object. Previous content of the map object is deleted in this function. Just as with the function above, it is assumed that the finite element in use here actually supports the notion of support points of all its components. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>This function should generate a multimap, rather than just a map, since several dofs may be located at the same support point. Currently, only the last value in the map returned by <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> for each point will be returned.</dd></dl>
<p>This is the opposite function to the one above. It generates a map where the keys are the support points of the degrees of freedom, while the values are the DoF indices. For a definition of support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>.</p>
<p>Since there is no natural order in the space of points (except for the 1d case), you have to provide a map with an explicitly specified comparator object. This function is therefore templatized on the comparator object. Previous content of the map object is deleted in this function.</p>
<p>Just as with the function above, it is assumed that the finite element in use here actually supports the notion of support points of all its components.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd>This function should generate a multimap, rather than just a map, since several dofs may be located at the same support point. Currently, only the last value in the map returned by <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> for each point will be returned. </dd></dl>
<p>This is the opposite function to the one above. It generates a map where the keys are the support points of the degrees of freedom, while the values are the DoF indices. For a definition of support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>. Since there is no natural order in the space of points (except for the 1d case), you have to provide a map with an explicitly specified comparator object. This function is therefore templatized on the comparator object. Previous content of the map object is deleted in this function. Just as with the function above, it is assumed that the finite element in use here actually supports the notion of support points of all its components. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd>This function should generate a multimap, rather than just a map, since several dofs may be located at the same support point. Currently, only the last value in the map returned by <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> for each point will be returned.</dd></dl>

</div>
</div>
<a id="a952f50bcd4f8fbb09924626ecc60c605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f50bcd4f8fbb09924626ecc60c605">&#9670;&nbsp;</a></span>distribute_cell_to_dof_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::distribute_cell_to_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a vector of values which live on cells (e.g. an error per cell) and distribute it to the dofs in such a way that a finite element field results, which can then be further processed, e.g. for output. You should note that the resulting field will not be continuous at hanging nodes. This can, however, easily be arranged by calling the appropriate <code>distribute</code> function of an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object created for this <a class="el" href="classDoFHandler.html">DoFHandler</a> object, after the vector has been fully assembled. It is assumed that the number of elements in <code>cell_data</code> equals the number of active cells and that the number of elements in <code>dof_data</code> equals <code>dof_handler.n_dofs()</code>. Note that the input vector may be a vector of any data type as long as it is convertible to <code>double</code>. The output vector, being a data vector on a DoF handler, always consists of elements of type <code>double</code>. In case the finite element used by this <a class="el" href="classDoFHandler.html">DoFHandler</a> consists of more than one component, you need to specify which component in the output vector should be used to store the finite element field in; the default is zero (no other value is allowed if the finite element consists only of one component). All other components of the vector remain untouched, i.e. their contents are not changed. This function cannot be used if the finite element in use has shape functions that are non-zero in more than one vector component (in deal.II speak: they are non-primitive). </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00306">306</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a1747081ebc1846a5b9ca3aa4bc2ee73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1747081ebc1846a5b9ca3aa4bc2ee73d">&#9670;&nbsp;</a></span>write_gnuplot_dof_support_point_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::write_gnuplot_dof_support_point_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p align="center">Generate text output readable by gnuplot with point data based on the given map <code>support_points</code>. For each support point location, a string label containing a list of all DoFs from the map is generated. The map can be generated with a call to <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> and is useful to visualize location and global numbering of unknowns. An example for the format of each line in the output is: </p><div class="fragment"><div class="line"><a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a> [<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>] [<a class="code" href="grid__generator__0_8txt.html#ad9adfa4fc9634eb12b6c9ba287d11e46">z</a>] <span class="stringliteral">&quot;dof1, dof2&quot;</span></div>
</div><!-- fragment --><p> where x, y, and z (present only in corresponding dimension) are the coordinates of the support point, followed by a list of DoF numbers. The points with labels can be plotted as follows in gnuplot: </p><div class="fragment"><div class="line"><a class="code" href="grid__out__0_8txt.html#ae0d02c861819c3872a41bb8f8f433044">plot</a> <span class="stringliteral">&quot;./points.gpl&quot;</span> <span class="keyword">using</span> 1:2:3 <a class="code" href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a> labels <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#afc7bd61123bcefecf640866d9e92d9c6">point</a> offset 1,1</div>
</div><!-- fragment --><p> Examples (this also includes the grid written separately using <a class="el" href="classGridOut.html">GridOut</a>): </p>
<div class="image">
<img src="support_point_dofs1.png" alt=""/>
</div>
 <div class="image">
<img src="support_point_dofs2.png" alt=""/>
</div>
 <p>To generate the mesh and the support point information in a single gnuplot file, use code similar to </p><div class="fragment"><div class="line">std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div>
<div class="line">  &lt;&lt; std::endl;</div>
<div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>);</div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div>
<div class="line">                                    dof_handler,</div>
<div class="line">                                    support_points);</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>,</div>
<div class="line">                                             support_points);</div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> and from within gnuplot execute the following command: </p><div class="fragment"><div class="line"><a class="code" href="distributed_2tria__0_8txt.html#ac3dc29f828db6ca06adf1c44744047df">load</a> <span class="stringliteral">&quot;gnuplot.gpl&quot;</span></div>
</div><!-- fragment --><p> Alternatively, the following gnuplot script will generate a png file when executed as <code>gnuplot gnuplot.gpl</code> on the command line: </p><div class="fragment"><div class="line">std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;set terminal png size 400,410 enhanced font \&quot;Helvetica,8\&quot;\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;set output \&quot;output.png\&quot;\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;set size square\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;set view equal xy\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset xtics\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset ytics\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset grid\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset border\n&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines notitle, &quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1 notitle&quot;</span></div>
<div class="line">  &lt;&lt; std::endl;</div>
<div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>);</div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div>
<div class="line">                                    dof_handler,</div>
<div class="line">                                    support_points);</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>,</div>
<div class="line">                                             support_points);</div>
<div class="line"><a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a> &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02312">2312</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a495fa975b1d6b81f0875bf641f266ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495fa975b1d6b81f0875bf641f266ce5">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02248">2248</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ab85610f8869cebbc3be41aed240ea4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85610f8869cebbc3be41aed240ea4b0">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02294">2294</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a730347c0582a281b1fbea079d7906e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730347c0582a281b1fbea079d7906e6a">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a>&#160;</td>
          <td class="paramname"><em>periodicity_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02573">2573</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_af35ca33203cd802325d779be7b6b41e8"><div class="ttname"><a href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin with</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00139">multithreading_0.txt:139</a></div></div>
<div class="ttc" id="afe__raviart__thomas__0_8txt_html_ac6ea408671d88ada97f59c4743d57c2d"><div class="ttname"><a href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a></div><div class="ttdeci">ii the shape functions are defined so that certain integrals over the faces are either zero or rather than the common case of certain point values being either zero or the degree of the element denotes the polynomial degree of the[1.x.1] contained in the finite element even if the space may contain shape functions of higher polynomial degree The lowest order element is consequently i the Raviart Thomas element of degree even though the functions of this space are in general polynomials of degree one in each variable This choice of degree implies that the approximation order of the function itself as with usual polynomial spaces The numbering so chosen implies the sequence *[1.x.3] This class is not implemented for the codimension one the[2.x.7] node values are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials Since the normal trace of the RT space of degree[1.x.6] on an edge face is the the moments are taken with respect to this space **Higher order RT spaces have interior nodes These are moments taken with respect to the gradient of functions in[1.x.9] on the which will be computed by quadrature rules themselves The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy The points needed are those of QGauss&lt; sub &gt; k&lt;/sub &gt; on each face as well as QGauss&lt; sub &gt; k&lt;/sub &gt; in the interior of the with[2.x.9] and[2.x.10] replaced by appropriate values **This function returns[2.x.11] if the shape function[2.x.12] has non zero function values somewhere on the face[2.x.13] Right this is only implemented for RT0 in returns always *[2.x.14] *Return a list of constant modes of the element This method is currently not correctly implemented because it returns ones for all components **Only for internal use Its full name is[2.x.15] function and it creates the[2.x.16] vector that is needed within the constructor to be passed to the constructor of[2.x.17] FiniteElementData **Initialize the[2.x.18] field of the FiniteElement class and fill the tables with interpolation this restriction face_flip</div><div class="ttdef"><b>Definition:</b> <a href="fe__raviart__thomas__0_8txt_source.html#l00043">fe_raviart_thomas_0.txt:43</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="ablock__info__0_8txt_html_a6e40fe1b2d784c06fbd9ad45ce139aac"><div class="ttname"><a href="block__info__0_8txt.html#a6e40fe1b2d784c06fbd9ad45ce139aac">local</a></div><div class="ttdeci">multilevel and computations *Once a DoFHandler has been initialized with an a data object of type which reflects the block structure of the degrees of freedom *BlockInfo consists of several BlockIndices objects The member usually referred to as the global system As soon as[2.x.2] has been the function[2.x.3] in the same structure is automatically generated for each level The level blocks can be accessed through there are local() BlockIndices</div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_aa2626b9a8731384418b99aaadfc1d365"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a></div><div class="ttdeci">this leads to a degree of flexibility in computations that cannot be matched by auto differentiation For one could perform the permanent substitution[2.x.86] and then recompute[2.x.87] for several different values of[2.x.88] One could also post factum express an interdependency between x and y</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="agrid__generator__0_8txt_html_ad9adfa4fc9634eb12b6c9ba287d11e46"><div class="ttname"><a href="grid__generator__0_8txt.html#ad9adfa4fc9634eb12b6c9ba287d11e46">z</a></div><div class="ttdeci">namespace provides a collection of functions for generating triangulations for some basic geometries *Some of these functions receive a parts of the boundary receive different[2.x.2] boundary indicators allowing them to be distinguished for the purpose of evaluating different boundary conditions *If the domain is each of the domain parts that should be refined by following an appropriate Manifold description will receive a different[2.x.3] manifold and the correct Manifold descriptor will be attached to the Triangulation Notice that if you later transform the you have to make sure you attach the correct new Manifold to the triangulation ******Creating meshes for basic geometries **Initialize the given triangulation with a where the limits are given as arguments They default to zero and then producing the unit hypercube If the argument[2.x.7] is then all boundary indicators are set to the boundary is[2.x.8] colorized as in see a&lt; tt &gt; Triangulation[2.x.15] will be a square in the xy plane with z</div><div class="ttdef"><b>Definition:</b> <a href="grid__generator__0_8txt_source.html#l00014">grid_generator_0.txt:14</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="agrid__out__0_8txt_html_ae0d02c861819c3872a41bb8f8f433044"><div class="ttname"><a href="grid__out__0_8txt.html#ae0d02c861819c3872a41bb8f8f433044">plot</a></div><div class="ttdeci">they then have a template as usual ********Declaration of a name for each of the different output formats These are used by the generic output function resp Not implemented for the codimension one case **Write the triangulation in the gnuplot format In GNUPLOT each cell is written as a sequence of its confining lines Apart from the coordinates of the lines end the level and the material of the cell are appended to each line of output if you let GNUPLOT draw a grid as a plot</div><div class="ttdef"><b>Definition:</b> <a href="grid__out__0_8txt_source.html#l00288">grid_out_0.txt:288</a></div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a5abc878123b65e2a7a16e57bba0e282e"><div class="ttname"><a href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a></div><div class="ttdeci">******This module deals with constraints on degrees of freedom The central class to deal with constraints is the AffineConstraints class *Constraints typically come from several for one usually enforces them by requiring that degrees of freedom on the boundary have particular for example[2.x.3] if the boundary condition[2.x.4] requires that the finite element solution[2.x.5] at the location of degree of freedom has the value Such constraints are generated by those versions of the[2.x.6] function that take a AffineConstraints for example no normal as happens in flow problems and is handled by the[2.x.11] function or prescribed tangential as happens in electromagnetic problems and is handled by the[2.x.13] function For the former imagine for example that we are at at vertex where the normal vector has the form[2.x.14] and that and[2.x.17] components of the flow field at this vertex are associated with degrees of and Then the no normal flux condition means that we need to have the condition[2.x.18] The prescribed tangential component leads to similar constraints though there is often something on the right hand side ****If you have hanging node constraints</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00020">constraints_0.txt:20</a></div></div>
<div class="ttc" id="aclassGridOut_html_ad114b5e2e6105f5a269b1599cc53d27e"><div class="ttname"><a href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">GridOut::write_gnuplot</a></div><div class="ttdeci">void write_gnuplot(const Triangulation&lt; dim, spacedim &gt; &amp;tria, std::ostream &amp;out, const Mapping&lt; dim, spacedim &gt; *mapping=nullptr) const</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04572">grid_out.cc:4572</a></div></div>
<div class="ttc" id="aclassMappingQ1_html"><div class="ttname"><a href="classMappingQ1.html">MappingQ1&lt; dim &gt;</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a98c83a8c964d1c88f6f2493b1c2ae26f"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a></div><div class="ttdeci">and where the chemical species react with each other based on reaction coefficients that also depend nonlinearly and in complicated ways on the chemical and pressure In many the exact formulas for all of these coefficients can take several lines to write out</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="alaoperators__0_8txt_html_adb1fe2e68343594471e91a43c52b9a67"><div class="ttname"><a href="laoperators__0_8txt.html#adb1fe2e68343594471e91a43c52b9a67">denote</a></div><div class="ttdeci">like[2.x.1] the MatrixType defines a minimal interface for[1.x.1] a linear operation on a vector such an object can be used as a matrix object in all[2.x.2] iterative solver either as a matrix or as[2.x.3] preconditioner *The big advantage of the LinearOperator class is that it provides syntactic sugar for complex matrix vector operations As an example consider the and[2.x.7] denote(possibly different) SparseMatrix objects. In order to const ruct a LinearOperator[2.x.8] that performs above computation when applied on a vector</div></div>
<div class="ttc" id="afe__raviart__thomas__0_8txt_html_abddfd52613d27285fd6ca5d28773658d"><div class="ttname"><a href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a></div><div class="ttdeci">ii the shape functions are defined so that certain integrals over the faces are either zero or rather than the common case of certain point values being either zero or the degree of the element denotes the polynomial degree of the[1.x.1] contained in the finite element even if the space may contain shape functions of higher polynomial degree The lowest order element is consequently i the Raviart Thomas element of degree even though the functions of this space are in general polynomials of degree one in each variable This choice of degree implies that the approximation order of the function itself as with usual polynomial spaces The numbering so chosen implies the sequence *[1.x.3] This class is not implemented for the codimension one the[2.x.7] node values are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials Since the normal trace of the RT space of degree[1.x.6] on an edge face is the the moments are taken with respect to this space **Higher order RT spaces have interior nodes These are moments taken with respect to the gradient of functions in[1.x.9] on the which will be computed by quadrature rules themselves The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy The points needed are those of QGauss&lt; sub &gt; k&lt;/sub &gt; on each face as well as QGauss&lt; sub &gt; k&lt;/sub &gt; in the interior of the with[2.x.9] and[2.x.10] replaced by appropriate values **This function returns[2.x.11] if the shape function[2.x.12] has non zero function values somewhere on the face[2.x.13] Right this is only implemented for RT0 in returns always *[2.x.14] *Return a list of constant modes of the element This method is currently not correctly implemented because it returns ones for all components **Only for internal use Its full name is[2.x.15] function and it creates the[2.x.16] vector that is needed within the constructor to be passed to the constructor of[2.x.17] FiniteElementData **Initialize the[2.x.18] field of the FiniteElement class and fill the tables with interpolation this restriction face_rotation</div><div class="ttdef"><b>Definition:</b> <a href="fe__raviart__thomas__0_8txt_source.html#l00043">fe_raviart_thomas_0.txt:43</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_a2b24e414d1a0d32deea919c5e8899811"><div class="ttname"><a href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a></div><div class="ttdeci">([1.x.8]&lt; sub &gt;1&lt;/sub &gt;, [1.x.9]&lt; sub &gt;2&lt;/sub &gt;, [1.x.10]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt; and[1.x.11] accordingly. Then, we can write the simplified equation in coordinates as[1.x.12] We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component(this is where the formulation with the[2.x.33] is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions:first, choose[1.x.13]=([1.x.14]&lt; sub &gt;1&lt;/sub &gt;, 0, 0)&lt; sup &gt;T&lt;/sup &gt;, then[1.x.15]=(0, [1.x.16]&lt; sub &gt;2&lt;/sub &gt;, 0)&lt; sup &gt;T&lt;/sup &gt;, and finally[1.x.17]=(0, 0, [1.x.18]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt;. writing the outcomes below each other, we obtain the system[1.x.19] where we used the standard inner product notation[2.x.34] . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form[1.x.20]([1.x.21], [1.x.22]), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient[1.x.23]:[1.x.24] Very formally, if we believe in operator valued matrices, we can rewrite this in the form[1.x.25]&lt; sup &gt;T&lt;/sup &gt;[1.x.26]=[1.x.27]&lt; sup &gt;T&lt;/sup &gt;[1.x.28] or[1.x.29] *[1.x.30] Now, let us consider a more complex example, the mixed Laplace equations discussed in[2.x.35] in three dimensions:[1.x.31] **Here, we have four solution components:the scalar pressure[2.x.36] and the vector-valued velocity[2.x.37] with three vector components. Note as important difference to the previous example, that the vector space[1.x.32] is not just simply a copy of three identical spaces/*A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows:[1.x.33] **This makes it clear that the solution[1.x.34] *indeed has four components. We note that we could change the ordering of the solution components[2.x.38] and[2.x.39] inside[2.x.40] if we also change columns of the matrix operator.*Next, we need to think about test functions[2.x.41] . We want to multiply both sides of the equation with them, then integrate over[2.x.42] . The result should be a scalar equality. We can achieve this by choosing[2.x.43] also vector valued as[1.x.35] **It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on(in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. *With this in mind, let us multiply by[2.x.44] and integrate to get the following equation which has to hold for all test functions[2.x.45] :[1.x.36] *or equivalently:[1.x.37] ***We get the final form by integrating by part the second term:[1.x.38] **It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector:the form in which we have solution and test functions[2.x.46] that each consist of a number of vector components that we can extract. **[2.x.47] VVFEs[1.x.39] *Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the FESystem class comes in:it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need[2.x.48] copies of the same element, for instance **[1.x.40] *This will generate a vector valued space of dimension[2.x.49], where each component is a continuous bilinear element of type FE_Q. It will have[2.x.50] times as many basis functions as the corresponding FE_Q, and each of these basis functions is a basis function of FE_Q, lifted into one of the components of the vector. *For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces[2.x.51] . One option would be the stable Raviart-Thomas pair **[1.x.41] *The first element in this system is already a vector valued element of dimension[2.x.52], while the second is a regular scalar element. *Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely **[1.x.42] *This system just has[2.x.53] equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer **[1.x.43] *Here, we have a system of two elements, one vector-valued and one scalar, very much like with the[2.x.54] . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely **[1.x.44] *It must be pointed out, that this element is different from **[1.x.45] *While the constructor call is very similar to[2.x.55], the result actually resembles more[2.x.56] in that this element produces[2.x.57] independent components. A more detailed comparison of the resulting FESystem objects is below. *[1.x.46] *FESystem has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table:&lt; table border=&quot;1&quot;&gt;&lt; tr &gt;&lt; th &gt;System Element&lt;/th &gt;[2.x.58][2.x.59][2.x.60]&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.61]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.62]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.63]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.64]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.65]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt;/table &gt; *From this table, it is clear that the FESystem reflects a lot of the structure of the system of differential equations in the cases of the[2.x.66] and the[2.x.67], in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. *At this point, it is important to note that nesting of two FESystem object can give the whole FESystem a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so. *[2.x.68] VVAssembling[1.x.47] The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with[2.x.69] . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. *The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. *[1.x.48] This is essentially how[2.x.70] does it:**[1.x.49] **So here 's what is happening:[2.x.71][2.x.72] The first thing we do is to declare &quot;extractors&quot;(see the FEValuesExtractors namespace). These are objects that don 't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1(i.e. what we call a &quot;physical vector&quot;, always consisting of[2.x.73] components). Here, we declare an object that represents the velocities consisting of[2.x.74] components starting at component zero, and the extractor for the pressure, which is a scalar component at position[2.x.75] . *[2.x.76] We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form(i.e. neglecting boundary terms) looked as follows, based on shape functions[2.x.77] :[1.x.50] *whereas the implementation looked like this:*[1.x.51] *The similarities are pretty obvious. *[2.x.78] Essentially, what happens in above code is this:when you do[2.x.79], a so-called &quot;view&quot; is created, i.e. an object that unlike the full FEValues object represents not all components of a finite element, but only the one(s) represented by the extractor object[2.x.80] or[2.x.81] . *[2.x.82] These views can then be asked for information about these individual components. For example, when you write[2.x.83] you get the value of the pressure component of the[2.x.84] th shape function[2.x.85] at the[2.x.86] th quadrature point. Because the extractor[2.x.87] represents a scalar component, the results of the operator[2.x.88] is a scalar number. On the other hand, the call[2.x.89] would produce the value of a whole set of[2.x.90] components, which would be of type[2.x.91] . *[2.x.92] Other things that can be done with views is to ask for the gradient of a particular shape function 's components described by an extractor. For example,[2.x.93] would represent the gradient of the scalar pressure component, which is of type[2.x.94], whereas the gradient of the velocities components,[2.x.95] is a[2.x.96], i.e. a matrix[2.x.97] that consists of entries[2.x.98] . Finally, both scalar and vector views can be asked for the second derivatives(&quot;Hessians&quot;) and vector views can be asked for the symmetric gradient, defined as[2.x.99] as well as the divergence[2.x.100] .[2.x.101] Other examples of using extractors and views are shown in tutorial programs[2.x.102],[2.x.103],[2.x.104] and several other programs. ***[2.x.105] In the current context, when we talk about a vector(for example in extracting the velocity components above), we mean the word in the sense physics uses it:it has[2.x.106] components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word &quot;vector&quot;(and how we use this word in other contexts in the library, for example in the Vector class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame x</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00090">vector_valued_0.txt:90</a></div></div>
<div class="ttc" id="adistributed_2tria__0_8txt_html_ac3dc29f828db6ca06adf1c44744047df"><div class="ttname"><a href="distributed_2tria__0_8txt.html#ac3dc29f828db6ca06adf1c44744047df">load</a></div><div class="ttdeci">see[2.x.56] the glossary One is not typically interested in this so the function returns whether there are hanging nodes between any two cells of the global i the union of locally owned cells on all processors **Return the memory consumption in bytes **Return the memory consumption contained in the p4est data structures alone This is already contained in this function is useful for debugging the interface between deal II and p4est **Produce a check sum of the triangulation This is a collective operation and is mostly useful for debugging purposes **Save the refinement information from the coarse mesh into the given file This file needs to be reachable from all nodes in the computation on a shared network file system See the SolutionTransfer class on how to store solution vectors into this file Additional cell based data can be saved using *[2.x.57] *Load the refinement information saved with if a mesh is loaded with a different number of MPI processes than used at the time of the mesh is repartitioned appropriately Cell based data that was saved with[2.x.58] can be read in with[2.x.59] after calling load(). If you use p4est version &gt; 0.3.4.2 the[2.x.60] flag tells p4est to ignore the partitioning that the triangulation had when it was saved and make it uniform upon loading. If[2.x.61] is set to false</div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_afc7bd61123bcefecf640866d9e92d9c6"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#afc7bd61123bcefecf640866d9e92d9c6">point</a></div><div class="ttdeci">and situations where one is given a parameter dependent problem[2.x.4] and wants to form derivatives with regards to the for example to optimize an output functional with regards or for a sensitivity analysis with regards to[2.x.7] One should think of[2.x.8] as design the width or shape of a the stiffness coefficients of a material chosen to build an the power sent to a the chemical composition of the gases sent to a burner In all of these one should think of[2.x.9] and[2.x.10] as[1.x.0] and cumbersome to differentiate **at least when doing it by hand A relatively simple case of a nonlinear problem that already highlights the tedium of computing derivatives by hand is shown in[2.x.11] in one for think about problems such as chemically reactive flows where the fluid equations have coefficients such as the density and viscosity that depend strongly and nonlinearly on the chemical and pressure of the fluid at each point</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="agrid__out__0_8txt_html_a4764aa6a9ff4cc355ec2f8982984495a"><div class="ttname"><a href="grid__out__0_8txt.html#a4764aa6a9ff4cc355ec2f8982984495a">combination</a></div><div class="ttdeci">to obtain the same triangulation as you have to specify faces with differing boundary indicators which is done by this flag Names and values of further flags controlling the output can be found in the documentation of the[2.x.56] class Works also in the codimension one case **Write the triangulation in any format supported by gmsh API Gmsh API allows writing its output in several formats through their C API This function translates a Triangulation object into a gmsh collection of entities and calls the[2.x.57] method with the filename passed as argument This method generates a different entity for each unique pair of non default manifold id and boundary and writes a gmsh physical group for each unique combination</div><div class="ttdef"><b>Definition:</b> <a href="grid__out__0_8txt_source.html#l00294">grid_out_0.txt:294</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_a1747081ebc1846a5b9ca3aa4bc2ee73d"><div class="ttname"><a href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a></div><div class="ttdeci">void write_gnuplot_dof_support_point_info(std::ostream &amp;out, const std::map&lt; types::global_dof_index, Point&lt; spacedim &gt;&gt; &amp;support_points)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l02312">dof_tools.cc:2312</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_acce0a318676405d57af6ef0f5cbe4ec3"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications and</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_adad35057b6e70ae37d4abe7878683d90"><div class="ttname"><a href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per the child indices of the child cells adjacent to face</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="anamespacetypes_html_a3bf9e493f1aab00b04933b81856144c4"><div class="ttname"><a href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></div><div class="ttdeci">unsigned int global_dof_index</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00074">types.h:74</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a5abb1355f897601e766edb6b0ae168e8"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a5abb1355f897601e766edb6b0ae168e8">that</a></div><div class="ttdeci">dual numbers do not contain any higher order terms in their first while for the complex step method these existent higher order terms are neglected It can be shown that both of these methods are not subject to subtractive cancellation errors and that</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00058">automatic_and_symbolic_differentiation_0.txt:58</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_a5514e4f59ea659f63953d62ca429eaff"><div class="ttname"><a href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a></div><div class="ttdeci">void map_dofs_to_support_points(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;support_points, const ComponentMask &amp;mask=ComponentMask())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l02222">dof_tools.cc:2222</a></div></div>
<div class="ttc" id="aclassGridOut_html"><div class="ttname"><a href="classGridOut.html">GridOut</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__out_8h_source.html#l01050">grid_out.h:1050</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a3c7e76b7aa721e073bb9d0a192b85df2"><div class="ttname"><a href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a></div><div class="ttdeci">false&lt;/tt &gt; argument. *The information which child cell is at which position of which face is most often used when computing jump terms across faces with hanging nodes, using objects of type FESubfaceValues. Sitting on one cell, you would look at a face and figure out which child of the neighbor is sitting on a given subface between the present and the neighboring cell. To avoid having to query the standard orientation of the faces of the two cells every time in such cases, you should use a function call like&lt; tt &gt;cell-&gt;neighbor_child_on_subface(face_no, subface_no)&lt;/tt &gt;, which returns the correct result both in 2d(where face orientations are immaterial) and 3d(where it is necessary to use the face orientation as additional argument to[2.x.142] *For anisotropic refinement, the child cells can not be numbered according to adjacent vertices, thus the following conventions are used:**[1.x.27] ****[1.x.28] ****[1.x.29] ****[1.x.30] ****[1.x.31] ****[1.x.32] **This information can also be obtained by the[2.x.143] function. *[1.x.33] *We define the following coordinate system for the explicit coordinates of the vertices of the unit cell:**[1.x.34] **By the convention laid down as above, the vertices have the following coordinates(lexicographic, with x running fastest):[2.x.144][2.x.145] Vertex 0:&lt; tt &gt;(0, 0, 0)&lt;/tt &gt; face_orientation</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00444">geometry_info_0.txt:444</a></div></div>
<div class="ttc" id="adof__renumbering__0_8txt_html_a834d5d19e92acf763e40c9176a517db4"><div class="ttname"><a href="dof__renumbering__0_8txt.html#a834d5d19e92acf763e40c9176a517db4">DoF</a></div><div class="ttdeci">namespace compute new indices for each degree of freedom of a DoFHandler object and then call *[2.x.0] **Within this the Cuthill McKee algorithm is implemented It starts at a degree of searches the other DoFs for those which are coupled with the one we started with and numbers these in a certain way It then finds the second level of namely those that couple with those of the previous especially the numbering within each please see H R but numbers all elements in the reverse order *These algorithms have one major i e the degree of freedom index that will get a new index of zero The renumbering functions therefore allow the caller to specify such an initial DoF</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering__0_8txt_source.html#l00007">dof_renumbering_0.txt:7</a></div></div>
<div class="ttc" id="agraph__coloring__0_8txt_html_a068d28578c03dd6b6bb6b32bf268eafd"><div class="ttname"><a href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a></div><div class="ttdeci">namespace containing functions that can color graphs ***Given two sets of indices that are assumed to be determine whether they will have a nonempty intersection The actual intersection is not computed[2.x.0] indices1 A set of indices</div><div class="ttdef"><b>Definition:</b> <a href="graph__coloring__0_8txt_source.html#l00006">graph_coloring_0.txt:6</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
