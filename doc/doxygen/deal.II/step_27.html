<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_27.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-27 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-27 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Finiteelementcollections">Finite element collections</a>
        <li><a href="#TheDoFHandlerclassinihpimodeassociatingcellswithfiniteelementsandconstraints">The DoFHandler class in <i>hp</i>-mode, associating cells with finite elements, and constraints</a>
        <li><a href="#Assemblingmatricesandvectorswithhpobjects">Assembling matrices and vectors with hp-objects</a>
        <li><a href="#Asimpleindicatorforhprefinementandestimatingsmoothness">A simple indicator for hp-refinement and estimating smoothness</a>
      <ul>
        <li><a href="#Theidea">The idea</a>
        <li><a href="#Whatwehavetodo">What we have to do</a>
        <li><a href="#Compensatingforanisotropy">Compensating for anisotropy</a>
        <li><a href="#Questionsaboutcellsizes">Questions about cell sizes</a>
      </ul>
        <li><a href="#Complicationswithlinearsystemsforhpdiscretizations">Complications with linear systems for hp-discretizations</a>
      <ul>
        <li><a href="#Creatingthesparsitypattern">Creating the sparsity pattern</a>
        <li><a href="#Eliminatingconstraineddegreesoffreedom">Eliminating constrained degrees of freedom</a>
      </ul>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Themainclass">The main class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Implementationofthemainclass">Implementation of the main class</a>
      <ul>
        <li><a href="#LaplaceProblemLaplaceProblemconstructor">LaplaceProblem::LaplaceProblem constructor</a>
        <li><a href="#LaplaceProblemLaplaceProblemdestructor">LaplaceProblem::~LaplaceProblem destructor</a>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblempostprocess">LaplaceProblem::postprocess</a>
        <li><a href="#LaplaceProblemcreate_coarse_grid">LaplaceProblem::create_coarse_grid</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Differenthpdecisionstrategies">Different hp-decision strategies</a>
        <li><a href="#Parallelhpadaptivefiniteelements">Parallel hp-adaptive finite elements</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program attempts to show how to use \(hp\)-finite element methods with deal.II. It solves the Laplace equation and so builds only on the first few tutorial programs, in particular on <a class="el" href="step_4.html">step-4</a> for dimension independent programming and <a class="el" href="step_6.html">step-6</a> for adaptive mesh refinement.</p>
<p>The \(hp\)-finite element method was proposed in the early 1980s by Babu&scaron;ka and Guo as an alternative to either (i) mesh refinement (i.e., decreasing the mesh parameter \(h\) in a finite element computation) or (ii) increasing the polynomial degree \(p\) used for shape functions. It is based on the observation that increasing the polynomial degree of the shape functions reduces the approximation error if the solution is sufficiently smooth. On the other hand, it is well known that even for the generally well-behaved class of elliptic problems, higher degrees of regularity can not be guaranteed in the vicinity of boundaries, corners, or where coefficients are discontinuous; consequently, the approximation can not be improved in these areas by increasing the polynomial degree \(p\) but only by refining the mesh, i.e., by reducing the mesh size \(h\). These differing means to reduce the error have led to the notion of \(hp\)-finite elements, where the approximating finite element spaces are adapted to have a high polynomial degree \(p\) wherever the solution is sufficiently smooth, while the mesh width \(h\) is reduced at places wherever the solution lacks regularity. It was already realized in the first papers on this method that \(hp\)-finite elements can be a powerful tool that can guarantee that the error is reduced not only with some negative power of the number of degrees of freedom, but in fact exponentially.</p>
<p>In order to implement this method, we need several things above and beyond what a usual finite element program needs, and in particular above what we have introduced in the tutorial programs leading up to <a class="el" href="step_6.html">step-6</a>. In particular, we will have to discuss the following aspects: </p><ul>
<li>
<p class="startli">Instead of using the same finite element on all cells, we now will want a collection of finite element objects, and associate each cell with one of these objects in this collection.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Degrees of freedom will then have to be allocated on each cell depending on what finite element is associated with this particular cell. Constraints will have to be generated in the same way as for hanging nodes, but we now also have to deal with the case where two neighboring cells have different finite elements assigned.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We will need to be able to assemble cell and face contributions to global matrices and right hand side vectors.</p>
<p class="endli"></p>
</li>
<li>
After solving the resulting linear system, we will want to analyze the solution. In particular, we will want to compute error indicators that tell us whether a given cell should be refined and/or whether the polynomial degree of the shape functions used on it should be increased. </li>
</ul>
<p>We will discuss all these aspects in the following subsections of this introduction. It will not come as a big surprise that most of these tasks are already well supported by functionality provided by the deal.II, and that we will only have to provide the logic of what the program should do, not exactly how all this is going to happen.</p>
<p>In deal.II, the \(hp\)-functionality is largely packaged into the hp-namespace. This namespace provides classes that handle \(hp\)-discretizations, assembling matrices and vectors, and other tasks. We will get to know many of them further down below. In addition, most of the functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a>, and <a class="el" href="namespaceVectorTools.html">VectorTools</a> namespaces accept \(hp\)-objects in addition to the non- \(hp\)-ones. Much of the \(hp\)-implementation is also discussed in the <a class="el" href="group__hp.html">hp-finite element support Classes and functions that have to</a> documentation module and the links found there.</p>
<p>It may be worth giving a slightly larger perspective at the end of this first part of the introduction. \(hp\)-functionality has been implemented in a number of different finite element packages (see, for example, the list of references cited in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>). However, by and large, most of these packages have implemented it only for the (i) the 2d case, and/or (ii) the discontinuous Galerkin method. The latter is a significant simplification because discontinuous finite elements by definition do not require continuity across faces between cells and therefore do not require the special treatment otherwise necessary whenever finite elements of different polynomial degree meet at a common face. In contrast, deal.II implements the most general case, i.e., it allows for continuous and discontinuous elements in 1d, 2d, and 3d, and automatically handles the resulting complexity. In particular, it handles computing the constraints (similar to hanging node constraints) of elements of different degree meeting at a face or edge. The many algorithmic and data structure techniques necessary for this are described in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a> for those interested in such detail.</p>
<p>We hope that providing such a general implementation will help explore the potential of \(hp\)-methods further.</p>
<p><a class="anchor" id="Finiteelementcollections"></a></p><h3>Finite element collections</h3>
<p>Now on again to the details of how to use the \(hp\)-functionality in deal.II. The first aspect we have to deal with is that now we do not have only a single finite element any more that is used on all cells, but a number of different elements that cells can choose to use. For this, deal.II introduces the concept of a <em>finite element collection</em>, implemented in the class <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>. In essence, such a collection acts like an object of type <code>std::vector&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&gt;</code>, but with a few more bells and whistles and a memory management better suited to the task at hand. As we will later see, we will also use similar quadrature collections, and &mdash; although we don't use them here &mdash; there is also the concept of mapping collections. All of these classes are described in the <a class="el" href="group__hpcollection.html">hp-Collections In the implementation of the</a> overview.</p>
<p>In this tutorial program, we will use continuous Lagrange elements of orders 2 through 7 (in 2d) or 2 through 5 (in 3d). The collection of used elements can then be created as follows: </p><div class="fragment"><div class="line"><a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
</div><!-- fragment --><p><a class="anchor" id="TheDoFHandlerclassinihpimodeassociatingcellswithfiniteelementsandconstraints"></a></p><h3>The <a class="el" href="classDoFHandler.html">DoFHandler</a> class in <em>hp</em>-mode, associating cells with finite elements, and constraints</h3>
<p>The next task we have to consider is what to do with the list of finite element objects we want to use. In previous tutorial programs, starting with <a class="el" href="step_2.html">step-2</a>, we have seen that the <a class="el" href="classDoFHandler.html">DoFHandler</a> class is responsible for making the connection between a mesh (described by a <a class="el" href="classTriangulation.html">Triangulation</a> object) and a finite element, by allocating the correct number of degrees of freedom for each vertex, face, edge, and cell of the mesh.</p>
<p>The situation here is a bit more complicated since we do not just have a single finite element object, but rather may want to use different elements on different cells. We therefore need two things: (i) a version of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class that can deal with this situation, and (ii) a way to tell the <a class="el" href="classDoFHandler.html">DoFHandler</a> which element to use on which cell.</p>
<p>The first of these two things is implemented in the <em>hp</em>-mode of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class: rather than associating it with a triangulation and a single finite element object, it is associated with a triangulation and a finite element collection. The second part is achieved by a loop over all cells of this <a class="el" href="classDoFHandler.html">DoFHandler</a> and for each cell setting the index of the finite element within the collection that shall be used on this cell. We call the index of the finite element object within the collection that shall be used on a cell the cell's <em>active FE index</em> to indicate that this is the finite element that is active on this cell, whereas all the other elements of the collection are inactive on it. The general outline of this reads like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>: dof_handler.active_cell_iterators())</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;set_active_fe_index(...);</div>
<div class="line">dof_handler.distribute_dofs(fe_collection);</div>
</div><!-- fragment --><p>Dots in the call to <code>set_active_fe_index()</code> indicate that we will have to have some sort of strategy later on to decide which element to use on which cell; we will come back to this later. The main point here is that the first and last line of this code snippet is pretty much exactly the same as for the non- \(hp\)-case.</p>
<p>Another complication arises from the fact that this time we do not simply have hanging nodes from local mesh refinement, but we also have to deal with the case that if there are two cells with different active finite element indices meeting at a face (for example a Q2 and a Q3 element) then we have to compute additional constraints on the finite element field to ensure that it is continuous. This is conceptually very similar to how we compute hanging node constraints, and in fact the code looks exactly the same: </p><div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"><a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
</div><!-- fragment --><p> In other words, the <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> deals not only with hanging node constraints, but also with \(hp\)-constraints at the same time.</p>
<p><a class="anchor" id="Assemblingmatricesandvectorswithhpobjects"></a></p><h3>Assembling matrices and vectors with hp-objects</h3>
<p>Following this, we have to set up matrices and vectors for the linear system of the correct size and assemble them. Setting them up works in exactly the same way as for the non- \(hp\)-case. Assembling requires a bit more thought.</p>
<p>The main idea is of course unchanged: we have to loop over all cells, assemble local contributions, and then copy them into the global objects. As discussed in some detail first in <a class="el" href="step_3.html">step-3</a>, deal.II has the <a class="el" href="classFEValues.html">FEValues</a> class that pulls the finite element description, mapping, and quadrature formula together and aids in evaluating values and gradients of shape functions as well as other information on each of the quadrature points mapped to the real location of a cell. Every time we move on to a new cell we re-initialize this <a class="el" href="classFEValues.html">FEValues</a> object, thereby asking it to re-compute that part of the information that changes from cell to cell. It can then be used to sum up local contributions to bilinear form and right hand side.</p>
<p>In the context of \(hp\)-finite element methods, we have to deal with the fact that we do not use the same finite element object on each cell. In fact, we should not even use the same quadrature object for all cells, but rather higher order quadrature formulas for cells where we use higher order finite elements. Similarly, we may want to use higher order mappings on such cells as well.</p>
<p>To facilitate these considerations, deal.II has a class <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> that does what we need in the current context. The difference is that instead of a single finite element, quadrature formula, and mapping, it takes collections of these objects. It's use is very much like the regular <a class="el" href="classFEValues.html">FEValues</a> class, i.e., the interesting part of the loop over all cells would look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(mapping_collection,</div>
<div class="line">                               fe_collection,</div>
<div class="line">                               quadrature_collection,</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">  {</div>
<div class="line">    hp_fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">    ...  <span class="comment">// assemble local contributions and copy them into global object</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p>In this tutorial program, we will always use a Q1 mapping, so the mapping collection argument to the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> construction will be omitted. Inside the loop, we first initialize the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell. The second, third and fourth arguments denote the index within their respective collections of the quadrature, mapping, and finite element objects we wish to use on this cell. These arguments can be omitted (and are in the program below), in which case <code>cell-&gt;active_fe_index()</code> is used for this index. The order of these arguments is chosen in this way because one may sometimes want to pick a different quadrature or mapping object from their respective collections, but hardly ever a different finite element than the one in use on this cell, i.e., one with an index different from <code>cell-&gt;active_fe_index()</code>. The finite element collection index is therefore the last default argument so that it can be conveniently omitted.</p>
<p>What this <code>reinit</code> call does is the following: the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class checks whether it has previously already allocated a non- \(hp\)-<a class="el" href="classFEValues.html">FEValues</a> object for this combination of finite element, quadrature, and mapping objects. If not, it allocates one. It then re-initializes this object for the current cell, after which there is now a <a class="el" href="classFEValues.html">FEValues</a> object for the selected finite element, quadrature and mapping usable on the current cell. A reference to this object is then obtained using the call <code>hp_fe_values.get_present_fe_values()</code>, and will be used in the usual fashion to assemble local contributions.</p>
<p><a class="anchor" id="Asimpleindicatorforhprefinementandestimatingsmoothness"></a></p><h3>A simple indicator for hp-refinement and estimating smoothness</h3>
<p>One of the central pieces of the adaptive finite element method is that we inspect the computed solution (a posteriori) with an indicator that tells us which are the cells where the error is largest, and then refine them. In many of the other tutorial programs, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class to get an indication of the size of the error on a cell, although we also discuss more complicated strategies in some programs, most importantly in <a class="el" href="step_14.html">step-14</a>.</p>
<p>In any case, as long as the decision is only "refine this cell" or "do not
refine this cell", the actual refinement step is not particularly challenging. However, here we have a code that is capable of hp-refinement, i.e., we suddenly have two choices whenever we detect that the error on a certain cell is too large for our liking: we can refine the cell by splitting it into several smaller ones, or we can increase the polynomial degree of the shape functions used on it. How do we know which is the more promising strategy? Answering this question is the central problem in \(hp\)-finite element research at the time of this writing.</p>
<p>In short, the question does not appear to be settled in the literature at this time. There are a number of more or less complicated schemes that address it, but there is nothing like the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> that is universally accepted as a good, even if not optimal, indicator of the error. Most proposals use the fact that it is beneficial to increase the polynomial degree whenever the solution is locally smooth whereas it is better to refine the mesh wherever it is rough. However, the questions of how to determine the local smoothness of the solution as well as the decision when a solution is smooth enough to allow for an increase in \(p\) are certainly big and important ones.</p>
<p>In the following, we propose a simple estimator of the local smoothness of a solution. As we will see in the results section, this estimator has flaws, in particular as far as cells with local hanging nodes are concerned. We therefore do not intend to present the following ideas as a complete solution to the problem. Rather, it is intended as an idea to approach it that merits further research and investigation. In other words, we do not intend to enter a sophisticated proposal into the fray about answers to the general question. However, to demonstrate our approach to \(hp\)-finite elements, we need a simple indicator that does generate some useful information that is able to drive the simple calculations this tutorial program will perform.</p>
<p><a class="anchor" id="Theidea"></a></p><h4>The idea</h4>
<p>Our approach here is simple: for a function \(u({\bf x})\) to be in the Sobolev space \(H^s(K)\) on a cell \(K\), it has to satisfy the condition </p><p class="formulaDsp">
\[ \int_K |\nabla^s u({\bf x})|^2 \; d{\bf x} &lt; \infty. \]
</p>
<p> Assuming that the cell \(K\) is not degenerate, i.e., that the mapping from the unit cell to cell \(K\) is sufficiently regular, above condition is of course equivalent to </p><p class="formulaDsp">
\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} &lt; \infty\,, \]
</p>
<p> where \(\hat u(\hat{\bf x})\) is the function \(u({\bf x})\) mapped back onto the unit cell \(\hat K\). From here, we can do the following: first, let us define the Fourier series of \(\hat u\) as </p><p class="formulaDsp">
\[ \hat u(\hat{\bf x}) = \sum_{\bf k} \hat U_{\bf k}\,e^{-i {\bf k}\cdot \hat{\bf x}}, \]
</p>
<p> with Fourier vectors \({\bf k}=(k_x,k_y)\) in 2d, \({\bf k}=(k_x,k_y,k_z)\) in 3d, etc, and \(k_x,k_y,k_z=0,2\pi,4\pi,\ldots\). The coefficients of expansion \(\hat U_{\bf k}\) can be obtained using \(L^2\)-orthogonality of the exponential basis </p><p class="formulaDsp">
\[ \int_{\hat K} e^{-i {\bf m}\cdot \hat{\bf x}} e^{i {\bf n}\cdot \hat{\bf x}} d\hat{\bf x} = \delta_{\bf m \bf n}, \]
</p>
<p> that leads to the following expression </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \,. \]
</p>
<p> It becomes clear that we can then write the \(H^s\) norm of \(\hat u\) as </p><p class="formulaDsp">
\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} = \int_{\hat K} \left| \sum_{\bf k} |{\bf k}|^s e^{-i{\bf k}\cdot \hat{\bf x}} \hat U_{\bf k} \right|^2 \; d\hat{\bf x} = \sum_{\bf k} |{\bf k}|^{2s} |\hat U_{\bf k}|^2. \]
</p>
<p> In other words, if this norm is to be finite (i.e., for \(\hat u(\hat{\bf x})\) to be in \(H^s(\hat K)\)), we need that </p><p class="formulaDsp">
\[ |\hat U_{\bf k}| = {\cal O}\left(|{\bf k}|^{-\left(s+1/2+\frac{d-1}{2}+\epsilon\right)}\right). \]
</p>
<p> Put differently: the higher regularity \(s\) we want, the faster the Fourier coefficients have to go to zero. If you wonder where the additional exponent \(\frac{d-1}2\) comes from: we would like to make use of the fact that \(\sum_l a_l &lt; \infty\) if the sequence \(a_l = {\cal O}(l^{-1-\epsilon})\) for any \(\epsilon&gt;0\). The problem is that we here have a summation not only over a single variable, but over all the integer multiples of \(2\pi\) that are located inside the \(d\)-dimensional sphere, because we have vector components \(k_x, k_y, \ldots\). In the same way as we prove that the sequence \(a_l\) above converges by replacing the sum by an integral over the entire line, we can replace our \(d\)-dimensional sum by an integral over \(d\)-dimensional space. Now we have to note that between distance \(|{\bf k}|\) and \(|{\bf k}|+d|{\bf k}|\), there are, up to a constant, \(|{\bf k}|^{d-1}\) modes, in much the same way as we can transform the volume element \(dx\;dy\) into \(2\pi r\; dr\). Consequently, it is no longer \(|{\bf k}|^{2s}|\hat U_{\bf k}|^2\) that has to decay as \({\cal O}(|{\bf k}|^{-1-\epsilon})\), but it is in fact \(|{\bf k}|^{2s}|\hat U_{\bf k}|^2 |{\bf k}|^{d-1}\). A comparison of exponents yields the result.</p>
<p>We can turn this around: Assume we are given a function \(\hat u\) of unknown smoothness. Let us compute its Fourier coefficients \(\hat U_{\bf k}\) and see how fast they decay. If they decay as </p><p class="formulaDsp">
\[ |\hat U_{\bf k}| = {\cal O}(|{\bf k}|^{-\mu-\epsilon}), \]
</p>
<p> then consequently the function we had here was in \(H^{\mu-d/2}\).</p>
<p><a class="anchor" id="Whatwehavetodo"></a></p><h4>What we have to do</h4>
<p>So what do we have to do to estimate the local smoothness of \(u({\bf x})\) on a cell \(K\)? Clearly, the first step is to compute the Fourier coefficients of our solution. Fourier series being infinite series, we simplify our task by only computing the first few terms of the series, such that \(|{\bf k}|\le 2\pi N\) with a cut-off \(N\). Let us parenthetically remark that we want to choose \(N\) large enough so that we capture at least the variation of those shape functions that vary the most. On the other hand, we should not choose \(N\) too large: clearly, a finite element function, being a polynomial, is in \(C^\infty\) on any given cell, so the coefficients will have to decay exponentially at one point; since we want to estimate the smoothness of the function this polynomial approximates, not of the polynomial itself, we need to choose a reasonable cutoff for \(N\). Either way, computing this series is not particularly hard: from the definition </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \]
</p>
<p> we see that we can compute the coefficient \(\hat U_{\bf k}\) as </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \sum_{i=0}^{\textrm{dofs per cell}} \left[\int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_i(\hat{\bf x}) d\hat{\bf x} \right] u_i, \]
</p>
<p> where \(u_i\) is the value of the \(i\)th degree of freedom on this cell. In other words, we can write it as a matrix-vector product </p><p class="formulaDsp">
\[ \hat U_{\bf k} = {\cal F}_{{\bf k},j} u_j, \]
</p>
<p> with the matrix </p><p class="formulaDsp">
\[ {\cal F}_{{\bf k},j} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_j(\hat{\bf x}) d\hat{\bf x}. \]
</p>
<p> This matrix is easily computed for a given number of shape functions \(\varphi_j\) and Fourier modes \(N\). Consequently, finding the coefficients \(\hat U_{\bf k}\) is a rather trivial job. To simplify our life even further, we will use <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> class which does exactly this.</p>
<p>The next task is that we have to estimate how fast these coefficients decay with \(|{\bf k}|\). The problem is that, of course, we have only finitely many of these coefficients in the first place. In other words, the best we can do is to fit a function \(\alpha |{\bf k}|^{-\mu}\) to our data points \(\hat U_{\bf k}\), for example by determining \(\alpha,\mu\) via a least-squares procedure: </p><p class="formulaDsp">
\[ \min_{\alpha,\mu} \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( |\hat U_{\bf k}| - \alpha |{\bf k}|^{-\mu}\right)^2 \]
</p>
<p> However, the problem with this is that it leads to a nonlinear problem, a fact that we would like to avoid. On the other hand, we can transform the problem into a simpler one if we try to fit the logarithm of our coefficients to the logarithm of \(\alpha |{\bf k}|^{-\mu}\), like this: </p><p class="formulaDsp">
\[ \min_{\alpha,\mu} Q(\alpha,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \ln (\alpha |{\bf k}|^{-\mu})\right)^2. \]
</p>
<p> Using the usual facts about logarithms, we see that this yields the problem </p><p class="formulaDsp">
\[ \min_{\beta,\mu} Q(\beta,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \beta + \mu \ln |{\bf k}|\right)^2, \]
</p>
<p> where \(\beta=\ln \alpha\). This is now a problem for which the optimality conditions \(\frac{\partial Q}{\partial\beta}=0, \frac{\partial Q}{\partial\mu}=0\), are linear in \(\beta,\mu\). We can write these conditions as follows: </p><p class="formulaDsp">
\[ \left(\begin{array}{cc} \sum_{{\bf k}, |{\bf k}|\le N} 1 &amp; \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| &amp; \sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2 \end{array}\right) \left(\begin{array}{c} \beta \\ -\mu \end{array}\right) = \left(\begin{array}{c} \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \end{array}\right) \]
</p>
<p> This linear system is readily inverted to yield </p><p class="formulaDsp">
\[ \beta = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 } \]
</p>
<p> and </p><p class="formulaDsp">
\[ \mu = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 }. \]
</p>
<p>This is nothing else but linear regression fit and to do that we will use <a class="el" href="namespaceFESeries.html#afa42058db3555536415fae91822d27e3">FESeries::linear_regression()</a>. While we are not particularly interested in the actual value of \(\beta\), the formula above gives us a mean to calculate the value of the exponent \(\mu\) that we can then use to determine that \(\hat u(\hat{\bf x})\) is in \(H^s(\hat K)\) with \(s=\mu-\frac d2\).</p>
<p>These steps outlined above are applicable to many different scenarios, which motivated the introduction of a generic function <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay()</a> in deal.II, that combines all the tasks described in this section in one simple function call. We will use it in the implementation of this program.</p>
<p><a class="anchor" id="Compensatingforanisotropy"></a></p><h4>Compensating for anisotropy</h4>
<p>In the formulas above, we have derived the Fourier coefficients \(\hat U_{\bf k}\). Because \({\bf k}\) is a vector, we will get a number of Fourier coefficients \(\hat U_{{\bf k}}\) for the same absolute value \(|{\bf k}|\), corresponding to the Fourier transform in different directions. If we now consider a function like \(|x|y^2\) then we will find lots of large Fourier coefficients in \(x\)-direction because the function is non-smooth in this direction, but fast-decaying Fourier coefficients in \(y\)-direction because the function is smooth there. The question that arises is this: if we simply fit our polynomial decay \(\alpha |{\bf k}|^\mu\) to <em>all</em> Fourier coefficients, we will fit it to a smoothness <em>averaged in all spatial directions</em>. Is this what we want? Or would it be better to only consider the largest coefficient \(\hat U_{{\bf k}}\) for all \({\bf k}\) with the same magnitude, essentially trying to determine the smoothness of the solution in that spatial direction in which the solution appears to be roughest?</p>
<p>One can probably argue for either case. The issue would be of more interest if deal.II had the ability to use anisotropic finite elements, i.e., ones that use different polynomial degrees in different spatial directions, as they would be able to exploit the directionally variable smoothness much better. Alas, this capability does not exist at the time of writing this tutorial program.</p>
<p>Either way, because we only have isotopic finite element classes, we adopt the viewpoint that we should tailor the polynomial degree to the lowest amount of regularity, in order to keep numerical efforts low. Consequently, instead of using the formula </p><p class="formulaDsp">
\[ \mu = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 }. \]
</p>
<p> To calculate \(\mu\) as shown above, we have to slightly modify all sums: instead of summing over all Fourier modes, we only sum over those for which the Fourier coefficient is the largest one among all \(\hat U_{{\bf k}}\) with the same magnitude \(|{\bf k}|\), i.e., all sums above have to replaced by the following sums: </p><p class="formulaDsp">
\[ \sum_{{\bf k}, |{\bf k}|\le N} \longrightarrow \sum_{\begin{matrix}{{\bf k}, |{\bf k}|\le N} \\ {|\hat U_{{\bf k}}| \ge |\hat U_{{\bf k}&#39;}| \ \textrm{for all}\ {\bf k}&#39;\ \textrm{with}\ |{\bf k}&#39;|=|{\bf k}|}\end{matrix}}. \]
</p>
<p> This is the form we will implement in the program.</p>
<p><a class="anchor" id="Questionsaboutcellsizes"></a></p><h4>Questions about cell sizes</h4>
<p>One may ask whether it is a problem that we only compute the Fourier transform on the <em>reference cell</em> (rather than the real cell) of the solution. After all, we stretch the solution by a factor \(\frac 1h\) during the transformation, thereby shifting the Fourier frequencies by a factor of \(h\). This is of particular concern since we may have neighboring cells with mesh sizes \(h\) that differ by a factor of 2 if one of them is more refined than the other. The concern is also motivated by the fact that, as we will see in the results section below, the estimated smoothness of the solution should be a more or less continuous function, but exhibits jumps at locations where the mesh size jumps. It therefore seems natural to ask whether we have to compensate for the transformation.</p>
<p>The short answer is "no". In the process outlined above, we attempt to find coefficients \(\beta,\mu\) that minimize the sum of squares of the terms </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln |{\bf k}|. \]
</p>
<p> To compensate for the transformation means not attempting to fit a decay \(|{\bf k}|^\mu\) with respect to the Fourier frequencies \({\bf k}\) <em>on the unit cell</em>, but to fit the coefficients \(\hat U_{{\bf k}}\) computed on the reference cell <em>to the Fourier frequencies on the real cell \(|\bf k|h\)</em>, where \(h\) is the norm of the transformation operator (i.e., something like the diameter of the cell). In other words, we would have to minimize the sum of squares of the terms </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln (|{\bf k}|h). \]
</p>
<p> instead. However, using fundamental properties of the logarithm, this is simply equivalent to minimizing </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - (\beta - \mu \ln h) + \mu \ln (|{\bf k}|). \]
</p>
<p> In other words, this and the original least squares problem will produce the same best-fit exponent \(\mu\), though the offset will in one case be \(\beta\) and in the other \(\beta-\mu \ln h\). However, since we are not interested in the offset at all but only in the exponent, it doesn't matter whether we scale Fourier frequencies in order to account for mesh size effects or not, the estimated smoothness exponent will be the same in either case.</p>
<p><a class="anchor" id="Complicationswithlinearsystemsforhpdiscretizations"></a></p><h3>Complications with linear systems for hp-discretizations</h3>
<p><a class="anchor" id="Creatingthesparsitypattern"></a></p><h4>Creating the sparsity pattern</h4>
<p>One of the problems with \(hp\)-methods is that the high polynomial degree of shape functions together with the large number of constrained degrees of freedom leads to matrices with large numbers of nonzero entries in some rows. At the same time, because there are areas where we use low polynomial degree and consequently matrix rows with relatively few nonzero entries. Consequently, allocating the sparsity pattern for these matrices is a challenge: we cannot simply assemble a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> by starting with an estimate of the bandwidth without using a lot of extra memory.</p>
<p>The way in which we create a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> for the underlying linear system is tightly coupled to the strategy we use to enforce constraints. deal.II supports handling constraints in linear systems in two ways: </p><ol>
<li>
Assembling the matrix without regard to the constraints and applying them afterwards with <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a>, or </li>
<li>
Applying constraints as we assemble the system with <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. </li>
</ol>
<p>Most programs built on deal.II use the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> function to allocate a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that takes constraints into account. The system matrix then uses a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> copied over from the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. This method is explained in <a class="el" href="step_2.html">step-2</a> and used in most tutorial programs.</p>
<p>The early tutorial programs use first or second degree finite elements, so removing entries in the sparsity pattern corresponding to constrained degrees of freedom does not have a large impact on the overall number of zeros explicitly stored by the matrix. However, since as many as a third of the degrees of freedom may be constrained in an hp-discretization (and, with higher degree elements, these constraints can couple one DoF to as many as ten or twenty other DoFs), it is worthwhile to take these constraints into consideration since the resulting matrix will be much sparser (and, therefore, matrix-vector products or factorizations will be substantially faster too).</p>
<p><a class="anchor" id="Eliminatingconstraineddegreesoffreedom"></a></p><h4>Eliminating constrained degrees of freedom</h4>
<p>A second problem particular to \(hp\)-methods arises because we have so many constrained degrees of freedom: typically up to about one third of all degrees of freedom (in 3d) are constrained because they either belong to cells with hanging nodes or because they are on cells adjacent to cells with a higher or lower polynomial degree. This is, in fact, not much more than the fraction of constrained degrees of freedom in non- \(hp\)-mode, but the difference is that each constrained hanging node is constrained not only against the two adjacent degrees of freedom, but is constrained against many more degrees of freedom.</p>
<p>It turns out that the strategy presented first in <a class="el" href="step_6.html">step-6</a> to eliminate the constraints while computing the element matrices and vectors with <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a> is the most efficient approach also for this case. The alternative strategy to first build the matrix without constraints and then "condensing" away constrained degrees of freedom is considerably more expensive. It turns out that building the sparsity pattern by this inefficient algorithm requires at least \({\cal O}(N \log N)\) in the number of unknowns, whereas an ideal finite element program would of course only have algorithms that are linear in the number of unknowns. Timing the sparsity pattern creation as well as the matrix assembly shows that the algorithm presented in <a class="el" href="step_6.html">step-6</a> (and used in the code below) is indeed faster.</p>
<p>In our program, we will also treat the boundary conditions as (possibly inhomogeneous) constraints and eliminate the matrix rows and columns to those as well. All we have to do for this is to call the function that interpolates the Dirichlet boundary conditions already in the setup phase in order to tell the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object about them, and then do the transfer from local to global data on matrix and vector simultaneously. This is exactly what we've shown in <a class="el" href="step_6.html">step-6</a>.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>The test case we will solve with this program is a re-take of the one we already look at in <a class="el" href="step_14.html">step-14</a>: we solve the Laplace equation </p><p class="formulaDsp">
\[ -\Delta u = f \]
</p>
<p> in 2d, with \(f=(x+1)(y+1)\), and with zero Dirichlet boundary values for \(u\). We do so on the domain \([-1,1]^2\backslash[-\frac 12,\frac 12]^2\), i.e., a square with a square hole in the middle.</p>
<p>The difference to <a class="el" href="step_14.html">step-14</a> is of course that we use \(hp\)-finite elements for the solution. The test case is of interest because it has re-entrant corners in the corners of the hole, at which the solution has singularities. We therefore expect that the solution will be smooth in the interior of the domain, and rough in the vicinity of the singularities. The hope is that our refinement and smoothness indicators will be able to see this behavior and refine the mesh close to the singularities, while the polynomial degree is increased away from it. As we will see in the results section, this is indeed the case.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few files have already been covered in previous examples and will thus not be further commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
</div><!-- fragment --><p>These are the new files we need. The first and second provide the FECollection and the <em>hp</em> version of the <a class="el" href="classFEValues.html">FEValues</a> class as described in the introduction of this program. The next one provides the functionality for automatic \(hp\)-adaptation, for which we will use the estimation algorithms based on decaying series expansion coefficients that are part of the last two files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2refinement_8h.html">deal.II/hp/refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__series_8h.html">deal.II/fe/fe_series.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2smoothness__estimator_8h.html">deal.II/numerics/smoothness_estimator.h</a>&gt;</span></div>
</div><!-- fragment --><p>The last set of include files are standard C++ headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Finally, this is as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep27.html">Step27</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="Themainclass"></a> </p><h3>The main class</h3>
<p>The main class of this program looks very much like the one already used in the first few tutorial programs, for example the one in <a class="el" href="step_6.html">step-6</a>. The main difference is that we have merged the refine_grid and output_results functions into one since we will also want to output some of the quantities used in deciding how to refine the mesh (in particular the estimated smoothness of the solution).</p>
<p>As far as member variables are concerned, we use the same structure as already used in <a class="el" href="step_6.html">step-6</a>, but we need collections instead of individual finite element, quadrature, and face quadrature objects. We will fill these collections in the constructor of the class. The last variable, <code>max_degree</code>, indicates the maximal polynomial degree of shape functions used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classLaplaceProblem.html">LaplaceProblem</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem</a>();</div>
<div class="line">  ~<a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">setup_system</a>();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">assemble_system</a>();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">solve</a>();</div>
<div class="line">  <span class="keywordtype">void</span> create_coarse_grid();</div>
<div class="line">  <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="classLaplaceProblem.html#a1f9c6147583b774bd1620d534c32dee5">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>          <a class="code" href="classLaplaceProblem.html#a2713d4075ba7824063d84a8c9f9d2967">dof_handler</a>;</div>
<div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div>
<div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div>
<div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt; face_quadrature_collection;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#a40d0609a27a24ce310ae30cfccdf7f04">constraints</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#addbdc7360d9feca8f8676eb6f381b6db">system_matrix</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#a5c6d887dea84186bb992ec9fec99f744">solution</a>;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Next, let us define the right hand side function for this problem. It is \(x+1\) in 1d, \((x+1)(y+1)\) in 2d, and so on.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classRightHandSide.html#a07b87d7025c7c5feca044c5c7d4296ef">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classRightHandSide.html#a07b87d7025c7c5feca044c5c7d4296ef">RightHandSide&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">    <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> *= (<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] + 1);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Implementationofthemainclass"></a> </p><h3>Implementation of the main class</h3>
<p><a class="anchor" id="LaplaceProblemLaplaceProblemconstructor"></a> </p><h4><a class="el" href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem::LaplaceProblem</a> constructor</h4>
<p>The constructor of this class is fairly straightforward. It associates the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with the triangulation, and then sets the maximal polynomial degree to 7 (in 1d and 2d) or 5 (in 3d and higher). We do so because using higher order polynomial degrees becomes prohibitively expensive, especially in higher space dimensions.</p>
<p>Following this, we fill the collections of finite element, and cell and face quadrature objects. We start with quadratic elements, and each quadrature formula is chosen so that it is appropriate for the matching finite element in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><a class="code" href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem&lt;dim&gt;::LaplaceProblem</a>()</div>
<div class="line">  : dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , max_degree(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &lt;= 2 ? 7 : 5)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">    {</div>
<div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
<div class="line">      quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">      face_quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemLaplaceProblemdestructor"></a> </p><h4>LaplaceProblem::~LaplaceProblem destructor</h4>
<p>The destructor is unchanged from what we already did in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::~LaplaceProblem</a>()</div>
<div class="line">{</div>
<div class="line">  dof_handler.clear();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4><a class="el" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem::setup_system</a></h4>
<p>This function is again a verbatim copy of what we already did in <a class="el" href="step_6.html">step-6</a>. Despite function calls with exactly the same names and arguments, the algorithms used internally are different in some aspect since the dof_handler variable here is in \(hp\)-mode.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem&lt;dim&gt;::setup_system</a>()</div>
<div class="line">{</div>
<div class="line">  dof_handler.distribute_dofs(fe_collection);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.n_dofs());</div>
<div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div>
<div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                           0,</div>
<div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                           <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">  system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4><a class="el" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem::assemble_system</a></h4>
<p>This is the function that assembles the global matrix and right hand side vector from the local contributions of each cell. Its main working is as has been described in many of the tutorial programs before. The significant deviations are the ones necessary for <em>hp</em> finite element methods. In particular, that we need to use a collection of <a class="el" href="classFEValues.html">FEValues</a> object (implemented through the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class), and that we have to eliminate constrained degrees of freedom already when copying local contributions into global objects. Both of these are explained in detail in the introduction of this program.</p>
<p>One other slight complication is the fact that because we use different polynomial degrees on different cells, the matrices and vectors holding local contributions do not have the same size on all cells. At the beginning of the loop over all cells, we therefore each time have to resize them to the correct size (given by <code>dofs_per_cell</code>). Because these classes are implemented in such a way that reducing the size of a matrix or vector does not release the currently allocated memory (unless the new size is zero), the process of resizing at the beginning of the loop will only require re-allocation of memory during the first few iterations. Once we have found in a cell with the maximal finite element degree, no more re-allocations will happen because all subsequent <code>reinit</code> calls will only set the size to something that fits the currently allocated memory. This is important since allocating memory is expensive, and doing so every time we visit a new cell would take significant compute time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem&lt;dim&gt;::assemble_system</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div>
<div class="line">                                 quadrature_collection,</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classRightHandSide.html">RightHandSide&lt;dim&gt;</a> rhs_function;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_fe().n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> = 0;</div>
<div class="line"> </div>
<div class="line">      cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">      hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;double&gt; rhs_values(fe_values.n_quadrature_points);</div>
<div class="line">      rhs_function.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(), rhs_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; fe_values.n_quadrature_points;</div>
<div class="line">           ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">              <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// grad phi_i(x_q)</span></div>
<div class="line">                 fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) * <span class="comment">// grad phi_j(x_q)</span></div>
<div class="line">                 fe_values.JxW(q_point));           <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">            cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                            rhs_values[q_point] *               <span class="comment">// f(x_q)</span></div>
<div class="line">                            fe_values.JxW(q_point));            <span class="comment">// dx</span></div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>, cell_rhs, <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>, system_matrix, system_rhs);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4><a class="el" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem::solve</a></h4>
<p>The function solving the linear system is entirely unchanged from previous examples. We simply try to reduce the initial residual (which equals the \(l_2\) norm of the right hand side) by a certain factor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div>
<div class="line">                               1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12 * system_rhs.l2_norm());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">  <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(system_matrix, 1.2);</div>
<div class="line"> </div>
<div class="line">  cg.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblempostprocess"></a> </p><h4>LaplaceProblem::postprocess</h4>
<p>After solving the linear system, we will want to postprocess the solution. Here, all we do is to estimate the error, estimate the local smoothness of the solution as described in the introduction, then write graphical output, and finally refine the mesh in both \(h\) and \(p\) according to the indicators computed before. We do all this in the same function because we want the estimated error and smoothness indicators not only for refinement, but also include them in the graphical output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::postprocess</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">{</div>
</div><!-- fragment --><p>Let us start with computing estimated error and smoothness indicators, which each are one number for each active cell of our triangulation. For the error indicator, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class as always.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">  dof_handler,</div>
<div class="line">  face_quadrature_collection,</div>
<div class="line">  <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">  estimated_error_per_cell);</div>
</div><!-- fragment --><p>Estimating the smoothness is performed with the method of decaying expansion coefficients as outlined in the introduction. We will first need to create an object capable of transforming the finite element solution on every single cell into a sequence of Fourier series coefficients. The <a class="el" href="namespaceSmoothnessEstimator.html">SmoothnessEstimator</a> namespace offers a factory function for such a <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> object that is optimized for the process of estimating smoothness. The actual determination of the decay of Fourier coefficients on every individual cell then happens in the last function.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classFESeries_1_1Fourier.html">FESeries::Fourier&lt;dim&gt;</a> fourier =</div>
<div class="line">  <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#a748faa704c9dfb67a074d11316e777b4">SmoothnessEstimator::Fourier::default_fe_series</a>(fe_collection);</div>
<div class="line"><a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay</a>(fourier,</div>
<div class="line">                                                dof_handler,</div>
<div class="line">                                                <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                                smoothness_indicators);</div>
</div><!-- fragment --><p>Next we want to generate graphical output. In addition to the two estimated quantities derived above, we would also like to output the polynomial degree of the finite elements used on each of the elements on the mesh.</p>
<p>The way to do that requires that we loop over all cells and poll the active finite element index of them using <code>cell-&gt;active_fe_index()</code>. We then use the result of this operation and query the finite element collection for the finite element with that index, and finally determine the polynomial degree of that element. The result we put into a vector with one element per cell. The <a class="el" href="classDataOut.html">DataOut</a> class requires this to be a vector of <code>float</code> or <code>double</code>, even though our values are all integers, so that is what we use:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    fe_degrees(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) =</div>
<div class="line">      fe_collection[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_fe_index()].degree;</div>
</div><!-- fragment --><p>With now all data vectors available &ndash; solution, estimated errors and smoothness indicators, and finite element degrees &ndash;, we create a <a class="el" href="classDataOut.html">DataOut</a> object for graphical output and attach all data:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
</div><!-- fragment --><p>The final step in generating output is to determine a file name, open the file, and write the data into it (here, we use VTK format):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After this, we would like to actually refine the mesh, in both \(h\) and \(p\). The way we are going to do this is as follows: first, we use the estimated error to flag those cells for refinement that have the largest error. This is what we have always done:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                  estimated_error_per_cell,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0.03);</div>
</div><!-- fragment --><p>Next we would like to figure out which of the cells that have been flagged for refinement should actually have \(p\) increased instead of \(h\) decreased. The strategy we choose here is that we look at the smoothness indicators of those cells that are flagged for refinement, and increase \(p\) for those with a smoothness larger than a certain relative threshold. In other words, for every cell for which (i) the refinement flag is set, (ii) the smoothness indicator is larger than the threshold, and (iii) we still have a finite element with a polynomial degree higher than the current one in the finite element collection, we will assign a future FE index that corresponds to a polynomial with degree one higher than it currently is. The following function is capable of doing exactly this. Absent any better strategies, we will set the threshold via interpolation between the minimal and maximal smoothness indicators on cells flagged for refinement. Since the corner singularities are strongly localized, we will favor \(p\)- over \(h\)-refinement quantitatively. We achieve this with a low threshold by setting a small interpolation factor of 0.2. In the same way, we deal with cells that are going to be coarsened and decrease their polynomial degree when their smoothness indicator is below the corresponding threshold determined on cells to be coarsened.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">hp::Refinement::p_adaptivity_from_relative_threshold</a>(</div>
<div class="line">  dof_handler, smoothness_indicators, 0.2, 0.2);</div>
</div><!-- fragment --><p>The above function only determines whether the polynomial degree will change via future FE indices, but does not manipulate the \(h\)-refinement flags. So for cells that are flagged for both refinement categories, we prefer \(p\)- over \(h\)-refinement. The following function call ensures that only one of \(p\)- or \(h\)-refinement is imposed, and not both at once.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">hp::Refinement::choose_p_over_h</a>(dof_handler);</div>
</div><!-- fragment --><p>For grid adaptive refinement, we ensure a 2:1 mesh balance by limiting the difference of refinement levels of neighboring cells to one by calling <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a>. We would like to achieve something similar for the p-levels of neighboring cells: levels of future finite elements are not allowed to differ by more than a specified difference. With its default parameters, a call of <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> ensures that their level difference is limited to one. This will not necessarily decrease the number of hanging nodes in the domain, but makes sure that high order polynomials are not constrained to much lower polynomials on faces, e.g., fifth order to second order polynomials.</p>
<div class="fragment"><div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference</a>(dof_handler);</div>
</div><!-- fragment --><p>At the end of this procedure, we then refine the mesh. During this process, children of cells undergoing bisection inherit their mother cell's finite element index. Further, future finite element indices will turn into active ones, so that the new finite elements will be assigned to cells after the next call of <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>.</p>
<div class="fragment"><div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcreate_coarse_grid"></a> </p><h4>LaplaceProblem::create_coarse_grid</h4>
<p>The following function is used when creating the initial grid. The grid we would like to create is actually similar to the one from <a class="el" href="step_14.html">step-14</a>, i.e., the square domain with the square hole in the middle. It can be generated by exactly the same function. However, since its implementation is only a specialization of the 2d case, we will present a different way of creating this domain which is dimension independent.</p>
<p>We first create a hypercube triangulation with enough cells so that it already holds our desired domain \([-1,1]^d\), subdivided into \(4^d\) cells. We then remove those cells in the center of the domain by testing the coordinate values of the vertices on each cell. In the end, we refine the so created grid globally as usual.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::create_coarse_grid</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> cube;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(cube, 4, -1., 1.);</div>
<div class="line"> </div>
<div class="line">  std::set&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt; cells_to_remove;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : cube.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a> = 0; <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell</a>; ++<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>).square() &lt; .1)</div>
<div class="line">        cells_to_remove.insert(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">GridGenerator::create_triangulation_with_removed_cells</a>(cube,</div>
<div class="line">                                                         cells_to_remove,</div>
<div class="line">                                                         <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(3);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4><a class="el" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem::run</a></h4>
<p>This function implements the logic of the program, as did the respective function in most of the previous programs already, see for example <a class="el" href="step_6.html">step-6</a>.</p>
<p>Basically, it contains the adaptive loop: in the first iteration create a coarse grid, and then set up the linear system, assemble it, solve, and postprocess the solution including mesh refinement. Then start over again. In the meantime, also output some information for those staring at the screen trying to figure out what the program does:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; 6; ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">          create_coarse_grid();</div>
<div class="line"> </div>
<div class="line">        setup_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells      : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        assemble_system();</div>
<div class="line">        <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">        postprocess(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step27</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The main function is again verbatim what we had before: wrap creating and running an object of the main class into a <code>try</code> block and catch whatever exceptions are thrown, thereby producing meaningful output if anything should go wrong:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep27.html">Step27</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;2&gt;</a> laplace_problem;</div>
<div class="line">      laplace_problem.<a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>In this section, we discuss a few results produced from running the current tutorial program. More results, in particular the extension to 3d calculations and determining how much compute time the individual components of the program take, are given in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>.</p>
<p>When run, this is what the program produces:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">[ 66%] Built target @<a class="code" href="ginkgo__solver__0_8txt.html#af756036e4c7d624b94dfff983b9d40f5">ref</a> step_27 <span class="stringliteral">&quot;step-27&quot;</span></div>
<div class="line">[100%] Run @<a class="code" href="ginkgo__solver__0_8txt.html#af756036e4c7d624b94dfff983b9d40f5">ref</a> step_27 <span class="stringliteral">&quot;step-27&quot;</span> <a class="code" href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a> Release <a class="code" href="physics__0_8txt.html#a38362129af36598c1e4b4e928688ca77">configuration</a></div>
<div class="line">Cycle 0:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 768</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 3264</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 384</div>
<div class="line">Cycle 1:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 807</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 4764</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 756</div>
<div class="line">Cycle 2:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 927</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 8226</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 1856</div>
<div class="line">Cycle 3:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 978</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 12146</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 2944</div>
<div class="line">Cycle 4:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 1104</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 16892</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 3998</div>
<div class="line">Cycle 5:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 1149</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 22078</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 5230</div>
</div><!-- fragment --><p>The first thing we learn from this is that the number of constrained degrees of freedom is on the order of 20-25% of the total number of degrees of freedom, at least on the later grids when we have elements of relatively high order (in 3d, the fraction of constrained degrees of freedom can be up to 30%). This is, in fact, on the same order of magnitude as for non- \(hp\)-discretizations. For example, in the last step of the <a class="el" href="step_6.html">step-6</a> program, we have 18353 degrees of freedom, 4432 of which are constrained. The difference is that in the latter program, each constrained hanging node is constrained against only the two adjacent degrees of freedom, whereas in the \(hp\)-case, constrained nodes are constrained against many more degrees of freedom. Note also that the current program also includes nodes subject to Dirichlet boundary conditions in the list of constraints. In cycle 0, all the constraints are actually because of boundary conditions.</p>
<p>Of maybe more interest is to look at the graphical output. First, here is the solution of the problem:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-27-solution.png" alt="Elevation plot of the solution, showing the lack of regularity near
          the interior (reentrant) corners." width="200" height="200" class="inline"/></p>
<p>Secondly, let us look at the sequence of meshes generated:</p>
<div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-00.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners without adaptive refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-01.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with one level of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-02.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with two levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-03.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with three levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-04.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with four levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-05.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with five levels of
         refinement. New cells are placed near the corners.</object> </div> </div><p>It is clearly visible how the mesh is refined near the corner singularities, as one would expect it. More interestingly, we should be curious to see the distribution of finite element polynomial degrees to these mesh cells, where the lightest color corresponds to degree two and the darkest one corresponds to degree seven:</p>
<div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-00.svg" style="pointer-events: none;" width="200" height="200">Initial grid where all cells contain just biquadratic functions.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-01.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after one refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-02.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after two refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-03.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after three refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-04.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after four refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-05.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after five refinements.</object> </div> </div><p>While this is certainly not a perfect arrangement, it does make some sense: we use low order elements close to boundaries and corners where regularity is low. On the other hand, higher order elements are used where (i) the error was at one point fairly large, i.e., mainly in the general area around the corner singularities and in the top right corner where the solution is large, and (ii) where the solution is smooth, i.e., far away from the boundary.</p>
<p>This arrangement of polynomial degrees of course follows from our smoothness estimator. Here is the estimated smoothness of the solution, with darker colors indicating least smoothness and lighter indicating the smoothest areas:</p>
<div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-00.svg" style="pointer-events: none;" width="200" height="200">Estimated regularity per cell on the initial grid.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-01.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after one refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-02.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after two refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-03.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after three refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-04.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after four refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-05.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after five refinements.</object> </div> </div><p>The primary conclusion one can draw from this is that the loss of regularity at the internal corners is a highly localized phenomenon; it only seems to impact the cells adjacent to the corner itself, so when we refine the mesh the black coloring is no longer visible. Besides the corners, this sequence of plots implies that the smoothness estimates are somewhat independent of the mesh refinement, particularly when we are far away from boundaries. It is also obvious that the smoothness estimates are independent of the actual size of the solution (see the picture of the solution above), as it should be. A point of larger concern, however, is that one realizes on closer inspection that the estimator we have overestimates the smoothness of the solution on cells with hanging nodes. This in turn leads to higher polynomial degrees in these areas, skewing the allocation of finite elements onto cells.</p>
<p>We have no good explanation for this effect at the moment. One theory is that the numerical solution on cells with hanging nodes is, of course, constrained and therefore not entirely free to explore the function space to get close to the exact solution. This lack of degrees of freedom may manifest itself by yielding numerical solutions on these cells with suppressed oscillation, meaning a higher degree of smoothness. The estimator picks this signal up and the estimated smoothness overestimates the actual value. However, a definite answer to what is going on currently eludes the authors of this program.</p>
<p>The bigger question is, of course, how to avoid this problem. Possibilities include estimating the smoothness not on single cells, but cell assemblies or patches surrounding each cell. It may also be possible to find simple correction factors for each cell depending on the number of constrained degrees of freedom it has. In either case, there are ample opportunities for further research on finding good \(hp\)-refinement criteria. On the other hand, the main point of the current program was to demonstrate using the \(hp\)-technology in deal.II, which is unaffected by our use of a possible sub-optimal refinement criterion.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Differenthpdecisionstrategies"></a></p><h4>Different hp-decision strategies</h4>
<p>This tutorial demonstrates only one particular strategy to decide between \(h\)- and \(p\)-adaptation. In fact, there are many more ways to automatically decide on the adaptation type, of which a few are already implemented in deal.II: </p><ul>
<li>
<p class="startli"><em>Fourier coefficient decay:</em> This is the strategy currently implemented in this tutorial. For more information on this strategy, see the general documentation of the <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">SmoothnessEstimator::Fourier</a> namespace.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Legendre coefficient decay:</em> This strategy is quite similar to the current one, but uses Legendre series expansion rather than the Fourier one: instead of sinusoids as basis functions, this strategy uses Legendre polynomials. Of course, since we approximate the solution using a finite-dimensional polynomial on each cell, the expansion of the solution in Legendre polynomials is also finite and, consequently, when we talk about the "decay" of this expansion, we can only consider the finitely many nonzero coefficients of this expansion, rather than think about it in asymptotic terms. But, if we have enough of these coefficients, we can certainly think of the decay of these coefficients as characteristic of the decay of the coefficients of the exact solution (which is, in general, not polynomial and so will have an infinite Legendre expansion), and considering the coefficients we have should reveal something about the properties of the exact solution.</p>
<p class="interli">The transition from the Fourier strategy to the Legendre one is quite simple: You just need to change the series expansion class and the corresponding smoothness estimation function to be part of the proper namespaces <a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> and <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">SmoothnessEstimator::Legendre</a>. This strategy is used in <a class="el" href="step_75.html">step-75</a>. For the theoretical background of this strategy, consult the general documentation of the <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">SmoothnessEstimator::Legendre</a> namespace, as well as <b>[mavriplis1994hp]</b> , <b>[eibner2007hp]</b> and <b>[davydov2017hp]</b> .</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Refinement history:</em> The last strategy is quite different from the other two. In theory, we know how the error will converge after changing the discretization of the function space. With \(h\)-refinement the solution converges algebraically as already pointed out in <a class="el" href="step_7.html">step-7</a>. If the solution is sufficiently smooth, though, we expect that the solution will converge exponentially with increasing polynomial degree of the finite element. We can compare a proper prediction of the error with the actual error in the following step to see if our choice of adaptation type was justified.</p>
<p class="interli">The transition to this strategy is a bit more complicated. For this, we need an initialization step with pure \(h\)- or \(p\)-refinement and we need to transfer the predicted errors over adapted meshes. The extensive documentation of the <a class="el" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error()</a> function describes not only the theoretical details of this approach, but also presents a blueprint on how to implement this strategy in your code. For more information, see <b>[melenk2001hp]</b> .</p>
<p class="endli">Note that with this particular function you cannot predict the error for the next time step in time-dependent problems. Therefore, this strategy cannot be applied to this type of problem without further ado. Alternatively, the following approach could be used, which works for all the other strategies as well: start each time step with a coarse mesh, keep refining until happy with the result, and only then move on to the next time step. </p>
</li>
</ul>
<p>Try implementing one of these strategies into this tutorial and observe the subtle changes to the results. You will notice that all strategies are capable of identifying the singularities near the reentrant corners and will perform \(h\)-refinement in these regions, while preferring \(p\)-refinement in the bulk domain. A detailed comparison of these strategies is presented in <b>[fehling2020]</b> .</p>
<p><a class="anchor" id="Parallelhpadaptivefiniteelements"></a></p><h4>Parallel hp-adaptive finite elements</h4>
<p>All functionality presented in this tutorial already works for both sequential and parallel applications. It is possible without too much effort to change to either the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> classes. If you feel eager to try it, we recommend reading <a class="el" href="step_18.html">step-18</a> for the former and <a class="el" href="step_40.html">step-40</a> for the latter case first for further background information on the topic, and then come back to this tutorial to try out your newly acquired skills.</p>
<p>We go one step further in <a class="el" href="step_75.html">step-75</a>: Here, we combine hp-adapative and <a class="el" href="classMatrixFree.html">MatrixFree</a> methods in combination with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2006, 2007;</span></div>
<div class="line"><span class="comment"> *          Denis Davydov, University of Erlangen-Nuremberg, 2016;</span></div>
<div class="line"><span class="comment"> *          Marc Fehling, Colorado State University, 2020.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2refinement_8h.html">deal.II/hp/refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__series_8h.html">deal.II/fe/fe_series.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2smoothness__estimator_8h.html">deal.II/numerics/smoothness_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep27.html">Step27</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classLaplaceProblem.html">LaplaceProblem</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line">    ~<a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    <span class="keywordtype">void</span> create_coarse_grid();</div>
<div class="line">    <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>          dof_handler;</div>
<div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div>
<div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div>
<div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt; face_quadrature_collection;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="classStep27_1_1RightHandSide.html#a19c67ad03b64ec2b1e970bd2551981ed">RightHandSide&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">      <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> *= (<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] + 1);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep27_1_1LaplaceProblem.html#a5ad3099268928abf7d470cb7fb12176a">LaplaceProblem&lt;dim&gt;::LaplaceProblem</a>()</div>
<div class="line">    : dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">    , max_degree(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &lt;= 2 ? 7 : 5)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">      {</div>
<div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
<div class="line">        quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">        face_quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::~LaplaceProblem</a>()</div>
<div class="line">  {</div>
<div class="line">    dof_handler.clear();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem&lt;dim&gt;::setup_system</a>()</div>
<div class="line">  {</div>
<div class="line">    dof_handler.distribute_dofs(fe_collection);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.n_dofs());</div>
<div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                             0,</div>
<div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                             <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem&lt;dim&gt;::assemble_system</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div>
<div class="line">                                   quadrature_collection,</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                     <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                     <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classRightHandSide.html">RightHandSide&lt;dim&gt;</a> rhs_function;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_fe().n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> = 0;</div>
<div class="line"> </div>
<div class="line">        cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">        hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;double&gt; rhs_values(fe_values.n_quadrature_points);</div>
<div class="line">        rhs_function.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(), rhs_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; fe_values.n_quadrature_points;</div>
<div class="line">             ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                  (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// grad phi_i(x_q)</span></div>
<div class="line">                   fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) * <span class="comment">// grad phi_j(x_q)</span></div>
<div class="line">                   fe_values.JxW(q_point));           <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">              cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                              rhs_values[q_point] *               <span class="comment">// f(x_q)</span></div>
<div class="line">                              fe_values.JxW(q_point));            <span class="comment">// dx</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>, cell_rhs, <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>, system_matrix, system_rhs);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div>
<div class="line">                                 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12 * system_rhs.l2_norm());</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">    <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(system_matrix, 1.2);</div>
<div class="line"> </div>
<div class="line">    cg.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::postprocess</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">      dof_handler,</div>
<div class="line">      face_quadrature_collection,</div>
<div class="line">      <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">      <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">      estimated_error_per_cell);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">    <a class="code" href="classFESeries_1_1Fourier.html">FESeries::Fourier&lt;dim&gt;</a> fourier =</div>
<div class="line">      <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#a748faa704c9dfb67a074d11316e777b4">SmoothnessEstimator::Fourier::default_fe_series</a>(fe_collection);</div>
<div class="line">    <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay</a>(fourier,</div>
<div class="line">                                                    dof_handler,</div>
<div class="line">                                                    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                                    smoothness_indicators);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">        fe_degrees(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) =</div>
<div class="line">          fe_collection[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_fe_index()].degree;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> std::string filename =</div>
<div class="line">        <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line">      std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">      data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.3,</div>
<div class="line">                                                      0.03);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">hp::Refinement::p_adaptivity_from_relative_threshold</a>(</div>
<div class="line">        dof_handler, smoothness_indicators, 0.2, 0.2);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">hp::Refinement::choose_p_over_h</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::create_coarse_grid</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> cube;</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(cube, 4, -1., 1.);</div>
<div class="line"> </div>
<div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt; cells_to_remove;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : cube.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a> = 0; <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell</a>; ++<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>).square() &lt; .1)</div>
<div class="line">          cells_to_remove.insert(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">GridGenerator::create_triangulation_with_removed_cells</a>(cube,</div>
<div class="line">                                                           cells_to_remove,</div>
<div class="line">                                                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(3);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; 6; ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">          create_coarse_grid();</div>
<div class="line"> </div>
<div class="line">        setup_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells      : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        assemble_system();</div>
<div class="line">        <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">        postprocess(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step27</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep27.html">Step27</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;2&gt;</a> laplace_problem;</div>
<div class="line">      laplace_problem.<a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 This tutorial depends on <a class="el" href="step_6.html">step-6</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Finiteelementcollections">Finite element collections</a><a href="#Finiteelementcollections">Finite element collections</a>
        <li><a href="#TheDoFHandlerclassinihpimodeassociatingcellswithfiniteelementsandconstraints">The DoFHandler class in <i>hp</i><a href="#TheDoFHandlerclassinihpimodeassociatingcellswithfiniteelementsandconstraints">The DoFHandler class in <i>hp</i>-mode, associating cells with finite elements, and constraints</a><i>hp</i>-mode, associating cells with finite elements, and constraints</a>
        <li><a href="#Assemblingmatricesandvectorswithhpobjects">Assembling matrices and vectors with hp-objects</a><a href="#Assemblingmatricesandvectorswithhpobjects">Assembling matrices and vectors with hp-objects</a>
        <li><a href="#Asimpleindicatorforhprefinementandestimatingsmoothness">A simple indicator for hp-refinement and estimating smoothness</a><a href="#Asimpleindicatorforhprefinementandestimatingsmoothness">A simple indicator for hp-refinement and estimating smoothness</a>
      <ul>
        <li><a href="#Theidea">The idea</a><a href="#Theidea">The idea</a>
        <li><a href="#Whatwehavetodo">What we have to do</a><a href="#Whatwehavetodo">What we have to do</a>
        <li><a href="#Compensatingforanisotropy">Compensating for anisotropy</a><a href="#Compensatingforanisotropy">Compensating for anisotropy</a>
        <li><a href="#Questionsaboutcellsizes">Questions about cell sizes</a><a href="#Questionsaboutcellsizes">Questions about cell sizes</a>
      </ul>
        <li><a href="#Complicationswithlinearsystemsforhpdiscretizations">Complications with linear systems for hp-discretizations</a><a href="#Complicationswithlinearsystemsforhpdiscretizations">Complications with linear systems for hp-discretizations</a>
      <ul>
        <li><a href="#Creatingthesparsitypattern">Creating the sparsity pattern</a><a href="#Creatingthesparsitypattern">Creating the sparsity pattern</a>
        <li><a href="#Eliminatingconstraineddegreesoffreedom">Eliminating constrained degrees of freedom</a><a href="#Eliminatingconstraineddegreesoffreedom">Eliminating constrained degrees of freedom</a>
      </ul>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Themainclass">The main class</a><a href="#Themainclass">The main class</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#Implementationofthemainclass">Implementation of the main class</a><a href="#Implementationofthemainclass">Implementation of the main class</a>
      <ul>
        <li><a href="#LaplaceProblemLaplaceProblemconstructor">LaplaceProblem::LaplaceProblem constructor</a><a href="#LaplaceProblemLaplaceProblemconstructor">LaplaceProblem::LaplaceProblem constructor</a>
        <li><a href="#LaplaceProblemLaplaceProblemdestructor">LaplaceProblem::~LaplaceProblem destructor</a><a href="#LaplaceProblemLaplaceProblemdestructor">LaplaceProblem::~LaplaceProblem destructor</a>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblempostprocess">LaplaceProblem::postprocess</a><a href="#LaplaceProblempostprocess">LaplaceProblem::postprocess</a>
        <li><a href="#LaplaceProblemcreate_coarse_grid">LaplaceProblem::create_coarse_grid</a><a href="#LaplaceProblemcreate_coarse_grid">LaplaceProblem::create_coarse_grid</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Differenthpdecisionstrategies">Different hp-decision strategies</a><a href="#Differenthpdecisionstrategies">Different hp-decision strategies</a>
        <li><a href="#Parallelhpadaptivefiniteelements">Parallel hp-adaptive finite elements</a><a href="#Parallelhpadaptivefiniteelements">Parallel hp-adaptive finite elements</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program attempts to show how to use \(hp\) -finite element methodswith deal.II. It solves the Laplace equation and so builds only on the firstfew tutorial programs, in particular on <a class="el" href="step_4.html">step-4</a> for dimensionindependent programming and <a class="el" href="step_6.html">step-6</a> for adaptive mesh refinement. The \(hp\) -finite element method was proposed in the early 1980s byBabu&scaron;ka and Guo as an alternative to either(i) mesh refinement (i.e., decreasing the mesh parameter \(h\) in a finiteelement computation) or (ii) increasing the polynomial degree \(p\) used forshape functions. It is based on the observation that increasing the polynomialdegree of the shape functions reduces the approximation error if the solutionis sufficiently smooth. On the other hand, it is well knownthat even for the generally well-behaved class of elliptic problems, higherdegrees of regularity can not be guaranteed in the vicinity of boundaries,corners, or where coefficients are discontinuous; consequently, theapproximation can not be improved in these areas by increasing the polynomialdegree \(p\) but only by refining the mesh, i.e., by reducing the mesh size \(h\) . These differing means to reduce theerror have led to the notion of \(hp\) -finite elements, where the approximatingfinite element spaces are adapted to have a high polynomial degree \(p\) wherever the solution is sufficiently smooth, while the mesh width \(h\) isreduced at places wherever the solution lacks regularity. It wasalready realized in the first papers on this method that \(hp\) -finite elementscan be a powerful tool that can guarantee that the error is reduced not onlywith some negative power of the number of degrees of freedom, but in factexponentially. In order to implement this method, we need several things above and beyondwhat a usual finite element program needs, and in particular above what wehave introduced in the tutorial programs leading up to <a class="el" href="step_6.html">step-6</a> . In particular,we will have to discuss the following aspects: </p><ul>
<li>
Instead of using the same finite element on all cells, we now will want a collection of finite element objects, and associate each cell with one of these objects in this collection.  <br  />
 </li>
<li>
Degrees of freedom will then have to be allocated on each cell depending on what finite element is associated with this particular cell. Constraints will have to be generated in the same way as for hanging nodes, but we now also have to deal with the case where two neighboring cells have different finite elements assigned.  <br  />
 </li>
<li>
We will need to be able to assemble cell and face contributions to global matrices and right hand side vectors.  <br  />
 </li>
<li>
After solving the resulting linear system, we will want to analyze the solution. In particular, we will want to compute error indicators that tell us whether a given cell should be refined and/or whether the polynomial degree of the shape functions used on it should be increased.  </li>
</ul>
<p><br  />
 We will discuss all these aspects in the following subsections of thisintroduction. It will not come as a big surprise that most of thesetasks are already well supported by functionality provided by thedeal.II, and that we will only have to provide the logic of what theprogram should do, not exactly how all this is going to happen. In deal.II, the \(hp\) -functionality is largely packaged intothe hp-namespace. This namespace provides classes that handle \(hp\) -discretizations, assembling matrices and vectors, and othertasks. We will get to know many of them further down below. Inaddition, most of the functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a>, and VectorToolsnamespaces accept \(hp\) -objects in addition to the non- \(hp\) -ones. Much ofthe \(hp\) -implementation is also discussed in the <a class="el" href="group__hp.html">hp-finite element support Classes and functions that have to</a> documentationmodule and the links found there. It may be worth giving a slightly larger perspective at the end ofthis first part of the introduction. \(hp\) -functionality has beenimplemented in a number of different finite element packages (see, forexample, the list of references cited in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>).However, by and large, most of these packages have implemented it onlyfor the (i) the 2d case, and/or (ii) the discontinuous Galerkinmethod. The latter is a significant simplification becausediscontinuous finite elements by definition do not require continuityacross faces between cells and therefore do not require the specialtreatment otherwise necessary whenever finite elements of differentpolynomial degree meet at a common face. In contrast, deal.IIimplements the most general case, i.e., it allows for continuous anddiscontinuous elements in 1d, 2d, and 3d, and automatically handlesthe resulting complexity. In particular, it handles computing theconstraints (similar to hanging node constraints) of elements ofdifferent degree meeting at a face or edge. The many algorithmic anddata structure techniques necessary for this are described in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a> for those interested in such detail. We hope that providing such a general implementation will help explorethe potential of \(hp\) -methods further.</p>
<p><a class="anchor" id="Finiteelementcollections"></a></p><h3>Finite element collections</h3>
<p>Now on again to the details of how to use the \(hp\) -functionality indeal.II. The first aspect we have to deal with is that now we do nothave only a single finite element any more that is used on all cells,but a number of different elements that cells can choose to use. Forthis, deal.II introduces the concept of a <em>finite element collection</em>, implemented in the class <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>. In essence,such a collection acts like an object of type <code>std::vector&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&gt;</code> , but with a few more bellsand whistles and a memory management better suited to the task athand. As we will later see, we will also use similar quadraturecollections, and &mdash; although we don't use them here &mdash; thereis also the concept of mapping collections. All of these classes aredescribed in the <a class="el" href="group__hpcollection.html">hp-Collections In the implementation of the</a> overview. In this tutorial program, we will use continuous Lagrange elements oforders 2 through 7 (in 2d) or 2 through 5 (in 3d). The collection ofused elements can then be created as follows: </p><div class="fragment"><div class="line"><a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
</div><!-- fragment --><p><a class="anchor" id="TheDoFHandlerclassinihpimodeassociatingcellswithfiniteelementsandconstraints"></a></p><h3>The <a class="el" href="classDoFHandler.html">DoFHandler</a> class in <em>hp</em><em>hp</em>-mode, associating cells with finite elements, and constraints</h3>
<p>The next task we have to consider is what to do with the list offinite element objects we want to use. In previous tutorial programs,starting with <a class="el" href="step_2.html">step-2</a> , we have seen that the DoFHandlerclass is responsible for making the connection between a mesh(described by a Triangulation object) and a finite element, byallocating the correct number of degrees of freedom for each vertex,face, edge, and cell of the mesh. The situation here is a bit more complicated since we do not just havea single finite element object, but rather may want to use differentelements on different cells. We therefore need two things: (i) aversion of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class that can deal with this situation, <a class="el" href="sparsity__0_8txt.html#aac1152d82b1ea3099c73daed328c6611">and(ii)</a> a way to tell the <a class="el" href="classDoFHandler.html">DoFHandler</a> which element to use on which cell. The first of these two things is implemented in the <em>hp</em>-mode ofthe <a class="el" href="classDoFHandler.html">DoFHandler</a> class: rather than associating it with a triangulationand a single finite element object, it is associated with a triangulationand a finite element collection. The second part is achieved by a loopover all cells of this <a class="el" href="classDoFHandler.html">DoFHandler</a> and for each cell setting the indexof the finite element within the collection that shall be used on thiscell. We call the index of the finite element object within thecollection that shall be used on a cell the cell's <em>active FE index</em> to indicate that this is the finite element that is activeon this cell, whereas all the other elements of the collection areinactive on it. The general outline of this reads like this: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>: dof_handler.active_cell_iterators())</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;set_active_fe_index(...);</div>
<div class="line">dof_handler.distribute_dofs(fe_collection);</div>
</div><!-- fragment --><p>Dots in the call to <code>set_active_fe_index()</code> indicate thatwe will have to have some sort of strategy later on to decide whichelement to use on which cell; we will come back to this later. Themain point here is that the first and last line of this code snippetis pretty much exactly the same as for the non- \(hp\) -case. Another complication arises from the fact that this time we do notsimply have hanging nodes from local mesh refinement, but we also haveto deal with the case that if there are two cells with differentactive finite element indices meeting at a face (for example a Q2 anda Q3 element) then we have to compute additional constraints on thefinite element field to ensure that it is continuous. This isconceptually very similar to how we compute hanging node constraints,and in fact the code looks exactly the same: </p><div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"><a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
</div><!-- fragment --><p> In other words, the <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> deals notonly with hanging node constraints, but also with \(hp\) -constraints atthe same time.</p>
<p><a class="anchor" id="Assemblingmatricesandvectorswithhpobjects"></a></p><h3>Assembling matrices and vectors with hp-objects</h3>
<p>Following this, we have to set up matrices and vectors for the linear systemof the correct size and assemble them. Setting them up works in exactly thesame way as for the non- \(hp\) -case. Assembling requires a bit more thought. The main idea is of course unchanged: we have to loop over all cells, assemblelocal contributions, and then copy them into the global objects. As discussedin some detail first in <a class="el" href="step_3.html">step-3</a> , deal.II has the <a class="el" href="classFEValues.html">FEValues</a> class that pullsthe finite element description, mapping, and quadrature formulatogether and aids in evaluating values and gradients of shape functions aswell as other information on each of the quadrature points mapped to the reallocation of a cell. Every time we move on to a new cell we re-initialize thisFEValues object, thereby asking it to re-compute that part of the informationthat changes from cell to cell. It can then be used to sum up localcontributions to bilinear form and right hand side. In the context of \(hp\) -finite element methods, we have to deal with the factthat we do not use the same finite element object on each cell. In fact, weshould not even use the same quadrature object for all cells, but ratherhigher order quadrature formulas for cells where we use higher order finiteelements. Similarly, we may want to use higher order mappings on such cells aswell. To facilitate these considerations, deal.II has a class <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> that doeswhat we need in the current context. The difference is that instead of asingle finite element, quadrature formula, and mapping, it takes collectionsof these objects. It's use is very much like the regular <a class="el" href="classFEValues.html">FEValues</a> class,i.e., the interesting part of the loop over all cells would look like this: </p><div class="fragment"><div class="line"><a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(mapping_collection,</div>
<div class="line">                               fe_collection,</div>
<div class="line">                               quadrature_collection,</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">  {</div>
<div class="line">    hp_fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">    ...  <span class="comment">// assemble local contributions and copy them into global object</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p>In this tutorial program, we will always use a Q1 mapping, so the mappingcollection argument to the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> construction will be omitted. Insidethe loop, we first initialize the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the currentcell. The second, third and fourth arguments denote the index within theirrespective collections of the quadrature, mapping, and finite element objectswe wish to use on this cell. These arguments can be omitted (and are in theprogram below), in which case <code>cell-&gt;active_fe_index()</code> is usedfor this index. The order of these arguments is chosen in this way because onemay sometimes want to pick a different quadrature or mapping object from theirrespective collections, but hardly ever a different finite element than theone in use on this cell, i.e., one with an index different from <code>cell-&gt;active_fe_index()</code> . The finite element collection index istherefore the last default argument so that it can be conveniently omitted. What this <code>reinit</code> call does is the following: the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class checks whether it has previously already allocated anon- \(hp\) -<a class="el" href="classFEValues.html">FEValues</a> object for this combination of finite element, quadrature,and mapping objects. If not, it allocates one. It then re-initializes thisobject for the current cell, after which there is now a <a class="el" href="classFEValues.html">FEValues</a> object forthe selected finite element, quadrature and mapping usable on the currentcell. A reference to this object is then obtained using the call <code>hp_fe_values.get_present_fe_values()</code> , and will be used in theusual fashion to assemble local contributions.</p>
<p><a class="anchor" id="Asimpleindicatorforhprefinementandestimatingsmoothness"></a></p><h3>A simple indicator for hp-refinement and estimating smoothness</h3>
<p>One of the central pieces of the adaptive finite element method is that weinspect the computed solution (a posteriori) with an indicator that tells uswhich are the cells where the error is largest, and then refine them. In manyof the other tutorial programs, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class to get anindication of the size of the error on a cell, although we also discuss morecomplicated strategies in some programs, most importantly in <a class="el" href="step_14.html">step-14</a> . In any case, as long as the decision is only "refine this cell" or "do notrefine this cell", the actual refinement step is not particularlychallenging. However, here we have a code that is capable of hp-refinement,i.e., we suddenly have two choices whenever we detect that the error on acertain cell is too large for our liking: we can refine the cell by splittingit into several smaller ones, or we can increase the polynomial degree of theshape functions used on it. How do we know which is the more promisingstrategy? Answering this question is the central problem in \(hp\) -finiteelement research at the time of this writing. In short, the question does not appear to be settled in the literature at thistime. There are a number of more or less complicated schemes that address it,but there is nothing like the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> that is universally acceptedas a good, even if not optimal, indicator of the error. Most proposals use thefact that it is beneficial to increase the polynomial degree whenever thesolution is locally smooth whereas it is better to refine the mesh wherever itis rough. However, the questions of how to determine the local smoothness ofthe solution as well as the decision when a solution is smooth enough to allowfor an increase in \(p\) are certainly big and important ones. In the following, we propose a simple estimator of the local smoothness of asolution. As we will see in the results section, this estimator has flaws, inparticular as far as cells with local hanging nodes are concerned. Wetherefore do not intend to present the following ideas as a complete solutionto the problem. Rather, it is intended as an idea to approach it that meritsfurther research and investigation. In other words, we do not intend to entera sophisticated proposal into the fray about answers to the generalquestion. However, to demonstrate our approach to \(hp\) -finite elements, weneed a simple indicator that does generate some useful information that isable to drive the simple calculations this tutorial program will perform.</p>
<p><a class="anchor" id="Theidea"></a></p><h4>The idea</h4>
<p>Our approach here is simple: for a function \(u({\bf x})\) to be in theSobolev space \(H^s(K)\) on a cell \(K\) , it has to satisfy the condition </p><p class="formulaDsp">
\[ \int_K |\nabla^s u({\bf x})|^2 \; d{\bf x} &lt; \infty. \]
</p>
<p>@_fakenlAssuming that the cell \(K\) is not degenerate, i.e., that the mapping from theunit cell to cell \(K\) is sufficiently regular, above condition is of courseequivalent to </p><p class="formulaDsp">
\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} &lt; \infty\,, \]
</p>
<p>@_fakenlwhere \(\hat u(\hat{\bf x})\) is the function \(u({\bf x})\) mapped back onto the unit cell \(\hat K\) . From here, we can do the following: first, let us define theFourier series of \(\hat u\) as </p><p class="formulaDsp">
\[ \hat u(\hat{\bf x}) = \sum_{\bf k} \hat U_{\bf k}\,e^{-i {\bf k}\cdot \hat{\bf x}}, \]
</p>
<p>@_fakenlwith Fourier vectors \({\bf k}=(k_x,k_y)\) in 2d, \({\bf k}=(k_x,k_y,k_z)\) in 3d, etc, and \(k_x,k_y,k_z=0,2\pi,4\pi,\ldots\) . The coefficients of expansion \(\hat U_{\bf k}\) can be obtained using \(L^2\) -orthogonality of the exponential basis </p><p class="formulaDsp">
\[ \int_{\hat K} e^{-i {\bf m}\cdot \hat{\bf x}} e^{i {\bf n}\cdot \hat{\bf x}} d\hat{\bf x} = \delta_{\bf m \bf n}, \]
</p>
<p>@_fakenlthat leads to the following expression </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \,. \]
</p>
<p>@_fakenlIt becomes clear that we can then write the \(H^s\) norm of \(\hat u\) as </p><p class="formulaDsp">
\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} = \int_{\hat K} \left| \sum_{\bf k} |{\bf k}|^s e^{-i{\bf k}\cdot \hat{\bf x}} \hat U_{\bf k} \right|^2 \; d\hat{\bf x} = \sum_{\bf k} |{\bf k}|^{2s} |\hat U_{\bf k}|^2. \]
</p>
<p>@_fakenlIn other words, if this norm is to be finite (i.e., for \(\hat u(\hat{\bf x})\) to be in \(H^s(\hat K)\) ), we need that </p><p class="formulaDsp">
\[ |\hat U_{\bf k}| = {\cal O}\left(|{\bf k}|^{-\left(s+1/2+\frac{d-1}{2}+\epsilon\right)}\right). \]
</p>
<p>@_fakenlPut differently: the higher regularity \(s\) we want, the faster theFourier coefficients have to go to zero. If you wonder where theadditional exponent \(\frac{d-1}2\) comes from: we would like to makeuse of the fact that \(\sum_l a_l &lt; \infty\) if the sequence \(a_l = {\cal O}(l^{-1-\epsilon})\) for any \(\epsilon&gt;0\) . The problem is that wehere have a summation not only over a single variable, but over allthe integer multiples of \(2\pi\) that are located inside the \(d\) -dimensional sphere, because we have vector components \(k_x, k_y, \ldots\) . In the same way as we prove that the sequence \(a_l\) aboveconverges by replacing the sum by an integral over the entire line, wecan replace our \(d\) -dimensional sum by an integral over \(d\) -dimensional space. Now we have to note that between distance \(|{\bf k}|\) and \(|{\bf k}|+d|{\bf k}|\) , there are, up to a constant, \(|{\bf k}|^{d-1}\) modes, inmuch the same way as we can transform the volume element \(dx\;dy\) into \(2\pi r\; dr\) . Consequently, it is no longer \(|{\bf k}|^{2s}|\hat U_{\bf k}|^2\) that has to decay as \({\cal O}(|{\bf k}|^{-1-\epsilon})\) , butit is in fact \(|{\bf k}|^{2s}|\hat U_{\bf k}|^2 |{\bf k}|^{d-1}\) . Acomparison of exponents yields the result. We can turn this around: Assume we are given a function \(\hat u\) of unknownsmoothness. Let us compute its Fourier coefficients \(\hat U_{\bf k}\) and see how fast they decay. If they decay as </p><p class="formulaDsp">
\[ |\hat U_{\bf k}| = {\cal O}(|{\bf k}|^{-\mu-\epsilon}), \]
</p>
<p>@_fakenlthen consequently the function we had here was in \(H^{\mu-d/2}\) .</p>
<p><a class="anchor" id="Whatwehavetodo"></a></p><h4>What we have to do</h4>
<p>So what do we have to do to estimate the local smoothness of \(u({\bf x})\) ona cell \(K\) ? Clearly, the first step is to compute the Fourier coefficientsof our solution. Fourier series being infinite series, we simplify ourtask by only computing the first few terms of the series, such that \(|{\bf k}|\le 2\pi N\) with a cut-off \(N\) . Let us parenthetically remarkthat we want to choose \(N\) large enough so that we capture at leastthe variation of those shape functions that vary the most. On theother hand, we should not choose \(N\) too large: clearly, a finiteelement function, being a polynomial, is in \(C^\infty\) on any givencell, so the coefficients will have to decay exponentially at onepoint; since we want to estimate the smoothness of the function thispolynomial approximates, not of the polynomial itself, we need tochoose a reasonable cutoff for \(N\) . Either way, computing this seriesis not particularly hard: from the definition </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \]
</p>
<p>@_fakenlwe see that we can compute the coefficient \(\hat U_{\bf k}\) as </p><p class="formulaDsp">
\[ \hat U_{\bf k} = \sum_{i=0}^{\textrm{dofs per cell}} \left[\int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_i(\hat{\bf x}) d\hat{\bf x} \right] u_i, \]
</p>
<p>@_fakenlwhere \(u_i\) is the value of the \(i\) th degree of freedom on thiscell. In other words, we can write it as a matrix-vector product </p><p class="formulaDsp">
\[ \hat U_{\bf k} = {\cal F}_{{\bf k},j} u_j, \]
</p>
<p>@_fakenlwith the matrix </p><p class="formulaDsp">
\[ {\cal F}_{{\bf k},j} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_j(\hat{\bf x}) d\hat{\bf x}. \]
</p>
<p>@_fakenlThis matrix is easily computed for a given number of shape functions \(\varphi_j\) and Fourier modes \(N\) . Consequently, finding thecoefficients \(\hat U_{\bf k}\) is a rather trivial job.To simplify our life even further, we will use <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> class whichdoes exactly this. The next task is that we have to estimate how fast these coefficientsdecay with \(|{\bf k}|\) . The problem is that, of course, we have onlyfinitely many of these coefficients in the first place. In otherwords, the best we can do is to fit a function \(\alpha |{\bf k}|^{-\mu}\) to our data points \(\hat U_{\bf k}\) , for example bydetermining \(\alpha,\mu\) via a least-squares procedure: </p><p class="formulaDsp">
\[ \min_{\alpha,\mu} \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( |\hat U_{\bf k}| - \alpha |{\bf k}|^{-\mu}\right)^2 \]
</p>
<p>@_fakenlHowever, the problem with this is that it leads to a nonlinearproblem, a fact that we would like to avoid. On the other hand, we cantransform the problem into a simpler one if we try to fit thelogarithm of our coefficients to the logarithm of \(\alpha |{\bf k}|^{-\mu}\) ,like this: </p><p class="formulaDsp">
\[ \min_{\alpha,\mu} Q(\alpha,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \ln (\alpha |{\bf k}|^{-\mu})\right)^2. \]
</p>
<p>@_fakenlUsing the usual facts about logarithms, we see that this yields theproblem </p><p class="formulaDsp">
\[ \min_{\beta,\mu} Q(\beta,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \beta + \mu \ln |{\bf k}|\right)^2, \]
</p>
<p>@_fakenlwhere \(\beta=\ln \alpha\) . This is now a problem for which theoptimality conditions \(\frac{\partial Q}{\partial\beta}=0, \frac{\partial Q}{\partial\mu}=0\) , are linear in \(\beta,\mu\) . We canwrite these conditions as follows: </p><p class="formulaDsp">
\[ \left(\begin{array}{cc} \sum_{{\bf k}, |{\bf k}|\le N} 1 &amp; \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| &amp; \sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2 \end{array}\right) \left(\begin{array}{c} \beta \\ -\mu \end{array}\right) = \left(\begin{array}{c} \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \end{array}\right) \]
</p>
<p>@_fakenlThis linear system is readily inverted to yield </p><p class="formulaDsp">
\[ \beta = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 } \]
</p>
<p>@_fakenland </p><p class="formulaDsp">
\[ \mu = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 }. \]
</p>
<p> This is nothing else but linear regression fit and to do that we will use <a class="el" href="namespaceFESeries.html#afa42058db3555536415fae91822d27e3">FESeries::linear_regression()</a>. While we are not particularly interested in the actual value of \(\beta\) , the formula above gives us a mean to calculate the value ofthe exponent \(\mu\) that we can then use to determine that \(\hat u(\hat{\bf x})\) is in \(H^s(\hat K)\) with \(s=\mu-\frac d2\) . These steps outlined above are applicable to many different scenarios, whichmotivated the introduction of a generic function <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay()</a> in deal.II, that combines allthe tasks described in this section in one simple function call. We will use itin the implementation of this program.</p>
<p><a class="anchor" id="Compensatingforanisotropy"></a></p><h4>Compensating for anisotropy</h4>
<p>In the formulas above, we have derived the Fourier coefficients \(\hat U_{\bf k}\) . Because \({\bf k}\) is a vector, we will get a number of Fouriercoefficients \(\hat U_{{\bf k}}\) for the same absolute value \(|{\bf k}|\) ,corresponding to the Fourier transform in different directions. If we nowconsider a function like \(|x|y^2\) then we will find lots of large Fouriercoefficients in \(x\) -direction because the function is non-smooth in thisdirection, but fast-decaying Fourier coefficients in \(y\) -direction because thefunction is smooth there. The question that arises is this: if we simply fitour polynomial decay \(\alpha |{\bf k}|^\mu\) to <em>all</em> Fourier coefficients,we will fit it to a smoothness <em>averaged in all spatial directions</em>. Isthis what we want? Or would it be better to only consider the largestcoefficient \(\hat U_{{\bf k}}\) for all \({\bf k}\) with the same magnitude,essentially trying to determine the smoothness of the solution in that spatialdirection in which the solution appears to be roughest? One can probably argue for either case. The issue would be of more interest ifdeal.II had the ability to use anisotropic finite elements, i.e., ones that usedifferent polynomial degrees in different spatial directions, as they would beable to exploit the directionally variable smoothness much better. Alas, thiscapability does not exist at the time of writing this tutorial program. Either way, because we only have isotopic finite element classes, we adopt theviewpoint that we should tailor the polynomial degree to the lowest amount ofregularity, in order to keep numerical efforts low. Consequently, instead ofusing the formula </p><p class="formulaDsp">
\[ \mu = \frac { \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) } { \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2 }. \]
</p>
<p>@_fakenlTo calculate \(\mu\) as shown above, we have to slightly modify all sums:instead of summing over all Fourier modes, we only sum over those for whichthe Fourier coefficient is the largest one among all \(\hat U_{{\bf k}}\) withthe same magnitude \(|{\bf k}|\) , i.e., all sums above have to replaced by thefollowing sums: </p><p class="formulaDsp">
\[ \sum_{{\bf k}, |{\bf k}|\le N} \longrightarrow \sum_{\begin{matrix}{{\bf k}, |{\bf k}|\le N} \\ {|\hat U_{{\bf k}}| \ge |\hat U_{{\bf k}&#39;}| \ \textrm{for all}\ {\bf k}&#39;\ \textrm{with}\ |{\bf k}&#39;|=|{\bf k}|}\end{matrix}}. \]
</p>
<p>@_fakenlThis is the form we will implement in the program.</p>
<p><a class="anchor" id="Questionsaboutcellsizes"></a></p><h4>Questions about cell sizes</h4>
<p>One may ask whether it is a problem that we only compute the Fourier transformon the <em>reference cell</em> (rather than the real cell) of thesolution. After all, we stretch the solution by a factor \(\frac 1h\) during thetransformation, thereby shifting the Fourier frequencies by a factor of \(h\) . This is of particular concern since we may have neighboring cells withmesh sizes \(h\) that differ by a factor of 2 if one of them is more refinedthan the other. The concern is also motivated by the fact that, as we will seein the results section below, the estimated smoothness of the solution shouldbe a more or less continuous function, but exhibits jumps at locations wherethe mesh size jumps. It therefore seems natural to ask whether we have tocompensate for the transformation. The short answer is "no". In the process outlined above, we attempt to findcoefficients \(\beta,\mu\) that minimize the sum of squares of the terms </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln |{\bf k}|. \]
</p>
<p>@_fakenlTo compensate for the transformation means not attempting to fit a decay \(|{\bf k}|^\mu\) with respect to the Fourier frequencies \({\bf k}\) <em>on the unit cell</em>, but to fit the coefficients \(\hat U_{{\bf k}}\) computed on thereference cell <em>to the Fourier frequencies on the real cell \(|\bf k|h\)</em>, where \(h\) is the norm of the transformation operator (i.e., somethinglike the diameter of the cell). In other words, we would have to minimize thesum of squares of the terms </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln (|{\bf k}|h). \]
</p>
<p>@_fakenlinstead. However, using fundamental properties of the logarithm, this issimply equivalent to minimizing </p><p class="formulaDsp">
\[ \ln |\hat U_{{\bf k}}| - (\beta - \mu \ln h) + \mu \ln (|{\bf k}|). \]
</p>
<p>@_fakenlIn other words, this and the original least squares problem will produce thesame best-fit exponent \(\mu\) , though the offset will in one case be \(\beta\) and in the other \(\beta-\mu \ln h\) . However, since we are not interested inthe offset at all but only in the exponent, it doesn't matter whether we scaleFourier frequencies in order to account for mesh size effects or not, theestimated smoothness exponent will be the same in either case.</p>
<p><a class="anchor" id="Complicationswithlinearsystemsforhpdiscretizations"></a></p><h3>Complications with linear systems for hp-discretizations</h3>
<p><a class="anchor" id="Creatingthesparsitypattern"></a></p><h4>Creating the sparsity pattern</h4>
<p>One of the problems with \(hp\) -methods is that the high polynomial degree ofshape functions together with the large number of constrained degrees offreedom leads to matrices with large numbers of nonzero entries in somerows. At the same time, because there are areas where we use low polynomialdegree and consequently matrix rows with relatively few nonzeroentries. Consequently, allocating the sparsity pattern for these matrices is achallenge: we cannot simply assemble a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> by starting with anestimate of the bandwidth without using a lot of extra memory. The way in which we create a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> for the underlying linear system istightly coupled to the strategy we use to enforce constraints. deal.II supportshandling constraints in linear systems in two ways: </p><ol>
<li>
Assembling the matrix without regard to the constraints and applying them afterwards with <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a>, or  </li>
<li>
Applying constraints as we assemble the system with <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. </li>
</ol>
<p>Most programs built on deal.II use the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> functionto allocate a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that takes constraints into account. Thesystem matrix then uses a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> copied over from theDynamicSparsityPattern. This method is explained in <a class="el" href="step_2.html">step-2</a> and used in mosttutorial programs. The early tutorial programs use first or second degree finite elements, soremoving entries in the sparsity pattern corresponding to constrained degrees offreedom does not have a large impact on the overall number of zeros explicitlystored by the matrix. However, since as many as a third of the degrees offreedom may be constrained in an hp-discretization (and, with higher degreeelements, these constraints can couple one DoF to as many as ten or twenty otherDoFs), it is worthwhile to take these constraints into consideration since theresulting matrix will be much sparser (and, therefore, matrix-vector products orfactorizations will be substantially faster too).</p>
<p><a class="anchor" id="Eliminatingconstraineddegreesoffreedom"></a></p><h4>Eliminating constrained degrees of freedom</h4>
<p>A second problem particular to \(hp\) -methods arises because we have somany constrained degrees of freedom: typically up to about one thirdof all degrees of freedom (in 3d) are constrained because they eitherbelong to cells with hanging nodes or because they are on cellsadjacent to cells with a higher or lower polynomial degree. This is,in fact, not much more than the fraction of constrained degrees offreedom in non- \(hp\) -mode, but the difference is that each constrainedhanging node is constrained not only against the two adjacent degreesof freedom, but is constrained against many more degrees of freedom. It turns out that the strategy presented first in <a class="el" href="step_6.html">step-6</a> to eliminate theconstraints while computing the element matrices and vectors with <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a> is the most efficient approachalso for this case. The alternative strategy to first build the matrix withoutconstraints and then "condensing" away constrained degrees of freedom isconsiderably more expensive. It turns out that building the sparsity patternby this inefficient algorithm requires at least \({\cal O}(N \log N)\) in thenumber of unknowns, whereas an ideal finite element program would of courseonly have algorithms that are linear in the number of unknowns. Timing thesparsity pattern creation as well as the matrix assembly shows that thealgorithm presented in <a class="el" href="step_6.html">step-6</a> (and used in the code below) is indeed faster. In our program, we will also treat the boundary conditions as (possiblyinhomogeneous) constraints and eliminate the matrix rows and columns tothose as well. All we have to do for this is to call the function thatinterpolates the Dirichlet boundary conditions already in the setup phase inorder to tell the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object about them, and then do thetransfer from local to global data on matrix and vector simultaneously. Thisis exactly what we've shown in <a class="el" href="step_6.html">step-6</a> .</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>The test case we will solve with this program is a re-take of the one wealready look at in <a class="el" href="step_14.html">step-14</a> : we solve the Laplace equation </p><p class="formulaDsp">
\[ -\Delta u = f \]
</p>
<p>@_fakenlin 2d, with \(f=(x+1)(y+1)\) , and with zero Dirichlet boundary values for \(u\) . We do so on the domain \([-1,1]^2\backslash[-\frac 12,\frac 12]^2\) ,i.e., a square with a square hole in the middle. The difference to <a class="el" href="step_14.html">step-14</a> is of course that we use \(hp\) -finiteelements for the solution. The test case is of interest because it hasre-entrant corners in the corners of the hole, at which the solution hassingularities. We therefore expect that the solution will be smooth in theinterior of the domain, and rough in the vicinity of the singularities. Thehope is that our refinement and smoothness indicators will be able to see thisbehavior and refine the mesh close to the singularities, while the polynomialdegree is increased away from it. As we will see in the results section, thisis indeed the case.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few files have already been covered in previous examples and will thus not be further commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
</div><!-- fragment --><p>These are the new files we need. The first and second provide the FECollection and the <em>hp</em> version of the <a class="el" href="classFEValues.html">FEValues</a> class as described in the introduction of this program. The next one provides the functionality for automatic \(hp\) -adaptation, for which we will use the estimation algorithms based on decaying series expansion coefficients that are part of the last two files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2refinement_8h.html">deal.II/hp/refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__series_8h.html">deal.II/fe/fe_series.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2smoothness__estimator_8h.html">deal.II/numerics/smoothness_estimator.h</a>&gt;</span></div>
</div><!-- fragment --><p>The last set of include files are standard C++ headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Finally, this is as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep27.html">Step27</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="Themainclass"></a> </p><h3>The main class</h3>
<p>The main class of this program looks very much like the one already used in the first few tutorial programs, for example the one in <a class="el" href="step_6.html">step-6</a> . The main difference is that we have merged the refine_grid and output_results functions into one since we will also want to output some of the quantities used in deciding how to refine the mesh (in particular the estimated smoothness of the solution). <br  />
 As far as member variables are concerned, we use the same structure as already used in <a class="el" href="step_6.html">step-6</a> , but we need collections instead of individual finite element, quadrature, and face quadrature objects. We will fill these collections in the constructor of the class. The last variable, <code>max_degree</code> , indicates the maximal polynomial degree of shape functions used.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keyword">class </span><a class="code" href="classLaplaceProblem.html">LaplaceProblem</a></div>
<div class="line">   {</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">     <a class="code" href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem</a>();</div>
<div class="line">     ~<a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line">  </div>
<div class="line">     <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line">  </div>
<div class="line">   <span class="keyword">private</span>:</div>
<div class="line">     <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">setup_system</a>();</div>
<div class="line">     <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">assemble_system</a>();</div>
<div class="line">     <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">solve</a>();</div>
<div class="line">     <span class="keywordtype">void</span> create_coarse_grid();</div>
<div class="line">     <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="classLaplaceProblem.html#a1f9c6147583b774bd1620d534c32dee5">triangulation</a>;</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>          <a class="code" href="classLaplaceProblem.html#a2713d4075ba7824063d84a8c9f9d2967">dof_handler</a>;</div>
<div class="line">     <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div>
<div class="line">     <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div>
<div class="line">     <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div>
<div class="line">  </div>
<div class="line">- 1&gt; face_quadrature_collection;</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#a40d0609a27a24ce310ae30cfccdf7f04">constraints</a>;</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">     <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#addbdc7360d9feca8f8676eb6f381b6db">system_matrix</a>;</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="classLaplaceProblem.html#a5c6d887dea84186bb992ec9fec99f744">solution</a>;</div>
<div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div>
<div class="line">   };</div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p><br  />
 Next, let us define the right hand side function for this problem. It is \(x+1\) in 1d, \((x+1)(y+1)\) in 2d, and so on.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classRightHandSide.html#a07b87d7025c7c5feca044c5c7d4296ef">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classRightHandSide.html#a07b87d7025c7c5feca044c5c7d4296ef">RightHandSide&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">    <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a>= (<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] + 1);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Implementationofthemainclass"></a> </p><h3>Implementation of the main class</h3>
<pre class="fragment">&lt;a name="LaplaceProblemLaplaceProblemconstructor"&gt;&lt;/a&gt;  &lt;h4&gt;LaplaceProblem::LaplaceProblem constructor&lt;/h4&gt;
</pre><p>The constructor of this class is fairly straightforward. It associates the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with the triangulation, and then sets the maximal polynomial degree to 7 (in 1d and 2d) or 5 (in 3d and higher). We do so because using higher order polynomial degrees becomes prohibitively expensive, especially in higher space dimensions. <br  />
 Following this, we fill the collections of finite element, and cell and face quadrature objects. We start with quadratic elements, and each quadrature formula is chosen so that it is appropriate for the matching finite element in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <a class="code" href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem&lt;dim&gt;::LaplaceProblem</a>()</div>
<div class="line">     : dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">     , max_degree(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &lt;= 2 ? 7 : 5)</div>
<div class="line">   {</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">       {</div>
<div class="line">         fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
<div class="line">         quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">         face_quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div>
<div class="line">  </div>
<div class="line">- 1&gt;(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">       }</div>
<div class="line">   }</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemLaplaceProblemdestructor"></a> </p><h4>LaplaceProblem::~LaplaceProblem destructor</h4>
<p>The destructor is unchanged from what we already did in <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::~LaplaceProblem</a>()</div>
<div class="line">{</div>
<div class="line">  dof_handler.clear();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4><a class="el" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem::setup_system</a></h4>
<p><br  />
 This function is again a verbatim copy of what we already did in <a class="el" href="step_6.html">step-6</a> . Despite function calls with exactly the same names and arguments, the algorithms used internally are different in some aspect since the dof_handler variable here is in \(hp\) -mode.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem&lt;dim&gt;::setup_system</a>()</div>
<div class="line">{</div>
<div class="line">  dof_handler.distribute_dofs(fe_collection);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.n_dofs());</div>
<div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div>
<div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                           0,</div>
<div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                           <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">  system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4><a class="el" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem::assemble_system</a></h4>
<p>This is the function that assembles the global matrix and right hand side vector from the local contributions of each cell. Its main working is as has been described in many of the tutorial programs before. The significant deviations are the ones necessary for <em>hp</em> finite element methods. In particular, that we need to use a collection of <a class="el" href="classFEValues.html">FEValues</a> object (implemented through the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class), and that we have to eliminate constrained degrees of freedom already when copying local contributions into global objects. Both of these are explained in detail in the introduction of this program. <br  />
 One other slight complication is the fact that because we use different polynomial degrees on different cells, the matrices and vectors holding local contributions do not have the same size on all cells. At the beginning of the loop over all cells, we therefore each time have to resize them to the correct size (given by <code>dofs_per_cell</code> ). Because these classes are implemented in such a way that reducing the size of a matrix or vector does not release the currently allocated memory (unless the new size is zero), the process of resizing at the beginning of the loop will only require re-allocation of memory during the first few iterations. Once we have found in a cell with the maximal finite element degree, no more re-allocations will happen because all subsequent <code>reinit</code> calls will only set the size to something that fits the currently allocated memory. This is important since allocating memory is expensive, and doing so every time we visit a new cell would take significant compute time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem&lt;dim&gt;::assemble_system</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div>
<div class="line">                                 quadrature_collection,</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classRightHandSide.html">RightHandSide&lt;dim&gt;</a> rhs_function;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_fe().n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> = 0;</div>
<div class="line"> </div>
<div class="line">      cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">      hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;double&gt; rhs_values(fe_values.n_quadrature_points);</div>
<div class="line">      rhs_function.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(), rhs_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; fe_values.n_quadrature_points;</div>
<div class="line">           ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">              <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) <span class="comment">// grad phi_i(x_q)</span></div>
<div class="line">                 fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) <span class="comment">// grad phi_j(x_q)</span></div>
<div class="line">                 fe_values.JxW(q_point));           <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">            cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                            rhs_values[q_point]               <span class="comment">// f(x_q)</span></div>
<div class="line">                            fe_values.JxW(q_point));            <span class="comment">// dx</span></div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>, cell_rhs, <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>, system_matrix, system_rhs);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4><a class="el" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem::solve</a></h4>
<p>The function solving the linear system is entirely unchanged from previous examples. We simply try to reduce the initial residual (which equals the \(l_2\) norm of the right hand side) by a certain factor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div>
<div class="line">                               1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12 system_rhs.l2_norm());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">  <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(system_matrix, 1.2);</div>
<div class="line"> </div>
<div class="line">  cg.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblempostprocess"></a> </p><h4>LaplaceProblem::postprocess</h4>
<p>After solving the linear system, we will want to postprocess the solution. Here, all we do is to estimate the error, estimate the local smoothness of the solution as described in the introduction, then write graphical output, and finally refine the mesh in both \(h\) and \(p\) according to the indicators computed before. We do all this in the same function because we want the estimated error and smoothness indicators not only for refinement, but also include them in the graphical output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::postprocess</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">{</div>
</div><!-- fragment --><p>Let us start with computing estimated error and smoothness indicators, which each are one number for each active cell of our triangulation. For the error indicator, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class as always.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">  dof_handler,</div>
<div class="line">  face_quadrature_collection,</div>
<div class="line">  <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">  estimated_error_per_cell);</div>
</div><!-- fragment --><p>Estimating the smoothness is performed with the method of decaying expansion coefficients as outlined in the introduction. We will first need to create an object capable of transforming the finite element solution on every single cell into a sequence of Fourier series coefficients. The <a class="el" href="namespaceSmoothnessEstimator.html">SmoothnessEstimator</a> namespace offers a factory function for such a <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> object that is optimized for the process of estimating smoothness. The actual determination of the decay of Fourier coefficients on every individual cell then happens in the last function.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classFESeries_1_1Fourier.html">FESeries::Fourier&lt;dim&gt;</a> fourier =</div>
<div class="line">  <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#a748faa704c9dfb67a074d11316e777b4">SmoothnessEstimator::Fourier::default_fe_series</a>(fe_collection);</div>
<div class="line"><a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay</a>(fourier,</div>
<div class="line">                                                dof_handler,</div>
<div class="line">                                                <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                                smoothness_indicators);</div>
</div><!-- fragment --><p>Next we want to generate graphical output. In addition to the two estimated quantities derived above, we would also like to output the polynomial degree of the finite elements used on each of the elements on the mesh. <br  />
 The way to do that requires that we loop over all cells and poll the active finite element index of them using <code>cell-&gt;active_fe_index()</code> . We then use the result of this operation and query the finite element collection for the finite element with that index, and finally determine the polynomial degree of that element. The result we put into a vector with one element per cell. The <a class="el" href="classDataOut.html">DataOut</a> class requires this to be a vector of <code>float</code> or <code>double</code> , even though our values are all integers, so that is what we use:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    fe_degrees(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) =</div>
<div class="line">      fe_collection[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_fe_index()].degree;</div>
</div><!-- fragment --><p>With now all data vectors available</p>
<ul>
<li>solution, estimated errors and smoothness indicators, and finite element degrees</li>
<li>, we create a <a class="el" href="classDataOut.html">DataOut</a> object for graphical output and attach all data:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
</div><!-- fragment --><p>The final step in generating output is to determine a file name, open the file, and write the data into it (here, we use VTK format):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After this, we would like to actually refine the mesh, in both \(h\) and \(p\) . The way we are going to do this is as follows: first, we use the estimated error to flag those cells for refinement that have the largest error. This is what we have always done:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                  estimated_error_per_cell,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0.03);</div>
</div><!-- fragment --><p>Next we would like to figure out which of the cells that have been flagged for refinement should actually have \(p\) increased instead of \(h\) decreased. The strategy we choose here is that we look at the smoothness indicators of those cells that are flagged for refinement, and increase \(p\) for those with a smoothness larger than a certain relative threshold. In other words, for every cell for which (i) the refinement flag is set, (ii) the smoothness indicator is larger than the threshold, and (iii) we still have a finite element with a polynomial degree higher than the current one in the finite element collection, we will assign a future FE index that corresponds to a polynomial with degree one higher than it currently is. The following function is capable of doing exactly this. Absent any better strategies, we will set the threshold via interpolation between the minimal and maximal smoothness indicators on cells flagged for refinement. Since the corner singularities are strongly localized, we will favor \(p\) - over \(h\) -refinement quantitatively. We achieve this with a low threshold by setting a small interpolation factor of 0.2. In the same way, we deal with cells that are going to be coarsened and decrease their polynomial degree when their smoothness indicator is below the corresponding threshold determined on cells to be coarsened.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">hp::Refinement::p_adaptivity_from_relative_threshold</a>(</div>
<div class="line">  dof_handler, smoothness_indicators, 0.2, 0.2);</div>
</div><!-- fragment --><p>The above function only determines whether the polynomial degree will change via future FE indices, but does not manipulate the \(h\) -refinement flags. So for cells that are flagged for both refinement categories, we prefer \(p\) - over \(h\) -refinement. The following function call ensures that only one of \(p\) - or \(h\) -refinement is imposed, and not both at once.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">hp::Refinement::choose_p_over_h</a>(dof_handler);</div>
</div><!-- fragment --><p>For grid adaptive refinement, we ensure a 2:1 mesh balance by limiting the difference of refinement levels of neighboring cells to one by calling <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a>. We would like to achieve something similar for the p-levels of neighboring cells: levels of future finite elements are not allowed to differ by more than a specified difference. With its default parameters, a call of <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> ensures that their level difference is limited to one. This will not necessarily decrease the number of hanging nodes in the domain, but makes sure that high order polynomials are not constrained to much lower polynomials on faces, e.g., fifth order to second order polynomials.</p>
<div class="fragment"><div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference</a>(dof_handler);</div>
</div><!-- fragment --><p>At the end of this procedure, we then refine the mesh. During this process, children of cells undergoing bisection inherit their mother cell's finite element index. Further, future finite element indices will turn into active ones, so that the new finite elements will be assigned to cells after the next call of <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>. <br  />
</p>
<div class="fragment"><div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcreate_coarse_grid"></a> </p><h4>LaplaceProblem::create_coarse_grid</h4>
<p>The following function is used when creating the initial grid. The grid we would like to create is actually similar to the one from <a class="el" href="step_14.html">step-14</a> , i.e., the square domain with the square hole in the middle. It can be generated by exactly the same function. However, since its implementation is only a specialization of the 2d case, we will present a different way of creating this domain which is dimension independent. <br  />
 We first create a hypercube triangulation with enough cells so that it already holds our desired domain \([-1,1]^d\) , subdivided into \(4^d\) cells. We then remove those cells in the center of the domain by testing the coordinate values of the vertices on each cell. In the end, we refine the so created grid globally as usual.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::create_coarse_grid</a>()</div>
<div class="line">   {</div>
<div class="line">     <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> cube;</div>
<div class="line">     <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(cube, 4,</div>
<div class="line">  </div>
<div class="line">-1., 1.);</div>
<div class="line">  </div>
<div class="line">     std::set&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt; cells_to_remove;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : cube.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a> = 0; <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell</a>; ++<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>)</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>).square() &lt; .1)</div>
<div class="line">           cells_to_remove.insert(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">GridGenerator::create_triangulation_with_removed_cells</a>(cube,</div>
<div class="line">                                                            cells_to_remove,</div>
<div class="line">                                                            <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(3);</div>
<div class="line">   }</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4><a class="el" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem::run</a></h4>
<p>This function implements the logic of the program, as did the respective function in most of the previous programs already, see for example <a class="el" href="step_6.html">step-6</a> . <br  />
 Basically, it contains the adaptive loop: in the first iteration create a coarse grid, and then set up the linear system, assemble it, solve, and postprocess the solution including mesh refinement. Then start over again. In the meantime, also output some information for those staring at the screen trying to figure out what the program does:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; 6; ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">          create_coarse_grid();</div>
<div class="line"> </div>
<div class="line">        setup_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells      : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        assemble_system();</div>
<div class="line">        <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">        postprocess(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step27</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The main function is again verbatim what we had before: wrap creating and running an object of the main class into a <code>try</code> block and catch whatever exceptions are thrown, thereby producing meaningful output if anything should go wrong:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep27.html">Step27</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;2&gt;</a> laplace_problem;</div>
<div class="line">      laplace_problem.<a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>In this section, we discuss a few results produced from running thecurrent tutorial program. More results, in particular the extension to3d calculations and determining how much compute time the individualcomponents of the program take, are given in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. When run, this is what the program produces: </p><div class="fragment"><div class="line">&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">[ 66%] Built target @<a class="code" href="ginkgo__solver__0_8txt.html#af756036e4c7d624b94dfff983b9d40f5">ref</a> step_27 <span class="stringliteral">&quot;step-27&quot;</span></div>
<div class="line">[100%] Run @<a class="code" href="ginkgo__solver__0_8txt.html#af756036e4c7d624b94dfff983b9d40f5">ref</a> step_27 <span class="stringliteral">&quot;step-27&quot;</span> <a class="code" href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a> Release <a class="code" href="physics__0_8txt.html#a38362129af36598c1e4b4e928688ca77">configuration</a></div>
<div class="line">Cycle 0:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 768</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 3264</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 384</div>
<div class="line">Cycle 1:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 807</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 4764</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 756</div>
<div class="line">Cycle 2:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 927</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 8226</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 1856</div>
<div class="line">Cycle 3:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 978</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 12146</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 2944</div>
<div class="line">Cycle 4:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 1104</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 16892</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 3998</div>
<div class="line">Cycle 5:</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>      : 1149</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 22078</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>       : 5230</div>
</div><!-- fragment --><p>The first thing we learn from this is that the number of constrained degreesof freedom is on the order of 20-25% of the total number of degrees offreedom, at least on the later grids when we have elements of relativelyhigh order (in 3d, the fraction of constrained degrees of freedom can be upto 30%). This is, in fact, on the same order of magnitude as fornon- \(hp\) -discretizations. For example, in the last step of the <a class="el" href="step_6.html">step-6</a> program, we have 18353 degrees of freedom, 4432 of which areconstrained. The difference is that in the latter program, each constrainedhanging node is constrained against only the two adjacent degrees offreedom, whereas in the \(hp\) -case, constrained nodes are constrained againstmany more degrees of freedom. Note also that the current program alsoincludes nodes subject to Dirichlet boundary conditions in the list ofconstraints. In cycle 0, all the constraints are actually because ofboundary conditions. Of maybe more interest is to look at the graphical output. First, here is thesolution of the problem: <img src="https://www.dealii.org/images/steps/developer/  step-27  -solution.png" alt="Elevation plot of the solution, showing the lack of regularity near          the interior (reentrant) corners." width="200" height="200" class="inline"/> Secondly, let us look at the sequence of meshes generated: </p><div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-00.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners without adaptive refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-01.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with one level of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-02.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with two levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-03.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with three levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-04.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with four levels of
         refinement. New cells are placed near the corners.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.mesh-05.svg" style="pointer-events: none;" width="200" height="200">Triangulation containing reentrant corners with five levels of
         refinement. New cells are placed near the corners.</object> </div> </div><p> <br  />
 It is clearly visible how the mesh is refined near the corner singularities,as one would expect it. More interestingly, we should be curious to see thedistribution of finite element polynomial degrees to these mesh cells, wherethe lightest color corresponds to degree two and the darkest one correspondsto degree seven: </p><div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-00.svg" style="pointer-events: none;" width="200" height="200">Initial grid where all cells contain just biquadratic functions.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-01.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after one refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-02.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after two refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-03.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after three refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-04.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after four refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.fe_degree-05.svg" style="pointer-events: none;" width="200" height="200">Depiction of local approximation degrees after five refinements.</object> </div> </div><p> <br  />
 While this is certainly not a perfect arrangement, it does make some sense: weuse low order elements close to boundaries and corners where regularity islow. On the other hand, higher order elements are used where (i) the error wasat one point fairly large, i.e., mainly in the general area around the cornersingularities and in the top right corner where the solution is large, <a class="el" href="sparsity__0_8txt.html#aac1152d82b1ea3099c73daed328c6611">and(ii)</a> where the solution is smooth, i.e., far away from the boundary. This arrangement of polynomial degrees of course follows from our smoothnessestimator. Here is the estimated smoothness of the solution, with darker colorsindicating least smoothness and lighter indicating the smoothest areas: </p><div class="threecolumn" style="width: 80%"> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-00.svg" style="pointer-events: none;" width="200" height="200">Estimated regularity per cell on the initial grid.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-01.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after one refinement.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-02.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after two refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-03.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after three refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-04.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after four refinements.</object> </div> <div> <object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-27.smoothness-05.svg" style="pointer-events: none;" width="200" height="200">Depiction of the estimated regularity per cell after five refinements.</object> </div> </div><p> <br  />
 The primary conclusion one can draw from this is that the loss of regularity atthe internal corners is a highly localized phenomenon; it only seems to impactthe cells adjacent to the corner itself, so when we refine the mesh the blackcoloring is no longer visible. Besides the corners, this sequence of plotsimplies that the smoothness estimates are somewhat independent of the meshrefinement, particularly when we are far away from boundaries.It is also obvious that the smoothness estimates are independent of the actualsize of the solution (see the picture of the solution above), as it should be.A point of larger concern, however, is that one realizes on closer inspectionthat the estimator we have overestimates the smoothness of the solution oncells with hanging nodes. This in turn leads to higher polynomial degrees inthese areas, skewing the allocation of finite elements onto cells. We have no good explanation for this effect at the moment. One theory is thatthe numerical solution on cells with hanging nodes is, of course, constrainedand therefore not entirely free to explore the function space to get close tothe exact solution. This lack of degrees of freedom may manifest itself byyielding numerical solutions on these cells with suppressed oscillation,meaning a higher degree of smoothness. The estimator picks this signal up andthe estimated smoothness overestimates the actual value. However, a definiteanswer to what is going on currently eludes the authors of this program. The bigger question is, of course, how to avoid this problem. Possibilitiesinclude estimating the smoothness not on single cells, but cell assemblies orpatches surrounding each cell. It may also be possible to find simplecorrection factors for each cell depending on the number of constraineddegrees of freedom it has. In either case, there are ample opportunities forfurther research on finding good \(hp\) -refinement criteria. On the other hand,the main point of the current program was to demonstrate using the \(hp\) -technology in deal.II, which is unaffected by our use of a possiblesub-optimal refinement criterion.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Differenthpdecisionstrategies"></a></p><h4>Different hp-decision strategies</h4>
<p>This tutorial demonstrates only one particular strategy to decide between \(h\) - and \(p\) -adaptation. In fact, there are many more ways to automatically decide on theadaptation type, of which a few are already implemented in deal.II: </p><ul>
<li>
<em>Fourier coefficient decay:</em> This is the strategy currently implemented in this tutorial. For more information on this strategy, see the general documentation of the <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">SmoothnessEstimator::Fourier</a> namespace.  <br  />
 </li>
<li>
<em>Legendre coefficient decay:</em> This strategy is quite similar to the current one, but uses Legendre series expansion rather than the Fourier one: instead of sinusoids as basis functions, this strategy uses Legendre polynomials. Of course, since we approximate the solution using a finite-dimensional polynomial on each cell, the expansion of the solution in Legendre polynomials is also finite and, consequently, when we talk about the "decay" of this expansion, we can only consider the finitely many nonzero coefficients of this expansion, rather than think about it in asymptotic terms. But, if we have enough of these coefficients, we can certainly think of the decay of these coefficients as characteristic of the decay of the coefficients of the exact solution (which is, in general, not polynomial and so will have an infinite Legendre expansion), and considering the coefficients we have should reveal something about the properties of the exact solution. The transition from the Fourier strategy to the Legendre one is quite simple: You just need to change the series expansion class and the corresponding smoothness estimation function to be part of the proper namespaces <a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> and <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">SmoothnessEstimator::Legendre</a>. This strategy is used in <a class="el" href="step_75.html">step-75</a> . For the theoretical background of this strategy, consult the general documentation of the <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">SmoothnessEstimator::Legendre</a> namespace, as well as <b>[mavriplis1994hp]</b> , <b>[eibner2007hp]</b> and <b>[davydov2017hp]</b> .  <br  />
 </li>
<li>
<em>Refinement history:</em> The last strategy is quite different from the other two. In theory, we know how the error will converge after changing the discretization of the function space. With \(h\) -refinement the solution converges algebraically as already pointed out in <a class="el" href="step_7.html">step-7</a> . If the solution is sufficiently smooth, though, we expect that the solution will converge exponentially with increasing polynomial degree of the finite element. We can compare a proper prediction of the error with the actual error in the following step to see if our choice of adaptation type was justified. The transition to this strategy is a bit more complicated. For this, we need an initialization step with pure \(h\) - or \(p\) -refinement and we need to transfer the predicted errors over adapted meshes. The extensive documentation of the <a class="el" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error()</a> function describes not only the theoretical details of this approach, but also presents a blueprint on how to implement this strategy in your code. For more information, see <b>[melenk2001hp]</b> . Note that with this particular function you cannot predict the error for the next time step in time-dependent problems. Therefore, this strategy cannot be applied to this type of problem without further ado. Alternatively, the following approach could be used, which works for all the other strategies as well: start each time step with a coarse mesh, keep refining until happy with the result, and only then move on to the next time step.  </li>
</ul>
<p><br  />
 Try implementing one of these strategies into this tutorial and observe thesubtle changes to the results. You will notice that all strategies arecapable of identifying the singularities near the reentrant corners andwill perform \(h\) -refinement in these regions, while preferring \(p\) -refinementin the bulk domain. A detailed comparison of these strategies is presentedin <b>[fehling2020]</b> .</p>
<p><a class="anchor" id="Parallelhpadaptivefiniteelements"></a></p><h4>Parallel hp-adaptive finite elements</h4>
<p>All functionality presented in this tutorial already works for bothsequential and parallel applications. It is possible without too mucheffort to change to either the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> classes. If you feel eager to tryit, we recommend reading <a class="el" href="step_18.html">step-18</a> for the former and <a class="el" href="step_40.html">step-40</a> for thelatter case first for further background information on the topic, andthen come back to this tutorial to try out your newly acquired skills. We go one step further in <a class="el" href="step_75.html">step-75</a> : Here, we combine hp-adapative andMatrixFree methods in combination with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2006 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2006, 2007;</span></div>
<div class="line"><span class="comment"> *          Denis Davydov, University of Erlangen-Nuremberg, 2016;</span></div>
<div class="line"><span class="comment"> *          Marc Fehling, Colorado State University, 2020.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2refinement_8h.html">deal.II/hp/refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__series_8h.html">deal.II/fe/fe_series.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2smoothness__estimator_8h.html">deal.II/numerics/smoothness_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep27.html">Step27</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classLaplaceProblem.html">LaplaceProblem</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line">    ~<a class="code" href="classLaplaceProblem.html">LaplaceProblem</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    <span class="keywordtype">void</span> create_coarse_grid();</div>
<div class="line">    <span class="keywordtype">void</span> postprocess(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>          dof_handler;</div>
<div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div>
<div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div>
<div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt; face_quadrature_collection;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="classStep27_1_1RightHandSide.html#a19c67ad03b64ec2b1e970bd2551981ed">RightHandSide&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">      <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a> *= (<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] + 1);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep27_1_1LaplaceProblem.html#a5ad3099268928abf7d470cb7fb12176a">LaplaceProblem&lt;dim&gt;::LaplaceProblem</a>()</div>
<div class="line">    : dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">    , max_degree(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &lt;= 2 ? 7 : 5)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> = 2; <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> &lt;= max_degree; ++<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>)</div>
<div class="line">      {</div>
<div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>));</div>
<div class="line">        quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">        face_quadrature_collection.push_back(<a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(<a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a> + 1));</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::~LaplaceProblem</a>()</div>
<div class="line">  {</div>
<div class="line">    dof_handler.clear();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem&lt;dim&gt;::setup_system</a>()</div>
<div class="line">  {</div>
<div class="line">    dof_handler.distribute_dofs(fe_collection);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.n_dofs());</div>
<div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                             0,</div>
<div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                             <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem&lt;dim&gt;::assemble_system</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div>
<div class="line">                                   quadrature_collection,</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                     <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                     <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classRightHandSide.html">RightHandSide&lt;dim&gt;</a> rhs_function;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_fe().n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> = 0;</div>
<div class="line"> </div>
<div class="line">        cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">        hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;double&gt; rhs_values(fe_values.n_quadrature_points);</div>
<div class="line">        rhs_function.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(), rhs_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; fe_values.n_quadrature_points;</div>
<div class="line">             ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                  (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// grad phi_i(x_q)</span></div>
<div class="line">                   fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) * <span class="comment">// grad phi_j(x_q)</span></div>
<div class="line">                   fe_values.JxW(q_point));           <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">              cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                              rhs_values[q_point] *               <span class="comment">// f(x_q)</span></div>
<div class="line">                              fe_values.JxW(q_point));            <span class="comment">// dx</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>, cell_rhs, <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>, system_matrix, system_rhs);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.size(),</div>
<div class="line">                                 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12 * system_rhs.l2_norm());</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">    <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(system_matrix, 1.2);</div>
<div class="line"> </div>
<div class="line">    cg.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::postprocess</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">      dof_handler,</div>
<div class="line">      face_quadrature_collection,</div>
<div class="line">      <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">      <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">      estimated_error_per_cell);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">    <a class="code" href="classFESeries_1_1Fourier.html">FESeries::Fourier&lt;dim&gt;</a> fourier =</div>
<div class="line">      <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#a748faa704c9dfb67a074d11316e777b4">SmoothnessEstimator::Fourier::default_fe_series</a>(fe_collection);</div>
<div class="line">    <a class="code" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay</a>(fourier,</div>
<div class="line">                                                    dof_handler,</div>
<div class="line">                                                    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                                    smoothness_indicators);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">        fe_degrees(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) =</div>
<div class="line">          fe_collection[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_fe_index()].degree;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> std::string filename =</div>
<div class="line">        <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line">      std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">      data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.3,</div>
<div class="line">                                                      0.03);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">hp::Refinement::p_adaptivity_from_relative_threshold</a>(</div>
<div class="line">        dof_handler, smoothness_indicators, 0.2, 0.2);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">hp::Refinement::choose_p_over_h</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line">      <a class="code" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;dim&gt;::create_coarse_grid</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> cube;</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(cube, 4, -1., 1.);</div>
<div class="line"> </div>
<div class="line">    std::set&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt; cells_to_remove;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : cube.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a> = 0; <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell</a>; ++<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>).square() &lt; .1)</div>
<div class="line">          cells_to_remove.insert(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">GridGenerator::create_triangulation_with_removed_cells</a>(cube,</div>
<div class="line">                                                           cells_to_remove,</div>
<div class="line">                                                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(3);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; 6; ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">          create_coarse_grid();</div>
<div class="line"> </div>
<div class="line">        setup_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells      : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; std::endl</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div>
<div class="line">                  &lt;&lt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        assemble_system();</div>
<div class="line">        <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">        postprocess(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step27</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep27.html">Step27</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classLaplaceProblem.html">LaplaceProblem&lt;2&gt;</a> laplace_problem;</div>
<div class="line">      laplace_problem.<a class="code" href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">run</a>();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="aclasshp_1_1FEValues_html"><div class="ttname"><a href="classhp_1_1FEValues.html">hp::FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="hp_2fe__values_8h_source.html#l00324">fe_values.h:324</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_afec1b694405cadb2d251275096ad3563"><div class="ttname"><a href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data output</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00059">distributed_0.txt:59</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_af35ca33203cd802325d779be7b6b41e8"><div class="ttname"><a href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin with</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00139">multithreading_0.txt:139</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__cg_8h_source.html#l00088">solver_cg.h:88</a></div></div>
<div class="ttc" id="apetsc__precondition__0_8txt_html_a41ebb2d49faa97a3d9eab4b4f13c2742"><div class="ttname"><a href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a></div><div class="ttdeci">*Base class for preconditioner classes using the PETSc functionality The classes in this hierarchy don t do a whole lot except for providing a function that sets the preconditioner and certain parameters on the preconditioning context of the solver These classes are basically here only to allow a similar interface as already used for the deal II solver and preconditioner classes Note that derived classes only provide interfaces to the relevant functionality of PETSc PETSc does not implement all preconditioners for all matrix types In particular some preconditioners are not going to work for parallel jobs such as for example the ILU preconditioner ***Constructor **Destructor **Destroys the preconditioner</div><div class="ttdef"><b>Definition:</b> <a href="petsc__precondition__0_8txt_source.html#l00002">petsc_precondition_0.txt:2</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a358d5bd545bc115c8645d93fa79b64bc"><div class="ttname"><a href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a></div><div class="ttdeci">void subdivided_hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const unsigned int repetitions, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a8fba07b9a84b89e6be225f5f95c3e355"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div><div class="ttdeci">the program is just and one can not intelligently work around that *It is sometimes useful to change the behavior of the[2.x.6] macro from aborting a program to throwing exceptions On the other exceptions are not allowed to propagate out of destructors of classes For this there is a variant of the called[2.x.7] that can be used in destructors These use cases are discussed further down below on this page **Dynamic such as whether an output file can be written to *These are things that shouldn t be checked because it is not guaranteed that a program for which the condition is satisfied in a debug mode run</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00022">exceptions_0.txt:22</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2namespace__dealii_8h_source.html#l00026">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00070">fe_update_flags.h:70</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="ahp_2refinement_8h_html"><div class="ttname"><a href="hp_2refinement_8h.html">refinement.h</a></div></div>
<div class="ttc" id="astep-1_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="step-1_8cc_source.html#l00086">step-1.cc:86</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a33d9d552f696d578da30dc9a83048670"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference</a></div><div class="ttdeci">bool limit_p_level_difference(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int max_difference=1, const unsigned int contains_fe_index=0)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00804">refinement.cc:804</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_aadb8c949b40006062ac7e020547a1d15"><div class="ttname"><a href="classLaplaceProblem.html#aadb8c949b40006062ac7e020547a1d15">LaplaceProblem::setup_system</a></div><div class="ttdeci">void setup_system()</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00435">step-50.cc:435</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="afe_2fe__q_8h_html"><div class="ttname"><a href="fe_2fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="anamespaceGridRefinement_html_a48e5395381ed87155942a61a1edd134d"><div class="ttname"><a href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00322">grid_refinement.cc:322</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="anumerics_2error__estimator_8h_html"><div class="ttname"><a href="numerics_2error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a0b75d7ded89e820e9f5fdc1d2b68c76c"><div class="ttname"><a href="classLaplaceProblem.html#a0b75d7ded89e820e9f5fdc1d2b68c76c">LaplaceProblem::LaplaceProblem</a></div><div class="ttdeci">LaplaceProblem(const Settings &amp;settings)</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00412">step-50.cc:412</a></div></div>
<div class="ttc" id="aphysics__0_8txt_html_a38362129af36598c1e4b4e928688ca77"><div class="ttname"><a href="physics__0_8txt.html#a38362129af36598c1e4b4e928688ca77">configuration</a></div><div class="ttdeci">******classes that relate to continuum physical fields and materials ***A collection of namespaces and utilities to assist in the construction and manipulation of data related to physical fields and materials ***Notations that reduce the order of effectively storing them in some sort of consistent compressed storage pattern An example is storing the independent components of[2.x.2] symmetric tensors of rank as a vector with and then representing the independent elements of symmetric[2.x.3] tensors of with its generalization it has wider applicability This representation is also common in the material science and FEM literature There are several variations of tensor each a slightly different structure The primary difference between the various forms of tensor notation is the weighting prescribed to the various elements of the compressed tensors This[1.x.0] has some further general insights on this topic *Jean Paul **A collection of operations to assist in the transformation of tensor quantities from the reference to spatial configuration</div><div class="ttdef"><b>Definition:</b> <a href="physics__0_8txt_source.html#l00020">physics_0.txt:20</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_aafea668ad0c451ac7a0fae0f558c36d7"><div class="ttname"><a href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a></div><div class="ttdeci">in the area occupied by these artificial cells</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00037">distributed_0.txt:37</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a1f9c6147583b774bd1620d534c32dee5"><div class="ttname"><a href="classLaplaceProblem.html#a1f9c6147583b774bd1620d534c32dee5">LaplaceProblem::triangulation</a></div><div class="ttdeci">parallel::distributed::Triangulation&lt; dim &gt; triangulation</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00385">step-50.cc:385</a></div></div>
<div class="ttc" id="aclassFunction_html_a562fc1114e95e702e6696721f71528db"><div class="ttname"><a href="classFunction.html#a562fc1114e95e702e6696721f71528db">Function&lt; dim &gt;::value_list</a></div><div class="ttdeci">virtual void value_list(const std::vector&lt; Point&lt; dim &gt;&gt; &amp;points, std::vector&lt; double &gt; &amp;values, const unsigned int component=0) const</div></div>
<div class="ttc" id="aclasshp_1_1QCollection_html"><div class="ttname"><a href="classhp_1_1QCollection.html">hp::QCollection</a></div><div class="ttdef"><b>Definition:</b> <a href="hp_2q__collection_8h_source.html#l00044">q_collection.h:44</a></div></div>
<div class="ttc" id="aclassFEValues_html_a902429920d32c81c9c279d9a15faa263"><div class="ttname"><a href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">FEValues::get_present_fe_values</a></div><div class="ttdeci">const FEValues&lt; dim, spacedim &gt; &amp; get_present_fe_values() const</div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="aginkgo__solver__0_8txt_html_af756036e4c7d624b94dfff983b9d40f5"><div class="ttname"><a href="ginkgo__solver__0_8txt.html#af756036e4c7d624b94dfff983b9d40f5">ref</a></div><div class="ttdeci">which can be used to debug the library auto ref</div><div class="ttdef"><b>Definition:</b> <a href="ginkgo__solver__0_8txt_source.html#l00005">ginkgo_solver_0.txt:5</a></div></div>
<div class="ttc" id="alac_2affine__constraints_8h_html"><div class="ttname"><a href="lac_2affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_ad919e2b915d8e8226aef004c2d8399a8"><div class="ttname"><a href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">exception</a></div><div class="ttdeci">since default values may change in the process of program you cannot know the values of parameters not specified in the input file ****It is often convenient to have something happen as soon as a parameter value is read This could be a check that it is valid that a file that is listed in the parameter file exists **or to initiate something else in such as setting a variable outside the this action could also be initiated once all parameters are read via but it is sometimes[1.x.19] to do it right away *This is facilitated by the and can then do whatever they want with it **e save it somewhere outside the ParameterHandler in C one doesn t usually pass around the address of a but an action can be a function like object(taking a string as argument) that results from calling such as a[1.x.20] that has the form **[1.x.21] *and that is attached to a specific parameter. *A typical example of such an action would be as follows the content of the file equals the default value of the parameter the contents of files are never changed after declaration of a parameter a directory in this file system may not have a file called[2.x.20] in it In that the directory represents a subsection as declared and the directory s name will correspond to the name of the subsection It will then have no files in it at but it may have further directories in the code above will lead to a hierarchical representation of data that looks like this(the content of files is indicated at the right in a different font) this is only used when creating output for exceptions If non empty[2.x.35] is the ParameterHandler object will stop parsing lines after encountering[2.x.36] This is handy when adding extra data that shall be parsed manually If[2.x.37] the parameter handler will skip undefined sections and entries This is useful for partially parsing a parameter for example to obtain only the spatial dimension of the problem By default all entries and subsections are expected to be declared The function sets the value of all parameters it encounters in the input file to the provided value Parameters not explicitly listed in the input file are left at the value they previously which will be the default value provided to and for each parameter all associated actions that may previously have been set by or if an associated action throws an exception</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00241">parameter_handler_0.txt:241</a></div></div>
<div class="ttc" id="anumerics_2smoothness__estimator_8h_html"><div class="ttname"><a href="numerics_2smoothness__estimator_8h.html">smoothness_estimator.h</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="aclassFESeries_1_1Fourier_html"><div class="ttname"><a href="classFESeries_1_1Fourier.html">FESeries::Fourier</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__series_8h_source.html#l00075">fe_series.h:75</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a4890d9eae896d749b103c8eec9c2029d"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">hp::Refinement::choose_p_over_h</a></div><div class="ttdeci">void choose_p_over_h(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00690">refinement.cc:690</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a2713d4075ba7824063d84a8c9f9d2967"><div class="ttname"><a href="classLaplaceProblem.html#a2713d4075ba7824063d84a8c9f9d2967">LaplaceProblem::dof_handler</a></div><div class="ttdeci">DoFHandler&lt; dim &gt; dof_handler</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00389">step-50.cc:389</a></div></div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00116">fe_update_flags.h:116</a></div></div>
<div class="ttc" id="anumerics_2vector__tools_8h_html"><div class="ttname"><a href="numerics_2vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="abase_2function_8h_html"><div class="ttname"><a href="base_2function_8h.html">function.h</a></div></div>
<div class="ttc" id="aclassVector_html_ac4a4dbef7dd65ef8ad35ae56b57d7c05"><div class="ttname"><a href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">Vector::reinit</a></div><div class="ttdeci">virtual void reinit(const size_type N, const bool omit_zeroing_entries=false)</div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a1d460e36c9dca4e91d29ae20462c6579"><div class="ttname"><a href="classLaplaceProblem.html#a1d460e36c9dca4e91d29ae20462c6579">LaplaceProblem::solve</a></div><div class="ttdeci">void solve()</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00861">step-50.cc:861</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html"><div class="ttname"><a href="classLaplaceProblem.html">LaplaceProblem</a></div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00342">step-50.cc:342</a></div></div>
<div class="ttc" id="anamespacetypes_html_aaf4eb6ec214fa642dfd956f11a9cd2d7"><div class="ttname"><a href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a></div><div class="ttdeci">unsigned int boundary_id</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00117">types.h:117</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_ada140ece81bf38a23e738e0e57f89e97"><div class="ttname"><a href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">GridGenerator::create_triangulation_with_removed_cells</a></div><div class="ttdeci">void create_triangulation_with_removed_cells(const Triangulation&lt; dim, spacedim &gt; &amp;input_triangulation, const std::set&lt; typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cells_to_remove, Triangulation&lt; dim, spacedim &gt; &amp;result)</div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a40d0609a27a24ce310ae30cfccdf7f04"><div class="ttname"><a href="classLaplaceProblem.html#a40d0609a27a24ce310ae30cfccdf7f04">LaplaceProblem::constraints</a></div><div class="ttdeci">AffineConstraints&lt; double &gt; constraints</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00393">step-50.cc:393</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a373fbdacd8c486e675b8d2bff8943192"><div class="ttname"><a href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a></div><div class="ttdeci">void distribute_local_to_global(const InVector &amp;local_vector, const std::vector&lt; size_type &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02250">affine_constraints.h:2250</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html"><div class="ttname"><a href="base_2logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a5abc878123b65e2a7a16e57bba0e282e"><div class="ttname"><a href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a></div><div class="ttdeci">******This module deals with constraints on degrees of freedom The central class to deal with constraints is the AffineConstraints class *Constraints typically come from several for one usually enforces them by requiring that degrees of freedom on the boundary have particular for example[2.x.3] if the boundary condition[2.x.4] requires that the finite element solution[2.x.5] at the location of degree of freedom has the value Such constraints are generated by those versions of the[2.x.6] function that take a AffineConstraints for example no normal as happens in flow problems and is handled by the[2.x.11] function or prescribed tangential as happens in electromagnetic problems and is handled by the[2.x.13] function For the former imagine for example that we are at at vertex where the normal vector has the form[2.x.14] and that and[2.x.17] components of the flow field at this vertex are associated with degrees of and Then the no normal flux condition means that we need to have the condition[2.x.18] The prescribed tangential component leads to similar constraints though there is often something on the right hand side ****If you have hanging node constraints</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00020">constraints_0.txt:20</a></div></div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="anumerics_2matrix__tools_8h_html"><div class="ttname"><a href="numerics_2matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_acad99726038e4fca7f605fdffb3317e4"><div class="ttname"><a href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk</a></div><div class="ttdeci">void write_vtk(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07221">data_out_base.cc:7221</a></div></div>
<div class="ttc" id="amapping__fe__0_8txt_html_a0af9c36aca1d2fa34a8615b4521ad4de"><div class="ttname"><a href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">map</a></div><div class="ttdeci">where is the first fundamental form of the map</div><div class="ttdef"><b>Definition:</b> <a href="mapping__fe__0_8txt_source.html#l00084">mapping_fe_0.txt:84</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="avector__tools__point__value__0_8txt_html_ac7a5c2ceb5c739d5b51cc7e0eee8100a"><div class="ttname"><a href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a></div><div class="ttdeci">*Assembling of right hand sides **Create a right hand side vector for a point source at point[2.x.1] In other it creates a vector[2.x.2] so that[2.x.3] where[2.x.4] are the shape functions described by[2.x.5] and[2.x.6] is the point at which the delta function is located Prior content of the given[2.x.7] vector is deleted This function is for the case of a scalar finite element This function is typically used in one of these two with different values for right hand sides or and then evaluate the solution at the same point every time You could do this by calling[2.x.8] after each solve</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__point__value__0_8txt_source.html#l00015">vector_tools_point_value_0.txt:15</a></div></div>
<div class="ttc" id="alac_2dynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="lac_2dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="anamespaceStep27_html"><div class="ttname"><a href="namespaceStep27.html">Step27</a></div><div class="ttdef"><b>Definition:</b> <a href="step-27_8cc_source.html#l00055">step-27.cc:55</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a5c6d887dea84186bb992ec9fec99f744"><div class="ttname"><a href="classLaplaceProblem.html#a5c6d887dea84186bb992ec9fec99f744">LaplaceProblem::solution</a></div><div class="ttdeci">VectorType solution</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00397">step-50.cc:397</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="avector__0_8txt_html_aaf255149898cc5cea8c1fa1e76fffe6f"><div class="ttname"><a href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a></div><div class="ttdeci">0 v</div><div class="ttdef"><b>Definition:</b> <a href="vector__0_8txt_source.html#l00062">vector_0.txt:62</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a69730bc7f91dd1be17fd083a66514e73"><div class="ttname"><a href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled to indent allsource files that have been changed recently If you want to make sure thatthe indenting is correct for all your you might want to set up apre commit hook One way to do is to copy[2.x.4] to[2.x.5] and make sure it isexecutable *If the system you are working on has more than one version of[2.x.6] degrees of freedom</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00018">coding_conventions_0.txt:18</a></div></div>
<div class="ttc" id="aclasshp_1_1FECollection_html_a4b0e75a805ff012e76d33ad6d4c3eac8"><div class="ttname"><a href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">hp::FECollection::push_back</a></div><div class="ttdeci">void push_back(const FiniteElement&lt; dim, spacedim &gt; &amp;new_fe)</div><div class="ttdef"><b>Definition:</b> <a href="fe__collection_8cc_source.html#l00273">fe_collection.cc:273</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_adf261da8033116444de6140403ba8c3d"><div class="ttname"><a href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">AffineConstraints::n_constraints</a></div><div class="ttdeci">size_type n_constraints() const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02106">affine_constraints.h:2106</a></div></div>
<div class="ttc" id="atrilinos__sparse__matrix__0_8txt_html_ab4e34663c28496ee1b07f40fd5d00fa1"><div class="ttname"><a href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a></div><div class="ttdeci">all column elements of a row are stored on the same processor in any case The vector&lt; tt &gt; n_entries_per_row&lt;/tt &gt; specifies the number of entries in each row of the newly generated matrix **This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix__0_8txt_source.html#l00162">trilinos_sparse_matrix_0.txt:162</a></div></div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2dynamic__sparsity__pattern_8h_source.html#l00340">dynamic_sparsity_pattern.h:340</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparsity__pattern_8h_source.html#l00900">sparsity_pattern.h:900</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="aclassLaplaceProblem_html_addbdc7360d9feca8f8676eb6f381b6db"><div class="ttname"><a href="classLaplaceProblem.html#addbdc7360d9feca8f8676eb6f381b6db">LaplaceProblem::system_matrix</a></div><div class="ttdeci">MatrixType system_matrix</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00395">step-50.cc:395</a></div></div>
<div class="ttc" id="adofs_2dof__tools_8h_html"><div class="ttname"><a href="dofs_2dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="alac_2precondition_8h_html"><div class="ttname"><a href="lac_2precondition_8h.html">precondition.h</a></div></div>
<div class="ttc" id="aclassStep27_1_1RightHandSide_html_a19c67ad03b64ec2b1e970bd2551981ed"><div class="ttname"><a href="classStep27_1_1RightHandSide.html#a19c67ad03b64ec2b1e970bd2551981ed">Step27::RightHandSide::value</a></div><div class="ttdeci">virtual double value(const Point&lt; dim &gt; &amp;p, const unsigned int component) const override</div><div class="ttdef"><b>Definition:</b> <a href="step-27_8cc_source.html#l00107">step-27.cc:107</a></div></div>
<div class="ttc" id="aadvection__0_8txt_html_a79a3cbbb7583dd309bf1b14dc20895b6"><div class="ttname"><a href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a></div><div class="ttdeci">**its DG formulations All advection operators depend on an advection velocity denoted by[1.x.0] in the formulas below It is denoted as&lt; tt &gt; velocity&lt;/tt &gt; in the parameter lists The functions cell_matrix() and both upwind_value_matrix() are taking the equation in weak form</div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="aclassRightHandSide_html"><div class="ttname"><a href="classRightHandSide.html">RightHandSide</a></div><div class="ttdef"><b>Definition:</b> <a href="step-4_8cc_source.html#l00076">step-4.cc:76</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_a03a2f48682e29e39f7bccc11a7d1c4d1"><div class="ttname"><a href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has degree[1.x.4]</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00003">polynomial_space_0.txt:3</a></div></div>
<div class="ttc" id="abase_2quadrature__lib_8h_html"><div class="ttname"><a href="base_2quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="afe_2fe__series_8h_html"><div class="ttname"><a href="fe_2fe__series_8h.html">fe_series.h</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a7b3d3f295bb56d6cd6856bdc6cbe8a01"><div class="ttname"><a href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a></div><div class="ttdeci">void distribute(VectorType &amp;vec) const</div></div>
<div class="ttc" id="aclassAffineConstraints_html_addd15bc409c61d6f795f0132c574335b"><div class="ttname"><a href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">AffineConstraints::clear</a></div><div class="ttdeci">void clear()</div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00124">fe_update_flags.h:124</a></div></div>
<div class="ttc" id="alac_2full__matrix_8h_html"><div class="ttname"><a href="lac_2full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="alac_2solver__cg_8h_html"><div class="ttname"><a href="lac_2solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="apreconditioners__0_8txt_html_a12abe97dbf03e213445f02d95d945e59"><div class="ttname"><a href="preconditioners__0_8txt.html#a12abe97dbf03e213445f02d95d945e59">product</a></div><div class="ttdeci">*****Preconditioners are used to accelerate the iterative solution of linear systems Typical preconditioners are Gauss or but the library also supports more complex ones such as Vanka or incomplete LU sparse direct solvers can be used as preconditioners when available *Broadly preconditioners are which are multiplied with a matrix to improve conditioning The idea that the preconditioned system[1.x.1] is much easier to solve than the original system[1.x.2] What this means exactly depends on the structure of the matrix and cannot be discussed here in generality For positive definite matrices[1.x.3] it means that the spectral condition Richardson implemented in the preconditioned iteration looks like[1.x.7] preconditioning amounts to applying a linear one can usually treat any matrix like object which defines[2.x.2] as a preconditioner All preconditioner classes in this module implement this interface *When used in Krylov space it is up to the whether it simply replaces multiplications with[1.x.9] by those or does more sophisticated things SolverCG for instance uses[1.x.11] to define an inner product</div><div class="ttdef"><b>Definition:</b> <a href="preconditioners__0_8txt_source.html#l00010">preconditioners_0.txt:10</a></div></div>
<div class="ttc" id="afe__q__0_8txt_html_a1a8eaafa20c4d8c9ab128b62a984738c"><div class="ttname"><a href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a></div><div class="ttdeci">*Implementation of a scalar Lagrange finite element[2.x.0] that yields the finite element space of piecewise polynomials of degree[2.x.1] in each coordinate direction This class is realized using tensor product polynomials based on D Lagrange polynomials with Gauss or given support points *The standard constructor of this class takes the degree[2.x.2] of this finite element it can take a quadrature formula[2.x.3] defining the support points of the Lagrange interpolation in one coordinate direction *For more information about the&lt; tt &gt; spacedim&lt;/tt &gt; template parameter check the documentation of FiniteElement or the one of Triangulation **The constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.4] polynomials of degree[2.x.5] This[2.x.6] object provides all values and derivatives of the shape functions In case a quadrature rule is the constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.7] polynomials with the support points from *[2.x.8] Furthermore the constructor fills the[2.x.9] the[2.x.10] equidistant support points at i where one polynomial is one and all the others are zero For higher polynomial degrees</div><div class="ttdef"><b>Definition:</b> <a href="fe__q__0_8txt_source.html#l00009">fe_q_0.txt:9</a></div></div>
<div class="ttc" id="astep-69_8cc_html_a66a64d07b4db87c87b639bdcf7b18c82"><div class="ttname"><a href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; local_dof_indices</div><div class="ttdef"><b>Definition:</b> <a href="step-69_8cc_source.html#l00534">step-69.cc:534</a></div></div>
<div class="ttc" id="alac_2vector_8h_html"><div class="ttname"><a href="lac_2vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="ahp_2fe__collection_8h_html"><div class="ttname"><a href="hp_2fe__collection_8h.html">fe_collection.h</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceSmoothnessEstimator_1_1Fourier_html_aae63069820e030e1f012e3e84d28e6f8"><div class="ttname"><a href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">SmoothnessEstimator::Fourier::coefficient_decay</a></div><div class="ttdeci">void coefficient_decay(FESeries::Fourier&lt; dim, spacedim &gt; &amp;fe_fourier, const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const VectorType &amp;solution, Vector&lt; float &gt; &amp;smoothness_indicators, const VectorTools::NormType regression_strategy=VectorTools::Linfty_norm, const double smallest_abs_coefficient=1e-10, const bool only_flagged_cells=false)</div><div class="ttdef"><b>Definition:</b> <a href="smoothness__estimator_8cc_source.html#l00370">smoothness_estimator.cc:370</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ZeroFunction_html"><div class="ttname"><a href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00516">function.h:516</a></div></div>
<div class="ttc" id="anamespaceSmoothnessEstimator_1_1Fourier_html_a748faa704c9dfb67a074d11316e777b4"><div class="ttname"><a href="namespaceSmoothnessEstimator_1_1Fourier.html#a748faa704c9dfb67a074d11316e777b4">SmoothnessEstimator::Fourier::default_fe_series</a></div><div class="ttdeci">FESeries::Fourier&lt; dim, spacedim &gt; default_fe_series(const hp::FECollection&lt; dim, spacedim &gt; &amp;fe_collection, const unsigned int component=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="smoothness__estimator_8cc_source.html#l00579">smoothness_estimator.cc:579</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_aff61b855ec389b04419e490f82043ad8"><div class="ttname"><a href="classLaplaceProblem.html#aff61b855ec389b04419e490f82043ad8">LaplaceProblem::assemble_system</a></div><div class="ttdeci">void assemble_system()</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l00665">step-50.cc:665</a></div></div>
<div class="ttc" id="aclassPreconditionSSOR_html"><div class="ttname"><a href="classPreconditionSSOR.html">PreconditionSSOR</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2precondition_8h_source.html#l00699">precondition.h:699</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00140">function.h:140</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00052">solver_control.h:52</a></div></div>
<div class="ttc" id="ahp_2fe__values_8h_html"><div class="ttname"><a href="hp_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="agroup__CPP11_html_ga4288670ae5bd80367e24918d542cb2d8"><div class="ttname"><a href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators</a></div><div class="ttdeci">IteratorRange&lt; active_cell_iterator &gt; active_cell_iterators() const</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l12155">tria.cc:12155</a></div></div>
<div class="ttc" id="aclassStep27_1_1LaplaceProblem_html_a5ad3099268928abf7d470cb7fb12176a"><div class="ttname"><a href="classStep27_1_1LaplaceProblem.html#a5ad3099268928abf7d470cb7fb12176a">Step27::LaplaceProblem::LaplaceProblem</a></div><div class="ttdeci">LaplaceProblem()</div><div class="ttdef"><b>Definition:</b> <a href="step-27_8cc_source.html#l00121">step-27.cc:121</a></div></div>
<div class="ttc" id="aclassLaplaceProblem_html_a9933014a8275e32ea3ffcc018d804922"><div class="ttname"><a href="classLaplaceProblem.html#a9933014a8275e32ea3ffcc018d804922">LaplaceProblem::run</a></div><div class="ttdeci">void run()</div><div class="ttdef"><b>Definition:</b> <a href="step-50_8cc_source.html#l01311">step-50.cc:1311</a></div></div>
<div class="ttc" id="anamespaceEuler__DG_html_a143bc64b6fa6ced9f11c148a2af3ff09"><div class="ttname"><a href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Euler_DG::Number</a></div><div class="ttdeci">double Number</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00064">step-67.cc:64</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="amg__0_8txt_html_a1dadc108ee1520717957789de4b76416"><div class="ttname"><a href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a></div><div class="ttdeci">****Classes that have to do with multigrid algorithms *The main class with implementation of the multigrid scheme is Multigrid with its function[2.x.1] It uses the abstract following classes in order to perform the multigrid cycle</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00007">mg_0.txt:7</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a54156dbe64e8eda42b2e964c9b1c0963"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">hp::Refinement::p_adaptivity_from_relative_threshold</a></div><div class="ttdeci">void p_adaptivity_from_relative_threshold(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const Vector&lt; Number &gt; &amp;criteria, const double p_refine_fraction=0.5, const double p_coarsen_fraction=0.5, const ComparisonFunction&lt; typename identity&lt; Number &gt;::type &gt; &amp;compare_refine=std::greater_equal&lt; Number &gt;(), const ComparisonFunction&lt; typename identity&lt; Number &gt;::type &gt; &amp;compare_coarsen=std::less_equal&lt; Number &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00150">refinement.cc:150</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_af9f808a82e8c618e2e7a19dd08a9eae3"><div class="ttname"><a href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing or exact solutions Since closed form expressions for equations are often hard to pass along as function deal II uses the Function base class to describe these objects Essentially the interface of this base class requires derived classes to implement the ability to return the value of a function at one or a list of particular locations and function objects can then be used by algorithms like[2.x.1][2.x.2] and other functions *Some functions are needed again and and are therefore already provided in deal II This includes a function with a constant value</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00007">functions_0.txt:7</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassRightHandSide_html_a07b87d7025c7c5feca044c5c7d4296ef"><div class="ttname"><a href="classRightHandSide.html#a07b87d7025c7c5feca044c5c7d4296ef">RightHandSide::value</a></div><div class="ttdeci">virtual double value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const override</div><div class="ttdef"><b>Definition:</b> <a href="step-4_8cc_source.html#l00094">step-4.cc:94</a></div></div>
<div class="ttc" id="alac_2sparse__matrix_8h_html"><div class="ttname"><a href="lac_2sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a1611aa37f754086388ca76bcd421cce5"><div class="ttname"><a href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a></div><div class="ttdeci">void close()</div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="adof__tools__0_8txt_html_aa623f15672a6db0f3f730a81a5b432b4"><div class="ttname"><a href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a></div><div class="ttdeci">previous contents are not deleted **This function generates a matrix such that when a vector of data with as many elements as there are degrees of freedom of this component on the coarse grid is multiplied to this we obtain a vector with as many elements as there are global degrees of freedom on the fine grid All the elements of the other vector components of the finite element fields on the fine grid are not touched Triangulation of the fine grid can be distributed When called in each process has to have a copy of the coarse grid In this function returns transfer representation for a set of locally owned cells The output of this function is a compressed format that can be used to construct corresponding sparse transfer matrix ****Periodic boundary conditions *[2.x.121] *Insert this functions constrains all DoFs associated with the boundary described by[2.x.125] to the respective DoFs of the boundary described by[2.x.126] More the global DoF see below if[2.x.134] and[2.x.135] are not active this function loops recursively over the children of[2.x.136] and[2.x.137] If only one of the two faces is active</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__0_8txt_source.html#l00095">dof_tools_0.txt:95</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="agrid_2grid__generator_8h_html"><div class="ttname"><a href="grid_2grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="aclasshp_1_1FECollection_html"><div class="ttname"><a href="classhp_1_1FECollection.html">hp::FECollection&lt; dim &gt;</a></div></div>
<div class="ttc" id="atable__0_8txt_html_aa889bb34debce4db8c9ace2f875bdf0d"><div class="ttname"><a href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a></div><div class="ttdeci">tables that store three or more dimensional then there is nothing you can do about the size of these if your program is parallelized via then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file This is inefficient from two the data stored on every process is the and while every process needs to be able to read from a it is not necessary that every process stores its own either by re creating a copy of the table in the other processes memory space if by creating copies in shared memory once for all processes located on each of the machines used by the MPI job ******Integer type used to count the number of elements in this container **Default constructor Set all dimensions to zero **Constructor Initialize the array with the given dimensions in each index component **Constructor Initialize the array with the given dimensions in each index component</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00083">table_0.txt:83</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a02f5aa616d7b0799c538fe77d6c6c795"><div class="ttname"><a href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a></div><div class="ttdeci">i e</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00028">coding_conventions_0.txt:28</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
