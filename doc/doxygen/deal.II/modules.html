<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/modules.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Modules</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here is a list of all modules:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span><span onclick="javascript:toggleLevel(4);">4</span><span onclick="javascript:toggleLevel(5);">5</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__auto__symb__diff.html" target="_self">Automatic and symbolic differentiation</a></td><td class="desc">A module dedicated to the implementation of functions and classes that relate to automatic and symbolic differentiation. Below we provide a very brief introduction as to what automatic and symbolic differentiation are, what variations of these computational/numerical schemes exist, and how they are integrated within deal.II's framework. The purpose of all of these schemes is to automatically compute the derivative of functions, or approximations of it, in cases where one does not want to compute them by hand. Common examples are situations in the finite element context is where one wants to solve a nonlinear problem that is given by requiring that some residual \(F(u,\nabla u)=0\) where \(F\) is a complicated function that needs to be differentiated to apply Newton's method; and situations where one is given a parameter dependent problem \({\cal A}(q,u,\nabla u) = f\) and wants to form derivatives with regards to the parameters \(q\) , for example to optimize an output functional with regards to \(q\) , or for a sensitivity analysis with regards to \(q\) . One should think of \(q\) as design parameters: say, the width or shape of a wing, the stiffness coefficients of a material chosen to build an object, the power sent to a device, the chemical composition of the gases sent to a burner. In all of these cases, one should think of \(F\) and \(\cal A\) as <em>complicated</em> and cumbersome to differentiate </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__CPP11.html" target="_self">deal.II and the C++11 standard Since version 9.0, deal.II</a></td><td class="desc">Requires a compiler that supports at least <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a>. As part of this, many places in the internal implementation of deal.II are now using features that were only introduced in C++11. That said, deal.II also has functions and classes that make using it with C++11 features easier. One example is support for C++11 <a href="http://en.wikipedia.org/wiki/C++11#Range-based_for_loop">range-based for loops</a>. deal.II-based codes often have many loops of the kind </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__Concepts.html" target="_self">Concepts, or expectations on template parameters</a></td><td class="desc">Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em> concepts </em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template: </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__CUDAWrappers.html" target="_self">CUDA Wrappers The classes in this module are</a></td><td class="desc">Concerned with the description of features to be run on GPUs using CUDA </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_4_" class="arrow" onclick="toggleFolder('4_')">&#9660;</span><a class="el" href="group__dofs.html" target="_self">Degrees of Freedom This module groups classes and namespaces</a></td><td class="desc">That have to do with handling degrees of freedom. The central class of this group is the <a class="el" href="classDoFHandler.html">DoFHandler</a> class: it is built on top of a triangulation and a finite element class and allocated degrees of freedom on each cell of the triangulation as required for the finite element space described by the finite element object. There are other variants of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class such as <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> that do similar things for more special cases. <a class="el" href="classDoFHandler.html">DoFHandler</a> objects are used together with objects of type <a class="el" href="classFiniteElement.html">FiniteElement</a> (or <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> in the case of <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>) to enumerate all the degrees of freedom that exist in a triangulation for this particular finite element. As such, the combination of mesh, finite element, and DoF handler object can be thought of as providing a <em>basis</em> of the finite element space: the mesh provides the locations at which basis functions are defined; the finite element describes what kinds of basis functions exist; and the DoF handler object provides an enumeration of the basis, i.e., it is provides a concrete structure of the space so that we can describe functions in this finite dimensional space by vectors of coefficients. DoFHandlers extend <a class="el" href="classTriangulation.html">Triangulation</a> objects (and the other classes in the <a class="el" href="group__grid.html">Grids and Triangulations This module groups functions and</a> module) in that they, too, offer iterators that run over all cells, faces, or other geometric objects that make up a triangulation. These iterators are derived from the triangulation iterators and therefore offer the same functionality, but they also offer additional functions. For example, they allow to query the indices of the degrees of freedom associated with the present cell. Note that <a class="el" href="classDoFHandler.html">DoFHandler</a> classes are <em>not derived</em> from <a class="el" href="classTriangulation.html">Triangulation</a>, though they use <a class="el" href="classTriangulation.html">Triangulation</a> objects; the reason is that there can be more than one <a class="el" href="classDoFHandler.html">DoFHandler</a> object that works on the same <a class="el" href="classTriangulation.html">Triangulation</a> object. In addition to the DoF handler classes, this module holds a number of auxiliary classes not commonly used in application programs, as well as three classes that are not directly associated with the data structures of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class. The first of these is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class that stores and treats the constraints associated with hanging nodes. Secondly, the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace offers functions that can reorder degrees of freedom; among its functions are ones that sort degrees of freedom in downstream direction, for example, and ones that sort degrees of freedom in such a way that the bandwidth of associated matrices is minimized. Finally, the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace offers a variety of algorithms around handling degrees of freedom. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </td></tr>
<tr id="row_4_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__constraints.html" target="_self">Constraints on degrees of freedom</a></td><td class="desc"></td></tr>
<tr id="row_5_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_5_" class="arrow" onclick="toggleFolder('5_')">&#9660;</span><a class="el" href="group__feall.html" target="_self">Finite elements</a></td><td class="desc">All classes related to shape functions and to access to shape functions. This concerns the actual values of finite elements. For the numbering of degrees of freedom refer to the module on <a class="el" href="group__dofs.html">Degrees of Freedom This module groups classes and namespaces</a> . The classes and functions of this module fall into several sub-groups that are discussed in their respective sub-modules listed above. In addition, the <a class="el" href="namespaceFETools.html">FETools</a> class provides functions that provide information on finite elements, transformations between elements, etc. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </td></tr>
<tr id="row_5_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__febase.html" target="_self">Base classes The members of this sub-module describe the</a></td><td class="desc">Implementation mechanics of finite element classes, without actually implementing a concrete element. For example, the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class declares the virtual functions a derived class has to implement if it wants to describe a finite element space. Likewise, the <a class="el" href="classFiniteElementData.html">FiniteElementData</a> holds variables that describe certain values characterizing a finite element, such as the number of degrees of freedom per vertex, line, or face. On the other hand, classes like <a class="el" href="classFE__Poly.html">FE_Poly</a> and <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> are higher abstractions. They describe finite elements that are built atop polynomial descriptions of the shape functions on the unit cell. Classes derived from them then only have to provide a description of the particular polynomial from which a finite element is built. For example, the <a class="el" href="classFE__Q.html">FE_Q</a> class that implements the usual Lagrange elements uses the <a class="el" href="classFE__Poly.html">FE_Poly</a> base class to generate a finite element by providing it with a set of Lagrange interpolation polynomials corresponding to an equidistant subdivision of interpolation points. Finally, the <a class="el" href="classFESystem.html">FESystem</a> class is used for vector-valued problems. There, one may want to couple a number of scalar (or also vector-valued) base elements together to form the joint finite element of a vector-valued operator. As an example, for 3d Navier-Stokes flow, one may want to use three Q1 elements for the three components of the velocity, and a piecewise constant Q0 element for the pressure. The <a class="el" href="classFESystem.html">FESystem</a> class can be used to couple these four base elements together into a single, vector-valued element with 4 vector components. The <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_17.html">step-17</a> , and <a class="el" href="step_18.html">step-18</a> tutorial programs give an introduction into the use of this class in the context of the vector-valued elasticity (Lam&eacute;) equations. <a class="el" href="step_20.html">step-20</a> discusses a mixed Laplace discretization that also uses vector-valued elements </td></tr>
<tr id="row_5_1_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_5_1_" class="arrow" onclick="toggleFolder('5_1_')">&#9660;</span><a class="el" href="group__feaccess.html" target="_self">Finite element access/FEValues classes</a></td><td class="desc">The classes in this module are used when one wants to assemble matrices or vectors. They link finite elements, quadrature objects, and mappings: the finite element classes describe a finite element space on a unit cell (i.e. the unit line segment, square, or cube <code>[0,1]^d</code>), the quadrature classes describe where quadrature points are located and what weight they have, and the mapping classes describe how to map a point from the unit cell to a real cell and back. Since integration happens at quadrature points on the real cell, and needs to know their location as well as the values and gradients of finite element shape functions at these points. The <a class="el" href="classFEValues.html">FEValues</a> class coordinates getting this information. For integrations on faces (for example for integration on the boundary, or interfaces between cells), the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> class offers similar functionality as the <a class="el" href="classFEValues.html">FEValues</a> class does for cells. Finally, the <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> class offers the possibility to ingrate on parts of faces if the neighboring cell is refined and the present cell shares only a part of its face with the neighboring cell. If vector-valued elements are used, the <a class="el" href="classFEValues.html">FEValues</a> and related classes allow access to all vector components; if one wants to pick individual components, there are extractor classes that make this task simpler, as described in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. The last member of this group, the UpdateFlags enumeration, is used as an optimization: instead of letting the <a class="el" href="classFEValues.html">FEValues</a> class compute every possible piece of data relating to a given finite element on a cell, you have to specify up front which information you are actually interested in. The UpdateFlags enumeration is used to offer symbolic names denoting what you want the <a class="el" href="classFEValues.html">FEValues</a> class to compute. All these classes are used in all <a class="el" href="Tutorial.html">tutorial programs</a> from <a class="el" href="step_3.html">step-3</a> onward, and are described there in significant detail. The actual workings of the <a class="el" href="classFEValues.html">FEValues</a> class and friends is complicated because it has to be general yet efficient. The page on <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> attempts to give an overview of how this works. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </td></tr>
<tr id="row_5_1_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group__vector__valued.html" target="_self">Handling vector valued problems</a></td><td class="desc">Vector-valued problems are systems of partial differential equations. These are problems where the solution variable is not a scalar function, but a vector-valued function or a set of functions. This includes, for example: </td></tr>
<tr id="row_5_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__fe.html" target="_self">Finite element space descriptions The classes here describe</a></td><td class="desc">Finite element spaces, such as the simplest Q1 (bi-/trilinear) spaces, and higher order Lagrangian spaces Qp, but also more specialized spaces such as Nedelec or Raviart-Thomas ones. Concrete implementations are derived from the abstract <a class="el" href="classFiniteElement.html">FiniteElement</a> base class. In essence, the functions these classes have to implement provide the ability to query the value or derivatives of a shape function at a given point on the unit cell. To be useful in integrating matrix and right hand side entries, one has to have the ability to map these shape functions and gradients to the real cell. This is done using classes derived from the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> base class (see <a class="el" href="group__mapping.html">Mappings between reference and real cell The classes in</a> ) in conjunction with the <a class="el" href="classFEValues.html">FEValues</a> class (see <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a> ) </td></tr>
<tr id="row_5_3_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__mapping.html" target="_self">Mappings between reference and real cell The classes in</a></td><td class="desc">This module are used to map from unit coordinates to the coordinates of a cell in real cell. Most commonly, one uses the <a class="el" href="classMappingQ1.html">MappingQ1</a> class that provides a Q1 (bi-/trilinear) mapping (i.e. a mapping that is isoparametric for the usual Q1 elements). However, there are other classes that implement higher-order mappings as well to provide for curvilinear elements. These are discussed in the <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_12.html">step-12</a> tutorial programs. The <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a> class is an extension to the <a class="el" href="classMappingQ1.html">MappingQ1</a> class in that it accepts a vector that describes a displacement field for each position of the domain. This is used in Eulerian computations without the need to actually move vertices after each time step. In addition, the <a class="el" href="classMappingC1.html">MappingC1</a> class provides for a boundary of the computational domain that is not only curved, but also has a continuous derivative at the interface between two cells on the boundary. Finally, the <a class="el" href="classMappingCartesian.html">MappingCartesian</a> class is an optimization for elements that are brick-shaped and with edges parallel to the coordinate axes. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </td></tr>
<tr id="row_5_4_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__FE__vs__Mapping__vs__FEValues.html" target="_self">How Mapping, FiniteElement, and</a></td><td class="desc"><a class="el" href="classFEValues.html">FEValues</a> work together </td></tr>
<tr id="row_5_5_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__UpdateFlags.html" target="_self">The interplay of UpdateFlags, Mapping, and</a></td><td class="desc"><a class="el" href="classFiniteElement.html">FiniteElement</a> in <a class="el" href="classFEValues.html">FEValues</a> </td></tr>
<tr id="row_5_6_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__vector__valued.html" target="_self">Handling vector valued problems</a></td><td class="desc">Vector-valued problems are systems of partial differential equations. These are problems where the solution variable is not a scalar function, but a vector-valued function or a set of functions. This includes, for example: </td></tr>
<tr id="row_6_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__functions.html" target="_self">Functions Functions are used in various places in</a></td><td class="desc">Deal.II, for example to describe boundary conditions, coefficients in equations, forcing terms, or exact solutions. Since closed form expressions for equations are often hard to pass along as function arguments, deal.II uses the <a class="el" href="classFunction.html">Function</a> base class to describe these objects. Essentially, the interface of this base class requires derived classes to implement the ability to return the value of a function at one or a list of particular locations, and possibly (if needed) of gradients or second derivatives of the function. With this, function objects can then be used by algorithms like <a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>, <a class="el" href="namespaceVectorTools.html#a747e71d426643718d52eda904d46bb20">VectorTools::project_boundary_values</a>, and other functions. Some functions are needed again and again, and are therefore already provided in deal.II. This includes a function with a constant value; a function that is zero everywhere, or a vector-valued function for which only one vector component has a particular value and all other components are zero. Some more specialized functions are also defined in the <a class="el" href="namespaceFunctions.html">Functions</a> namespace </td></tr>
<tr id="row_7_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__geodynamics.html" target="_self">The geodynamics demonstration suite</a></td><td class="desc">Deal.II's <a class="el" href="Tutorial.html">tutorial</a> contains a set of programs that togetherform the geodynamics demonstration suite. The idea of these programs is todemonstrate techniques for advanced finite element software usingapplications from geodynamics, i.e. the investigation of processes in thesolid earth. By doing so, these programs are supposed to provide a basisfor more specialized, dedicated programs that can solve actual geodynamicsproblems, for example as part of the work of graduate students orpostdocs. A more thorough discussion of the motivation for these programsfollows below. Currently, the geodynamics testsuite contains the followingprograms: </td></tr>
<tr id="row_8_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__geomprimitives.html" target="_self">Geometric and other primitives This group contains</a></td><td class="desc">Number of classes that act as geometric primitives or primitives for other mathematical objects. For example, the <a class="el" href="classTensor.html">Tensor</a> &lt;rank,dim&gt; class provides tensors of rank <code>rank</code> in <code>dim</code> space dimensions. Likewise, the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> offers symmetric tensors. Geometrically, the <a class="el" href="classPoint.html">Point</a> class is the foundation of all geometric descriptions in the deal.II library. It denotes a geometric point in <code>dim</code> dimensional space. One can view a point as a vector the with <code>dim</code> coordinates that connects the origin with that particular point; as such, the <a class="el" href="classPoint.html">Point</a> class is derived from tensors of rank 1 (i.e. vectors), but in contrast to arbitrary tensors points have the special connotation of points in space, and therefore have some additional properties. In deal.II, meshes are built from line segments, quadrilaterals, or hexahedra (depending on the space dimension). The <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class is used to describe properties of these basic objects in unit space (i.e. for the unit line, unit square, and unit cube). It offers static data members denoting the number of vertices per cell, lines per face, or where which vertex is located. This abstraction allows to write applications mostly independently of the actual space dimension: loops over all vertices would simply run from zero to <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a> instead of from 0 to 4 (in 2d) or 0 to 8 (in 3d). In this way, the program will be correct in 2d as well as 3d, and one can run a program in a different space dimension simply by recompilation instead of having to change a significant portion of the code. These dimension-independent programming techniques are extensively discussed in the first few tutorial programs and are used throughout deal.II </td></tr>
<tr id="row_9_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_9_" class="arrow" onclick="toggleFolder('9_')">&#9660;</span><a class="el" href="group__grid.html" target="_self">Grids and Triangulations This module groups functions and</a></td><td class="desc">Classes that have to do with the topology and geometry of meshes. A mesh can be thought of as a collection of cells; if the mesh has been refined (possibly in an adaptive way), then this collection is grouped into a hierarchy of refinement levels. In addition to cells, the geometric objects that make up a triangulation are the faces of cells (and in 3d the edges of cells) as well as the vertices of the cells. Note that we abuse the word <em>triangulation</em> somewhat, since deal.II only implements triangulations made up of linear, quadrilateral, and hexahedral cells; triangles and tetrahedra are not supported. This collection of cells is managed by the <a class="el" href="classTriangulation.html">Triangulation</a> class and derived classes such as <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. It holds the relevant data in memory and offers interfaces to query it. Most things you want to do on cells are performed in loops over all cells. For this purpose, the <a class="el" href="classTriangulation.html">Triangulation</a> class offers the concept of iterators (see <a class="el" href="group__Iterators.html">Iterators on mesh-like containers @{</a> ): although implemented differently, they behave like pointers to cells or faces and can be queried for the geometric properties of cells as well as information like neighboring cells or faces of a cell. It is worth noting that the <a class="el" href="classTriangulation.html">Triangulation</a> class only stores geometry (i.e. the location of vertices and cells) and topology of a mesh (i.e. which cells are neighbors of which other cells, etc). It has nothing to do with finite elements or degrees of freedom that might be defined on a mesh. These functions are performed by the <a class="el" href="classDoFHandler.html">DoFHandler</a> class (see the <a class="el" href="group__dofs.html">Degrees of Freedom This module groups classes and namespaces</a> module) that gets a description of the finite element space and the allocates and manages degrees of freedom on vertices, faces, or cells, as described by the finite element class. This separation makes it possible to have multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> classes work on the same mesh at the same time. In the grand scheme of things, triangulations in deal.II interact with a variety of other parts of the library: </td></tr>
<tr id="row_9_0_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_9_0_" class="arrow" onclick="toggleFolder('9_0_')">&#9660;</span><a class="el" href="group__Iterators.html" target="_self">Iterators on mesh-like containers     @{</a></td><td class="desc">Deal.II has several classes which are understood conceptually asmeshes. Apart from the obvious <a class="el" href="classTriangulation.html">Triangulation</a>, these are, for example,<a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>. All of those define a setof iterators, allowing the user to traverse the whole mesh, i.e. theset of cells, faces, edges, etc that comprise the mesh, or portions ofit. These iterators are all in a sense derived from the TriaIteratorclass. Basically, the template signature of <a class="el" href="classTriaIterator.html">TriaIterator</a> is </td></tr>
<tr id="row_9_0_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group__Accessors.html" target="_self">Accessor classes of the mesh iterators</a></td><td class="desc"></td></tr>
<tr id="row_9_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__manifold.html" target="_self">Manifold description for triangulations</a></td><td class="desc"></td></tr>
<tr id="row_9_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__reordering.html" target="_self">Grid reordering and cell orientation</a></td><td class="desc">A module describing how deal.II consistently orients <a class="el" href="classTriangulation.html">Triangulation</a> objects </td></tr>
<tr id="row_10_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_10_" class="arrow" onclick="toggleFolder('10_')">&#9660;</span><a class="el" href="group__hp.html" target="_self">hp-finite element support Classes and functions that have to</a></td><td class="desc">Do with hp-finite elements. The <a class="el" href="step_27.html">step-27</a> tutorial program gives an overview of how to use the classes in this namespace. A slightly more exotic application is given in <a class="el" href="step_46.html">step-46</a> . The hp-namespace implements the algorithms and data structures used for the hp-framework in deal.II. An overview over the details of how these algorithms work and what data structures are used is given in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a> </td></tr>
<tr id="row_10_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__hpcollection.html" target="_self">hp-Collections In the implementation of the</a></td><td class="desc">Hp-finite element method, each cell might have a different finite element associated with it. To handle this, the <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> must have a whole set of finite element classes associated with it. This concept is represented by the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class: Objects of this type act as containers that hold a whole set of finite element objects. Instead of storing pointers to finite element objects on each cell, we then only store an index for each cell that identifies the finite element object within the collection that should be used by this cell. The <a class="el" href="classDoFHandler.html">DoFHandler</a> object associated with the given cell can then assign degrees of freedom to each cell in accordance with the finite element used for it. A similar situation arises when integrating terms on a cell: one may want to use different quadrature formulas for different finite elements. For example, on cells where we use a Q1 element, a <a class="el" href="vector__tools__integrate__difference__0_8txt.html#ab24469127f1997c40730327503fd684a">QGauss(2)</a> object (i.e. a quadrature formula with two points in each space direction) may be sufficient, but on another cell where a Q3 element is used, this would lead to underintegration and we should use a <a class="el" href="hp__0_8txt.html#aae852286c2ae8c0fc2705f3aa25d0ea1">QGauss(4)</a> formula instead. Just as above, there exists a class <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> that acts as a collection of quadrature formulas. Finally, one may want to use different orders for the boundary approximation for cells with different orders for the finite element. The <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> class allows to do this. All of these three classes, the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>, and <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> classes, implement an interface very similar to that of <code>std::vector</code> . They have functions <code><a class="el" href="q__collection__0_8txt.html#a98a6b91a750cdd7301bb66162fa71e80">push_back()</a></code> to add a finite element, quadrature formula, or mapping to the collection. They have an <code>operator[] (unsigned int)</code> function that allows to retrieve a reference to a given element of the collection. And they have a <code><a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a></code> function that returns the number of elements in the collection. Some of the classes, in particular that holding finite element objects, also implement other functions specific to their purpose. The similarity goes beyond the interface: When adding an element to the collection, all of the classes create a copy of the argument. This allows to pass a temporary object to the function adding the element. For example, the following works: </td></tr>
<tr id="row_11_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_11_" class="arrow" onclick="toggleFolder('11_')">&#9660;</span><a class="el" href="group__Integrators.html" target="_self">Integrators A collection of namespaces and functions</a></td><td class="desc">Which simplify the coding of forms and bilinear forms on finite element spaces. <a class="el" href="namespaceFunctions.html">Functions</a> for two different purposes are gathered here: the abstract integration on finite element meshes in <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and actual implementations of the integration of cell and face terms for concrete problems in <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces This namespace contains application specific local integral...">LocalIntegrators</a> </td></tr>
<tr id="row_11_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__MeshWorker.html" target="_self">The MeshWorker interface A collection of classes and</a></td><td class="desc"><a class="el" href="namespaceFunctions.html">Functions</a> simplifying the coding of loops over all cells and faces. All classes and functions of this module are in the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> namespace, which also contains documentation on the usage </td></tr>
<tr id="row_12_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_12_" class="arrow" onclick="toggleFolder('12_')">&#9660;</span><a class="el" href="group__IO.html" target="_self">Input/Output This module collects the classes used for reading</a></td><td class="desc">And writing meshes and data. There are two sub-modules for each of these operations </td></tr>
<tr id="row_12_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__input.html" target="_self">Input deal.II can read meshes in a number of different</a></td><td class="desc">Formats. However, all of them are constrained to so-called "coarse meshes", i.e. meshes that have no refinement hierarchy and in particular no hanging nodes. The <a class="el" href="classGridIn.html">GridIn</a> class describes in detail what formats are supported. In addition, deal.II can read an intermediate graphics format using the <a class="el" href="classDataOutReader.html">DataOutReader</a>. This format is used as an intermediate step between data associated with a simulation and is written by the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class (or through the more derived classes described in the <a class="el" href="group__output.html">Graphical output deal.II generates three types of output:</a> module). The <a class="el" href="classDataOutReader.html">DataOutReader</a> class reads this data back in, and it can then be converted to any of a number of data formats supported by visualization programs. Finally, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> classes (and the associated <a class="el" href="namespacePatterns.html">Patterns</a> namespace) are used to deal with parameter files describing run-time parameters to a program that one doesn't want to hard-code within the program source </td></tr>
<tr id="row_12_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__output.html" target="_self">Graphical output deal.II generates three types of output:</a></td><td class="desc">It can write triangulations/meshes in formats understood by several mesh readers (including those of deal.II itself), and it can create output used for visualization of data. Finally, it can output matrices in a graphical format </td></tr>
<tr id="row_12_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__textoutput.html" target="_self">Textual output</a></td><td class="desc">In addition to classes that provide graphical output formats (see the <a class="el" href="group__output.html">Graphical output deal.II generates three types of output:</a> module), deal.II has a number of classes that facilitate textual output in a number of ways. They are collected in this module. See the documentation of these classes for more details </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_13_" class="arrow" onclick="toggleFolder('13_')">&#9660;</span><a class="el" href="group__LAC.html" target="_self">Linear algebra classes This module contains classes that</a></td><td class="desc">Involve linear algebra, i.e., those associated with matrices, vectors, and the solution of linear systems. The description of individual groups of classes can be found in sub-modules. The files implementing linear algebra functionality are in the <code>lac</code> subdirectory, an abbreviation for <em> L </em> inear <em> A </em> lgebra <em> C </em> lasses </td></tr>
<tr id="row_13_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__LAOperators.html" target="_self">Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;</a></td><td class="desc">Deal.II includes support for describing linear transformations in a very general way. This is done with a <a class="el" href="classLinearOperator.html">LinearOperator</a> class that, like <a class="el" href="group__Concepts.html#ConceptMatrixType">the MatrixType concept</a>, defines a minimal interface for <em>applying</em> a linear operation on a vector </td></tr>
<tr id="row_13_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_13_1_" class="arrow" onclick="toggleFolder('13_1_')">&#9660;</span><a class="el" href="group__Matrices.html" target="_self">Matrix classes</a></td><td class="desc">Deal.II comes with a number of different matrix classes, tailored to the various purposes for which matrices are used. For example, there are full matrices, sparse matrices using different storage schemes, matrices composed of individual blocks, and matrices implemented as interfaces to other linear algebra classes. As far as possible, all these implementations share a common interface that contains at least the operations necessary to write iterative linear solvers (see <a class="el" href="group__Solvers.html">Linear solver classes</a> ), but also element-wise access to read from and write to a matrix. <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a> are matrix classes as well, since they perform linear operations on vectors </td></tr>
<tr id="row_13_1_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_13_1_0_" class="arrow" onclick="toggleFolder('13_1_0_')">&#9660;</span><a class="el" href="group__Matrix1.html" target="_self">Basic matrices</a></td><td class="desc">These are the actual matrix classes provided by deal.II. It is possible to store values in them and retrieve them. Furthermore, they provide the full interface required by linear solvers (see <a class="el" href="group__Solvers.html">Linear solver classes</a> ). Among the matrices in this group are full matrices, different sparse matrices, and block matrices. In addition, some of the classes in the interfaces to other linear algebra libraries (for example the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a>) are matrices. Most of the deal.II sparse matrix classes are separated from their sparsity patterns, to make storing several matrices with the same sparsity pattern more efficient. See <a class="el" href="group__Sparsity.html">Sparsity patterns Almost all finite element formulations</a> for more information </td></tr>
<tr id="row_13_1_0_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_13_1_0_0_" class="arrow" onclick="toggleFolder('13_1_0_0_')">&#9660;</span><a class="el" href="group__Exceptions.html" target="_self">Exceptions and assertions This module contains classes</a></td><td class="desc">That are used in the exception mechanism of deal.II </td></tr>
<tr id="row_13_1_0_0_0_" class="even"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_1_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group__Matrix2.html" target="_self">Derived matrices</a></td><td class="desc">These matrices are built on top of the basic matrices. They perform special operations using the interface defined by <a class="el" href="group__Concepts.html#ConceptMatrixType">the MatrixType concept</a> </td></tr>
<tr id="row_13_1_2_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_13_1_2_" class="arrow" onclick="toggleFolder('13_1_2_')">&#9660;</span><a class="el" href="group__Preconditioners.html" target="_self">Preconditioners and Relaxation Operators</a></td><td class="desc"></td></tr>
<tr id="row_13_1_2_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_13_1_2_0_" class="arrow" onclick="toggleFolder('13_1_2_0_')">&#9660;</span><a class="el" href="group__Exceptions.html" target="_self">Exceptions and assertions This module contains classes</a></td><td class="desc">That are used in the exception mechanism of deal.II </td></tr>
<tr id="row_13_1_2_0_0_" class="even"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_2_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_13_2_" class="arrow" onclick="toggleFolder('13_2_')">&#9660;</span><a class="el" href="group__PETScWrappers.html" target="_self">PETScWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the PETSc library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></code>. These classes are only available if a PETSc installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_2_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><a class="el" href="group__SLEPcWrappers.html" target="_self">SLEPcWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the SLEPc library. All classes and functions in this group reside in a namespace <code><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></code>. These classes are only available if a SLEPc installation and a PETSc installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_13_3_" class="arrow" onclick="toggleFolder('13_3_')">&#9660;</span><a class="el" href="group__Preconditioners.html" target="_self">Preconditioners and Relaxation Operators</a></td><td class="desc"></td></tr>
<tr id="row_13_3_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_13_3_0_" class="arrow" onclick="toggleFolder('13_3_0_')">&#9660;</span><a class="el" href="group__Exceptions.html" target="_self">Exceptions and assertions This module contains classes</a></td><td class="desc">That are used in the exception mechanism of deal.II </td></tr>
<tr id="row_13_3_0_0_"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_4_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__SLEPcWrappers.html" target="_self">SLEPcWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the SLEPc library. All classes and functions in this group reside in a namespace <code><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></code>. These classes are only available if a SLEPc installation and a PETSc installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_5_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__Solvers.html" target="_self">Linear solver classes</a></td><td class="desc">In order to work properly, solvers that take matrix and vector classes as template arguments require that these classes satisfy a certain minimal interface that can be used from inside the solver. For iterative solvers, this interface is defined in the Solver class. In addition, solvers are controlled using objects of classes that are derived from the <a class="el" href="classSolverControl.html">SolverControl</a> class (for example its derived class <a class="el" href="classReductionControl.html">ReductionControl</a>), in order to determine the maximal number of iterations or a desired tolerance. If detected during configuration (see the ReadMe file), some sparse direct solvers are also supported </td></tr>
<tr id="row_13_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_13_6_" class="arrow" onclick="toggleFolder('13_6_')">&#9660;</span><a class="el" href="group__Sparsity.html" target="_self">Sparsity patterns Almost all finite element formulations</a></td><td class="desc">Lead to matrices that are "sparse", i.e., for which the number of nonzero elements per row is (i) relatively small compared to the overall size of the matrix, and (ii) bounded by a fixed number that does not grow if the mesh is refined. For such cases, it is more efficient to not store <em>all</em> elements of the matrix, but only those that are actually (or may be) nonzero. This requires storing, for each row, the column indices of the nonzero entries (we call this the "sparsity pattern") as well as the actual values of these nonzero entries. (In practice, it sometimes happens that some of the nonzero values are, in fact, zero. Sparsity patterns and sparse matrices only intend to provision space for entries that <em>may</em> be nonzero, and do so at a time when we don't know yet what values these entries will ultimately have; they may have a zero value if a coefficient or cell happens to have particular values.) In deal.II, sparsity patterns are typically separated from the actual sparse matrices (with the exception of the <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a> class and some classes from interfaces to external libraries such as PETSc). The reason is that one often has several matrices that share the same sparsity pattern; examples include the stiffness and mass matrices necessary for time stepping schemes, or the left and right hand side matrix of generalized eigenvalue problems. It would therefore be wasteful if each of them had to store their sparsity pattern separately. Consequently, deal.II has sparsity pattern classes that matrix classes build on. There are two main groups of sparsity pattern classes, as discussed below: </td></tr>
<tr id="row_13_6_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_13_6_0_" class="arrow" onclick="toggleFolder('13_6_0_')">&#9660;</span><a class="el" href="group__Exceptions.html" target="_self">Exceptions and assertions This module contains classes</a></td><td class="desc">That are used in the exception mechanism of deal.II </td></tr>
<tr id="row_13_6_0_0_" class="even"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_7_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_13_8_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__VMemory.html" target="_self">Vector memory management This module groups a few classes</a></td><td class="desc">That are used to avoid allocating and deallocating vectors over and over in iterative procedures. These methods all use an object of the base class <a class="el" href="classVectorMemory.html">VectorMemory</a> to get their auxiliary vectors. Some discussion on this topic can be found in the discussion of the InverseMatrix class in <a class="el" href="step_20.html">step-20</a> </td></tr>
<tr id="row_13_9_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_13_9_" class="arrow" onclick="toggleFolder('13_9_')">&#9660;</span><a class="el" href="group__Vectors.html" target="_self">Vector classes</a></td><td class="desc">Here, we list all the classes that satisfy the <code>VectorType</code> concept and may be used in linear solvers (see <a class="el" href="group__Solvers.html">Linear solver classes</a> ) and for matrix-vector operations </td></tr>
<tr id="row_13_9_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_13_9_0_" class="arrow" onclick="toggleFolder('13_9_0_')">&#9660;</span><a class="el" href="group__Exceptions.html" target="_self">Exceptions and assertions This module contains classes</a></td><td class="desc">That are used in the exception mechanism of deal.II </td></tr>
<tr id="row_13_9_0_0_"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><a class="el" href="group__TrilinosWrappers.html" target="_self">TrilinosWrappers The classes in this module are</a></td><td class="desc">Wrappers around functionality provided by the Trilinos library. They provide a modern object-oriented interface that is compatible with the interfaces of the other linear algebra classes in deal.II. All classes and functions in this group reside in a namespace <code><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></code>. These classes are only available if a Trilinos installation was detected during configuration of deal.II. Refer to the README file for more details about this </td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__matrixfree.html" target="_self">Matrix-free infrastructure This module describes the</a></td><td class="desc">Matrix-free infrastructure in deal.II. An outline of how the primary groups of classes in deal.II interact with the matrix-free infrastructure is given by the following clickable graph, with a more detailed description below: </td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__mg.html" target="_self">Multilevel support Classes that have to do with multigrid</a></td><td class="desc"><a class="el" href="namespaceAlgorithms.html">Algorithms</a>. The main class with implementation of the multigrid scheme is <a class="el" href="classMultigrid.html">Multigrid</a> with its function <a class="el" href="classMultigrid.html#a0aee21aa90596848542153764f94345b">Multigrid::cycle()</a>. It uses the following abstract classes in order to perform the multigrid cycle: </td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__numerics.html" target="_self">Numerical algorithms This module groups a diverse set of</a></td><td class="desc">Classes that generally implement some sort of numerical algorithm on top all the basic triangulation, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and finite element classes in the library. They are generally unconnected to each other. Some of the classes, like <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a>, <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> and <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>, act on solutions already obtained, and compute derived quantities in the first two cases, or help transferring a set of vectors from one mesh to another. The namespaces <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a>, <a class="el" href="namespaceMatrixTools.html">MatrixTools</a>, and <a class="el" href="namespaceVectorTools.html">VectorTools</a> provide an assortment of services, such as creating a Laplace matrix, projecting or interpolating a function onto the present finite element space, etc. The difference to the functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a> and <a class="el" href="namespaceFETools.html">FETools</a> functions is that they work on vectors (i.e. members of a finite element function space on a given triangulation) or help in the creation of it. On the other hand, the <a class="el" href="namespaceDoFTools.html">DoFTools</a> functions only act on a given <a class="el" href="classDoFHandler.html">DoFHandler</a> object without reference to a data vector, and the <a class="el" href="namespaceFETools.html">FETools</a> objects generally work with finite element classes but again without any associated data vectors </td></tr>
<tr id="row_17_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_17_" class="arrow" onclick="toggleFolder('17_')">&#9660;</span><a class="el" href="group__Parallel.html" target="_self">Parallel computing</a></td><td class="desc">A module discussing the use of multiple processors. This module contains information on parallel computing. It is subdivided into parts on <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> and on <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> </td></tr>
<tr id="row_17_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__distributed.html" target="_self">Parallel computing with multiple processors using</a></td><td class="desc">Distributed memory </td></tr>
<tr id="row_17_1_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__threads.html" target="_self">Parallel computing with multiple processors accessing</a></td><td class="desc">Shared memory </td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__physics.html" target="_self">Physics</a></td><td class="desc">A module dedicated to the implementation of functions and classes that relate to continuum physics, physical fields and materials </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__Polynomials.html" target="_self">Polynomials and polynomial spaces This module groups</a></td><td class="desc">Classes that define certain families of polynomial functions. In particular, this includes Lagrangian interpolation polynomials for equidistant support points and their tensor products in higher dimensions, but also more exotic ones like Brezzi-Douglas-Marini or Raviart-Thomas spaces </td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__Quadrature.html" target="_self">Quadrature formulas This module contains the base</a></td><td class="desc">Class <a class="el" href="classQuadrature.html">Quadrature</a> as well as the quadrature formulas provided by deal.II. <a class="el" href="classQuadrature.html">Quadrature</a> formulas provide two essential pieces of data: the locations of quadrature points on the unit cell [0,1]^d, and the weight of each quadrature point. Since deal.II uses quadrilaterals and hexahedra, almost all quadrature formulas are generated as tensor products of 1-dimensional quadrature formulas defined on the unit interval [0,1], which makes their definition for the higher-dimensional case almost trivial. However, the library also allows anisotropic tensor products (more quadrature points in one coordinate direction than in another) through the <a class="el" href="classQAnisotropic.html">QAnisotropic</a> class, as well as the definition of quadrature formulas that are not tensor products. In the grand scheme of things, the classes of this module interact with a variety of other parts of the library: </td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__simplex.html" target="_self">Simplex support (experimental)</a></td><td class="desc">This module describes the experimental simplex support in deal.II. Simplex and mixed meshes in deal.II are still experimental, i.e., work in progress. Large parts of the library have been ported to be able to operate on such kind of meshes. However, there are still many functions that need to be generalized. You can get a good overview of the ported functionalities by taking a look at the tests in the folder "tests/simplex". In the following, we provide two very basic examples to get started and provide some implementation details </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_22_" class="arrow" onclick="toggleFolder('22_')">&#9660;</span><a class="el" href="group__utilities.html" target="_self">Utility functions and classes This module simply</a></td><td class="desc">Collects a number of functions and classes that provide general tools for tasks that do not usually have much to do with finite element programs in particular, but happen to be required there just as well </td></tr>
<tr id="row_22_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__memory.html" target="_self">Memory handling This group has some basic classes and</a></td><td class="desc">Namespaces for memory handling. The <a class="el" href="classSubscriptor.html">Subscriptor</a> and <a class="el" href="classSmartPointer.html">SmartPointer</a> classes are used for counted memory handling, i.e. whenever a <a class="el" href="classSmartPointer.html">SmartPointer</a> is set to point to an object, it increases a counter in that object; when the pointer is set to point elsewhere, it decreases it again. This way, one always knows how many users of an object there still are. While this is rarely useful in itself, it is used to generate an exception if an object is destroyed while a pointer somewhere is still pointing to it, as any access through that pointer at a later time would otherwise lead to access of invalid memory regions. In contrast to this, the <a class="el" href="namespaceMemoryConsumption.html">MemoryConsumption</a> namespace provides functions that can be used to determine the memory consumption of objects. For some simple classes, like the standard library containers, it directly determines how much memory they need (or at least gives an estimate). For deal.II classes, it uses the <code>memory_consumption</code> member function that most classes have </td></tr>
<tr id="row_22_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><a class="el" href="group__data.html" target="_self">Data storage primitives Here are a few simple classes that</a></td><td class="desc">Help in storage and viewing data. For example, the <a class="el" href="classTable.html">Table</a> templates allow to use not only arrays of objects (for which one might want to use the std::vector class), but also two-dimensional (rectangular) tables of arbitrary objects, as well as higher-order analogs up to tables with (presently) seven indices. Similarly, the VectorSlice function is a primitive that takes anything that has an interface that resembles a vector (for example the deal.II <a class="el" href="classVector.html">Vector</a> or the std::vector classes) and presents a view on it as if it were a vector in itself </td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><a class="el" href="group__OpenCASCADE.html" target="_self">@{</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
