<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classArborXWrappers_1_1BVH.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ArborXWrappers::BVH Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceArborXWrappers.html">ArborXWrappers</a></li><li class="navelem"><a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classArborXWrappers_1_1BVH-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArborXWrappers::BVH Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="arborx_2bvh_8h_source.html">deal.II/arborx/bvh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a7fdceb93b7c7a94ec7042aa48232f4e0">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;bounding_boxes)</td></tr>
<tr class="separator:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a424efa29fe23a86056aa6642527534ad">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>)</td></tr>
<tr class="separator:a424efa29fe23a86056aa6642527534ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0351b0a05e368ccd3201cbef3f09a0"><td class="memTemplParams" colspan="2">template&lt;typename QueryType &gt; </td></tr>
<tr class="memitem:a6b0351b0a05e368ccd3201cbef3f09a0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a6b0351b0a05e368ccd3201cbef3f09a0">query</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;queries)</td></tr>
<tr class="separator:a6b0351b0a05e368ccd3201cbef3f09a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a7fdceb93b7c7a94ec7042aa48232f4e0">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;bounding_boxes)</td></tr>
<tr class="separator:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a424efa29fe23a86056aa6642527534ad">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>)</td></tr>
<tr class="separator:a424efa29fe23a86056aa6642527534ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666b1affac50c8cfb9c717928ddfd19"><td class="memTemplParams" colspan="2">template&lt;typename QueryType &gt; </td></tr>
<tr class="memitem:a3666b1affac50c8cfb9c717928ddfd19"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a3666b1affac50c8cfb9c717928ddfd19">query</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;queries)</td></tr>
<tr class="separator:a3666b1affac50c8cfb9c717928ddfd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a7fdceb93b7c7a94ec7042aa48232f4e0">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;bounding_boxes)</td></tr>
<tr class="separator:a7fdceb93b7c7a94ec7042aa48232f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a424efa29fe23a86056aa6642527534ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a424efa29fe23a86056aa6642527534ad">BVH</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>)</td></tr>
<tr class="separator:a424efa29fe23a86056aa6642527534ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666b1affac50c8cfb9c717928ddfd19"><td class="memTemplParams" colspan="2">template&lt;typename QueryType &gt; </td></tr>
<tr class="memitem:a3666b1affac50c8cfb9c717928ddfd19"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a3666b1affac50c8cfb9c717928ddfd19">query</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;queries)</td></tr>
<tr class="separator:a3666b1affac50c8cfb9c717928ddfd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a574f557eb7c575c66e7ed253edd9f974"><td class="memItemLeft" align="right" valign="top">ArborX::BVH&lt; Kokkos::HostSpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a></td></tr>
<tr class="separator:a574f557eb7c575c66e7ed253edd9f974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper around ArborX::BVH. <a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a> stands for Bounding Volume Hierarchy. From <a href="https://en.wikipedia.org/wiki/Bounding_Volume_Hierarchy">Wikipedia</a>: </p><blockquote class="doxtable">
<p>A bounding volume hierarchy (<a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a>) is a tree structure on a set of geometric objects. All geometric objects are wrapped in bounding volumes that form the leaf nodes of the tree. These nodes are then grouped as small sets and enclosed within larger bounding volumes. These, in turn, are also grouped and enclosed within other larger bounding volumes in a recursive fashion, eventually resulting in a tree structure with a single bounding volume at the top of the tree. Bounding volume hierarchies are used to support several operations on sets of geometric objects efficiently, such as in collision detection and ray tracing. </p>
</blockquote>
<p>Because <a class="el" href="namespaceArborX.html">ArborX</a> uses Kokkos, Kokkos needs to be initialized and finalized before using this class. </p>

<p class="definition">Definition at line <a class="el" href="arborx_2bvh_8h_source.html#l00053">53</a> of file <a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7fdceb93b7c7a94ec7042aa48232f4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdceb93b7c7a94ec7042aa48232f4e0">&#9670;&nbsp;</a></span>BVH() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounding_boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <a class="el" href="classBoundingBox.html">BoundingBox</a> <code>bounding_boxes</code> as primitives. </p>

<p class="definition">Definition at line <a class="el" href="arborx_2bvh_8h_source.html#l00139">139</a> of file <a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a>.</p>

</div>
</div>
<a id="a424efa29fe23a86056aa6642527534ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424efa29fe23a86056aa6642527534ad">&#9670;&nbsp;</a></span>BVH() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <code>points</code> as primitives. </p>

<p class="definition">Definition at line <a class="el" href="arborx_2bvh_8h_source.html#l00146">146</a> of file <a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a>.</p>

</div>
</div>
<a id="a7fdceb93b7c7a94ec7042aa48232f4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdceb93b7c7a94ec7042aa48232f4e0">&#9670;&nbsp;</a></span>BVH() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounding_boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <a class="el" href="classBoundingBox.html">BoundingBox</a> <code>bounding_boxes</code> as primitives. </p>

</div>
</div>
<a id="a424efa29fe23a86056aa6642527534ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424efa29fe23a86056aa6642527534ad">&#9670;&nbsp;</a></span>BVH() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <code>points</code> as primitives. </p>

</div>
</div>
<a id="a7fdceb93b7c7a94ec7042aa48232f4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdceb93b7c7a94ec7042aa48232f4e0">&#9670;&nbsp;</a></span>BVH() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounding_boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <a class="el" href="classBoundingBox.html">BoundingBox</a> <code>bounding_boxes</code> as primitives. </p>

</div>
</div>
<a id="a424efa29fe23a86056aa6642527534ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424efa29fe23a86056aa6642527534ad">&#9670;&nbsp;</a></span>BVH() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArborXWrappers::BVH::BVH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use a vector of <code>points</code> as primitives. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6b0351b0a05e368ccd3201cbef3f09a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0351b0a05e368ccd3201cbef3f09a0">&#9670;&nbsp;</a></span>query() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename QueryType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &gt; ArborXWrappers::BVH::query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;&#160;</td>
          <td class="paramname"><em>queries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the indices of those <a class="el" href="classBoundingBox.html">BoundingBox</a> objects that satisfy the <code>queries</code>. Because <code>queries</code> can contain multiple queries, the function returns a pair of indices and offsets. Below is an example piece of code that does the following: Let us assume that we have a set of bounding boxes for objects</p>
<ul>
<li>say, the bounding boxes of each of the cells in a triangulation, or the bounding boxes for each of the parts of a triangulation in a parallel triangulation. We will store those in the <code>bvh_bounding_boxes</code> array below. Let us then also assume that we have a set of other bounding boxes, let's say for small objects that are moving around in our domain. We will put these bounding boxes into the <code>bb_intersect</code> array. The question we would then like to answer is the following: with which of the <a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a> bounding box(es) do each of the bb_intersect bounding boxes intersect? In other words, in which cell(s) or partition(s) are the particles? This query is answered by the following piece of code: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; query_bounding_boxes = ...</div>
<div class="line">ArborXWrappers::BoundingBoxIntersectPredicate</div>
<div class="line">bb_intersect(query_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(bb_intersect);</div>
</div><!-- fragment --> The elements of <code>bvh_bounding_boxes</code> that intersect the <code>j</code>th <a class="el" href="classBoundingBox.html">BoundingBox</a> of <code>query_bounding_boxes</code> are given by: <div class="fragment"><div class="line">std::vector&lt;int&gt; bvh_bounding_box_indices;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>+1]; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">bvh_bounding_box_indices.push_back(<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]);</div>
</div><!-- fragment --> In many other applications, we are interested not only in finding which bounding boxes another bounding box lies in, but in fact which bounding boxes individual points lie in</li>
<li>say, if instead of objects we have point-like particles moving around. In that case, we would need to answer a query for points, and this can be done as follows: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointIntersectPredicate pt_intersect(query_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_intersect);</div>
</div><!-- fragment --> As a final example, we want to show how to find the five nearest points of a given set of points. This can done as follows: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointNearestPredicate pt_nearest(query_points, 5);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; bvh_points = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_nearest);</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arborx_2bvh_8h_source.html#l00154">154</a> of file <a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a>.</p>

</div>
</div>
<a id="a3666b1affac50c8cfb9c717928ddfd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3666b1affac50c8cfb9c717928ddfd19">&#9670;&nbsp;</a></span>query() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename QueryType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt; &gt; ArborXWrappers::BVH::query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;&#160;</td>
          <td class="paramname"><em>queries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the indices of those <a class="el" href="classBoundingBox.html">BoundingBox</a> objects that satisfy the <code>queries</code>. Because <code>queries</code> can contain multiple queries, the function returns a pair of indices and offsets.</p>
<p>Below is an example piece of code that does the following: Let us assume that we have a set of bounding boxes for objects &ndash; say, the bounding boxes of each of the cells in a triangulation, or the bounding boxes for each of the parts of a triangulation in a parallel triangulation. We will store those in the <code>bvh_bounding_boxes</code> array below.</p>
<p>Let us then also assume that we have a set of other bounding boxes, let's say for small objects that are moving around in our domain. We will put these bounding boxes into the <code>bb_intersect</code> array. The question we would then like to answer is the following: with which of the <a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a> bounding box(es) do each of the bb_intersect bounding boxes intersect? In other words, in which cell(s) or partition(s) are the particles?</p>
<p>This query is answered by the following piece of code:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; query_bounding_boxes = ...</div>
<div class="line">ArborXWrappers::BoundingBoxIntersectPredicate</div>
<div class="line">bb_intersect(query_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(bb_intersect);</div>
</div><!-- fragment --><p>The elements of <code>bvh_bounding_boxes</code> that intersect the <code>j</code>th <a class="el" href="classBoundingBox.html">BoundingBox</a> of <code>query_bounding_boxes</code> are given by:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; bvh_bounding_box_indices;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>+1]; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  bvh_bounding_box_indices.push_back(<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]);</div>
</div><!-- fragment --><p>In many other applications, we are interested not only in finding which bounding boxes another bounding box lies in, but in fact which bounding boxes individual points lie in &ndash; say, if instead of objects we have point-like particles moving around. In that case, we would need to answer a query for points, and this can be done as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointIntersectPredicate pt_intersect(query_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_intersect);</div>
</div><!-- fragment --><p>As a final example, we want to show how to find the five nearest points of a given set of points. This can done as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointNearestPredicate pt_nearest(query_points, 5);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; bvh_points = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_nearest);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3666b1affac50c8cfb9c717928ddfd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3666b1affac50c8cfb9c717928ddfd19">&#9670;&nbsp;</a></span>query() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename QueryType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt; &gt; ArborXWrappers::BVH::query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> QueryType &amp;&#160;</td>
          <td class="paramname"><em>queries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the indices of those <a class="el" href="classBoundingBox.html">BoundingBox</a> objects that satisfy the <code>queries</code>. Because <code>queries</code> can contain multiple queries, the function returns a pair of indices and offsets. Below is an example piece of code that does the following: Let us assume that we have a set of bounding boxes for objects</p>
<ul>
<li>say, the bounding boxes of each of the cells in a triangulation, or the bounding boxes for each of the parts of a triangulation in a parallel triangulation. We will store those in the <code>bvh_bounding_boxes</code> array below. Let us then also assume that we have a set of other bounding boxes, let's say for small objects that are moving around in our domain. We will put these bounding boxes into the <code>bb_intersect</code> array. The question we would then like to answer is the following: with which of the <a class="el" href="classArborXWrappers_1_1BVH.html">BVH</a> bounding box(es) do each of the bb_intersect bounding boxes intersect? In other words, in which cell(s) or partition(s) are the particles? This query is answered by the following piece of code: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; query_bounding_boxes = ...</div>
<div class="line">ArborXWrappers::BoundingBoxIntersectPredicate</div>
<div class="line">bb_intersect(query_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(bb_intersect);</div>
</div><!-- fragment --> The elements of <code>bvh_bounding_boxes</code> that intersect the <code>j</code>th <a class="el" href="classBoundingBox.html">BoundingBox</a> of <code>query_bounding_boxes</code> are given by: <div class="fragment"><div class="line">std::vector&lt;int&gt; bvh_bounding_box_indices;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; offset[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>+1]; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">bvh_bounding_box_indices.push_back(<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]);</div>
</div><!-- fragment --> In many other applications, we are interested not only in finding which bounding boxes another bounding box lies in, but in fact which bounding boxes individual points lie in</li>
<li>say, if instead of objects we have point-like particles moving around. In that case, we would need to answer a query for points, and this can be done as follows: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointIntersectPredicate pt_intersect(query_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;BoundingBox&lt;dim&gt;&gt; bvh_bounding_boxes = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_bounding_boxes);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_intersect);</div>
</div><!-- fragment --> As a final example, we want to show how to find the five nearest points of a given set of points. This can done as follows: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; query_points = ...</div>
<div class="line">ArborXWrappers::PointNearestPredicate pt_nearest(query_points, 5);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; bvh_points = ...</div>
<div class="line">ArborxWrappers::BVH <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>(bvh_points);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>, offset] = <a class="code" href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">bvh</a>.query(pt_nearest);</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a574f557eb7c575c66e7ed253edd9f974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574f557eb7c575c66e7ed253edd9f974">&#9670;&nbsp;</a></span>bvh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArborX::BVH&lt; Kokkos::HostSpace &gt; ArborXWrappers::BVH::bvh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying <a class="el" href="namespaceArborX.html">ArborX</a> object. </p>

<p class="definition">Definition at line <a class="el" href="arborx_2bvh_8h_source.html#l00133">133</a> of file <a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/arborx/<a class="el" href="arborx_2bvh_8h_source.html">bvh.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="aclassArborXWrappers_1_1BVH_html_a574f557eb7c575c66e7ed253edd9f974"><div class="ttname"><a href="classArborXWrappers_1_1BVH.html#a574f557eb7c575c66e7ed253edd9f974">ArborXWrappers::BVH::bvh</a></div><div class="ttdeci">ArborX::BVH&lt; Kokkos::HostSpace &gt; bvh</div><div class="ttdef"><b>Definition:</b> <a href="arborx_2bvh_8h_source.html#l00133">bvh.h:133</a></div></div>
<div class="ttc" id="agraph__coloring__0_8txt_html_a068d28578c03dd6b6bb6b32bf268eafd"><div class="ttname"><a href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a></div><div class="ttdeci">namespace containing functions that can color graphs ***Given two sets of indices that are assumed to be determine whether they will have a nonempty intersection The actual intersection is not computed[2.x.0] indices1 A set of indices</div><div class="ttdef"><b>Definition:</b> <a href="graph__coloring__0_8txt_source.html#l00006">graph_coloring_0.txt:6</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
