<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classUtilities_1_1MutableBind.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Utilities::MutableBind&lt; ReturnType, FunctionArgs &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceUtilities.html">Utilities</a></li><li class="navelem"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classUtilities_1_1MutableBind-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Utilities::MutableBind&lt; ReturnType, FunctionArgs &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2mutable__bind_8h_source.html">deal.II/base/mutable_bind.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0440f0acbbe43f70a8459920f842deaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> = <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt; typename std::remove_cv&lt; typename std::remove_reference&lt; FunctionArgs &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt;::type... &gt;</td></tr>
<tr class="separator:a0440f0acbbe43f70a8459920f842deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0440f0acbbe43f70a8459920f842deaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> = <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt; typename std::remove_cv&lt; typename std::remove_reference&lt; FunctionArgs &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt;::type... &gt;</td></tr>
<tr class="separator:a0440f0acbbe43f70a8459920f842deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0440f0acbbe43f70a8459920f842deaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> = <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt; typename std::remove_cv&lt; typename std::remove_reference&lt; FunctionArgs &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt;::type... &gt;</td></tr>
<tr class="separator:a0440f0acbbe43f70a8459920f842deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a15d154c59a216965f1dc00a06c2c2f38">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a15d154c59a216965f1dc00a06c2c2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a6568bec393e51e619eeb7aaf1b12bc6b">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a2384b48b967ad65d2c69a822eb1cc0c4">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>)</td></tr>
<tr class="separator:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187b6ecbd97e97a873042d885729605b"><td class="memItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a187b6ecbd97e97a873042d885729605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9892610afbf8e437530a3302c290a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a8c9892610afbf8e437530a3302c290a8">set_arguments</a> (<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a8c9892610afbf8e437530a3302c290a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a578c55f3364fa1ec7535b13c934a0ef9">set_arguments</a> (FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675baf4560885f06f27387bff9c1969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#ad675baf4560885f06f27387bff9c1969">parse_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;value_string, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;<a class="el" href="matrix__tools__0_8txt.html#a89429838236bf0ea63970a5629123256">pattern</a>= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &gt;::to_pattern())</td></tr>
<tr class="separator:ad675baf4560885f06f27387bff9c1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a15d154c59a216965f1dc00a06c2c2f38">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a15d154c59a216965f1dc00a06c2c2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a6568bec393e51e619eeb7aaf1b12bc6b">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a2384b48b967ad65d2c69a822eb1cc0c4">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>)</td></tr>
<tr class="separator:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187b6ecbd97e97a873042d885729605b"><td class="memItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a187b6ecbd97e97a873042d885729605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9892610afbf8e437530a3302c290a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a8c9892610afbf8e437530a3302c290a8">set_arguments</a> (<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a8c9892610afbf8e437530a3302c290a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a578c55f3364fa1ec7535b13c934a0ef9">set_arguments</a> (FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675baf4560885f06f27387bff9c1969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#ad675baf4560885f06f27387bff9c1969">parse_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;value_string, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;<a class="el" href="matrix__tools__0_8txt.html#a89429838236bf0ea63970a5629123256">pattern</a>= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &gt;::to_pattern())</td></tr>
<tr class="separator:ad675baf4560885f06f27387bff9c1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a15d154c59a216965f1dc00a06c2c2f38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a15d154c59a216965f1dc00a06c2c2f38">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a15d154c59a216965f1dc00a06c2c2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a6568bec393e51e619eeb7aaf1b12bc6b">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>, <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a6568bec393e51e619eeb7aaf1b12bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplParams" colspan="2">template&lt;class FunctionType &gt; </td></tr>
<tr class="memitem:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a2384b48b967ad65d2c69a822eb1cc0c4">MutableBind</a> (FunctionType <a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a>)</td></tr>
<tr class="separator:a2384b48b967ad65d2c69a822eb1cc0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187b6ecbd97e97a873042d885729605b"><td class="memItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a187b6ecbd97e97a873042d885729605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9892610afbf8e437530a3302c290a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a8c9892610afbf8e437530a3302c290a8">set_arguments</a> (<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;<a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a8c9892610afbf8e437530a3302c290a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a578c55f3364fa1ec7535b13c934a0ef9">set_arguments</a> (FunctionArgs &amp;&amp;... <a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a>)</td></tr>
<tr class="separator:a578c55f3364fa1ec7535b13c934a0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675baf4560885f06f27387bff9c1969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#ad675baf4560885f06f27387bff9c1969">parse_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;value_string, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;<a class="el" href="matrix__tools__0_8txt.html#a89429838236bf0ea63970a5629123256">pattern</a>= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; <a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &gt;::to_pattern())</td></tr>
<tr class="separator:ad675baf4560885f06f27387bff9c1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a65017f0855c402166a173b31079f0433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::function&lt; ReturnType(FunctionArgs...)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#a65017f0855c402166a173b31079f0433">function</a></td></tr>
<tr class="separator:a65017f0855c402166a173b31079f0433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35eb72f97066fb0958a08729e503d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html#ac35eb72f97066fb0958a08729e503d8b">arguments</a></td></tr>
<tr class="separator:ac35eb72f97066fb0958a08729e503d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ReturnType, class... FunctionArgs&gt;<br />
class Utilities::MutableBind&lt; ReturnType, FunctionArgs &gt;</h3>

<p>A mutable version of std::bind, that binds all arguments of a function pointer to a stored tuple, and allows you to update the tuple between calls. An example usage of this class is through the helper function <a class="el" href="namespaceUtilities.html#ad438b60a6bc84b8b9d27e7063853a6f5">mutable_bind()</a> that creates a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object on the fly, based on its arguments: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_function(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;<a class="code" href="function__tools__0_8txt.html#a1a2acf608502527a80c0aeecdc12c908">a</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="mg__0_8txt.html#a05d914308ac970c97c941a291a81ccc1">b</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a> = <a class="code" href="namespaceUtilities.html#ad438b60a6bc84b8b9d27e7063853a6f5">mutable_bind</a>(my_function, 1, 2.0);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a>(); <span class="comment">// will execute my_function(1, 2.0);</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a>.set_arguments(2, 3.0);</div>
<div class="line"><a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a>(); <span class="comment">// will execute my_function(2, 3.0);</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a>.parse_arguments(<span class="stringliteral">&quot;3: 4.0&quot;</span>);</div>
<div class="line"><a class="code" href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a>(); <span class="comment">// will execute my_function(3, 4.0);</span></div>
</div><!-- fragment --><p> The arguments are copied to the tuple, with their reference and const attributes removed. Only copy constructible objects are allowed as function arguments. If you need to keep some references around, you may wrap your function into a lambda function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">example_function(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 3) {</div>
<div class="line">...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(1, 2);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind&lt;void, double, unsigned int&gt;</a> <a class="code" href="base_2numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a> = {</div>
<div class="line"> [&amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>](<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line"> {</div>
<div class="line">   example_function(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line"> },</div>
<div class="line"> {}};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="base_2numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>.parse_arguments(<span class="stringliteral">&quot;3.0 : 4&quot;</span>);</div>
<div class="line"><a class="code" href="base_2numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>(); <span class="comment">// calls example_function(p, 3.0, 4);</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="base_2mutable__bind_8h_source.html#l00079">79</a> of file <a class="el" href="base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0440f0acbbe43f70a8459920f842deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0440f0acbbe43f70a8459920f842deaf">&#9670;&nbsp;</a></span>TupleType <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> =  <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;typename std::remove_cv&lt; typename std::remove_reference&lt;FunctionArgs&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a>&gt;::type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias to the stored std::tuple type. Only copy constructible objects are allowed as tuple members. </p>

<p class="definition">Definition at line <a class="el" href="base_2mutable__bind_8h_source.html#l00088">88</a> of file <a class="el" href="base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>

</div>
</div>
<a id="a0440f0acbbe43f70a8459920f842deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0440f0acbbe43f70a8459920f842deaf">&#9670;&nbsp;</a></span>TupleType <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> =  <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;typename std::remove_cv&lt; typename std::remove_reference&lt;FunctionArgs&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a>&gt;::type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias to the stored std::tuple type. Only copy constructible objects are allowed as tuple members. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2mutable__bind_8h_source.html#l00090">90</a> of file <a class="el" href="origin_2base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>

</div>
</div>
<a id="a0440f0acbbe43f70a8459920f842deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0440f0acbbe43f70a8459920f842deaf">&#9670;&nbsp;</a></span>TupleType <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> =  <a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;typename std::remove_cv&lt; typename std::remove_reference&lt;FunctionArgs&gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a>&gt;::type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias to the stored std::tuple type. Only copy constructible objects are allowed as tuple members. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2mutable__bind_8h_source.html#l00088">88</a> of file <a class="el" href="translator_2base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a15d154c59a216965f1dc00a06c2c2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d154c59a216965f1dc00a06c2c2f38">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and each arguments separately. </p>

</div>
</div>
<a id="a6568bec393e51e619eeb7aaf1b12bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568bec393e51e619eeb7aaf1b12bc6b">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and the arguments as a tuple. </p>

</div>
</div>
<a id="a2384b48b967ad65d2c69a822eb1cc0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384b48b967ad65d2c69a822eb1cc0c4">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying only the function. By default, the arguments are left to their default constructor values. </p>

</div>
</div>
<a id="a15d154c59a216965f1dc00a06c2c2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d154c59a216965f1dc00a06c2c2f38">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and each arguments separately. </p>

</div>
</div>
<a id="a6568bec393e51e619eeb7aaf1b12bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568bec393e51e619eeb7aaf1b12bc6b">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and the arguments as a tuple. </p>

</div>
</div>
<a id="a2384b48b967ad65d2c69a822eb1cc0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384b48b967ad65d2c69a822eb1cc0c4">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying only the function. By default, the arguments are left to their default constructor values. </p>

</div>
</div>
<a id="a15d154c59a216965f1dc00a06c2c2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d154c59a216965f1dc00a06c2c2f38">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and each arguments separately. </p>

</div>
</div>
<a id="a6568bec393e51e619eeb7aaf1b12bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568bec393e51e619eeb7aaf1b12bc6b">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying the function, and the arguments as a tuple. </p>

</div>
</div>
<a id="a2384b48b967ad65d2c69a822eb1cc0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384b48b967ad65d2c69a822eb1cc0c4">&#9670;&nbsp;</a></span>MutableBind() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<div class="memtemplate">
template&lt;class FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object specifying only the function. By default, the arguments are left to their default constructor values. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a187b6ecbd97e97a873042d885729605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187b6ecbd97e97a873042d885729605b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">operator</a>() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the original function, passing as arguments the elements of the tuple of bound arguments. </p>

</div>
</div>
<a id="a8c9892610afbf8e437530a3302c290a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9892610afbf8e437530a3302c290a8">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="a578c55f3364fa1ec7535b13c934a0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578c55f3364fa1ec7535b13c934a0ef9">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="ad675baf4560885f06f27387bff9c1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad675baf4560885f06f27387bff9c1969">&#9670;&nbsp;</a></span>parse_arguments() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::parse_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>value_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;&#160;<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a>&#160;&gt;::to_pattern()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the arguments to use in <code>function</code> from a string, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called. The conversion is performed using a user supplied <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object. By default, <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;TupleType&gt;::to_pattern()</a> is used to determine how to convert from <code>value_string</code> to a TupleType object.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_string</td><td>The string to convert from </td></tr>
    <tr><td class="paramname">pattern</td><td>A unique pointer to the pattern to use when performing the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187b6ecbd97e97a873042d885729605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187b6ecbd97e97a873042d885729605b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">operator</a>() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the original function, passing as arguments the elements of the tuple of bound arguments. </p>

</div>
</div>
<a id="a8c9892610afbf8e437530a3302c290a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9892610afbf8e437530a3302c290a8">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="a578c55f3364fa1ec7535b13c934a0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578c55f3364fa1ec7535b13c934a0ef9">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="ad675baf4560885f06f27387bff9c1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad675baf4560885f06f27387bff9c1969">&#9670;&nbsp;</a></span>parse_arguments() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::parse_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>value_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;&#160;<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a>&#160;&gt;::to_pattern()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the arguments to use in <code>function</code> from a string, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called.</p>
<p>The conversion is performed using a user supplied <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object. By default, <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;TupleType&gt;::to_pattern()</a> is used to determine how to convert from <code>value_string</code> to a TupleType object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_string</td><td>The string to convert from </td></tr>
    <tr><td class="paramname">pattern</td><td>A unique pointer to the pattern to use when performing the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187b6ecbd97e97a873042d885729605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187b6ecbd97e97a873042d885729605b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::<a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">operator</a>() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the original function, passing as arguments the elements of the tuple of bound arguments. </p>

</div>
</div>
<a id="a8c9892610afbf8e437530a3302c290a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9892610afbf8e437530a3302c290a8">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="a578c55f3364fa1ec7535b13c934a0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578c55f3364fa1ec7535b13c934a0ef9">&#9670;&nbsp;</a></span>set_arguments() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::set_arguments </td>
          <td>(</td>
          <td class="paramtype">FunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the arguments to use in <code>function</code>, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called, using move semantic. </p>

</div>
</div>
<a id="ad675baf4560885f06f27387bff9c1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad675baf4560885f06f27387bff9c1969">&#9670;&nbsp;</a></span>parse_arguments() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::parse_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>value_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;&#160;<a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a>&#160;&gt;::to_pattern()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the arguments to use in <code>function</code> from a string, for next time <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a> is called. The conversion is performed using a user supplied <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object. By default, <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;TupleType&gt;::to_pattern()</a> is used to determine how to convert from <code>value_string</code> to a TupleType object.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_string</td><td>The string to convert from </td></tr>
    <tr><td class="paramname">pattern</td><td>A unique pointer to the pattern to use when performing the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a65017f0855c402166a173b31079f0433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65017f0855c402166a173b31079f0433">&#9670;&nbsp;</a></span>function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::function&lt; ReturnType(FunctionArgs...)&gt; <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An std::function that stores the original function. </p>

<p class="definition">Definition at line <a class="el" href="base_2mutable__bind_8h_source.html#l00160">160</a> of file <a class="el" href="base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>

</div>
</div>
<a id="ac35eb72f97066fb0958a08729e503d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35eb72f97066fb0958a08729e503d8b">&#9670;&nbsp;</a></span>arguments</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html#a0440f0acbbe43f70a8459920f842deaf">TupleType</a> <a class="el" href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a>&lt; ReturnType, FunctionArgs &gt;::arguments</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Currently stored arguments. These are forwarded to the function object above, when calling <a class="el" href="classUtilities_1_1MutableBind.html#a187b6ecbd97e97a873042d885729605b">operator()()</a>. </p>

<p class="definition">Definition at line <a class="el" href="base_2mutable__bind_8h_source.html#l00167">167</a> of file <a class="el" href="base_2mutable__bind_8h_source.html">mutable_bind.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="base_2mutable__bind_8h_source.html">mutable_bind.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_ad438b60a6bc84b8b9d27e7063853a6f5"><div class="ttname"><a href="namespaceUtilities.html#ad438b60a6bc84b8b9d27e7063853a6f5">Utilities::mutable_bind</a></div><div class="ttdeci">MutableBind&lt; ReturnType, FunctionArgs... &gt; mutable_bind(ReturnType(*function)(FunctionArgs...), typename identity&lt; FunctionArgs &gt;::type &amp;&amp;... arguments)</div></div>
<div class="ttc" id="amg__0_8txt_html_a05d914308ac970c97c941a291a81ccc1"><div class="ttname"><a href="mg__0_8txt.html#a05d914308ac970c97c941a291a81ccc1">b</a></div><div class="ttdeci">which is a wrapper around Multigrid with the standard interface of deal II[2.x.9] Preconditioners PreconditionMG also uses the classes inheriting from for instance where it uses[2.x.10] and[2.x.11] which transfer between the global vector and the level vectors we have several auxiliary namely which stores an object on each level **See b</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00011">mg_0.txt:11</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="afunction__tools__0_8txt_html_a1a2acf608502527a80c0aeecdc12c908"><div class="ttname"><a href="function__tools__0_8txt.html#a1a2acf608502527a80c0aeecdc12c908">a</a></div><div class="ttdeci">*Estimate bounds on the value and bounds on each gradient component of a over a by approximating it by a order Taylor polynomial starting from the box center Each lower and upper bound is returned as a[2.x.1]</div><div class="ttdef"><b>Definition:</b> <a href="function__tools__0_8txt_source.html#l00002">function_tools_0.txt:2</a></div></div>
<div class="ttc" id="areordering__0_8txt_html_a66927a1e0c9344dc086ec3c365fda166"><div class="ttname"><a href="reordering__0_8txt.html#a66927a1e0c9344dc086ec3c365fda166">bound</a></div><div class="ttdeci">it will soon be obvious that there can t exists such a even if we allow that there might be cells with clockwise and counterclockwise orientation of the lines at the same time *One might argue that the definition of unique directions for faces and and the definition of directions relative to the cells they bound</div><div class="ttdef"><b>Definition:</b> <a href="reordering__0_8txt_source.html#l00026">reordering_0.txt:26</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="abase_2numbers_8h_html_a372e01cd9d1d07fdf136f4f40975d5cf"><div class="ttname"><a href="base_2numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; exp(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05647">vectorization.h:5647</a></div></div>
<div class="ttc" id="aclassUtilities_1_1MutableBind_html"><div class="ttname"><a href="classUtilities_1_1MutableBind.html">Utilities::MutableBind</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2mutable__bind_8h_source.html#l00079">mutable_bind.h:79</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
