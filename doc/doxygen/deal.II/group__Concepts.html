<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__Concepts.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Concepts, or expectations on template parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Concepts, or expectations on template parameters</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em> concepts </em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template:  
<a href="#details">More...</a></p>
<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em> concepts </em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template: </p>
<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em>concepts</em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div>
</div><!-- fragment --><p> The point here is that you are creating a vector that can store elements of type <code>Number</code>. But there are some underlying assumptions on this. For example, the deal.II <a class="el" href="classVector.html">Vector</a> class is not intended to be used just as a collection (unlike <code>std::vector</code> ) but defines vector space operations such as addition of vectors, or the norm of vectors. Consequently, the data type users can specify for <code>Number</code> must satisfy certain conditions (i.e., it must conform to or "model" a "concept"): Specifically, the type must denote objects that represent the elements of what mathematically call a "field" (which you can think of as, well, "numbers": things we can add, multiply, divide, take the absolute value of, etc). The point of a concept is then to describe <em> what conditions a type must satisfy </em> to be a valid template argument in a given context. This page describes these conditions for a number of concepts used throughout deal.II. Specifically, in the example above, the <a class="el" href="group__Concepts.html#ConceptNumber">Number concept</a> discussed below describes the types that could be used as argument for the <a class="el" href="classVector.html">Vector</a> class. Concepts have been proposed as a language extension to C++ for a long time already. They would allow us to describe that a class or function has certain properties in order to be a qualified template argument. For example, it would allow us to express in C++ code that the first argument to, say, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, must have a type that represents an actual mesh</p>
<ul>
<li>which we can currently only describe in words, see below. Using C++ concepts would allow us to describe this in code and trying to call such a function with an object as first argument that is not, in fact, a mesh would yield a compiler error that makes the mismatch clear. Unfortunately, these proposals to C++ have never made it into any official C++ standard; they are proposed for C++20 however. We may start to use them once the vast majority of our users have compilers that support this standard. More information on the topic can be found at <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>.</li>
</ul>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b> </dt>
<dd>deal.II includes both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> as objects which manage degrees of freedom on a mesh. Though the two do not share any sort of inheritance relationship, they are similar enough that many functions just need something which resembles a <a class="el" href="classDoFHandler.html">DoFHandler</a> to work correctly.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b> </dt>
<dd><p class="startdd">Many functions and classes in deal.II require an object which knows how to calculate matrix-vector products (the member function <code>vmult</code> ), transposed matrix-vector products (the member function <code>Tvmult</code> ), as well as the &lsquo;multiply and add&rsquo; equivalents <code>vmult_add</code> and <code>Tvmult_add</code> . Some functions only require <code>vmult</code> and <code>Tvmult</code> , but an object should implement all four member functions if the template requires a MatrixType argument. Writing classes that satisfy these conditions is a sufficiently common occurrence that the <a class="el" href="classLinearOperator.html">LinearOperator</a> class was written to make things easier; see <a class="el" href="group__LAOperators.html">Linear Operators <h3>Linear Operator</h3>
</a> for more information. One way to think of <code>MatrixType</code> is to pretend it is a base class with the following signature (this is nearly the interface provided by <a class="el" href="classSparseMatrix.html">SparseMatrix</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#adbdcf27ec7ee0fc04967ac7d83ca82ac">vmult_add</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#a97beb9329f598756d41fddb3d8469b6c">Tvmult_add</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line">};</div>
</div><!-- fragment --><p class="enddd">Template functions in C++ cannot be virtual (which is the main reason why this approach is not used in deal.II), so implementing this interface with inheritance will not work, but it is still a good way to think about this template concept. One can use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class to implement <code>vmult_add</code> and <code>Tvmult_add</code> instead of implementing them manually.  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b> </dt>
<dd><p class="startdd">Meshes can be thought of as arrays of vertices and connectivities, but a more fruitful view is to consider them as <em>collections of cells</em>. In C++, collections are often called <em>containers</em> (typical containers are std::vector, std::list, etc.) and they are characterized by the ability to iterate over the elements of the collection. The <code>MeshType</code> concept refers to any container which defines appropriate methods (such as <a class="el" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">DoFHandler::begin_active()</a>) and <code>typedefs</code> (such as <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) for managing collections of cells. Instances of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> may all be considered as containers of cells. In fact, the most important parts of the public interface of these classes consists simply of the ability to get iterators to their elements. Since these parts of the interface are generic, i.e., the functions have the same name in all classes, it is possible to write operations that do not actually care whether they work on a triangulation or a DoF handler object. Examples abound, for example, in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace, underlining the power of the abstraction that meshes and DoF handlers can all be considered simply as collections (containers) of cells. On the other hand, meshes are non-standard containers unlike std::vector or std::list in that they can be sliced several ways. For example, one can iterate over the subset of active cells or over all cells; likewise, cells are organized into levels and one can get iterator ranges for only the cells on one level. Generally, however, all classes that implement the containers-of-cells concept use the same function names to provide the same functionality. Functions that may be called with either class indicate this by accepting a template parameter like</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div>
</div><!-- fragment --><p> or</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div>
</div><!-- fragment --><p> The classes that satisfy this concept are collectively referred to as <em> mesh classes </em> . The exact definition of <code>MeshType</code> relies a lot on library internals, but it can be summarized as any class with the following properties: </p><ol>
<li>
A <code>typedef</code> named <code>active_cell_iterator</code>.  </li>
<li>
A method <code>get_triangulation()</code> which returns a reference to the underlying geometrical description (one of the <a class="el" href="classTriangulation.html">Triangulation</a> classes) of the collection of cells. If the mesh happens to be a <a class="el" href="classTriangulation.html">Triangulation</a>, then the mesh just returns a reference to itself.  </li>
<li>
A method <code><a class="el" href="iterators__0_8txt.html#ad83e6d423f9ad63243b1465081bde416">begin_active()</a></code> which returns an iterator pointing to the first active cell.  </li>
<li>
A static member value <code>dimension</code> containing the dimension in which the object lives.  </li>
<li>
A static member value <code>space_dimension</code> containing the dimension of the object (e.g., a 2D surface in a 3D setting would have <code>space_dimension = 2</code>).  </li>
</ol>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b> </dt>
<dd>This concept describes scalars which make sense as vector or matrix entries, which is usually some finite precision approximation of a field element. The canonical examples are <code>double</code> and <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> for floating point type <code>T</code> in many places as well.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b> </dt>
<dd><p class="startdd">See the description in <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces This module groups</a> for more information. In some contexts, anything that satisfies the interface resembling</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PolynomialType</div>
<div class="line">{</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="fe_2fe__0_8txt.html#a754f79d53a1f0ebfe04ff6b9ff4abb8a">compute</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div>
<div class="line">                      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeade3f4c40082ead56c7aef5e90e43242f">values</a>,</div>
<div class="line">                      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div>
<div class="line">                      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="enddd">may be considered as a polynomial for the sake of implementing finite elements.  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b> </dt>
<dd>This is essentially a synonym for <code>MatrixType</code> , but usually only requires that <code><a class="el" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult()</a></code> and <code><a class="el" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult()</a></code> be defined. Most of the time defining <code><a class="el" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult()</a></code> is not necessary. One should think of <code><a class="el" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult()</a></code> as applying some approximation of the inverse of a linear operator to a vector, instead of the action of a linear operator to a vector, for the preconditioner classes.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b> </dt>
<dd><p class="startdd">This is an object capable of relaxation for multigrid methods. One can think of an object satisfying this constraint as having the following interface as well as the constraints required by <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where these two member functions perform one step (or the transpose of such a step) of the smoothing scheme. In other words, the operations performed by these functions are \(u = u - P^{-1} (A u - v)\) and \(u = u - P^{-T} (A u - v)\) .  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b> </dt>
<dd>Almost all functions (with the notable exception of <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) which take a sparsity pattern as an argument can take either a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> or a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, or even one of the block sparsity patterns. See <a class="el" href="group__Sparsity.html">Sparsity patterns Almost all finite element formulations</a> for more information.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b> </dt>
<dd>Deriving new stream classes in C++ is well-known to be difficult. To get around this, some functions accept a parameter which defines <code>operator&lt;&lt;</code> , which allows for easy output to any kind of output stream.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b> </dt>
<dd>deal.II supports many different vector classes, including bindings to vectors in other libraries. These are similar to standard library vectors (i.e., they define <code><a class="el" href="index__set__0_8txt.html#a06c4d20c91ab07a0e74210eb580db6d1">begin()</a></code>, <code><a class="el" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end()</a></code> , <code>operator[]</code>, and <code><a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a></code> ) but also define numerical operations like <code><a class="el" href="chunk__sparsity__pattern__0_8txt.html#a5b51102d307d0296227f3b3f5b095be4">add()</a></code> . Some examples of VectorType include <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, and <a class="el" href="classBlockVector.html">BlockVector</a>.  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div>
</div><!-- fragment --><p> The point here is that you are creating a vector that can store elements of type <code>Number</code>. But there are some underlying assumptions on this. For example, the deal.II <a class="el" href="classVector.html">Vector</a> class is not intended to be used just as a collection (unlike <code>std::vector</code>) but defines vector space operations such as addition of vectors, or the norm of vectors. Consequently, the data type users can specify for <code>Number</code> must satisfy certain conditions (i.e., it must conform to or "model" a "concept"): Specifically, the type must denote objects that represent the elements of what mathematically call a "field" (which you can think of as, well, "numbers": things we can add, multiply, divide, take the absolute value of, etc). The point of a concept is then to describe <em>what conditions a type must satisfy</em> to be a valid template argument in a given context.</p>
<p>This page describes these conditions for a number of concepts used throughout deal.II. Specifically, in the example above, the <a class="el" href="group__Concepts.html#ConceptNumber">Number concept</a> discussed below describes the types that could be used as argument for the <a class="el" href="classVector.html">Vector</a> class.</p>
<p>Concepts have been proposed as a language extension to C++ for a long time already. They would allow us to describe that a class or function has certain properties in order to be a qualified template argument. For example, it would allow us to express in C++ code that the first argument to, say, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, must have a type that represents an actual mesh &ndash; which we can currently only describe in words, see below. Using C++ concepts would allow us to describe this in code and trying to call such a function with an object as first argument that is not, in fact, a mesh would yield a compiler error that makes the mismatch clear.</p>
<p>Unfortunately, these proposals to C++ have never made it into any official C++ standard; they are proposed for C++20 however. We may start to use them once the vast majority of our users have compilers that support this standard.</p>
<p>More information on the topic can be found at <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>.</p>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b> </dt>
<dd><p class="startdd">deal.II includes both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> as objects which manage degrees of freedom on a mesh. Though the two do not share any sort of inheritance relationship, they are similar enough that many functions just need something which resembles a <a class="el" href="classDoFHandler.html">DoFHandler</a> to work correctly. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b> </dt>
<dd><p class="startdd">Many functions and classes in deal.II require an object which knows how to calculate matrix-vector products (the member function <code>vmult</code>), transposed matrix-vector products (the member function <code>Tvmult</code>), as well as the &lsquo;multiply and add&rsquo; equivalents <code>vmult_add</code> and <code>Tvmult_add</code>. Some functions only require <code>vmult</code> and <code>Tvmult</code>, but an object should implement all four member functions if the template requires a MatrixType argument. Writing classes that satisfy these conditions is a sufficiently common occurrence that the <a class="el" href="classLinearOperator.html">LinearOperator</a> class was written to make things easier; see <a class="el" href="group__LAOperators.html">Linear Operators <h3>Linear Operator</h3>
</a> for more information.</p>
<p class="interdd">One way to think of <code>MatrixType</code> is to pretend it is a base class with the following signature (this is nearly the interface provided by <a class="el" href="classSparseMatrix.html">SparseMatrix</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#adbdcf27ec7ee0fc04967ac7d83ca82ac">vmult_add</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="matrix__block__0_8txt.html#a97beb9329f598756d41fddb3d8469b6c">Tvmult_add</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line">};</div>
</div><!-- fragment --><p class="interdd">Template functions in C++ cannot be virtual (which is the main reason why this approach is not used in deal.II), so implementing this interface with inheritance will not work, but it is still a good way to think about this template concept. One can use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class to implement <code>vmult_add</code> and <code>Tvmult_add</code> instead of implementing them manually. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b> </dt>
<dd><p class="startdd">Meshes can be thought of as arrays of vertices and connectivities, but a more fruitful view is to consider them as <em>collections of cells</em>. In C++, collections are often called <em>containers</em> (typical containers are std::vector, std::list, etc.) and they are characterized by the ability to iterate over the elements of the collection. The <code>MeshType</code> concept refers to any container which defines appropriate methods (such as <a class="el" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">DoFHandler::begin_active()</a>) and <code>typedefs</code> (such as <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) for managing collections of cells.</p>
<p class="interdd">Instances of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> may all be considered as containers of cells. In fact, the most important parts of the public interface of these classes consists simply of the ability to get iterators to their elements. Since these parts of the interface are generic, i.e., the functions have the same name in all classes, it is possible to write operations that do not actually care whether they work on a triangulation or a DoF handler object. Examples abound, for example, in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace, underlining the power of the abstraction that meshes and DoF handlers can all be considered simply as collections (containers) of cells.</p>
<p class="interdd">On the other hand, meshes are non-standard containers unlike std::vector or std::list in that they can be sliced several ways. For example, one can iterate over the subset of active cells or over all cells; likewise, cells are organized into levels and one can get iterator ranges for only the cells on one level. Generally, however, all classes that implement the containers-of-cells concept use the same function names to provide the same functionality.</p>
<p class="interdd">Functions that may be called with either class indicate this by accepting a template parameter like </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div>
</div><!-- fragment --><p> The classes that satisfy this concept are collectively referred to as <em>mesh classes</em>. The exact definition of <code>MeshType</code> relies a lot on library internals, but it can be summarized as any class with the following properties: </p><ol>
<li>
A <code>typedef</code> named <code>active_cell_iterator</code>.  </li>
<li>
A method <code>get_triangulation()</code> which returns a reference to the underlying geometrical description (one of the <a class="el" href="classTriangulation.html">Triangulation</a> classes) of the collection of cells. If the mesh happens to be a <a class="el" href="classTriangulation.html">Triangulation</a>, then the mesh just returns a reference to itself.  </li>
<li>
A method <code><a class="el" href="iterators__0_8txt.html#ad83e6d423f9ad63243b1465081bde416">begin_active()</a></code> which returns an iterator pointing to the first active cell.  </li>
<li>
A static member value <code>dimension</code> containing the dimension in which the object lives.  </li>
<li>
A static member value <code>space_dimension</code> containing the dimension of the object (e.g., a 2D surface in a 3D setting would have <code>space_dimension = 2</code>).  </li>
</ol>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b> </dt>
<dd><p class="startdd">This concept describes scalars which make sense as vector or matrix entries, which is usually some finite precision approximation of a field element. The canonical examples are <code>double</code> and <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> for floating point type <code>T</code> in many places as well. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b> </dt>
<dd><p class="startdd">See the description in <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces This module groups</a> for more information. In some contexts, anything that satisfies the interface resembling </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PolynomialType</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="fe_2fe__0_8txt.html#a754f79d53a1f0ebfe04ff6b9ff4abb8a">compute</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div>
<div class="line">                        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeade3f4c40082ead56c7aef5e90e43242f">values</a>,</div>
<div class="line">                        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div>
<div class="line">                        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interdd">may be considered as a polynomial for the sake of implementing finite elements. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b> </dt>
<dd><p class="startdd">This is essentially a synonym for <code>MatrixType</code>, but usually only requires that <code><a class="el" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult()</a></code> and <code><a class="el" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult()</a></code> be defined. Most of the time defining <code><a class="el" href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult()</a></code> is not necessary. One should think of <code><a class="el" href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult()</a></code> as applying some approximation of the inverse of a linear operator to a vector, instead of the action of a linear operator to a vector, for the preconditioner classes. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b> </dt>
<dd><p class="startdd">This is an object capable of relaxation for multigrid methods. One can think of an object satisfying this constraint as having the following interface as well as the constraints required by <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType</a>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;<a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>) <span class="keyword">const</span> =0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where these two member functions perform one step (or the transpose of such a step) of the smoothing scheme. In other words, the operations performed by these functions are \(u = u - P^{-1} (A u - v)\) and \(u = u - P^{-T} (A u - v)\). </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b> </dt>
<dd><p class="startdd">Almost all functions (with the notable exception of <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) which take a sparsity pattern as an argument can take either a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> or a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, or even one of the block sparsity patterns. See <a class="el" href="group__Sparsity.html">Sparsity patterns Almost all finite element formulations</a> for more information. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b> </dt>
<dd><p class="startdd">Deriving new stream classes in C++ is well-known to be difficult. To get around this, some functions accept a parameter which defines <code>operator&lt;&lt;</code>, which allows for easy output to any kind of output stream. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b> </dt>
<dd><p class="startdd">deal.II supports many different vector classes, including bindings to vectors in other libraries. These are similar to standard library vectors (i.e., they define <code><a class="el" href="index__set__0_8txt.html#a06c4d20c91ab07a0e74210eb580db6d1">begin()</a></code>, <code><a class="el" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end()</a></code>, <code>operator[]</code>, and <code><a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a></code>) but also define numerical operations like <code><a class="el" href="chunk__sparsity__pattern__0_8txt.html#a5b51102d307d0296227f3b3f5b095be4">add()</a></code>. Some examples of VectorType include <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, and <a class="el" href="classBlockVector.html">BlockVector</a>. </p>
<p class="enddd"></p>
</dd>
</dl>
</div><!-- contents -->
<div class="ttc" id="alinear__operator__0_8txt_html_a64f52ea7f8959e614f32da4664cdbe50"><div class="ttname"><a href="linear__operator__0_8txt.html#a64f52ea7f8959e614f32da4664cdbe50">vmult</a></div><div class="ttdeci">*A class to store the abstract concept of a linear set up and handle intermediate storage locations by hand *As an example consider the and[2.x.8] one can sparse matrices with a or larger ***In order to use Trilinos or PETSc sparse matrices and preconditioners in conjunction with the LinearOperator it is necessary to extend the functionality of the LinearOperator class by means of an additional Payload *For for may represent a composite operation The[2.x.14] therefore provides an interface extension to the LinearOperator so that it can be passed to the solver and used by the solver as if it were a Trilinos it is again necessary to provide an interface that produces the result of this composite operation that is compatible with Trilinos the resulting this function also ensures that the underlying Payload matches that of the input *[2.x.105] *****LinearOperator *Return a nulled variant of the LinearOperator[2.x.108] i e with optimized[2.x.109][2.x.110] etc functions and with[2.x.111] set to true ******LinearOperator *Return a LinearOperator that acts as a mean value filter The vmult() functions of this matrix subtract the mean values of the vector. *The function takes an[2.x.114] object[2.x.115] as an argument to initialize the[2.x.116] and[2.x.117] objects of the LinearOperator object. ***[2.x.118] **[0.x.35] *[2.x.119] LinearOperator *Return a LinearOperator that acts as a mean value filter. The vmult() functions of this matrix subtract the mean values of the vector. *The function takes a LinearOperator[2.x.120] and uses its range initializer to create an mean value filter operator.The function also ensures that the underlying Payload matches that of the input[2.x.121] ***[2.x.122] **[0.x.36] *A helper class that is responsible for the initialization of a vector to be directly usable as the destination parameter</div></div>
<div class="ttc" id="anumerical__algorithms__0_8txt_html_a852a1e245dd2de4943eeb66beeaf65b1"><div class="ttname"><a href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">vector</a></div><div class="ttdeci">****This module groups a diverse set of classes that generally implement some sort of numerical algorithm on top all the basic and finite element classes in the library They are generally unconnected to each other *Some of the like KellyErrorEstimator and act on solutions already and compute derived quantities in the first two or help transferring a set of vectors from one mesh to another *The namespaces and VectorTools provide an assortment of such as creating a Laplace projecting or interpolating a function onto the present finite element etc The difference to the functions in the DoFTools and FETools functions is that they work on the DoFTools functions only act on a given DoFHandler object without reference to a data vector</div><div class="ttdef"><b>Definition:</b> <a href="numerical__algorithms__0_8txt_source.html#l00008">numerical_algorithms_0.txt:8</a></div></div>
<div class="ttc" id="amatrix__block__0_8txt_html_a97beb9329f598756d41fddb3d8469b6c"><div class="ttname"><a href="matrix__block__0_8txt.html#a97beb9329f598756d41fddb3d8469b6c">Tvmult_add</a></div><div class="ttdeci">that we may need a different number of matrices for different blocks in a block system For example a preconditioner for the Oseen system can be built as a block system where the pressure block is of the form[1.x.0]&lt; sup &gt;&lt;/sup &gt;&lt; sup &gt;&lt;/sup &gt; with[1.x.2] the pressure mass the pressure Laplacian and[1.x.4] the advection diffusion the functions and Tvmult_add() make it behave like a MatrixType</div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
<div class="ttc" id="avector__0_8txt_html_aaf255149898cc5cea8c1fa1e76fffe6f"><div class="ttname"><a href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a></div><div class="ttdeci">0 v</div><div class="ttdef"><b>Definition:</b> <a href="vector__0_8txt_source.html#l00062">vector_0.txt:62</a></div></div>
<div class="ttc" id="amatrix__block__0_8txt_html_adbdcf27ec7ee0fc04967ac7d83ca82ac"><div class="ttname"><a href="matrix__block__0_8txt.html#adbdcf27ec7ee0fc04967ac7d83ca82ac">vmult_add</a></div><div class="ttdeci">that we may need a different number of matrices for different blocks in a block system For example a preconditioner for the Oseen system can be built as a block system where the pressure block is of the form[1.x.0]&lt; sup &gt;&lt;/sup &gt;&lt; sup &gt;&lt;/sup &gt; with[1.x.2] the pressure mass the pressure Laplacian and[1.x.4] the advection diffusion the functions vmult_add()</div></div>
<div class="ttc" id="afe_2fe__0_8txt_html_a754f79d53a1f0ebfe04ff6b9ff4abb8a"><div class="ttname"><a href="fe_2fe__0_8txt.html#a754f79d53a1f0ebfe04ff6b9ff4abb8a">compute</a></div><div class="ttdeci">we cannot already compute the gradients on a concrete cell at the time the current function is but we can at least pre compute the gradients on the reference and store it in the object returned An extensive discussion of the interaction between this function and FEValues can be found in the[2.x.376] documentation module See also the documentation of the InternalDataBase class[2.x.377] update_flags A set of UpdateFlags values that describe what kind of information the FEValues object requests the finite element to compute This set of flags may also include information that the finite element can not compute</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__0_8txt_source.html#l00547">fe_0.txt:547</a></div></div>
<div class="ttc" id="anamespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeade3f4c40082ead56c7aef5e90e43242f"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeade3f4c40082ead56c7aef5e90e43242f">EvaluationFlags::values</a></div><div class="ttdeci">@ values</div><div class="ttdef"><b>Definition:</b> <a href="matrix__free_2evaluation__flags_8h_source.html#l00055">evaluation_flags.h:55</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="atable__handler__0_8txt_html_a61e9964f9093088848525ca172895749"><div class="ttname"><a href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a></div><div class="ttdeci">the ConvergenceTable class does something like this *To support both the TableHandler class has a property called[1.x.4] By auto fill mode is but it can be enabled by calling set_auto_fill_mode(). If auto-fill mode is enabled we use the following algorithm call it *[2.x.18] ***If[2.x.19] then we add[2.x.20] copies of the object[2.x.21] to this column is the data type of the given[2.x.23] is a numeric then[2.x.24] is[2.x.25] is the empty string *[2.x.26] ***Add the given value to this column *Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column In other if we have skipped previous invocations of then the padding will enter default values into this column *The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step</div><div class="ttdef"><b>Definition:</b> <a href="table__handler__0_8txt_source.html#l00070">table_handler_0.txt:70</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2mapping__q1__eulerian_8h_source.html#l00032">mapping_q1_eulerian.h:32</a></div></div>
<div class="ttc" id="amatrix__block__0_8txt_html_a215ae9c37388b3782d0d58703df61a73"><div class="ttname"><a href="matrix__block__0_8txt.html#a215ae9c37388b3782d0d58703df61a73">Tvmult</a></div><div class="ttdeci">that we may need a different number of matrices for different blocks in a block system For example a preconditioner for the Oseen system can be built as a block system where the pressure block is of the form[1.x.0]&lt; sup &gt;&lt;/sup &gt;&lt; sup &gt;&lt;/sup &gt; with[1.x.2] the pressure mass the pressure Laplacian and[1.x.4] the advection diffusion the functions Tvmult()</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
