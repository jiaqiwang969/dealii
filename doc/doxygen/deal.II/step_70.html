<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_70.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-70 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-70 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_19.html">step-19</a>, <a class="el" href="step_32.html">step-32</a>, <a class="el" href="step_60.html">step-60</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a>
      <ul>
        <li><a href="#Codimensiononecase">Co-dimension one case</a>
        <li><a href="#Codimensionzerocase">Co-dimension zero case</a>
        <li><a href="#Representationofand">Representation of Ω and Γ</a>
        <li><a href="#Usingparticlestotrack">Using particles to track Γ</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Morereferences"> More references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a>
        <li><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a>
        <li><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a>
      <ul>
        <li><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a>
        <li><a href="#Particleinitializationfunctions">Particle initialization functions</a>
        <li><a href="#DoFinitializationfunctions">DoF initialization functions</a>
        <li><a href="#Assemblyfunctions">Assembly functions</a>
        <li><a href="#Solvingthelinearsystem">Solving the linear system</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Creatingoutputforvisualization">Creating output for visualization</a>
        <li><a href="#Therunfunction">The "run" function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a>
        <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>In this tutorial we consider a mixing problem in the laminar flow regime. Such problems occur in a wide range of applications ranging from chemical engineering to power generation (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically, because they often involve a container (with fixed boundaries, and possibly complex geometries such as baffles), represented by the domain \(\Omega\), and one (or more) immersed and rotating impellers (represented by the domain \(\Omega^{\text{imp}}\)). The domain in which we would like to solve the flow equations is the (time dependent) difference between the two domains, namely: \(\Omega\setminus\Omega^{\text{imp}}\).</p>
<p>For rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations (in which the fluid domain &ndash; along with the mesh! &ndash; is smoothly deformed to follow the deformations of the immersed solid) is not possible, unless only small times (i.e., small fluid domain deformations) are considered. If one wants to track the evolution of the flow across multiple rotations of the impellers, the resulting deformed grid would simply be too distorted to be useful.</p>
<p>In this case, a viable alternative strategy would be to use non-matching methods (similarly to what we have done in <a class="el" href="step_60.html">step-60</a>), where a background fixed grid (that may or may not be locally refined in time to better capture the solid motion) is coupled with a rotating, independent, grid.</p>
<p>In order to maintain the same notations used in <a class="el" href="step_60.html">step-60</a>, we use \(\Omega\) to denote the domain in \({\mathbb R}^{\text{spacedim}}\) representing the container of both the fluid and the impeller, and we use \(\Gamma\) in \({\mathbb R}^{\text{dim}}\) to denote either the full impeller (when its <code>spacedim</code> measure is non-negligible, i.e., when we can represent it as a grid of dimension <code>dim</code> equal to <code>spacedim</code>), a co-dimension one representation of a thin impeller, or just the boundary of the full impeller.</p>
<p>The domain \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\)) and it is non-matching: It does not, in general, align with any of the features of the volume mesh. We solve a partial differential equation on \(\Omega\), enforcing some conditions on the solution of the problem on the embedded domain \(\Gamma\) by some penalization techniques. In the current case, the condition is that the velocity of the fluid at points on \(\Gamma\) equal the velocity of the solid impeller at that point.</p>
<p>The technique we describe here is presented in the literature using one of many names: the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is that the discretization of the two grids are kept completely independent. In the present tutorial, this approach is used to solve for the motion of a viscous fluid, described by the Stokes equation, that is agitated by a rigid non-deformable impeller.</p>
<p>Thus, the equations solved in \(\Omega\) are the Stokes equations for a creeping flow (i.e. a flow where \(\text{Re}\rightarrow 0\)) and a no-slip boundary condition is applied on the moving <em>embedded domain</em> \(\Gamma\) associated with the impeller. However, this tutorial could be readily extended to other equations (e.g. the Navier-Stokes equations, linear elasticity equation, etc.). It can be seen as a natural extension of <a class="el" href="step_60.html">step-60</a> that enables the solution of large problems using a distributed parallel computing architecture via MPI.</p>
<p>However, contrary to <a class="el" href="step_60.html">step-60</a>, the Dirichlet boundary conditions on \(\Gamma\) are imposed weakly instead of through the use of Lagrange multipliers, and we concentrate on dealing with the coupling of two fully distributed triangulations (a combination that was not possible in the implementation of <a class="el" href="step_60.html">step-60</a>).</p>
<p>There are two interesting scenarios that occur when one wants to enforce conditions on the embedded domain \(\Gamma\):</p>
<ul>
<li>The geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same of the domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero. In this case, the imposition of the Dirichlet boundary boundary condition on \(\Gamma\) is done through a volumetric penalization. If the applied penalization only depends on the velocity, this is often referred to as \(\mathcal{L}^2\) penalization whereas if the penalization depends on both the velocity and its gradient, it is an \(\mathcal{H}^1\) penalization. The case of the \(\mathcal{L}^2\) penalization is very similar to a Darcy-type approach. Both \(\mathcal{L}^2\) and \(\mathcal{H}^1\) penalizations have been analyzed extensively (see, for example, <b>[Angot1999]</b>).</li>
<li>The embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smaller than that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure is zero; for example it is a curve embedded in a two dimensional domain, or a surface embedded in a three-dimensional domain. This is of course physically impossible, but one may consider very thin sheets of metal moving in a fluid as essentially lower-dimensional if the thickness of the sheet is negligible. In this case, the boundary condition is imposed weakly on \(\Gamma\) by applying the <a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a> method (see <b>[Freund1995]</b>).</li>
</ul>
<p>Both approaches have very similar requirements and result in highly similar formulations. Thus, we treat them almost in the same way.</p>
<p>In this tutorial program we are not interested in further details on \(\Gamma\): we assume that the dimension of the embedded domain (<code>dim</code>) is always smaller by one or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>).</p>
<p>We are going to solve the following differential problem: given a sufficiently regular function \(g\) on \(\Gamma\), find the solution \((\textbf{u},p)\) to</p>
<p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>This equation, which we have normalized by scaling the time units in such a way that the viscosity has a numerical value of 1, describes slow, viscous flow such as honey or lava. The main goal of this tutorial is to show how to impose the velocity field condition \(\mathbf{u} = \mathbf{g}\) on a non-matching \(\Gamma\) in a weak way, using a penalization method. A more extensive discussion of the Stokes problem including body forces, different boundary conditions, and solution strategies can be found in <a class="el" href="step_22.html">step-22</a>.</p>
<p>Let us start by considering the Stokes problem alone, in the entire domain \(\Omega\). We look for a velocity field \(\mathbf{u}\) and a pressure field \(p\) that satisfy the Stokes equations with homogeneous boundary conditions on \(\partial\Omega\).</p>
<p>The weak form of the Stokes equations is obtained by first writing it in vector form as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued test function \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\), and integrating over the domain \(\Omega\), yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\).</p>
<p>Integrating by parts and exploiting the boundary conditions on \(\partial\Omega\), we obtain the following variational problem: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) represents the \(L^2\) scalar product. This is the same variational form used in <a class="el" href="step_22.html">step-22</a>.</p>
<p>This variational formulation does not take into account the embedded domain. Contrary to <a class="el" href="step_60.html">step-60</a>, we do not enforce strongly the constraints of \(\textbf{u}\) on \(\Gamma\), but enforce them weakly via a penalization term.</p>
<p>The analysis of this weak imposition of the boundary condition depends on the spacedim-dimensional measure of \(\Gamma\) as either positive (if <code>dim</code> is equal to <code>spacedim</code>) or zero (if <code>dim</code> is smaller than <code>spacedim</code>). We discuss both scenarios.</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>In this case, we assume that \(\Gamma\) is the boundary of the actual impeller, that is, a closed curve embedded in a two-dimensional domain or a closed surface in a three-dimensional domain. The idea of this method starts by considering a weak imposition of the Dirichlet boundary condition on \(\Gamma\), following the Nitsche method. This is achieved by using the following modified formulation on the fluid domain, where no strong conditions on the test functions on \(\Gamma\) are imposed:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>The integrals over \(\Gamma\) are lower-dimensional integrals. It can be shown (see <b>[Freund1995]</b>) that there exists a positive constant \(C_1\) so that if \(\beta &gt; C_1\), the weak imposition of the boundary will be consistent and stable. The first two additional integrals on \(\Gamma\) (the second line in the equation above) appear naturally after integrating by parts, when one does not assume that \(\mathbf{v}\) is zero on \(\Gamma\).</p>
<p>The third line in the equation above contains two terms that are added to ensure consistency of the weak form, and a stabilization term, that is there to enforce the boundary condition with an error which is consistent with the approximation error. The consistency terms and the stabilization term are added to the right hand side with the actual boundary data \(\mathbf{g}\).</p>
<p>When \(\mathbf{u}\) satisfies the condition \(\mathbf{u}=\mathbf{g}\) on \(\Gamma\), all the consistency and stability integrals on \(\Gamma\) cancel out, and one is left with the usual weak form of Stokes flow, that is, the above formulation is consistent.</p>
<p>We note that an alternative (non-symmetric) formulation can be used :</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p> Note the different sign of the first terms on the third and fourth lines. In this case, the stability and consistency conditions become \(\beta &gt; 0\). In the symmetric case, the value of \(\beta\) is dependent on \(h\), and it is in general chosen such that \(\beta = C h^{-1} \) with \(h\) a measure of size of the face being integrated and \(C\) a constant such that \(1 \leq C \leq 10\). This is as one usually does with the Nitsche penalty method to enforcing Dirichlet boundary conditions.</p>
<p>The non-symmetric approach, on the other hand, is related to how one enforced continuity for the non-symmetric interior penalty method for discontinuous Galerkin methods (the "NIPG" method <b>[Riviere1999]</b>). Even if the non-symmetric case seems advantageous w.r.t. possible choices of stabilization parameters, we opt for the symmetric discretization, since in this case it can be shown that the dual problem is also consistent, leading to a solution where not only the energy norm of the solution converges with the correct order, but also its \(L^2\) norm. Furthermore, the resulting matrix remains symmetric.</p>
<p>The above formulation works under the assumption that the domain is discretized exactly. However, if the deformation of the impeller is a rigid body motion, it is possible to artificially extend the solution of the Stokes problem inside the propeller itself, since a rigid body motion is also a solution to the Stokes problem. The idea is then to solve the same problem, inside \(\Omega^{\text{imp}}\), imposing the same boundary conditions on \(\Gamma\), using the same penalization technique, and testing with test functions \(\mathbf{v}\) which are globally continuous over \(\Omega\).</p>
<p>This results in the following (intermediate) formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p> where the jump terms, denoted with \(\lbrack \cdot \rbrack\), are computed with respect to a fixed orientation of the normal vector \(\textbf{n}\). The factor of 2 appears in front of \(\beta\) since we see every part of \(\Gamma\) twice, once from within the fluid and once from within the obstacle moving around in it. (For all of the other integrals over \(\Gamma\), we visit each part of \(\Gamma\) twice, but with opposite signs, and consequently get the jump terms.)</p>
<p>Here we notice that, unlike in discontinuous Galerkin methods, the test and trial functions are continuous across \(\Gamma\). Moreover, if \(\Gamma\) is not aligned with cell boundaries, all the jump terms are also zero, since, in general, finite element function spaces are smooth inside each cell, and if \(\Gamma\) cuts through an element intersecting its boundary only at a finite number of points, all the contributions on \(\Gamma\), with the exception of the stabilization ones, can be neglected from the formulation, resulting in the following final form of the variational formulation:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>In <a class="el" href="step_60.html">step-60</a>, the imposition of the constraint required the addition of new variables in the form of Lagrange multipliers. This is not the case for this tutorial program. The imposition of the boundary condition using Nitsche's method only modifies the system matrix and the right-hand side without adding additional unknowns. However, the velocity vector \(\textbf{u}\) on the embedded domain will not match exactly the prescribed velocity \(\textbf{g}\), but only up to a numerical error which is in the same order as the interpolation error of the finite element method. Furthermore, as in <a class="el" href="step_60.html">step-60</a>, we still need to integrate over the non-matching embedded grid in order to construct the boundary term necessary to impose the boundary condition over \(\Gamma\).</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>In this case, \(\Gamma\) has the same dimension, but is embedded into \(\Omega\). We can think of this as a thick object moving around in the fluid. In the case of \(\mathcal{L}^2\) penalization, the additional penalization term can be interpreted as a Darcy term within \(\Gamma\), resulting in:</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Here, integrals over \(\Gamma\) are simply integrals over a part of the volume. The \(\mathcal{L}^2\) penalization thus consists in adding a volumetric term that constrains the velocity of the fluid to adhere to the velocity of the rigid body within \(\Gamma\). Also in this case, \(\beta\) must be chosen sufficiently large in order to ensure that the Dirichlet boundary condition in \(\Gamma\) is sufficiently respected, but not too high in order to maintain the proper conditioning of the system matrix.</p>
<p>A \(\mathcal{H}^1\) penalization may be constructed in a similar manner, with the addition of a viscous component to the penalization that dampens the velocity gradient within \(\Gamma\):</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Notice that the \(L^2\) penalization (<code>dim</code> equal to <code>spacedim</code>) and the Nitsche penalization (<code>dim</code> equal to <code>spacedim-1</code>) result in the exact same numerical implementation, thanks to the dimension independent capabilities of deal.II.</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>In this tutorial, both the embedded grid \(\Gamma\) and the embedding grid are described using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. These two triangulations can be built from functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or by reading a mesh file produced with another application (e.g. GMSH, see the discussion in <a class="el" href="step_49.html">step-49</a>). This is slightly more general than what was previously done in <a class="el" href="step_60.html">step-60</a>.</p>
<p>The addition of the immersed boundary method, whether it is in the <code>dim=spacedim</code> or <code>dim&lt;spacedim</code> case, only introduces additional terms in the system matrix and the right-hand side of the system which result from the integration over \(\Gamma\). This does not modify the number of variables for which the problem must be solved. The challenge is thus related to the integrals that must be carried over \(\Gamma\).</p>
<p>As usual in finite elements we split this integral into contributions from all cells of the triangulation used to discretize \(\Gamma\), we transform the integral on \(K\) to an integral on the reference element \(\hat K\), where \(F_{K}\) is the mapping from \(\hat K\) to \(K\), and compute the integral on \(\hat K\) using a quadrature formula. For example:</p>
<p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\). In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(y_i = F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\), and unless we figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on an arbitrary point on \(\Omega\), we cannot compute the integral needed.</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to be taken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\), where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\). This is the easy part: FEValues::quadrature_point() gives us the real-space locations of all quadrature points.</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\).</li>
<li>Find the reference coordinates within \(T\) of \(y_i\). For this, we need the inverse of the mapping \(G_T\) that transforms the reference element \(\hat T\) into the element \(T\): \(\hat y_i = G^{-1}_{T} (y_i)\).</li>
<li>Evaluate the basis function \(v_j\) of the \(\Omega\) mesh at this point \(\hat y_i\). This is, again, relatively simple using <a class="el" href="classFEValues.html">FEValues</a>.</li>
</ul>
<p align="center"></p>
<p><img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png" alt="" class="inline"/> </p>
<p>In <a class="el" href="step_60.html">step-60</a>, the second through fourth steps above were computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step.</li>
</ul>
<p>Although this approach could work for the present case, it does not lends itself readily to parallel simulations using distributed triangulations. Indeed, since the position of the quadrature points on the cells of the embedded domain \(\Gamma\) do not match that of the embedding triangulation and since \(\Gamma\) is constantly moving, this would require that the triangulation representing \(\Gamma\) be stored in it's entirety for all of the processors. As the number of processor and the number of cells in \(\Gamma\) increases, this leads to a severe bottleneck in terms of memory. Consequently, an alternative strategy is sought in this step.</p>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>Remember that for both the penalization approach ( \(\mathcal{L}^2\) or \(\mathcal{H}^1\)) and the Nitsche method, we want to compute integrals that are approximated by the quadrature. That is, we need to compute </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> If you followed the discussion above, then you will recall that \(\textbf{u}\) and \(\textbf{v}\) are shape functions defined on the fluid mesh. The only things defined on the solid mesh are: \(F_K(\hat x_i)\), which is the location of a quadrature point on a solid cell that is part of \(\Gamma\), \(J_K\) is the determinant of its Jacobian, and \(w_i\) the corresponding quadrature weight.</p>
<p>The important part to realize is now this: \(w_i\) is a property of the quadrature formula and does not change with time. Furthermore, the Jacobian matrix of \(F_K\) itself changes as the solid obstacle moves around in the fluid, but because the solid is considered non-deforming (it only translates and rotates, but doesn't dilate), the determinant of the Jacobian remains constant. As a consequence, the product \(J_K(\hat x_i) w_i\) (which we typically denote by <code>JxW</code>) remains constant for each quadrature point. So the only thing we need keep track of are the positions \(x_i=F_K(\hat x_i)\) &ndash; but these move with the velocity of the solid domain.</p>
<p>In other words, we don't actually need to keep the solid mesh at all. All we need is the positions \(x_i(t)\) and corresponding <code>JxW</code> values. Since both of these properties are point-properties (or point-vectors) that are attached to the solid material, they can be idealized as a set of disconnected infinitesimally small "particles", which carry the required <code>JxW</code> information with the movement of the solid. deal.II has the ability to distribute and store such a set of particles in large-scale parallel computations in the form of the ParticleHandler class (for details on the implementation see <b>[GLHPW2018]</b>), and we will make use of this functionality in this tutorial.</p>
<p>Thus, the approach taken in this step is as follows:</p><ul>
<li>Create a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> for the domain \(\Gamma\);</li>
<li>Create <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> at the positions of the quadrature points on \(\Gamma\);</li>
<li>Call the <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> function, to distribute the particles across processors, <em>following the solid triangulation</em>;</li>
<li>Attach the <code>JxW</code> values as a "property" to each <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> object.</li>
</ul>
<p>This structure is relatively expensive to generate, but must only be generated once per simulation. Once the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> is generated and the required information is attached to the particle, the integrals over \(\Gamma\) can be carried out by exploiting the fact that particles are grouped cellwise inside ParticleHandler, allowing us to:</p><ul>
<li>Looping over all cells of \(\Omega\) that contain at least one particle</li>
<li>Looping over all particles in the given cell</li>
<li>Compute the integrals and fill the global matrix.</li>
</ul>
<p>Since the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can manage the exchange of particles from one processor to the other, the embedded triangulation can be moved or deformed by displacing the particles. The only constraint associated with this displacement is that particles should be displaced by a distance that is no larger than the size of one cell. That's because that is the limit to which <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can track which cell a particle that leaves its current cell now resides in.</p>
<p>Once the entire problem (the Stokes problem and the immersed boundary imposition) is assembled, the final saddle point problem is solved by an iterative solver, applied to the Schur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_22.html">step-22</a>), and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is a demonstration of the time-reversibility of Stokes flow. This is often illustrated in science education experiments with a Taylor-Couette flow and dye droplets that revert back to their original shape after the fluid has been displaced in a periodic manner.</p>
<p> 

<iframe width="560" height="315" src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</p>
<p>In the present problem, a very viscous fluid is agitated by the rotation of an impeller, which, in 2D, is modeled by a rectangular grid. The impeller rotates for a given number of revolutions, after which the flow is reversed such that the same number of revolutions is carried out in the opposite direction. We recall that since the Stokes equations are self-adjoint, creeping flows are reversible. Consequently, if the impeller motion is reversed in the opposite direction, the fluid should return to its original position. In the present case, this is illustrated by inserting a circle of passive tracer particles that are advected by the fluid and which return to their original position, thus demonstrating the time-reversibility of the flow.</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>This tutorial program uses a number of techniques on imposing velocity conditions on non-matching interfaces in the interior of the fluid. For more background material, you may want to look up the following references: <b>[Freund1995]</b>, <b>[Angot1999]</b>, <b>[Glowinski1999]</b>, <b>[Boffi2008]</b>, <b>[Heltai2012]</b>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_50.html">step-50</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceLA.html">LA</a></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div>
<div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div>
<div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">} <span class="comment">// namespace LA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
</div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a>. In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div>
</div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep70.html">Step70</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a>, we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files.</p>
<p>The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference.</p>
<p>The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblemParameters();</div>
</div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="function__time__0_8txt.html#a1ee09a9dd26d8e6c3685fe170eb40343">set_time</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">  angular_velocity.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div>
<div class="line"><span class="keywordtype">double</span>       <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>           = 1.0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div>
</div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div>
</div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div>
</div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div>
</div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div>
</div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple.</p>
<p>The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.).</p>
<p>In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles.</p>
<p>When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>.</p>
<p>In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take).</p>
<p>In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself.</p>
<p>To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div>
<div class="line">std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div>
<div class="line">std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div>
<div class="line">std::string arguments_for_solid_grid = <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ?</div>
<div class="line">                                         <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div>
<div class="line">                                         <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div>
<div class="line">std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div>
<div class="line">std::string arguments_for_particle_grid =</div>
<div class="line">  <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div>
</div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field.</p>
<p>We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>.</p>
<p>Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div>
<div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div>
<div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div>
<div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div>
<div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div>
</div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>;</div>
<div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div>
<div class="line">    angular_velocity;</div>
<div class="line">};</div>
</div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">StokesImmersedProblemParameters&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,</div>
<div class="line">                                <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::StokesImmersedProblemParameters()</div>
<div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div>
<div class="line">  , <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<span class="stringliteral">&quot;Right hand side&quot;</span>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1)</div>
<div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div>
<div class="line">                initial_fluid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div>
<div class="line">                initial_solid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div>
<div class="line">                fluid_rtree_extraction_level,</div>
<div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div>
<div class="line">    particle_insertion_refinement,</div>
<div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div>
<div class="line">    homogeneous_dirichlet_ids,</div>
<div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div>
</div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div>
<div class="line">                arguments_for_particle_grid);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div>
<div class="line">                refinement_strategy,</div>
<div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                this-&gt;prm,</div>
<div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
</div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">  <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div>
<div class="line">                                                            <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">  });</div>
<div class="line">  angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">    this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div>
<div class="line">    : angular_velocity(angular_velocity)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>;</div>
</div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line">    <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[0]        = -omega * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">    <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[1]        = omega * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">    , angular_velocity(angular_velocity)</div>
<div class="line">    , time_step(time_step)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dtheta = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) * time_step;</div>
<div class="line"> </div>
<div class="line">    new_position[0] = <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0] - <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">    new_position[1] = <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0] + <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> new_position[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div>
<div class="line">  {</div>
<div class="line">    time_step = new_time_step;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">  <span class="keywordtype">double</span>                                     time_step;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblem(</div>
<div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
</div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div>
<div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div>
</div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div>
<div class="line"><span class="keywordtype">void</span> setup_dofs();</div>
</div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div>
<div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div>
</div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a>) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>,</div>
<div class="line">                      std::string                                 fprefix,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div>
</div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a>, for example:</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div>
</div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a>. Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping.</p>
<p>We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes).</p>
<p>This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns.</p>
<p>In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div>
<div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div>
</div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom.</p>
<p>We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div>
<div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div>
</div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a>, we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div>
</div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> system_matrix;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> locally_relevant_solution;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> system_rhs;</div>
</div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div>
<div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div>
</div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() * spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\). This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain.</p>
<p>While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm.</p>
<p>The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div>
<div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> tracer_particle_velocities;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div>
</div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping.</p>
<p>In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area &ndash; in the form of more refined bounding box information &ndash; the less communication we have to perform.)</p>
<p>We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be.</p>
<p>As an example, this is what would be extracted by the <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree:</p>
<div class="image">
<img src="rtree-process-0.png" alt=""/>
</div>
 <div class="image">
<img src="rtree-process-1.png" alt=""/>
</div>
 <div class="image">
<img src="rtree-process-2.png" alt=""/>
</div>
<p>We store these boxes in a global member variable, which is updated at every refinement step:</p>
<div class="fragment"><div class="line">  std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassimplementation"></a> </p><h3>The StokesImmersedProblem class implementation</h3>
<p><a class="anchor" id="Objectconstructionandmeshinitializationfunctions"></a> </p><h4>Object construction and mesh initialization functions</h4>
<p>In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div>
<div class="line">  <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div>
<div class="line">  : par(par)</div>
<div class="line">  , mpi_communicator(MPI_COMM_WORLD)</div>
<div class="line">  , pcout(std::cout,</div>
<div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="base_2partitioner__0_8txt.html#a6d2d0fa485d1660823c59c494fb0fb31">MPI</a>::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div>
<div class="line">  , computing_timer(mpi_communicator,</div>
<div class="line">                    pcout,</div>
<div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div>
<div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div>
<div class="line">  , fluid_tria(mpi_communicator,</div>
<div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::MeshSmoothing(</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_refinement |</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_coarsening))</div>
<div class="line">  , solid_tria(mpi_communicator,</div>
<div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::MeshSmoothing(</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_refinement |</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_coarsening))</div>
<div class="line">  , fluid_dh(fluid_tria)</div>
<div class="line">  , solid_dh(solid_tria)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(<span class="keyword">const</span> std::string &amp;grid_file_name,</div>
<div class="line">                             <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div>
<div class="line">                             <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div>
<div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div>
<div class="line">  grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div>
</div><!-- fragment --><p>If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>.</p>
<p>We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div>
<div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>   = pair.first;</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> = boost::algorithm::to_lower_copy(</div>
<div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div>
<div class="line"> </div>
<div class="line">        TopoDS_Shape shape;</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;iges&quot;</span> || <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;igs&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;step&quot;</span> || <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;stp&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div>
</div><!-- fragment --><p>Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="table__0_8txt.html#ab0c207fc9a63cc7861178ab4e76b2da9">n_elements</a> = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div>
<div class="line"><span class="keywordflow">if</span> ((std::get&lt;0&gt;(<a class="code" href="table__0_8txt.html#ab0c207fc9a63cc7861178ab4e76b2da9">n_elements</a>) == 0))</div>
<div class="line">  tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div>
<div class="line">    <a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 3)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div>
<div class="line">    t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">                    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div>
<div class="line">                      shape));</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
</div><!-- fragment --><p>We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>.</p>
<div class="fragment"><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div>
<div class="line">                              <a class="code" href="geometry__info__0_8txt.html#aeab70d834b7bc032f4ab627e72d6084c">TopoDS::Face</a>(shape)));</div>
<div class="line">      }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    (void)ids_and_cad_file_names;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
</div><!-- fragment --><p>Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function.</p>
<p>We repeat this pattern for both the fluid and the solid mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">        fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(par.name_of_fluid_grid,</div>
<div class="line">                              par.arguments_for_fluid_grid,</div>
<div class="line">                              fluid_tria);</div>
<div class="line">    }</div>
<div class="line">  fluid_tria.refine_global(par.initial_fluid_refinement);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">        solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(par.name_of_solid_grid,</div>
<div class="line">                              par.arguments_for_solid_grid,</div>
<div class="line">                              solid_tria);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  solid_tria.refine_global(par.initial_solid_refinement);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Particleinitializationfunctions"></a> </p><h4>Particle initialization functions</h4>
<p>Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice &ndash; a choice determined by one of the run-time parameters in the parameter file.</p>
<p>In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves.</p>
<p>In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program.</p>
<p>With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div>
<div class="line">    mpi_communicator);</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">    particle_insert_tria,</div>
<div class="line">    par.name_of_particle_grid,</div>
<div class="line">    par.arguments_for_particle_grid);</div>
<div class="line">  particle_insert_tria.refine_global(par.particle_insertion_refinement);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div>
<div class="line">  particles_dof_handler.distribute_dofs(particles_fe);</div>
</div><!-- fragment --><p>This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors.</p>
<p>We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:</p>
<div class="fragment"><div class="line">std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div>
<div class="line">all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_tria.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">    all_boxes.emplace_back(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;bounding_box());</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a> = <a class="code" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div>
<div class="line">  <a class="code" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(<a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>, par.fluid_rtree_extraction_level);</div>
</div><!-- fragment --><p>Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes.</p>
<p>Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.</p>
<div class="fragment"><div class="line">global_fluid_bounding_boxes =</div>
<div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div>
<div class="line"> </div>
<div class="line">tracer_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                   <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div>
<div class="line">                                          global_fluid_bounding_boxes,</div>
<div class="line">                                          tracer_particle_handler);</div>
<div class="line"> </div>
<div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div>
<div class="line">      &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles * spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles * spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does).</p>
<div class="fragment"><div class="line">locally_owned_tracer_particle_coordinates =</div>
<div class="line">  tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div>
<div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>));</div>
</div><!-- fragment --><p>At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not.</p>
<p>Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.</p>
<div class="fragment"><div class="line">locally_relevant_tracer_particle_coordinates =</div>
<div class="line">  locally_owned_tracer_particle_coordinates;</div>
</div><!-- fragment --><p>Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost.</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div>
<div class="line">    tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid.</p>
<p>This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid.</p>
<p>In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(fluid_fe-&gt;degree + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div>
<div class="line">  solid_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                    <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div>
<div class="line">                                    n_properties);</div>
</div><!-- fragment --><p>The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div>
<div class="line">quadrature_points_vec.reserve(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.size() *</div>
<div class="line">                              solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>;</div>
<div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>.reserve(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.size() *</div>
<div class="line">                   solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div>
<div class="line">                             <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                             <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : solid_dh.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">    {</div>
<div class="line">      fe_v.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a> = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          quadrature_points_vec.emplace_back(<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>[q]);</div>
<div class="line">          <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>.emplace_back(</div>
<div class="line">            std::vector&lt;double&gt;(n_properties, <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>[q]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected</p>
<p>Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div>
<div class="line">         <span class="stringliteral">&quot;I was expecting the &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">solid_particle_handler.insert_global_particles(quadrature_points_vec,</div>
<div class="line">                                               global_fluid_bounding_boxes,</div>
<div class="line">                                               <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>);</div>
</div><!-- fragment --><p>As in the previous function, we end by making sure that upon refinement, particles are correctly transferred:</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">  fluid_tria.signals.post_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div>
<div class="line"> </div>
<div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="DoFinitializationfunctions"></a> </p><h4>DoF initialization functions</h4>
<p>We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\)). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class.</p>
<p>Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  fluid_fe =</div>
<div class="line">    std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div>
<div class="line">                                         <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>,</div>
<div class="line">                                         <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div>
<div class="line">                                                        1),</div>
<div class="line">                                         1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div>
<div class="line">  solid_dh.distribute_dofs(*solid_fe);</div>
<div class="line"> </div>
<div class="line">  fluid_quadrature_formula =</div>
<div class="line">    std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">  solid_quadrature_formula =</div>
<div class="line">    std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from <a class="el" href="step_55.html">step-55</a> and we refer to this step for a thorough explanation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  fluid_dh.distribute_dofs(*fluid_fe);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, 0);</div>
<div class="line">  stokes_sub_blocks[<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>] = 1;</div>
<div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> dofs_per_block =</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">        &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div>
<div class="line">        &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div>
<div class="line">        &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  fluid_owned_dofs.resize(2);</div>
<div class="line">  fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div>
<div class="line">  fluid_owned_dofs[1] =</div>
<div class="line">    fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div>
<div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div>
<div class="line">  fluid_relevant_dofs.resize(2);</div>
<div class="line">  fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div>
<div class="line">  fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(</div>
<div class="line">      fluid_dh,</div>
<div class="line">      0,</div>
<div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1),</div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>,</div>
<div class="line">      fluid_fe-&gt;component_mask(<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>));</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div>
<div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a>(mpi_communicator,</div>
<div class="line">                               fluid_dh.locally_owned_dofs());</div>
<div class="line">  {</div>
<div class="line">    system_matrix.clear();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = 0; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">          coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> || <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> || <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">          coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">      fluid_dh, coupling, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">      dsp,</div>
<div class="line">      locally_owned_dofs_per_processor,</div>
<div class="line">      mpi_communicator,</div>
<div class="line">      locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = 0; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">          coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">      fluid_dh, coupling, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">      dsp,</div>
<div class="line">      locally_owned_dofs_per_processor,</div>
<div class="line">      mpi_communicator,</div>
<div class="line">      locally_relevant_dofs);</div>
<div class="line">    preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  locally_relevant_solution.reinit(fluid_owned_dofs,</div>
<div class="line">                                   fluid_relevant_dofs,</div>
<div class="line">                                   mpi_communicator);</div>
<div class="line">  system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Assemblyfunctions"></a> </p><h4>Assembly functions</h4>
<p>We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from <a class="el" href="step_55.html">step-55</a>, which is essentially what <a class="el" href="step_27.html">step-27</a> also has, and is pretty standard if you know what the Stokes equations look like.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div>
<div class="line">{</div>
<div class="line">  system_matrix         = 0;</div>
<div class="line">  preconditioner_matrix = 0;</div>
<div class="line">  system_rhs            = 0;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div>
<div class="line">                               *fluid_quadrature_formula,</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = fluid_quadrature_formula-&gt;size();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>,</div>
<div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1));</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  std::vector&lt;double&gt;              div_phi_u(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  std::vector&lt;double&gt;              phi_p(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_dh.active_cell_iterators())</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>  = 0;</div>
<div class="line">        cell_matrix2 = 0;</div>
<div class="line">        cell_rhs     = 0;</div>
<div class="line"> </div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">        par.rhs.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                  rhs_values);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">              {</div>
<div class="line">                grad_phi_u[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>] = fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].gradient(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">                div_phi_u[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>]  = fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">                phi_p[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>]      = fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                  {</div>
<div class="line">                    <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                      (par.viscosity *</div>
<div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>], grad_phi_u[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]) -</div>
<div class="line">                       div_phi_u[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] * phi_p[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] - phi_p[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] * div_phi_u[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]) *</div>
<div class="line">                      fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">                    cell_matrix2(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += 1.0 / par.viscosity * phi_p[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] *</div>
<div class="line">                                          phi_p[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] * fe_values.JxW(q);</div>
<div class="line">                  }</div>
<div class="line"> </div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">                  fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>).first;</div>
<div class="line">                cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                               rhs_values[q](component_i) * fe_values.JxW(q);</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(<a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>,</div>
<div class="line">                                               cell_rhs,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               system_matrix,</div>
<div class="line">                                               system_rhs);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix2,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               preconditioner_matrix);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">  system_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">  preconditioner_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">  system_rhs.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line"> </div>
<div class="line">  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div>
<div class="line">    fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div>
<div class="line">                                  fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line">  <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div>
<div class="line">    1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div>
</div><!-- fragment --><p>We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> = solid_particle_handler.<a class="code" href="classArrayView.html#a1a1c62a26e5f55bfe124894c0a31386f">begin</a>();</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> != solid_particle_handler.<a class="code" href="classArrayView.html#a775e02d2deaf2f769e24dee0c3e7a582">end</a>())</div>
<div class="line">  {</div>
<div class="line">    local_matrix = 0;</div>
<div class="line">    local_rhs    = 0;</div>
</div><!-- fragment --><p>We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a>-&gt;get_surrounding_cell(fluid_tria);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, &amp;fluid_dh);</div>
<div class="line">dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div>
</div><!-- fragment --><p>So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles.</p>
<p>Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> : pic)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_reference_location();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_location();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>    = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_properties()[0];</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; fluid_fe-&gt;n_dofs_per_cell(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div>
<div class="line">                fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>).first;</div>
<div class="line">              <span class="keywordflow">if</span> (comp_i &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">                       ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                    {</div>
<div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div>
<div class="line">                        fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>).first;</div>
<div class="line">                      <span class="keywordflow">if</span> (comp_i == comp_j)</div>
<div class="line">                        local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                          penalty_parameter * par.penalty_term *</div>
<div class="line">                          fluid_fe-&gt;shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, ref_q) *</div>
<div class="line">                          fluid_fe-&gt;shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, ref_q) * <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>;</div>
<div class="line">                    }</div>
<div class="line">                  local_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += penalty_parameter * par.penalty_term *</div>
<div class="line">                                  solid_velocity.value(real_q, comp_i) *</div>
<div class="line">                                  fluid_fe-&gt;shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, ref_q) * <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div>
<div class="line">                                             local_rhs,</div>
<div class="line">                                             fluid_dof_indices,</div>
<div class="line">                                             system_matrix,</div>
<div class="line">                                             system_rhs);</div>
<div class="line">      <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> = pic.<a class="code" href="classArrayView.html#a775e02d2deaf2f769e24dee0c3e7a582">end</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  system_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">  system_rhs.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Solvingthelinearsystem"></a> </p><h4>Solving the linear system</h4>
<p>This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">StokesImmersedProblem&lt;dim, spacedim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a326d001228d45e600ba97606c24a01c7">LA::MPI::PreconditionAMG</a> prec_A;</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="relaxation__block__0_8txt.html#a2076fd56276055e74e230fad6edac013">LA::MPI::PreconditionAMG::AdditionalData</a> <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_A.initialize(system_matrix.block(0, 0), <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a326d001228d45e600ba97606c24a01c7">LA::MPI::PreconditionAMG</a> prec_S;</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="relaxation__block__0_8txt.html#a2076fd56276055e74e230fad6edac013">LA::MPI::PreconditionAMG::AdditionalData</a> <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="symmetric__tensor__0_8txt.html#a37cd5701f5aaccacc8caf38d4a7a903a">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="symmetric__tensor__0_8txt.html#a37cd5701f5aaccacc8caf38d4a7a903a">A</a>, prec_A);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div>
<div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div>
<div class="line">                                          1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8 * system_rhs.l2_norm(),</div>
<div class="line">                                          1.e-2);</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="symmetric__tensor__0_8txt.html#aeaf892aa244db24771fb1ff7cce8057f">P</a> = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div>
<div class="line">      <a class="code" href="function__0_8txt.html#a931d002b61ed821e97fe70a7bf5b35f2">std::array</a>&lt;</div>
<div class="line">        ::<a class="code" href="classLinearOperator.html">LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;</a>,</div>
<div class="line">        2&gt;{{amgA, amgS}});</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div>
<div class="line">                                 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-10 * system_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>(solver_control);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="symmetric__tensor__0_8txt.html#aeaf892aa244db24771fb1ff7cce8057f">P</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(fluid_dh,</div>
<div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div>
<div class="line">                                      locally_relevant_solution,</div>
<div class="line">                                      <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1).add(-mean_pressure);</div>
<div class="line">    locally_relevant_solution.block(1) = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1);</div>
<div class="line">  }</div>
</div><!-- fragment --><p><a class="anchor" id="Meshrefinement"></a> </p><h4>Mesh refinement</h4>
<p>We deal with mesh refinement in a completely standard way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>(0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div>
<div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div>
<div class="line">                                            par.velocity_degree + 1),</div>
<div class="line">                                          {},</div>
<div class="line">                                          locally_relevant_solution,</div>
<div class="line">                                          error_per_cell,</div>
<div class="line">                                          fluid_fe-&gt;component_mask(<a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div>
<div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">        refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div>
<div class="line">                                          error_per_cell,</div>
<div class="line">                                          par.refinement_fraction,</div>
<div class="line">                                          par.coarsening_fraction);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div>
<div class="line">        fluid_tria,</div>
<div class="line">        error_per_cell,</div>
<div class="line">        par.refinement_fraction,</div>
<div class="line">        par.coarsening_fraction,</div>
<div class="line">        par.max_cells);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_tria.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;refine_flag_set() &amp;&amp;</div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level() == par.max_level_refinement)</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;clear_refine_flag();</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;coarsen_flag_set() &amp;&amp;</div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level() == par.min_level_refinement)</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;clear_coarsen_flag();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div>
<div class="line">    <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>(fluid_dh);</div>
<div class="line">  fluid_tria.prepare_coarsening_and_refinement();</div>
<div class="line">  <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div>
<div class="line">  fluid_tria.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line">  setup_dofs();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>.interpolate(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">  locally_relevant_solution = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Creatingoutputforvisualization"></a> </p><h4>Creating output for visualization</h4>
<p>We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>,</div>
<div class="line">                                                     <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::string&gt; solution_names(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">    data_component_interpretation(</div>
<div class="line">      <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">  data_component_interpretation.push_back(</div>
<div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div>
<div class="line">                           solution_names,</div>
<div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div>
<div class="line">                           data_component_interpretation);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>(fluid_tria.n_active_cells());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) = fluid_tria.locally_owned_subdomain();</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>, <span class="stringliteral">&quot;subdomain&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                 mpi_communicator);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div>
<div class="line">  times_and_names.push_back(std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename));</div>
<div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their id &ndash; but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>,</div>
<div class="line">  std::string                                 fprefix,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div>
<div class="line">  particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>);</div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">  particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                      mpi_communicator);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div>
<div class="line">    times_and_names;</div>
<div class="line">  <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div>
<div class="line">    times_and_names[fprefix].<a class="code" href="q__collection__0_8txt.html#a98a6b91a750cdd7301bb66162fa71e80">push_back</a>(std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename));</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    times_and_names[fprefix] = {std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename)};</div>
<div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h4>The "run" function</h4>
<p>This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs &ndash; take <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_26.html">step-26</a> as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div>
<div class="line">                               <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) +</div>
<div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div>
<div class="line">                             <a class="code" href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a2713a592c467d1b282bdde44c65f6111">ParameterHandler::Short</a>);</div>
</div><!-- fragment --><p>We then start the time loop. We initialize all the elements of the simulation in the first cycle</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div>
<div class="line"><span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>         = 0;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; par.number_of_time_steps;</div>
<div class="line">     ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">  {</div>
<div class="line">    par.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a>();</div>
<div class="line">        initial_setup();</div>
<div class="line">        setup_dofs();</div>
<div class="line">        setup_tracer_particles();</div>
<div class="line">        setup_solid_particles();</div>
<div class="line">        tracer_particle_velocities.reinit(</div>
<div class="line">          locally_owned_tracer_particle_coordinates, mpi_communicator);</div>
<div class="line">        output_results(output_cycle, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">          output_particles(tracer_particle_handler,</div>
<div class="line">                           <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                           output_cycle,</div>
<div class="line">                           <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">          output_particles(solid_particle_handler,</div>
<div class="line">                           <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                           output_cycle,</div>
<div class="line">                           <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">        }</div>
<div class="line">      }</div>
</div><!-- fragment --><p>After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div>
<div class="line">                         <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div>
<div class="line">                                           time_step);</div>
<div class="line">    solid_particle_handler.set_particle_positions(solid_position,</div>
<div class="line">                                                  <span class="keyword">false</span>);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div>
<div class="line">    fluid_dh,</div>
<div class="line">    tracer_particle_handler,</div>
<div class="line">    locally_relevant_solution,</div>
<div class="line">    tracer_particle_velocities,</div>
<div class="line">    fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div>
<div class="line"> </div>
<div class="line">  tracer_particle_velocities *= time_step;</div>
<div class="line"> </div>
<div class="line">  locally_relevant_tracer_particle_coordinates =</div>
<div class="line">    tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div>
<div class="line">      <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>));</div>
<div class="line"> </div>
<div class="line">  relevant_tracer_particle_displacements.reinit(</div>
<div class="line">    locally_owned_tracer_particle_coordinates,</div>
<div class="line">    locally_relevant_tracer_particle_coordinates,</div>
<div class="line">    mpi_communicator);</div>
<div class="line"> </div>
<div class="line">  relevant_tracer_particle_displacements = tracer_particle_velocities;</div>
<div class="line"> </div>
<div class="line">  tracer_particle_handler.set_particle_positions(</div>
<div class="line">    relevant_tracer_particle_displacements);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using these new locations, we can then assemble the Stokes system and solve it.</p>
<div class="fragment"><div class="line">assemble_stokes_system();</div>
<div class="line">assemble_nitsche_restriction();</div>
<div class="line"><a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
</div><!-- fragment --><p>With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> % par.output_frequency == 0)</div>
<div class="line">          {</div>
<div class="line">            output_results(output_cycle, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">            ++output_cycle;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> % par.refinement_frequency == 0 &amp;&amp;</div>
<div class="line">            <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> != par.number_of_time_steps - 1)</div>
<div class="line">          refine_and_transfer();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step70</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The <a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> function</h3>
<p>The remainder of the code, the <code><a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.</p>
<p>If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceStep70.html">Step70</a>;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">  <a class="code" href="base_2logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line">      std::string prm_file;</div>
<div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">        prm_file = argv[1];</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;2, 3&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;2, 3&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;3&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;3&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;2&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;2&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run contains a number of sample parameter files that you can use to reproduce the results presented in this section. If you do not specify a parameter file as an argument on the command line, the program will try to read the file "`parameters.prm`" by default, and will execute the two dimensional version of the code. As explained in the discussion of the source code, if your file name contains the string "23", then the program will run a three dimensional problem, with immersed solid of co-dimension one. If it contains the string "3", it will run a three dimensional problem, with immersed solid of co-dimension zero, otherwise it will run a two dimensional problem with immersed solid of co-dimension zero.</p>
<p>Regardless of the specific parameter file name, if the specified file does not exist, when you execute the program you will get an exception that no such file can be found:</p>
<div class="fragment"><div class="line">----------------------------------------------------</div>
<div class="line">Exception <a class="code" href="data__out__base__0_8txt.html#a1a0f08903e9f2a25a073261a20b86e26">on</a> processing:</div>
<div class="line"> </div>
<div class="line">--------------------------------------------------------</div>
<div class="line">An <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a> occurred <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> line &lt;74&gt; <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="grid__0_8txt.html#abc4bc3849dde2110dfa9e18bf7ae1b8c">file</a> &lt;../<a class="code" href="data__out__base__0_8txt.html#a0d0a9b5bbc80d6f0b9d863fa664d74ef">source</a>/base/parameter_acceptor.cc&gt; <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> <span class="keyword">function</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="table__0_8txt.html#aa22355d271761047703d8c139352814f">void ::ParameterAcceptor::initialize</a>(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div>
<div class="line"><a class="code" href="A-headers_2fe__0_8txt.html#ac58f1344c78bfcb3556c763b59c923c6">The</a> <a class="code" href="A-headers_2exceptions__0_8txt.html#a887b88f558acbcf4a6621eb0f0d39772">violated</a> <a class="code" href="vector__tools__constraints__0_8txt.html#acb0039192ebc332fa285c0450e90388b">condition</a> was:</div>
<div class="line">    <span class="keyword">false</span></div>
<div class="line">Additional <a class="code" href="fe__vs__mapping__vs__fevalues__0_8txt.html#a4e0105c19ddbc5d3acf9aa95e2c9a082">information</a>:</div>
<div class="line">    You <a class="code" href="tensor__function__0_8txt.html#a7df5c44c3259e9ce6ab8c7d1681e8e5e">specified</a> &lt;<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.prm&gt; <a class="code" href="coding__conventions__0_8txt.html#a7b1ab7a5dcacc31df12a0592293133c0">as</a> <a class="code" href="parameter__handler__0_8txt.html#a141ebbaf93668d52831bbd4ec5a1e949">input</a> <a class="code" href="coding__conventions__0_8txt.html#a676390618e4d4cade021c4edeac58b65">parameter</a> <a class="code" href="grid__0_8txt.html#abc4bc3849dde2110dfa9e18bf7ae1b8c">file</a>, <a class="code" href="fe__nedelec__0_8txt.html#a8b7c0468fae3de73000ffc4dfafc048a">but</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#ac5d1c63883bb2a85710935e76a7dedd4">it</a> <a class="code" href="multithreading__0_8txt.html#a65ecb3886ec86207a20d2f9e8e690022">does</a> <a class="code" href="work__stream__0_8txt.html#a1c121a619b3787a3c8ac4194ed595af8">not</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a5aa168344f21991b9dfdd2e4854a305c">exist</a>. We <a class="code" href="opencascade_2utilities__0_8txt.html#a23b9c1bdc9420a32a79f19f214a53812">created</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#ac5d1c63883bb2a85710935e76a7dedd4">it</a> <span class="keywordflow">for</span> you.</div>
<div class="line">--------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">Aborting!</div>
<div class="line">----------------------------------------------------</div>
</div><!-- fragment --><p>However, as the error message already states, the code that triggers the exception will also generate the specified file ("`parameters.prm`" in this case) that simply contains the default values for all parameters this program cares about (for the correct dimension and co-dimension, according to the whether a string "23" or "3" is contained in the file name). By inspection of the default parameter file, we see the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div>
<div class="line"><span class="preprocessor"># ---------------------</span></div>
<div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Final <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>                            = 1</div>
<div class="line"><span class="preprocessor">  # Extraction level of the rtree used to construct global bounding boxes</span></div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid bounding <a class="code" href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a> extraction <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a> = 1</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Boundary Ids over which homogeneous Dirichlet boundary conditions are</span></div>
<div class="line"><span class="preprocessor">  # applied</span></div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Homogeneous Dirichlet <a class="code" href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a> ids    = 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Initial mesh refinement used for the fluid domain Omega</span></div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial fluid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 5</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Initial mesh refinement used for the solid domain Gamma</span></div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial solid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 5</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Nitsche penalty <a class="code" href="polynomial__0_8txt.html#ad2c421d87c61fba8a64abc270463b1b7">term</a>                  = 100</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>                  = 501</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Output directory                      = .</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Output frequency                      = 1</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Refinement of the volumetric mesh used to insert the particles</span></div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> insertion <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>         = 3</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Velocity <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>                       = 2</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Viscosity                             = 1</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  subsection Angular <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a></div>
<div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div>
<div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div>
<div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div>
<div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div>
<div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div>
<div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div>
<div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div>
<div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div>
<div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div>
<div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div>
<div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div>
<div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div>
<div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div>
<div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div>
<div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div>
<div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div>
<div class="line"><span class="preprocessor">    # components by a semicolon.</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = t &lt; .500001 ? 6.283185 : -6.283185 # <span class="keywordflow">default</span>: 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div>
<div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div>
<div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div>
<div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div>
<div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div>
<div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div>
<div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div>
<div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div>
<div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div>
<div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div>
<div class="line"><span class="preprocessor">    # your function expression.</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = -1: 1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a> = 0.3, 0.3: 0.1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = <a class="code" href="grid__generator__0_8txt.html#aa11be8d5d13009407ac286e68efd4387">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = -.5, -.1: .5, .1: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Refinement <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a> remeshing</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Maximum <a class="code" href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>        = 20000</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="cell__weights__0_8txt.html#aa2b27042ab4d10b014332d2edd6cd466">coarsening</a> fraction = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement maximal <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a>       = 8</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement minimal <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a>       = 5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> frequency      = 5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="grid_2grid__refinement__0_8txt.html#a25a49aa21a8c8032ab50bb5e8087a5d7">strategy</a>            = fixed_fraction</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Right <a class="code" href="constraints__0_8txt.html#a836d12b85657b83a8978aff8d7672c23">hand</a> <a class="code" href="update__flags__0_8txt.html#a401b2012c153de7bc4c63a89c334e118">side</a></div>
<div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div>
<div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div>
<div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div>
<div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div>
<div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div>
<div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div>
<div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div>
<div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div>
<div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div>
<div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div>
<div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div>
<div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div>
<div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div>
<div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div>
<div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div>
<div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div>
<div class="line"><span class="preprocessor">    # components by a semicolon.</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = 0; 0; 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div>
<div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div>
<div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div>
<div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div>
<div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div>
<div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div>
<div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div>
<div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div>
<div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div>
<div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div>
<div class="line"><span class="preprocessor">    # your function expression.</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"> </div>
<div class="line"><a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
</div><!-- fragment --><p>If you now run the program, you will get a file called <code>parameters_22.prm</code> in the directory specified by the parameter <code>Output directory</code> (which defaults to the current directory) containing a shorter version of the above parameters (without comments and documentation), documenting all parameters that were used to run your program:</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Final <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>                            = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid bounding <a class="code" href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a> extraction <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a> = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Homogeneous Dirichlet <a class="code" href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a> ids    = 0</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial fluid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 5</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial solid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 5</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Nitsche penalty <a class="code" href="polynomial__0_8txt.html#ad2c421d87c61fba8a64abc270463b1b7">term</a>                  = 100</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>                  = 501</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Output directory                      = .</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Output frequency                      = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> insertion <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>         = 3</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Velocity <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>                       = 2</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Viscosity                             = 1</div>
<div class="line">  subsection Angular <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = t &lt; .500001 ? 6.283185 : -6.283185</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = -1: 1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a> = 0.3, 0.3: 0.1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = <a class="code" href="grid__generator__0_8txt.html#aa11be8d5d13009407ac286e68efd4387">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = -.5, -.1: .5, .1: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Refinement <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a> remeshing</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Maximum <a class="code" href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>        = 20000</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="cell__weights__0_8txt.html#aa2b27042ab4d10b014332d2edd6cd466">coarsening</a> fraction = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement maximal <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a>       = 8</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement minimal <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a>       = 5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> frequency      = 5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="grid_2grid__refinement__0_8txt.html#a25a49aa21a8c8032ab50bb5e8087a5d7">strategy</a>            = fixed_fraction</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Right <a class="code" href="constraints__0_8txt.html#a836d12b85657b83a8978aff8d7672c23">hand</a> <a class="code" href="update__flags__0_8txt.html#a401b2012c153de7bc4c63a89c334e118">side</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = 0; 0; 0</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"><a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
</div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time the program is run) and then a <code>output/parameters_22.prm</code> (every time you run the program with an existing input file), is because you may want to leave most parameters to their default values, and only modify a handful of them, while still beeing able to reproduce the results and inspect what parameters were used for a specific simulation. It is generally good scientific practice to store the parameter file you used for a simulation along with the simulation output so that you can repeat the exact same run at a later time if necessary.</p>
<p>Another reason is because the input file may only contain those parameters that differ from their defaults. For example, you could use the following (perfectly valid) parameter file with this tutorial program: </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Final <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>                         = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Nitsche penalty <a class="code" href="polynomial__0_8txt.html#ad2c421d87c61fba8a64abc270463b1b7">term</a>               = 10</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>               = 101</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Velocity <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>                    = 3</div>
<div class="line"><a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
</div><!-- fragment --><p> and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101 steps, using a Nitsche penalty of <code>10</code>, and leaving all the other parameters to their default value. The output directory then contains a record of not just these parameters, but indeed all parameters used in the simulation. You can inspect all the other parameters in the produced file <code>parameters_22.prm</code>.</p>
<p><a class="anchor" id="Twodimensionaltestcase"></a></p><h3>Two dimensional test case </h3>
<p>The default problem generates a co-dimension zero impeller, consisting of a rotating rectangular grid, where the rotation is for half a time unit in one direction, and half a time unit in the opposite direction, with constant angular velocity equal to \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\). Consequently, the impeller does half a rotation and returns to its original position. The following animation displays the velocity magnitude, the motion of the solid impeller and of the tracer particles.</p>
<p align="center"></p>
<div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" alt="" width="500" class="inline"/> </div> <p>On one core, the output of the program will look like the following:</p>
<div class="fragment"><div class="line">bash@<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>$ mpirun -np 1 ./<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-70 test.prm</div>
<div class="line">Running StokesImmersedProblem&lt;2&gt; <span class="keyword">using</span> <a class="code" href="la__vector__0_8txt.html#a89d012f842e841940822e70887770169">Trilinos</a>.</div>
<div class="line">Cycle 0:</div>
<div class="line">Time : 0, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 9539 (8450+1089 -- 0+0)</div>
<div class="line">Tracer <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>: 337</div>
<div class="line">Solid <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>: 9216</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 158 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 9845 (8722+1123 -- 9216+337)</div>
<div class="line">Cycle 1:</div>
<div class="line">Time : 0.002, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 142 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line">Cycle 2:</div>
<div class="line">Time : 0.004, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 121 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line">Cycle 3:</div>
<div class="line">Time : 0.006, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 121 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Cycle 499:</div>
<div class="line">Time : 0.998, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 199 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line">Cycle 500:</div>
<div class="line">Time : 1, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>: 0.002</div>
<div class="line">   Solved <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 196 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line"> </div>
<div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> elapsed <a class="code" href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a> <a class="code" href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a>    |       302<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| <a class="code" href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a>                         | <a class="code" href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a>. <a class="code" href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a> |  wall <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> | % <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble Nitsche <a class="code" href="functions__0_8txt.html#a4cd641df34659abb61c41ded50daf3ce">terms</a>          |       501 |      43.3s |        14% |</div>
<div class="line">| Assemble Stokes <a class="code" href="functions__0_8txt.html#a4cd641df34659abb61c41ded50daf3ce">terms</a>           |       501 |      21.5s |       7.1% |</div>
<div class="line">| Initial setup                   |         1 |  0.000792s |         0% |</div>
<div class="line">| Output fluid                    |       502 |      31.8s |        11% |</div>
<div class="line">| Output solid <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>          |       502 |      32.2s |        11% |</div>
<div class="line">| Output tracer <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>         |       502 |      0.61s |       0.2% |</div>
<div class="line">| Refine                          |       100 |      4.68s |       1.5% |</div>
<div class="line">| Set solid <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> <a class="code" href="base_2utilities__0_8txt.html#a5b55f653ddb6c9850a414d80c71827a5">position</a>     |       500 |      3.34s |       1.1% |</div>
<div class="line">| Set tracer <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> motion      |       501 |     0.729s |      0.24% |</div>
<div class="line">| Setup <a class="code" href="distributed__0_8txt.html#ad207fe81a5be05e18534713c2677da7b">dofs</a>                      |       101 |       2.2s |      0.73% |</div>
<div class="line">| Solve                           |       501 |       164<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |        54% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p>You may notice that assembling the coupling system is more expensive than assembling the Stokes part. This depends highly on the number of Gauss points (solid particles) that are used to apply the Nitsche restriction. In the present case, a relatively low number of tracer particles are used. Consequently, tracking their motion is relatively cheap.</p>
<p>The following movie shows the evolution of the solution over time:</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/y4Gypj2jpXw"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>The movie shows the rotating obstacle in gray (actually a superposition of the solid particles plotted with large enough dots that they overlap), <a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">streamlines of the fluid flow</a> in light colors (including the corner vertices that form at specific times during the simulation), and the tracer particles in bluish tones.</p>
<p>The simulation shows that at the end time, the tracer particles have somewhat returned to their original position, although they have been distorted by the flow field. The following image compares the initial and the final position of the particles after one time unit of flow.</p>
<p align="center"></p>
<div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" alt="" width="500" class="inline"/> </div> <p>In this case, we see that the tracer particles that were outside of the swept volume of the impeller have returned very close to their initial position, whereas those in the swept volume were slightly more deformed. This deformation is non-physical. It is caused by the numerical error induced by the explicit Euler scheme used to advect the particles, by the loss of accuracy due to the fictitious domain and, finally, by the discretization error on the Stokes equations. The first two errors are the leading cause of this deformation and they could be alleviated by the use of a finer mesh and a lower time step.</p>
<p><a class="anchor" id="Threedimensionaltestcase"></a></p><h3>Three dimensional test case </h3>
<p>To play around a little bit, we complicate the fictitious domain (taken from <a href="https://grabcad.com/library/lungstors-blower-1">https://grabcad.com/library/lungstors-blower-1</a>), and run a co-dimension one simulation in three space dimensions, using the following "`parameters_23.prm`" file :</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Final <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>                            = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Homogeneous Dirichlet <a class="code" href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a> ids    = 0</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid bounding <a class="code" href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a> extraction <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a> = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial fluid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 3</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Initial solid <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>              = 0</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Nitsche penalty <a class="code" href="polynomial__0_8txt.html#ad2c421d87c61fba8a64abc270463b1b7">term</a>                  = 10</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>                  = 101</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Output frequency                      = 1</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> insertion <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a>         = 3</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Velocity <a class="code" href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a>                       = 2</div>
<div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Viscosity                             = 1</div>
<div class="line">  subsection Angular <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = t &lt; .500001 ? 5 : -5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,<a class="code" href="grid__generator__0_8txt.html#ad9adfa4fc9634eb12b6c9ba287d11e46">z</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = <a class="code" href="grid__generator__0_8txt.html#aa11be8d5d13009407ac286e68efd4387">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Fluid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = -50,-50, -10: 50, 50, 40: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator              = impeller.vtk</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Solid <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a>    = 1:impeller.step</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a> <a class="code" href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a> generator <a class="code" href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a> = 30, 30, 20: 10: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Refinement <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a> remeshing</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Maximum <a class="code" href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>        = 100000</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="cell__weights__0_8txt.html#aa2b27042ab4d10b014332d2edd6cd466">coarsening</a> fraction = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement maximal <a class="code" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a>       = 6</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> frequency      = 5</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Refinement <a class="code" href="grid_2grid__refinement__0_8txt.html#a25a49aa21a8c8032ab50bb5e8087a5d7">strategy</a>            = fixed_fraction</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line">  subsection Right <a class="code" href="constraints__0_8txt.html#a836d12b85657b83a8978aff8d7672c23">hand</a> <a class="code" href="update__flags__0_8txt.html#a401b2012c153de7bc4c63a89c334e118">side</a></div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a>  =</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="classFunction.html">Function</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a> = 0; 0; 0; 0</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Variable <a class="code" href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a>      = <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>,<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>,<a class="code" href="grid__generator__0_8txt.html#ad9adfa4fc9634eb12b6c9ba287d11e46">z</a>,t</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
<div class="line"><a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div>
</div><!-- fragment --><p>In this case, the timing outputs are a bit different:</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> elapsed <a class="code" href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a> <a class="code" href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a>    |  5.54e+03<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| <a class="code" href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a>                         | <a class="code" href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a>. <a class="code" href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a> |  wall <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> | % <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble Nitsche <a class="code" href="functions__0_8txt.html#a4cd641df34659abb61c41ded50daf3ce">terms</a>          |       101 |       111<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |         2% |</div>
<div class="line">| Assemble Stokes <a class="code" href="functions__0_8txt.html#a4cd641df34659abb61c41ded50daf3ce">terms</a>           |       101 |       208<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |       3.8% |</div>
<div class="line">| Initial setup                   |         1 |   0.00187s |         0% |</div>
<div class="line">| Output fluid                    |       102 |      15.5s |      0.28% |</div>
<div class="line">| Output solid <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>          |       102 |      2.63s |         0% |</div>
<div class="line">| Output tracer <a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>         |       102 |      2.49s |         0% |</div>
<div class="line">| Refine                          |        20 |      18.4s |      0.33% |</div>
<div class="line">| Set solid <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> <a class="code" href="base_2utilities__0_8txt.html#a5b55f653ddb6c9850a414d80c71827a5">position</a>     |       100 |       6.1s |      0.11% |</div>
<div class="line">| Set tracer <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> motion      |       101 |      10.8s |       0.2% |</div>
<div class="line">| Setup <a class="code" href="distributed__0_8txt.html#ad207fe81a5be05e18534713c2677da7b">dofs</a>                      |        21 |      13.9s |      0.25% |</div>
<div class="line">| Solve                           |       101 |  5.16e+03<a class="code" href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a> |        93% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p>Now, the solver is taking most of the solution time in three dimensions, and the particle motion and Nitsche assembly remain relatively unimportant as far as run time is concerned.</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Srwq7zyR9mg"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The current tutorial program shows a one-way coupling between the fluid and the solid, where the solid motion is imposed (and not solved for), and read in the solid domain by exploiting the location and the weights of the solid quadrature points.</p>
<p>The structure of the code already allows one to implement a two-way coupling, by exploiting the possibility to read values of the fluid velocity on the quadrature points of the solid grid. For this to be more efficient in terms of MPI communication patterns, one should maintain ownership of the quadrature points on the solid processor that owns the cells where they have been created. In the current code, it is sufficient to define the <a class="el" href="classIndexSet.html">IndexSet</a> of the vectors used to exchange information of the quadrature points by using the solid partition instead of the initial fluid partition.</p>
<p>This allows the combination of the technique used in this tutorial program with those presented in the tutorial <a class="el" href="step_60.html">step-60</a> to solve a fluid structure interaction problem with distributed Lagrange multipliers, on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<p>The timings above show that the current preconditioning strategy does not work well for Nitsche penalization, and we should come up with a better preconditioner if we want to aim at larger problems. Moreover, a checkpoint restart strategy should be implemented to allow for longer simulations to be interrupted and restored, as it is done for example in the <a class="el" href="step_69.html">step-69</a> tutorial.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2020 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceLA.html">LA</a></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div>
<div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div>
<div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">} <span class="comment">// namespace LA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep70.html">Step70</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters</a> : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="function__time__0_8txt.html#a1ee09a9dd26d8e6c3685fe170eb40343">set_time</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">      angular_velocity.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div>
<div class="line">    <span class="keywordtype">double</span>       <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>           = 1.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> viscosity    = 1.0;</div>
<div class="line">    <span class="keywordtype">double</span> penalty_term = 100;</div>
<div class="line"> </div>
<div class="line">    std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div>
<div class="line"> </div>
<div class="line">    std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div>
<div class="line">    std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div>
<div class="line">    std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div>
<div class="line">    std::string arguments_for_solid_grid = <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ?</div>
<div class="line">                                             <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div>
<div class="line">                                             <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div>
<div class="line">    std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div>
<div class="line">    std::string arguments_for_particle_grid =</div>
<div class="line">      <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span>          max_level_refinement = 8;</div>
<div class="line">    <span class="keywordtype">int</span>          min_level_refinement = 5;</div>
<div class="line">    std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div>
<div class="line">    <span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div>
<div class="line">    <span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div>
<div class="line">    <span class="keywordtype">int</span>          refinement_frequency = 5;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>;</div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div>
<div class="line">      angular_velocity;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,</div>
<div class="line">                                  <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;<a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">::StokesImmersedProblemParameters</a>()</div>
<div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div>
<div class="line">    , <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<span class="stringliteral">&quot;Right hand side&quot;</span>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1)</div>
<div class="line">    , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div>
<div class="line">                  initial_fluid_refinement,</div>
<div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div>
<div class="line">                  initial_solid_refinement,</div>
<div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div>
<div class="line">                  fluid_rtree_extraction_level,</div>
<div class="line">                  <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div>
<div class="line">      particle_insertion_refinement,</div>
<div class="line">      <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div>
<div class="line">      homogeneous_dirichlet_ids,</div>
<div class="line">      <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div>
<div class="line"> </div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div>
<div class="line"> </div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div>
<div class="line">                    arguments_for_particle_grid);</div>
<div class="line">    }</div>
<div class="line">    leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div>
<div class="line">                    refinement_strategy,</div>
<div class="line">                    <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                    this-&gt;prm,</div>
<div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div>
<div class="line">    }</div>
<div class="line">    leave_subsection();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div>
<div class="line">                                                              <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">    });</div>
<div class="line">    angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">      this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div>
<div class="line">      : angular_velocity(angular_velocity)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line">      <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[0]        = -omega * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">      <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[1]        = omega * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">      , angular_velocity(angular_velocity)</div>
<div class="line">      , time_step(time_step)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> dtheta = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) * time_step;</div>
<div class="line"> </div>
<div class="line">      new_position[0] = <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0] - <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">      new_position[1] = <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0] + <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> new_position[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div>
<div class="line">    {</div>
<div class="line">      time_step = new_time_step;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">    <span class="keywordtype">double</span>                                     time_step;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;dim, spacedim&gt;</a> &amp;par);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setup_tracer_particles();</div>
<div class="line">    <span class="keywordtype">void</span> setup_solid_particles();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initial_setup();</div>
<div class="line">    <span class="keywordtype">void</span> setup_dofs();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> assemble_stokes_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_nitsche_restriction();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> refine_and_transfer();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>,</div>
<div class="line">                          std::string                                 fprefix,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;dim, spacedim&gt;</a> &amp;par;</div>
<div class="line"> </div>
<div class="line">    MPI_Comm mpi_communicator;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div>
<div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div>
<div class="line">    std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div>
<div class="line"> </div>
<div class="line">    DoFHandler&lt;spacedim&gt;      fluid_dh;</div>
<div class="line">    DoFHandler&lt;dim, spacedim&gt; solid_dh;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div>
<div class="line">    std::vector&lt;IndexSet&gt; solid_owned_dofs;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div>
<div class="line">    std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> system_matrix;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> locally_relevant_solution;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div>
<div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> tracer_particle_velocities;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;dim, spacedim&gt;</a> &amp;par)</div>
<div class="line">    : par(par)</div>
<div class="line">    , mpi_communicator(MPI_COMM_WORLD)</div>
<div class="line">    , pcout(std::cout,</div>
<div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="base_2partitioner__0_8txt.html#a6d2d0fa485d1660823c59c494fb0fb31">MPI</a>::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div>
<div class="line">    , computing_timer(mpi_communicator,</div>
<div class="line">                      pcout,</div>
<div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div>
<div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div>
<div class="line">    , fluid_tria(mpi_communicator,</div>
<div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::MeshSmoothing(</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_refinement |</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_coarsening))</div>
<div class="line">    , solid_tria(mpi_communicator,</div>
<div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::MeshSmoothing(</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_refinement |</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::smoothing_on_coarsening))</div>
<div class="line">    , fluid_dh(fluid_tria)</div>
<div class="line">    , solid_dh(solid_tria)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(<span class="keyword">const</span> std::string &amp;grid_file_name,</div>
<div class="line">                               <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div>
<div class="line">                               <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div>
<div class="line">    grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div>
<div class="line">    grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div>
<div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>   = pair.first;</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> = boost::algorithm::to_lower_copy(</div>
<div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div>
<div class="line"> </div>
<div class="line">        TopoDS_Shape shape;</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;iges&quot;</span> || <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;igs&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;step&quot;</span> || <a class="code" href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a> == <span class="stringliteral">&quot;stp&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="table__0_8txt.html#ab0c207fc9a63cc7861178ab4e76b2da9">n_elements</a> = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div>
<div class="line">        <span class="keywordflow">if</span> ((std::get&lt;0&gt;(<a class="code" href="table__0_8txt.html#ab0c207fc9a63cc7861178ab4e76b2da9">n_elements</a>) == 0))</div>
<div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div>
<div class="line">            <a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">            <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 3)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div>
<div class="line">            t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div>
<div class="line">                              shape));</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div>
<div class="line">                              <a class="code" href="geometry__info__0_8txt.html#aeab70d834b7bc032f4ab627e72d6084c">TopoDS::Face</a>(shape)));</div>
<div class="line">      }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    (void)ids_and_cad_file_names;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">      {</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(par.name_of_fluid_grid,</div>
<div class="line">                                par.arguments_for_fluid_grid,</div>
<div class="line">                                fluid_tria);</div>
<div class="line">      }</div>
<div class="line">    fluid_tria.refine_global(par.initial_fluid_refinement);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">read_grid_and_cad_files</a>(par.name_of_solid_grid,</div>
<div class="line">                                par.arguments_for_solid_grid,</div>
<div class="line">                                solid_tria);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    solid_tria.refine_global(par.initial_solid_refinement);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div>
<div class="line">      mpi_communicator);</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">      particle_insert_tria,</div>
<div class="line">      par.name_of_particle_grid,</div>
<div class="line">      par.arguments_for_particle_grid);</div>
<div class="line">    particle_insert_tria.refine_global(par.particle_insertion_refinement);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div>
<div class="line">    DoFHandler&lt;spacedim&gt; particles_dof_handler(particle_insert_tria);</div>
<div class="line">    particles_dof_handler.distribute_dofs(particles_fe);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div>
<div class="line">    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_tria.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">        all_boxes.emplace_back(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;bounding_box());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a> = <a class="code" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div>
<div class="line">      <a class="code" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(<a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>, par.fluid_rtree_extraction_level);</div>
<div class="line"> </div>
<div class="line">    global_fluid_bounding_boxes =</div>
<div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div>
<div class="line"> </div>
<div class="line">    tracer_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                       <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div>
<div class="line">                                              global_fluid_bounding_boxes,</div>
<div class="line">                                              tracer_particle_handler);</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div>
<div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    locally_owned_tracer_particle_coordinates =</div>
<div class="line">      tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div>
<div class="line">        <a class="code" href="base_2index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>));</div>
<div class="line"> </div>
<div class="line">    locally_relevant_tracer_particle_coordinates =</div>
<div class="line">      locally_owned_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div>
<div class="line">      tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(fluid_fe-&gt;degree + 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div>
<div class="line">    solid_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                      <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div>
<div class="line">                                      n_properties);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div>
<div class="line">    quadrature_points_vec.reserve(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.size() *</div>
<div class="line">                                  solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>;</div>
<div class="line">    <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>.reserve(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.size() *</div>
<div class="line">                       solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div>
<div class="line">                                 <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : solid_dh.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">        {</div>
<div class="line">          fe_v.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a> = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>.size(); ++q)</div>
<div class="line">            {</div>
<div class="line">              quadrature_points_vec.emplace_back(<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>[q]);</div>
<div class="line">              <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>.emplace_back(</div>
<div class="line">                std::vector&lt;double&gt;(n_properties, <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>[q]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div>
<div class="line">             <span class="stringliteral">&quot;I was expecting the &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    solid_particle_handler.insert_global_particles(quadrature_points_vec,</div>
<div class="line">                                                   global_fluid_bounding_boxes,</div>
<div class="line">                                                   <a class="code" href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.post_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    fluid_fe =</div>
<div class="line">      std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div>
<div class="line">                                           <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>,</div>
<div class="line">                                           <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div>
<div class="line">                                                          1),</div>
<div class="line">                                           1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div>
<div class="line">    solid_dh.distribute_dofs(*solid_fe);</div>
<div class="line"> </div>
<div class="line">    fluid_quadrature_formula =</div>
<div class="line">      std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">    solid_quadrature_formula =</div>
<div class="line">      std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    fluid_dh.distribute_dofs(*fluid_fe);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, 0);</div>
<div class="line">    stokes_sub_blocks[<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>] = 1;</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> dofs_per_block =</div>
<div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">          &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div>
<div class="line">          &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div>
<div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    fluid_owned_dofs.resize(2);</div>
<div class="line">    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div>
<div class="line">    fluid_owned_dofs[1] =</div>
<div class="line">      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div>
<div class="line">    fluid_relevant_dofs.resize(2);</div>
<div class="line">    fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div>
<div class="line">    fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(</div>
<div class="line">        fluid_dh,</div>
<div class="line">        0,</div>
<div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1),</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>,</div>
<div class="line">        fluid_fe-&gt;component_mask(<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>));</div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div>
<div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a>(mpi_communicator,</div>
<div class="line">                                 fluid_dh.locally_owned_dofs());</div>
<div class="line">    {</div>
<div class="line">      system_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = 0; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">            coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> || <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> || <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">            coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        fluid_dh, coupling, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">        dsp,</div>
<div class="line">        locally_owned_dofs_per_processor,</div>
<div class="line">        mpi_communicator,</div>
<div class="line">        locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = 0; <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> == <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">            coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[<a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        fluid_dh, coupling, dsp, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>, <span class="keyword">false</span>);</div>
<div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">        dsp,</div>
<div class="line">        locally_owned_dofs_per_processor,</div>
<div class="line">        mpi_communicator,</div>
<div class="line">        locally_relevant_dofs);</div>
<div class="line">      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution.reinit(fluid_owned_dofs,</div>
<div class="line">                                     fluid_relevant_dofs,</div>
<div class="line">                                     mpi_communicator);</div>
<div class="line">    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system</a>()</div>
<div class="line">  {</div>
<div class="line">    system_matrix         = 0;</div>
<div class="line">    preconditioner_matrix = 0;</div>
<div class="line">    system_rhs            = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div>
<div class="line">                                 *fluid_quadrature_formula,</div>
<div class="line">                                 <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                   <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = fluid_quadrature_formula-&gt;size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>,</div>
<div class="line">                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1));</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    std::vector&lt;double&gt;              div_phi_u(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    std::vector&lt;double&gt;              phi_p(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_dh.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>  = 0;</div>
<div class="line">          cell_matrix2 = 0;</div>
<div class="line">          cell_rhs     = 0;</div>
<div class="line"> </div>
<div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">          par.rhs.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                    rhs_values);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">                {</div>
<div class="line">                  grad_phi_u[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>] = fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].gradient(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">                  div_phi_u[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>]  = fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">                  phi_p[<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>]      = fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                    {</div>
<div class="line">                      <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                        (par.viscosity *</div>
<div class="line">                           <a class="code" href="base_2symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>], grad_phi_u[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]) -</div>
<div class="line">                         div_phi_u[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] * phi_p[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] - phi_p[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] * div_phi_u[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>]) *</div>
<div class="line">                        fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">                      cell_matrix2(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += 1.0 / par.viscosity * phi_p[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] *</div>
<div class="line">                                            phi_p[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] * fe_values.JxW(q);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">                    fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>).first;</div>
<div class="line">                  cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                                 rhs_values[q](component_i) * fe_values.JxW(q);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">          <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(<a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>,</div>
<div class="line">                                                 cell_rhs,</div>
<div class="line">                                                 <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                                 system_matrix,</div>
<div class="line">                                                 system_rhs);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix2,</div>
<div class="line">                                                 <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                                 preconditioner_matrix);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    system_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">    preconditioner_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">    system_rhs.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line"> </div>
<div class="line">    SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div>
<div class="line">      fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div>
<div class="line">                                    fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line">    <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div>
<div class="line">      1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> = solid_particle_handler.<a class="code" href="classArrayView.html#a1a1c62a26e5f55bfe124894c0a31386f">begin</a>();</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> != solid_particle_handler.<a class="code" href="classArrayView.html#a775e02d2deaf2f769e24dee0c3e7a582">end</a>())</div>
<div class="line">      {</div>
<div class="line">        local_matrix = 0;</div>
<div class="line">        local_rhs    = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a>-&gt;get_surrounding_cell(fluid_tria);</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div>
<div class="line">          <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, &amp;fluid_dh);</div>
<div class="line">        dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> : pic)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_reference_location();</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_location();</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>    = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>.get_properties()[0];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; fluid_fe-&gt;n_dofs_per_cell(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">              {</div>
<div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div>
<div class="line">                  fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>).first;</div>
<div class="line">                <span class="keywordflow">if</span> (comp_i &lt; <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">                  {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">                         ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">                      {</div>
<div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div>
<div class="line">                          fluid_fe-&gt;system_to_component_index(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>).first;</div>
<div class="line">                        <span class="keywordflow">if</span> (comp_i == comp_j)</div>
<div class="line">                          local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">                            penalty_parameter * par.penalty_term *</div>
<div class="line">                            fluid_fe-&gt;shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, ref_q) *</div>
<div class="line">                            fluid_fe-&gt;shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, ref_q) * <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>;</div>
<div class="line">                      }</div>
<div class="line">                    local_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += penalty_parameter * par.penalty_term *</div>
<div class="line">                                    solid_velocity.value(real_q, comp_i) *</div>
<div class="line">                                    fluid_fe-&gt;shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, ref_q) * <a class="code" href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a>;</div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(local_matrix,</div>
<div class="line">                                               local_rhs,</div>
<div class="line">                                               fluid_dof_indices,</div>
<div class="line">                                               system_matrix,</div>
<div class="line">                                               system_rhs);</div>
<div class="line">        <a class="code" href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a> = pic.<a class="code" href="classArrayView.html#a775e02d2deaf2f769e24dee0c3e7a582">end</a>();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    system_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">    system_rhs.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">StokesImmersedProblem&lt;dim, spacedim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a326d001228d45e600ba97606c24a01c7">LA::MPI::PreconditionAMG</a> prec_A;</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="relaxation__block__0_8txt.html#a2076fd56276055e74e230fad6edac013">LA::MPI::PreconditionAMG::AdditionalData</a> <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_A.initialize(system_matrix.block(0, 0), <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a326d001228d45e600ba97606c24a01c7">LA::MPI::PreconditionAMG</a> prec_S;</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="relaxation__block__0_8txt.html#a2076fd56276055e74e230fad6edac013">LA::MPI::PreconditionAMG::AdditionalData</a> <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="symmetric__tensor__0_8txt.html#a37cd5701f5aaccacc8caf38d4a7a903a">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(<a class="code" href="symmetric__tensor__0_8txt.html#a37cd5701f5aaccacc8caf38d4a7a903a">A</a>, prec_A);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div>
<div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(S, prec_S);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div>
<div class="line">                                          1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8 * system_rhs.l2_norm(),</div>
<div class="line">                                          1.e-2);</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="symmetric__tensor__0_8txt.html#aeaf892aa244db24771fb1ff7cce8057f">P</a> = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div>
<div class="line">      <a class="code" href="function__0_8txt.html#a931d002b61ed821e97fe70a7bf5b35f2">std::array</a>&lt;</div>
<div class="line">        ::<a class="code" href="classLinearOperator.html">LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;</a>,</div>
<div class="line">        2&gt;{{amgA, amgS}});</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div>
<div class="line">                                 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-10 * system_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>(solver_control);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>.solve(system_matrix, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, system_rhs, <a class="code" href="symmetric__tensor__0_8txt.html#aeaf892aa244db24771fb1ff7cce8057f">P</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(fluid_dh,</div>
<div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div>
<div class="line">                                      locally_relevant_solution,</div>
<div class="line">                                      <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>);</div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1).add(-mean_pressure);</div>
<div class="line">    locally_relevant_solution.block(1) = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>(0);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div>
<div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div>
<div class="line">                                              par.velocity_degree + 1),</div>
<div class="line">                                            {},</div>
<div class="line">                                            locally_relevant_solution,</div>
<div class="line">                                            error_per_cell,</div>
<div class="line">                                            fluid_fe-&gt;component_mask(<a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div>
<div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">          refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div>
<div class="line">                                            error_per_cell,</div>
<div class="line">                                            par.refinement_fraction,</div>
<div class="line">                                            par.coarsening_fraction);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div>
<div class="line">          fluid_tria,</div>
<div class="line">          error_per_cell,</div>
<div class="line">          par.refinement_fraction,</div>
<div class="line">          par.coarsening_fraction,</div>
<div class="line">          par.max_cells);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : fluid_tria.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;refine_flag_set() &amp;&amp;</div>
<div class="line">            <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level() == par.max_level_refinement)</div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;clear_refine_flag();</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;coarsen_flag_set() &amp;&amp;</div>
<div class="line">            <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level() == par.min_level_refinement)</div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;clear_coarsen_flag();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div>
<div class="line">      <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>(fluid_dh);</div>
<div class="line">    fluid_tria.prepare_coarsening_and_refinement();</div>
<div class="line">    <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div>
<div class="line">    fluid_tria.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line">    setup_dofs();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a>.interpolate(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    locally_relevant_solution = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>,</div>
<div class="line">                                                       <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; solution_names(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">      data_component_interpretation(</div>
<div class="line">        <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">    data_component_interpretation.push_back(</div>
<div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div>
<div class="line">                             solution_names,</div>
<div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div>
<div class="line">                             data_component_interpretation);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>(fluid_tria.n_active_cells());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      <a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) = fluid_tria.locally_owned_subdomain();</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a>, <span class="stringliteral">&quot;subdomain&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                   mpi_communicator);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div>
<div class="line">    times_and_names.push_back(std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename));</div>
<div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>,</div>
<div class="line">    std::string                                 fprefix,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div>
<div class="line">    particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>);</div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">    particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                        mpi_communicator);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div>
<div class="line">      times_and_names;</div>
<div class="line">    <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div>
<div class="line">      times_and_names[fprefix].<a class="code" href="q__collection__0_8txt.html#a98a6b91a750cdd7301bb66162fa71e80">push_back</a>(std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename));</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      times_and_names[fprefix] = {std::make_pair(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, filename)};</div>
<div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div>
<div class="line">                               <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>) +</div>
<div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div>
<div class="line">                             <a class="code" href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a2713a592c467d1b282bdde44c65f6111">ParameterHandler::Short</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div>
<div class="line">    <span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>         = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> = 0; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt; par.number_of_time_steps;</div>
<div class="line">         ++<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">      {</div>
<div class="line">        par.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a>();</div>
<div class="line">            initial_setup();</div>
<div class="line">            setup_dofs();</div>
<div class="line">            setup_tracer_particles();</div>
<div class="line">            setup_solid_particles();</div>
<div class="line">            tracer_particle_velocities.reinit(</div>
<div class="line">              locally_owned_tracer_particle_coordinates, mpi_communicator);</div>
<div class="line">            output_results(output_cycle, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div>
<div class="line">                                 <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div>
<div class="line"> </div>
<div class="line">            SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div>
<div class="line">                                                   time_step);</div>
<div class="line">            solid_particle_handler.set_particle_positions(solid_position,</div>
<div class="line">                                                          <span class="keyword">false</span>);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div>
<div class="line">          <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div>
<div class="line">            fluid_dh,</div>
<div class="line">            tracer_particle_handler,</div>
<div class="line">            locally_relevant_solution,</div>
<div class="line">            tracer_particle_velocities,</div>
<div class="line">            fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div>
<div class="line"> </div>
<div class="line">          tracer_particle_velocities *= time_step;</div>
<div class="line"> </div>
<div class="line">          locally_relevant_tracer_particle_coordinates =</div>
<div class="line">            tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div>
<div class="line">              <a class="code" href="base_2index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>));</div>
<div class="line"> </div>
<div class="line">          relevant_tracer_particle_displacements.reinit(</div>
<div class="line">            locally_owned_tracer_particle_coordinates,</div>
<div class="line">            locally_relevant_tracer_particle_coordinates,</div>
<div class="line">            mpi_communicator);</div>
<div class="line"> </div>
<div class="line">          relevant_tracer_particle_displacements = tracer_particle_velocities;</div>
<div class="line"> </div>
<div class="line">          tracer_particle_handler.set_particle_positions(</div>
<div class="line">            relevant_tracer_particle_displacements);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        assemble_stokes_system();</div>
<div class="line">        assemble_nitsche_restriction();</div>
<div class="line">        <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> % par.output_frequency == 0)</div>
<div class="line">          {</div>
<div class="line">            output_results(output_cycle, <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">            }</div>
<div class="line">            ++output_cycle;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> % par.refinement_frequency == 0 &amp;&amp;</div>
<div class="line">            <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a> != par.number_of_time_steps - 1)</div>
<div class="line">          refine_and_transfer();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step70</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespaceStep70.html">Step70</a>;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">  <a class="code" href="base_2logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line">      std::string prm_file;</div>
<div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">        prm_file = argv[1];</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;2, 3&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;2, 3&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;3&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;3&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblemParameters.html">StokesImmersedProblemParameters&lt;2&gt;</a> par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="classStep70_1_1StokesImmersedProblem.html">StokesImmersedProblem&lt;2&gt;</a> <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(par);</div>
<div class="line">          <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 This tutorial depends on <a class="el" href="step_19.html">step-19</a> , <a class="el" href="step_32.html">step-32</a> , <a class="el" href="step_60.html">step-60</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a>
      <ul>
        <li><a href="#Codimensiononecase">Co-dimension one case</a><a href="#Codimensiononecase">Co-dimension one case</a>
        <li><a href="#Codimensionzerocase">Co-dimension zero case</a><a href="#Codimensionzerocase">Co-dimension zero case</a>
        <li><a href="#Representationofand">Representation of Ω and Γ</a><a href="#Representationofand">Representation of Ω and Γ</a>
        <li><a href="#Usingparticlestotrack">Using particles to track Γ</a><a href="#Usingparticlestotrack">Using particles to track Γ</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The testcase</a>
        <li><a href="#Morereferences"> More references</a><a href="#Morereferences"> More references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a><a href="#Runtimeparameterhandling">Run-time parameter handling</a>
        <li><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a>
        <li><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a>
      <ul>
        <li><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a>
        <li><a href="#Particleinitializationfunctions">Particle initialization functions</a><a href="#Particleinitializationfunctions">Particle initialization functions</a>
        <li><a href="#DoFinitializationfunctions">DoF initialization functions</a><a href="#DoFinitializationfunctions">DoF initialization functions</a>
        <li><a href="#Assemblyfunctions">Assembly functions</a><a href="#Assemblyfunctions">Assembly functions</a>
        <li><a href="#Solvingthelinearsystem">Solving the linear system</a><a href="#Solvingthelinearsystem">Solving the linear system</a>
        <li><a href="#Meshrefinement">Mesh refinement</a><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Creatingoutputforvisualization">Creating output for visualization</a><a href="#Creatingoutputforvisualization">Creating output for visualization</a>
        <li><a href="#Therunfunction">The "run" function</a><a href="#Therunfunction">The "run" function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a><a href="#Twodimensionaltestcase"> Two dimensional test case </a>
        <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a><a href="#Threedimensionaltestcase"> Three dimensional test case </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
 <br  />
 <em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em> </p><dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a>  <br  />
</dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>In this tutorial we consider a mixing problem in the laminar flow regime.Such problems occur in a wide range of applications ranging from chemical engineering to powergeneration (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically,because they often involve a container (with fixed boundaries, and possiblycomplex geometries such as baffles), represented by the domain \(\Omega\) ,and one (or more) immersed and rotating impellers (represented by the domain \(\Omega^{\text{imp}}\) ).The domain in which we would like to solve the flow equations is the (timedependent) difference between the two domains, namely: \(\Omega\setminus\Omega^{\text{imp}}\) . For rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations(in which the fluid domain</p>
<ul>
<li>along with the mesh!</li>
<li>is smoothly deformed to follow the deformationsof the immersed solid) is not possible, unless only small times (i.e.,small fluid domain deformations) are considered. If one wants to track theevolution of the flow across multiple rotations of the impellers, the resultingdeformed grid would simply be too distorted to be useful. In this case, a viable alternative strategy would be to use non-matchingmethods (similarly to what we have done in <a class="el" href="step_60.html">step-60</a> ), where a background fixedgrid (that may or may not be locally refined in time to better capture the solidmotion) is coupled with a rotating, independent, grid. In order to maintain the same notations used in <a class="el" href="step_60.html">step-60</a> , we use \(\Omega\) todenote the domain in \({\mathbb R}^{\text{spacedim}}\) representing the container of boththe fluid and the impeller, and we use \(\Gamma\) in \({\mathbb R}^{\text{dim}}\) to denoteeither the full impeller (when its <code>spacedim</code> measure is non-negligible, i.e.,when we can represent it as a grid of dimension <code>dim</code> equal to <code>spacedim</code>),a co-dimension one representation of a thin impeller, or just the boundary ofthe full impeller. The domain \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\) ) and itis non-matching: It does not, in general, align with any of thefeatures of the volume mesh. We solve a partial differential equation on \(\Omega\) ,enforcing some conditions on the solution of the problem on the embeddeddomain \(\Gamma\) by some penalization techniques. In the current case,the condition is that the velocity of the fluid at points on \(\Gamma\) equal the velocity of the solid impeller at that point. The technique we describe here is presented in the literature using one of manynames: the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is that the discretization of thetwo grids are kept completely independent. In the present tutorial, thisapproach is used to solve for the motion of a viscous fluid, described by theStokes equation, that is agitated by a rigid non-deformable impeller. Thus, the equations solved in \(\Omega\) are the Stokes equations for a creepingflow (i.e. a flow where \(\text{Re}\rightarrow 0\) ) and a no-slip boundarycondition is applied on the movingembedded domain* \(\Gamma\) associated withthe impeller. However, this tutorial could be readily extendedto other equations (e.g. the Navier-Stokes equations, linear elasticityequation, etc.). It can be seen as a natural extension of <a class="el" href="step_60.html">step-60</a> thatenables the solution of large problems using a distributed parallel computingarchitecture via MPI. However, contrary to <a class="el" href="step_60.html">step-60</a> , the Dirichlet boundary conditions on \(\Gamma\) are imposed weakly instead of through the use of Lagrange multipliers, and weconcentrate on dealing with the coupling of two fully distributedtriangulations (a combination that was not possible in the implementation of <a class="el" href="step_60.html">step-60</a> ). There are two interesting scenarios that occur when one wants to enforceconditions on the embedded domain \(\Gamma\) :</li>
<li>The geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same ofthe domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero. In this case, the imposition of the Dirichlet boundaryboundary condition on \(\Gamma\) is done through a volumetric penalization. If theapplied penalization only depends on the velocity, this is often referredto as \(\mathcal{L}^2\) penalization whereas if the penalization dependson both the velocity and its gradient, it is an \(\mathcal{H}^1\) penalization.The case of the \(\mathcal{L}^2\) penalization is very similar to a Darcy-typeapproach. Both \(\mathcal{L}^2\) and \(\mathcal{H}^1\) penalizations have beenanalyzed extensively (see, for example, <b>[Angot1999]</b> ).</li>
<li>The embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smallerthan that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure iszero; for example it is a curve embedded in a two dimensional domain, or asurface embedded in a three-dimensional domain. This is of coursephysically impossible, but one may consider very thin sheets of metalmoving in a fluid as essentially lower-dimensional if the thickness ofthe sheet is negligible. In this case, the boundarycondition is imposed weakly on \(\Gamma\) by applying the<a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a> method (see <b>[Freund1995]</b> ). Both approaches have very similar requirements and result in highlysimilar formulations. Thus, we treat them almost in the same way. In this tutorial program we are not interested in further details on \(\Gamma\) :we assume that the dimension of the embedded domain (<code>dim</code>) is always smaller byone or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>). We are going to solve the following differential problem: given a sufficientlyregular function \(g\) on \(\Gamma\) , find the solution \((\textbf{u},p)\) to <p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
</li>
</ul>
<p>This equation, which we have normalized by scaling the time units insuch a way that the viscosity has a numerical value of 1, describesslow, viscous flow such as honey or lava.The main goal of this tutorial is to show how to impose the velocity fieldcondition \(\mathbf{u} = \mathbf{g}\) on a non-matching \(\Gamma\) in a weak way,using a penalization method. A more extensive discussion of the Stokesproblem including body forces, different boundary conditions, and solutionstrategies can be found in <a class="el" href="step_22.html">step-22</a> . Let us start by considering the Stokes problem alone, in the entire domain \(\Omega\) . We look for a velocity field \(\mathbf{u}\) and a pressure field \(p\) that satisfy the Stokes equations with homogeneous boundary conditionson \(\partial\Omega\) . The weak form of the Stokes equations is obtained by first writing it in vectorform as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued testfunction \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) , and integratingover the domain \(\Omega\) , yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) .</p>
<p>Integrating by parts and exploiting the boundary conditions on \(\partial\Omega\) ,we obtain the following variational problem: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) represents the \(L^2\) scalarproduct. This is the same variational form used in <a class="el" href="step_22.html">step-22</a> . This variational formulation does not take into account the embedded domain.Contrary to <a class="el" href="step_60.html">step-60</a> , we do not enforce strongly the constraints of \(\textbf{u}\) on \(\Gamma\) , but enforce them weakly via a penalization term. The analysis of this weak imposition of the boundary condition depends on thespacedim-dimensional measure of \(\Gamma\) as either positive (if <code>dim</code> is equalto <code>spacedim</code>) or zero (if <code>dim</code> is smaller than <code>spacedim</code>). We discuss bothscenarios.</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>In this case, we assume that \(\Gamma\) is the boundary of the actual impeller,that is, a closed curve embedded in a two-dimensional domain or a closedsurface in a three-dimensional domain. The idea of this method starts byconsidering a weak imposition of the Dirichlet boundary condition on \(\Gamma\) ,following the Nitsche method. This is achieved by using the following modified formulationon the fluid domain, where no strong conditions on the test functions on \(\Gamma\) are imposed: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>The integrals over \(\Gamma\) are lower-dimensional integrals. It can be shown (see <b>[Freund1995]</b> ) that there exists a positive constant \(C_1\) so that if \(\beta &gt; C_1\) , the weak imposition of the boundary willbe consistent and stable. The first two additional integrals on \(\Gamma\) (thesecond line in the equation above) appear naturally after integrating by parts,when one does not assume that \(\mathbf{v}\) is zero on \(\Gamma\) . The third line in the equation above contains two terms that are added to ensureconsistency of the weak form, and a stabilization term, that is there to enforcethe boundary condition with an error which is consistent with the approximationerror. The consistency terms and the stabilization term are added to theright hand side with the actual boundary data \(\mathbf{g}\) . When \(\mathbf{u}\) satisfies the condition \(\mathbf{u}=\mathbf{g}\) on \(\Gamma\) ,all the consistency and stability integrals on \(\Gamma\) cancel out, and one isleft with the usual weak form of Stokes flow, that is, the above formulation isconsistent. We note that an alternative (non-symmetric) formulation can be used : </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p> Note the different sign of the first terms on the third and fourth lines.In this case, the stability and consistency conditions become \(\beta &gt; 0\) . Inthe symmetric case, the value of \(\beta\) is dependent on \(h\) , and it is ingeneral chosen such that \(\beta = C h^{-1} \) with \(h\) a measure of size of the face being integrated and \(C\) a constant such that \(1 \leq C \leq 10\) . This is as one usually does with the Nitschepenalty method to enforcing Dirichlet boundary conditions. The non-symmetric approach, on the other hand, is related to how oneenforced continuity for the non-symmetric interior penalty method fordiscontinuous Galerkin methods (the "NIPG" method <b>[Riviere1999]</b> ).Even if the non-symmetric case seems advantageous w.r.t.possible choices of stabilization parameters, we opt for the symmetricdiscretization, since in this case it can be shown that the dual problem isalso consistent, leading to a solution where not only the energy norm of thesolution converges with the correct order, but also its \(L^2\) norm. Furthermore, the resulting matrix remains symmetric. The above formulation works under the assumption that the domain is discretizedexactly. However, if the deformation of the impeller is a rigid bodymotion, it is possible to artificially extend the solution of the Stokesproblem inside the propeller itself, since a rigid body motion is also asolution to the Stokes problem. The idea is then to solve the same problem,inside \(\Omega^{\text{imp}}\) , imposing the same boundary conditions on \(\Gamma\) , using the same penalization technique, and testing with testfunctions \(\mathbf{v}\) which are globally continuous over \(\Omega\) . This results in the following (intermediate) formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p> where the jump terms, denoted with \(\lbrack \cdot \rbrack\) , are computed withrespect to a fixed orientation of the normal vector \(\textbf{n}\) . Thefactor of 2 appears in front of \(\beta\) since we see every part of \(\Gamma\) twice, once from within the fluid and once from within theobstacle moving around in it. (For all of the other integrals over \(\Gamma\) , we visit each part of \(\Gamma\) twice, but with oppositesigns, and consequently get the jump terms.) Here we notice that, unlike in discontinuous Galerkin methods, the testand trial functions are continuous across \(\Gamma\) . Moreover, if \(\Gamma\) isnot aligned with cell boundaries, all the jump terms are also zero, since, ingeneral, finite element function spaces are smooth inside each cell, and if \(\Gamma\) cuts through an element intersecting its boundary only at a finitenumber of points, all the contributions on \(\Gamma\) , with the exception ofthe stabilization ones, can be neglected from the formulation, resulting inthe following final form of the variational formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>In <a class="el" href="step_60.html">step-60</a> , the imposition of the constraintrequired the addition of new variables in the form of Lagrange multipliers.This is not the case for this tutorial program. The imposition of theboundary condition using Nitsche's method only modifies the system matrixand the right-hand side without adding additional unknowns.However, the velocity vector \(\textbf{u}\) on the embedded domain will not matchexactly the prescribed velocity \(\textbf{g}\) , but only up to a numerical errorwhich is in the same order as the interpolation error of the finite elementmethod. Furthermore, as in <a class="el" href="step_60.html">step-60</a> , we still need to integrate over thenon-matching embedded grid in order to construct the boundary term necessaryto impose the boundary condition over \(\Gamma\) .</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>In this case, \(\Gamma\) has the same dimension, but is embedded into \(\Omega\) . We can think of this as a thick object moving around in the fluid.In the case of \(\mathcal{L}^2\) penalization, the additional penalizationterm can be interpreted as a Darcy term within \(\Gamma\) , resulting in: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Here, integrals over \(\Gamma\) are simply integrals over a part of the volume.The \(\mathcal{L}^2\) penalization thus consists in adding a volumetric term thatconstrains the velocity of the fluid to adhere to the velocity of the rigid bodywithin \(\Gamma\) . Also in this case, \(\beta\) must be chosen sufficiently largein order to ensure that the Dirichlet boundary condition in \(\Gamma\) issufficiently respected, but not too high in order to maintain the properconditioning of the system matrix. A \(\mathcal{H}^1\) penalization may be constructed in a similar manner, with theaddition of a viscous component to the penalization that dampens the velocitygradient within \(\Gamma\) : </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Notice that the \(L^2\) penalization (<code>dim</code> equal to <code>spacedim</code>) and the Nitschepenalization (<code>dim</code> equal to <code>spacedim-1</code>) result in the exact same numericalimplementation, thanks to the dimension independent capabilities of deal.II.</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>In this tutorial, both the embedded grid \(\Gamma\) and the embeddinggrid are described using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. These twotriangulations can be built from functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or by readinga mesh file produced with another application (e.g. GMSH, see thediscussion in <a class="el" href="step_49.html">step-49</a> ). This is slightlymore general than what was previously done in <a class="el" href="step_60.html">step-60</a> . The addition of the immersed boundary method, whetherit is in the <code>dim=spacedim</code> or <code>dim&lt;spacedim</code> case, only introducesadditional terms in the system matrix and the right-hand side of thesystem which result from the integration over \(\Gamma\) . This does notmodify the number of variables for which the problemmust be solved. The challenge is thus related to the integralsthat must be carried over \(\Gamma\) . As usual in finite elements we split this integral into contributions from allcells of the triangulation used todiscretize \(\Gamma\) , we transform the integral on \(K\) to an integral on thereference element \(\hat K\) , where \(F_{K}\) is the mapping from \(\hat K\) to \(K\) ,and compute the integral on \(\hat K\) using a quadrature formula. For example: </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\) . In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(y_i = F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\) , and unlesswe figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on anarbitrary point on \(\Omega\) , we cannot compute the integral needed.</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to betaken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\) , where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\) . This is the easy part: FEValues::quadrature_point() gives us the real-space locations of allquadrature points.</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\) .</li>
<li>Find the reference coordinates within \(T\) of \(y_i\) . For this, weneed the inverse of the mapping \(G_T\) thattransforms the reference element \(\hat T\) into the element \(T\) : \(\hat y_i = G^{-1}_{T} (y_i)\) .</li>
<li><p class="startli">Evaluate the basis function \(v_j\) of the \(\Omega\) mesh at this point \(\hat y_i\) . This is, again, relatively simple using <a class="el" href="classFEValues.html">FEValues</a>.</p>
<p class="startli"><img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png" alt="" class="inline"/> </p>
<p class="startli"><br  />
 In <a class="el" href="step_60.html">step-60</a> , the second through fourth steps above were computed by calling, in turn,</p>
</li>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step. Although this approach could work for the present case, it does not lends itselfreadily to parallel simulations using distributed triangulations. Indeed,since the position of the quadrature points on the cells of theembedded domain \(\Gamma\) do not match that of the embedding triangulationand since \(\Gamma\) is constantly moving, this would require that the triangulation representing \(\Gamma\) be stored in it's entirety for all of the processors. As the numberof processor and the number of cells in \(\Gamma\) increases, this leadsto a severe bottleneck in terms of memory. Consequently, an alternative strategy is soughtin this step.</li>
</ul>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>Remember that for both the penalization approach ( \(\mathcal{L}^2\) or \(\mathcal{H}^1\) )and the Nitsche method, we want to compute integrals that are approximated bythe quadrature. That is, we need to compute </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>@_fakenlIf you followed the discussion above, then you will recall that \(\textbf{u}\) and \(\textbf{v}\) are shape functions defined on the fluid mesh.The only things defined on the solid mesh are: \(F_K(\hat x_i)\) , which is the location of a quadrature point on a solid cell thatis part of \(\Gamma\) , \(J_K\) is the determinant of its Jacobian, and \(w_i\) the correspondingquadrature weight. The important part to realize is now this: \(w_i\) is a property ofthe quadrature formula and does not change with time. Furthermore,the Jacobian matrix of \(F_K\) itself changes as the solid obstaclemoves around in the fluid, but because the solid is considerednon-deforming (it only translates and rotates, but doesn't dilate),the determinant of the Jacobian remains constant. As a consequence,the product \(J_K(\hat x_i) w_i\) (which we typically denote by <code>JxW</code>)remains constant for each quadrature point. So the only thing we needkeep track of are the positions \(x_i=F_K(\hat x_i)\) <br  />
</p>
<ul>
<li>but thesemove with the velocity of the solid domain. In other words, we don't actually need to keep the solid mesh at all.All we need is the positions \(x_i(t)\) and corresponding <code>JxW</code> values.Since both of these properties are point-properties (or point-vectors) that areattached to the solid material, they can be idealized as a set of disconnectedinfinitesimally small "particles", which carry the required <code>JxW</code> information with themovement of the solid. deal.II has the ability to distribute andstore such a set of particles in large-scale parallel computations in the form ofthe ParticleHandler class (for details on the implementation see <b>[GLHPW2018]</b> ),and we will make use of this functionality in this tutorial. Thus, the approach taken in this step is as follows:</li>
<li>Create a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> for the domain \(\Gamma\) ;</li>
<li>Create <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> at the positions of the quadrature points on \(\Gamma\) ;</li>
<li>Call the <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> function, to distribute the particles across processors,following the solid triangulation*;</li>
<li>Attach the <code>JxW</code> values as a "property" to each <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> object. This structure is relatively expensive to generate, but must only be generatedonce per simulation. Once the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> is generated and therequired information is attached to the particle, the integrals over \(\Gamma\) can be carried out by exploiting the fact that particles are grouped cellwiseinside ParticleHandler, allowing us to:</li>
<li>Looping over all cells of \(\Omega\) that contain at least one particle</li>
<li>Looping over all particles in the given cell</li>
<li>Compute the integrals and fill the global matrix. Since the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can manage the exchange of particles fromone processor to the other, the embeddedtriangulation can be moved or deformed by displacing the particles.The only constraint associated with this displacement is that particles shouldbe displaced by a distance that is no larger than the size of onecell. That's because that is the limit to which <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can track which cell a particle that leavesits current cell now resides in. Once the entire problem (the Stokes problem and the immersed boundaryimposition) is assembled,the final saddle point problem is solved by an iterative solver, applied to theSchur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_22.html">step-22</a> ),and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</li>
</ul>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is a demonstration of the time-reversibility of Stokesflow. This is often illustrated in science education experiments with aTaylor-Couette flow and dye droplets that revert back to their original shapeafter the fluid has been displaced in a periodic manner.  
  
<iframe width="560" height="315" src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  
</p>
<p>In the present problem, a very viscous fluid is agitated by the rotation ofan impeller, which, in 2D, is modeled by a rectangular grid. The impellerrotates for a given number of revolutions, after which the flow is reversed suchthat the same number of revolutions is carried out in the opposite direction. Werecall that since the Stokes equations are self-adjoint, creeping flows arereversible. Consequently, if the impeller motion is reversed in the oppositedirection, the fluid should return to its original position. In the presentcase, this is illustrated by inserting a circle of passive tracer particles thatare advected by the fluid and which return to their original position, thusdemonstrating the time-reversibility of the flow.</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>This tutorial program uses a number of techniques on imposing velocityconditions on non-matching interfaces in the interior of the fluid.For more background material, you may want to look up the following references: <b>[Freund1995]</b> , <b>[Angot1999]</b> , <b>[Glowinski1999]</b> , <b>[Boffi2008]</b> , <b>[Heltai2012]</b> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in step-40 and step-50 .</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceLA.html">LA</a></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div>
<div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div>
<div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">} <span class="comment">// namespace LA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
</div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a> . In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div>
</div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep70.html">Step70</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a> , we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files. <br  />
 The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference. <br  />
 The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblemParameters();</div>
</div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="function__time__0_8txt.html#a1ee09a9dd26d8e6c3685fe170eb40343">set_time</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">  angular_velocity.set_time(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div>
<div class="line"><span class="keywordtype">double</span>       <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>           = 1.0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div>
</div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div>
</div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div>
</div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div>
</div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div>
</div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple. <br  />
 The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.). <br  />
 In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles. <br  />
 When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>. <br  />
 In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take). <br  />
 In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself. <br  />
 To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">     std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div>
<div class="line">     std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div>
<div class="line">     std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div>
<div class="line">     std::string arguments_for_solid_grid = <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ?</div>
<div class="line">                                              <span class="stringliteral">&quot;-.5,</span></div>
<div class="line"><span class="stringliteral">  </span></div>
<div class="line"><span class="stringliteral">-.1: .5, .1: false&quot;</span> :</div>
<div class="line">                                              <span class="stringliteral">&quot;-.5,</span></div>
<div class="line"><span class="stringliteral">  </span></div>
<div class="line"><span class="stringliteral">-.1,</span></div>
<div class="line"><span class="stringliteral">  </span></div>
<div class="line"><span class="stringliteral">-.1: .5, .1, .1: false&quot;</span>;</div>
<div class="line">     std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div>
<div class="line">     std::string arguments_for_particle_grid =</div>
<div class="line">       <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div>
</div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field. <br  />
 We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>. <br  />
 Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div>
<div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div>
<div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div>
<div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div>
<div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div>
</div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>;</div>
<div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div>
<div class="line">    angular_velocity;</div>
<div class="line">};</div>
</div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">StokesImmersedProblemParameters&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,</div>
<div class="line">                                <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;::StokesImmersedProblemParameters()</div>
<div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div>
<div class="line">  , <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<span class="stringliteral">&quot;Right hand side&quot;</span>, <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1)</div>
<div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, <a class="code" href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">final_time</a>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div>
<div class="line">                initial_fluid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div>
<div class="line">                initial_solid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div>
<div class="line">                fluid_rtree_extraction_level,</div>
<div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div>
<div class="line">    particle_insertion_refinement,</div>
<div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div>
<div class="line">    homogeneous_dirichlet_ids,</div>
<div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div>
</div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div>
<div class="line">                arguments_for_particle_grid);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div>
<div class="line">                refinement_strategy,</div>
<div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                this-&gt;prm,</div>
<div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
</div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">     <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">       <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div>
<div class="line">                                                               <a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> + 1);</div>
<div class="line">     });</div>
<div class="line">     angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">       this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 :</span></div>
<div class="line"><span class="stringliteral">  </span></div>
<div class="line"><span class="stringliteral">-6.283185&quot;</span>);</div>
<div class="line">     });</div>
<div class="line">   }</div>
</div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div>
<div class="line">    : angular_velocity(angular_velocity)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>;</div>
</div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line">       <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[0]        =</div>
<div class="line">  </div>
<div class="line">-omega <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">       <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[1]        = omega <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0];</div>
<div class="line">  </div>
<div class="line">       <span class="keywordflow">return</span> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">     }</div>
<div class="line">  </div>
<div class="line">   <span class="keyword">private</span>:</div>
<div class="line">     <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">   };</div>
</div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">   <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">   {</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">     static_assert(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a> &gt; 1,</div>
<div class="line">                   <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div>
<div class="line">  </div>
<div class="line">     SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div>
<div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>&gt;(<a class="code" href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a>)</div>
<div class="line">       , angular_velocity(angular_velocity)</div>
<div class="line">       , time_step(time_step)</div>
<div class="line">     {}</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">     </span>{</div>
<div class="line">       <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>;</div>
<div class="line">  </div>
<div class="line">       <span class="keywordtype">double</span> dtheta = angular_velocity.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) time_step;</div>
<div class="line">  </div>
<div class="line">       new_position[0] = <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0]</div>
<div class="line">  </div>
<div class="line">- <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">       new_position[1] = <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(dtheta) <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[0] + <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>[1];</div>
<div class="line">  </div>
<div class="line">       <span class="keywordflow">return</span> new_position[<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>];</div>
<div class="line">     }</div>
<div class="line">  </div>
<div class="line">     <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div>
<div class="line">     {</div>
<div class="line">       time_step = new_time_step;</div>
<div class="line">     }</div>
<div class="line">  </div>
<div class="line">   <span class="keyword">private</span>:</div>
<div class="line">     <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">     <span class="keywordtype">double</span>                                     time_step;</div>
<div class="line">   };</div>
</div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblem(</div>
<div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
</div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div>
<div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div>
</div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div>
<div class="line"><span class="keywordtype">void</span> setup_dofs();</div>
</div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div>
<div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div>
</div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a> ) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;<a class="code" href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a>,</div>
<div class="line">                      std::string                                 fprefix,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div>
</div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a> , for example:</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div>
</div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a> . Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping. <br  />
 We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes). <br  />
 This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns. <br  />
 In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div>
<div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div>
</div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom. <br  />
 We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div>
<div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div>
</div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a> , we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div>
</div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> system_matrix;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> locally_relevant_solution;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LA::MPI::BlockVector</a> system_rhs;</div>
</div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div>
<div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div>
</div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\) . This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>. <br  />
 Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain. <br  />
 While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm. <br  />
 The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div>
<div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> tracer_particle_velocities;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div>
</div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping. <br  />
 In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area</p>
<ul>
<li>in the form of more refined bounding box information</li>
<li>the less communication we have to perform.) <br  />
 We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be. <br  />
 As an example, this is what would be extracted by the <a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree: <br  />
 <div class="image">
<img src="rtree-process-0.png" alt=""/>
<div class="caption">
<div class="image">
<img src="rtree-process-1.png" alt=""/>
<div class="caption">
<div class="image">
<img src="rtree-process-2.png" alt=""/>
</div>
 br We store these boxes in a global member variable, which is updated at every refinement step: @code std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes; };  @endcode  aa h3The StokesImmersedProblem class implementationh3 @verbatim aa h4Object construction and mesh initialization functionsh4 @endverbatim  In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed. @code template &lt;int dim, int spacedim&gt; StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem( const StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par) : par(par) , mpi_communicator(MPI_COMM_WORLD) , pcout(std::cout, (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) , computing_timer(mpi_communicator, pcout, <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>, <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>) , fluid_tria(mpi_communicator, typename <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation&lt;spacedim&gt;::MeshSmoothing</a>( <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">Triangulation&lt;spacedim&gt;::smoothing_on_refinement</a> | <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">Triangulation&lt;spacedim&gt;::smoothing_on_coarsening</a>)) , solid_tria(mpi_communicator, typename <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation&lt;dim, spacedim&gt;::MeshSmoothing</a>( <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaebeb641af1053ef7ce13f640c13fd81b">Triangulation&lt;dim, spacedim&gt;::smoothing_on_refinement</a> | <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9d142d690386f72c659a34b440cc54c6">Triangulation&lt;dim, spacedim&gt;::smoothing_on_coarsening</a>)) , fluid_dh(fluid_tria) , solid_dh(solid_tria) {}  @endcode  In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation: @code template &lt;int dim, int spacedim&gt; void read_grid_and_cad_files(const std::string &amp;grid_file_name, const std::string &amp;ids_and_cad_file_names, Triangulation&lt;dim, spacedim&gt; &amp;tria) { GridIn&lt;dim, spacedim&gt; grid_in; grid_in.attach_triangulation(tria); grid_in.read(grid_file_name);  @endcode  If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>. br We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us: @code #ifdef DEAL_II_WITH_OPENCASCADE using map_type = std::map&lt;types::manifold_id, std::string&gt;; using Converter = Patterns::Tools::Convert&lt;map_type&gt;;  for (const auto &amp;pair : Converter::to_value(ids_and_cad_file_names)) { const auto &amp;manifold_id = pair.first; const auto &amp;cad_file_name = pair.second;  const auto extension = boost::algorithm::to_lower_copy( cad_file_name.substr(cad_file_name.find_last_of('.') + 1));  TopoDS_Shape shape; if (extension == "iges" || extension == "igs") shape = OpenCASCADE::read_IGES(cad_file_name); else if (extension == "step" || extension == "stp") shape = OpenCASCADE::read_STEP(cad_file_name); else AssertThrow(false, ExcNotImplemented("We found an extension that we " "do not recognize as a CAD file " "extension. Bailing out."));  @endcode  Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2. @code const auto n_elements = OpenCASCADE::count_elements(shape); if ((std::get&lt;0&gt;(n_elements) == 0)) tria.set_manifold( manifold_id, OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;(shape)); else if (spacedim == 3) { @endcode  We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly. @code const auto t = reinterpret_cast&lt;Triangulation&lt;dim, 3&gt;&gt;(&amp;tria); t-&gt;set_manifold(manifold_id, OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;( shape)); } else @endcode  We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>. @code tria.set_manifold(manifold_id, OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;( TopoDS::Face(shape))); } <a class="el" href="distributed__0_8txt.html#afbef545315e0adf43b132473bc29bf6f">else</a> (void)ids_and_cad_file_names; AssertThrow(false, ExcNotImplemented("Generation of the grid failed.")); #endif }  @endcode  Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function. br We repeat this pattern for both the fluid and the solid mesh. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid() { try { <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>( fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid); } catch (...) { pcout &lt;&lt; "Generating from name and argument failed." &lt;&lt; std::endl &lt;&lt; "Trying to read from file name." &lt;&lt; std::endl; read_grid_and_cad_files(par.name_of_fluid_grid, par.arguments_for_fluid_grid, fluid_tria); } fluid_tria.refine_global(par.initial_fluid_refinement);  try { <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>( solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid); } catch (...) { read_grid_and_cad_files(par.name_of_solid_grid, par.arguments_for_solid_grid, solid_tria); }  solid_tria.refine_global(par.initial_solid_refinement); }  @endcode  aa h4Particle initialization functionsh4  Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choicechoice a choice determined by one of the run-time parameters in the parameter file. br In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points. br The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves. br In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program. br With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations: @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles() { parallel::distributed::Triangulation&lt;spacedim&gt; particle_insert_tria( mpi_communicator); <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>( particle_insert_tria, par.name_of_particle_grid, par.arguments_for_particle_grid); particle_insert_tria.refine_global(par.particle_insertion_refinement);  FE_Q&lt;spacedim&gt; particles_fe(1); DoFHandler&lt;spacedim&gt; particles_dof_handler(particle_insert_tria); particles_dof_handler.distribute_dofs(particles_fe);  @endcode  This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors. br We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree: @code std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes; all_boxes.reserve(fluid_tria.n_locally_owned_active_cells()); for (const auto &amp;cell : fluid_tria.active_cell_iterators()) if (cell-&gt;<a class="el" href="quadrature__point__data__0_8txt.html#a175634c053aca0ba3b25782a53938ea5">is_locally_owned()</a>) all_boxes.emplace_back(cell-&gt;bounding_box());  const auto tree = pack_rtree(all_boxes); const auto local_boxes = extract_rtree_level(tree, par.fluid_rtree_extraction_level);  @endcode  Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes. br Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point. @code global_fluid_bounding_boxes = Utilities::MPI::all_gather(mpi_communicator, local_boxes);  tracer_particle_handler.initialize(fluid_tria, <a class="el" href="structStaticMappingQ1.html#a62b367e32a8ae7a2883955bd9dc08655">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);  <a class="el" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler, global_fluid_bounding_boxes, tracer_particle_handler);  pcout &lt;&lt; "Tracer particles: " &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;  @endcode  Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does). @code locally_owned_tracer_particle_coordinates = tracer_particle_handler.locally_owned_particle_ids().tensor_product( complete_index_set(spacedim));  @endcode  At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not. br Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain. @code locally_relevant_tracer_particle_coordinates = locally_owned_tracer_particle_coordinates;  @endcode  Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive. br The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost. @code fluid_tria.signals.pre_distributed_refinement.connect( [&amp;]() { tracer_particle_handler.register_store_callback_function(); });  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() { tracer_particle_handler.register_load_callback_function(false); }); }  @endcode  Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid. br This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid. br In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles() { QGauss&lt;dim&gt; quadrature(fluid_fe-&gt;degree + 1);  const unsigned int n_properties = 1; solid_particle_handler.initialize(fluid_tria, <a class="el" href="structStaticMappingQ1.html#a62b367e32a8ae7a2883955bd9dc08655">StaticMappingQ1&lt;spacedim&gt;::mapping</a>, n_properties);  @endcode  The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors: @code std::vector&lt;<a class="el" href="classPoint.html">Point&lt;spacedim&gt;</a>&gt; quadrature_points_vec; quadrature_points_vec.reserve(quadrature.size() solid_tria.n_locally_owned_active_cells());  std::vector&lt;std::vector&lt;double&gt;&gt; properties; properties.reserve(quadrature.size() solid_tria.n_locally_owned_active_cells());  FEValues&lt;dim, spacedim&gt; fe_v(*solid_fe, quadrature, update_JxW_values | update_quadrature_points); for (const auto &amp;cell : solid_dh.active_cell_iterators()) if (cell-&gt;<a class="el" href="quadrature__point__data__0_8txt.html#a175634c053aca0ba3b25782a53938ea5">is_locally_owned()</a>) { fe_v.reinit(cell); const auto &amp;points = <a class="el" href="namespaceinternal_1_1QGaussChebyshev.html#acc7f5fb23e9d1e7fa916d87f24479f35">fe_v.get_quadrature_points()</a>; const auto &amp;JxW = fe_v.get_JxW_values();  for (unsigned int q = 0; q &lt; points.size(); ++q) { quadrature_points_vec.emplace_back(points[q]); properties.emplace_back( std::vector&lt;double&gt;(n_properties, JxW[q])); } }  @endcode  We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected br Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function: @code Assert(!global_fluid_bounding_boxes.<a class="el" href="distributed__0_8txt.html#ae662b500470aa22b097e11a9da781fd8">empty()</a>, ExcInternalError( "I was expecting the " "global_fluid_bounding_boxes to be filled at this stage. " "Make sure you fill this vector before trying to use it " "here. Bailing out."));  solid_particle_handler.insert_global_particles(quadrature_points_vec, global_fluid_bounding_boxes, properties);  @endcode  As in the previous function, we end by making sure that upon refinement, particles are correctly transferred: @code fluid_tria.signals.pre_distributed_refinement.connect( [&amp;]() { solid_particle_handler.register_store_callback_function(); });  fluid_tria.signals.post_distributed_refinement.connect( [&amp;]() { solid_particle_handler.register_load_callback_function(false); });  pcout &lt;&lt; "Solid particles: " &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; std::endl; }  @endcode  aa h4DoF initialization functionsh4  We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\) ). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class. br Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup() { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Initial setup");  fluid_fe = std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(FE_Q&lt;spacedim&gt;(par.velocity_degree), spacedim, FE_Q&lt;spacedim&gt;(par.velocity_degreepar.velocity_degree 1), 1);  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;(); solid_dh.distribute_dofs(*solid_fe);  fluid_quadrature_formula = std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1); solid_quadrature_formula = std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1); }  @endcode  We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from @ref step_55 "step-55" and we refer to this step for a thorough explanation. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs() { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Setup dofs");  fluid_dh.distribute_dofs(*fluid_fe);  std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0); stokes_sub_blocks[spacedim] = 1; DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks);  auto dofs_per_block = DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks);  const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];  pcout &lt;&lt; "   Number of degrees of freedom: " &lt;&lt; fluid_dh.n_dofs() &lt;&lt; " (" &lt;&lt; n_u &lt;&lt; '+' &lt;&lt; n_p &lt;&lt; " -- " &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; '+' &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; ')' &lt;&lt; std::endl;  fluid_owned_dofs.resize(2); fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u); fluid_owned_dofs[1] = fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);  <a class="el" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs; DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs); fluid_relevant_dofs.resize(2); fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u); fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);  { constraints.reinit(locally_relevant_dofs);  <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0); DoFTools::make_hanging_node_constraints(fluid_dh, constraints); <a class="el" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>( fluid_dh, 0, Functions::ZeroFunction&lt;spacedim&gt;(spacedim + 1), constraints, fluid_fe-&gt;component_mask(velocities)); constraints.close(); }  auto locally_owned_dofs_per_processor = <a class="el" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a>(mpi_communicator, fluid_dh.locally_owned_dofs()); { system_matrix.clear();  Table&lt;2, DoFTools::Coupling&gt; coupling(spacedim + 1, spacedim + 1); for (unsigned int c = 0; c &lt; spacedim + 1; ++c) for (unsigned int d = 0; d &lt; spacedim + 1; ++d) if (c == spacedim &amp;&amp; d == spacedim) coupling[c][d] = <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>; else if (c == spacedim || d == spacedim || c == d) coupling[c][d] = <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>; else coupling[c][d] = <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;  <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);  <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>( fluid_dh, coupling, dsp, constraints, false);  <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>( dsp, locally_owned_dofs_per_processor, mpi_communicator, locally_relevant_dofs);  system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator); }  { preconditioner_matrix.clear();  Table&lt;2, DoFTools::Coupling&gt; coupling(spacedim + 1, spacedim + 1); for (unsigned int c = 0; c &lt; spacedim + 1; ++c) for (unsigned int d = 0; d &lt; spacedim + 1; ++d) if (c == spacedim &amp;&amp; d == spacedim) coupling[c][d] = <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a>; else coupling[c][d] = <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a>;  <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);  <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>( fluid_dh, coupling, dsp, constraints, false); <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>( dsp, locally_owned_dofs_per_processor, mpi_communicator, locally_relevant_dofs); preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator); }  locally_relevant_solution.reinit(fluid_owned_dofs, fluid_relevant_dofs, mpi_communicator); system_rhs.reinit(fluid_owned_dofs, mpi_communicator); solution.reinit(fluid_owned_dofs, mpi_communicator); }  @endcode  aa h4Assembly functionsh4  We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from @ref step_55 "step-55" , which is essentially what @ref step_27 "step-27" also has, and is pretty standard if you know what the Stokes equations look like. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system() { system_matrix = 0; preconditioner_matrix = 0; system_rhs = 0;  <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Assemble Stokes terms");  FEValues&lt;spacedim&gt; fe_values(*fluid_fe, fluid_quadrature_formula, update_values | update_gradients | update_quadrature_points | update_JxW_values);  const unsigned int dofs_per_cell = fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>; const unsigned int n_q_points = fluid_quadrature_formula-&gt;<a class="el" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size()</a>;  <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix(dofs_per_cell, dofs_per_cell); <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell); <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> cell_rhs(dofs_per_cell);  std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>&gt; rhs_values(n_q_points, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>(spacedim + 1));  std::vector&lt;<a class="el" href="classTensor.html">Tensor&lt;2, spacedim&gt;</a>&gt; grad_phi_u(dofs_per_cell); std::vector&lt;double&gt; div_phi_u(dofs_per_cell); std::vector&lt;double&gt; phi_p(dofs_per_cell);  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0); const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);  for (const auto &amp;cell : fluid_dh.active_cell_iterators()) if (cell-&gt;<a class="el" href="quadrature__point__data__0_8txt.html#a175634c053aca0ba3b25782a53938ea5">is_locally_owned()</a>) { cell_matrix = 0; cell_matrix2 = 0; cell_rhs = 0;  fe_values.reinit(cell); par.rhs.vector_value_list(<a class="el" href="namespaceinternal_1_1QGaussChebyshev.html#acc7f5fb23e9d1e7fa916d87f24479f35">fe_values.get_quadrature_points()</a>, rhs_values); for (unsigned int q = 0; q &lt; n_q_points; ++q) { for (unsigned int k = 0; k &lt; dofs_per_cell; ++k) { grad_phi_u[k] = fe_values[velocities].gradient(k, q); div_phi_u[k] = fe_values[velocities].divergence(k, q); phi_p[k] = fe_values[pressure].value(k, q); }  for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) { for (unsigned int j = 0; j &lt; dofs_per_cell; ++j) { cell_matrix(i, j) += (par.viscosity scalar_product(grad_phi_u[i], grad_phi_u[j])scalar_product(grad_phi_u[i], grad_phi_u[j]) div_phi_u[i] phi_p[j]]phi_p[i] div_phi_u[j]) fe_values.JxW(q);  cell_matrix2(i, j) += 1.0 / par.viscosity phi_p[i] phi_p[j] fe_values.JxW(q); }  const unsigned int component_i = fluid_fe-&gt;system_to_component_index(i).first; cell_rhs(i) += fe_values.shape_value(i, q) rhs_values[q](component_i) fe_values.JxW(q); } }  cell-&gt;get_dof_indices(local_dof_indices); constraints.distribute_local_to_global(cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);  constraints.distribute_local_to_global(cell_matrix2, local_dof_indices, preconditioner_matrix); }  system_matrix.compress(VectorOperation::add); preconditioner_matrix.compress(VectorOperation::add); system_rhs.compress(VectorOperation::add); }  @endcode  The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction() { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Assemble Nitsche terms");  const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0); const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices( fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>);  <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>, fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>); <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>);  const auto penalty_parameter = 1.0 / GridTools::minimal_cell_diameter(fluid_tria);  @endcode  We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body). @code auto particle = solid_particle_handler.begin(); while (particle != solid_particle_handler.end()) { local_matrix = 0; local_rhs = 0;  @endcode  We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally. @code const auto &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria); const auto &amp;dh_cell = typename DoFHandler&lt;spacedim&gt;::cell_iterator(*cell, &amp;fluid_dh); dh_cell-&gt;get_dof_indices(fluid_dof_indices);  @endcode  So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles. br Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location. @code const auto pic = solid_particle_handler.particles_in_cell(cell); Assert(pic.begin() == particle, <a class="el" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError()</a>); for (const auto &amp;p : pic) { const auto &amp;ref_q = p.get_reference_location(); const auto &amp;real_q = p.get_location(); const auto &amp;JxW = p.get_properties()[0];  for (unsigned int i = 0; i &lt; fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>; ++i) { const auto comp_i = fluid_fe-&gt;system_to_component_index(i).first; if (comp_i &lt; spacedim) { for (unsigned int j = 0; j &lt; fluid_fe-&gt;<a class="el" href="fe__q__base__0_8txt.html#af36d3d5134aa2e6fa02ba348a4c3295f">n_dofs_per_cell()</a>; ++j) { const auto comp_j = fluid_fe-&gt;system_to_component_index(j).first; if (comp_i == comp_j) local_matrix(i, j) += penalty_parameter par.penalty_term fluid_fe-&gt;shape_value(i, ref_q) fluid_fe-&gt;shape_value(j, ref_q) JxW; } local_rhs(i) += penalty_parameter par.penalty_term solid_velocity.value(real_q, comp_i) fluid_fe-&gt;shape_value(i, ref_q) JxW; } } }  constraints.distribute_local_to_global(local_matrix, local_rhs, fluid_dof_indices, system_matrix, system_rhs); particle = pic.end(); }  system_matrix.compress(VectorOperation::add); system_rhs.compress(VectorOperation::add); }  @endcode  aa h4Solving the linear systemh4  This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above). @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::solve() { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Solve");  LA::MPI::PreconditionAMG prec_A; { LA::MPI::PreconditionAMG::AdditionalData data;  #ifdef USE_PETSC_LA data.symmetric_operator = true; #endif prec_A.initialize(system_matrix.block(0, 0), data); }  LA::MPI::PreconditionAMG prec_S; { LA::MPI::PreconditionAMG::AdditionalData data;  #ifdef USE_PETSC_LA data.symmetric_operator = true; #endif prec_S.initialize(preconditioner_matrix.block(1, 1), data); }  const auto A = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0)); const auto amgA = linear_operator(A, prec_A);  const auto S = linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1)); const auto amgS = linear_operator(S, prec_S);  <a class="el" href="classReductionControl.html">ReductionControl</a> inner_solver_control(100, 1e-8 <a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a069487de103023e142d174c1bb6712fa">system_rhs.l2_norm()</a>, 1.e-2); SolverCG&lt;LA::MPI::Vector&gt; cg(inner_solver_control);  const auto invS = inverse_operator(S, cg, amgS);  const auto P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;( std::array&lt; ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;, 2&gt;{{amgA, amgS}});  <a class="el" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(), 1e-10 <a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a069487de103023e142d174c1bb6712fa">system_rhs.l2_norm()</a>);  SolverFGMRES&lt;LA::MPI::BlockVector&gt; solver(solver_control);  constraints.set_zero(solution);  solver.solve(system_matrix, solution, system_rhs, P);  pcout &lt;&lt; "   Solved in " &lt;&lt; solver_control.last_step() &lt;&lt; " iterations." &lt;&lt; std::endl;  constraints.distribute(solution);  locally_relevant_solution = solution; const double mean_pressure = <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(fluid_dh, QGauss&lt;spacedim&gt;(par.velocity_degree + 2), locally_relevant_solution, spacedim); solution.block(1).add(-mean_pressure); locally_relevant_solution.block(1) = solution.block(1); }  @endcode  aa h4Mesh refinementh4  We deal with mesh refinement in a completely standard way: @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer() { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Refine"); const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;float&gt;</a> error_per_cell(<a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">fluid_tria.n_active_cells()</a>); <a class="el" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh, <a class="el" href="classQGauss.html">QGauss</a>&lt;spacedimspacedim1&gt;( par.velocity_degree + 1), {}, locally_relevant_solution, error_per_cell, fluid_fe-&gt;component_mask(velocity));  if (par.refinement_strategy == "fixed_fraction") { <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">parallel::distributed::GridRefinement</a>:: refine_and_coarsen_fixed_fraction(fluid_tria, error_per_cell, par.refinement_fraction, par.coarsening_fraction); } else if (par.refinement_strategy == "fixed_number") { <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>( fluid_tria, error_per_cell, par.refinement_fraction, par.coarsening_fraction, par.max_cells); }  for (const auto &amp;cell : fluid_tria.active_cell_iterators()) { if (cell-&gt;refine_flag_set() &amp;&amp; cell-&gt;<a class="el" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level()</a> == par.max_level_refinement) cell-&gt;clear_refine_flag(); if (cell-&gt;coarsen_flag_set() &amp;&amp; cell-&gt;<a class="el" href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level()</a> == par.min_level_refinement) cell-&gt;clear_coarsen_flag(); }  parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt; transfer(fluid_dh); fluid_tria.prepare_coarsening_and_refinement(); transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution); fluid_tria.execute_coarsening_and_refinement();  setup_dofs();  transfer.interpolate(solution); constraints.distribute(solution); locally_relevant_solution = solution; }  @endcode  aa h4Creating output for visualizationh4  We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(const unsigned int cycle, double time) const { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Output fluid");  std::vector&lt;std::string&gt; solution_names(spacedim, "velocity"); solution_names.emplace_back("pressure"); std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt; data_component_interpretation( spacedim, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>); data_component_interpretation.push_back( <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a>);  DataOut&lt;spacedim&gt; data_out; data_out.attach_dof_handler(fluid_dh); data_out.add_data_vector(locally_relevant_solution, solution_names, <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27aa76306340b5b73ca2d14e961e99d2972">DataOut&lt;spacedim&gt;::type_dof_data</a>, data_component_interpretation);  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;float&gt;</a> subdomain(<a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">fluid_tria.n_active_cells()</a>); for (unsigned int i = 0; i &lt; subdomain.size(); ++i) subdomain(i) = fluid_tria.locally_owned_subdomain(); data_out.add_data_vector(subdomain, "subdomain");  data_out.build_patches();  const std::string filename = "solution-" + Utilities::int_to_string(cycle) + ".vtu"; data_out.write_vtu_in_parallel(par.output_directory + "/" + filename, mpi_communicator);  static std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names; times_and_names.push_back(std::make_pair(time, filename)); std::ofstream ofile(par.output_directory + "/" + "solution.pvd"); DataOutBase::write_pvd_record(ofile, times_and_names); }  @endcode  Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their idid but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles( const Particles::ParticleHandler&lt;spacedim&gt; &amp;particles, std::string fprefix, const unsigned int iter, const double time) const { Particles::DataOut&lt;spacedim&gt; particles_out; particles_out.build_patches(particles); const std::string filename = (fprefix + "-" + Utilities::int_to_string(iter) + ".vtu"); particles_out.write_vtu_in_parallel(par.output_directory + "/" + filename, mpi_communicator);  static std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt; times_and_names; if (times_and_names.find(fprefix) != times_and_names.end()) times_and_names[fprefix].push_back(std::make_pair(time, filename)); else times_and_names[fprefix] = {std::make_pair(time, filename)}; std::ofstream ofile(par.output_directory + "/" + fprefix + ".pvd"); DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]); }  @endcode  aa h4The "run" functionh4  This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programsprograms take @ref step_21 "step-21" or @ref step_26 "step-26" as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility. @code template &lt;int dim, int spacedim&gt; void StokesImmersedProblem&lt;dim, spacedim&gt;::run() { #ifdef USE_PETSC_LA pcout &lt;&lt; "Running StokesImmersedProblem&lt;" &lt;&lt; Utilities::dim_string(dim, spacedim) &lt;&lt; "&gt; using PETSc." &lt;&lt; std::endl; <a class="el" href="distributed__0_8txt.html#afbef545315e0adf43b132473bc29bf6f">else</a> pcout &lt;&lt; "Running StokesImmersedProblem&lt;" &lt;&lt; Utilities::dim_string(dim, spacedim) &lt;&lt; "&gt; using Trilinos." &lt;&lt; std::endl; #endif par.prm.print_parameters(par.output_directory + "/" + "used_parameters_" + std::to_string(dim) + std::to_string(spacedim) + ".prm", <a class="el" href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a2713a592c467d1b282bdde44c65f6111">ParameterHandler::Short</a>);  @endcode  We then start the time loop. We initialize all the elements of the simulation in the first cycle @code const double time_step = par.final_time / (par.number_of_time_stepspar.number_of_time_steps1); double time = 0; unsigned int output_cycle = 0;  for (unsigned int cycle = 0; cycle &lt; par.number_of_time_steps; ++cycle, time += time_step) { par.set_time(time); pcout &lt;&lt; "Cycle " &lt;&lt; cycle &lt;&lt; ':' &lt;&lt; std::endl &lt;&lt; "Time : " &lt;&lt; time &lt;&lt; ", time step: " &lt;&lt; time_step &lt;&lt; std::endl;  if (cycle == 0) { <a class="el" href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid()</a>; initial_setup(); setup_dofs(); setup_tracer_particles(); setup_solid_particles(); tracer_particle_velocities.reinit( locally_owned_tracer_particle_coordinates, mpi_communicator); output_results(output_cycle, time); { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Output tracer particles"); output_particles(tracer_particle_handler, "tracer", output_cycle, time); } { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Output solid particles"); output_particles(solid_particle_handler, "solid", output_cycle, time); } } @endcode  After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved. @code else { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Set solid particle position");  SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity, time_step); solid_particle_handler.set_particle_positions(solid_position, false); }  @endcode  In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles. @code { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Set tracer particle motion"); <a class="el" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>( fluid_dh, tracer_particle_handler, locally_relevant_solution, tracer_particle_velocities, fluid_fe-&gt;component_mask(FEValuesExtractors::Vector(0)));  tracer_particle_velocities= time_step;  locally_relevant_tracer_particle_coordinates = tracer_particle_handler.locally_owned_particle_ids().tensor_product( complete_index_set(spacedim));  relevant_tracer_particle_displacements.reinit( locally_owned_tracer_particle_coordinates, locally_relevant_tracer_particle_coordinates, mpi_communicator);  relevant_tracer_particle_displacements = tracer_particle_velocities;  tracer_particle_handler.set_particle_positions( relevant_tracer_particle_displacements); }  @endcode  Using these new locations, we can then assemble the Stokes system and solve it. @code assemble_stokes_system(); assemble_nitsche_restriction(); <a class="el" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve()</a>;  @endcode  With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh. @code if (cycle % par.output_frequency == 0) { output_results(output_cycle, time); { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Output tracer particles"); output_particles(tracer_particle_handler, "tracer", output_cycle, time); } { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Output solid particles"); output_particles(solid_particle_handler, "solid", output_cycle, time); } ++output_cycle; } if (cycle % par.refinement_frequency == 0 &amp;&amp; cycle != par.number_of_time_stepspar.number_of_time_steps1) refine_and_transfer(); } }  } // namespace <a class="el" href="namespaceStep70.html">Step70</a>  @endcode  aa h3The <a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> functionh3  The remainder of the code, the <code><a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.  If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default. @code int main(int argc, charargv[]) { using namespace <a class="el" href="namespaceStep70.html">Step70</a>; using namespace dealii; deallog.depth_console(1); try { <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);  std::string prm_file; if (argc &gt; 1) prm_file = argv[1]; else prm_file = "parameters.prm";  if (prm_file.find("23") != std::string::npos) { StokesImmersedProblemParameters&lt;2, 3&gt; par; ParameterAcceptor::initialize(prm_file);  StokesImmersedProblem&lt;2, 3&gt; problem(par); problem.run(); } else if (prm_file.find("3") != std::string::npos) { StokesImmersedProblemParameters&lt;3&gt; par; ParameterAcceptor::initialize(prm_file);  StokesImmersedProblem&lt;3&gt; problem(par); problem.run(); } else { StokesImmersedProblemParameters&lt;2&gt; par; ParameterAcceptor::initialize(prm_file);  StokesImmersedProblem&lt;2&gt; problem(par); problem.run(); } } catch (std::exception &amp;exc) { std::cerr &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl; std::cerr &lt;&lt; "Exception on processing: " &lt;&lt; std::endl &lt;&lt; exc.what() &lt;&lt; std::endl &lt;&lt; "Aborting!" &lt;&lt; std::endl &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl;  return 1; } catch (...) { std::cerr &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl; std::cerr &lt;&lt; "Unknown exception!" &lt;&lt; std::endl &lt;&lt; "Aborting!" &lt;&lt; std::endl &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl; return 1; }  return 0; } @endcode aah1Resultsh1  The directory in which this program is run contains a number of sampleparameter files that you can use to reproduce the results presented in thissection. If you do not specify a parameter file as an argument on the commandline, the program will try to read the file "`parameters.prm`" by default, andwill execute the two dimensional version of the code. As explained inthe discussion of the source code, ifyour file name contains the string "23", then the program will run a threedimensional problem, with immersed solid of co-dimension one. If it containsthe string "3", it will run a three dimensional problem, with immersed solid ofco-dimension zero, otherwise it will run a two dimensional problem withimmersed solid of co-dimension zero. Regardless of the specific parameter file name, if the specified file does notexist, when you execute the program you will get an exception that no such filecan be found: @code ---------------------------------------------------- Exception on processing: -------------------------------------------------------- An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in function static void ::ParameterAcceptor::initialize(const std::string &amp;, const std::string &amp;, const ParameterHandler::OutputStyle, ::ParameterHandler &amp;) The violated condition was: false Additional information: You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it for you. -------------------------------------------------------- Aborting! ---------------------------------------------------- @endcode  However, as the error message already states, the code that triggers theexception will also generate the specified file ("`parameters.prm`" in this case)that simply contains the default values for all parameters this program caresabout (for the correct dimension and co-dimension, according to the whether astring "23" or "3" is contained in the file name). By inspection of the defaultparameter file, we see the following: @code # Listing of Parameters # --------------------- subsection Stokes Immersed Problem set Final time = 1 # Extraction level of the rtree used to construct global bounding boxes set Fluid bounding boxes extraction level = 1  # Boundary Ids over which homogeneous Dirichlet boundary conditions are # applied set Homogeneous Dirichlet boundary ids = 0  # Initial mesh refinement used for the fluid domain Omega set Initial fluid refinement = 5  # Initial mesh refinement used for the solid domain Gamma set Initial solid refinement = 5 set Nitsche penalty term = 100 set Number of time steps = 501 set Output directory = . set Output frequency = 1  # Refinement of the volumetric mesh used to insert the particles set Particle insertion refinement = 3 set Velocity degree = 2 set Viscosity = 1  subsection Angular velocity # Sometimes it is convenient to use symbolic constants in the expression # that describes the function, rather than having to use its numeric value # everywhere the constant appears. These values can be defined using this # parameter, in the form `var1=value1, var2=value2, ...'. # # A typical example would be to set this runtime parameter to # `pi=3.1415926536' and then use `pi' in the expression of the actual # formula. (That said, for convenience this class actually defines both # `pi' and `Pi' by default, but you get the idea.) set <a class="el" href="classFunction.html">Function</a> constants =  # The formula that denotes the function you want to evaluate for # particular values of the independent variables. This expression may # contain any of the usual operations such as addition or multiplication, # as well as all of the common functions such as `sin' or `cos'. In # addition, it may contain expressions like `if(x&gt;0, 1, -1)' where the # expression evaluates to the second argument if the first argument is # true, and to the third argument otherwise. For a full overview of # possible expressions accepted see the documentation of the muparser # library at <a href="http://muparser.beltoforion.de/">http://muparser.beltoforion.de/</a>. # # If the function you are describing represents a vector-valued function # with multiple components, then separate the expressions for individual # components by a semicolon. set <a class="el" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185 # default: 0  # The names of the variables as they will be used in the function, # separated by commas. By default, the names of variables at which the # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in # 3d) for spatial coordinates and `t' for time. You can then use these # variable names in your function expression and they will be replaced by # the values of these variables at which the function is currently # evaluated. However, you can also choose a different set of names for the # independent variables at which to evaluate your function expression. For # example, if you work in spherical coordinates, you may wish to set this # input parameter to `r,phi,theta,t' and then use these variable names in # your function expression. set Variable names = x,y,t end  subsection Grid generation set Fluid grid generator = hyper_cube set Fluid grid generator arguments = -1: 1: false set Particle grid generator = hyper_ball set Particle grid generator arguments = 0.3, 0.3: 0.1: false set Solid grid generator = hyper_rectangle set Solid grid generator arguments = -.5, -.1: .5, .1: false end  subsection Refinement and remeshing set Maximum number of cells = 20000 set Refinement coarsening fraction = 0.3 set Refinement fraction = 0.3 set Refinement maximal level = 8 set Refinement minimal level = 5 set Refinement step frequency = 5 set Refinement strategy = fixed_fraction end  subsection Right hand side # Sometimes it is convenient to use symbolic constants in the expression # that describes the function, rather than having to use its numeric value # everywhere the constant appears. These values can be defined using this # parameter, in the form `var1=value1, var2=value2, ...'. # # A typical example would be to set this runtime parameter to # `pi=3.1415926536' and then use `pi' in the expression of the actual # formula. (That said, for convenience this class actually defines both # `pi' and `Pi' by default, but you get the idea.) set <a class="el" href="classFunction.html">Function</a> constants =  # The formula that denotes the function you want to evaluate for # particular values of the independent variables. This expression may # contain any of the usual operations such as addition or multiplication, # as well as all of the common functions such as `sin' or `cos'. In # addition, it may contain expressions like `if(x&gt;0, 1, -1)' where the # expression evaluates to the second argument if the first argument is # true, and to the third argument otherwise. For a full overview of # possible expressions accepted see the documentation of the muparser # library at <a href="http://muparser.beltoforion.de/">http://muparser.beltoforion.de/</a>. # # If the function you are describing represents a vector-valued function # with multiple components, then separate the expressions for individual # components by a semicolon. set <a class="el" href="classFunction.html">Function</a> expression = 0; 0; 0  # The names of the variables as they will be used in the function, # separated by commas. By default, the names of variables at which the # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in # 3d) for spatial coordinates and `t' for time. You can then use these # variable names in your function expression and they will be replaced by # the values of these variables at which the function is currently # evaluated. However, you can also choose a different set of names for the # independent variables at which to evaluate your function expression. For # example, if you work in spherical coordinates, you may wish to set this # input parameter to `r,phi,theta,t' and then use these variable names in # your function expression. set Variable names = x,y,t end end @endcode  If you now run the program, you will get a file called <code>parameters_22.prm</code> inthe directory specified by the parameter <code>Output directory</code> (which defaults tothe current directory) containing a shorter version of the above parameters(without comments and documentation), documenting all parameters that were usedto run your program: @code subsection Stokes Immersed Problem set Final time = 1 set Fluid bounding boxes extraction level = 1 set Homogeneous Dirichlet boundary ids = 0 set Initial fluid refinement = 5 set Initial solid refinement = 5 set Nitsche penalty term = 100 set Number of time steps = 501 set Output directory = . set Output frequency = 1 set Particle insertion refinement = 3 set Velocity degree = 2 set Viscosity = 1 subsection Angular velocity set <a class="el" href="classFunction.html">Function</a> constants = set <a class="el" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185 set Variable names = x,y,t end subsection Grid generation set Fluid grid generator = hyper_cube set Fluid grid generator arguments = -1: 1: false set Particle grid generator = hyper_ball set Particle grid generator arguments = 0.3, 0.3: 0.1: false set Solid grid generator = hyper_rectangle set Solid grid generator arguments = -.5, -.1: .5, .1: false end subsection Refinement and remeshing set Maximum number of cells = 20000 set Refinement coarsening fraction = 0.3 set Refinement fraction = 0.3 set Refinement maximal level = 8 set Refinement minimal level = 5 set Refinement step frequency = 5 set Refinement strategy = fixed_fraction end subsection Right hand side set <a class="el" href="classFunction.html">Function</a> constants = set <a class="el" href="classFunction.html">Function</a> expression = 0; 0; 0 set Variable names = x,y,t end end @endcode  The rationale behind creating first <code>parameters.prm</code> file (the first time theprogram is run) and then a <code>output/parameters_22.prm</code> (every time yourun the program with an existing input file), is because you may wantto leave most parameters to theirdefault values, and only modify a handful of them, while still beeing able toreproduce the results and inspect what parameters were used for a specificsimulation. It is generally good scientific practice to store theparameter file you used for a simulation along with the simulationoutput so that you can repeat the exact same run at a later time if necessary. Another reason is because the input file may only contain thoseparameters that differ from their defaults.For example, you could use the following (perfectly valid) parameter file withthis tutorial program: @code subsection Stokes Immersed Problem set Final time = 1 set Nitsche penalty term = 10 set Number of time steps = 101 set Velocity degree = 3 end @endcode and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101steps, using a Nitsche penalty of <code>10</code>, and leaving all the other parameters totheir default value. The output directory then contains a record ofnot just these parameters, but indeed all parameters used in thesimulation. You can inspect all the other parameters in theproduced file <code>parameters_22.prm</code>.  aah3 Two dimensional test case h3  The default problem generates a co-dimension zero impeller, consisting of arotating rectangular grid, where the rotation is for half a time unit in onedirection, and half a time unit in the opposite direction, with constant angularvelocity equal to \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\) . Consequently, the impeller does half arotation and returns to its original position. The following animationdisplays the velocity magnitude, the motion of the solid impeller and of thetracer particles.  p  <img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" alt="" width="500" class="inline"/>  p br On one core, the output of the program will look like the following: @code bash@f$ mpirun -np 1 ./step-70 test.prm Running StokesImmersedProblem&lt;2&gt; using Trilinos. Cycle 0: Time : 0, time step: 0.002 Number of degrees of freedom: 9539 (8450+1089 -- 0+0) Tracer particles: 337 Solid particles: 9216 Solved in 158 iterations. Number of degrees of freedom: 9845 (8722+1123 -- 9216+337) Cycle 1: Time : 0.002, time step: 0.002 Solved in 142 iterations. Cycle 2: Time : 0.004, time step: 0.002 Solved in 121 iterations. Cycle 3: Time : 0.006, time step: 0.002 Solved in 121 iterations. ... Cycle 499: Time : 0.998, time step: 0.002 Solved in 199 iterations. Cycle 500: Time : 1, time step: 0.002 Solved in 196 iterations. +---------------------------------------------+------------+------------+ | Total wallclock time elapsed since start | 302s | | | | | | | Section | no. calls | wall time | % of total | +---------------------------------+-----------+------------+------------+ | Assemble Nitsche terms | 501 | 43.3s | 14% | | Assemble Stokes terms | 501 | 21.5s | 7.1% | | Initial setup | 1 | 0.000792s | 0% | | Output fluid | 502 | 31.8s | 11% | | Output solid particles | 502 | 32.2s | 11% | | Output tracer particles | 502 | 0.61s | 0.2% | | Refine | 100 | 4.68s | 1.5% | | Set solid particle position | 500 | 3.34s | 1.1% | | Set tracer particle motion | 501 | 0.729s | 0.24% | | Setup dofs | 101 | 2.2s | 0.73% | | Solve | 501 | 164s | 54% | +---------------------------------+-----------+------------+------------+ @endcode  You may notice that assembling the coupling system is more expensive thanassembling the Stokes part. This depends highly on the number of Gauss points(solid particles) that are used to apply the Nitsche restriction.In the present case, a relatively low number of tracer particles are used.Consequently, tracking their motion is relatively cheap. The following movie shows the evolution of the solution over time:  
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/y4Gypj2jpXw"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
  The movie shows the rotating obstacle in gray (actually asuperposition of the solid particles plotted with large enough dotsthat they overlap), astreamlines of the fluid flowa in light colors (including the corner verticesthat form at specific times during the simulation), and the tracer particles inbluish tones. The simulation shows that at the end time,the tracer particles have somewhat returned to theiroriginal position, although they have been distorted by the flow field. Thefollowing image compares the initial and the final position of the particlesafter one time unit of flow. p  <img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" alt="" width="500" class="inline"/>  p br In this case, we see that the tracer particles that were outside of the sweptvolume of the impeller have returned very close to their initial position,whereas those in the swept volume were slightly more deformed. This deformationis non-physical. It is caused by the numerical error induced by the explicitEuler scheme used to advect the particles, by the loss of accuracy due to thefictitious domain and, finally, by the discretization error on the Stokesequations. The first two errors are the leading cause of this deformation andthey could be alleviated by the use of a finer mesh and a lower time step.  aah3 Three dimensional test case h3  To play around a little bit, we complicate the fictitious domain (taken fromhttps://grabcad.com/library/lungstors-blower-1), and run a co-dimension onesimulation in three space dimensions, using the following"`parameters_23.prm`" file : @code subsection Stokes Immersed Problem set Final time = 1 set Homogeneous Dirichlet boundary ids = 0 set Fluid bounding boxes extraction level = 1 set Initial fluid refinement = 3 set Initial solid refinement = 0 set Nitsche penalty term = 10 set Number of time steps = 101 set Output frequency = 1 set Particle insertion refinement = 3 set Velocity degree = 2 set Viscosity = 1 subsection Angular velocity set <a class="el" href="classFunction.html">Function</a> constants = set <a class="el" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 5 : -5 set Variable names = x,y,z,t end subsection Grid generation set Fluid grid generator = hyper_rectangle set Fluid grid generator arguments = -50,-50, -10: 50, 50, 40: false set Solid grid generator = impeller.vtk set Solid grid generator arguments = 1:impeller.step set Particle grid generator = hyper_ball set Particle grid generator arguments = 30, 30, 20: 10: false end subsection Refinement and remeshing set Maximum number of cells = 100000 set Refinement coarsening fraction = 0.3 set Refinement fraction = 0.3 set Refinement maximal level = 6 set Refinement step frequency = 5 set Refinement strategy = fixed_fraction end subsection Right hand side set <a class="el" href="classFunction.html">Function</a> constants = set <a class="el" href="classFunction.html">Function</a> expression = 0; 0; 0; 0 set Variable names = x,y,z,t end end @endcode  In this case, the timing outputs are a bit different: @code +---------------------------------------------+------------+------------+ | Total wallclock time elapsed since start | 5.54e+03s | | | | | | | Section | no. calls | wall time | % of total | +---------------------------------+-----------+------------+------------+ | Assemble Nitsche terms | 101 | 111s | 2% | | Assemble Stokes terms | 101 | 208s | 3.8% | | Initial setup | 1 | 0.00187s | 0% | | Output fluid | 102 | 15.5s | 0.28% | | Output solid particles | 102 | 2.63s | 0% | | Output tracer particles | 102 | 2.49s | 0% | | Refine | 20 | 18.4s | 0.33% | | Set solid particle position | 100 | 6.1s | 0.11% | | Set tracer particle motion | 101 | 10.8s | 0.2% | | Setup dofs | 21 | 13.9s | 0.25% | | Solve | 101 | 5.16e+03s | 93% | +---------------------------------+-----------+------------+------------+ @endcode  Now, the solver is taking most of the solution time in three dimensions,and the particle motion and Nitsche assembly remain relativelyunimportant as far as run time is concerned.  
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Srwq7zyR9mg"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
  aaaah3Possibilities for extensionsh3  The current tutorial program shows a one-way coupling between the fluid and thesolid, where the solid motion is imposed (and not solved for), and read in thesolid domain by exploiting the location and the weights of the solid quadraturepoints. The structure of the code already allows one to implement a two-way coupling,by exploiting the possibility to read values of the fluid velocity on thequadrature points of the solid grid. For this to be more efficient in terms ofMPI communication patterns, one should maintain ownership of the quadraturepoints on the solid processor that owns the cells where they have been created.In the current code, it is sufficient to define the <a class="el" href="classIndexSet.html">IndexSet</a> of the vectorsused to exchange information of the quadrature points by using the solidpartition instead of the initial fluid partition. This allows the combination of the technique used in this tutorial program withthose presented in the tutorial @ref step_60 "step-60" to solve a fluid structure interactionproblem with distributed Lagrange multipliers, on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects. The timings above show that the current preconditioning strategy does not workwell for Nitsche penalization, and we should come up with a betterpreconditioner if we want to aim at larger problems. Moreover, a checkpointrestart strategy should be implemented to allow for longer simulations to beinterrupted and restored, as it is done for example in the @ref step_69 "step-69" tutorial.  aah1 The plain programh1 @include "step-70.cc" br </div></div>
</div></div>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a5aa168344f21991b9dfdd2e4854a305c"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a5aa168344f21991b9dfdd2e4854a305c">exist</a></div><div class="ttdeci">******to automatic and symbolic differentiation *Below we provide a very brief introduction as to what automatic and symbolic differentiation what variations of these computational numerical schemes exist</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00010">automatic_and_symbolic_differentiation_0.txt:10</a></div></div>
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="alac_2solver__gmres_8h_html"><div class="ttname"><a href="lac_2solver__gmres_8h.html">solver_gmres.h</a></div></div>
<div class="ttc" id="anamespaceStep70_html_ad78a11f6e1566a0db5cd71e8f3ac0768"><div class="ttname"><a href="namespaceStep70.html#ad78a11f6e1566a0db5cd71e8f3ac0768">Step70::read_grid_and_cad_files</a></div><div class="ttdeci">void read_grid_and_cad_files(const std::string &amp;grid_file_name, const std::string &amp;ids_and_cad_file_names, Triangulation&lt; dim, spacedim &gt; &amp;tria)</div><div class="ttdef"><b>Definition:</b> <a href="step-70_8cc_source.html#l00431">step-70.cc:431</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData&lt; dim, dim, dim, dim &gt;::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="aclassParameterHandler_html_a8364dda711b93753c6809eefe2a8e827"><div class="ttname"><a href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></div><div class="ttdeci">OutputStyle</div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__handler_8h_source.html#l00845">parameter_handler.h:845</a></div></div>
<div class="ttc" id="asymmetric__tensor__0_8txt_html_a37cd5701f5aaccacc8caf38d4a7a903a"><div class="ttname"><a href="symmetric__tensor__0_8txt.html#a37cd5701f5aaccacc8caf38d4a7a903a">A</a></div><div class="ttdeci">1 A</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor__0_8txt_source.html#l00078">symmetric_tensor_0.txt:78</a></div></div>
<div class="ttc" id="aclassArrayView_html_a1a1c62a26e5f55bfe124894c0a31386f"><div class="ttname"><a href="classArrayView.html#a1a1c62a26e5f55bfe124894c0a31386f">ArrayView::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdef"><b>Definition:</b> <a href="base_2array__view_8h_source.html#l00602">array_view.h:602</a></div></div>
<div class="ttc" id="aclassIndexSet_html"><div class="ttname"><a href="classIndexSet.html">IndexSet</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2index__set_8h_source.html#l00068">index_set.h:68</a></div></div>
<div class="ttc" id="aclassGridIn_html_ad30d9d6f2ff9920c4285e795c4495826"><div class="ttname"><a href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">GridIn::read</a></div><div class="ttdeci">void read(std::istream &amp;in, Format format=Default)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l03574">grid_in.cc:3574</a></div></div>
<div class="ttc" id="aclassFEValues_html_a21f914e63d588e2652a9514620653d77"><div class="ttname"><a href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a></div><div class="ttdeci">void reinit(const TriaIterator&lt; DoFCellAccessor&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</div></div>
<div class="ttc" id="adofs_2dof__handler__0_8txt_html_aae1f8d9ad7eda22eb5458605a6db742d"><div class="ttname"><a href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a></div><div class="ttdeci">this information can therefore be used upon construction of the SparsityPattern object The returned number is not really the maximum number but an estimate based on the finite element and the maximum number of cells meeting at a vertex The number holds for the constrained matrix as well The determination of the number of couplings can be done by simple picture drawing An example can be found in the implementation of this function *This function is most often used to determine the maximal row length for sparsity patterns while the estimates returned by this function are rather accurate in they are often significantly too high leading the SparsityPattern class to allocate much too much memory in some cases Unless someone comes around to improving the present function for d there is not very much one can do about these cases The typical way to work around this problem is to use an intermediate compressed sparsity pattern that only allocates memory on demand Refer to the[2.x.89] and[2.x.90] example programs on how to do this The problem is also discussed in the documentation of the module on *[2.x.91] *Return the number of degrees of freedom located on the boundary another dof on the boundary can couple with The number is the same as for all cells on this level are further then this function returns[2.x.98] so that loops of the kind **have zero iterations</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler__0_8txt_source.html#l00175">dof_handler_0.txt:175</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraPETSc_1_1MPI_html_a326d001228d45e600ba97606c24a01c7"><div class="ttname"><a href="namespaceLinearAlgebraPETSc_1_1MPI.html#a326d001228d45e600ba97606c24a01c7">LinearAlgebraPETSc::MPI::PreconditionAMG</a></div><div class="ttdeci">PETScWrappers::PreconditionBoomerAMG PreconditionAMG</div><div class="ttdef"><b>Definition:</b> <a href="lac_2generic__linear__algebra_8h_source.html#l00151">generic_linear_algebra.h:151</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_aa2b5a089b26d5eb6842e77a0320440b0"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a></div><div class="ttdeci">precision How many digits to use when writing the error</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00041">parsed_convergence_table_0.txt:41</a></div></div>
<div class="ttc" id="anewton__0_8txt_html_af4dc1cb00f59a52e48df46a4c205a8e6"><div class="ttname"><a href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a></div><div class="ttdeci">*Operator class performing Newton s iteration with standard step size control and adaptive matrix generation This class performs a Newton iteration up to convergence determined by control If after an update the norm of the residual has become larger then step size control is activated and the update is subsequently divided by two until the residual actually becomes depending on the tends to be this method applies an adaptive reassembling strategy Only if the reduction factor for the residual is more than receiving the applications computing the residual and solving the linear respectively **Declare the parameters applicable to Newton s method **Read the parameters in the ParameterHandler **Initialize the pointer data_out for debugging **The actual Newton iteration The initial value is in&lt; tt &gt; which also contains the result after convergence Values in&lt; tt &gt; in&lt;/tt &gt; are not used by but will be handed down to the objects **Set the maximal residual reduction allowed without triggering assembling in the next step Return the previous value **Control object for the Newton iteration **The indicating that the matrix must be assembled anew upon start **A flag used to decide how many stepsize iteration should be made Default is the original value of Enter zero here to turn off stepsize control *Controlled by&lt; tt &gt; Stepsize iterations&lt;/tt &gt; in parameter file **Threshold for re assembling matrix If the quotient of two consecutive residuals is smaller than this the system matrix is not assembled in this step *This parameter should be adjusted to the residual gain of the inner solver The default values is resulting in reassembling in every Newton step **Print update and updated solution after each step into file&lt; tt &gt; Newton_NNN&lt;/tt &gt; **Write debug output to[2.x.3] the higher the number</div><div class="ttdef"><b>Definition:</b> <a href="newton__0_8txt_source.html#l00034">newton_0.txt:34</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="aclassArrayView_html_a775e02d2deaf2f769e24dee0c3e7a582"><div class="ttname"><a href="classArrayView.html#a775e02d2deaf2f769e24dee0c3e7a582">ArrayView::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="base_2array__view_8h_source.html#l00611">array_view.h:611</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="atable__0_8txt_html_aa22355d271761047703d8c139352814f"><div class="ttname"><a href="table__0_8txt.html#aa22355d271761047703d8c139352814f">initialize</a></div><div class="ttdeci">and so on *This class specifically replaces attempts at higher dimensional arrays like[2.x.8] or even higher nested constructs These constructs have the disadvantage that they are hard to initialize</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00043">table_0.txt:43</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ad207fe81a5be05e18534713c2677da7b"><div class="ttname"><a href="distributed__0_8txt.html#ad207fe81a5be05e18534713c2677da7b">dofs</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data error input in integration This is because in these one typically needs access not only to[2.x.39] locally owned dofs but also to[2.x.40] locally active dofs and sometimes to[2.x.41] locally relevant dofs</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00059">distributed_0.txt:59</a></div></div>
<div class="ttc" id="agroup__Iterators_html_ga32b2a057d9abd2e1752bf8a3cb88e644"><div class="ttname"><a href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler::cell_iterator</a></div><div class="ttdeci">typename ActiveSelector::cell_iterator cell_iterator</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00372">dof_handler.h:372</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_ae902d012155474413712116e310bba66"><div class="ttname"><a href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a></div><div class="ttdeci">namespace ::x *For time dependent boundary conditions and or right hand side functions may also change with time Since at a given time step one is usually only interested in the spatial dependence of a it would be awkward if one had to pass a value for the time variable to all methods that use function objects For the[2.x.3] function would have to take a time argument which it can use when it wants to query the value of the boundary function at a given time step it would also have to do so if we are considering a stationary problem</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00011">functions_0.txt:11</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__cg_8h_source.html#l00088">solver_cg.h:88</a></div></div>
<div class="ttc" id="alac_2petsc__solver_8h_html"><div class="ttname"><a href="lac_2petsc__solver_8h.html">petsc_solver.h</a></div></div>
<div class="ttc" id="aclassTimerOutput_1_1Scope_html"><div class="ttname"><a href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00600">timer.h:600</a></div></div>
<div class="ttc" id="abase_2parameter__acceptor_8h_html"><div class="ttname"><a href="base_2parameter__acceptor_8h.html">parameter_acceptor.h</a></div></div>
<div class="ttc" id="aclassStep70_1_1StokesImmersedProblem_html"><div class="ttname"><a href="classStep70_1_1StokesImmersedProblem.html">Step70::StokesImmersedProblem</a></div><div class="ttdef"><b>Definition:</b> <a href="step-70_8cc_source.html#l00321">step-70.cc:321</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ParsedFunction_html_a57fd4a680441ae940812431a421c9c40"><div class="ttname"><a href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction::declare_parameters</a></div><div class="ttdeci">static void declare_parameters(ParameterHandler &amp;prm, const unsigned int n_components=1)</div><div class="ttdef"><b>Definition:</b> <a href="parsed__function_8cc_source.html#l00036">parsed_function.cc:36</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a8fba07b9a84b89e6be225f5f95c3e355"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div><div class="ttdeci">the program is just and one can not intelligently work around that *It is sometimes useful to change the behavior of the[2.x.6] macro from aborting a program to throwing exceptions On the other exceptions are not allowed to propagate out of destructors of classes For this there is a variant of the called[2.x.7] that can be used in destructors These use cases are discussed further down below on this page **Dynamic such as whether an output file can be written to *These are things that shouldn t be checked because it is not guaranteed that a program for which the condition is satisfied in a debug mode run</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00022">exceptions_0.txt:22</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__q_8h_source.html#l00587">fe_q.h:587</a></div></div>
<div class="ttc" id="alac_2sparsity__tools_8h_html"><div class="ttname"><a href="lac_2sparsity__tools_8h.html">sparsity_tools.h</a></div></div>
<div class="ttc" id="astructStaticMappingQ1_html"><div class="ttname"><a href="structStaticMappingQ1.html">StaticMappingQ1</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2mapping__q1_8h_source.html#l00093">mapping_q1.h:93</a></div></div>
<div class="ttc" id="anumerics_2rtree_8h_html_a66a9d76ea405b07e60e74aa6159ac7ad"><div class="ttname"><a href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a></div><div class="ttdeci">RTree&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt; pack_rtree(const LeafTypeIterator &amp;begin, const LeafTypeIterator &amp;end)</div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_a141ebbaf93668d52831bbd4ec5a1e949"><div class="ttname"><a href="parameter__handler__0_8txt.html#a141ebbaf93668d52831bbd4ec5a1e949">input</a></div><div class="ttdeci">if you have code where no sensible default value for a parameter is you can then catch and ignore this exception The parameter[2.x.43] defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the for example to override an earlier default value **Attach an action to the parameter with name[2.x.46] in the current section The action needs to be a function like object that takes the value of the parameter as as well as examples The action is executed in three different even those that are not actually specified in the input the action is executed whenever the parameter with which it is associated is read from the input</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00289">parameter_handler_0.txt:289</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a2e990f30e4c3b71e80e78084f073ca9b"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a2e990f30e4c3b71e80e78084f073ca9b">names</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field and will produce an error table with H1 and L2 norm of the error in the velocity to write the table only to the file specified in the parameter file *By calling the method the following options will be defined in the given ParameterHandler and can be modified at run time through a parameter please cite ******Minimal constructor for ParsedConvergenceTable objects The number of components must match the number of components of the finite element space that is used to compute the errors If a component name is than it is interpreted as a vector and the errors of the repeated components are grouped together The size of the vector[2.x.3] must match the number of unique component names</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00035">parsed_convergence_table_0.txt:35</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga59da8cbc1fc7db44bebb4fbc9dc4bbe9"><div class="ttname"><a href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Patterns::Tools::to_value</a></div><div class="ttdeci">void to_value(const std::string &amp;s, T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l02421">patterns.h:2421</a></div></div>
<div class="ttc" id="agrid_2grid__tools_8h_html"><div class="ttname"><a href="grid_2grid__tools_8h.html">grid_tools.h</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2namespace__dealii_8h_source.html#l00026">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_a138febc7b9c140e5ea6f80e2ce7b44ef"><div class="ttname"><a href="data__out__base__0_8txt.html#a138febc7b9c140e5ea6f80e2ce7b44ef">boundary</a></div><div class="ttdeci">for&lt; tt &gt;&lt; tt &gt;&lt; tt &gt; etc The actual location of these points on the patch will be computed by a multilinear transformation from the vertices given for this patch For cells at the boundary</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00011">data_out_base_0.txt:11</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00070">fe_update_flags.h:70</a></div></div>
<div class="ttc" id="afe__vs__mapping__vs__fevalues__0_8txt_html_a4e0105c19ddbc5d3acf9aa95e2c9a082"><div class="ttname"><a href="fe__vs__mapping__vs__fevalues__0_8txt.html#a4e0105c19ddbc5d3acf9aa95e2c9a082">information</a></div><div class="ttdeci">*****Most people create finite but that is also just set during construction time In other people never observe FiniteElement or Mapping objects actually[1.x.1] anything **and that is completely by design *This document is therefore for those who are interested in writing finite element or mapping classes and want to understand how FEValues works and interacts with the FiniteElement and Mapping classes In the we will not make a distinction between and the term FEValues will be used generally for all three of these classes in the text below ***Before going into detail about data and control let us define which class is responsible for providing what kind of information **FEValues is an abstraction that derived from the observation that almost everything one ever does in finite element codes only requires the evaluation of finite element shape functions at quadrature points This could for the approximation of an integral of the form[1.x.4] by quadrature[1.x.5] but it is equally valid when wanting to generate graphical and this too can be written as evaluating everything at quadrature points **these quadrature points are then simply the vertices of the their at quadrature points The same is true with some geometric information</div><div class="ttdef"><b>Definition:</b> <a href="fe__vs__mapping__vs__fevalues__0_8txt_source.html#l00021">fe_vs_mapping_vs_fevalues_0.txt:21</a></div></div>
<div class="ttc" id="aclassGridIn_html_a82ac1c03b0efe87204ad45d2f1d87f7e"><div class="ttname"><a href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">GridIn::attach_triangulation</a></div><div class="ttdeci">void attach_triangulation(Triangulation&lt; dim, spacedim &gt; &amp;tria)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l00119">grid_in.cc:119</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a8d598702a2d755352f20b4b6c3b0a9eb"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a8d598702a2d755352f20b4b6c3b0a9eb">expression</a></div><div class="ttdeci">they may later be interpreted as complex or something else for which the power and natural logarithm functions are well defined Obviously this means that there is also no assumption about which point to evaluate either the expression or its derivatives One could readily take the expression for[2.x.83] and evaluate it at[2.x.84] and then with no recomputation of the derivative expression evaluate it at[2.x.85] In the interpretation of any symbolic variable or expression</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="ageodynamics__0_8txt_html_a47b3a2cd492d04754f4796002e14ed13"><div class="ttname"><a href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a></div><div class="ttdeci">all others have started as modifications of one of the tutorial programs *The tutorial programs we propose to write will provide students and researchers with a reference implementation of current numerical technology such as higher order sophisticated linear and nonlinear stabilization etc Providing these as starting points for further development by others will also serve the goal of training a new generation of geodynamicists in modern numerical algorithms *In deal it is fairly simple to extend a set of equations by another for example an additional advected quantity that enters the existing equations as a right hand side or in one of the coefficients Since applications typically use blocked matrices rather than the one big matrix for everything it is also not complicated to find suitable linear solvers for augmented equations deal II is a good tool for trying out more complex formulations of or more complete models and their effects on the accuracy of solutions *deal II provides many interchangeable components that allow rapid prototyping of finite element kinds and stabilization or linear solvers For typically only a few lines of code have to be changed to replace low order by high order elements Through it becomes relatively simple to try out higher order a different block elimination solver</div><div class="ttdef"><b>Definition:</b> <a href="geodynamics__0_8txt_source.html#l00033">geodynamics_0.txt:33</a></div></div>
<div class="ttc" id="astep-1_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="step-1_8cc_source.html#l00086">step-1.cc:86</a></div></div>
<div class="ttc" id="aparticles_2generators_8h_html"><div class="ttname"><a href="particles_2generators_8h.html">generators.h</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga7b52b286796c23ef9ff178faf7a4b68f"><div class="ttname"><a href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">StandardExceptions::ExcNotImplemented</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcNotImplemented()</div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01033">tria.h:1033</a></div></div>
<div class="ttc" id="asolver__cg__0_8txt_html_ab8dd1e5e6028b76d234561ae8e1d22bc"><div class="ttname"><a href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a></div><div class="ttdeci">*This class implements the preconditioned Conjugate but is used in many other tutorial programs as well Like all other solver it can work on any kind of vector and matrix as long as they satisfy certain and defaults to *[2.x.2] **This version of CG is taken from D Braess s book Finite Elements It requires a symmetric the projected matrix[2.x.4] is tri diagonal Since the projection is the eigenvalues of[2.x.5] approximate those of the original preconditioned matrix[2.x.6] In after[2.x.7] steps</div><div class="ttdef"><b>Definition:</b> <a href="solver__cg__0_8txt_source.html#l00010">solver_cg_0.txt:10</a></div></div>
<div class="ttc" id="anamespaceparallel_1_1distributed_1_1GridRefinement_html_aa2ffb707a796ae6dedb75036606ef2e6"><div class="ttname"><a href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(parallel::distributed::Triangulation&lt; dim, spacedim &gt; &amp;tria, const ::Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const types::global_cell_index max_n_cells=std::numeric_limits&lt; types::global_cell_index &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="distributed_2grid__refinement_8cc_source.html#l00493">grid_refinement.cc:493</a></div></div>
<div class="ttc" id="aupdate__flags__0_8txt_html_a5873b8f7eeaefb5e7a99005c6c93b175"><div class="ttname"><a href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a></div><div class="ttdeci">and a mapping object that provides the Jacobian as well as its determinant Dealing with all these objects would be cumbersome and error prone *On the other these three kinds of objects almost always appear and it is in fact very rare for deal II application codes to do anything with quadrature</div><div class="ttdef"><b>Definition:</b> <a href="update__flags__0_8txt_source.html#l00019">update_flags_0.txt:19</a></div></div>
<div class="ttc" id="afe_2fe__q_8h_html"><div class="ttname"><a href="fe_2fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html_ab14ac27fc9ab74d4de531698b492d8de"><div class="ttname"><a href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">SymmetricTensor::scalar_product</a></div><div class="ttdeci">constexpr ProductType&lt; Number, OtherNumber &gt;::type scalar_product(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;t1, const SymmetricTensor&lt; 2, dim, OtherNumber &gt; &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="base_2symmetric__tensor_8h_source.html#l03792">symmetric_tensor.h:3792</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="asymmetric__tensor__0_8txt_html_aeaf892aa244db24771fb1ff7cce8057f"><div class="ttname"><a href="symmetric__tensor__0_8txt.html#aeaf892aa244db24771fb1ff7cce8057f">P</a></div><div class="ttdeci">see there for more information **Import two alias from the switch class above **Constructor Take a reference to the tensor object which we will access The second argument denotes the values of previous indices into the tensor For for a rank if P</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor__0_8txt_source.html#l00056">symmetric_tensor_0.txt:56</a></div></div>
<div class="ttc" id="anumerics_2error__estimator_8h_html"><div class="ttname"><a href="numerics_2error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__extractors_8h_source.html#l00095">fe_values_extractors.h:95</a></div></div>
<div class="ttc" id="abase_2timer_8h_html"><div class="ttname"><a href="base_2timer_8h.html">timer.h</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_aa2626b9a8731384418b99aaadfc1d365"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a></div><div class="ttdeci">this leads to a degree of flexibility in computations that cannot be matched by auto differentiation For one could perform the permanent substitution[2.x.86] and then recompute[2.x.87] for several different values of[2.x.88] One could also post factum express an interdependency between x and y</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="agrid__generator__0_8txt_html_ad9adfa4fc9634eb12b6c9ba287d11e46"><div class="ttname"><a href="grid__generator__0_8txt.html#ad9adfa4fc9634eb12b6c9ba287d11e46">z</a></div><div class="ttdeci">namespace provides a collection of functions for generating triangulations for some basic geometries *Some of these functions receive a parts of the boundary receive different[2.x.2] boundary indicators allowing them to be distinguished for the purpose of evaluating different boundary conditions *If the domain is each of the domain parts that should be refined by following an appropriate Manifold description will receive a different[2.x.3] manifold and the correct Manifold descriptor will be attached to the Triangulation Notice that if you later transform the you have to make sure you attach the correct new Manifold to the triangulation ******Creating meshes for basic geometries **Initialize the given triangulation with a where the limits are given as arguments They default to zero and then producing the unit hypercube If the argument[2.x.7] is then all boundary indicators are set to the boundary is[2.x.8] colorized as in see a&lt; tt &gt; Triangulation[2.x.15] will be a square in the xy plane with z</div><div class="ttdef"><b>Definition:</b> <a href="grid__generator__0_8txt_source.html#l00014">grid_generator_0.txt:14</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_aafea668ad0c451ac7a0fae0f558c36d7"><div class="ttname"><a href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a></div><div class="ttdeci">in the area occupied by these artificial cells</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00037">distributed_0.txt:37</a></div></div>
<div class="ttc" id="anamespaceParticles_1_1Generators_html_a498c6b70c8c3169a3d1513418beb9e15"><div class="ttname"><a href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a></div><div class="ttdeci">void dof_support_points(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; std::vector&lt; BoundingBox&lt; spacedim &gt;&gt;&gt; &amp;global_bounding_boxes, ParticleHandler&lt; dim, spacedim &gt; &amp;particle_handler, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()), const ComponentMask &amp;components=ComponentMask(), const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;properties={})</div><div class="ttdef"><b>Definition:</b> <a href="generators_8cc_source.html#l00414">generators.cc:414</a></div></div>
<div class="ttc" id="afe_2mapping__fe__field_8h_html"><div class="ttname"><a href="fe_2mapping__fe__field_8h.html">mapping_fe_field.h</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga72743302dcb1a0fb1f2f8dc5122d299e"><div class="ttname"><a href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">Patterns::Tools::to_string</a></div><div class="ttdeci">std::string to_string(const T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l02413">patterns.h:2413</a></div></div>
<div class="ttc" id="amapping__info__0_8txt_html_aaed09e22b1fee38bd2273caeedfb0e90"><div class="ttname"><a href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a></div><div class="ttdeci">*An enum to identify various types of cells and faces The most general type is what we typically compute in the FEValues context but for many geometries we can save significant storage ***The cell or face is Cartesian **The cell or face can be described with an affine mapping **The face is i the normal factor on a face is the same on all quadrature points This type is not assigned for cells **There is no special information available for compressing the representation of the object under consideration **Definition of a structure that stores all cached data related to the evaluated geometry from the mapping In order to support hp adaptivity and compressed storage length can be different for different rows it allows to jump at the data of individual rows similar to compressed row storage in sparse matrices We have two different start indices for fields with different sizes The first category of offsets are the indices for Jacobians of the transformation from unit to real second JxW and normal vectors We keep separate arrays for all these data structures because a user code might access only some of them In such a one array will be gone through in a contiguous order with access to all which makes it easy for the processor to prefetch data Having all data in a single array would require some strides in the access which is much more complicated for the processor to called which contains the quadrature weights and permutations of how to go through quadrature points in case of face data The latter comes in a vector for the support of hp with several data fields for the individual quadrature formulas ***Constructor Does nothing **Set up the lengths in the various members of this struct **Set up the lengths in the various members of this struct **Returns the memory consumption in bytes **Number of quadrature points applied on the given cell or face **Original one dimensional quadrature formula applied on the given cell or face **Quadrature formula applied on the given cell or face **Quadrature weights separated by dimension for use in specific situations **A cached vector of quadrature weights in the given number the evaluation of basis functions is not in the correct order if a face is not in the standard orientation to a given element This data structure is used to re order the data evaluated on quadrature points to represent the correct order **A class describing the layout of the sections in the[2.x.2] field and also includes some data that depends on the number of quadrature points in the hp context such as the inner quadrature formula and re indexing for faces that are not in the standard orientation **Collection of quadrature formulae applied on the given face *Only filled for since faces might be quadrilateral or triangle shaped **Stores the index offset into the arrays[2.x.4][2.x.5][2.x.6] and the second derivatives Note that affine cells have shorter fields of where the others have lengths equal to the number of quadrature points of the given cell **The storage of the Jacobian i the inverse and transposed Jacobians of the transformation from the unit to the real cell Indexed by[2.x.9] Contains two fields for access from both sides for interior but the default only the upper diagonal and diagonal part are needed The first index runs through the starting with the diagonal and then continuing row i and so on The second index is the spatial coordinate Indexed by[2.x.12] Contains two fields for access from both sides for interior but the default including a compression scheme for Cartesian cells where we do not need to store the full data on all points Indexed by *[2.x.16] *Clears all data fields except the descriptor vector **Returns the quadrature index for a given number of quadrature points If not in hp mode or if the index is not this function always returns index this function does not check whether the given degree is actually present **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **Returns the memory consumption in bytes **The class that stores all geometry dependent data related with cell interiors for use in the matrix free class ***Compute the information in the given cells and faces The cells are specified by the level and the index within the a mapping and several quadrature formulas are given **Update the information in the given cells and faces that is the result of a change in the given mapping keeping the quadrature formulas and other unknowns unchanged This call is only valid if[2.x.20] has been called before **Return the type of a given cell as detected during initialization **Clear all data fields in this class **Return the memory consumption of this class in bytes **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **The given update flags for computing the geometry on the cells **The given update flags for computing the geometry on the boundary faces **The given update flags for computing the geometry on the interior faces **The given update flags for computing the geometry on the faces for cell centric loops **Stores whether a cell is has constant transform data() or is whether it represents an affine whether it is a flat face where the normal vector is the same throughout the or is following the[2.x.21] variable for the cell types **The pointer to the underlying[2.x.22] object **The pointer to the first entry of mapping_collection **Reference cell type related to each quadrature and active quadrature index **Internal function to compute the geometry for the case the mapping is a MappingQ and a single quadrature formula per i it uses a polynomial description of the cell especially when several different quadrature formulas are and consumes less memory[2.x.23] tria The triangulation to be used for setup[2.x.24] cells The actual cells of the triangulation to be worked given as a tuple of the level and index within the level as used in the main initialization of the class ::x faces The description of the connectivity from faces to cells as filled in the MatrixFree class **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Helper function to determine which update flags must be set in the internal functions to initialize all data as requested by the user **A helper class to extract either cell or face data from mapping info for use in FEEvaluationBase **A class that is used to compare floating point c</div><div class="ttdef"><b>Definition:</b> <a href="mapping__info__0_8txt_source.html#l00116">mapping_info_0.txt:116</a></div></div>
<div class="ttc" id="akinsol__0_8txt_html_a6f62a16b407bb6c63e7b27a45efe9c97"><div class="ttname"><a href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a></div><div class="ttdeci">**Additional parameters that can be passed to the KINSOL class **KINSOL solution strategy KINSOL includes a Newton Krylov solver(both local and global) as well as Picard and fixed point solvers. *[0.x.3] *Standard Newton iteration. *[0.x.4] *Newton iteration with linesearch. *[0.x.5] *Fixed point iteration. *[0.x.6] *Picard iteration. *[0.x.7] *Initialization parameters for KINSOL. Global parameters the computation will be aborted and an assertion will be thrown **A function object that users may supply and that is intended to prepare the linear solver for subsequent calls to in the solution of linear systems[2.x.78] The exact nature of this system depends on the SolutionStrategy that has been selected In the cases and this function is never called The or a function within the linear solver to compute Jacobian related data that is required by the linear solver It may also preprocess that data as needed for which may involve calling a generic more build preconditioners from the assembled Jacobian In any the data so generated may then be used whenever a linear system is solved The point of this function is that but only as frequently as the solver determines that it is appropriate to perform the setup task In this Jacobian related data generated by thereby saving the effort to regenerate the Jacobian matrix and a preconditioner for it whenever possible[2.x.87] current_u Current value of[2.x.88][2.x.89] current_f Current value of[2.x.90] or[2.x.91] This function should then KINSOL does not call on the internal KINSOL convergence tests then KINSOL calls then only a fixed point iteration strategy can be used Notice that this may not or may converge very slowly A call to this function should store in dst the result of[2.x.93] applied to rhs</div><div class="ttdef"><b>Definition:</b> <a href="kinsol__0_8txt_source.html#l00517">kinsol_0.txt:517</a></div></div>
<div class="ttc" id="aclassIndexSet_html_add590b083cdde3fa61e637a058b51835"><div class="ttname"><a href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">IndexSet::get_view</a></div><div class="ttdeci">IndexSet get_view(const size_type begin, const size_type end) const</div><div class="ttdef"><b>Definition:</b> <a href="index__set_8cc_source.html#l00211">index_set.cc:211</a></div></div>
<div class="ttc" id="alac_2linear__operator_8h_html"><div class="ttname"><a href="lac_2linear__operator_8h.html">linear_operator.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2particles_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2particles_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="agroup__LAOperators_html_ga52a70111839180da28ccfebb4c588eca"><div class="ttname"><a href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a></div><div class="ttdeci">LinearOperator&lt; Range, Domain, Payload &gt; linear_operator(const OperatorExemplar &amp;, const Matrix &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="lac_2linear__operator_8h_source.html#l01465">linear_operator.h:1465</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_aeab70d834b7bc032f4ab627e72d6084c"><div class="ttname"><a href="geometry__info__0_8txt.html#aeab70d834b7bc032f4ab627e72d6084c">Face</a></div><div class="ttdeci">Face Face</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00389">geometry_info_0.txt:389</a></div></div>
<div class="ttc" id="aclassBlockDynamicSparsityPattern_html"><div class="ttname"><a href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2block__sparsity__pattern_8h_source.html#l00549">block_sparsity_pattern.h:549</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="aclassReductionControl_html"><div class="ttname"><a href="classReductionControl.html">ReductionControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00443">solver_control.h:443</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_a614ec9f581086ad423513dd407e9e520"><div class="ttname"><a href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a></div><div class="ttdeci">TopoDS_Shape read_STEP(const std::string &amp;filename, const double scale_factor=1e-3)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00355">utilities.cc:355</a></div></div>
<div class="ttc" id="aclassStep70_1_1StokesImmersedProblemParameters_html"><div class="ttname"><a href="classStep70_1_1StokesImmersedProblemParameters.html">Step70::StokesImmersedProblemParameters</a></div><div class="ttdef"><b>Definition:</b> <a href="step-70_8cc_source.html#l00110">step-70.cc:110</a></div></div>
<div class="ttc" id="agroup__Vectors_html_ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b"><div class="ttname"><a href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a></div><div class="ttdeci">@ add</div><div class="ttdef"><b>Definition:</b> <a href="lac_2vector__operation_8h_source.html#l00056">vector_operation.h:56</a></div></div>
<div class="ttc" id="alac_2affine__constraints_8h_html"><div class="ttname"><a href="lac_2affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="agroup__LAOperators_html_ga87e38fbde431397c069a88692bd24ae7"><div class="ttname"><a href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">LinearOperator::inverse_operator</a></div><div class="ttdeci">LinearOperator&lt; Domain, Range, Payload &gt; inverse_operator(const LinearOperator&lt; Range, Domain, Payload &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</div><div class="ttdef"><b>Definition:</b> <a href="lac_2linear__operator_8h_source.html#l00746">linear_operator.h:746</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_a0d0a9b5bbc80d6f0b9d863fa664d74ef"><div class="ttname"><a href="data__out__base__0_8txt.html#a0d0a9b5bbc80d6f0b9d863fa664d74ef">source</a></div><div class="ttdeci">several of the example programs show how to do this **All functions take a parameter which is a structure of type&lt; tt &gt; where&lt; tt &gt; X&lt;/tt &gt; is the name of the output format To find out what flags are presently read the documentation of the different structures *Note that usually the output formats used for scientific visualization programs have no or very few like Postscript or Povray need to be given a lot more since there the output file has to contain all details of the light source</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00027">data_out_base_0.txt:27</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_ad919e2b915d8e8226aef004c2d8399a8"><div class="ttname"><a href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">exception</a></div><div class="ttdeci">since default values may change in the process of program you cannot know the values of parameters not specified in the input file ****It is often convenient to have something happen as soon as a parameter value is read This could be a check that it is valid that a file that is listed in the parameter file exists **or to initiate something else in such as setting a variable outside the this action could also be initiated once all parameters are read via but it is sometimes[1.x.19] to do it right away *This is facilitated by the and can then do whatever they want with it **e save it somewhere outside the ParameterHandler in C one doesn t usually pass around the address of a but an action can be a function like object(taking a string as argument) that results from calling such as a[1.x.20] that has the form **[1.x.21] *and that is attached to a specific parameter. *A typical example of such an action would be as follows the content of the file equals the default value of the parameter the contents of files are never changed after declaration of a parameter a directory in this file system may not have a file called[2.x.20] in it In that the directory represents a subsection as declared and the directory s name will correspond to the name of the subsection It will then have no files in it at but it may have further directories in the code above will lead to a hierarchical representation of data that looks like this(the content of files is indicated at the right in a different font) this is only used when creating output for exceptions If non empty[2.x.35] is the ParameterHandler object will stop parsing lines after encountering[2.x.36] This is handy when adding extra data that shall be parsed manually If[2.x.37] the parameter handler will skip undefined sections and entries This is useful for partially parsing a parameter for example to obtain only the spatial dimension of the problem By default all entries and subsections are expected to be declared The function sets the value of all parameters it encounters in the input file to the provided value Parameters not explicitly listed in the input file are left at the value they previously which will be the default value provided to and for each parameter all associated actions that may previously have been set by or if an associated action throws an exception</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00241">parameter_handler_0.txt:241</a></div></div>
<div class="ttc" id="apolynomial__0_8txt_html_ad2c421d87c61fba8a64abc270463b1b7"><div class="ttname"><a href="polynomial__0_8txt.html#ad2c421d87c61fba8a64abc270463b1b7">term</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant term</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00012">polynomial_0.txt:12</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData&lt; dim, dim, dim, dim &gt;::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="awork__stream__0_8txt_html_a1c121a619b3787a3c8ac4194ed595af8"><div class="ttname"><a href="work__stream__0_8txt.html#a1c121a619b3787a3c8ac4194ed595af8">not</a></div><div class="ttdeci">a large number makes sure that each thread gets a significant amount of work before the next task switch whereas a small number is better for load balancing **A class that manages calling the worker function on a number of parallel threads Note that it is in the TBB notation a filter that can run in parallel **Constructor Takes a reference to the object on which we will operate as well as a pointer to the function that will do the assembly **Work on an item **Pointer to the function that does the assembling on the sequence of cells **This flag is true if the copier stage exist If it does not</div><div class="ttdef"><b>Definition:</b> <a href="work__stream__0_8txt_source.html#l00109">work_stream_0.txt:109</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ac686a2d27b6681259628e383e731c143">DoFTools::none</a></div><div class="ttdeci">@ none</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__tools_8h_source.html#l00216">dof_tools.h:216</a></div></div>
<div class="ttc" id="alac_2linear__operator__tools_8h_html"><div class="ttname"><a href="lac_2linear__operator__tools_8h.html">linear_operator_tools.h</a></div></div>
<div class="ttc" id="amg__0_8txt_html_a1f7a91126f3fe8004760adfc52fc5dbe"><div class="ttname"><a href="mg__0_8txt.html#a1f7a91126f3fe8004760adfc52fc5dbe">level</a></div><div class="ttdeci">which is a wrapper around Multigrid with the standard interface of deal II[2.x.9] Preconditioners PreconditionMG also uses the classes inheriting from for instance where it uses[2.x.10] and[2.x.11] which transfer between the global vector and the level vectors we have several auxiliary namely which stores an object on each level **See and[2.x.14] example programs on how to use this functionality **Using multigrid methods on adaptively refined meshes involves more infrastructure than with regular refinement in order to keep the complexity we need to decide how to do the smoothing on each level And to this we have to define what a level is in the sense of multilevel decomposition we define that a level in the multigrid sense is constituted by all cells of a certain level in the mesh hierarchy smoothing on a certain level is restricted to the subdomain which consists of cells of this level or finer This is usually referred to as smoothing The advantage of this definition that level matrices for the multigrid scheme can be assembled easily by traversing to all cells of a certain level</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00014">mg_0.txt:14</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a676390618e4d4cade021c4edeac58b65"><div class="ttname"><a href="coding__conventions__0_8txt.html#a676390618e4d4cade021c4edeac58b65">parameter</a></div><div class="ttdeci">and someone else can make a mistake while calling myfunction In either I would like to write my code in such a way thaterrors ii that the compiler can alreadyfind some of the for example because the program aborts Defensiveprogramming is then a set of strategies that make these goals more likely *[2.x.85] Over we have learned a number of techniques to this some of whichwe list all the time As the prototypical consider a trivial implementation of vector this function will get into trouble if the two vectors do not have the same size You think it is silly to call this function with vectors of different size of course it is But it happens all the or it is reset in a different etc It happens So if you are in such an unlucky it can take a long time to figure out what s going on because you are likely to just read uninitialized or maybe you are writing to memory the[2.x.89] vector doesn t actually own Neither is going to lead to immediate termination of the but you ll probably get random errors at a later time It would be much easier if the program just stopped here right away The following implementation will do exactly and otherwise prints a string containing information encoded by the second argument and aborts the program This when you write a new program that happens to call this you will learn of your error right away and have the opportunity to fix it without ever having to seriously debug anything[2.x.91] As a general whenever you implement a new think about the[1.x.16] on parameter</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00065">coding_conventions_0.txt:65</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__component__interpretation_8h_source.html#l00062">data_component_interpretation.h:62</a></div></div>
<div class="ttc" id="aclassTable_html"><div class="ttname"><a href="classTable.html">Table</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2array__view_8h_source.html#l00033">array_view.h:33</a></div></div>
<div class="ttc" id="aclassOpenCASCADE_1_1NormalToMeshProjectionManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00227">manifold_lib.h:227</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_a4cd641df34659abb61c41ded50daf3ce"><div class="ttname"><a href="functions__0_8txt.html#a4cd641df34659abb61c41ded50daf3ce">terms</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing terms</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00006">functions_0.txt:6</a></div></div>
<div class="ttc" id="abase_2symmetric__tensor_8h_html_ab14ac27fc9ab74d4de531698b492d8de"><div class="ttname"><a href="base_2symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a></div><div class="ttdeci">constexpr ProductType&lt; Number, OtherNumber &gt;::type scalar_product(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;t1, const SymmetricTensor&lt; 2, dim, OtherNumber &gt; &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="base_2symmetric__tensor_8h_source.html#l03792">symmetric_tensor.h:3792</a></div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a836d12b85657b83a8978aff8d7672c23"><div class="ttname"><a href="constraints__0_8txt.html#a836d12b85657b83a8978aff8d7672c23">hand</a></div><div class="ttdeci">****and the matrix is finally condensed *In the condensation we are not actually changing the number of rows or columns of the sparsity and vectors the condense functions add nonzero entries to the sparsity pattern of the rows and columns subject to constraints are distributed to the rows and columns of unconstrained nodes The constrained degrees of freedom remain in place In order not to disturb the solution these rows and columns are filled with zeros and an appropriate positive value on the main the constrained node will always get the value zero upon solution of the equation system and will not couple to other nodes any more *Keeping the entries in the matrix has the advantage over creating a new and smaller that only one matrix and sparsity pattern is needed thus less memory is required the condensation process is less since not all but only constrained values in the matrix have to be copied On the other hand</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00068">constraints_0.txt:68</a></div></div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="aclassSolverControl_html_a42aeae81cd6b67ce93b5fbea3328371f"><div class="ttname"><a href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">SolverControl::last_step</a></div><div class="ttdeci">unsigned int last_step() const</div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8cc_source.html#l00127">solver_control.cc:127</a></div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00038">fe.h:38</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00116">fe_update_flags.h:116</a></div></div>
<div class="ttc" id="agroup__manifold_html_ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><div class="ttname"><a href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a></div><div class="ttdeci">void set_manifold(const types::manifold_id number, const Manifold&lt; dim, spacedim &gt; &amp;manifold_object)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10154">tria.cc:10154</a></div></div>
<div class="ttc" id="aclassOpenCASCADE_1_1NURBSPatchManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00359">manifold_lib.h:359</a></div></div>
<div class="ttc" id="aparticle__0_8txt_html_a758e3b11dc0bab28f80a228d34935196"><div class="ttname"><a href="particle__0_8txt.html#a758e3b11dc0bab28f80a228d34935196">Particle</a></div><div class="ttdeci">namespace that contains all classes that are related to the particle implementation in particular the fundamental Particle class ***Internal alias of cell level index pair **A class that represents a particle in a domain that is meshed by a triangulation of some kind The data this class stores is the position of the particle in the overall space the position of the particle in the reference coordinate system of the cell it is currently in an ID number that is unique among all particles and a variable number of properties The properties attached to each object of this class are stored by a PropertyPool object These properties are stored as an array of double variables that can be accessed via an ArrayView object For example if one wanted to equip each particle with a temperature and chemical composition property that is advected along with the then one would allocate two properties per particle in the PropertyPool object In one often wants to associate properties with particles that are not just independent numbers as in the situation above An example would be if one wanted to track the stress or strain that a particle is subjected to **a tensor valued quantity In these one would[1.x.0] these scalar properties as the[1.x.1] In other one would first tell the PropertyPool to allocate as many properties per particle as there are components in the tensor one wants to and then write small conversion functions that take the ArrayView of scalar properties returned by the in floating point numbers but rather one may want to mark some particles as or green The property might then either be represented as an or as an element of an enum In these one would need to come up with a way to[1.x.2] these sorts of categorical fields in terms of floating point numbers For one could map red to the floating point blue and green to The conversion functions to translate between these two representations should then not be very difficult to write either ***Empty constructor for Particle</div><div class="ttdef"><b>Definition:</b> <a href="particle__0_8txt_source.html#l00013">particle_0.txt:13</a></div></div>
<div class="ttc" id="apolynomials__abf__0_8txt_html_a7a716deb19e461cf8ba2a26e01c6a908"><div class="ttname"><a href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a></div><div class="ttdeci">*This class implements the[1.x.0] vector valued Arnold Boffi Falk polynomials as described in the article by Arnold Boffi SIAM J Numer Anal pp **The ABF polynomials are constructed such that the divergence is in the tensor product polynomial space[1.x.1] the polynomial order of each component must be two orders higher in the corresponding yielding the polynomial spaces[1.x.2] and[1.x.3] in resp ******Constructor Creates all basis functions for Raviart Thomas polynomials of given degree[2.x.1] k</div><div class="ttdef"><b>Definition:</b> <a href="polynomials__abf__0_8txt_source.html#l00013">polynomials_abf_0.txt:13</a></div></div>
<div class="ttc" id="anumerics_2vector__tools_8h_html"><div class="ttname"><a href="numerics_2vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="abase_2function_8h_html"><div class="ttname"><a href="base_2function_8h.html">function.h</a></div></div>
<div class="ttc" id="aclassTimerOutput_html"><div class="ttname"><a href="classTimerOutput.html">TimerOutput</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00591">timer.h:591</a></div></div>
<div class="ttc" id="agroup__LAOperators_html_ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><div class="ttname"><a href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">LinearOperator::linear_operator</a></div><div class="ttdeci">LinearOperator&lt; Range, Domain, Payload &gt; linear_operator(const Matrix &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="lac_2linear__operator_8h_source.html#l01436">linear_operator.h:1436</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a65ecb3886ec86207a20d2f9e8e690022"><div class="ttname"><a href="multithreading__0_8txt.html#a65ecb3886ec86207a20d2f9e8e690022">does</a></div><div class="ttdeci">threads then execute sub ranges if they are done with their steal entire or parts of sub ranges from other threads to keep busy This work is load balanced even if not every loop iteration takes equally much or if some of the CPU cores fall behind because the operating system interrupted them for some other work *The TBB library primitives for this are a bit clumsy so deal II has wrapper routines for the most frequently used operations The simplest one is akin to what the[2.x.40] does</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00082">multithreading_0.txt:82</a></div></div>
<div class="ttc" id="astructPatterns_1_1Tools_1_1Convert_html"><div class="ttname"><a href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l01389">patterns.h:1389</a></div></div>
<div class="ttc" id="abase_2index__set_8h_html"><div class="ttname"><a href="base_2index__set_8h.html">index_set.h</a></div></div>
<div class="ttc" id="amg__constrained__dofs__0_8txt_html_af0d9e7397d0d6434a351da4ea2a005a5"><div class="ttname"><a href="mg__constrained__dofs__0_8txt.html#af0d9e7397d0d6434a351da4ea2a005a5">transfer</a></div><div class="ttdeci">*Collection of boundary constraints and refinement edge constraints for level vectors ******Fill the internal data structures with hanging node constraints extracted from the dof handler object Works with natural boundary conditions only There exists a sister function setting up boundary constraints as well This function ensures that on every degrees of freedom at interior edges of a refinement level are treated corrected but leaves degrees of freedom at the boundary of the domain untouched assuming that no Dirichlet boundary conditions for them exist this call sets up an AffineConstraints object on each level that contains possible periodicity constraints in case those have been added to the underlying triangulation The AffineConstraints object can be queried by i the respective argument in the[2.x.1] may not be different from the identity matrix If no level_relevant_dofs are passed as the second the function uses the locally relevant level extracted by[2.x.2] the user provided which should define a superset of locally relevant are used on each level to allow the user to add additional indices to the set of constrained DoFs **Fill the internal data structures with information about Dirichlet boundary dofs The conflicting constraints will overwrite the previous constraints for that DoF Before the transfer</div><div class="ttdef"><b>Definition:</b> <a href="mg__constrained__dofs__0_8txt_source.html#l00014">mg_constrained_dofs_0.txt:14</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_a0069596c748f19eefb336d83ba03c96f"><div class="ttname"><a href="data__out__base__0_8txt.html#a0069596c748f19eefb336d83ba03c96f">grid</a></div><div class="ttdeci">if you want to write out data on such a grid</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00010">data_out_base_0.txt:10</a></div></div>
<div class="ttc" id="avector__tools__constraints__0_8txt_html_acb0039192ebc332fa285c0450e90388b"><div class="ttname"><a href="vector__tools__constraints__0_8txt.html#acb0039192ebc332fa285c0450e90388b">condition</a></div><div class="ttdeci">*Interpolation and projection **This function computes the constraints that correspond to boundary conditions of the i normal flux constraints where[2.x.2] is a vector valued solution variable and[2.x.3] is a prescribed vector field whose normal component we want to be equal to the normal component of the solution These conditions have exactly the form handled by the AffineConstraints in that they relate a[1.x.0] of boundary degrees of freedom to a corresponding the current function creates a list of constraints that are written into an AffineConstraints container This object may already have some for example from hanging node that remains untouched These constraints have to be applied to the linear system like any other such i you have to condense the linear system with the constraints before and you have to distribute the solution vector afterwards This function treats a more general case because everything that would apply to that function also applies as a special case to the current the following discussion is relevant to both *This function doesn t make much sense so it throws an exception if[2.x.9] equals one[1.x.1] The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain For if we were solving a Stokes equation in and the finite element had then[2.x.11] first_vector_component needs to be zero if you intend to constraint the vector[2.x.12] On the other if we solved the Maxwell equations in and the finite element has components[2.x.13] and we want the boundary condition[2.x.14]</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__constraints__0_8txt_source.html#l00005">vector_tools_constraints_0.txt:5</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_affe07b496f4edf844d5f4e8d7a540295"><div class="ttname"><a href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a></div><div class="ttdeci">TopoDS_Shape read_IGES(const std::string &amp;filename, const double scale_factor=1e-3)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00238">utilities.cc:238</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a373fbdacd8c486e675b8d2bff8943192"><div class="ttname"><a href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a></div><div class="ttdeci">void distribute_local_to_global(const InVector &amp;local_vector, const std::vector&lt; size_type &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02250">affine_constraints.h:2250</a></div></div>
<div class="ttc" id="anamespaceDataOutBase_html_a6f1c052ba49fd44cd8e3f35ba871aebd"><div class="ttname"><a href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a></div><div class="ttdeci">void write_pvd_record(std::ostream &amp;out, const std::vector&lt; std::pair&lt; double, std::string &gt;&gt; &amp;times_and_names)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l05963">data_out_base.cc:5963</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160ae505ee2251dce5d665811501b2037af7">DoFTools::always</a></div><div class="ttdeci">@ always</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__tools_8h_source.html#l00221">dof_tools.h:221</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_a5520ba264c2ecb9dac7e6eee24dfb4ec"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a></div><div class="ttdeci">std::vector&lt; T &gt; all_gather(const MPI_Comm &amp;comm, const T &amp;object_to_send)</div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a5abc878123b65e2a7a16e57bba0e282e"><div class="ttname"><a href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a></div><div class="ttdeci">******This module deals with constraints on degrees of freedom The central class to deal with constraints is the AffineConstraints class *Constraints typically come from several for one usually enforces them by requiring that degrees of freedom on the boundary have particular for example[2.x.3] if the boundary condition[2.x.4] requires that the finite element solution[2.x.5] at the location of degree of freedom has the value Such constraints are generated by those versions of the[2.x.6] function that take a AffineConstraints for example no normal as happens in flow problems and is handled by the[2.x.11] function or prescribed tangential as happens in electromagnetic problems and is handled by the[2.x.13] function For the former imagine for example that we are at at vertex where the normal vector has the form[2.x.14] and that and[2.x.17] components of the flow field at this vertex are associated with degrees of and Then the no normal flux condition means that we need to have the condition[2.x.18] The prescribed tangential component leads to similar constraints though there is often something on the right hand side ****If you have hanging node constraints</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00020">constraints_0.txt:20</a></div></div>
<div class="ttc" id="alac_2solver__minres_8h_html"><div class="ttname"><a href="lac_2solver__minres_8h.html">solver_minres.h</a></div></div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Vector_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__extractors_8h_source.html#l00140">fe_values_extractors.h:140</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="agrid__generator__0_8txt_html_aa11be8d5d13009407ac286e68efd4387"><div class="ttname"><a href="grid__generator__0_8txt.html#aa11be8d5d13009407ac286e68efd4387">hyper_rectangle</a></div><div class="ttdeci">namespace provides a collection of functions for generating triangulations for some basic geometries *Some of these functions receive a parts of the boundary receive different[2.x.2] boundary indicators allowing them to be distinguished for the purpose of evaluating different boundary conditions *If the domain is each of the domain parts that should be refined by following an appropriate Manifold description will receive a different[2.x.3] manifold and the correct Manifold descriptor will be attached to the Triangulation Notice that if you later transform the you have to make sure you attach the correct new Manifold to the triangulation ******Creating meshes for basic geometries **Initialize the given triangulation with a where the limits are given as arguments They default to zero and then producing the unit hypercube If the argument[2.x.7] is then all boundary indicators are set to the boundary is[2.x.8] colorized as in hyper_rectangle(). In 1d the indicators are always colorized</div></div>
<div class="ttc" id="amg__transfer__0_8txt_html_a6b401cd9c6154fc787311f58ab910002"><div class="ttname"><a href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a></div><div class="ttdeci">MGTransferBase is defined in mg_base h ***Implementation of transfer between the global vectors and the multigrid levels for use in the derived class MGTransferPrebuilt and other classes ***Reset the object to the state it had right after the default constructor **Transfer from a vector on the global grid to vectors defined on each of the levels separately for the active degrees of freedom In for a globally refined mesh only the finest level in[2.x.0] is filled as a plain copy of[2.x.1] All the other level objects are left untouched **Transfer from multi level vector to normal vector Copies data from active portions of an MGVector into the respective positions of a&lt; tt &gt; Vector&lt; number &gt;&lt;/tt &gt; In order to keep the result constrained degrees of freedom are set to zero **Add a multi level vector to a normal vector Works as the previous but probably not for continuous elements **If this object operates on BlockVector we need to describe how the individual vector components are mapped to the blocks of a vector For for a Stokes we have dim vector components for velocity and pressure</div><div class="ttdef"><b>Definition:</b> <a href="mg__transfer__0_8txt_source.html#l00017">mg_transfer_0.txt:17</a></div></div>
<div class="ttc" id="aclassParticles_1_1DataOut_html_adf095165dc286310226584b2b9972701"><div class="ttname"><a href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">Particles::DataOut::build_patches</a></div><div class="ttdeci">void build_patches(const Particles::ParticleHandler&lt; dim, spacedim &gt; &amp;particles, const std::vector&lt; std::string &gt; &amp;data_component_names={}, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretations={})</div><div class="ttdef"><b>Definition:</b> <a href="particles_2data__out_8cc_source.html#l00028">data_out.cc:28</a></div></div>
<div class="ttc" id="avector__tools__point__value__0_8txt_html_ac7a5c2ceb5c739d5b51cc7e0eee8100a"><div class="ttname"><a href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a></div><div class="ttdeci">*Assembling of right hand sides **Create a right hand side vector for a point source at point[2.x.1] In other it creates a vector[2.x.2] so that[2.x.3] where[2.x.4] are the shape functions described by[2.x.5] and[2.x.6] is the point at which the delta function is located Prior content of the given[2.x.7] vector is deleted This function is for the case of a scalar finite element This function is typically used in one of these two with different values for right hand sides or and then evaluate the solution at the same point every time You could do this by calling[2.x.8] after each solve</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__point__value__0_8txt_source.html#l00015">vector_tools_point_value_0.txt:15</a></div></div>
<div class="ttc" id="aclassParameterAcceptor_html_a8c735525d2865112e5d67f9ba697224e"><div class="ttname"><a href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a></div><div class="ttdeci">static void initialize(const std::string &amp;filename=&quot;&quot;, const std::string &amp;output_filename=&quot;&quot;, const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &amp;prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)</div><div class="ttdef"><b>Definition:</b> <a href="parameter__acceptor_8cc_source.html#l00060">parameter_acceptor.cc:60</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_a11c48f86a4f2adf21555e64049ecde8c"><div class="ttname"><a href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05605">vectorization.h:5605</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a2165565a5e6b6679392a7dee5d01ef58"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a2165565a5e6b6679392a7dee5d01ef58">LinearAlgebraDealII::Vector</a></div><div class="ttdeci">Vector&lt; double &gt; Vector</div><div class="ttdef"><b>Definition:</b> <a href="lac_2generic__linear__algebra_8h_source.html#l00046">generic_linear_algebra.h:46</a></div></div>
<div class="ttc" id="alac_2dynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="lac_2dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="abase_2bounding__box__0_8txt_html_a56581e78a349db4405441847b3ee5b1d"><div class="ttname"><a href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a></div><div class="ttdeci">*The enumerator NeighborType describes the neighboring relation between two bounding boxes ***Not in this means that the two boxes touch at one corner of the each box **Attached in this means that the two boxes touch along an edge **Mergeable e g **or one is inside the other **A class that represents a box of arbitrary dimension&lt; tt &gt; spacedim&lt;/tt &gt; and with sides parallel to the coordinate axes that is a region a bounding box is top right for useful in parallel distributed meshes to give a general description of the owners of each portion of the mesh *Taking the cross section of a BoundingBox&lt; spacedim &gt; orthogonal to a given direction gives a box in one dimension the coordinates of the cross section of BoundingBox&lt; 3 &gt; can be ordered in different ways That if we take the cross section orthogonal to the y direction we could either order a coordinate into a coordinate as[2.x.1] or as[2.x.2] This class uses the second convention corresponding to the coordinates being ordered cyclicly[2.x.3] To be if we take a cross z y *This is according to the convention set by the function *[2.x.4] **Standard constructor Creates an object that corresponds to an empty i e a degenerate box with both points being the origin **Standard constructor for non empty boxes</div><div class="ttdef"><b>Definition:</b> <a href="base_2bounding__box__0_8txt_source.html#l00060">bounding_box_0.txt:60</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a></div><div class="ttdeci">@ component_is_scalar</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__component__interpretation_8h_source.html#l00055">data_component_interpretation.h:55</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_a796721b56b3a90e4e3973c7caae4c3d8"><div class="ttname"><a href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; count_dofs_per_fe_block(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned int &gt; &amp;target_block=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l01943">dof_tools.cc:1943</a></div></div>
<div class="ttc" id="anamespaceLA_html"><div class="ttname"><a href="namespaceLA.html">LA</a></div><div class="ttdef"><b>Definition:</b> <a href="step-40_8cc_source.html#l00028">step-40.cc:28</a></div></div>
<div class="ttc" id="atable__0_8txt_html_ab0c207fc9a63cc7861178ab4e76b2da9"><div class="ttname"><a href="table__0_8txt.html#ab0c207fc9a63cc7861178ab4e76b2da9">n_elements</a></div><div class="ttdeci">=0&lt;/tt &gt;. *[0.x.39] *Fill this table(which is assumed to already have the correct size) from a source given by dereferencing the given forward iterator(which could, for example, be a pointer to the first element of an array, or an inserting[2.x.16] The second argument denotes whether the elements pointed to are arranged in a way that corresponds to the last index running fastest or slowest. The default is to use C-style indexing where the last index runs fastest(as opposed to Fortran-style where the first index runs fastest when traversing multidimensional arrays. For example, if you try to fill an object of type Table&lt; 2, T &gt;, then calling this function with the default value for the second argument will result in the equivalent of doing *[1.x.3] *On the other hand, if the second argument to this function is false, then this would result in code of the following form:*[1.x.4] *Note the switched order in which we fill the table elements by traversing the given set of iterators.[2.x.17] entries An iterator to a set of elements from which to initialize this table. It is assumed that iterator can be incremented and dereferenced a sufficient number of times to fill this table.[2.x.18] C_style_indexing If true, run over elements of the table with the last index changing fastest as we dereference subsequent elements of the input range. If false, change the first index fastest. *[0.x.40] *Fill all table entries with the same value. *[0.x.41] *Return a read-write reference to the indicated element. *[0.x.42] *Return the value of the indicated element as a read-only reference. We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don 't know here whether copying is expensive or not. *[0.x.43] *This function replicates the state found on the process indicated by[2.x.19] across all processes of the MPI communicator. The current state found on any of the processes other than[2.x.20] is lost in this process. One can imagine this operation to act like a call to[2.x.21] from the root process to all other processes, though in practice the function may try to move the data into shared memory regions on each of the machines that host MPI processes and let all MPI processes on this machine then access this shared memory region instead of keeping their own copy. See the general documentation of this class for a code example. The intent of this function is to quickly exchange large arrays from one process to others, rather than having to compute or create it on all processes. This is specifically the case for data loaded from disk **- say, large data tables **- that are more easily dealt with by reading once and then distributing across all processes in an MPI universe, than letting each process read the data from disk itself. Specifically, the use of shared memory regions allows for replicating the data only once per multicore machine in the MPI universe, rather than replicating data once for each MPI process. This results in large memory savings if the data is large on today 's machines that can easily house several dozen MPI processes per shared memory space. This function does not imply a model of keeping data on different processes in sync, as[2.x.22] and other vector classes do where there exists a notion of certain elements of the vector owned by each process and possibly ghost elements that are mirrored from its owning process to other processes. Rather, the elements of the current object are simply copied to the other processes, and it is useful to think of this operation as creating a set of `const ` AlignedVector objects on all processes that should not be changed any more after the replication operation, as this is the only way to ensure that the vectors remain the same on all processes. This is particularly true because of the use of shared memory regions where any modification of a vector element on one MPI process may also result in a modification of elements visible on other processes, assuming they are located within one shared memory node. *[2.x.23] The use of shared memory between MPI processes requires that the detected MPI installation supports the necessary operations. This is the case for MPI 3.0 and higher. *[2.x.24] This function is not cheap. It needs to create sub-communicators of the provided[2.x.25] object, which is generally an expensive operation. Likewise, the generation of shared memory spaces is not a cheap operation. As a consequence, this function primarily makes sense when the goal is to share large read-only data tables among processes n_elements</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00131">table_0.txt:131</a></div></div>
<div class="ttc" id="aopencascade_2manifold__lib_8h_html"><div class="ttname"><a href="opencascade_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, spacedim &gt;</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a21aa22d290ce783e37587b6c879b926c"><div class="ttname"><a href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a></div><div class="ttdeci">std::string dim_string(const int dim, const int spacedim)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00558">utilities.cc:558</a></div></div>
<div class="ttc" id="aindex__set__0_8txt_html_a85fb0893d080862c6fc2fbcb1e57a791"><div class="ttname"><a href="index__set__0_8txt.html#a85fb0893d080862c6fc2fbcb1e57a791">subdomain</a></div><div class="ttdeci">*A class that represents a subset of indices among a larger set For example it can be used to denote the set of degrees of freedom within the range[2.x.0] that belongs to a particular subdomain</div><div class="ttdef"><b>Definition:</b> <a href="index__set__0_8txt_source.html#l00002">index_set_0.txt:2</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="anumerics_2rtree_8h_html_a3591e6e032b1a56920f897a2bc387d43"><div class="ttname"><a href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a></div><div class="ttdeci">std::vector&lt; BoundingBox&lt; boost::geometry::dimension&lt; typename Rtree::indexable_type &gt;::value &gt; &gt; extract_rtree_level(const Rtree &amp;tree, const unsigned int level)</div></div>
<div class="ttc" id="abase_2index__set_8h_html_ad28b2e725afda38ffdef1bf61d5cadd4"><div class="ttname"><a href="base_2index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a></div><div class="ttdeci">IndexSet complete_index_set(const IndexSet::size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="base_2index__set_8h_source.html#l01094">index_set.h:1094</a></div></div>
<div class="ttc" id="anamespacetypes_html_a9f062a82e4dab1dd631a2c4fa8162bea"><div class="ttname"><a href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a></div><div class="ttdeci">unsigned int manifold_id</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00123">types.h:123</a></div></div>
<div class="ttc" id="anamespaceDoFRenumbering_html_a52c1941406d1ce2937e29a46edf111f4"><div class="ttname"><a href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></div><div class="ttdeci">void component_wise(DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering_8cc_source.html#l00681">dof_renumbering.cc:681</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html_ac643e79bd992f1a9bd0dca5b9f2859fb"><div class="ttname"><a href="base_2logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a></div><div class="ttdeci">LogStream deallog</div><div class="ttdef"><b>Definition:</b> <a href="logstream_8cc_source.html#l00037">logstream.cc:37</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ParsedFunction_html"><div class="ttname"><a href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2parsed__function_8h_source.html#l00077">parsed_function.h:77</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_ae41b67cfd48e02f6035e39c84f0fb47a"><div class="ttname"><a href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">FEValuesBase&lt; dim, dim &gt;::get_quadrature_points</a></div><div class="ttdeci">const std::vector&lt; Point&lt; spacedim &gt; &gt; &amp; get_quadrature_points() const</div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a69730bc7f91dd1be17fd083a66514e73"><div class="ttname"><a href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled to indent allsource files that have been changed recently If you want to make sure thatthe indenting is correct for all your you might want to set up apre commit hook One way to do is to copy[2.x.4] to[2.x.5] and make sure it isexecutable *If the system you are working on has more than one version of[2.x.6] degrees of freedom</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00018">coding_conventions_0.txt:18</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a553c97770c66367cd8861ec511390650"><div class="ttname"><a href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a></div><div class="ttdeci">for if the values of a function need to be evaluated at quadrature points</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00182">multithreading_0.txt:182</a></div></div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1Triangulation_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2tria_8h_source.html#l00226">tria.h:226</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a8b46679b07e8a15bf4914231091c57bf"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a8b46679b07e8a15bf4914231091c57bf">LinearAlgebraDealII::BlockSparseMatrix</a></div><div class="ttdeci">BlockSparseMatrix&lt; double &gt; BlockSparseMatrix</div><div class="ttdef"><b>Definition:</b> <a href="lac_2generic__linear__algebra_8h_source.html#l00064">generic_linear_algebra.h:64</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_af85863b31be0cbd660acba99051e0634"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a></div><div class="ttdeci">****This module contains classes that are used in the exception mechanism of deal II **Exceptions are used in two different not in static assertions are typically used to check that parameters to functions satisfy certain that internal data structures are and similar assertions For static assertions are used to make sure that two vectors that are added together have the same number of components **everything else would not make any sense anyway *Such checks are performed by the[2.x.3] macro in several thousand places within the library several tutorial programs starting with[2.x.4] show how to do this *If static a assertion is the exception mechanism generates an exception of a type that indicates what exactly goes wrong displays appropriate information including the exact location where the problem was detected and then aborts the program **if you try to add two vectors of different there is nothing that can be done within the program to cope with the you have to go fix the program code instead There is generally not even a reason to[2.x.5] an exception object using the usual C exception mechanism because there is nothing a function higher up could do in such cases to rectify the situation and deal with it in a useful way **it s not that the program received bad data</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00015">exceptions_0.txt:15</a></div></div>
<div class="ttc" id="abase_2utilities__0_8txt_html_a5b55f653ddb6c9850a414d80c71827a5"><div class="ttname"><a href="base_2utilities__0_8txt.html#a5b55f653ddb6c9850a414d80c71827a5">position</a></div><div class="ttdeci">for each remove leading and trailing spaces The default value of the delimiter is a so that the function splits comma separated lists of strings To make data input from tables if the input string ends in a then this last delimiter is ignored For **yields the same element list of output[2.x.37] as you would get if the input had been **or **As a consequence of this a call like **yields a one element list Because of the trimming of the single element is the empty string This function can digest the case that the delimiter is a space In this it returns all words in the string Combined with the rules this implies that **yields again the element list of output[2.x.38] from above despite the presence of space at the end of the string **yields an empty list regardless of the number of spaces in the string **Specialization of usually a documentation or and try to break it into individual lines of text at most[2.x.39] characters by breaking at positions marked by[2.x.40] in the text If this is not return the shortest lines that are longer than[2.x.41] The default value of the delimiter is a space character If original_text contains newline the string is split at these too **Return true if the given pattern string appears in the first position of the string **Read and return this integer as a pair together with how many characters it takes up in the string If no integer can be read at the indicated position</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities__0_8txt_source.html#l00067">utilities_0.txt:67</a></div></div>
<div class="ttc" id="atensor__function__0_8txt_html_a7df5c44c3259e9ce6ab8c7d1681e8e5e"><div class="ttname"><a href="tensor__function__0_8txt.html#a7df5c44c3259e9ce6ab8c7d1681e8e5e">specified</a></div><div class="ttdeci">takes the constant tensor value as an argument The reference value is copied internally An initial value for the time variable may be specified</div><div class="ttdef"><b>Definition:</b> <a href="tensor__function__0_8txt_source.html#l00038">tensor_function_0.txt:38</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="adistributed_2grid__refinement_8h_html"><div class="ttname"><a href="distributed_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_a1a0f08903e9f2a25a073261a20b86e26"><div class="ttname"><a href="data__out__base__0_8txt.html#a1a0f08903e9f2a25a073261a20b86e26">on</a></div><div class="ttdeci">several of the example programs show how to do this **All functions take a parameter which is a structure of type&lt; tt &gt; where&lt; tt &gt; X&lt;/tt &gt; is the name of the output format To find out what flags are presently read the documentation of the different structures *Note that usually the output formats used for scientific visualization programs have no or very few like Postscript or Povray need to be given a lot more since there the output file has to contain all details of the light etc **An abstraction layer has been introduced to facilitate coding backends for additional visualization tools It is applicable for data formats separating the information into a field of a field of connection information for the grid cells and data fields *For each of these output functions are namely a format specific output stream must be following the examples of VtkStream and so on</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00030">data_out_base_0.txt:30</a></div></div>
<div class="ttc" id="aA-headers_2fe__0_8txt_html_abbd000c1bb0a029706ba0d8934597f39"><div class="ttname"><a href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a></div><div class="ttdeci">****All classes related to shape functions and to access to shape functions This concerns the actual values of finite elements For the numbering of degrees of freedom refer to the module on *[2.x.1] The classes and functions of this module fall into several sub groups that are discussed in their respective sub modules listed above In the FETools class provides functions that provide information on finite elements transformations between elements etc *In the grand scheme of the pieces of this module interact with a variety of other parts of the without actually implementing a concrete element For the FiniteElement base class declares the virtual functions a derived class has to implement if it wants to describe a finite element space Likewise the FiniteElementData holds variables that describe certain values characterizing a finite element such as the number of degrees of freedom per vertex line or face *On the other classes like FE_Poly and FE_PolyTensor are higher abstractions They describe finite elements that are built atop polynomial descriptions of the shape functions on the unit cell Classes derived from them then only have to provide a description of the particular polynomial from which a finite element is built For the FE_Q class that implements the usual Lagrange elements uses the FE_Poly base class to generate a finite element by providing it with a set of Lagrange interpolation polynomials corresponding to an equidistant subdivision of interpolation points the FESystem class is used for vector valued problems There one may want to couple a number of for Navier Stokes one may want to use three Q1 elements for the three components of the velocity</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2fe__0_8txt_source.html#l00021">fe_0.txt:21</a></div></div>
<div class="ttc" id="aclassFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_ac5d1c63883bb2a85710935e76a7dedd4"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#ac5d1c63883bb2a85710935e76a7dedd4">it</a></div><div class="ttdeci">******to automatic and symbolic differentiation *Below we provide a very brief introduction as to what automatic and symbolic differentiation what variations of these computational numerical schemes and how they are integrated within deal II s framework The purpose of all of these schemes is to automatically compute the derivative of or approximations of it</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00010">automatic_and_symbolic_differentiation_0.txt:10</a></div></div>
<div class="ttc" id="afe_2fe__nothing_8h_html"><div class="ttname"><a href="fe_2fe__nothing_8h.html">fe_nothing.h</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_a9e454ad255c745650fddd97d61d90086"><div class="ttname"><a href="functions__0_8txt.html#a9e454ad255c745650fddd97d61d90086">arguments</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing or exact solutions Since closed form expressions for equations are often hard to pass along as function arguments</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00006">functions_0.txt:6</a></div></div>
<div class="ttc" id="aclassParameterAcceptorProxy_html"><div class="ttname"><a href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__acceptor_8h_source.html#l00671">parameter_acceptor.h:671</a></div></div>
<div class="ttc" id="adofs_2dof__tools_8h_html"><div class="ttname"><a href="dofs_2dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="astep-2_8cc_html_ab108b7b7bca84a81aceda045aaef1961"><div class="ttname"><a href="step-2_8cc.html#ab108b7b7bca84a81aceda045aaef1961">make_grid</a></div><div class="ttdeci">void make_grid(Triangulation&lt; 2 &gt; &amp;triangulation)</div><div class="ttdef"><b>Definition:</b> <a href="step-2_8cc_source.html#l00038">step-2.cc:38</a></div></div>
<div class="ttc" id="afe_2fe__system_8h_html"><div class="ttname"><a href="fe_2fe__system_8h.html">fe_system.h</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_add141cdc4d28d06d71948acb7f0c7150"><div class="ttname"><a href="vector__valued__0_8txt.html#add141cdc4d28d06d71948acb7f0c7150">s</a></div><div class="ttdeci">each of these vectors has[2.x.174] elements containing the values of the[2.x.175] velocities and the one pressure at a quadrature point *We can use these values to then construct other things like residuals the construct is a bit awkward we have a[2.x.176] s</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00155">vector_valued_0.txt:155</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a602682024ec652b990be121b5665f8ce"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a></div><div class="ttdeci">&lt;/tt &gt; **If the&lt; tt &gt;&lt;/tt &gt; preprocessor directive is set</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00031">exceptions_0.txt:31</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_a2b24e414d1a0d32deea919c5e8899811"><div class="ttname"><a href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a></div><div class="ttdeci">([1.x.8]&lt; sub &gt;1&lt;/sub &gt;, [1.x.9]&lt; sub &gt;2&lt;/sub &gt;, [1.x.10]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt; and[1.x.11] accordingly. Then, we can write the simplified equation in coordinates as[1.x.12] We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component(this is where the formulation with the[2.x.33] is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions:first, choose[1.x.13]=([1.x.14]&lt; sub &gt;1&lt;/sub &gt;, 0, 0)&lt; sup &gt;T&lt;/sup &gt;, then[1.x.15]=(0, [1.x.16]&lt; sub &gt;2&lt;/sub &gt;, 0)&lt; sup &gt;T&lt;/sup &gt;, and finally[1.x.17]=(0, 0, [1.x.18]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt;. writing the outcomes below each other, we obtain the system[1.x.19] where we used the standard inner product notation[2.x.34] . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form[1.x.20]([1.x.21], [1.x.22]), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient[1.x.23]:[1.x.24] Very formally, if we believe in operator valued matrices, we can rewrite this in the form[1.x.25]&lt; sup &gt;T&lt;/sup &gt;[1.x.26]=[1.x.27]&lt; sup &gt;T&lt;/sup &gt;[1.x.28] or[1.x.29] *[1.x.30] Now, let us consider a more complex example, the mixed Laplace equations discussed in[2.x.35] in three dimensions:[1.x.31] **Here, we have four solution components:the scalar pressure[2.x.36] and the vector-valued velocity[2.x.37] with three vector components. Note as important difference to the previous example, that the vector space[1.x.32] is not just simply a copy of three identical spaces/*A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows:[1.x.33] **This makes it clear that the solution[1.x.34] *indeed has four components. We note that we could change the ordering of the solution components[2.x.38] and[2.x.39] inside[2.x.40] if we also change columns of the matrix operator.*Next, we need to think about test functions[2.x.41] . We want to multiply both sides of the equation with them, then integrate over[2.x.42] . The result should be a scalar equality. We can achieve this by choosing[2.x.43] also vector valued as[1.x.35] **It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on(in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. *With this in mind, let us multiply by[2.x.44] and integrate to get the following equation which has to hold for all test functions[2.x.45] :[1.x.36] *or equivalently:[1.x.37] ***We get the final form by integrating by part the second term:[1.x.38] **It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector:the form in which we have solution and test functions[2.x.46] that each consist of a number of vector components that we can extract. **[2.x.47] VVFEs[1.x.39] *Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the FESystem class comes in:it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need[2.x.48] copies of the same element, for instance **[1.x.40] *This will generate a vector valued space of dimension[2.x.49], where each component is a continuous bilinear element of type FE_Q. It will have[2.x.50] times as many basis functions as the corresponding FE_Q, and each of these basis functions is a basis function of FE_Q, lifted into one of the components of the vector. *For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces[2.x.51] . One option would be the stable Raviart-Thomas pair **[1.x.41] *The first element in this system is already a vector valued element of dimension[2.x.52], while the second is a regular scalar element. *Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely **[1.x.42] *This system just has[2.x.53] equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer **[1.x.43] *Here, we have a system of two elements, one vector-valued and one scalar, very much like with the[2.x.54] . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely **[1.x.44] *It must be pointed out, that this element is different from **[1.x.45] *While the constructor call is very similar to[2.x.55], the result actually resembles more[2.x.56] in that this element produces[2.x.57] independent components. A more detailed comparison of the resulting FESystem objects is below. *[1.x.46] *FESystem has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table:&lt; table border=&quot;1&quot;&gt;&lt; tr &gt;&lt; th &gt;System Element&lt;/th &gt;[2.x.58][2.x.59][2.x.60]&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.61]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.62]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.63]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.64]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.65]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt;/table &gt; *From this table, it is clear that the FESystem reflects a lot of the structure of the system of differential equations in the cases of the[2.x.66] and the[2.x.67], in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. *At this point, it is important to note that nesting of two FESystem object can give the whole FESystem a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so. *[2.x.68] VVAssembling[1.x.47] The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with[2.x.69] . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. *The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. *[1.x.48] This is essentially how[2.x.70] does it:**[1.x.49] **So here 's what is happening:[2.x.71][2.x.72] The first thing we do is to declare &quot;extractors&quot;(see the FEValuesExtractors namespace). These are objects that don 't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1(i.e. what we call a &quot;physical vector&quot;, always consisting of[2.x.73] components). Here, we declare an object that represents the velocities consisting of[2.x.74] components starting at component zero, and the extractor for the pressure, which is a scalar component at position[2.x.75] . *[2.x.76] We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form(i.e. neglecting boundary terms) looked as follows, based on shape functions[2.x.77] :[1.x.50] *whereas the implementation looked like this:*[1.x.51] *The similarities are pretty obvious. *[2.x.78] Essentially, what happens in above code is this:when you do[2.x.79], a so-called &quot;view&quot; is created, i.e. an object that unlike the full FEValues object represents not all components of a finite element, but only the one(s) represented by the extractor object[2.x.80] or[2.x.81] . *[2.x.82] These views can then be asked for information about these individual components. For example, when you write[2.x.83] you get the value of the pressure component of the[2.x.84] th shape function[2.x.85] at the[2.x.86] th quadrature point. Because the extractor[2.x.87] represents a scalar component, the results of the operator[2.x.88] is a scalar number. On the other hand, the call[2.x.89] would produce the value of a whole set of[2.x.90] components, which would be of type[2.x.91] . *[2.x.92] Other things that can be done with views is to ask for the gradient of a particular shape function 's components described by an extractor. For example,[2.x.93] would represent the gradient of the scalar pressure component, which is of type[2.x.94], whereas the gradient of the velocities components,[2.x.95] is a[2.x.96], i.e. a matrix[2.x.97] that consists of entries[2.x.98] . Finally, both scalar and vector views can be asked for the second derivatives(&quot;Hessians&quot;) and vector views can be asked for the symmetric gradient, defined as[2.x.99] as well as the divergence[2.x.100] .[2.x.101] Other examples of using extractors and views are shown in tutorial programs[2.x.102],[2.x.103],[2.x.104] and several other programs. ***[2.x.105] In the current context, when we talk about a vector(for example in extracting the velocity components above), we mean the word in the sense physics uses it:it has[2.x.106] components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word &quot;vector&quot;(and how we use this word in other contexts in the library, for example in the Vector class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame x</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00090">vector_valued_0.txt:90</a></div></div>
<div class="ttc" id="aadvection__0_8txt_html_a79a3cbbb7583dd309bf1b14dc20895b6"><div class="ttname"><a href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a></div><div class="ttdeci">**its DG formulations All advection operators depend on an advection velocity denoted by[1.x.0] in the formulas below It is denoted as&lt; tt &gt; velocity&lt;/tt &gt; in the parameter lists The functions cell_matrix() and both upwind_value_matrix() are taking the equation in weak form</div></div>
<div class="ttc" id="aclassAffineConstraints_html_a2c9d71b5b7e8851c25a411ccf34de986"><div class="ttname"><a href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">AffineConstraints::reinit</a></div><div class="ttdeci">void reinit(const IndexSet &amp;local_constraints=IndexSet())</div></div>
<div class="ttc" id="aq__collection__0_8txt_html_a98a6b91a750cdd7301bb66162fa71e80"><div class="ttname"><a href="q__collection__0_8txt.html#a98a6b91a750cdd7301bb66162fa71e80">push_back</a></div><div class="ttdeci">they need not even be of the same size in this case The same arguments about the order of elements of collections by the also be made about the elements of[2.x.13] objects This class creates a copy of the given quadrature object i e you can do things like&lt; tt &gt; push_back(QGauss&lt; dim &gt;(3))</div></div>
<div class="ttc" id="aA-headers_2fe__0_8txt_html_ac58f1344c78bfcb3556c763b59c923c6"><div class="ttname"><a href="A-headers_2fe__0_8txt.html#ac58f1344c78bfcb3556c763b59c923c6">The</a></div><div class="ttdeci">****All classes related to shape functions and to access to shape functions This concerns the actual values of finite elements For the numbering of degrees of freedom refer to the module on *[2.x.1] The classes and functions of this module fall into several sub groups that are discussed in their respective sub modules listed above In the FETools class provides functions that provide information on finite elements transformations between elements etc *In the grand scheme of the pieces of this module interact with a variety of other parts of the without actually implementing a concrete element For the FiniteElement base class declares the virtual functions a derived class has to implement if it wants to describe a finite element space Likewise the FiniteElementData holds variables that describe certain values characterizing a finite element such as the number of degrees of freedom per vertex line or face *On the other classes like FE_Poly and FE_PolyTensor are higher abstractions They describe finite elements that are built atop polynomial descriptions of the shape functions on the unit cell Classes derived from them then only have to provide a description of the particular polynomial from which a finite element is built For the FE_Q class that implements the usual Lagrange elements uses the FE_Poly base class to generate a finite element by providing it with a set of Lagrange interpolation polynomials corresponding to an equidistant subdivision of interpolation points the FESystem class is used for vector valued problems There one may want to couple a number of for Navier Stokes one may want to use three Q1 elements for the three components of the and a piecewise constant Q0 element for the pressure The FESystem class can be used to couple these four base elements together into a single vector valued element with vector components The[2.x.3]</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2fe__0_8txt_source.html#l00021">fe_0.txt:21</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="arelaxation__block__0_8txt_html_a2076fd56276055e74e230fad6edac013"><div class="ttname"><a href="relaxation__block__0_8txt.html#a2076fd56276055e74e230fad6edac013">AdditionalData</a></div><div class="ttdeci">*Base class for the implementation of overlapping multiplicative Schwarz relaxation methods and smoothers *This class uses the infrastructure provided by PreconditionBlockBase It adds functions to initialize with a block list and to do the relaxation step The actual relaxation method with the interface expected by SolverRelaxation and MGSmootherRelaxation is in the derived classes *This class allows for more general relaxation methods than PreconditionBlock since the index sets may be arbitrary and overlapping while there only contiguous disjoint sets of equal size are allowed As a drawback this class cannot be used as a preconditioner since its implementation relies on a straight forward implementation of the Gauss Seidel process *Parallel computations require you to specify an initialized ghost vector in *[2.x.0] *****Define number type of matrix **Value type for inverse matrices **Declare type for container size **Parameters for block relaxation methods In addition to typical control parameters like **Constructor **The mapping from indices to blocks Each row of this pattern enumerates the indices constituting a diagonal block to be inverted **Relaxation parameter **Invert diagonal during initialization diagonal blocks are inverted on the whenever they are used While inverting blocks in advance requires more it usually saves a lot of computation See **Assume all diagonal blocks are equal to save memory If this flag is then only the first diagonal block of the matrix is inverted and stored It is then used for all other blocks note Avoid setting this true if your blocks are not in particular if their sizes differ **Choose the inversion method for the blocks **If **If **The order in which blocks should be traversed This vector can initiate several modes of then the relaxation method will be executed from first to last block[2.x.6][2.x.7] If the length is then the inner vector must have the same size as the number of blocks The relaxation method is applied in the order given in this vector[2.x.8][2.x.9] If the outer vector has length greater then the relaxation method is applied several each time in the order given by the inner vector of the corresponding index This mode can for instance be used for ADI methods and similar direction sweeps *[2.x.10][2.x.11] *Temporary ghost vector that is used in the relaxation method when performing parallel MPI computations The user is required to have this point to an initialized vector that contains all indices that appear in the[2.x.12] sa ghost values this the set of locally active level DoFs Unused when VectorType is a serial vector type like Vector&lt; double &gt; **Return the memory allocated in this object **Initialize matrix and additional information In a second the inverses of the diagonal blocks may be computed Note that AdditionalData</div><div class="ttdef"><b>Definition:</b> <a href="relaxation__block__0_8txt_source.html#l00043">relaxation_block_0.txt:43</a></div></div>
<div class="ttc" id="anamespaceEuler__DG_html_ae1cc4c5ec49b9998f5dc924707c29ed4"><div class="ttname"><a href="namespaceEuler__DG.html#ae1cc4c5ec49b9998f5dc924707c29ed4">Euler_DG::final_time</a></div><div class="ttdeci">constexpr double final_time</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00067">step-67.cc:67</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_a03a2f48682e29e39f7bccc11a7d1c4d1"><div class="ttname"><a href="polynomial__space__0_8txt.html#a03a2f48682e29e39f7bccc11a7d1c4d1">degree</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has degree[1.x.4]</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00003">polynomial_space_0.txt:3</a></div></div>
<div class="ttc" id="abase_2quadrature__lib_8h_html"><div class="ttname"><a href="base_2quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a4874d3f2becad91b2bdda53a5539ff54"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a></div><div class="ttdeci">pow(2x+1, y)` and computing the derivatives `diff(f, x)` and `diff(f, y)`. At this point there is no assumption of what `x` and `y` represent f</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a96ecfde131843f52ee49d0e0c1180134"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications in impossible to get right Higher derivatives are even more impossible to do without computer aid Automatic or symbolic differentiation is a way out of and gets compile time</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="agrid_2manifold__lib_8h_html"><div class="ttname"><a href="grid_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
<div class="ttc" id="acell__weights__0_8txt_html_aa2b27042ab4d10b014332d2edd6cd466"><div class="ttname"><a href="cell__weights__0_8txt.html#aa2b27042ab4d10b014332d2edd6cd466">coarsening</a></div><div class="ttdeci">*Anytime a[2.x.0] is either upon request or by refinement coarsening</div><div class="ttdef"><b>Definition:</b> <a href="cell__weights__0_8txt_source.html#l00002">cell_weights_0.txt:2</a></div></div>
<div class="ttc" id="afunction__time__0_8txt_html_aec9d63e7b1c02618470be701525a5211"><div class="ttname"><a href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">sin</a></div><div class="ttdeci">*Support for time dependent functions The library was also designed for time dependent problems For this the function objects also contain a field which stores the as well as functions manipulating them Time independent problems should not access or even abuse them for other but since one normally does not create thousands of function the gain in generality weighs out the fact that we need not store the time value for not time dependent problems The second advantage is that the derived standard classes like&lt; tt &gt;&lt; tt &gt; ConstantFunction&lt;/tt &gt; etc also work for time dependent problems *Access to the time goes through the following so that derived classes can perform computations which need only be done once for every new time For if a time dependent function had a factor&lt; tt &gt; sin(t)&lt;/tt &gt;</div></div>
<div class="ttc" id="aclassLogStream_html_a8028e970ad8388596d625ed463894e98"><div class="ttname"><a href="classLogStream.html#a8028e970ad8388596d625ed463894e98">LogStream::depth_console</a></div><div class="ttdeci">unsigned int depth_console(const unsigned int n)</div><div class="ttdef"><b>Definition:</b> <a href="logstream_8cc_source.html#l00350">logstream.cc:350</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a533c4778cbc9bcbed365dcab42ca4418"><div class="ttname"><a href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a></div><div class="ttdeci">void hyper_ball(Triangulation&lt; dim &gt; &amp;tria, const Point&lt; dim &gt; &amp;center=Point&lt; dim &gt;(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)</div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_a8f384576a64c89a6fa8352847523e340"><div class="ttname"><a href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for n_q_points</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00537">fe_evaluation_0.txt:537</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga31978c026b8b6b5116df30b8e748f6b7"><div class="ttname"><a href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">StandardExceptions::ExcInternalError</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcInternalError()</div></div>
<div class="ttc" id="aclassDataOutInterface_html_a5df488dad82b811ceb08cb1adf9eafcd"><div class="ttname"><a href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface&lt; patch_dim, patch_spacedim &gt;::write_vtu_in_parallel</a></div><div class="ttdeci">void write_vtu_in_parallel(const std::string &amp;filename, const MPI_Comm &amp;comm) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07254">data_out_base.cc:7254</a></div></div>
<div class="ttc" id="adistributed_2tria_8h_html"><div class="ttname"><a href="distributed_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a7b3d3f295bb56d6cd6856bdc6cbe8a01"><div class="ttname"><a href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a></div><div class="ttdeci">void distribute(VectorType &amp;vec) const</div></div>
<div class="ttc" id="adofs_2dof__renumbering_8h_html"><div class="ttname"><a href="dofs_2dof__renumbering_8h.html">dof_renumbering.h</a></div></div>
<div class="ttc" id="afunction__time__0_8txt_html_a1ee09a9dd26d8e6c3685fe170eb40343"><div class="ttname"><a href="function__time__0_8txt.html#a1ee09a9dd26d8e6c3685fe170eb40343">set_time</a></div><div class="ttdeci">*Support for time dependent functions The library was also designed for time dependent problems For this the function objects also contain a field which stores the as well as functions manipulating them Time independent problems should not access or even abuse them for other but since one normally does not create thousands of function the gain in generality weighs out the fact that we need not store the time value for not time dependent problems The second advantage is that the derived standard classes like&lt; tt &gt;&lt; tt &gt; ConstantFunction&lt;/tt &gt; etc also work for time dependent problems *Access to the time goes through the following so that derived classes can perform computations which need only be done once for every new time For if a time dependent function had a factor&lt; tt &gt; then it may be a reasonable choice to calculate this factor in a derived version of set_time()</div></div>
<div class="ttc" id="adistributed_2solution__transfer_8h_html"><div class="ttname"><a href="distributed_2solution__transfer_8h.html">solution_transfer.h</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00124">fe_update_flags.h:124</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01581">exceptions.h:1581</a></div></div>
<div class="ttc" id="aclassParticles_1_1DataOut_html"><div class="ttname"><a href="classParticles_1_1DataOut.html">Particles::DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="particles_2data__out_8h_source.html#l00044">data_out.h:44</a></div></div>
<div class="ttc" id="abase_2conditional__ostream_8h_html"><div class="ttname"><a href="base_2conditional__ostream_8h.html">conditional_ostream.h</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a47c293eff2ec7ce4b90ba08b35d1f2e2"><div class="ttname"><a href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a></div><div class="ttdeci">double minimal_cell_diameter(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l04309">grid_tools.cc:4309</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_a895dcd8223a0ee6f0e6a80b80e2d5982"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a></div><div class="ttdeci">unsigned int this_mpi_process(const MPI_Comm &amp;mpi_communicator)</div><div class="ttdef"><b>Definition:</b> <a href="mpi_8cc_source.html#l00128">mpi.cc:128</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a680d8b0d6d9162296d224196cfd47028"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a></div><div class="ttdeci">and situations where one is given a parameter dependent problem[2.x.4] and wants to form derivatives with regards to the parameters[2.x.5]</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00010">automatic_and_symbolic_differentiation_0.txt:10</a></div></div>
<div class="ttc" id="alac_2full__matrix_8h_html"><div class="ttname"><a href="lac_2full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="alac_2solver__cg_8h_html"><div class="ttname"><a href="lac_2solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a7b1ab7a5dcacc31df12a0592293133c0"><div class="ttname"><a href="coding__conventions__0_8txt.html#a7b1ab7a5dcacc31df12a0592293133c0">as</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per the child indices of the child cells adjacent to rather than writing them into the code directly as[2.x.35]</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="alac_2petsc__precondition_8h_html"><div class="ttname"><a href="lac_2petsc__precondition_8h.html">petsc_precondition.h</a></div></div>
<div class="ttc" id="alac_2petsc__sparse__matrix_8h_html"><div class="ttname"><a href="lac_2petsc__sparse__matrix_8h.html">petsc_sparse_matrix.h</a></div></div>
<div class="ttc" id="aupdate__flags__0_8txt_html_a401b2012c153de7bc4c63a89c334e118"><div class="ttname"><a href="update__flags__0_8txt.html#a401b2012c153de7bc4c63a89c334e118">side</a></div><div class="ttdeci">*****In order to compute contributions of an individual cell to the global matrix and right hand side</div><div class="ttdef"><b>Definition:</b> <a href="update__flags__0_8txt_source.html#l00007">update_flags_0.txt:7</a></div></div>
<div class="ttc" id="afe__q__0_8txt_html_a1a8eaafa20c4d8c9ab128b62a984738c"><div class="ttname"><a href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a></div><div class="ttdeci">*Implementation of a scalar Lagrange finite element[2.x.0] that yields the finite element space of piecewise polynomials of degree[2.x.1] in each coordinate direction This class is realized using tensor product polynomials based on D Lagrange polynomials with Gauss or given support points *The standard constructor of this class takes the degree[2.x.2] of this finite element it can take a quadrature formula[2.x.3] defining the support points of the Lagrange interpolation in one coordinate direction *For more information about the&lt; tt &gt; spacedim&lt;/tt &gt; template parameter check the documentation of FiniteElement or the one of Triangulation **The constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.4] polynomials of degree[2.x.5] This[2.x.6] object provides all values and derivatives of the shape functions In case a quadrature rule is the constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.7] polynomials with the support points from *[2.x.8] Furthermore the constructor fills the[2.x.9] the[2.x.10] equidistant support points at i where one polynomial is one and all the others are zero For higher polynomial degrees</div><div class="ttdef"><b>Definition:</b> <a href="fe__q__0_8txt_source.html#l00009">fe_q_0.txt:9</a></div></div>
<div class="ttc" id="afe__nedelec__0_8txt_html_a8b7c0468fae3de73000ffc4dfafc048a"><div class="ttname"><a href="fe__nedelec__0_8txt.html#a8b7c0468fae3de73000ffc4dfafc048a">but</a></div><div class="ttdeci">lec element is constructed in such a way ii the shape functions are but(iii) the tangential component(s) of the vector field represented by each shape function are continuous across the faces of cells. *Other properties of the N &amp;eacute</div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="aparticles_2particle__handler_8h_html"><div class="ttname"><a href="particles_2particle__handler_8h.html">particle_handler.h</a></div></div>
<div class="ttc" id="aclassGridIn_html"><div class="ttname"><a href="classGridIn.html">GridIn</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__in_8h_source.html#l00248">grid_in.h:248</a></div></div>
<div class="ttc" id="agrid_2grid__refinement__0_8txt_html_a25a49aa21a8c8032ab50bb5e8087a5d7"><div class="ttname"><a href="grid_2grid__refinement__0_8txt.html#a25a49aa21a8c8032ab50bb5e8087a5d7">strategy</a></div><div class="ttdeci">and W R the function uses the observation that the error behaves like[2.x.65] with some constant[2.x.66] that depends on the dimension and the finite element degree It should **given optimal mesh refinement **not depend so much on the regularity of the as it is based on the that all singularities can be resolved by refinement Mesh refinement is then based on the idea that we want to make[2.x.67] small This corresponds to the functional[2.x.68] above *This function was originally implemented by Thomas Richter It follows a strategy described in T Parallel Multigrid Method for Adaptive Finite Elements with Application to Flow PhD University of See in particular pp **Mark all mesh cells for which the value in[2.x.70] exceeds[2.x.71] threshold for but only flag up to[2.x.72] cells The vector[2.x.73] contains a nonnegative value for each active ordered in the canonical order of[2.x.74] The cells are only flagged for they are not actually refined To do you have to call[2.x.75] This function does not implement a refinement strategy</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement__0_8txt_source.html#l00031">grid_refinement_0.txt:31</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6365596c7d2490c474cd0b7ce9722b37"><div class="ttname"><a href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a></div><div class="ttdeci">it does so for both DoFHandler and[2.x.14] objects Note that the DoFAccessor class is derived from either TriaAccessor or the DoFAccessor class comes in two flavors one accessing degrees of freedom on the level of a cell and the other accessing the active dofs of an active cell **The DoFCellAccessor class has the same purpose and relation to DoFCellAccessor as the CellAccessor has to TriaAccessor *Except to look up member you will not usually have to deal withthe actual class names listed above Rather one uses the typedefs provided bythe mesh classes Triangulation DoFHandler and[2.x.15] as wellas the function that generate such buta hexahedron there are corresponding types and calls like[2.x.34] that act on thedimension independent geometric objects and hex These calls</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00076">iterators_0.txt:76</a></div></div>
<div class="ttc" id="acuda__matrix__free__0_8txt_html_a747ffbda88fa48702c72f4b04f9c5721"><div class="ttname"><a href="cuda__matrix__free__0_8txt.html#a747ffbda88fa48702c72f4b04f9c5721">JxW</a></div><div class="ttdeci">*This class collects all the data that is stored for the matrix free implementation The storage scheme is tailored towards several loops performed with the same data i e typically doing many matrix vector products or residual computations on the same mesh This class does not implement any operations involving finite element basis functions i e regarding the operation performed on the cells For these operations the class FEEvaluation is designed to use the data collected in this class This class implements a loop over all which implies that it is possible to write to vectors in parallel without having to explicitly synchronize access to these vectors and matrices This class does not implement any shape values all it does is to cache the respective data To implement finite element operations use the class[2.x.0] This class traverse the cells in a different order than the usual Triangulation class in deal II *Only float and double are supported ***Parallelization scheme parallelization over degrees of freedom or over cells **This flag is used to determine which quantities should be cached This class can cache data needed for gradient Jacobian quadrature points as well as data for only data for gradients and Jacobian determinants times quadrature JxW</div><div class="ttdef"><b>Definition:</b> <a href="cuda__matrix__free__0_8txt_source.html#l00014">cuda_matrix_free_0.txt:14</a></div></div>
<div class="ttc" id="aclassConditionalOStream_html"><div class="ttname"><a href="classConditionalOStream.html">ConditionalOStream</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2conditional__ostream_8h_source.html#l00083">conditional_ostream.h:83</a></div></div>
<div class="ttc" id="anamespaceSparsityTools_html_afbc0c7a206ced91b154666215ea3c218"><div class="ttname"><a href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a></div><div class="ttdeci">void distribute_sparsity_pattern(DynamicSparsityPattern &amp;dsp, const IndexSet &amp;locally_owned_rows, const MPI_Comm &amp;mpi_comm, const IndexSet &amp;locally_relevant_rows)</div><div class="ttdef"><b>Definition:</b> <a href="sparsity__tools_8cc_source.html#l01045">sparsity_tools.cc:1045</a></div></div>
<div class="ttc" id="aclassParticles_1_1ParticleHandler_html"><div class="ttname"><a href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="particles_2data__out_8h_source.html#l00032">data_out.h:32</a></div></div>
<div class="ttc" id="astep-69_8cc_html_a66a64d07b4db87c87b639bdcf7b18c82"><div class="ttname"><a href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; local_dof_indices</div><div class="ttdef"><b>Definition:</b> <a href="step-69_8cc_source.html#l00534">step-69.cc:534</a></div></div>
<div class="ttc" id="ala__vector__0_8txt_html_a89d012f842e841940822e70887770169"><div class="ttname"><a href="la__vector__0_8txt.html#a89d012f842e841940822e70887770169">Trilinos</a></div><div class="ttdeci">namespace contains various classes that provide wrappers to vector classes from different external libraries like Trilinos(EPetra) or PETSc and native implementations like[2.x.0] *The different vector classes are derived from VectorSpaceVector to provide a joint interface for vector space operations</div></div>
<div class="ttc" id="alac_2vector_8h_html"><div class="ttname"><a href="lac_2vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a177c697348e3052c514824563807ea3b"><div class="ttname"><a href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div><div class="ttdeci">**Throughout deal we strive to keep our programming style and the kind ofinterfaces we provide as consistent as possible To this end</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00003">coding_conventions_0.txt:3</a></div></div>
<div class="ttc" id="aquadrature__point__data__0_8txt_html_a35c4177ef651238576ebc1395f9e116e"><div class="ttname"><a href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a></div><div class="ttdeci">i a property that varies discontinuously within a solid In such trying to transfer data from the quadrature points to a finite element field that is once evaluated at a different set of quadrature the quadrature rule[2.x.94] used to integrate its mass matrix and finally the quadrature rule[2.x.95] which is used to store[2.x.96][2.x.97][2.x.98] has to be scalar valued *Since this class does projection on cell by cell basis[2.x.100] is only required to be continuous within the cell **Prepare for coarsening and refinement of a triangulation[2.x.101][2.x.102] represents the cell data which should be transferred and it should be initialized for each locally owned active cell *Although CellDataStorage class allows storing on different cells different objects derived from the base class here we assume that[2.x.104] contains objects of the same more specifically they pack unpack the same data **Interpolate the data previously stored in this object before the mesh was refined or coarsened onto the quadrature points of the currently active set of cells *Before calling this function the user is expected to populate the data stored in the[2.x.106] object provided to an exception will be thrown in debug mode **A callback function used to pack the data on the current mesh into objects that can later be retrieved after refinement</div><div class="ttdef"><b>Definition:</b> <a href="quadrature__point__data__0_8txt_source.html#l00085">quadrature_point_data_0.txt:85</a></div></div>
<div class="ttc" id="anamespaceStep70_html"><div class="ttname"><a href="namespaceStep70.html">Step70</a></div><div class="ttdef"><b>Definition:</b> <a href="step-70_8cc_source.html#l00104">step-70.cc:104</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; spacedim &gt;</a></div></div>
<div class="ttc" id="aclassOpenCASCADE_1_1ArclengthProjectionLineManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00292">manifold_lib.h:292</a></div></div>
<div class="ttc" id="anamespaceParticles_1_1Utilities_html_a054f60295f7694c31a30b0019d94df73"><div class="ttname"><a href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a></div><div class="ttdeci">void interpolate_field_on_particles(const DoFHandler&lt; dim, spacedim &gt; &amp;field_dh, const Particles::ParticleHandler&lt; dim, spacedim &gt; &amp;particle_handler, const InputVectorType &amp;field_vector, OutputVectorType &amp;interpolated_field, const ComponentMask &amp;field_comps=ComponentMask())</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2particles_2utilities_8h_source.html#l00165">utilities.h:165</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ZeroFunction_html"><div class="ttname"><a href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00516">function.h:516</a></div></div>
<div class="ttc" id="atimer__0_8txt_html_a48e9e3a8116df3cc4b62db810904e91f"><div class="ttname"><a href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a></div><div class="ttdeci">*A compatible with the[2.x.0] notion of a whose by in multiples of of a second and POSIX uses so go with microseconds for uniformity **Signed integral type used to store the value returned by this requires platform specific so this function returns on platforms that are neither Windows nor POSIX **The Timer class provides a way to measure both the amount of wall or[2.x.1] as well as the total time elapsed over all laps Here is an you can also restart the timer instead of resetting it The times between successive calls to start() and stop()(i.e.</div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6e6ddb523c3838fca58a8e556843d8d3"><div class="ttname"><a href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a></div><div class="ttdeci">after this come the grandchildren of the coarse and so on it must be noted that programs should not rely on this particularorder of traversing a tree</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00022">iterators_0.txt:22</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_a3e3e0df474c0e4f9abb627753c8754e9"><div class="ttname"><a href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a></div><div class="ttdeci">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt; count_elements(const TopoDS_Shape &amp;shape)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00088">utilities.cc:88</a></div></div>
<div class="ttc" id="aclassParameterHandler_html"><div class="ttname"><a href="classParameterHandler.html">ParameterHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__handler_8h_source.html#l00820">parameter_handler.h:820</a></div></div>
<div class="ttc" id="atable__handler__0_8txt_html_a61e9964f9093088848525ca172895749"><div class="ttname"><a href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a></div><div class="ttdeci">the ConvergenceTable class does something like this *To support both the TableHandler class has a property called[1.x.4] By auto fill mode is but it can be enabled by calling set_auto_fill_mode(). If auto-fill mode is enabled we use the following algorithm call it *[2.x.18] ***If[2.x.19] then we add[2.x.20] copies of the object[2.x.21] to this column is the data type of the given[2.x.23] is a numeric then[2.x.24] is[2.x.25] is the empty string *[2.x.26] ***Add the given value to this column *Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column In other if we have skipped previous invocations of then the padding will enter default values into this column *The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step</div><div class="ttdef"><b>Definition:</b> <a href="table__handler__0_8txt_source.html#l00070">table_handler_0.txt:70</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_acce0a318676405d57af6ef0f5cbe4ec3"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#acce0a318676405d57af6ef0f5cbe4ec3">and</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications and</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_acad7e0841b9046eaafddc4c617ab1d9d"><div class="ttname"><a href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a></div><div class="ttdeci">void extract_locally_relevant_dofs(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, IndexSet &amp;dof_set)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l01133">dof_tools.cc:1133</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="alac_2generic__linear__algebra_8h_html"><div class="ttname"><a href="lac_2generic__linear__algebra_8h.html">generic_linear_algebra.h</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a1e6c4dcc63863449f08a78a22ec73747"><div class="ttname"><a href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a></div><div class="ttdeci">void generate_from_name_and_arguments(Triangulation&lt; dim, spacedim &gt; &amp;tria, const std::string &amp;grid_generator_function_name, const std::string &amp;grid_generator_function_arguments)</div><div class="ttdef"><b>Definition:</b> <a href="grid__generator__from__name_8cc_source.html#l00327">grid_generator_from_name.cc:327</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ad83f9d9d8b603ed71c3483de199bc7a7"><div class="ttname"><a href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled in</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00013">coding_conventions_0.txt:13</a></div></div>
<div class="ttc" id="aopencascade_2utilities__0_8txt_html_a23b9c1bdc9420a32a79f19f214a53812"><div class="ttname"><a href="opencascade_2utilities__0_8txt.html#a23b9c1bdc9420a32a79f19f214a53812">created</a></div><div class="ttdeci">namespace all utilities which operate on OpenCASCADE entities OpenCASCADE splits every object into a topological description and a geometrical entity The basic topological description is a TopoDS_Shape TopoDS_Shapes are light objects and can be copied around The closest deal II analog is a TriaIterator *The OpenCASCADE topology is designed with reference to the STEP standard ISO The structure is an oriented one way where parents refer to their and there are no back references Abstract structure is implemented as C classes from the TopoDS package A TopoDS_Shape is manipulated by value and contains orientation and a myTShape myTShape and Location are used to share data between various shapes to save memory For an edge belonging to two faces has equal Locations and myTShape fields but different etc *Once a topological description is if a concrete geometrical object can be created</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities__0_8txt_source.html#l00005">utilities_0.txt:5</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00140">function.h:140</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1SolutionTransfer_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2solution__transfer_8h_source.html#l00206">solution_transfer.h:206</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00052">solver_control.h:52</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ad086eb08b8424fd7c853e389a3978a9a"><div class="ttname"><a href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a></div><div class="ttdeci">VectorType::value_type compute_mean_value(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim &gt; &amp;quadrature, const VectorType &amp;v, const unsigned int component)</div></div>
<div class="ttc" id="abase_2bounding__box__0_8txt_html_a448658829353774b234a6819182c72db"><div class="ttname"><a href="base_2bounding__box__0_8txt.html#a448658829353774b234a6819182c72db">spacedim</a></div><div class="ttdeci">*The enumerator NeighborType describes the neighboring relation between two bounding boxes ***Not in this means that the two boxes touch at one corner of the each box **Attached in this means that the two boxes touch along an edge **Mergeable e g **or one is inside the other **A class that represents a box of arbitrary dimension&lt; tt &gt; spacedim&lt;/tt &gt; and with sides parallel to the coordinate axes that is a region a bounding box is top right for useful in parallel distributed meshes to give a general description of the owners of each portion of the mesh *Taking the cross section of a BoundingBox&lt; spacedim &gt; orthogonal to a given direction gives a box in one dimension the coordinates of the cross section of BoundingBox&lt; 3 &gt; can be ordered in different ways That if we take the cross section orthogonal to the y direction we could either order a coordinate into a coordinate as[2.x.1] or as[2.x.2] This class uses the second convention corresponding to the coordinates being ordered cyclicly[2.x.3] To be if we take a cross z y *This is according to the convention set by the function *[2.x.4] **Standard constructor Creates an object that corresponds to an empty i e a degenerate box with both points being the origin **Standard constructor for non empty Number elements **Return a reference to the boundary_points **Return const a reference to the boundary_points **Test for equality **Test for inequality **Check if the current object and[2.x.5] are i e if the boxes have dimension spacedim</div><div class="ttdef"><b>Definition:</b> <a href="base_2bounding__box__0_8txt_source.html#l00070">bounding_box_0.txt:70</a></div></div>
<div class="ttc" id="abase_2partitioner__0_8txt_html_a6d2d0fa485d1660823c59c494fb0fb31"><div class="ttname"><a href="base_2partitioner__0_8txt.html#a6d2d0fa485d1660823c59c494fb0fb31">MPI</a></div><div class="ttdeci">*This class defines a model for the partitioning of a it includes a structure for the point to point communication patterns It allows the inclusion of ghost it also stores the other processors ghost indices belonging to the current which are the indices where other processors might require information from In a these import indices form the dual of the ghost indices This information is gathered once when constructing the which obviates subsequent global communication steps when exchanging data The figure below gives an example of index space[2.x.2] being split into four parts that are each owned by one MPI the next four lines indicate which elements of the overall array each processor wants to know about **this is generally a superset of the locally owned with the difference being what are called ghost elements To understand the remaining pieces of the remember that in MPI</div><div class="ttdef"><b>Definition:</b> <a href="base_2partitioner__0_8txt_source.html#l00004">partitioner_0.txt:4</a></div></div>
<div class="ttc" id="atable__0_8txt_html_ac37423c4af9ffbf59d47e318ce8b04eb"><div class="ttname"><a href="table__0_8txt.html#ac37423c4af9ffbf59d47e318ce8b04eb">extension</a></div><div class="ttdeci">examples are data tables that are loaded at start up time and then used over the course of the run time of the program In such the start up cost of running this function can be amortized over and the potential memory savings from not having to store the table on each process may be substantial on machines with large core counts on which many MPI processes run on the same machine *This function only makes sense if the data type T is self i all of its information is stored in its member and if none of the member variables are pointers to other parts of the memory This is because if a type T does have pointers to other parts of then moving T into a shared memory space does not result in the other processes having access to data that the object points to with its member variable and are typically in memory areas not accessible to the other processes As a the usual use case for this function is to share arrays of simple objects such as double s or int s *After calling this objects on different MPI processes share a common state That means that certain operations become i they must be called on all participating processors at the same time In you can no longer call or because they have to communicate for these operations If you do not do you will likely get a deadlock that may be difficult to debug By extension</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00135">table_0.txt:135</a></div></div>
<div class="ttc" id="aclassSolverFGMRES_html"><div class="ttname"><a href="classSolverFGMRES.html">SolverFGMRES</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__gmres_8h_source.html#l00481">solver_gmres.h:481</a></div></div>
<div class="ttc" id="aclassPatterns_1_1Selection_html"><div class="ttname"><a href="classPatterns_1_1Selection.html">Patterns::Selection</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l00400">patterns.h:400</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a01e76d6a9109d0fc42c67e122e06757e"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a01e76d6a9109d0fc42c67e122e06757e">constants</a></div><div class="ttdeci">dual numbers do not contain any higher order terms in their first while for the complex step method these existent higher order terms are neglected It can be shown that both of these methods are not subject to subtractive cancellation errors and within their finite difference they are not numerically sensitive to the internal[2.x.35] size chosen for the numerical perturbation The dual number approach thus produces exact first while the complex step approximation does not The standard implementation of the dual cannot yield exact values for second derivatives Hyper dual numbers take a different view of this with numbers being represented in a form similar to with the appropriate both first and second derivatives can be computed exactly ****With[2.x.36] taped[2.x.37] a specified subregion of code is selected as one for which all operations executed with the recorded arbitrarily high order derivatives of the function then can be computed by referring to the code path tracked and stored on the or if it is not analytic one might need to consider the case of branched where the tape is no longer but rather forks off on a different evaluation path to that due to the original recorded inputs ****Methods based on[1.x.2] leverage the computational constructed from abstract the syntax that resolves the function output from its input values The outermost leaves on the tree represent the independent variables or constants</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00068">automatic_and_symbolic_differentiation_0.txt:68</a></div></div>
<div class="ttc" id="anamespaceEuler__DG_html_a143bc64b6fa6ced9f11c148a2af3ff09"><div class="ttname"><a href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Euler_DG::Number</a></div><div class="ttdeci">double Number</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00064">step-67.cc:64</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="amg__0_8txt_html_a1dadc108ee1520717957789de4b76416"><div class="ttname"><a href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a></div><div class="ttdeci">****Classes that have to do with multigrid algorithms *The main class with implementation of the multigrid scheme is Multigrid with its function[2.x.1] It uses the abstract following classes in order to perform the multigrid cycle</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00007">mg_0.txt:7</a></div></div>
<div class="ttc" id="aclassParameterHandler_html_aa6418ea655b1b550b9dcf63513030196"><div class="ttname"><a href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set</a></div><div class="ttdeci">void set(const std::string &amp;entry_name, const std::string &amp;new_value)</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler_8cc_source.html#l01152">parameter_handler.cc:1152</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a722841395d33b29d935d673b292e1947"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a722841395d33b29d935d673b292e1947">LinearAlgebraDealII::BlockVector</a></div><div class="ttdeci">BlockVector&lt; double &gt; BlockVector</div><div class="ttdef"><b>Definition:</b> <a href="lac_2generic__linear__algebra_8h_source.html#l00052">generic_linear_algebra.h:52</a></div></div>
<div class="ttc" id="afe_2mapping__q_8h_html"><div class="ttname"><a href="fe_2mapping__q_8h.html">mapping_q.h</a></div></div>
<div class="ttc" id="agrid_2grid__in_8h_html"><div class="ttname"><a href="grid_2grid__in_8h.html">grid_in.h</a></div></div>
<div class="ttc" id="anamespaceparallel_1_1distributed_1_1GridRefinement_html_ae5159e3207f6786f0749fc0b66ab8ca3"><div class="ttname"><a href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(parallel::distributed::Triangulation&lt; dim, spacedim &gt; &amp;tria, const ::Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_error, const double bottom_fraction_of_error, const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="distributed_2grid__refinement_8cc_source.html#l00566">grid_refinement.cc:566</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aclassParameterAcceptor_html"><div class="ttname"><a href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__acceptor_8h_source.html#l00351">parameter_acceptor.h:351</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00137">data_out.h:137</a></div></div>
<div class="ttc" id="aparticle__0_8txt_html_a770ac0edb21c7955207df05e1fa5e0c5"><div class="ttname"><a href="particle__0_8txt.html#a770ac0edb21c7955207df05e1fa5e0c5">particle</a></div><div class="ttdeci">namespace that contains all classes that are related to the particle implementation in particular the fundamental Particle class ***Internal alias of cell level index pair **A class that represents a particle in a domain that is meshed by a triangulation of some kind The data this class stores is the position of the particle in the overall space the position of the particle in the reference coordinate system of the cell it is currently in an ID number that is unique among all particles and a variable number of properties The properties attached to each object of this class are stored by a PropertyPool object These properties are stored as an array of double variables that can be accessed via an ArrayView object For example if one wanted to equip each particle with a temperature and chemical composition property that is advected along with the particle(and may change from time step to time step based on some differential equation, for example)</div></div>
<div class="ttc" id="aparticle__handler__0_8txt_html_a8a14acfef214304cd74d5000acdc8fc2"><div class="ttname"><a href="particle__handler__0_8txt.html#a8a14acfef214304cd74d5000acdc8fc2">particles</a></div><div class="ttdeci">*This class manages the storage and handling of particles It provides the data structures necessary to store particles efficiently accessor functions to iterate over particles and find particles and algorithms to distribute particles in parallel domains Note that the class is designed in a similar way as the triangulation class In particular we call particles in the domain of the local process local particles and particles that belong to neighbor processes and live in the ghost cells around the locally owned domain ghost particles This class is used in *[2.x.0] **A type that can be used to iterate over all particles in the domain **A type that represents a range of particles **Default constructor **Constructor that initializes the particle handler with a given triangulation and mapping Since particles are stored in respect to their surrounding cells this information is necessary to correctly organize the particle collection This constructor is equivalent to calling the default constructor and the initialize function **Destructor **Initialize the particle handler This function does not clear the internal data it just sets the triangulation and the mapping to be used **Copy the state of particle handler[2.x.2] into the current object This will copy all particles and properties and leave this object as an identical copy of[2.x.3] Existing particles in this object are deleted Be aware that this does not copy functions that are connected to the signals of[2.x.4] nor does it connect the current object s member functions to triangulation which must be done by the caller if that is if the[2.x.5] had connected functions This function is expensive as it has to duplicate all data in[2.x.6] and insert it into this which may be a significant amount of data it can be useful to save the state of a particle collection at a certain point in time and reset this state later under certain for example if a timestep has to be undone and repeated **Clear all particle related data **Only clear particle but keep cache information about number of particles This is useful during reorganization of particle data between processes **Update all internally cached numbers Note that all functions that modify internal data structures and act on multiple particles will call this function while functions that act on single particles will not call this it is not an efficient function to use if the number of particles is large That is because to find the particles that are located in one cell costs[2.x.9] where[2.x.10] is the number of overall particles Since you will likely do this for every and assuming that the number of particles and the number of cells are roughly you end up with an[2.x.11] algorithm A better approach is to use the fact that particles are arranged in the order of the active cells they are in In other if you iterate over all particles</div><div class="ttdef"><b>Definition:</b> <a href="particle__handler__0_8txt_source.html#l00042">particle_handler_0.txt:42</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_af9f808a82e8c618e2e7a19dd08a9eae3"><div class="ttname"><a href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing or exact solutions Since closed form expressions for equations are often hard to pass along as function deal II uses the Function base class to describe these objects Essentially the interface of this base class requires derived classes to implement the ability to return the value of a function at one or a list of particular locations and function objects can then be used by algorithms like[2.x.1][2.x.2] and other functions *Some functions are needed again and and are therefore already provided in deal II This includes a function with a constant value</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00007">functions_0.txt:7</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_aaee87206b92ccb284e9c77fa5d847637"><div class="ttname"><a href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a></div><div class="ttdeci">each of these vectors has[2.x.174] elements containing the values of the[2.x.175] velocities and the one pressure at a quadrature point *We can use these values to then construct other things like residuals the construct is a bit awkward we have a[2.x.176] which always looks strange It is also inefficient because it implies dynamic memory allocation for the outer vector as well as for all the inner vectors maybe we are only interested in the velocities</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00155">vector_valued_0.txt:155</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a1611aa37f754086388ca76bcd421cce5"><div class="ttname"><a href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a></div><div class="ttdeci">void close()</div></div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01699">exceptions.h:1699</a></div></div>
<div class="ttc" id="agrid_2manifold__0_8txt_html_a02d8bd1db3a4d0b6d68a99a931ce1b83"><div class="ttname"><a href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a></div><div class="ttdeci">*We collect here some helper functions used in the Manifold&lt; dim, spacedim &gt; classes ***A[2.x.0] helper function that returns the number of default points for the structure type pointed to by the given[2.x.1] See the documentation of[2.x.2] for more information **Given a general mesh construct arrays of quadrature points and weights that contain the following then the quadrature points are the two vertices of the line This results in a point vector with two points ********If the iterator points to a then the quadrature points are the vertices and line mid points This results in a point vector with then the quadrature points are the the line mid and the face mid points This results in a points vector which computes a new point on a manifold based on a weighted average of surrounding points represented by the quadrature points and weights stored in the returned pair of vectors This function creates such an object based on the points that surround a or and weights are chosen in a way appropriate for computing the new mid point of the object pointed to An example of where this is necessary is for mesh and then a new cell point[2.x.8] iterator A mesh iterator that points to either a or hex[2.x.9] with_interpolation Whether or not to compute the quadrature weights from transfinite as discussed above[2.x.10] MeshIteratorType An iterator type that corresponds to then no periodicity is assumed in that direction Whenever a function that tries to compute averages is an exception will be thrown if one of the points which you are using for the average lies outside the periodicity box The return points are guaranteed to lie in the periodicity box plus or minus tolerance *periodicity and then calls internally the function is to allow lazy programmers to implement only the the middle point of a cell is close to true middle point of the and a projection may suffice For most simple it is possible to get reasonable results by deriving your own Manifold class from FlatManifold and write a new interface only for the project_to_manifold function You will have good approximations also with large deformations as long as in the coarsest mesh size you are trying to refine the middle point is not too far from the manifold mid point i e as long as the coarse mesh size is small enough **Compute a new set of points that interpolate between the given points[2.x.108] surrounding_points[2.x.109] is a table with as many columns as[2.x.110] surrounding_points the interpolation of the[2.x.113] according to the[2.x.114] is simply performed in Cartesian space **Project to FlatManifold This is the identity function for Euclidean spaces Note however that this function can be overloaded by derived which will then benefit from the logic behind the is tangential to the geodesic that connects two points[2.x.116] For the current we assume that the manifold is so the geodesic is the straight line between the two and we return[2.x.117] The normalization of the vector is chosen so that it fits the convention described in *[2.x.118] If you use this class as a stepping stone to build a manifold that only slightly deviates from a flat manifold by overloading the and the one at which the direction is to be evaluated[2.x.121] x2 The second point that describes the geodesic[2.x.122] A direction vector tangential to the geodesic this possibly modified by the periodicity of the domain as set in the to use the shortest connection between the points through the periodic boundary as necessary **Return the normal vector to the given face at point p taking into account that quadrilateral faces of hexahedral cells in may not be planar In those the face is assumed to have a geometry described by a bilinear and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric **Compute the normal vectors to the boundary at each vertex of the given face taking into account that quadrilateral faces of hexahedral cells in may not be planar In those the face is assumed to have a geometry described by a bilinear and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric **Return the periodicity of this Manifold **The periodicity of this Manifold Periodicity affects the way a middle point is computed It is assumed that if two points are more than half period then the distance should be computed by crossing the periodicity i the average is computed by adding a full period to the sum of the two For if along direction we have *pi then the average but since</div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__0_8txt_source.html#l00147">manifold_0.txt:147</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a4c0a7149e1927066d2fcdb356cb90f7b"><div class="ttname"><a href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a></div><div class="ttdeci">in this it often pays off to use rather than in a program *deal II does not implement scheduling tasks to threads itself For we use the[1.x.10] for which we provide simple wrappers TBB abstracts the details of how to start or stop start tasks on individual and provides interfaces that are portable across many different systems ***MTUsing *[1.x.11] the syntax to start would be something like this for the example we would like to indicate the fact that the function call should be run on a separate task by simply prefixing the call with a as it is here *Since C does not support the creation of new we have to be a bit more creative The way chosen is to introduce a function[2.x.24] that takes as arguments the function to call as well as the arguments to the call The[2.x.25] function is overloaded to accommodate starting tasks with functions that take no</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00045">multithreading_0.txt:45</a></div></div>
<div class="ttc" id="aclassLinearOperator_html"><div class="ttname"><a href="classLinearOperator.html">LinearOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2linear__operator_8h_source.html#l00188">linear_operator.h:188</a></div></div>
<div class="ttc" id="agrid_2grid__refinement__0_8txt_html_a8bdcf8330609e043ba26a394139934f2"><div class="ttname"><a href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a></div><div class="ttdeci">and W R the function uses the observation that the error behaves like[2.x.65] with some constant[2.x.66] that depends on the dimension and the finite element degree It should **given optimal mesh refinement **not depend so much on the regularity of the as it is based on the that all singularities can be resolved by refinement Mesh refinement is then based on the idea that we want to make[2.x.67] small This corresponds to the functional[2.x.68] above *This function was originally implemented by Thomas Richter It follows a strategy described in T Parallel Multigrid Method for Adaptive Finite Elements with Application to Flow PhD University of See in particular Section</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement__0_8txt_source.html#l00029">grid_refinement_0.txt:29</a></div></div>
<div class="ttc" id="aclassIndexSet_html_ad28b2e725afda38ffdef1bf61d5cadd4"><div class="ttname"><a href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">IndexSet::complete_index_set</a></div><div class="ttdeci">IndexSet complete_index_set(const IndexSet::size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="base_2index__set_8h_source.html#l01094">index_set.h:1094</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_aaf5e6d44ce4d5c7d60fe8ff73dda8d4b"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#aaf5e6d44ce4d5c7d60fe8ff73dda8d4b">properties</a></div><div class="ttdeci">****This module contains classes that are used in the exception mechanism of deal II **Exceptions are used in two different not in static assertions are typically used to check that parameters to functions satisfy certain properties</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00009">exceptions_0.txt:9</a></div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="abase_2parsed__function_8h_html"><div class="ttname"><a href="base_2parsed__function_8h.html">parsed_function.h</a></div></div>
<div class="ttc" id="agrid__0_8txt_html_abc4bc3849dde2110dfa9e18bf7ae1b8c"><div class="ttname"><a href="grid__0_8txt.html#abc4bc3849dde2110dfa9e18bf7ae1b8c">file</a></div><div class="ttdeci">triangles and tetrahedra are not supported *This collection of cells is managed by the Triangulation class and derived classes such as[2.x.1] and[2.x.2] It holds the relevant data in memory and offers interfaces to query it Most things you want to do on cells are performed in loops over all cells For this the Triangulation class offers the concept of iterators(see[2.x.3])[2.x.7] Reading from a file</div><div class="ttdef"><b>Definition:</b> <a href="grid__0_8txt_source.html#l00007">grid_0.txt:7</a></div></div>
<div class="ttc" id="anamespaceUtilities_html"><div class="ttname"><a href="namespaceUtilities.html">Utilities</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2communication__pattern__base_8h_source.html#l00030">communication_pattern_base.h:30</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_a7371618d5977d28dfe82c81fbac29c0f"><div class="ttname"><a href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">FEValuesBase&lt; dim, dim &gt;::get_JxW_values</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; get_JxW_values() const</div></div>
<div class="ttc" id="alac_2block__linear__operator_8h_html"><div class="ttname"><a href="lac_2block__linear__operator_8h.html">block_linear_operator.h</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="aparticles_2data__out_8h_html"><div class="ttname"><a href="particles_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="afunction__0_8txt_html_a931d002b61ed821e97fe70a7bf5b35f2"><div class="ttname"><a href="function__0_8txt.html#a931d002b61ed821e97fe70a7bf5b35f2">array</a></div><div class="ttdeci">it defaults to i e the first component **Return all components of a vector valued function at a given point&lt; tt &gt; values&lt;/tt &gt; shall have the right size i e **Set&lt; tt &gt; values&lt;/tt &gt; to the point values of the specified component of the function at the&lt; tt &gt; points&lt;/tt &gt; It is assumed that&lt; tt &gt; values&lt;/tt &gt; already has the right i e the same size as the&lt; tt &gt; points&lt;/tt &gt; array By this function repeatedly calls to fill the output array **Set&lt; tt &gt; values&lt;/tt &gt; to the point values of the function at the&lt; tt &gt; points&lt;/tt &gt; It is assumed that&lt; tt &gt; values&lt;/tt &gt; already has the right i e the same size as the&lt; tt &gt; points&lt;/tt &gt; array</div><div class="ttdef"><b>Definition:</b> <a href="function__0_8txt_source.html#l00054">function_0.txt:54</a></div></div>
<div class="ttc" id="agrid_2grid__generator_8h_html"><div class="ttname"><a href="grid_2grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="alac_2petsc__vector_8h_html"><div class="ttname"><a href="lac_2petsc__vector_8h.html">petsc_vector.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2opencascade_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2opencascade_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="atable__0_8txt_html_aa889bb34debce4db8c9ace2f875bdf0d"><div class="ttname"><a href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a></div><div class="ttdeci">tables that store three or more dimensional then there is nothing you can do about the size of these if your program is parallelized via then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file This is inefficient from two the data stored on every process is the and while every process needs to be able to read from a it is not necessary that every process stores its own either by re creating a copy of the table in the other processes memory space if by creating copies in shared memory once for all processes located on each of the machines used by the MPI job ******Integer type used to count the number of elements in this container **Default constructor Set all dimensions to zero **Constructor Initialize the array with the given dimensions in each index component **Constructor Initialize the array with the given dimensions in each index component</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00083">table_0.txt:83</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga8364dda711b93753c6809eefe2a8e827a2713a592c467d1b282bdde44c65f6111"><div class="ttname"><a href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a2713a592c467d1b282bdde44c65f6111">ParameterHandler::Short</a></div><div class="ttdeci">@ Short</div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__handler_8h_source.html#l00859">parameter_handler.h:859</a></div></div>
<div class="ttc" id="aclassUtilities_1_1MPI_1_1MPI__InitFinalize_html"><div class="ttname"><a href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2mpi_8h_source.html#l00836">mpi.h:836</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a887b88f558acbcf4a6621eb0f0d39772"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a887b88f558acbcf4a6621eb0f0d39772">violated</a></div><div class="ttdeci">****This module contains classes that are used in the exception mechanism of deal II **Exceptions are used in two different not in static assertions are typically used to check that parameters to functions satisfy certain that internal data structures are and similar assertions For static assertions are used to make sure that two vectors that are added together have the same number of components **everything else would not make any sense anyway *Such checks are performed by the[2.x.3] macro in several thousand places within the library several tutorial programs starting with[2.x.4] show how to do this *If static a assertion is violated</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00013">exceptions_0.txt:13</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_ae82f75876b5982cfa4334737e5439c39"><div class="ttname"><a href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">AffineConstraints::set_zero</a></div><div class="ttdeci">void set_zero(VectorType &amp;vec) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02093">affine_constraints.h:2093</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a02f5aa616d7b0799c538fe77d6c6c795"><div class="ttname"><a href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a></div><div class="ttdeci">i e</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00028">coding_conventions_0.txt:28</a></div></div>
<div class="ttc" id="aclassPatterns_1_1Integer_html"><div class="ttname"><a href="classPatterns_1_1Integer.html">Patterns::Integer</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l00198">patterns.h:198</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
