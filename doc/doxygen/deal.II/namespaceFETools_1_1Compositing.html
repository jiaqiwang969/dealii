<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceFETools_1_1Compositing.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools::Compositing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFETools.html">FETools</a></li><li class="navelem"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools::Compositing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aedbccf8a62ae83b8dbedcea2a496b82b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aedbccf8a62ae83b8dbedcea2a496b82b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#aedbccf8a62ae83b8dbedcea2a496b82b">multiply_dof_numbers</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:aedbccf8a62ae83b8dbedcea2a496b82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d4dab923eaefa5a19b693224b6111"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afa7d4dab923eaefa5a19b693224b6111"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#afa7d4dab923eaefa5a19b693224b6111">multiply_dof_numbers</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:afa7d4dab923eaefa5a19b693224b6111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ae4c145f88cfc1ff2b139f1793b89f023">multiply_dof_numbers</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0)</td></tr>
<tr class="separator:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4b086e9e247c5971e4dc435fae1390"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aab4b086e9e247c5971e4dc435fae1390"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#aab4b086e9e247c5971e4dc435fae1390">compute_restriction_is_additive_flags</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:aab4b086e9e247c5971e4dc435fae1390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b3c7fc5dfd2107fcbaedbc685bb70"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab70b3c7fc5dfd2107fcbaedbc685bb70"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ab70b3c7fc5dfd2107fcbaedbc685bb70">compute_restriction_is_additive_flags</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:ab70b3c7fc5dfd2107fcbaedbc685bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a8cfbda8143ee7cc43d7427a25cd5fed1">compute_restriction_is_additive_flags</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0)</td></tr>
<tr class="separator:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56925956547364f6e037ada5a5a722f5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a56925956547364f6e037ada5a5a722f5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a56925956547364f6e037ada5a5a722f5">compute_nonzero_components</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:a56925956547364f6e037ada5a5a722f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b4f04333fb72ef6858ca51911736f7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a69b4f04333fb72ef6858ca51911736f7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a69b4f04333fb72ef6858ca51911736f7">compute_nonzero_components</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a69b4f04333fb72ef6858ca51911736f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab130b73d1aa4f570063c4f2903567b00"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab130b73d1aa4f570063c4f2903567b00"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ab130b73d1aa4f570063c4f2903567b00">compute_nonzero_components</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:ab130b73d1aa4f570063c4f2903567b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd957d101116d4a8b4c17c0ee16ad202"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abd957d101116d4a8b4c17c0ee16ad202"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#abd957d101116d4a8b4c17c0ee16ad202">build_cell_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;system_to_base_table, std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;system_to_component_table, std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;component_to_base_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:abd957d101116d4a8b4c17c0ee16ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bbed0346e30935279bc5289c7c9269"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae9bbed0346e30935279bc5289c7c9269"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ae9bbed0346e30935279bc5289c7c9269">build_face_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;face_system_to_base_table, std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;face_system_to_component_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true, const unsigned <a class="el" href="classint.html">int</a> face_no=0)</td></tr>
<tr class="separator:ae9bbed0346e30935279bc5289c7c9269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace that contains functions that help setting up internal data structures when implementing <a class="el" href="classFiniteElement.html">FiniteElement</a> which are build from simpler ("base") elements, for example <a class="el" href="classFESystem.html">FESystem</a>. The things computed by these functions typically serve as constructor arguments to the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class of the derived finite element object being constructed. There are generally two ways in which one can build more complex elements, and this is reflected by several of the functions in this namespace having arguments called <code>do_tensor_product</code> : </p><ol>
<li>
<a class="el" href="classTensor.html">Tensor</a> product construction ( <code>do_tensor_product=true</code> ): The tensor product construction, in the simplest case, builds a vector-valued element from scalar elements (see <a class="el" href="group__vector__valued.html">this documentation module</a> and <a class="el" href="DEALGlossary.html#GlossComponent">this glossary entry</a> for more information). To give an example, consider creating a vector-valued element with two vector components, where the first should have linear shape functions and the second quadratic shape functions. In 1d, the shape functions (on the reference cell) of the base elements are then <p class="formulaDsp">
\begin{align*} Q_1 &amp;= \{ 1-x, x \}, \\ Q_2 &amp;= \{ 2(\frac 12 - x)(1-x), 2(x - \frac 12)x, 4x(1-x) \}, \end{align*}
</p>
 where shape functions are ordered in the usual way (first on the first vertex, then on the second vertex, then in the interior of the cell). The tensor product construction will create an element with the following shape functions: <p class="formulaDsp">
\begin{align*} Q_1 \times Q_2 &amp;= \left\{ \begin{pmatrix} 1-x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(\frac 12 - x)(1-x) \end{pmatrix}, \begin{pmatrix} x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(x - \frac 12)x \end{pmatrix}, \begin{pmatrix} 0 \\ 4x(1-x) \end{pmatrix} \right\}. \end{align*}
</p>
 The list here is again in standard order. Of course, the procedure also works if the base elements are already vector valued themselves: in that case, the composed element simply has as many vector components as the base elements taken together. </li>
<li>
Combining shape functions ( <code>do_tensor_product=false</code> ): In contrast to the previous strategy, combining shape functions simply takes <em>all</em> of the shape functions together. In the case above, this would yield the following element: <p class="formulaDsp">
\begin{align*} Q_1 + Q_2 &amp;= \{ 1-x, 2(\frac 12 - x)(1-x), x, 2(x - \frac 12)x, 4x(1-x) \}. \end{align*}
</p>
 In other words, if the base elements are scalar, the resulting element will also be. In general, the base elements all will have to have the same number of vector components. The element constructed above of course no longer has a linearly independent set of shape functions. As a consequence, any matrix one creates by treating all shape functions of the composed element in the same way will be singular. In practice, this strategy is therefore typically used in situations where one explicitly makes sure that certain shape functions are treated differently (e.g., by multiplying them with weight functions), or in cases where the shape functions one combines are not linearly dependent. </li>
</ol>
<p>A namespace that contains functions that help setting up internal data structures when implementing <a class="el" href="classFiniteElement.html">FiniteElement</a> which are build from simpler ("base") elements, for example <a class="el" href="classFESystem.html">FESystem</a>. The things computed by these functions typically serve as constructor arguments to the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class of the derived finite element object being constructed.</p>
<p>There are generally two ways in which one can build more complex elements, and this is reflected by several of the functions in this namespace having arguments called <code>do_tensor_product</code>:</p>
<ol>
<li>
<p class="startli"><a class="el" href="classTensor.html">Tensor</a> product construction (<code>do_tensor_product=true</code>): The tensor product construction, in the simplest case, builds a vector-valued element from scalar elements (see <a class="el" href="group__vector__valued.html">this documentation module</a> and <a class="el" href="DEALGlossary.html#GlossComponent">this glossary entry</a> for more information). To give an example, consider creating a vector-valued element with two vector components, where the first should have linear shape functions and the second quadratic shape functions. In 1d, the shape functions (on the reference cell) of the base elements are then </p><p class="formulaDsp">
\begin{align*} Q_1 &amp;= \{ 1-x, x \}, \\ Q_2 &amp;= \{ 2(\frac 12 - x)(1-x), 2(x - \frac 12)x, 4x(1-x) \}, \end{align*}
</p>
<p> where shape functions are ordered in the usual way (first on the first vertex, then on the second vertex, then in the interior of the cell). The tensor product construction will create an element with the following shape functions: </p><p class="formulaDsp">
\begin{align*} Q_1 \times Q_2 &amp;= \left\{ \begin{pmatrix} 1-x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(\frac 12 - x)(1-x) \end{pmatrix}, \begin{pmatrix} x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(x - \frac 12)x \end{pmatrix}, \begin{pmatrix} 0 \\ 4x(1-x) \end{pmatrix} \right\}. \end{align*}
</p>
<p> The list here is again in standard order.</p>
<p class="interli">Of course, the procedure also works if the base elements are already vector valued themselves: in that case, the composed element simply has as many vector components as the base elements taken together.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Combining shape functions (<code>do_tensor_product=false</code>): In contrast to the previous strategy, combining shape functions simply takes <em>all</em> of the shape functions together. In the case above, this would yield the following element: </p><p class="formulaDsp">
\begin{align*} Q_1 + Q_2 &amp;= \{ 1-x, 2(\frac 12 - x)(1-x), x, 2(x - \frac 12)x, 4x(1-x) \}. \end{align*}
</p>
<p> In other words, if the base elements are scalar, the resulting element will also be. In general, the base elements all will have to have the same number of vector components.</p>
<p class="interli">The element constructed above of course no longer has a linearly independent set of shape functions. As a consequence, any matrix one creates by treating all shape functions of the composed element in the same way will be singular. In practice, this strategy is therefore typically used in situations where one explicitly makes sure that certain shape functions are treated differently (e.g., by multiplying them with weight functions), or in cases where the shape functions one combines are not linearly dependent.</p>
<p class="endli"></p>
</li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aedbccf8a62ae83b8dbedcea2a496b82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbccf8a62ae83b8dbedcea2a496b82b">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take vectors of finite elements and multiplicities and multiply out how many degrees of freedom the composed element has per vertex, line, etc. If <code>do_tensor_product</code> is true, the number of components returned in the <a class="el" href="classFiniteElementData.html">FiniteElementData</a> object is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components. See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="afa7d4dab923eaefa5a19b693224b6111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7d4dab923eaefa5a19b693224b6111">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,   spacedim&gt;&gt;, unsigned int&gt;</code> and <code>do_tensor_product = true</code> .</p>
<p>Same as above for an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;, unsigned int&gt;</code> and <code>do_tensor_product = true</code>. </p>

</div>
</div>
<a id="ae4c145f88cfc1ff2b139f1793b89f023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c145f88cfc1ff2b139f1793b89f023">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for a specific number of sub-elements. </p>

</div>
</div>
<a id="aab4b086e9e247c5971e4dc435fae1390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4b086e9e247c5971e4dc435fae1390">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the "restriction is additive" flags (see the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> class) for a list of finite elements with multiplicities given in the second argument. The "restriction
is additive" flags are properties of individual shape functions that do not depend on whether the composed element uses the tensor product or combination strategy outlined in the documentation of the FETools::Composition namespace. Consequently, this function does not have a <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="ab70b3c7fc5dfd2107fcbaedbc685bb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70b3c7fc5dfd2107fcbaedbc685bb70">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,   spacedim&gt;&gt;, unsigned int&gt;</code>. </p>

</div>
</div>
<a id="a8cfbda8143ee7cc43d7427a25cd5fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfbda8143ee7cc43d7427a25cd5fed1">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> object and return a boolean vector describing the <code>restriction_is_additive_flags</code> (see the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> class) for each shape function of the mixed element consisting of <code>N1</code>, <code>N2</code>, ... copies of the sub-elements <code>fe1</code>, <code>fe2</code>, ... The "restriction
is additive" flags are properties of individual shape functions that do not depend on whether the composed element uses the tensor product or combination strategy outlined in the documentation of the FETools::Composition namespace. Consequently, this function does not have a <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="a56925956547364f6e037ada5a5a722f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56925956547364f6e037ada5a5a722f5">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the nonzero components for each shape function of a composed finite element described by a list of finite elements with multiplicities given in the second argument. If <code>do_tensor_product</code> is true, the number of components (and thus the size of the <a class="el" href="classComponentMask.html">ComponentMask</a> objects) is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components. See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="a69b4f04333fb72ef6858ca51911736f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b4f04333fb72ef6858ca51911736f7">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,   spacedim&gt;&gt;, unsigned int&gt;</code> and <code>do_tensor_product = true</code> .</p>
<p>Same as above for an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;, unsigned int&gt;</code> and <code>do_tensor_product = true</code>. </p>

</div>
</div>
<a id="ab130b73d1aa4f570063c4f2903567b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab130b73d1aa4f570063c4f2903567b00">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the non-zero vector components of a composed finite element. This function is similar to the previous one, except that the pointers indicate the elements to be composed, and the arguments <code>N1</code>, <code>N2</code>, ... the multiplicities. Null pointers indicate that an argument is to be skipped. If <code>do_tensor_product</code> is true, the number of components (and thus the size of the <a class="el" href="classComponentMask.html">ComponentMask</a> objects) is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components. See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="abd957d101116d4a8b4c17c0ee16ad202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd957d101116d4a8b4c17c0ee16ad202">&#9670;&nbsp;</a></span>build_cell_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_cell_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given (composite) <code>finite_element</code> build <code>system_to_component_table</code>, <code>system_to_base_table</code> and <code>component_to_base_table</code>. If <code>do_tensor_product</code> is true, the number of components used for the composite element is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components. See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

</div>
</div>
<a id="ae9bbed0346e30935279bc5289c7c9269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bbed0346e30935279bc5289c7c9269">&#9670;&nbsp;</a></span>build_face_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_face_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given (composite) <code>finite_element</code> build <code>face_system_to_base_table</code>, and <code>face_system_to_component_table</code>. If <code>do_tensor_product</code> is true, the number of components used for the composite element is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components. See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
