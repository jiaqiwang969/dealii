<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataPostprocessorTensor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataPostprocessorTensor&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataPostprocessorTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessorTensor&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2data__postprocessor_8h_source.html">deal.II/numerics/data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessorTensor&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81eaa494a89bfa997902657cfb28cea8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a81eaa494a89bfa997902657cfb28cea8">DataPostprocessorTensor</a> (const std::string &amp;<a class="el" href="classDataPostprocessorTensor.html#a9bbc119e1c0f6104b339543286a7f73a">name</a>, const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html#aa39f3cc739d0c3ba13d2f4699f724e35">update_flags</a>)</td></tr>
<tr class="separator:a81eaa494a89bfa997902657cfb28cea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a96637bbaa3011861981e98e8a5aa7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a90a96637bbaa3011861981e98e8a5aa7">get_names</a> () const override</td></tr>
<tr class="separator:a90a96637bbaa3011861981e98e8a5aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4da33ead3f195ab7475ced4cf05a10"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a9d4da33ead3f195ab7475ced4cf05a10">get_data_component_interpretation</a> () const override</td></tr>
<tr class="separator:a9d4da33ead3f195ab7475ced4cf05a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf55a054599aac4956ea3752b9e349ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags</a> () const override</td></tr>
<tr class="separator:aaf55a054599aac4956ea3752b9e349ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eaa494a89bfa997902657cfb28cea8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a81eaa494a89bfa997902657cfb28cea8">DataPostprocessorTensor</a> (const std::string &amp;<a class="el" href="classDataPostprocessorTensor.html#a9bbc119e1c0f6104b339543286a7f73a">name</a>, const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html#aa39f3cc739d0c3ba13d2f4699f724e35">update_flags</a>)</td></tr>
<tr class="separator:a81eaa494a89bfa997902657cfb28cea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b2ef38a32d11746b6ee081bb444bbb"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#ac1b2ef38a32d11746b6ee081bb444bbb">get_names</a> () const override</td></tr>
<tr class="separator:ac1b2ef38a32d11746b6ee081bb444bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39b993ce4b4b6793ced0be30c7f7903"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#aa39b993ce4b4b6793ced0be30c7f7903">get_data_component_interpretation</a> () const override</td></tr>
<tr class="separator:aa39b993ce4b4b6793ced0be30c7f7903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ef67404375e3333caa9b7270acfece"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a85ef67404375e3333caa9b7270acfece">get_needed_update_flags</a> () const override</td></tr>
<tr class="separator:a85ef67404375e3333caa9b7270acfece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eaa494a89bfa997902657cfb28cea8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a81eaa494a89bfa997902657cfb28cea8">DataPostprocessorTensor</a> (const std::string &amp;<a class="el" href="classDataPostprocessorTensor.html#a9bbc119e1c0f6104b339543286a7f73a">name</a>, const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html#aa39f3cc739d0c3ba13d2f4699f724e35">update_flags</a>)</td></tr>
<tr class="separator:a81eaa494a89bfa997902657cfb28cea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b2ef38a32d11746b6ee081bb444bbb"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#ac1b2ef38a32d11746b6ee081bb444bbb">get_names</a> () const override</td></tr>
<tr class="separator:ac1b2ef38a32d11746b6ee081bb444bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39b993ce4b4b6793ced0be30c7f7903"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#aa39b993ce4b4b6793ced0be30c7f7903">get_data_component_interpretation</a> () const override</td></tr>
<tr class="separator:aa39b993ce4b4b6793ced0be30c7f7903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ef67404375e3333caa9b7270acfece"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a85ef67404375e3333caa9b7270acfece">get_needed_update_flags</a> () const override</td></tr>
<tr class="separator:a85ef67404375e3333caa9b7270acfece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a3a2cd25375af88b518b489b3f47ad0d4">evaluate_scalar_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a3a2cd25375af88b518b489b3f47ad0d4">evaluate_scalar_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a3a2cd25375af88b518b489b3f47ad0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba57b598d24d64365d469a854271c68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a1ba57b598d24d64365d469a854271c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1bbafe00fba18dd906adc1e1dec29b25">evaluate_vector_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1bbafe00fba18dd906adc1e1dec29b25">evaluate_vector_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a1bbafe00fba18dd906adc1e1dec29b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9bbc119e1c0f6104b339543286a7f73a"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#a9bbc119e1c0f6104b339543286a7f73a">name</a></td></tr>
<tr class="separator:a9bbc119e1c0f6104b339543286a7f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39f3cc739d0c3ba13d2f4699f724e35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessorTensor.html#aa39f3cc739d0c3ba13d2f4699f724e35">update_flags</a></td></tr>
<tr class="separator:aa39f3cc739d0c3ba13d2f4699f724e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
class DataPostprocessorTensor&lt; dim &gt;</h3>

<p>This class provides a simpler interface to the functionality offered by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class in case one wants to compute only a single tensor quantity (defined as having exactly <code>dim*dim</code> components) from the finite element field passed to the <a class="el" href="classDataOut.html">DataOut</a> class. For this case, we would like to output all of these components as parts of a tensor-valued quantity. Unfortunately, the various backends that write <a class="el" href="classDataOut.html">DataOut</a> data in graphical file formats (see the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace for what formats can be written) do not support tensor data at the current time. In fact, neither does the <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a> namespace that provides semantic information how individual components of graphical data should be interpreted. Nevertheless, like <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>, this class helps with setting up what the <a class="el" href="classDataPostprocessorTensor.html#a90a96637bbaa3011861981e98e8a5aa7">get_names()</a> and <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags()</a> functions required by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> base class should return, and so the current class implements these based on information that the constructor of the current class receives from further derived classes. (In order to visualize this collection of scalar fields that, together, are then supposed to be interpreted as a tensor, one has to (i) use a visualization program that can visualize tensors, and (ii) teach it how to re-combine the scalar fields into tensors. In the case of VisIt</p>
<ul>
<li>see <a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/</a></li>
<li>this is done by creating a new "Expression": in essence, one creates a variable, say "grad_u", that is tensor-valued and whose value is given by the expression <code>{{grad_u_xx,grad_u_xy},{grad_u_yx, grad_u_yy}}</code>, where the referenced variables are the names of scalar fields that, here, are produced by the example below. VisIt is then able to visualize this "new" variable as a tensor.) All derived classes have to do is implement a constructor and overload either <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> as discussed in the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class's documentation. An example of how the closely related class <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> is used can be found in <a class="el" href="step_29.html">step-29</a> . An example of how the <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> class can be used is found in the documentation of that class.</li>
</ul>
<h3>An example </h3>
<p>A common example of what one wants to do with postprocessors is to visualize not just the value of the solution, but the gradient. This class is meant for tensor-valued outputs, so we will start with a vector-valued solution: the displacement field of <a class="el" href="step_8.html">step-8</a> . The gradient is a rank-2 tensor (with exactly <code>dim*dim</code> components), so the current class fits the bill to produce the gradient through postprocessing. Then, the following code snippet implements everything you need to have to visualize the gradient:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>GradientPostprocessor : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  GradientPostprocessor ()</div>
<div class="line">    :</div>
<div class="line">    <a class="code" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt;dim&gt; (<span class="stringliteral">&quot;grad_u&quot;</span>,</div>
<div class="line">                                  <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span></div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a></div>
<div class="line">  (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;input_data,</div>
<div class="line">   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// ensure that there really are as many output slots</span></div>
<div class="line">    <span class="comment">// as there are points at which DataOut provides the</span></div>
<div class="line">    <span class="comment">// gradients:</span></div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (input_data.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a2a918d936d56f2be4cdad1b8074c3a86">solution_gradients</a>.size(),</div>
<div class="line">                     computed_quantities.size());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;input_data.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a2a918d936d56f2be4cdad1b8074c3a86">solution_gradients</a>.size(); ++p)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// ensure that each output slot has exactly &#39;dim*dim&#39;</span></div>
<div class="line">        <span class="comment">// components (as should be expected, given that we</span></div>
<div class="line">        <span class="comment">// want to create tensor-valued outputs), and copy the</span></div>
<div class="line">        <span class="comment">// gradients of the solution at the evaluation points</span></div>
<div class="line">        <span class="comment">// into the output slots:</span></div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (computed_quantities[p].size(),</div>
<div class="line">                         (<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;::n_independent_components</a>));</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">e</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">e</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">e</a>)</div>
<div class="line">            computed_quantities[p][<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;::component_to_unrolled_index</a>(<a class="code" href="classTableIndices.html">TableIndices&lt;2&gt;</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>,<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">e</a>))]</div>
<div class="line">              = input_data.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a2a918d936d56f2be4cdad1b8074c3a86">solution_gradients</a>[p][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">e</a>];</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The only tricky part in this piece of code is how to sort the <code>dim*dim</code> elements of the strain tensor into the one vector of computed output quantities</p>
<ul>
<li>in other words, how to <em>unroll</em> the elements of the tensor into the vector. This is facilitated by the <a class="el" href="classTensor.html#a691feb72e96831cab4a85fbc28167abd">Tensor::component_to_unrolled_index()</a> function that takes a pair of indices that specify a particular element of the tensor and returns a vector index that is then used in the code above to fill the <code>computed_quantities</code> array. The last thing that is necessary is to add another output to the call of DataOut::add_vector() in the <code>output_results()</code> function of the <code>Step8</code> class of that example program. The corresponding code snippet would then look like this:</li>
</ul>
<div class="fragment"><div class="line">GradientPostprocessor&lt;dim&gt; grad_u;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">data_component_interpretation</div>
<div class="line">(dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (solution,</div>
<div class="line">                          std::vector&lt;std::string&gt;(dim,<span class="stringliteral">&quot;displacement&quot;</span>),</div>
<div class="line">                          <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div>
<div class="line">                          data_component_interpretation);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (solution, grad_u);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> ();</div>
<div class="line">data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div>
</div><!-- fragment --><p>This leads to the following output for the displacement field (i.e., the solution) and the gradients (you may want to compare with the solution shown in the results section of <a class="el" href="step_8.html">step-8</a> ; the current data is generated on a uniform mesh for simplicity): </p><div class="image">
<img src="data_postprocessor_tensor_0.png" alt=""/>
<div class="caption">
<div class="image">
<img src="data_postprocessor_tensor_1.png" alt=""/>
</div>
 These pictures show an ellipse representing the gradient tensor at, on average, every tenth mesh point. You may want to read through the documentation of the VisIt visualization program (see <a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/</a>) for an interpretation of how exactly tensors are visualizated. In elasticity, one is often interested not in the gradient of the displacement, but in the "strain", i.e., the symmetrized version of the gradient \(\varepsilon=\frac 12 (\nabla u + \nabla u^T)\) . This is easily facilitated with the following minor modification: @code template int class StrainPostprocessor : public DataPostprocessorTensor&lt;dim&gt; { public: StrainPostprocessor () : DataPostprocessorTensor&lt;dim&gt; ("strain", update_gradients) {}  virtual void evaluate_vector_field (const DataPostprocessorInputs::Vector&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { AssertDimension (computed_quantities[p].size(), (<a class="el" href="classTensor.html#a6be05c0fb6403c62d9b9877431b37c53">Tensor&lt;2,dim&gt;::n_independent_components</a>)); for (unsigned int d=0; d&lt;dim; ++d) for (unsigned int e=0; e&lt;dim; ++e) computed_quantities[p][Tensor&lt;2,dim&gt;::component_to_unrolled_index(TableIndices&lt;2&gt;(d,e))] = (input_data.solution_gradients[p][d][e]] input_data.solution_gradients[p][e][d]) / 2; } } }; @endcode Using this class in @ref step_8 "step-8" leads to the following visualization: <div class="image">
<img src="data_postprocessor_tensor_2.png" alt=""/>
</div>
 Given how easy it is to output the strain, it would also not be very complicated to write a postprocessor that computes the <em>stress</em> in the solution field as the stress is easily computed from the strain by multiplication with either the strain-stress tensor or, in simple cases, the Lam&eacute; constants. This class provides a simpler interface to the functionality offered by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class in case one wants to compute only a single tensor quantity (defined as having exactly <code>dim*dim</code> components) from the finite element field passed to the <a class="el" href="classDataOut.html">DataOut</a> class. For this case, we would like to output all of these components as parts of a tensor-valued quantity. Unfortunately, the various backends that write <a class="el" href="classDataOut.html">DataOut</a> data in graphical file formats (see the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace for what formats can be written) do not support tensor data at the current time. In fact, neither does the <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a> namespace that provides semantic information how individual components of graphical data should be interpreted. Nevertheless, like <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>, this class helps with setting up what the <a class="el" href="classDataPostprocessorTensor.html#a90a96637bbaa3011861981e98e8a5aa7">get_names()</a> and <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags()</a> functions required by the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> base class should return, and so the current class implements these based on information that the constructor of the current class receives from further derived classes. (In order to visualize this collection of scalar fields that, together, are then supposed to be interpreted as a tensor, one has to (i) use a visualization program that can visualize tensors, and (ii) teach it how to re-combine the scalar fields into tensors. In the case of VisIt &ndash; see <a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/</a> &ndash; this is done by creating a new "Expression": in essence, one creates a variable, say "grad_u", that is tensor-valued and whose value is given by the expression <code>{{grad_u_xx,grad_u_xy}, {grad_u_yx, grad_u_yy}}</code>, where the referenced variables are the names of scalar fields that, here, are produced by the example below. VisIt is then able to visualize this "new" variable as a tensor.) All derived classes have to do is implement a constructor and overload either <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> as discussed in the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class's documentation. An example of how the closely related class <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> is used can be found in @ref step_29 "step-29". An example of how the <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> class can be used is found in the documentation of that class. h3 An example h3 A common example of what one wants to do with postprocessors is to visualize not just the value of the solution, but the gradient. This class is meant for tensor-valued outputs, so we will start with a vector-valued solution: the displacement field of @ref step_8 "step-8". The gradient is a rank-2 tensor (with exactly <code>dim*dim</code> components), so the current class fits the bill to produce the gradient through postprocessing. Then, the following code snippet implements everything you need to have to visualize the gradient: @code template int class GradientPostprocessor : public DataPostprocessorTensor&lt;dim&gt; { public: GradientPostprocessor () : DataPostprocessorTensor&lt;dim&gt; ("grad_u", update_gradients) {}  virtual void evaluate_vector_field (const DataPostprocessorInputs::Vector&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { // ensure that there really are as many output slots // as there are points at which <a class="el" href="classDataOut.html">DataOut</a> provides the // gradients: AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { // ensure that each output slot has exactly 'dim*dim' // components (as should be expected, given that we // want to create tensor-valued outputs), and copy the // gradients of the solution at the evaluation points // into the output slots: AssertDimension (computed_quantities[p].size(), (<a class="el" href="classTensor.html#a6be05c0fb6403c62d9b9877431b37c53">Tensor&lt;2,dim&gt;::n_independent_components</a>)); for (unsigned int d=0; d&lt;dim; ++d) for (unsigned int e=0; e&lt;dim; ++e) computed_quantities[p][Tensor&lt;2,dim&gt;::component_to_unrolled_index(TableIndices&lt;2&gt;(d,e))] = input_data.solution_gradients[p][d][e]; } } }; @endcode The only tricky part in this piece of code is how to sort the <code>dim*dim</code> elements of the strain tensor into the one vector of computed output quantities &ndash; in other words, how to <em>unroll</em> the elements of the tensor into the vector. This is facilitated by the <a class="el" href="classTensor.html#a691feb72e96831cab4a85fbc28167abd">Tensor::component_to_unrolled_index()</a> function that takes a pair of indices that specify a particular element of the tensor and returns a vector index that is then used in the code above to fill the <code>computed_quantities</code> array. The last thing that is necessary is to add another output to the call of DataOut::add_vector() in the <code>output_results()</code> function of the <code>Step8</code> class of that example program. The corresponding code snippet would then look like this: @code GradientPostprocessor&lt;dim&gt; grad_u;  <a class="el" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; data_out.attach_dof_handler (dof_handler);  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt; data_component_interpretation (dim, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>); data_out.add_data_vector (solution, std::vector&lt;std::string&gt;(dim,"displacement"), <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27aa76306340b5b73ca2d14e961e99d2972">DataOut&lt;dim&gt;::type_dof_data</a>, data_component_interpretation); data_out.add_data_vector (solution, grad_u); data_out.build_patches (); data_out.write_vtk (output); @endcode This leads to the following output for the displacement field (i.e., the solution) and the gradients (you may want to compare with the solution shown in the results section of @ref step_8 "step-8"; the current data is generated on a uniform mesh for simplicity): <div class="image">
<img src="data_postprocessor_tensor_0.png" alt=""/>
</div>
 <div class="image">
<img src="data_postprocessor_tensor_1.png" alt=""/>
</div>
 These pictures show an ellipse representing the gradient tensor at, on average, every tenth mesh point. You may want to read through the documentation of the VisIt visualization program (see <a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/</a>) for an interpretation of how exactly tensors are visualizated. In elasticity, one is often interested not in the gradient of the displacement, but in the "strain", i.e., the symmetrized version of the gradient \(\varepsilon=\frac 12 (\nabla u + \nabla u^T)\). This is easily facilitated with the following minor modification: @code template int class StrainPostprocessor : public DataPostprocessorTensor&lt;dim&gt; { public: StrainPostprocessor () : DataPostprocessorTensor&lt;dim&gt; ("strain", update_gradients) {}  virtual void evaluate_vector_field (const DataPostprocessorInputs::Vector&lt;dim&gt; &amp;input_data, std::vector&lt;<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> &gt; &amp;computed_quantities) const override { AssertDimension (input_data.solution_gradients.size(), computed_quantities.size());  for (unsigned int p=0; p&lt;input_data.solution_gradients.size(); ++p) { AssertDimension (computed_quantities[p].size(), (<a class="el" href="classTensor.html#a6be05c0fb6403c62d9b9877431b37c53">Tensor&lt;2,dim&gt;::n_independent_components</a>)); for (unsigned int d=0; d&lt;dim; ++d) for (unsigned int e=0; e&lt;dim; ++e) computed_quantities[p][Tensor&lt;2,dim&gt;::component_to_unrolled_index(TableIndices&lt;2&gt;(d,e))] = (input_data.solution_gradients[p][d][e]] input_data.solution_gradients[p][e][d]) / 2; } } }; @endcode Using this class in @ref step_8 "step-8" leads to the following visualization: <div class="image">
<img src="data_postprocessor_tensor_2.png" alt=""/>
</div>
 Given how easy it is to output the strain, it would also not be very complicated to write a postprocessor that computes the <em>stress</em> in the solution field as the stress is easily computed from the strain by multiplication with either the strain-stress tensor or, in simple cases, the Lam&eacute; constants. </div></div>

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l01069">1069</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a81eaa494a89bfa997902657cfb28cea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eaa494a89bfa997902657cfb28cea8">&#9670;&nbsp;</a></span>DataPostprocessorTensor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::<a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files.</td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00138">138</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a81eaa494a89bfa997902657cfb28cea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eaa494a89bfa997902657cfb28cea8">&#9670;&nbsp;</a></span>DataPostprocessorTensor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::<a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files. </td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81eaa494a89bfa997902657cfb28cea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eaa494a89bfa997902657cfb28cea8">&#9670;&nbsp;</a></span>DataPostprocessorTensor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::<a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take the name of the single vector variable computed by classes derived from the current one, as well as the update flags necessary to compute this quantity.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the vector variable computed by this class should be made available in graphical output files.</td></tr>
    <tr><td class="paramname">update_flags</td><td>This has to be a combination of <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> and <code>update_quadrature_points</code>. Note that the flag <code>update_quadrature_points</code> updates <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a47b81aaed3bc9549c57488b8a98db4b3">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. The description of the flags can be found at <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a90a96637bbaa3011861981e98e8a5aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a96637bbaa3011861981e98e8a5aa7">&#9670;&nbsp;</a></span>get_names() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00149">149</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a9d4da33ead3f195ab7475ced4cf05a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4da33ead3f195ab7475ced4cf05a10">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_data_component_interpretation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00158">158</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="aaf55a054599aac4956ea3752b9e349ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf55a054599aac4956ea3752b9e349ae">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_needed_update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00167">167</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="ac1b2ef38a32d11746b6ee081bb444bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b2ef38a32d11746b6ee081bb444bbb">&#9670;&nbsp;</a></span>get_names() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="aa39b993ce4b4b6793ced0be30c7f7903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39b993ce4b4b6793ced0be30c7f7903">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a85ef67404375e3333caa9b7270acfece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ef67404375e3333caa9b7270acfece">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ac1b2ef38a32d11746b6ee081bb444bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b2ef38a32d11746b6ee081bb444bbb">&#9670;&nbsp;</a></span>get_names() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. Given the purpose of this class, this is a vector with dim entries all equal to the name given to the constructor. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="aa39b993ce4b4b6793ced0be30c7f7903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39b993ce4b4b6793ced0be30c7f7903">&#9670;&nbsp;</a></span>get_data_component_interpretation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns information about how the individual components of output files that consist of more than one data set are to be interpreted. Since the current class is meant to be used for a single vector result variable, the returned value is obviously DataComponentInterpretation::component_is_part repeated dim times. </p>

<p>Reimplemented from <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a85ef67404375e3333caa9b7270acfece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ef67404375e3333caa9b7270acfece">&#9670;&nbsp;</a></span>get_needed_update_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return which data has to be provided to compute the derived quantities. The flags returned here are the ones passed to the constructor of this class. </p>

<p>Implements <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a07ebcf764cf911c6d78f21c32ea1d2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ebcf764cf911c6d78f21c32ea1d2d0">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function. The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data</p>
<ul>
<li>in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state. This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00026">26</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a3a2cd25375af88b518b489b3f47ad0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2cd25375af88b518b489b3f47ad0d4">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function.</p>
<p>The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data &ndash; in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state.</p>
<p>This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </p>

</div>
</div>
<a id="a3a2cd25375af88b518b489b3f47ad0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2cd25375af88b518b489b3f47ad0d4">&#9670;&nbsp;</a></span>evaluate_scalar_field() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function. The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data</p>
<ul>
<li>in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by an overridden version of the <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state. This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e., if the finite element in use has only a single real-valued vector component. </li>
</ul>

</div>
</div>
<a id="a1ba57b598d24d64365d469a854271c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba57b598d24d64365d469a854271c68">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00037">37</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a1bbafe00fba18dd906adc1e1dec29b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbafe00fba18dd906adc1e1dec29b25">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

</div>
</div>
<a id="a1bbafe00fba18dd906adc1e1dec29b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbafe00fba18dd906adc1e1dec29b25">&#9670;&nbsp;</a></span>evaluate_vector_field() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e., the finite element in use has multiple vector components. This function is also called if the finite element is scalar but the solution vector is complex-valued. If the solution vector to be visualized is complex-valued (whether scalar or not), then the input data contains first all real parts of the solution vector at each evaluation point, and then all imaginary parts. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9bbc119e1c0f6104b339543286a7f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbc119e1c0f6104b339543286a7f73a">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies of the two arguments given to the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l01125">1125</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<a id="aa39f3cc739d0c3ba13d2f4699f724e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39f3cc739d0c3ba13d2f4699f724e35">&#9670;&nbsp;</a></span>update_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a>&lt; dim &gt;::update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="numerics_2data__postprocessor_8h_source.html#l01126">1126</a> of file <a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
<li>source/numerics/<a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="aclassTableIndices_html"><div class="ttname"><a href="classTableIndices.html">TableIndices</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2table__indices_8h_source.html#l00045">table_indices.h:45</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a496b854daac5cca870bc8008f562daad"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a496b854daac5cca870bc8008f562daad">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html_a2a918d936d56f2be4cdad1b8074c3a86"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html#a2a918d936d56f2be4cdad1b8074c3a86">DataPostprocessorInputs::Vector::solution_gradients</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Tensor&lt; 1, spacedim &gt; &gt; &gt; solution_gradients</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00347">data_postprocessor.h:347</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__component__interpretation_8h_source.html#l00062">data_component_interpretation.h:62</a></div></div>
<div class="ttc" id="aclassDataPostprocessor_html_a1ba57b598d24d64365d469a854271c68"><div class="ttname"><a href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field</a></div><div class="ttdeci">virtual void evaluate_vector_field(const DataPostprocessorInputs::Vector&lt; dim &gt; &amp;input_data, std::vector&lt; Vector&lt; double &gt;&gt; &amp;computed_quantities) const</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8cc_source.html#l00037">data_postprocessor.cc:37</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_acad99726038e4fca7f605fdffb3317e4"><div class="ttname"><a href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk</a></div><div class="ttdeci">void write_vtk(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07221">data_out_base.cc:7221</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor_8h_source.html#l00441">tensor.h:441</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="aclassDataPostprocessorTensor_html"><div class="ttname"><a href="classDataPostprocessorTensor.html">DataPostprocessorTensor</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l01069">data_postprocessor.h:1069</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga9442b63275c9ef3fab29bc222831c49c"><div class="ttname"><a href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a></div><div class="ttdeci">#define AssertDimension(dim1, dim2)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01749">exceptions.h:1749</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00319">data_postprocessor.h:319</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
