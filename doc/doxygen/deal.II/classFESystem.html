<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFESystem.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FESystem&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFESystem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FESystem&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__febase.html">Base classes</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__fe.html">Finite element space descriptions</a><a class="el" href="group__feall.html">Finite elements</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a> &raquo;  &#124; <a class="el" href="group__vector__valued.html">Handling vector valued problems</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">deal.II/fe/fe.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FESystem&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem_1_1InternalData.html">InternalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a158ced808c3e615b5a3413eea85e254a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a158ced808c3e615b5a3413eea85e254a">FESystem</a> ()=delete</td></tr>
<tr class="separator:a158ced808c3e615b5a3413eea85e254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd69b25bd2dab03bcd565930aceaea33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acd69b25bd2dab03bcd565930aceaea33">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const unsigned <a class="el" href="classint.html">int</a> n_elements)</td></tr>
<tr class="separator:acd69b25bd2dab03bcd565930aceaea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af422559e139959f2025124afba835c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af422559e139959f2025124afba835c89">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2)</td></tr>
<tr class="separator:af422559e139959f2025124afba835c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a51c67b7c8c1eb84175337c47d0b3afd3">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3)</td></tr>
<tr class="separator:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac385e7885b5e9d9e26967a3fa783391b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac385e7885b5e9d9e26967a3fa783391b">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4)</td></tr>
<tr class="separator:ac385e7885b5e9d9e26967a3fa783391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01de107675f319789f2fa70fe6ecf55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa01de107675f319789f2fa70fe6ecf55">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe5, const unsigned <a class="el" href="classint.html">int</a> n5)</td></tr>
<tr class="separator:aa01de107675f319789f2fa70fe6ecf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a83c7bc44f43e75d7d3750cd6c3bce89b">FESystem</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplParams" colspan="2">template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem</a> (FEPairs &amp;&amp;... fe_pairs)</td></tr>
<tr class="separator:a6e27f91193d25f03da55f2438f1d0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0e2aa0e6bd118482b13a5da73d125a4c">FESystem</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305628a44a4a6318b4077ac0236fca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1305628a44a4a6318b4077ac0236fca7">FESystem</a> (const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:a1305628a44a4a6318b4077ac0236fca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae4a5b073e0eb8197845ead711fa09ab2">FESystem</a> (<a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;other_fe_system) noexcept</td></tr>
<tr class="separator:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16ae6333666b8d042306c257f6dc286"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af16ae6333666b8d042306c257f6dc286">~FESystem</a> () override=default</td></tr>
<tr class="separator:af16ae6333666b8d042306c257f6dc286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7ceb9c3eb2eebaa49f9608f458d34c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a8c7ceb9c3eb2eebaa49f9608f458d34c">get_name</a> () const override</td></tr>
<tr class="separator:a8c7ceb9c3eb2eebaa49f9608f458d34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af143e194528aa74e206c2b26c2a49f85"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af143e194528aa74e206c2b26c2a49f85">clone</a> () const override</td></tr>
<tr class="separator:af143e194528aa74e206c2b26c2a49f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab10b19cea15873b34aa3b597bef4de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a3ab10b19cea15873b34aa3b597bef4de">requires_update_flags</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:a3ab10b19cea15873b34aa3b597bef4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4f1afff1380d9f81f6ee1cf63a1a81"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a8e4f1afff1380d9f81f6ee1cf63a1a81">get_sub_fe</a> (const unsigned <a class="el" href="classint.html">int</a> first_component, const unsigned <a class="el" href="classint.html">int</a> n_selected_components) const override</td></tr>
<tr class="separator:a8e4f1afff1380d9f81f6ee1cf63a1a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89164574c530cdf920903040cc134ddf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a89164574c530cdf920903040cc134ddf">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a89164574c530cdf920903040cc134ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ab3340fc4b79ecc619c713fb0e77f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a632ab3340fc4b79ecc619c713fb0e77f">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a632ab3340fc4b79ecc619c713fb0e77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a55732c93a6d7df876af9850d245ef0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a9a55732c93a6d7df876af9850d245ef0">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a9a55732c93a6d7df876af9850d245ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435bbc6cebd810237a87b7b17c3ad006"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a435bbc6cebd810237a87b7b17c3ad006">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a435bbc6cebd810237a87b7b17c3ad006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfe48ad66f32fd977f613b1f342ca8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acbfe48ad66f32fd977f613b1f342ca8c">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:acbfe48ad66f32fd977f613b1f342ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4669a634c58504c69fe030c926252865"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a4669a634c58504c69fe030c926252865">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a4669a634c58504c69fe030c926252865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad795407bb8ed6a584a63102e5c415060"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ad795407bb8ed6a584a63102e5c415060">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ad795407bb8ed6a584a63102e5c415060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4259713fa38075409d422d0080d16f9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af4259713fa38075409d422d0080d16f9">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:af4259713fa38075409d422d0080d16f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b440758f45da4842b77a81a56e4b3d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a50b440758f45da4842b77a81a56e4b3d">shape_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a50b440758f45da4842b77a81a56e4b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1483d485cefac01d5346d3025954360"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa1483d485cefac01d5346d3025954360">shape_4th_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:aa1483d485cefac01d5346d3025954360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117566232430f89edbf198ef9d5ae1a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a117566232430f89edbf198ef9d5ae1a9">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const override</td></tr>
<tr class="separator:a117566232430f89edbf198ef9d5ae1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a870396630e54769b1e2adbdf4f55fc"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2a870396630e54769b1e2adbdf4f55fc">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a2a870396630e54769b1e2adbdf4f55fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e86b6adc43346cae19f40e6d626a32"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a85e86b6adc43346cae19f40e6d626a32">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const override</td></tr>
<tr class="separator:a85e86b6adc43346cae19f40e6d626a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28477b6f49b26d5bc6a289e814211840"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a28477b6f49b26d5bc6a289e814211840">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:a28477b6f49b26d5bc6a289e814211840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7802b1354590cdb8990bc0b417d47e9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac7802b1354590cdb8990bc0b417d47e9">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:ac7802b1354590cdb8990bc0b417d47e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad92aed11c564b6e09129c8c6e11688"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2ad92aed11c564b6e09129c8c6e11688">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const override</td></tr>
<tr class="separator:a2ad92aed11c564b6e09129c8c6e11688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff9c9724937205d201b35a97fa8eb1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a59ff9c9724937205d201b35a97fa8eb1">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a59ff9c9724937205d201b35a97fa8eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f156493477b5e69ca8388e30f1a28d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a35f156493477b5e69ca8388e30f1a28d">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a35f156493477b5e69ca8388e30f1a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c0f8d4411b7f38517c35133615d655"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a17c0f8d4411b7f38517c35133615d655">get_constant_modes</a> () const override</td></tr>
<tr class="separator:a17c0f8d4411b7f38517c35133615d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ced808c3e615b5a3413eea85e254a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a158ced808c3e615b5a3413eea85e254a">FESystem</a> ()=delete</td></tr>
<tr class="separator:a158ced808c3e615b5a3413eea85e254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd69b25bd2dab03bcd565930aceaea33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acd69b25bd2dab03bcd565930aceaea33">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const unsigned <a class="el" href="classint.html">int</a> n_elements)</td></tr>
<tr class="separator:acd69b25bd2dab03bcd565930aceaea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af422559e139959f2025124afba835c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af422559e139959f2025124afba835c89">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2)</td></tr>
<tr class="separator:af422559e139959f2025124afba835c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a51c67b7c8c1eb84175337c47d0b3afd3">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3)</td></tr>
<tr class="separator:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac385e7885b5e9d9e26967a3fa783391b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac385e7885b5e9d9e26967a3fa783391b">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4)</td></tr>
<tr class="separator:ac385e7885b5e9d9e26967a3fa783391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01de107675f319789f2fa70fe6ecf55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa01de107675f319789f2fa70fe6ecf55">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe5, const unsigned <a class="el" href="classint.html">int</a> n5)</td></tr>
<tr class="separator:aa01de107675f319789f2fa70fe6ecf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a83c7bc44f43e75d7d3750cd6c3bce89b">FESystem</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplParams" colspan="2">template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem</a> (FEPairs &amp;&amp;... fe_pairs)</td></tr>
<tr class="separator:a6e27f91193d25f03da55f2438f1d0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0e2aa0e6bd118482b13a5da73d125a4c">FESystem</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305628a44a4a6318b4077ac0236fca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1305628a44a4a6318b4077ac0236fca7">FESystem</a> (const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:a1305628a44a4a6318b4077ac0236fca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae4a5b073e0eb8197845ead711fa09ab2">FESystem</a> (<a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;other_fe_system) noexcept</td></tr>
<tr class="separator:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16ae6333666b8d042306c257f6dc286"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af16ae6333666b8d042306c257f6dc286">~FESystem</a> () override=default</td></tr>
<tr class="separator:af16ae6333666b8d042306c257f6dc286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bead461257e10db3b5200b12dbaa13a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a4bead461257e10db3b5200b12dbaa13a">get_name</a> () const override</td></tr>
<tr class="separator:a4bead461257e10db3b5200b12dbaa13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8f25e0f645ff56370acded9160e0f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a3ce8f25e0f645ff56370acded9160e0f">clone</a> () const override</td></tr>
<tr class="separator:a3ce8f25e0f645ff56370acded9160e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567cacda250362348c58d4b5dbeb4d16"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a567cacda250362348c58d4b5dbeb4d16">requires_update_flags</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:a567cacda250362348c58d4b5dbeb4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0943cddd61aec42370ee37f27ba385"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a9d0943cddd61aec42370ee37f27ba385">get_sub_fe</a> (const unsigned <a class="el" href="classint.html">int</a> first_component, const unsigned <a class="el" href="classint.html">int</a> n_selected_components) const override</td></tr>
<tr class="separator:a9d0943cddd61aec42370ee37f27ba385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ffba94f76a56e45ecb13dddc59fce8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac0ffba94f76a56e45ecb13dddc59fce8">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ac0ffba94f76a56e45ecb13dddc59fce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01d292b9183fb0db6345dd65986fa08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac01d292b9183fb0db6345dd65986fa08">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:ac01d292b9183fb0db6345dd65986fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f0ca95fef98a5a795ba78da7797b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a226f0ca95fef98a5a795ba78da7797b0">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a226f0ca95fef98a5a795ba78da7797b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f423f2b10511d6bdb3e940b32c85af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ad9f423f2b10511d6bdb3e940b32c85af">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:ad9f423f2b10511d6bdb3e940b32c85af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6810b30f175bcc3708bbe816389bca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2f6810b30f175bcc3708bbe816389bca">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a2f6810b30f175bcc3708bbe816389bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b29168c6e8c007fcfe973e6c2600560"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a8b29168c6e8c007fcfe973e6c2600560">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a8b29168c6e8c007fcfe973e6c2600560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886198e8af5a27191a9118ac85a4135"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7886198e8af5a27191a9118ac85a4135">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a7886198e8af5a27191a9118ac85a4135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c88c3fc150b2ca6272dd7619f9e888"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a21c88c3fc150b2ca6272dd7619f9e888">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a21c88c3fc150b2ca6272dd7619f9e888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632bcef7a158890590c0983b7b2dc11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0632bcef7a158890590c0983b7b2dc11">shape_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a0632bcef7a158890590c0983b7b2dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66880f9471932ba9eca38086f2a2f457"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a66880f9471932ba9eca38086f2a2f457">shape_4th_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a66880f9471932ba9eca38086f2a2f457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81434b7f789d58de174332cf418fc715"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a81434b7f789d58de174332cf418fc715">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const override</td></tr>
<tr class="separator:a81434b7f789d58de174332cf418fc715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d99a0ab9afd229cf814b9d828b44a2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a76d99a0ab9afd229cf814b9d828b44a2">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a76d99a0ab9afd229cf814b9d828b44a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e16265d9cd2695aa478b764e7e178"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7f0e16265d9cd2695aa478b764e7e178">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const override</td></tr>
<tr class="separator:a7f0e16265d9cd2695aa478b764e7e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b3955be5f0a0dd00613863663ad37"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa78b3955be5f0a0dd00613863663ad37">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:aa78b3955be5f0a0dd00613863663ad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c24e15d2cc5acc418b0f5871e03e6f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae0c24e15d2cc5acc418b0f5871e03e6f">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:ae0c24e15d2cc5acc418b0f5871e03e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e79aafafe7cfa71d5527326541e720"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a30e79aafafe7cfa71d5527326541e720">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const override</td></tr>
<tr class="separator:a30e79aafafe7cfa71d5527326541e720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407cfce59711c10f48ebabc78327e79d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a407cfce59711c10f48ebabc78327e79d">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a407cfce59711c10f48ebabc78327e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc5c4bf19afec1c55d13d3a81c03a75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0dc5c4bf19afec1c55d13d3a81c03a75">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a0dc5c4bf19afec1c55d13d3a81c03a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2f2d3af8769dfcb13ec1ab96d669d1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6a2f2d3af8769dfcb13ec1ab96d669d1">get_constant_modes</a> () const override</td></tr>
<tr class="separator:a6a2f2d3af8769dfcb13ec1ab96d669d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ced808c3e615b5a3413eea85e254a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a158ced808c3e615b5a3413eea85e254a">FESystem</a> ()=delete</td></tr>
<tr class="separator:a158ced808c3e615b5a3413eea85e254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd69b25bd2dab03bcd565930aceaea33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acd69b25bd2dab03bcd565930aceaea33">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const unsigned <a class="el" href="classint.html">int</a> n_elements)</td></tr>
<tr class="separator:acd69b25bd2dab03bcd565930aceaea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af422559e139959f2025124afba835c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af422559e139959f2025124afba835c89">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2)</td></tr>
<tr class="separator:af422559e139959f2025124afba835c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a51c67b7c8c1eb84175337c47d0b3afd3">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3)</td></tr>
<tr class="separator:a51c67b7c8c1eb84175337c47d0b3afd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac385e7885b5e9d9e26967a3fa783391b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac385e7885b5e9d9e26967a3fa783391b">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4)</td></tr>
<tr class="separator:ac385e7885b5e9d9e26967a3fa783391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01de107675f319789f2fa70fe6ecf55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa01de107675f319789f2fa70fe6ecf55">FESystem</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const unsigned <a class="el" href="classint.html">int</a> n1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, const unsigned <a class="el" href="classint.html">int</a> n2, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe3, const unsigned <a class="el" href="classint.html">int</a> n3, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe4, const unsigned <a class="el" href="classint.html">int</a> n4, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe5, const unsigned <a class="el" href="classint.html">int</a> n5)</td></tr>
<tr class="separator:aa01de107675f319789f2fa70fe6ecf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a83c7bc44f43e75d7d3750cd6c3bce89b">FESystem</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:a83c7bc44f43e75d7d3750cd6c3bce89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplParams" colspan="2">template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </td></tr>
<tr class="memitem:a6e27f91193d25f03da55f2438f1d0f00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem</a> (FEPairs &amp;&amp;... fe_pairs)</td></tr>
<tr class="separator:a6e27f91193d25f03da55f2438f1d0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0e2aa0e6bd118482b13a5da73d125a4c">FESystem</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a0e2aa0e6bd118482b13a5da73d125a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305628a44a4a6318b4077ac0236fca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1305628a44a4a6318b4077ac0236fca7">FESystem</a> (const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:a1305628a44a4a6318b4077ac0236fca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae4a5b073e0eb8197845ead711fa09ab2">FESystem</a> (<a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;other_fe_system) noexcept</td></tr>
<tr class="separator:ae4a5b073e0eb8197845ead711fa09ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16ae6333666b8d042306c257f6dc286"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af16ae6333666b8d042306c257f6dc286">~FESystem</a> () override=default</td></tr>
<tr class="separator:af16ae6333666b8d042306c257f6dc286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bead461257e10db3b5200b12dbaa13a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a4bead461257e10db3b5200b12dbaa13a">get_name</a> () const override</td></tr>
<tr class="separator:a4bead461257e10db3b5200b12dbaa13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8f25e0f645ff56370acded9160e0f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a3ce8f25e0f645ff56370acded9160e0f">clone</a> () const override</td></tr>
<tr class="separator:a3ce8f25e0f645ff56370acded9160e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567cacda250362348c58d4b5dbeb4d16"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a567cacda250362348c58d4b5dbeb4d16">requires_update_flags</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:a567cacda250362348c58d4b5dbeb4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0943cddd61aec42370ee37f27ba385"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a9d0943cddd61aec42370ee37f27ba385">get_sub_fe</a> (const unsigned <a class="el" href="classint.html">int</a> first_component, const unsigned <a class="el" href="classint.html">int</a> n_selected_components) const override</td></tr>
<tr class="separator:a9d0943cddd61aec42370ee37f27ba385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ffba94f76a56e45ecb13dddc59fce8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac0ffba94f76a56e45ecb13dddc59fce8">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ac0ffba94f76a56e45ecb13dddc59fce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01d292b9183fb0db6345dd65986fa08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac01d292b9183fb0db6345dd65986fa08">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:ac01d292b9183fb0db6345dd65986fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f0ca95fef98a5a795ba78da7797b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a226f0ca95fef98a5a795ba78da7797b0">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a226f0ca95fef98a5a795ba78da7797b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f423f2b10511d6bdb3e940b32c85af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ad9f423f2b10511d6bdb3e940b32c85af">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:ad9f423f2b10511d6bdb3e940b32c85af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6810b30f175bcc3708bbe816389bca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2f6810b30f175bcc3708bbe816389bca">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a2f6810b30f175bcc3708bbe816389bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b29168c6e8c007fcfe973e6c2600560"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a8b29168c6e8c007fcfe973e6c2600560">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a8b29168c6e8c007fcfe973e6c2600560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886198e8af5a27191a9118ac85a4135"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7886198e8af5a27191a9118ac85a4135">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a7886198e8af5a27191a9118ac85a4135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c88c3fc150b2ca6272dd7619f9e888"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a21c88c3fc150b2ca6272dd7619f9e888">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a21c88c3fc150b2ca6272dd7619f9e888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632bcef7a158890590c0983b7b2dc11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0632bcef7a158890590c0983b7b2dc11">shape_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a0632bcef7a158890590c0983b7b2dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66880f9471932ba9eca38086f2a2f457"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a66880f9471932ba9eca38086f2a2f457">shape_4th_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a66880f9471932ba9eca38086f2a2f457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81434b7f789d58de174332cf418fc715"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a81434b7f789d58de174332cf418fc715">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const override</td></tr>
<tr class="separator:a81434b7f789d58de174332cf418fc715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d99a0ab9afd229cf814b9d828b44a2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a76d99a0ab9afd229cf814b9d828b44a2">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a76d99a0ab9afd229cf814b9d828b44a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e16265d9cd2695aa478b764e7e178"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7f0e16265d9cd2695aa478b764e7e178">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const override</td></tr>
<tr class="separator:a7f0e16265d9cd2695aa478b764e7e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b3955be5f0a0dd00613863663ad37"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa78b3955be5f0a0dd00613863663ad37">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:aa78b3955be5f0a0dd00613863663ad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c24e15d2cc5acc418b0f5871e03e6f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae0c24e15d2cc5acc418b0f5871e03e6f">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const override</td></tr>
<tr class="separator:ae0c24e15d2cc5acc418b0f5871e03e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e79aafafe7cfa71d5527326541e720"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a30e79aafafe7cfa71d5527326541e720">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const override</td></tr>
<tr class="separator:a30e79aafafe7cfa71d5527326541e720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407cfce59711c10f48ebabc78327e79d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a407cfce59711c10f48ebabc78327e79d">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const override</td></tr>
<tr class="separator:a407cfce59711c10f48ebabc78327e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc5c4bf19afec1c55d13d3a81c03a75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a0dc5c4bf19afec1c55d13d3a81c03a75">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a0dc5c4bf19afec1c55d13d3a81c03a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2f2d3af8769dfcb13ec1ab96d669d1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6a2f2d3af8769dfcb13ec1ab96d669d1">get_constant_modes</a> () const override</td></tr>
<tr class="separator:a6a2f2d3af8769dfcb13ec1ab96d669d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions to support hp @{</h2></td></tr>
<tr class="memitem:a8db3bc88ad730296f67027e1e5f4cd59"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a8db3bc88ad730296f67027e1e5f4cd59">invalid_face_number</a> = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></td></tr>
<tr class="separator:a8db3bc88ad730296f67027e1e5f4cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9fa9ff1f607cef689093930b99fc4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::unique_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa3e9fa9ff1f607cef689093930b99fc4">base_elements</a></td></tr>
<tr class="separator:aa3e9fa9ff1f607cef689093930b99fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ed3350a24760f4e6c74854b171279"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ade4ed3350a24760f4e6c74854b171279">generalized_support_points_index_table</a></td></tr>
<tr class="separator:ade4ed3350a24760f4e6c74854b171279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15db43093d0228707327d98ff45bc533"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a15db43093d0228707327d98ff45bc533">mutex</a></td></tr>
<tr class="separator:a15db43093d0228707327d98ff45bc533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f9aed2c32be9a09208c64f73b54aa8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ae9f9aed2c32be9a09208c64f73b54aa8">FE_Enriched&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:ae9f9aed2c32be9a09208c64f73b54aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d083777a26e139e566a666e0091e7e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ab5d083777a26e139e566a666e0091e7e">hp_constraints_are_implemented</a> () const override</td></tr>
<tr class="separator:ab5d083777a26e139e566a666e0091e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a4d4886f54ebe3c3169b26b82e0858"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a60a4d4886f54ebe3c3169b26b82e0858">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a60a4d4886f54ebe3c3169b26b82e0858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5031867f79f76ae1065bbf6427e692"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#abc5031867f79f76ae1065bbf6427e692">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:abc5031867f79f76ae1065bbf6427e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99ac38fdabea78d1b2eb15cc413d14f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ad99ac38fdabea78d1b2eb15cc413d14f">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:ad99ac38fdabea78d1b2eb15cc413d14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bc69e0a928673d093743af96ecb8ce"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a50bc69e0a928673d093743af96ecb8ce">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:a50bc69e0a928673d093743af96ecb8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d39d3c9635f9e2ac013d3a12136c5d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a23d39d3c9635f9e2ac013d3a12136c5d">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a23d39d3c9635f9e2ac013d3a12136c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc005a9584d52b4a1e42d8f62840b8df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#abc005a9584d52b4a1e42d8f62840b8df">compare_for_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> codim=0) const override final</td></tr>
<tr class="separator:abc005a9584d52b4a1e42d8f62840b8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fffa81396f85e6a7b6b1ff6923b21a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a4fffa81396f85e6a7b6b1ff6923b21a2">convert_generalized_support_point_values_to_dof_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;support_point_values, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_values) const override</td></tr>
<tr class="separator:a4fffa81396f85e6a7b6b1ff6923b21a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dba139aa845dac7f363c23d8a09792"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a44dba139aa845dac7f363c23d8a09792">memory_consumption</a> () const override</td></tr>
<tr class="separator:a44dba139aa845dac7f363c23d8a09792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928be8e2a0821ee9ce6b49d8e6af31e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a928be8e2a0821ee9ce6b49d8e6af31e4">hp_constraints_are_implemented</a> () const override</td></tr>
<tr class="separator:a928be8e2a0821ee9ce6b49d8e6af31e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8da51192aa2016c12acaae3553c5f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acc8da51192aa2016c12acaae3553c5f9">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:acc8da51192aa2016c12acaae3553c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cec45533b2bc8ad05563316cdd244d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac6cec45533b2bc8ad05563316cdd244d">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:ac6cec45533b2bc8ad05563316cdd244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743be5a59591e0746df95a660ca868e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2743be5a59591e0746df95a660ca868e">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:a2743be5a59591e0746df95a660ca868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376198fb1a52db80d3eb59bdaa19d27"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2376198fb1a52db80d3eb59bdaa19d27">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:a2376198fb1a52db80d3eb59bdaa19d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd093ee5bdcbc956d49307f6a905975"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a5bd093ee5bdcbc956d49307f6a905975">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a5bd093ee5bdcbc956d49307f6a905975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596cd1dbcdad862b8ee5611c961fc1c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a596cd1dbcdad862b8ee5611c961fc1c7">compare_for_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> codim=0) const override final</td></tr>
<tr class="separator:a596cd1dbcdad862b8ee5611c961fc1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1fe3f9c386185c9e534a773f6bc8bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6b1fe3f9c386185c9e534a773f6bc8bb">convert_generalized_support_point_values_to_dof_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;support_point_values, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_values) const override</td></tr>
<tr class="separator:a6b1fe3f9c386185c9e534a773f6bc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee119185633ea5d7c1c94f1ff29dea1b"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aee119185633ea5d7c1c94f1ff29dea1b">memory_consumption</a> () const override</td></tr>
<tr class="separator:aee119185633ea5d7c1c94f1ff29dea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1011888f2cf239284408947ca57f0d00"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1011888f2cf239284408947ca57f0d00">get_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a1011888f2cf239284408947ca57f0d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a69b6a5609cd010d1db0fdcb906a02f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1a69b6a5609cd010d1db0fdcb906a02f">get_face_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a1a69b6a5609cd010d1db0fdcb906a02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12fe280e7d0b92e65a94381221ccb0b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ab12fe280e7d0b92e65a94381221ccb0b">get_subface_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ab12fe280e7d0b92e65a94381221ccb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd17d235114948d7f6e4d9b5631bc22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aebd17d235114948d7f6e4d9b5631bc22">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:aebd17d235114948d7f6e4d9b5631bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb9cd153953b0b57e7319069525931"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#adecb9cd153953b0b57e7319069525931">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:adecb9cd153953b0b57e7319069525931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4297067cdc2ad6bf1c9c5050590cfa2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a4297067cdc2ad6bf1c9c5050590cfa2f">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a4297067cdc2ad6bf1c9c5050590cfa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplParams" colspan="2">template&lt;int dim_1&gt; </td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1642039a2a407d409fff5d957c33f8fc">compute_fill</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;quadrature, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_data, const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a1642039a2a407d409fff5d957c33f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1da7b364721481c737863dd13fd37"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#adde1da7b364721481c737863dd13fd37">get_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:adde1da7b364721481c737863dd13fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822e18d3891e859beaaa0d6d1fde1ce"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af822e18d3891e859beaaa0d6d1fde1ce">get_face_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:af822e18d3891e859beaaa0d6d1fde1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5a18f327f8fc2cc89e53d4f3eb02c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7be5a18f327f8fc2cc89e53d4f3eb02c">get_subface_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a7be5a18f327f8fc2cc89e53d4f3eb02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c78ecdd66c27bb01f38c86fd1158a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a47c78ecdd66c27bb01f38c86fd1158a2">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a47c78ecdd66c27bb01f38c86fd1158a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601019e75e79e6924ed29632986186a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a601019e75e79e6924ed29632986186a5">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a601019e75e79e6924ed29632986186a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a2eda09c8bd983833192803c257b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ab64a2eda09c8bd983833192803c257b9">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ab64a2eda09c8bd983833192803c257b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplParams" colspan="2">template&lt;int dim_1&gt; </td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1642039a2a407d409fff5d957c33f8fc">compute_fill</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;quadrature, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_data, const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a1642039a2a407d409fff5d957c33f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba222014c6b71fe5484f4ef7c57b18be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aba222014c6b71fe5484f4ef7c57b18be">initialize</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:aba222014c6b71fe5484f4ef7c57b18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa530a01111c2b0dfe60dec3ebd2d3d26">build_interface_constraints</a> ()</td></tr>
<tr class="separator:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb26650d3fef364887f1c73aa171faa2"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:abb26650d3fef364887f1c73aa171faa2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#abb26650d3fef364887f1c73aa171faa2">hp_object_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:abb26650d3fef364887f1c73aa171faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba222014c6b71fe5484f4ef7c57b18be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aba222014c6b71fe5484f4ef7c57b18be">initialize</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:aba222014c6b71fe5484f4ef7c57b18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa530a01111c2b0dfe60dec3ebd2d3d26">build_interface_constraints</a> ()</td></tr>
<tr class="separator:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada617df314b4577743306e837533bb20"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:ada617df314b4577743306e837533bb20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#ada617df314b4577743306e837533bb20">hp_object_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ada617df314b4577743306e837533bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions to support hp</h2></td></tr>
<tr class="memitem:a928be8e2a0821ee9ce6b49d8e6af31e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a928be8e2a0821ee9ce6b49d8e6af31e4">hp_constraints_are_implemented</a> () const override</td></tr>
<tr class="separator:a928be8e2a0821ee9ce6b49d8e6af31e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8da51192aa2016c12acaae3553c5f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#acc8da51192aa2016c12acaae3553c5f9">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:acc8da51192aa2016c12acaae3553c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cec45533b2bc8ad05563316cdd244d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ac6cec45533b2bc8ad05563316cdd244d">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:ac6cec45533b2bc8ad05563316cdd244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743be5a59591e0746df95a660ca868e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2743be5a59591e0746df95a660ca868e">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:a2743be5a59591e0746df95a660ca868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376198fb1a52db80d3eb59bdaa19d27"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a2376198fb1a52db80d3eb59bdaa19d27">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const override</td></tr>
<tr class="separator:a2376198fb1a52db80d3eb59bdaa19d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd093ee5bdcbc956d49307f6a905975"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a5bd093ee5bdcbc956d49307f6a905975">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const override</td></tr>
<tr class="separator:a5bd093ee5bdcbc956d49307f6a905975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596cd1dbcdad862b8ee5611c961fc1c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a596cd1dbcdad862b8ee5611c961fc1c7">compare_for_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> codim=0) const override final</td></tr>
<tr class="separator:a596cd1dbcdad862b8ee5611c961fc1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1fe3f9c386185c9e534a773f6bc8bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a6b1fe3f9c386185c9e534a773f6bc8bb">convert_generalized_support_point_values_to_dof_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;support_point_values, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_values) const override</td></tr>
<tr class="separator:a6b1fe3f9c386185c9e534a773f6bc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee119185633ea5d7c1c94f1ff29dea1b"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aee119185633ea5d7c1c94f1ff29dea1b">memory_consumption</a> () const override</td></tr>
<tr class="separator:aee119185633ea5d7c1c94f1ff29dea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1da7b364721481c737863dd13fd37"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#adde1da7b364721481c737863dd13fd37">get_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:adde1da7b364721481c737863dd13fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822e18d3891e859beaaa0d6d1fde1ce"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#af822e18d3891e859beaaa0d6d1fde1ce">get_face_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:af822e18d3891e859beaaa0d6d1fde1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5a18f327f8fc2cc89e53d4f3eb02c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a7be5a18f327f8fc2cc89e53d4f3eb02c">get_subface_data</a> (const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a7be5a18f327f8fc2cc89e53d4f3eb02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c78ecdd66c27bb01f38c86fd1158a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a47c78ecdd66c27bb01f38c86fd1158a2">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a47c78ecdd66c27bb01f38c86fd1158a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601019e75e79e6924ed29632986186a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#a601019e75e79e6924ed29632986186a5">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a601019e75e79e6924ed29632986186a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a2eda09c8bd983833192803c257b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#ab64a2eda09c8bd983833192803c257b9">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ab64a2eda09c8bd983833192803c257b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplParams" colspan="2">template&lt;int dim_1&gt; </td></tr>
<tr class="memitem:a1642039a2a407d409fff5d957c33f8fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#a1642039a2a407d409fff5d957c33f8fc">compute_fill</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;quadrature, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;mapping_internal, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;fe_data, const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a1642039a2a407d409fff5d957c33f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba222014c6b71fe5484f4ef7c57b18be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aba222014c6b71fe5484f4ef7c57b18be">initialize</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:aba222014c6b71fe5484f4ef7c57b18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html#aa530a01111c2b0dfe60dec3ebd2d3d26">build_interface_constraints</a> ()</td></tr>
<tr class="separator:aa530a01111c2b0dfe60dec3ebd2d3d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada617df314b4577743306e837533bb20"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:ada617df314b4577743306e837533bb20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFESystem.html#ada617df314b4577743306e837533bb20">hp_object_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ada617df314b4577743306e837533bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class FESystem&lt; dim, spacedim &gt;</h3>

<p>This class provides an interface to group several elements together into one, vector-valued element. As example, consider the Taylor-Hood element that is used for the solution of the Stokes and Navier-Stokes equations: There, the velocity (of which there are as many components as the dimension \(d\) of the domain) is discretized with \(Q_2\) elements and the pressure with \(Q_1\) elements. Mathematically, the finite element space for the coupled problem is then often written as \(V_h = Q_2^d \times Q_1\) where the exponentiation is understood to be the tensor product of spaces</p>
<ul>
<li>i.e., in 2d, we have \(V_h=Q_2\times Q_2\times Q_1\)</li>
<li>and tensor products lead to vectors where each component of the vector-valued function space corresponds to a scalar function in one of the \(Q_2\) or \(Q_1\) spaces. Using the <a class="el" href="classFESystem.html">FESystem</a> class, this space is created using</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> taylor_hood_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim,   <span class="comment">// velocity components</span></div>
<div class="line">                              <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));      <span class="comment">// pressure component</span></div>
</div><!-- fragment --><p> The creation of this element here corresponds to taking tensor-product powers of the \(Q_2\) element in the first line of the list of arguments to the <a class="el" href="classFESystem.html">FESystem</a> constructor, and then concatenation via another tensor product with the element in the second line. This kind of construction is used, for example, in the <a class="el" href="step_22.html">step-22</a> tutorial program. Similarly, <a class="el" href="step_8.html">step-8</a> solves an elasticity equation where we need to solve for the displacement of a solid object. The displacement again has \(d\) components if the domain is \(d\) -dimensional, and so the combined finite element is created using</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> displacement_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1)^dim);</div>
</div><!-- fragment --><p> where now each (vector) component of the combined element corresponds to a \(Q_1\) space. To the outside world, <a class="el" href="classFESystem.html">FESystem</a> objects look just like a usual finite element object, they just happen to be composed of several other finite elements that are possibly of different type. These "base
elements" can themselves have multiple components and, in particular, could also be vector-valued</p>
<ul>
<li>for example, if one of the base elements is an <a class="el" href="classFESystem.html">FESystem</a> itself (see also below). An example is given in the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a>, when using the "tensor product" strategy. Vector valued elements are discussed in a number of tutorial programs, for example <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_20.html">step-20</a> , <a class="el" href="step_21.html">step-21</a> , <a class="el" href="step_22.html">step-22</a> , and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. <dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<h3><a class="el" href="classFESystem.html">FESystem</a>, components and blocks</h3>
</li>
</ul>
<p>An <a class="el" href="classFESystem.html">FESystem</a>, except in the most trivial case, produces a vector-valued finite element with several components. The number of components n_components() corresponds to the dimension of the solution function in the PDE system, and correspondingly also to the number of equations your PDE system has. For example, the mixed Laplace system covered in <a class="el" href="step_20.html">step-20</a> has \(d+1\) components in \(d\) space dimensions: the scalar pressure and the \(d\) components of the velocity vector. Similarly, the elasticity equation covered in <a class="el" href="step_8.html">step-8</a> has \(d\) components in \(d\) space dimensions. In general, the number of components of a <a class="el" href="classFESystem.html">FESystem</a> element is the accumulated number of components of all base elements times their multiplicities. A bit more on components is also given in the <a class="el" href="DEALGlossary.html#GlossComponent">glossary entry on components</a>. While the concept of components is important from the viewpoint of a partial differential equation, the finite element side looks a bit different Since not only <a class="el" href="classFESystem.html">FESystem</a>, but also vector-valued elements like <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>, have several components. The concept needed here is a <a class="el" href="DEALGlossary.html#GlossBlock">block</a>. Each block encompasses the set of degrees of freedom associated with a single base element of an <a class="el" href="classFESystem.html">FESystem</a>, where base elements with multiplicities count multiple times. These blocks are usually addressed using the information in <a class="el" href="classDoFHandler.html#a76c71bc8d38639321ff571661de296dd">DoFHandler::block_info()</a>. The number of blocks of a <a class="el" href="classFESystem.html">FESystem</a> object is simply the sum of all multiplicities of base elements and is given by <a class="el" href="namespaceMatrixFreeOperators_1_1BlockHelper.html#a7828d18b23c938f419a9869ad940f92f">n_blocks()</a>. For example, the <a class="el" href="classFESystem.html">FESystem</a> for the Taylor-Hood element for the three-dimensional Stokes problem can be built using the code</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a> u(2);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a> p(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(u,3, p,1);</div>
</div><!-- fragment --><p> or more concisely via</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(<a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(2),3,</div>
<div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(1),1);</div>
</div><!-- fragment --><p> or even shorter (mimicking the mathematical notation that we are dealing with a \(Q_2^3 \times Q_1\) element):</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(<a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(2)^3,</div>
<div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(1));</div>
</div><!-- fragment --><p>This example creates an <a class="el" href="classFESystem.html">FESystem</a> <code>sys1</code> with four components, three for the velocity components and one for the pressure, and also four blocks with the degrees of freedom of each of the velocity components and the pressure in a separate block each. The number of blocks is four since the first base element is repeated three times. On the other hand, a Taylor-Hood element can also be constructed using</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>(u,3);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys2(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>, p);</div>
</div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> <code>sys2</code> created here has the same four components, but the degrees of freedom are distributed into only two blocks. The first block has all velocity degrees of freedom from <code>U</code>, while the second block contains the pressure degrees of freedom. Note that while <code>U</code> itself has 3 blocks, the <a class="el" href="classFESystem.html">FESystem</a> <code>sys2</code> does not attempt to split <code>U</code> into its base elements but considers it a block of its own. By blocking all velocities into one system first as in <code>sys2</code>, we achieve the same block structure that would be generated if instead of using a \(Q_2^3\) element for the velocities we had used vector-valued base elements, for instance like using a mixed discretization of Darcy's law using</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas&lt;3&gt;</a> u(1);</div>
<div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;3&gt;</a> p(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys3(u, p);</div>
</div><!-- fragment --><p>This example also produces a system with four components, but only two blocks. In most cases, the composed element behaves as if it were a usual element. It just has more degrees of freedom than most of the "common" elements. However the underlying structure is visible in the restriction, prolongation and interface constraint matrices, which do not couple the degrees of freedom of the base elements. E.g. the continuity requirement is imposed for the shape functions of the subobjects separately; no requirement exist between shape functions of different subobjects, i.e. in the above example: on a hanging node, the respective value of the <code>u</code> velocity is only coupled to <code>u</code> at the vertices and the line on the larger cell next to this vertex, but there is no interaction with <code>v</code> and <code>w</code> of this or the other cell.</p>
<h3>Internal information on numbering of degrees of freedom</h3>
<p>The overall numbering of degrees of freedom is as follows: for each subobject (vertex, line, quad, or hex), the degrees of freedom are numbered such that we run over all subelements first, before turning for the next dof on this subobject or for the next subobject. For example, for an element of three components in one space dimension, the first two components being cubic lagrange elements and the third being a quadratic lagrange element, the ordering for the system <code>s=(u,v,p)</code> is: </p><ul>
<li>
First vertex: <code>u0, v0, p0 = s0, s1, s2</code> </li>
<li>
Second vertex: <code>u1, v1, p1 = s3, s4, s5</code> </li>
<li>
First component on the line: <code>u2, u3 = s4, s5</code> </li>
<li>
Second component on the line: <code>v2, v3 = s6, s7</code>. </li>
<li>
Third component on the line: <code>p2 = s8</code>. </li>
</ul>
<p>That said, you should not rely on this numbering in your application as these internals might change in future. Rather use the functions system_to_component_index() and component_to_system_index(). For more information on the template parameter <code>spacedim</code> see the documentation of <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>This class provides an interface to group several elements together into one, vector-valued element. As example, consider the Taylor-Hood element that is used for the solution of the Stokes and Navier-Stokes equations: There, the velocity (of which there are as many components as the dimension \(d\) of the domain) is discretized with \(Q_2\) elements and the pressure with \(Q_1\) elements. Mathematically, the finite element space for the coupled problem is then often written as \(V_h = Q_2^d \times Q_1\) where the exponentiation is understood to be the tensor product of spaces &ndash; i.e., in 2d, we have \(V_h=Q_2\times Q_2\times Q_1\) &ndash; and tensor products lead to vectors where each component of the vector-valued function space corresponds to a scalar function in one of the \(Q_2\) or \(Q_1\) spaces. Using the <a class="el" href="classFESystem.html">FESystem</a> class, this space is created using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> taylor_hood_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim,   <span class="comment">// velocity components</span></div>
<div class="line">                              <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));      <span class="comment">// pressure component</span></div>
</div><!-- fragment --><p> The creation of this element here corresponds to taking tensor-product powers of the \(Q_2\) element in the first line of the list of arguments to the <a class="el" href="classFESystem.html">FESystem</a> constructor, and then concatenation via another tensor product with the element in the second line. This kind of construction is used, for example, in the <a class="el" href="step_22.html">step-22</a> tutorial program.</p>
<p>Similarly, <a class="el" href="step_8.html">step-8</a> solves an elasticity equation where we need to solve for the displacement of a solid object. The displacement again has \(d\) components if the domain is \(d\)-dimensional, and so the combined finite element is created using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> displacement_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1)^dim);</div>
</div><!-- fragment --><p> where now each (vector) component of the combined element corresponds to a \(Q_1\) space.</p>
<p>To the outside world, <a class="el" href="classFESystem.html">FESystem</a> objects look just like a usual finite element object, they just happen to be composed of several other finite elements that are possibly of different type. These "base elements" can themselves have multiple components and, in particular, could also be vector-valued &ndash; for example, if one of the base elements is an <a class="el" href="classFESystem.html">FESystem</a> itself (see also below). An example is given in the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a>, when using the "tensor product" strategy.</p>
<p>Vector valued elements are discussed in a number of tutorial programs, for example <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_21.html">step-21</a>, <a class="el" href="step_22.html">step-22</a>, and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<h3><a class="el" href="classFESystem.html">FESystem</a>, components and blocks</h3>
<p>An <a class="el" href="classFESystem.html">FESystem</a>, except in the most trivial case, produces a vector-valued finite element with several components. The number of components n_components() corresponds to the dimension of the solution function in the PDE system, and correspondingly also to the number of equations your PDE system has. For example, the mixed Laplace system covered in <a class="el" href="step_20.html">step-20</a> has \(d+1\) components in \(d\) space dimensions: the scalar pressure and the \(d\) components of the velocity vector. Similarly, the elasticity equation covered in <a class="el" href="step_8.html">step-8</a> has \(d\) components in \(d\) space dimensions. In general, the number of components of a <a class="el" href="classFESystem.html">FESystem</a> element is the accumulated number of components of all base elements times their multiplicities. A bit more on components is also given in the <a class="el" href="DEALGlossary.html#GlossComponent">glossary entry on components</a>.</p>
<p>While the concept of components is important from the viewpoint of a partial differential equation, the finite element side looks a bit different Since not only <a class="el" href="classFESystem.html">FESystem</a>, but also vector-valued elements like <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>, have several components. The concept needed here is a <a class="el" href="DEALGlossary.html#GlossBlock">block</a>. Each block encompasses the set of degrees of freedom associated with a single base element of an <a class="el" href="classFESystem.html">FESystem</a>, where base elements with multiplicities count multiple times. These blocks are usually addressed using the information in <a class="el" href="classDoFHandler.html#a76c71bc8d38639321ff571661de296dd">DoFHandler::block_info()</a>. The number of blocks of a <a class="el" href="classFESystem.html">FESystem</a> object is simply the sum of all multiplicities of base elements and is given by <a class="el" href="namespaceMatrixFreeOperators_1_1BlockHelper.html#a7828d18b23c938f419a9869ad940f92f">n_blocks()</a>.</p>
<p>For example, the <a class="el" href="classFESystem.html">FESystem</a> for the Taylor-Hood element for the three-dimensional Stokes problem can be built using the code </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a> u(2);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a> p(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(u,3, p,1);</div>
</div><!-- fragment --><p> or more concisely via </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(<a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(2),3,</div>
<div class="line">                 <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(1),1);</div>
</div><!-- fragment --><p> or even shorter (mimicking the mathematical notation that we are dealing with a \(Q_2^3 \times Q_1\) element): </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys1(<a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(2)^3,</div>
<div class="line">                 <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(1));</div>
</div><!-- fragment --><p>This example creates an <a class="el" href="classFESystem.html">FESystem</a> <code>sys1</code> with four components, three for the velocity components and one for the pressure, and also four blocks with the degrees of freedom of each of the velocity components and the pressure in a separate block each. The number of blocks is four since the first base element is repeated three times.</p>
<p>On the other hand, a Taylor-Hood element can also be constructed using</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>(u,3);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys2(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>, p);</div>
</div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> <code>sys2</code> created here has the same four components, but the degrees of freedom are distributed into only two blocks. The first block has all velocity degrees of freedom from <code>U</code>, while the second block contains the pressure degrees of freedom. Note that while <code>U</code> itself has 3 blocks, the <a class="el" href="classFESystem.html">FESystem</a> <code>sys2</code> does not attempt to split <code>U</code> into its base elements but considers it a block of its own. By blocking all velocities into one system first as in <code>sys2</code>, we achieve the same block structure that would be generated if instead of using a \(Q_2^3\) element for the velocities we had used vector-valued base elements, for instance like using a mixed discretization of Darcy's law using</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas&lt;3&gt;</a> u(1);</div>
<div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;3&gt;</a> p(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;3&gt;</a> sys3(u, p);</div>
</div><!-- fragment --><p>This example also produces a system with four components, but only two blocks.</p>
<p>In most cases, the composed element behaves as if it were a usual element. It just has more degrees of freedom than most of the "common" elements. However the underlying structure is visible in the restriction, prolongation and interface constraint matrices, which do not couple the degrees of freedom of the base elements. E.g. the continuity requirement is imposed for the shape functions of the subobjects separately; no requirement exist between shape functions of different subobjects, i.e. in the above example: on a hanging node, the respective value of the <code>u</code> velocity is only coupled to <code>u</code> at the vertices and the line on the larger cell next to this vertex, but there is no interaction with <code>v</code> and <code>w</code> of this or the other cell.</p>
<h3>Internal information on numbering of degrees of freedom</h3>
<p>The overall numbering of degrees of freedom is as follows: for each subobject (vertex, line, quad, or hex), the degrees of freedom are numbered such that we run over all subelements first, before turning for the next dof on this subobject or for the next subobject. For example, for an element of three components in one space dimension, the first two components being cubic lagrange elements and the third being a quadratic lagrange element, the ordering for the system <code>s=(u,v,p)</code> is:</p>
<ul>
<li>
First vertex: <code>u0, v0, p0 = s0, s1, s2</code> </li>
<li>
Second vertex: <code>u1, v1, p1 = s3, s4, s5</code> </li>
<li>
First component on the line: <code>u2, u3 = s4, s5</code> </li>
<li>
Second component on the line: <code>v2, v3 = s6, s7</code>. </li>
<li>
Third component on the line: <code>p2 = s8</code>. </li>
</ul>
<p>That said, you should not rely on this numbering in your application as these internals might change in future. Rather use the functions system_to_component_index() and component_to_system_index().</p>
<p>For more information on the template parameter <code>spacedim</code> see the documentation of <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00044">44</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a158ced808c3e615b5a3413eea85e254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ced808c3e615b5a3413eea85e254a">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[1/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete default constructor so that <code><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem(FEPairs &amp;&amp;... fe_pairs)</a></code> is not accidentally picked if no <a class="el" href="classFiniteElement.html">FiniteElement</a> is provided. </p>

</div>
</div>
<a id="acd69b25bd2dab03bcd565930aceaea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd69b25bd2dab03bcd565930aceaea33">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[2/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take a finite element and the number of elements you want to group together using this class. The object <code>fe</code> is not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), 2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object. This constructor (or its variants below) is used in essentially all tutorial programs that deal with vector valued problems. See <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_20.html">step-20</a> , <a class="el" href="step_22.html">step-22</a> and others for use cases. Also see the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>. </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe</td><td>The finite element that will be used to represent the components of this composed element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>An integer denoting how many copies of <code>fe</code> this element should consist of. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00108">108</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="af422559e139959f2025124afba835c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af422559e139959f2025124afba835c89">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[3/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with two base elements. See the other constructor above for an explanation of the general idea of composing elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00127">127</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a51c67b7c8c1eb84175337c47d0b3afd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c67b7c8c1eb84175337c47d0b3afd3">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[4/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with three base elements. See the other constructor above for an explanation of the general idea of composing elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00152">152</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ac385e7885b5e9d9e26967a3fa783391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac385e7885b5e9d9e26967a3fa783391b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[5/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with four base elements. See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00188">188</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="aa01de107675f319789f2fa70fe6ecf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01de107675f319789f2fa70fe6ecf55">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[6/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with five base elements. See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00239">239</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a83c7bc44f43e75d7d3750cd6c3bce89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7bc44f43e75d7d3750cd6c3bce89b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[7/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for any number of base elements. Pointers to the base elements and their multiplicities are passed as vectors to this constructor. The lengths of these vectors are assumed to be equal. As above, the finite element objects pointed to by the first argument are not actually used other than to create copies internally. Consequently, you can delete these pointers immediately again after calling this constructor. </p><h4>How to use this constructor</h4>
<p>Using this constructor is a bit awkward at times because you need to pass two vectors in a place where it may not be straightforward to construct such a vector</p>
<ul>
<li>for example, in the member initializer list of a class with an <a class="el" href="classFESystem.html">FESystem</a> member variable. For example, if your main class looks like this: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (...)  <span class="comment">// what to pass here???</span></div>
<div class="line">{}</div>
</div><!-- fragment --> Using the C++11 language standard (or later) you could do something like this to create an element with four base elements and multiplicities 1, 2, 3 and 4: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (std::vector&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt;*&gt; { <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4) },</div>
<div class="line">      std::vector&lt;unsigned int&gt; { 1, 2, 3, 4 })</div>
<div class="line">{}</div>
</div><!-- fragment --> This creates two vectors in place and initializes them using the initializer list enclosed in braces <code>{ ... }</code> . This code has a problem: it creates four memory leaks because the first vector above is created with pointers to elements that are allocated with <code>new</code> but never destroyed. The solution to the second of these problems is to create two static member functions that can create vectors. Here is an example: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">  create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">  create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; fe_list;</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4));</div>
<div class="line">  <span class="keywordflow">return</span> fe_list;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;unsigned int&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_multiplicities ()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;unsigned int&gt; multiplicities;</div>
<div class="line">  multiplicities.push_back (1);</div>
<div class="line">  multiplicities.push_back (2);</div>
<div class="line">  multiplicities.push_back (3);</div>
<div class="line">  multiplicities.push_back (4);</div>
<div class="line">  <span class="keywordflow">return</span> multiplicities;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (create_fe_list (polynomial_degree),</div>
<div class="line">      create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --> The way this works is that we have two static member functions that create the necessary vectors to pass to the constructor of the member variable <code>fe</code> . They need to be static because they are called during the constructor of <code>MySimulator</code> at a time when the <code>*this</code> object isn't fully constructed and, consequently, regular member functions cannot be called yet. The code above does not solve the problem with the memory leak yet, though: the <code>create_fe_list()</code> function creates a vector of pointers, but nothing destroys these. This is the solution: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>VectorElementDestroyer</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; data;</div>
<div class="line"> </div>
<div class="line">  VectorElementDestroyer(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// destructor to delete the pointers</span></div>
<div class="line">  ~VectorElementDestroyer ();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp; <a class="code" href="classFESystem.html#a1011888f2cf239284408947ca57f0d00">get_data</a> () <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">VectorElementDestroyer(</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers)</div>
<div class="line">:</div>
<div class="line">data(pointers)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">~VectorElementDestroyer ()</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;data.size(); ++i)</div>
<div class="line">  <span class="keyword">delete</span> data[i];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">get_data ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"><span class="keywordflow">return</span> data;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">:</div>
<div class="line">fe (VectorElementDestroyer(create_fe_list (polynomial_degree)).get_data(),</div>
<div class="line">  create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --> In other words, the vector we receive from the <code>create_fe_list()</code> is packed into a temporary object of type <code>VectorElementDestroyer</code> ; we then get the vector from this temporary object immediately to pass it to the constructor of <code>fe</code>; and finally, the <code>VectorElementDestroyer</code> destructor is called at the end of the entire expression (after the constructor of <code>fe</code> has finished) and destroys the elements of the temporary vector. Voila: not short nor elegant, but it works! </li>
</ul>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00292">292</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a6e27f91193d25f03da55f2438f1d0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e27f91193d25f03da55f2438f1d0f00">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[8/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">FEPairs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fe_pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor taking an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,   spacedim&gt;&gt;, unsigned int&gt;</code>. In combination with <a class="el" href="classFiniteElement.html#aa0833eb3ee7cbff916b3d8f3e7558501">FiniteElement::operator^</a>, this allows to construct <a class="el" href="classFESystem.html">FESystem</a> objects as follows: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system ( fe_1^dim, fe_2 );</div>
</div><!-- fragment --><p> The <code>fe_1</code> and <code>fe_2</code> objects are not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object. As a shortcut, this constructor also allows calling </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
</div><!-- fragment --><p> instead of the more explicit </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1)^1);</div>
</div><!-- fragment --><p> In other words, if no multiplicity for an element is explicitly specified via the exponentiation operation, then it is assumed to be one (as one would have expected). </p><dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. Defining this constructor leads to internal compiler errors for Intel compilers prior to 18.0. </dd></dl>

</div>
</div>
<a id="a0e2aa0e6bd118482b13a5da73d125a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2aa0e6bd118482b13a5da73d125a4c">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[9/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above allowing the following syntax: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system = { fe_1^dim, fe_2^1 };</div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. The constructor is just not selected for overload resolution. </dd></dl>

</div>
</div>
<a id="a1305628a44a4a6318b4077ac0236fca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305628a44a4a6318b4077ac0236fca7">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[10/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is deleted, i.e., copying <a class="el" href="classFESystem.html">FESystem</a> objects is not allowed. </p>

</div>
</div>
<a id="ae4a5b073e0eb8197845ead711fa09ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a5b073e0eb8197845ead711fa09ab2">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[11/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other_fe_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l00526">526</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="af16ae6333666b8d042306c257f6dc286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16ae6333666b8d042306c257f6dc286">&#9670;&nbsp;</a></span>~FESystem() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a158ced808c3e615b5a3413eea85e254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ced808c3e615b5a3413eea85e254a">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[12/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete default constructor so that <code><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem(FEPairs &amp;&amp;... fe_pairs)</a></code> is not accidentally picked if no <a class="el" href="classFiniteElement.html">FiniteElement</a> is provided. </p>

</div>
</div>
<a id="acd69b25bd2dab03bcd565930aceaea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd69b25bd2dab03bcd565930aceaea33">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[13/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take a finite element and the number of elements you want to group together using this class.</p>
<p>The object <code>fe</code> is not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), 2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object.</p>
<p>This constructor (or its variants below) is used in essentially all tutorial programs that deal with vector valued problems. See <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_22.html">step-22</a> and others for use cases. Also see the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe</td><td>The finite element that will be used to represent the components of this composed element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>An integer denoting how many copies of <code>fe</code> this element should consist of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af422559e139959f2025124afba835c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af422559e139959f2025124afba835c89">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[14/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with two base elements.</p>
<p>See the other constructor above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="a51c67b7c8c1eb84175337c47d0b3afd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c67b7c8c1eb84175337c47d0b3afd3">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[15/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with three base elements.</p>
<p>See the other constructor above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="ac385e7885b5e9d9e26967a3fa783391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac385e7885b5e9d9e26967a3fa783391b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[16/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with four base elements.</p>
<p>See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="aa01de107675f319789f2fa70fe6ecf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01de107675f319789f2fa70fe6ecf55">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[17/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with five base elements.</p>
<p>See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="a83c7bc44f43e75d7d3750cd6c3bce89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7bc44f43e75d7d3750cd6c3bce89b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[18/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for any number of base elements. Pointers to the base elements and their multiplicities are passed as vectors to this constructor. The lengths of these vectors are assumed to be equal.</p>
<p>As above, the finite element objects pointed to by the first argument are not actually used other than to create copies internally. Consequently, you can delete these pointers immediately again after calling this constructor.</p>
<h4>How to use this constructor</h4>
<p>Using this constructor is a bit awkward at times because you need to pass two vectors in a place where it may not be straightforward to construct such a vector &ndash; for example, in the member initializer list of a class with an <a class="el" href="classFESystem.html">FESystem</a> member variable. For example, if your main class looks like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (...)  <span class="comment">// what to pass here???</span></div>
<div class="line">{}</div>
</div><!-- fragment --><p>Using the C++11 language standard (or later) you could do something like this to create an element with four base elements and multiplicities 1, 2, 3 and 4: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (std::vector&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt;*&gt; { <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4) },</div>
<div class="line">      std::vector&lt;unsigned int&gt; { 1, 2, 3, 4 })</div>
<div class="line">{}</div>
</div><!-- fragment --><p> This creates two vectors in place and initializes them using the initializer list enclosed in braces <code>{ ... }</code>.</p>
<p>This code has a problem: it creates four memory leaks because the first vector above is created with pointers to elements that are allocated with <code>new</code> but never destroyed.</p>
<p>The solution to the second of these problems is to create two static member functions that can create vectors. Here is an example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">  create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">  create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; fe_list;</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4));</div>
<div class="line">  <span class="keywordflow">return</span> fe_list;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;unsigned int&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_multiplicities ()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;unsigned int&gt; multiplicities;</div>
<div class="line">  multiplicities.push_back (1);</div>
<div class="line">  multiplicities.push_back (2);</div>
<div class="line">  multiplicities.push_back (3);</div>
<div class="line">  multiplicities.push_back (4);</div>
<div class="line">  <span class="keywordflow">return</span> multiplicities;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (create_fe_list (polynomial_degree),</div>
<div class="line">      create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --><p>The way this works is that we have two static member functions that create the necessary vectors to pass to the constructor of the member variable <code>fe</code>. They need to be static because they are called during the constructor of <code>MySimulator</code> at a time when the <code>*this</code> object isn't fully constructed and, consequently, regular member functions cannot be called yet.</p>
<p>The code above does not solve the problem with the memory leak yet, though: the <code>create_fe_list()</code> function creates a vector of pointers, but nothing destroys these. This is the solution: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>VectorElementDestroyer</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; data;</div>
<div class="line"> </div>
<div class="line">    VectorElementDestroyer(</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// destructor to delete the pointers</span></div>
<div class="line">    ~VectorElementDestroyer ();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp; <a class="code" href="classFESystem.html#a1011888f2cf239284408947ca57f0d00">get_data</a> () <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">  create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">  create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">VectorElementDestroyer(</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers)</div>
<div class="line">  :</div>
<div class="line">  data(pointers)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">~VectorElementDestroyer ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;data.size(); ++i)</div>
<div class="line">    <span class="keyword">delete</span> data[i];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">get_data ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> data;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">:</div>
<div class="line">fe (VectorElementDestroyer(create_fe_list (polynomial_degree)).get_data(),</div>
<div class="line">    create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --><p>In other words, the vector we receive from the <code>create_fe_list()</code> is packed into a temporary object of type <code>VectorElementDestroyer</code>; we then get the vector from this temporary object immediately to pass it to the constructor of <code>fe</code>; and finally, the <code>VectorElementDestroyer</code> destructor is called at the end of the entire expression (after the constructor of <code>fe</code> has finished) and destroys the elements of the temporary vector. Voila: not short nor elegant, but it works! </p>

</div>
</div>
<a id="a6e27f91193d25f03da55f2438f1d0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e27f91193d25f03da55f2438f1d0f00">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[19/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">FEPairs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fe_pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor taking an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;, unsigned int&gt;</code>. In combination with <a class="el" href="classFiniteElement.html#aa0833eb3ee7cbff916b3d8f3e7558501">FiniteElement::operator^</a>, this allows to construct <a class="el" href="classFESystem.html">FESystem</a> objects as follows: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system ( fe_1^dim, fe_2 );</div>
</div><!-- fragment --><p>The <code>fe_1</code> and <code>fe_2</code> objects are not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object.</p>
<p>As a shortcut, this constructor also allows calling </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
</div><!-- fragment --><p> instead of the more explicit </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1)^1);</div>
</div><!-- fragment --><p> In other words, if no multiplicity for an element is explicitly specified via the exponentiation operation, then it is assumed to be one (as one would have expected).</p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. Defining this constructor leads to internal compiler errors for Intel compilers prior to 18.0. </dd></dl>

</div>
</div>
<a id="a0e2aa0e6bd118482b13a5da73d125a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2aa0e6bd118482b13a5da73d125a4c">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[20/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above allowing the following syntax: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system = { fe_1^dim, fe_2^1 };</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. The constructor is just not selected for overload resolution. </dd></dl>

</div>
</div>
<a id="a1305628a44a4a6318b4077ac0236fca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305628a44a4a6318b4077ac0236fca7">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[21/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is deleted, i.e., copying <a class="el" href="classFESystem.html">FESystem</a> objects is not allowed. </p>

</div>
</div>
<a id="ae4a5b073e0eb8197845ead711fa09ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a5b073e0eb8197845ead711fa09ab2">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[22/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other_fe_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="origin_2fe_2fe__system_8h_source.html#l00581">581</a> of file <a class="el" href="origin_2fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="af16ae6333666b8d042306c257f6dc286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16ae6333666b8d042306c257f6dc286">&#9670;&nbsp;</a></span>~FESystem() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a158ced808c3e615b5a3413eea85e254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ced808c3e615b5a3413eea85e254a">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[23/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete default constructor so that <code><a class="el" href="classFESystem.html#a6e27f91193d25f03da55f2438f1d0f00">FESystem(FEPairs &amp;&amp;... fe_pairs)</a></code> is not accidentally picked if no <a class="el" href="classFiniteElement.html">FiniteElement</a> is provided. </p>

</div>
</div>
<a id="acd69b25bd2dab03bcd565930aceaea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd69b25bd2dab03bcd565930aceaea33">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[24/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take a finite element and the number of elements you want to group together using this class. The object <code>fe</code> is not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), 2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object. This constructor (or its variants below) is used in essentially all tutorial programs that deal with vector valued problems. See <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_20.html">step-20</a> , <a class="el" href="step_22.html">step-22</a> and others for use cases. Also see the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>. </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe</td><td>The finite element that will be used to represent the components of this composed element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>An integer denoting how many copies of <code>fe</code> this element should consist of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af422559e139959f2025124afba835c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af422559e139959f2025124afba835c89">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[25/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with two base elements. See the other constructor above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="a51c67b7c8c1eb84175337c47d0b3afd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c67b7c8c1eb84175337c47d0b3afd3">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[26/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with three base elements. See the other constructor above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="ac385e7885b5e9d9e26967a3fa783391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac385e7885b5e9d9e26967a3fa783391b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[27/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with four base elements. See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="aa01de107675f319789f2fa70fe6ecf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01de107675f319789f2fa70fe6ecf55">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[28/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for mixed discretizations with five base elements. See the first of the other constructors above for an explanation of the general idea of composing elements. </p>

</div>
</div>
<a id="a83c7bc44f43e75d7d3750cd6c3bce89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7bc44f43e75d7d3750cd6c3bce89b">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[29/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for any number of base elements. Pointers to the base elements and their multiplicities are passed as vectors to this constructor. The lengths of these vectors are assumed to be equal. As above, the finite element objects pointed to by the first argument are not actually used other than to create copies internally. Consequently, you can delete these pointers immediately again after calling this constructor. </p><h4>How to use this constructor</h4>
<p>Using this constructor is a bit awkward at times because you need to pass two vectors in a place where it may not be straightforward to construct such a vector</p>
<ul>
<li>for example, in the member initializer list of a class with an <a class="el" href="classFESystem.html">FESystem</a> member variable. For example, if your main class looks like this: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (...)  <span class="comment">// what to pass here???</span></div>
<div class="line">{}</div>
</div><!-- fragment --> Using the C++11 language standard (or later) you could do something like this to create an element with four base elements and multiplicities 1, 2, 3 and 4: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (std::vector&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt;*&gt; { <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3),</div>
<div class="line">                                               <span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4) },</div>
<div class="line">      std::vector&lt;unsigned int&gt; { 1, 2, 3, 4 })</div>
<div class="line">{}</div>
</div><!-- fragment --> This creates two vectors in place and initializes them using the initializer list enclosed in braces <code>{ ... }</code> . This code has a problem: it creates four memory leaks because the first vector above is created with pointers to elements that are allocated with <code>new</code> but never destroyed. The solution to the second of these problems is to create two static member functions that can create vectors. Here is an example: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">  create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">  create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; fe_list;</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(3));</div>
<div class="line">  fe_list.push_back (<span class="keyword">new</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(4));</div>
<div class="line">  <span class="keywordflow">return</span> fe_list;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::vector&lt;unsigned int&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::create_fe_multiplicities ()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;unsigned int&gt; multiplicities;</div>
<div class="line">  multiplicities.push_back (1);</div>
<div class="line">  multiplicities.push_back (2);</div>
<div class="line">  multiplicities.push_back (3);</div>
<div class="line">  multiplicities.push_back (4);</div>
<div class="line">  <span class="keywordflow">return</span> multiplicities;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">  :</div>
<div class="line">  fe (create_fe_list (polynomial_degree),</div>
<div class="line">      create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --> The way this works is that we have two static member functions that create the necessary vectors to pass to the constructor of the member variable <code>fe</code> . They need to be static because they are called during the constructor of <code>MySimulator</code> at a time when the <code>*this</code> object isn't fully constructed and, consequently, regular member functions cannot be called yet. The code above does not solve the problem with the memory leak yet, though: the <code>create_fe_list()</code> function creates a vector of pointers, but nothing destroys these. This is the solution: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>MySimulator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>VectorElementDestroyer</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; data;</div>
<div class="line"> </div>
<div class="line">  VectorElementDestroyer(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// destructor to delete the pointers</span></div>
<div class="line">  ~VectorElementDestroyer ();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp; <a class="code" href="classFESystem.html#a1011888f2cf239284408947ca57f0d00">get_data</a> () <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt;</div>
<div class="line">create_fe_list (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> std::vector&lt;unsigned int&gt;</div>
<div class="line">create_fe_multiplicities ();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">VectorElementDestroyer(</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>*&gt; &amp;pointers)</div>
<div class="line">:</div>
<div class="line">data(pointers)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">~VectorElementDestroyer ()</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;data.size(); ++i)</div>
<div class="line">  <span class="keyword">delete</span> data[i];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;const FiniteElement&lt;dim&gt;*&gt; &amp;</div>
<div class="line">MySimulator&lt;dim&gt;::VectorElementDestroyer::</div>
<div class="line">get_data ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"><span class="keywordflow">return</span> data;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">MySimulator&lt;dim&gt;::MySimulator (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polynomial_degree)</div>
<div class="line">:</div>
<div class="line">fe (VectorElementDestroyer(create_fe_list (polynomial_degree)).get_data(),</div>
<div class="line">  create_fe_multiplicities ())</div>
<div class="line">{}</div>
</div><!-- fragment --> In other words, the vector we receive from the <code>create_fe_list()</code> is packed into a temporary object of type <code>VectorElementDestroyer</code> ; we then get the vector from this temporary object immediately to pass it to the constructor of <code>fe</code>; and finally, the <code>VectorElementDestroyer</code> destructor is called at the end of the entire expression (after the constructor of <code>fe</code> has finished) and destroys the elements of the temporary vector. Voila: not short nor elegant, but it works! </li>
</ul>

</div>
</div>
<a id="a6e27f91193d25f03da55f2438f1d0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e27f91193d25f03da55f2438f1d0f00">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[30/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class... FEPairs, typename  = typename enable_if_all&lt;      (std::is_same&lt;typename std::decay&lt;FEPairs&gt;::type,                    std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt;,                              unsigned int&gt;&gt;::value ||       std::is_base_of&lt;FiniteElement&lt;dim, spacedim&gt;,                       typename std::decay&lt;FEPairs&gt;::type&gt;::value)...&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">FEPairs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fe_pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor taking an arbitrary number of parameters of type <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,   spacedim&gt;&gt;, unsigned int&gt;</code>. In combination with <a class="el" href="classFiniteElement.html#aa0833eb3ee7cbff916b3d8f3e7558501">FiniteElement::operator^</a>, this allows to construct <a class="el" href="classFESystem.html">FESystem</a> objects as follows: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system ( fe_1^dim, fe_2 );</div>
</div><!-- fragment --><p> The <code>fe_1</code> and <code>fe_2</code> objects are not actually used for anything other than creating a copy that will then be owned by the current object. In other words, it is completely fine to call this constructor with a temporary object for the finite element, as in this code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^2);</div>
</div><!-- fragment --><p> Here, <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2)</code> constructs an unnamed, temporary object that is passed to the <a class="el" href="classFESystem.html">FESystem</a> constructor to create a finite element that consists of two components, both of which are quadratic <a class="el" href="classFE__Q.html">FE_Q</a> elements. The temporary is destroyed again at the end of the code that corresponds to this line, but this does not matter because <a class="el" href="classFESystem.html">FESystem</a> creates its own copy of the <a class="el" href="classFE__Q.html">FE_Q</a> object. As a shortcut, this constructor also allows calling </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1));</div>
</div><!-- fragment --><p> instead of the more explicit </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2)^dim, <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1)^1);</div>
</div><!-- fragment --><p> In other words, if no multiplicity for an element is explicitly specified via the exponentiation operation, then it is assumed to be one (as one would have expected). </p><dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. Defining this constructor leads to internal compiler errors for Intel compilers prior to 18.0. </dd></dl>

</div>
</div>
<a id="a0e2aa0e6bd118482b13a5da73d125a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2aa0e6bd118482b13a5da73d125a4c">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[31/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above allowing the following syntax: </p><div class="fragment"><div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_1;</div>
<div class="line">FiniteElementType1&lt;dim,spacedim&gt; fe_2;</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fe_system = { fe_1^dim, fe_2^1 };</div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>This feature is not available for Intel compilers prior to version 19.0. The constructor is just not selected for overload resolution. </dd></dl>

</div>
</div>
<a id="a1305628a44a4a6318b4077ac0236fca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305628a44a4a6318b4077ac0236fca7">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[32/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is deleted, i.e., copying <a class="el" href="classFESystem.html">FESystem</a> objects is not allowed. </p>

</div>
</div>
<a id="ae4a5b073e0eb8197845ead711fa09ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a5b073e0eb8197845ead711fa09ab2">&#9670;&nbsp;</a></span>FESystem() <span class="overload">[33/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other_fe_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="translator_2fe_2fe__system_8h_source.html#l00526">526</a> of file <a class="el" href="translator_2fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="af16ae6333666b8d042306c257f6dc286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16ae6333666b8d042306c257f6dc286">&#9670;&nbsp;</a></span>~FESystem() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFESystem.html">FESystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c7ceb9c3eb2eebaa49f9608f458d34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7ceb9c3eb2eebaa49f9608f458d34c">&#9670;&nbsp;</a></span>get_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. This element returns a string that is composed of the strings <code>name1</code>...<code>nameN</code> returned by the basis elements. From these, we create a sequence <code>FESystem&lt;dim&gt;[name1^m1-name2^m2-...-nameN^mN]</code>, where <code>mi</code> are the multiplicities of the basis elements. If a multiplicity is equal to one, then the superscript is omitted. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00310">310</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="af143e194528aa74e206c2b26c2a49f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af143e194528aa74e206c2b26c2a49f85">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::clone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00339">339</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a3ab10b19cea15873b34aa3b597bef4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab10b19cea15873b34aa3b597bef4de">&#9670;&nbsp;</a></span>requires_update_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00896">896</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a8e4f1afff1380d9f81f6ee1cf63a1a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4f1afff1380d9f81f6ee1cf63a1a81">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_selected_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a reference to a contained finite element that matches the components selected by the given <a class="el" href="classComponentMask.html">ComponentMask</a> <code>mask</code>. For an arbitrarily nested <a class="el" href="classFESystem.html">FESystem</a>, this function returns the inner-most <a class="el" href="classFiniteElement.html">FiniteElement</a> that matches the given mask. The method fails if the <code>mask</code> does not exactly match one of the contained finite elements. It is most useful if the current object is an <a class="el" href="classFESystem.html">FESystem</a>, as the return value can only be <code>this</code> in all other cases. Note that the returned object can be an <a class="el" href="classFESystem.html">FESystem</a> if the mask matches it but not any of the contained objects. Let us illustrate the function with the an <a class="el" href="classFESystem.html">FESystem</a> <code>fe</code> with 7 components: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe_velocity(<a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(2), 2);</div>
<div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe_pressure(1);</div>
<div class="line"><a class="code" href="classFE__DGP.html">FE_DGP&lt;2&gt;</a> fe_dg(0);</div>
<div class="line"><a class="code" href="classFE__BDM.html">FE_BDM&lt;2&gt;</a> fe_nonprim(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe(fe_velocity, 1, fe_pressure, 1, fe_dg, 2, fe_nonprim, 1);</div>
</div><!-- fragment --><p> The following table lists all possible component masks you can use: </p><table class="doxtable">
<tr>
<th><a class="el" href="classComponentMask.html">ComponentMask</a> </th><th>Result </th><th>Description  </th></tr>
<tr>
<td><code>[true,true,true,true,true,true,true]</code> </td><td><code>FESystem&lt;2&gt;[FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]-FE_Q&lt;2&gt;(1)-FE_DGP&lt;2&gt;(0)^2-FE_BDM&lt;2&gt;(1)]</code> </td><td><code>fe</code> itself, the whole <code><a class="el" href="classFESystem.html">FESystem</a></code>   </td></tr>
<tr>
<td><code>[true,true,false,false,false,false,false]</code> </td><td><code>FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]</code> </td><td>just the <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[true,false,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The first component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,true,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The second component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,false,true,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(1)</code> </td><td><code>fe_pressure</code>   </td></tr>
<tr>
<td><code>[false,false,false,true,false,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>first copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,true,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>second copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,false,true,true]</code> </td><td><code>FE_BDM&lt;2&gt;(1)</code> </td><td>both components of <code>fe_nonprim</code>   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00356">356</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a89164574c530cdf920903040cc134ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89164574c530cdf920903040cc134ddf">&#9670;&nbsp;</a></span>shape_value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00385">385</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a632ab3340fc4b79ecc619c713fb0e77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632ab3340fc4b79ecc619c713fb0e77f">&#9670;&nbsp;</a></span>shape_value_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00401">401</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a9a55732c93a6d7df876af9850d245ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a55732c93a6d7df876af9850d245ef0">&#9670;&nbsp;</a></span>shape_grad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element, and likewise the gradient is the gradient on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00437">437</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a435bbc6cebd810237a87b7b17c3ad006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435bbc6cebd810237a87b7b17c3ad006">&#9670;&nbsp;</a></span>shape_grad_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00453">453</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="acbfe48ad66f32fd977f613b1f342ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe48ad66f32fd977f613b1f342ca8c">&#9670;&nbsp;</a></span>shape_grad_grad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of second derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00482">482</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a4669a634c58504c69fe030c926252865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4669a634c58504c69fe030c926252865">&#9670;&nbsp;</a></span>shape_grad_grad_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the second derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00498">498</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ad795407bb8ed6a584a63102e5c415060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad795407bb8ed6a584a63102e5c415060">&#9670;&nbsp;</a></span>shape_3rd_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of third derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00527">527</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="af4259713fa38075409d422d0080d16f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4259713fa38075409d422d0080d16f9">&#9670;&nbsp;</a></span>shape_3rd_derivative_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the third derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00543">543</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a50b440758f45da4842b77a81a56e4b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b440758f45da4842b77a81a56e4b3d">&#9670;&nbsp;</a></span>shape_4th_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of fourth derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00572">572</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="aa1483d485cefac01d5346d3025954360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1483d485cefac01d5346d3025954360">&#9670;&nbsp;</a></span>shape_4th_derivative_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00588">588</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a117566232430f89edbf198ef9d5ae1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117566232430f89edbf198ef9d5ae1a9">&#9670;&nbsp;</a></span>get_interpolation_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <code>dofs_per_cell</code> times <code>source.n_dofs_per_cell()</code>. These matrices are available if source and destination element are both <code><a class="el" href="classFESystem.html">FESystem</a></code> elements, have the same number of base elements with same element multiplicity, and if these base elements also implement their <code>get_interpolation_matrix</code> functions. Otherwise, an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented is thrown. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00617">617</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a2a870396630e54769b1e2adbdf4f55fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a870396630e54769b1e2adbdf4f55fc">&#9670;&nbsp;</a></span>base_element() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to a composing element. The index needs to be smaller than the number of base elements. Note that the number of base elements may in turn be smaller than the number of components of the system element, if the multiplicities are greater than one. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02366">2366</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a85e86b6adc43346cae19f40e6d626a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e86b6adc43346cae19f40e6d626a32">&#9670;&nbsp;</a></span>has_support_on_face() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero function values somewhere on the face <code>face_index</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02376">2376</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a28477b6f49b26d5bc6a289e814211840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28477b6f49b26d5bc6a289e814211840">&#9670;&nbsp;</a></span>get_restriction_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projection from a fine grid space onto a coarse grid space. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when requested). If this projection operator is associated with a matrix <code>P</code>, then the restriction of this matrix <code>P_i</code> to a single child cell is returned here. The matrix <code>P</code> is the concatenation or the sum of the cell matrices <code>P_i</code>, depending on the value of <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">FiniteElement::restriction_is_additive()</a>. This distinguishes interpolation (concatenation) and projection with respect to scalar products (summation). Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator. If projection matrices are not implemented in the derived finite element class, this function aborts with an exception of type FiniteElement::ExcProjectionVoid. You can check whether this would happen by first calling the restriction_is_implemented() or the isotropic_restriction_is_implemented() function. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00694">694</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ac7802b1354590cdb8990bc0b417d47e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7802b1354590cdb8990bc0b417d47e9">&#9670;&nbsp;</a></span>get_prolongation_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Embedding matrix between grids. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when queried). The identity operator from a coarse grid space into a fine grid space is associated with a matrix <code>P</code>. The restriction of this matrix <code>P_i</code> to a single child cell is returned here. The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once. Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator. These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix. If prolongation matrices are not implemented in one of the base finite element classes, this function aborts with an exception of type FiniteElement::ExcEmbeddingVoid. You can check whether this would happen by first calling the prolongation_is_implemented() or the isotropic_prolongation_is_implemented() function. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00785">785</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a2ad92aed11c564b6e09129c8c6e11688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad92aed11c564b6e09129c8c6e11688">&#9670;&nbsp;</a></span>face_to_cell_index() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell. To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the is_primitive() function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that. Code implementing this would then look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;dofs_per_face; ++i)</div>
<div class="line"><span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div>
<div class="line">... <span class="keywordflow">do</span> whatever</div>
</div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face.</td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo::faces_per_cell</a>.</td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> .</td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> .</td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00851">851</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a59ff9c9724937205d201b35a97fa8eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff9c9724937205d201b35a97fa8eb1">&#9670;&nbsp;</a></span>unit_support_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02389">2389</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a35f156493477b5e69ca8388e30f1a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f156493477b5e69ca8388e30f1a28d">&#9670;&nbsp;</a></span>unit_face_support_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02410">2410</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a17c0f8d4411b7f38517c35133615d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c0f8d4411b7f38517c35133615d655">&#9670;&nbsp;</a></span>get_constant_modes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_constant_modes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of constant modes of the element. The returns table has as many rows as there are components in the element and dofs_per_cell columns. To each component of the finite element, the row in the returned table contains a basis representation of the constant function 1 on the element. Concatenates the constant modes of each base element. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02441">2441</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ab5d083777a26e139e566a666e0091e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d083777a26e139e566a666e0091e7e">&#9670;&nbsp;</a></span>hp_constraints_are_implemented() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp-compatible". This function returns <code>true</code> if and only if all its base elements return <code>true</code> for this function. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01921">1921</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a60a4d4886f54ebe3c3169b26b82e0858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a4d4886f54ebe3c3169b26b82e0858">&#9670;&nbsp;</a></span>get_face_interpolation_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the face of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>. Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01934">1934</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="abc5031867f79f76ae1065bbf6427e692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5031867f79f76ae1065bbf6427e692">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the subface of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>. Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02050">2050</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ad99ac38fdabea78d1b2eb15cc413d14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99ac38fdabea78d1b2eb15cc413d14f">&#9670;&nbsp;</a></span>hp_vertex_dof_identities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp-code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of n_dofs_per_vertex() of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02287">2287</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a50bc69e0a928673d093743af96ecb8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bc69e0a928673d093743af96ecb8ce">&#9670;&nbsp;</a></span>hp_line_dof_identities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02295">2295</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a23d39d3c9635f9e2ac013d3a12136c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d39d3c9635f9e2ac013d3a12136c5d">&#9670;&nbsp;</a></span>hp_quad_dof_identities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02305">2305</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="abc005a9584d52b4a1e42d8f62840b8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc005a9584d52b4a1e42d8f62840b8df">&#9670;&nbsp;</a></span>compare_for_domination() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compare_for_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return whether this element dominates another one given as argument <code>fe_other</code>, whether it is the other way around, whether neither dominates, or if either could dominate. The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. For example, if <code>codim==0</code> then this function compares which element dominates at the cell level. If <code>codim==1</code>, then the elements are compared at faces, i.e., the comparison happens between the function spaces of the two finite elements as restricted to a face. Larger values of <code>codim</code> work correspondingly. For a definition of domination, see <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02316">2316</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a4fffa81396f85e6a7b6b1ff6923b21a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fffa81396f85e6a7b6b1ff6923b21a2">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function. This function simply calls <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values</a> of the base elements and re-assembles everything into the output argument. If a base element is non-interpolatory the corresponding dof values are filled with "signaling" NaNs instead. The function fails if none of the base elements of the <a class="el" href="classFESystem.html">FESystem</a> are interpolatory. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02497">2497</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a44dba139aa845dac7f363c23d8a09792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dba139aa845dac7f363c23d8a09792">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02604">2604</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a1011888f2cf239284408947ca57f0d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1011888f2cf239284408947ca57f0d00">&#9670;&nbsp;</a></span>get_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00910">910</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a1a69b6a5609cd010d1db0fdcb906a02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a69b6a5609cd010d1db0fdcb906a02f">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l00973">973</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="ab12fe280e7d0b92e65a94381221ccb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12fe280e7d0b92e65a94381221ccb0b">&#9670;&nbsp;</a></span>get_subface_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01036">1036</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="aebd17d235114948d7f6e4d9b5631bc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd17d235114948d7f6e4d9b5631bc22">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01097">1097</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="adecb9cd153953b0b57e7319069525931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecb9cd153953b0b57e7319069525931">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01127">1127</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a4297067cdc2ad6bf1c9c5050590cfa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4297067cdc2ad6bf1c9c5050590cfa2f">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01157">1157</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a1642039a2a407d409fff5d957c33f8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1642039a2a407d409fff5d957c33f8fc">&#9670;&nbsp;</a></span>compute_fill() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int dim_1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compute_fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the work for the three <code>fill_fe*_values</code> functions. Calls (among other things) <code>fill_fe_([sub]face)_values</code> of the base elements. Calls <code>fill_fe_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no==invalid_face_no</code>; calls <code>fill_fe_face_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>; and calls <code>fill_fe_subface_values</code> if <code>face_no!=invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01189">1189</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="aba222014c6b71fe5484f4ef7c57b18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba222014c6b71fe5484f4ef7c57b18be">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is simply singled out of the constructors since there are several of them. It sets up the index table for the system as well as <code>restriction</code> and <code>prolongation</code> matrices. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01632">1632</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="aa530a01111c2b0dfe60dec3ebd2d3d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa530a01111c2b0dfe60dec3ebd2d3d26">&#9670;&nbsp;</a></span>build_interface_constraints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::build_interface_constraints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by <code>initialize</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l01408">1408</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="abb26650d3fef364887f1c73aa171faa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb26650d3fef364887f1c73aa171faa2">&#9670;&nbsp;</a></span>hp_object_dof_identities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_object_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that computes the <a class="el" href="classFESystem.html#ad99ac38fdabea78d1b2eb15cc413d14f">hp_vertex_dof_identities()</a>, <a class="el" href="classFESystem.html#a50bc69e0a928673d093743af96ecb8ce">hp_line_dof_identities()</a>, or <a class="el" href="classFESystem.html#a23d39d3c9635f9e2ac013d3a12136c5d">hp_quad_dof_identities()</a>, depending on the value of the template parameter. </p>

<p class="definition">Definition at line <a class="el" href="fe__system_8cc_source.html#l02174">2174</a> of file <a class="el" href="fe__system_8cc_source.html">fe_system.cc</a>.</p>

</div>
</div>
<a id="a4bead461257e10db3b5200b12dbaa13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bead461257e10db3b5200b12dbaa13a">&#9670;&nbsp;</a></span>get_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. This element returns a string that is composed of the strings <code>name1</code>...<code>nameN</code> returned by the basis elements. From these, we create a sequence <code>FESystem&lt;dim&gt;[name1^m1-name2^m2-...-nameN^mN]</code>, where <code>mi</code> are the multiplicities of the basis elements. If a multiplicity is equal to one, then the superscript is omitted. </p>

</div>
</div>
<a id="a3ce8f25e0f645ff56370acded9160e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce8f25e0f645ff56370acded9160e0f">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a567cacda250362348c58d4b5dbeb4d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567cacda250362348c58d4b5dbeb4d16">&#9670;&nbsp;</a></span>requires_update_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0943cddd61aec42370ee37f27ba385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0943cddd61aec42370ee37f27ba385">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_selected_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a reference to a contained finite element that matches the components selected by the given <a class="el" href="classComponentMask.html">ComponentMask</a> <code>mask</code>. For an arbitrarily nested <a class="el" href="classFESystem.html">FESystem</a>, this function returns the inner-most <a class="el" href="classFiniteElement.html">FiniteElement</a> that matches the given mask. The method fails if the <code>mask</code> does not exactly match one of the contained finite elements. It is most useful if the current object is an <a class="el" href="classFESystem.html">FESystem</a>, as the return value can only be <code>this</code> in all other cases. Note that the returned object can be an <a class="el" href="classFESystem.html">FESystem</a> if the mask matches it but not any of the contained objects. Let us illustrate the function with the an <a class="el" href="classFESystem.html">FESystem</a> <code>fe</code> with 7 components: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe_velocity(<a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(2), 2);</div>
<div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe_pressure(1);</div>
<div class="line"><a class="code" href="classFE__DGP.html">FE_DGP&lt;2&gt;</a> fe_dg(0);</div>
<div class="line"><a class="code" href="classFE__BDM.html">FE_BDM&lt;2&gt;</a> fe_nonprim(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe(fe_velocity, 1, fe_pressure, 1, fe_dg, 2, fe_nonprim, 1);</div>
</div><!-- fragment --><p> The following table lists all possible component masks you can use: </p><table class="doxtable">
<tr>
<th><a class="el" href="classComponentMask.html">ComponentMask</a> </th><th>Result </th><th>Description  </th></tr>
<tr>
<td><code>[true,true,true,true,true,true,true]</code> </td><td><code>FESystem&lt;2&gt;[FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]-FE_Q&lt;2&gt;(1)-FE_DGP&lt;2&gt;(0)^2-FE_BDM&lt;2&gt;(1)]</code> </td><td><code>fe</code> itself, the whole <code><a class="el" href="classFESystem.html">FESystem</a></code>   </td></tr>
<tr>
<td><code>[true,true,false,false,false,false,false]</code> </td><td><code>FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]</code> </td><td>just the <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[true,false,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The first component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,true,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The second component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,false,true,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(1)</code> </td><td><code>fe_pressure</code>   </td></tr>
<tr>
<td><code>[false,false,false,true,false,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>first copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,true,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>second copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,false,true,true]</code> </td><td><code>FE_BDM&lt;2&gt;(1)</code> </td><td>both components of <code>fe_nonprim</code>   </td></tr>
</table>

</div>
</div>
<a id="ac0ffba94f76a56e45ecb13dddc59fce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ffba94f76a56e45ecb13dddc59fce8">&#9670;&nbsp;</a></span>shape_value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>.</p>
<p>An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="ac01d292b9183fb0db6345dd65986fa08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01d292b9183fb0db6345dd65986fa08">&#9670;&nbsp;</a></span>shape_value_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function.</p>
<p>Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a226f0ca95fef98a5a795ba78da7797b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f0ca95fef98a5a795ba78da7797b0">&#9670;&nbsp;</a></span>shape_grad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element, and likewise the gradient is the gradient on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>.</p>
<p>An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="ad9f423f2b10511d6bdb3e940b32c85af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f423f2b10511d6bdb3e940b32c85af">&#9670;&nbsp;</a></span>shape_grad_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function.</p>
<p>Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a2f6810b30f175bcc3708bbe816389bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6810b30f175bcc3708bbe816389bca">&#9670;&nbsp;</a></span>shape_grad_grad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of second derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>.</p>
<p>An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a8b29168c6e8c007fcfe973e6c2600560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b29168c6e8c007fcfe973e6c2600560">&#9670;&nbsp;</a></span>shape_grad_grad_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the second derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function.</p>
<p>Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a7886198e8af5a27191a9118ac85a4135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7886198e8af5a27191a9118ac85a4135">&#9670;&nbsp;</a></span>shape_3rd_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of third derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>.</p>
<p>An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a21c88c3fc150b2ca6272dd7619f9e888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c88c3fc150b2ca6272dd7619f9e888">&#9670;&nbsp;</a></span>shape_3rd_derivative_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the third derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function.</p>
<p>Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a0632bcef7a158890590c0983b7b2dc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632bcef7a158890590c0983b7b2dc11">&#9670;&nbsp;</a></span>shape_4th_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of fourth derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>.</p>
<p>An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a66880f9471932ba9eca38086f2a2f457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66880f9471932ba9eca38086f2a2f457">&#9670;&nbsp;</a></span>shape_4th_derivative_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function.</p>
<p>Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a81434b7f789d58de174332cf418fc715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81434b7f789d58de174332cf418fc715">&#9670;&nbsp;</a></span>get_interpolation_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <code>dofs_per_cell</code> times <code>source.n_dofs_per_cell()</code>.</p>
<p>These matrices are available if source and destination element are both <code><a class="el" href="classFESystem.html">FESystem</a></code> elements, have the same number of base elements with same element multiplicity, and if these base elements also implement their <code>get_interpolation_matrix</code> functions. Otherwise, an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented is thrown. </p>

</div>
</div>
<a id="a76d99a0ab9afd229cf814b9d828b44a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d99a0ab9afd229cf814b9d828b44a2">&#9670;&nbsp;</a></span>base_element() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to a composing element. The index needs to be smaller than the number of base elements. Note that the number of base elements may in turn be smaller than the number of components of the system element, if the multiplicities are greater than one. </p>

</div>
</div>
<a id="a7f0e16265d9cd2695aa478b764e7e178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0e16265d9cd2695aa478b764e7e178">&#9670;&nbsp;</a></span>has_support_on_face() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero function values somewhere on the face <code>face_index</code>. </p>

</div>
</div>
<a id="aa78b3955be5f0a0dd00613863663ad37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b3955be5f0a0dd00613863663ad37">&#9670;&nbsp;</a></span>get_restriction_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projection from a fine grid space onto a coarse grid space. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when requested).</p>
<p>If this projection operator is associated with a matrix <code>P</code>, then the restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation or the sum of the cell matrices <code>P_i</code>, depending on the value of <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">FiniteElement::restriction_is_additive()</a>. This distinguishes interpolation (concatenation) and projection with respect to scalar products (summation).</p>
<p>Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>If projection matrices are not implemented in the derived finite element class, this function aborts with an exception of type FiniteElement::ExcProjectionVoid. You can check whether this would happen by first calling the restriction_is_implemented() or the isotropic_restriction_is_implemented() function. </p>

</div>
</div>
<a id="ae0c24e15d2cc5acc418b0f5871e03e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c24e15d2cc5acc418b0f5871e03e6f">&#9670;&nbsp;</a></span>get_prolongation_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Embedding matrix between grids. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when queried).</p>
<p>The identity operator from a coarse grid space into a fine grid space is associated with a matrix <code>P</code>. The restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once.</p>
<p>Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix.</p>
<p>If prolongation matrices are not implemented in one of the base finite element classes, this function aborts with an exception of type FiniteElement::ExcEmbeddingVoid. You can check whether this would happen by first calling the prolongation_is_implemented() or the isotropic_prolongation_is_implemented() function. </p>

</div>
</div>
<a id="a30e79aafafe7cfa71d5527326541e720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e79aafafe7cfa71d5527326541e720">&#9670;&nbsp;</a></span>face_to_cell_index() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell.</p>
<p>To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the is_primitive() function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that.</p>
<p>Code implementing this would then look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;dofs_per_face; ++i)</div>
<div class="line"> <span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div>
<div class="line">  ... <span class="keywordflow">do</span> whatever</div>
</div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face. </td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo::faces_per_cell</a>. </td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell. </dd></dl>

</div>
</div>
<a id="a407cfce59711c10f48ebabc78327e79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407cfce59711c10f48ebabc78327e79d">&#9670;&nbsp;</a></span>unit_support_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

</div>
</div>
<a id="a0dc5c4bf19afec1c55d13d3a81c03a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc5c4bf19afec1c55d13d3a81c03a75">&#9670;&nbsp;</a></span>unit_face_support_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

</div>
</div>
<a id="a6a2f2d3af8769dfcb13ec1ab96d669d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2f2d3af8769dfcb13ec1ab96d669d1">&#9670;&nbsp;</a></span>get_constant_modes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classbool.html">bool</a>&gt;, std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_constant_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of constant modes of the element. The returns table has as many rows as there are components in the element and dofs_per_cell columns. To each component of the finite element, the row in the returned table contains a basis representation of the constant function 1 on the element. Concatenates the constant modes of each base element. </p>

</div>
</div>
<a id="a928be8e2a0821ee9ce6b49d8e6af31e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928be8e2a0821ee9ce6b49d8e6af31e4">&#9670;&nbsp;</a></span>hp_constraints_are_implemented() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp-compatible".</p>
<p>This function returns <code>true</code> if and only if all its base elements return <code>true</code> for this function. </p>

</div>
</div>
<a id="acc8da51192aa2016c12acaae3553c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8da51192aa2016c12acaae3553c5f9">&#9670;&nbsp;</a></span>get_face_interpolation_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the face of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>.</p>
<p>Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

</div>
</div>
<a id="ac6cec45533b2bc8ad05563316cdd244d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cec45533b2bc8ad05563316cdd244d">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the subface of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>.</p>
<p>Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

</div>
</div>
<a id="a2743be5a59591e0746df95a660ca868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743be5a59591e0746df95a660ca868e">&#9670;&nbsp;</a></span>hp_vertex_dof_identities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp-code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of n_dofs_per_vertex() of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

</div>
</div>
<a id="a2376198fb1a52db80d3eb59bdaa19d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376198fb1a52db80d3eb59bdaa19d27">&#9670;&nbsp;</a></span>hp_line_dof_identities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

</div>
</div>
<a id="a5bd093ee5bdcbc956d49307f6a905975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd093ee5bdcbc956d49307f6a905975">&#9670;&nbsp;</a></span>hp_quad_dof_identities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

</div>
</div>
<a id="a596cd1dbcdad862b8ee5611c961fc1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596cd1dbcdad862b8ee5611c961fc1c7">&#9670;&nbsp;</a></span>compare_for_domination() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compare_for_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return whether this element dominates another one given as argument <code>fe_other</code>, whether it is the other way around, whether neither dominates, or if either could dominate. The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. For example, if <code>codim==0</code> then this function compares which element dominates at the cell level. If <code>codim==1</code>, then the elements are compared at faces, i.e., the comparison happens between the function spaces of the two finite elements as restricted to a face. Larger values of <code>codim</code> work correspondingly. For a definition of domination, see <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. </p>

</div>
</div>
<a id="a6b1fe3f9c386185c9e534a773f6bc8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1fe3f9c386185c9e534a773f6bc8bb">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function.</p>
<p>This function simply calls <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values</a> of the base elements and re-assembles everything into the output argument. If a base element is non-interpolatory the corresponding dof values are filled with "signaling" NaNs instead.</p>
<p>The function fails if none of the base elements of the <a class="el" href="classFESystem.html">FESystem</a> are interpolatory. </p>

</div>
</div>
<a id="aee119185633ea5d7c1c94f1ff29dea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee119185633ea5d7c1c94f1ff29dea1b">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

</div>
</div>
<a id="adde1da7b364721481c737863dd13fd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde1da7b364721481c737863dd13fd37">&#9670;&nbsp;</a></span>get_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af822e18d3891e859beaaa0d6d1fde1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822e18d3891e859beaaa0d6d1fde1ce">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7be5a18f327f8fc2cc89e53d4f3eb02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5a18f327f8fc2cc89e53d4f3eb02c">&#9670;&nbsp;</a></span>get_subface_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c78ecdd66c27bb01f38c86fd1158a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c78ecdd66c27bb01f38c86fd1158a2">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a601019e75e79e6924ed29632986186a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601019e75e79e6924ed29632986186a5">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab64a2eda09c8bd983833192803c257b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a2eda09c8bd983833192803c257b9">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1642039a2a407d409fff5d957c33f8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1642039a2a407d409fff5d957c33f8fc">&#9670;&nbsp;</a></span>compute_fill() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int dim_1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compute_fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the work for the three <code>fill_fe*_values</code> functions.</p>
<p>Calls (among other things) <code>fill_fe_([sub]face)_values</code> of the base elements. Calls <code>fill_fe_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no==invalid_face_no</code>; calls <code>fill_fe_face_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>; and calls <code>fill_fe_subface_values</code> if <code>face_no!=invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>. </p>

</div>
</div>
<a id="aba222014c6b71fe5484f4ef7c57b18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba222014c6b71fe5484f4ef7c57b18be">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is simply singled out of the constructors since there are several of them. It sets up the index table for the system as well as <code>restriction</code> and <code>prolongation</code> matrices. </p>

</div>
</div>
<a id="aa530a01111c2b0dfe60dec3ebd2d3d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa530a01111c2b0dfe60dec3ebd2d3d26">&#9670;&nbsp;</a></span>build_interface_constraints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::build_interface_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by <code>initialize</code>. </p>

</div>
</div>
<a id="ada617df314b4577743306e837533bb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada617df314b4577743306e837533bb20">&#9670;&nbsp;</a></span>hp_object_dof_identities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int structdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_object_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that computes the <a class="el" href="classFESystem.html#ad99ac38fdabea78d1b2eb15cc413d14f">hp_vertex_dof_identities()</a>, <a class="el" href="classFESystem.html#a50bc69e0a928673d093743af96ecb8ce">hp_line_dof_identities()</a>, or <a class="el" href="classFESystem.html#a23d39d3c9635f9e2ac013d3a12136c5d">hp_quad_dof_identities()</a>, depending on the value of the template parameter. </p>

</div>
</div>
<a id="a4bead461257e10db3b5200b12dbaa13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bead461257e10db3b5200b12dbaa13a">&#9670;&nbsp;</a></span>get_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. This element returns a string that is composed of the strings <code>name1</code>...<code>nameN</code> returned by the basis elements. From these, we create a sequence <code>FESystem&lt;dim&gt;[name1^m1-name2^m2-...-nameN^mN]</code>, where <code>mi</code> are the multiplicities of the basis elements. If a multiplicity is equal to one, then the superscript is omitted. </p>

</div>
</div>
<a id="a3ce8f25e0f645ff56370acded9160e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce8f25e0f645ff56370acded9160e0f">&#9670;&nbsp;</a></span>clone() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a567cacda250362348c58d4b5dbeb4d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567cacda250362348c58d4b5dbeb4d16">&#9670;&nbsp;</a></span>requires_update_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0943cddd61aec42370ee37f27ba385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0943cddd61aec42370ee37f27ba385">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_selected_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a reference to a contained finite element that matches the components selected by the given <a class="el" href="classComponentMask.html">ComponentMask</a> <code>mask</code>. For an arbitrarily nested <a class="el" href="classFESystem.html">FESystem</a>, this function returns the inner-most <a class="el" href="classFiniteElement.html">FiniteElement</a> that matches the given mask. The method fails if the <code>mask</code> does not exactly match one of the contained finite elements. It is most useful if the current object is an <a class="el" href="classFESystem.html">FESystem</a>, as the return value can only be <code>this</code> in all other cases. Note that the returned object can be an <a class="el" href="classFESystem.html">FESystem</a> if the mask matches it but not any of the contained objects. Let us illustrate the function with the an <a class="el" href="classFESystem.html">FESystem</a> <code>fe</code> with 7 components: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe_velocity(<a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(2), 2);</div>
<div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe_pressure(1);</div>
<div class="line"><a class="code" href="classFE__DGP.html">FE_DGP&lt;2&gt;</a> fe_dg(0);</div>
<div class="line"><a class="code" href="classFE__BDM.html">FE_BDM&lt;2&gt;</a> fe_nonprim(1);</div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe(fe_velocity, 1, fe_pressure, 1, fe_dg, 2, fe_nonprim, 1);</div>
</div><!-- fragment --><p> The following table lists all possible component masks you can use: </p><table class="doxtable">
<tr>
<th><a class="el" href="classComponentMask.html">ComponentMask</a> </th><th>Result </th><th>Description  </th></tr>
<tr>
<td><code>[true,true,true,true,true,true,true]</code> </td><td><code>FESystem&lt;2&gt;[FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]-FE_Q&lt;2&gt;(1)-FE_DGP&lt;2&gt;(0)^2-FE_BDM&lt;2&gt;(1)]</code> </td><td><code>fe</code> itself, the whole <code><a class="el" href="classFESystem.html">FESystem</a></code>   </td></tr>
<tr>
<td><code>[true,true,false,false,false,false,false]</code> </td><td><code>FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]</code> </td><td>just the <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[true,false,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The first component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,true,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The second component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,false,true,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(1)</code> </td><td><code>fe_pressure</code>   </td></tr>
<tr>
<td><code>[false,false,false,true,false,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>first copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,true,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>second copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,false,true,true]</code> </td><td><code>FE_BDM&lt;2&gt;(1)</code> </td><td>both components of <code>fe_nonprim</code>   </td></tr>
</table>

</div>
</div>
<a id="ac0ffba94f76a56e45ecb13dddc59fce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ffba94f76a56e45ecb13dddc59fce8">&#9670;&nbsp;</a></span>shape_value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="ac01d292b9183fb0db6345dd65986fa08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01d292b9183fb0db6345dd65986fa08">&#9670;&nbsp;</a></span>shape_value_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a226f0ca95fef98a5a795ba78da7797b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f0ca95fef98a5a795ba78da7797b0">&#9670;&nbsp;</a></span>shape_grad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element, and likewise the gradient is the gradient on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="ad9f423f2b10511d6bdb3e940b32c85af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f423f2b10511d6bdb3e940b32c85af">&#9670;&nbsp;</a></span>shape_grad_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a2f6810b30f175bcc3708bbe816389bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6810b30f175bcc3708bbe816389bca">&#9670;&nbsp;</a></span>shape_grad_grad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of second derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a8b29168c6e8c007fcfe973e6c2600560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b29168c6e8c007fcfe973e6c2600560">&#9670;&nbsp;</a></span>shape_grad_grad_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the second derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a7886198e8af5a27191a9118ac85a4135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7886198e8af5a27191a9118ac85a4135">&#9670;&nbsp;</a></span>shape_3rd_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of third derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a21c88c3fc150b2ca6272dd7619f9e888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c88c3fc150b2ca6272dd7619f9e888">&#9670;&nbsp;</a></span>shape_3rd_derivative_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the third derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a0632bcef7a158890590c0983b7b2dc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632bcef7a158890590c0983b7b2dc11">&#9670;&nbsp;</a></span>shape_4th_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of fourth derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. Since this finite element is always vector-valued, we return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then throw an exception of type <code>ExcShapeFunctionNotPrimitive</code>. An <code>ExcUnitShapeValuesDoNotExist</code> is thrown if the shape values of the <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> (corresponding to the <code>ith</code> shape function) depend on the shape of the cell in real space. </p>

</div>
</div>
<a id="a66880f9471932ba9eca38086f2a2f457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66880f9471932ba9eca38086f2a2f457">&#9670;&nbsp;</a></span>shape_4th_derivative_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth derivatives of the <code>componentth</code> vector component of the <code>ith</code> shape function at the point <code>p</code>. See the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class for more information about the semantics of this function. Since this element is vector valued in general, it relays the computation of these values to the base elements. </p>

</div>
</div>
<a id="a81434b7f789d58de174332cf418fc715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81434b7f789d58de174332cf418fc715">&#9670;&nbsp;</a></span>get_interpolation_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <code>dofs_per_cell</code> times <code>source.n_dofs_per_cell()</code>. These matrices are available if source and destination element are both <code><a class="el" href="classFESystem.html">FESystem</a></code> elements, have the same number of base elements with same element multiplicity, and if these base elements also implement their <code>get_interpolation_matrix</code> functions. Otherwise, an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented is thrown. </p>

</div>
</div>
<a id="a76d99a0ab9afd229cf814b9d828b44a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d99a0ab9afd229cf814b9d828b44a2">&#9670;&nbsp;</a></span>base_element() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to a composing element. The index needs to be smaller than the number of base elements. Note that the number of base elements may in turn be smaller than the number of components of the system element, if the multiplicities are greater than one. </p>

</div>
</div>
<a id="a7f0e16265d9cd2695aa478b764e7e178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0e16265d9cd2695aa478b764e7e178">&#9670;&nbsp;</a></span>has_support_on_face() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero function values somewhere on the face <code>face_index</code>. </p>

</div>
</div>
<a id="aa78b3955be5f0a0dd00613863663ad37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b3955be5f0a0dd00613863663ad37">&#9670;&nbsp;</a></span>get_restriction_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projection from a fine grid space onto a coarse grid space. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when requested). If this projection operator is associated with a matrix <code>P</code>, then the restriction of this matrix <code>P_i</code> to a single child cell is returned here. The matrix <code>P</code> is the concatenation or the sum of the cell matrices <code>P_i</code>, depending on the value of <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">FiniteElement::restriction_is_additive()</a>. This distinguishes interpolation (concatenation) and projection with respect to scalar products (summation). Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator. If projection matrices are not implemented in the derived finite element class, this function aborts with an exception of type FiniteElement::ExcProjectionVoid. You can check whether this would happen by first calling the restriction_is_implemented() or the isotropic_restriction_is_implemented() function. </p>

</div>
</div>
<a id="ae0c24e15d2cc5acc418b0f5871e03e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c24e15d2cc5acc418b0f5871e03e6f">&#9670;&nbsp;</a></span>get_prolongation_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Embedding matrix between grids. Overrides the respective method in <a class="el" href="classFiniteElement.html">FiniteElement</a>, implementing lazy evaluation (initialize when queried). The identity operator from a coarse grid space into a fine grid space is associated with a matrix <code>P</code>. The restriction of this matrix <code>P_i</code> to a single child cell is returned here. The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once. Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator. These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix. If prolongation matrices are not implemented in one of the base finite element classes, this function aborts with an exception of type FiniteElement::ExcEmbeddingVoid. You can check whether this would happen by first calling the prolongation_is_implemented() or the isotropic_prolongation_is_implemented() function. </p>

</div>
</div>
<a id="a30e79aafafe7cfa71d5527326541e720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e79aafafe7cfa71d5527326541e720">&#9670;&nbsp;</a></span>face_to_cell_index() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell. To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the is_primitive() function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that. Code implementing this would then look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;dofs_per_face; ++i)</div>
<div class="line"><span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div>
<div class="line">... <span class="keywordflow">do</span> whatever</div>
</div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face.</td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo::faces_per_cell</a>.</td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> .</td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> .</td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell. </dd></dl>

</div>
</div>
<a id="a407cfce59711c10f48ebabc78327e79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407cfce59711c10f48ebabc78327e79d">&#9670;&nbsp;</a></span>unit_support_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

</div>
</div>
<a id="a0dc5c4bf19afec1c55d13d3a81c03a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc5c4bf19afec1c55d13d3a81c03a75">&#9670;&nbsp;</a></span>unit_face_support_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the respective function in the base class. </p>

</div>
</div>
<a id="a6a2f2d3af8769dfcb13ec1ab96d669d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2f2d3af8769dfcb13ec1ab96d669d1">&#9670;&nbsp;</a></span>get_constant_modes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classbool.html">bool</a>&gt;, std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_constant_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of constant modes of the element. The returns table has as many rows as there are components in the element and dofs_per_cell columns. To each component of the finite element, the row in the returned table contains a basis representation of the constant function 1 on the element. Concatenates the constant modes of each base element. </p>

</div>
</div>
<a id="a928be8e2a0821ee9ce6b49d8e6af31e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928be8e2a0821ee9ce6b49d8e6af31e4">&#9670;&nbsp;</a></span>hp_constraints_are_implemented() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp-compatible". This function returns <code>true</code> if and only if all its base elements return <code>true</code> for this function. </p>

</div>
</div>
<a id="acc8da51192aa2016c12acaae3553c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8da51192aa2016c12acaae3553c5f9">&#9670;&nbsp;</a></span>get_face_interpolation_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the face of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>. Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

</div>
</div>
<a id="ac6cec45533b2bc8ad05563316cdd244d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cec45533b2bc8ad05563316cdd244d">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the subface of the neighboring element. The size of the matrix is then <code>source.dofs_per_face</code> times <code>this-&gt;dofs_per_face</code>. Base elements of this element will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type FiniteElement&lt;dim,spacedim&gt;::ExcInterpolationNotImplemented, which will get propagated out from this element. </p>

</div>
</div>
<a id="a2743be5a59591e0746df95a660ca868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743be5a59591e0746df95a660ca868e">&#9670;&nbsp;</a></span>hp_vertex_dof_identities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp-code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of n_dofs_per_vertex() of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

</div>
</div>
<a id="a2376198fb1a52db80d3eb59bdaa19d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376198fb1a52db80d3eb59bdaa19d27">&#9670;&nbsp;</a></span>hp_line_dof_identities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

</div>
</div>
<a id="a5bd093ee5bdcbc956d49307f6a905975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd093ee5bdcbc956d49307f6a905975">&#9670;&nbsp;</a></span>hp_quad_dof_identities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

</div>
</div>
<a id="a596cd1dbcdad862b8ee5611c961fc1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596cd1dbcdad862b8ee5611c961fc1c7">&#9670;&nbsp;</a></span>compare_for_domination() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compare_for_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return whether this element dominates another one given as argument <code>fe_other</code>, whether it is the other way around, whether neither dominates, or if either could dominate. The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. For example, if <code>codim==0</code> then this function compares which element dominates at the cell level. If <code>codim==1</code>, then the elements are compared at faces, i.e., the comparison happens between the function spaces of the two finite elements as restricted to a face. Larger values of <code>codim</code> work correspondingly. For a definition of domination, see <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. </p>

</div>
</div>
<a id="a6b1fe3f9c386185c9e534a773f6bc8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1fe3f9c386185c9e534a773f6bc8bb">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function. This function simply calls <a class="el" href="group__Exceptions.html#ga97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values</a> of the base elements and re-assembles everything into the output argument. If a base element is non-interpolatory the corresponding dof values are filled with "signaling" NaNs instead. The function fails if none of the base elements of the <a class="el" href="classFESystem.html">FESystem</a> are interpolatory. </p>

</div>
</div>
<a id="aee119185633ea5d7c1c94f1ff29dea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee119185633ea5d7c1c94f1ff29dea1b">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

</div>
</div>
<a id="adde1da7b364721481c737863dd13fd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde1da7b364721481c737863dd13fd37">&#9670;&nbsp;</a></span>get_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af822e18d3891e859beaaa0d6d1fde1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822e18d3891e859beaaa0d6d1fde1ce">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7be5a18f327f8fc2cc89e53d4f3eb02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5a18f327f8fc2cc89e53d4f3eb02c">&#9670;&nbsp;</a></span>get_subface_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c78ecdd66c27bb01f38c86fd1158a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c78ecdd66c27bb01f38c86fd1158a2">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a601019e75e79e6924ed29632986186a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601019e75e79e6924ed29632986186a5">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab64a2eda09c8bd983833192803c257b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a2eda09c8bd983833192803c257b9">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1642039a2a407d409fff5d957c33f8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1642039a2a407d409fff5d957c33f8fc">&#9670;&nbsp;</a></span>compute_fill() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int dim_1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::compute_fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the work for the three <code>fill_fe*_values</code> functions. Calls (among other things) <code>fill_fe_([sub]face)_values</code> of the base elements. Calls <code>fill_fe_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no==invalid_face_no</code>; calls <code>fill_fe_face_values</code> if <code>face_no==invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>; and calls <code>fill_fe_subface_values</code> if <code>face_no!=invalid_face_no</code> and <code>sub_no!=invalid_face_no</code>. </p>

</div>
</div>
<a id="aba222014c6b71fe5484f4ef7c57b18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba222014c6b71fe5484f4ef7c57b18be">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is simply singled out of the constructors since there are several of them. It sets up the index table for the system as well as <code>restriction</code> and <code>prolongation</code> matrices. </p>

</div>
</div>
<a id="aa530a01111c2b0dfe60dec3ebd2d3d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa530a01111c2b0dfe60dec3ebd2d3d26">&#9670;&nbsp;</a></span>build_interface_constraints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::build_interface_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by <code>initialize</code>. </p>

</div>
</div>
<a id="ada617df314b4577743306e837533bb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada617df314b4577743306e837533bb20">&#9670;&nbsp;</a></span>hp_object_dof_identities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int structdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::hp_object_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that computes the <a class="el" href="classFESystem.html#ad99ac38fdabea78d1b2eb15cc413d14f">hp_vertex_dof_identities()</a>, <a class="el" href="classFESystem.html#a50bc69e0a928673d093743af96ecb8ce">hp_line_dof_identities()</a>, or <a class="el" href="classFESystem.html#a23d39d3c9635f9e2ac013d3a12136c5d">hp_quad_dof_identities()</a>, depending on the value of the template parameter. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae9f9aed2c32be9a09208c64f73b54aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f9aed2c32be9a09208c64f73b54aa8">&#9670;&nbsp;</a></span>FE_Enriched&lt; dim, spacedim &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFE__Enriched.html">FE_Enriched</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l01252">1252</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8db3bc88ad730296f67027e1e5f4cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db3bc88ad730296f67027e1e5f4cd59">&#9670;&nbsp;</a></span>invalid_face_number</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::invalid_face_number = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Value to indicate that a given face or subface number is invalid. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l01113">1113</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="aa3e9fa9ff1f607cef689093930b99fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e9fa9ff1f607cef689093930b99fc4">&#9670;&nbsp;</a></span>base_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::unique_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::base_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointers to underlying finite element objects. This object contains a pointer to each contributing element of a mixed discretization and its multiplicity. It is created by the constructor and constant afterwards. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l01123">1123</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="ade4ed3350a24760f4e6c74854b171279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4ed3350a24760f4e6c74854b171279">&#9670;&nbsp;</a></span>generalized_support_points_index_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::generalized_support_points_index_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An index table that maps generalized support points of a base element to the vector of generalized support points of the FE System. It holds true that </p><div class="fragment"><div class="line"><span class="keyword">auto</span> n = <a class="code" href="classFESystem.html#ade4ed3350a24760f4e6c74854b171279">generalized_support_points_index_table</a>[i][j];</div>
<div class="line">generalized_support_points[n] ==</div>
<div class="line">        <a class="code" href="classFESystem.html#aa3e9fa9ff1f607cef689093930b99fc4">base_elements</a>[i].generalized_support_points[j];</div>
</div><!-- fragment --><p> for each base element (indexed by i) and each g. s. point of the base element (index by j). </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l01138">1138</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<a id="a15db43093d0228707327d98ff45bc533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15db43093d0228707327d98ff45bc533">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classFESystem.html">FESystem</a>&lt; dim, spacedim &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex for protecting initialization of restriction and embedding matrix. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__system_8h_source.html#l01250">1250</a> of file <a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
<li>include/deal.II/fe/<a class="el" href="fe_2fe__system_8h_source.html">fe_system.h</a></li>
<li>source/fe/<a class="el" href="fe__system_8cc_source.html">fe_system.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassFE__DGQ_html"><div class="ttname"><a href="classFE__DGQ.html">FE_DGQ</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__dgq_8h_source.html#l00105">fe_dgq.h:105</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__q_8h_source.html#l00587">fe_q.h:587</a></div></div>
<div class="ttc" id="aclassFESystem_html_ade4ed3350a24760f4e6c74854b171279"><div class="ttname"><a href="classFESystem.html#ade4ed3350a24760f4e6c74854b171279">FESystem::generalized_support_points_index_table</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; generalized_support_points_index_table</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__system_8h_source.html#l01138">fe_system.h:1138</a></div></div>
<div class="ttc" id="aclassFE__RaviartThomas_html"><div class="ttname"><a href="classFE__RaviartThomas.html">FE_RaviartThomas</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__raviart__thomas_8h_source.html#l00092">fe_raviart_thomas.h:92</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a3e681d2d74dcf90f6556706d66f81a0d"><div class="ttname"><a href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">LAPACKSupport::U</a></div><div class="ttdeci">static const char U</div><div class="ttdef"><b>Definition:</b> <a href="lac_2lapack__support_8h_source.html#l00182">lapack_support.h:182</a></div></div>
<div class="ttc" id="aclassFESystem_html_aa3e9fa9ff1f607cef689093930b99fc4"><div class="ttname"><a href="classFESystem.html#aa3e9fa9ff1f607cef689093930b99fc4">FESystem::base_elements</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; std::unique_ptr&lt; const FiniteElement&lt; dim, spacedim &gt; &gt;, unsigned int &gt; &gt; base_elements</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__system_8h_source.html#l01123">fe_system.h:1123</a></div></div>
<div class="ttc" id="aclassFESystem_html_a1011888f2cf239284408947ca57f0d00"><div class="ttname"><a href="classFESystem.html#a1011888f2cf239284408947ca57f0d00">FESystem::get_data</a></div><div class="ttdeci">virtual std::unique_ptr&lt; typename FiniteElement&lt; dim, spacedim &gt;::InternalDataBase &gt; get_data(const UpdateFlags update_flags, const Mapping&lt; dim, spacedim &gt; &amp;mapping, const Quadrature&lt; dim &gt; &amp;quadrature, ::internal::FEValuesImplementation::FiniteElementRelatedData&lt; dim, spacedim &gt; &amp;output_data) const override</div><div class="ttdef"><b>Definition:</b> <a href="fe__system_8cc_source.html#l00910">fe_system.cc:910</a></div></div>
<div class="ttc" id="aclassFE__BDM_html"><div class="ttname"><a href="classFE__BDM.html">FE_BDM</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__bdm_8h_source.html#l00053">fe_bdm.h:53</a></div></div>
<div class="ttc" id="aclassFiniteElement_html"><div class="ttname"><a href="classFiniteElement.html">FiniteElement</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00910">fe.h:910</a></div></div>
<div class="ttc" id="aclassFE__DGP_html"><div class="ttname"><a href="classFE__DGP.html">FE_DGP</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__dgp_8h_source.html#l00286">fe_dgp.h:286</a></div></div>
<div class="ttc" id="aclassFESystem_html"><div class="ttname"><a href="classFESystem.html">FESystem</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00044">fe.h:44</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
