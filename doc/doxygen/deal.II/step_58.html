<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_58.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-58 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-58 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a>, <a class="el" href="step_29.html">step-29</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Anoteaboutthecharacteroftheequations">A note about the character of the equations</a>
        <li><a href="#Thegeneralideaofoperatorsplitting">The general idea of operator splitting</a>
        <li><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the "Lie splitting" approach</a>
        <li><a href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the "Strang splitting" approach</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial discretization and dealing with complex variables</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Definitionofthetestcase">Definition of the test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The <code>NonlinearSchroedingerEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation of the <code>NonlinearSchroedingerEquation</code> class</a>
      <ul>
        <li><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data structures and assembling matrices</a>
        <li><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang splitting steps</a>
        <li><a href="#Creatinggraphicaloutput">Creating graphical output</a>
        <li><a href="#Runningthesimulation">Running the simulation</a>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Visualizingthesolution">Visualizing the solution</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Betterlinearsolvers"> Better linear solvers </a>
        <li><a href="#Boundaryconditions"> Boundary conditions </a>
        <li><a href="#Adaptivemeshes"> Adaptive meshes </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em>This program was contributed by Wolfgang Bangerth (Colorado State University) and Yong-Yong Cai (<a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a>, CSRC) and is the result of the first author's time as a visitor at CSRC.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a href="https://en.wikipedia.org/wiki/Nonlinear_Schr%C3%B6dinger_equation">Nonlinear Schr&ouml;dinger Equation (NLSE)</a> for a function \(\psi=\psi(\mathbf x,t)\) and a potential \(V=V(\mathbf x)\) is a model often used in quantum mechanics and nonlinear optics. If one measures in appropriate quantities (so that \(\hbar=1\)), then it reads as follows: </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi + V \psi + \kappa |\psi|^2 \psi &amp;= 0 \qquad\qquad &amp; \text{in}\; \Omega\times (0,T), \\ \psi(\mathbf x,0) &amp;= \psi_0(\mathbf x) &amp; \text{in}\; \Omega, \\ \psi(\mathbf x,t) &amp;= 0 &amp; \text{on}\; \partial\Omega\times (0,T). \end{align*}
</p>
<p> If there is no potential, i.e. \(V(\mathbf x)=0\), then it can be used to describe the propagation of light in optical fibers. If \(V(\mathbf x)\neq 0\), the equation is also sometimes called the <a href="https://en.wikipedia.org/wiki/Gross%E2%80%93Pitaevskii_equation">Gross-Pitaevskii equation</a> and can be used to model the time dependent behavior of <a href="https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_condensate">Bose-Einstein condensates</a>.</p>
<p>For this particular tutorial program, the physical interpretation of the equation is not of much concern to us. Rather, we want to use it as a model that allows us to explain two aspects:</p><ul>
<li>It is a <b>complex-valued equation</b> for \(\psi \in H^1(\Omega,{\mathbb C})\). We have previously seen complex-valued equations in <a class="el" href="step_29.html">step-29</a>, but there have opted to split the equations into real and imaginary parts and consequently ended up solving a system of two real-valued equations. In contrast, the goal here is to show how to solve problems in which we keep everything as complex numbers.</li>
<li>The equation is a nice model problem to explain how <b>operator splitting methods</b> work. This is because it has terms with fundamentally different character: on the one hand, \(- \frac 12 \Delta \psi\) is a regular spatial operator in the way we have seen many times before; on the other hand, \(\kappa |\psi(\mathbf x,t)|^2 \psi\) has no spatial or temporal derivatives, i.e., it is a purely local operator. It turns out that we have efficient methods for each of these terms (in particular, we have analytic solutions for the latter), and that we may be better off treating these terms differently and separately. We will explain this in more detail below.</li>
</ul>
<p><a class="anchor" id="Anoteaboutthecharacteroftheequations"></a></p><h3>A note about the character of the equations</h3>
<p>At first glance, the equations appear to be parabolic and similar to the heat equation (see <a class="el" href="step_26.html">step-26</a>) as there is only a single time derivative and two spatial derivatives. But this is misleading. Indeed, that this is not the correct interpretation is more easily seen if we assume for a moment that the potential \(V=0\) and \(\kappa=0\). Then we have the equation </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi &amp;= 0. \end{align*}
</p>
<p> If we separate the solution into real and imaginary parts, \(\psi=v+iw\), with \(v=\textrm{Re}\;\psi,\; w=\textrm{Im}\;\psi\), then we can split the one equation into its real and imaginary parts in the same way as we did in <a class="el" href="step_29.html">step-29</a>: </p><p class="formulaDsp">
\begin{align*} \frac{\partial w}{\partial t} - \frac 12 \Delta v &amp;= 0, \\ -\frac{\partial v}{\partial t} - \frac 12 \Delta w &amp;= 0. \end{align*}
</p>
<p> Not surprisingly, the factor \(i\) in front of the time derivative couples the real and imaginary parts of the equation. If we want to understand this equation further, take the time derivative of one of the equations, say </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} - \frac 12 \Delta \frac{\partial v}{\partial t} &amp;= 0, \end{align*}
</p>
<p> (where we have assumed that, at least in some formal sense, we can commute the spatial and temporal derivatives), and then insert the other equation into it: </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} + \frac 14 \Delta^2 w &amp;= 0. \end{align*}
</p>
<p> This equation is hyperbolic and similar in character to the wave equation. (This will also be obvious if you look at the video in the "Results" section of this program.) Furthermore, we could have arrived at the same equation for \(v\) as well. Consequently, a better assumption for the NLSE is to think of it as a hyperbolic, wave-propagation equation than as a diffusion equation such as the heat equation. (You may wonder whether it is correct that the operator \(\Delta^2\) appears with a positive sign whereas in the wave equation, \(\Delta\) has a negative sign. This is indeed correct: After multiplying by a test function and integrating by parts, we want to come out with a positive (semi-)definite form. So, from \(-\Delta u\) we obtain \(+(\nabla v,\nabla u)\). Likewise, after integrating by parts twice, we obtain from \(+\Delta^2 u\) the form \(+(\Delta v,\Delta u)\). In both cases do we get the desired positive sign.)</p>
<p>The real NLSE, of course, also has the terms \(V\psi\) and \(\kappa|\psi|^2\psi\). However, these are of lower order in the spatial derivatives, and while they are obviously important, they do not change the character of the equation.</p>
<p>In any case, the purpose of this discussion is to figure out what time stepping scheme might be appropriate for the equation. The conclusions is that, as a hyperbolic-kind of equation, we need to choose a time step that satisfies a CFL-type condition. If we were to use an explicit method (which we will not), we would have to investigate the eigenvalues of the matrix that corresponds to the spatial operator. If you followed the discussions of the video lectures (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.26.html">video lecture 26</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.27.html">video lecture 27</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>.) then you will remember that the pattern is that one needs to make sure that \(k^s \propto h^t\) where \(k\) is the time step, \(h\) the mesh width, and \(s,t\) are the orders of temporal and spatial derivatives. Whether you take the original equation ( \(s=1,t=2\)) or the reformulation for only the real or imaginary part, the outcome is that we would need to choose \(k \propto h^2\) if we were to use an explicit time stepping method. This is not feasible for the same reasons as in <a class="el" href="step_26.html">step-26</a> for the heat equation: It would yield impractically small time steps for even only modestly refined meshes. Rather, we have to use an implicit time stepping method and can then choose a more balanced \(k \propto h\). Indeed, we will use the implicit Crank-Nicolson method as we have already done in <a class="el" href="step_23.html">step-23</a> before for the regular wave equation.</p>
<p><a class="anchor" id="Thegeneralideaofoperatorsplitting"></a></p><h3>The general idea of operator splitting</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.30.25.html">video lecture 30.25</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>If one thought of the NLSE as an ordinary differential equation in which the right hand side happens to have spatial derivatives, i.e., write it as </p><p class="formulaDsp">
\begin{align*} \frac{d\psi}{dt} &amp;= i\frac 12 \Delta \psi -i V \psi -i\kappa |\psi|^2 \psi, \qquad\qquad &amp; \text{for}\; t \in (0,T), \\ \psi(0) &amp;= \psi_0, \end{align*}
</p>
<p> one may be tempted to "formally solve" it by integrating both sides over a time interval \([t_{n},t_{n+1}]\) and obtain </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) -i V \psi(t) -i\kappa |\psi(t)|^2 \psi(t) \right) \; dt. \end{align*}
</p>
<p> Of course, it's not that simple: the \(\psi(t)\) in the integrand is still changing over time in accordance with the differential equation, so we cannot just evaluate the integral (or approximate it easily via quadrature) because we don't know \(\psi(t)\). But we can write this with separate contributions as follows, and this will allow us to deal with different terms separately: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi(t)|^2 \,\psi(t) \right) \; dt. \end{align*}
</p>
<p> The way this equation can now be read is as follows: For each time interval \([t_{n},t_{n+1}]\), the change \(\psi(t_{n+1})-\psi(t_{n})\) in the solution consists of three contributions:</p><ul>
<li>The contribution of the Laplace operator.</li>
<li>The contribution of the potential \(V\).</li>
<li>The contribution of the "phase" term \(-i\kappa |\psi(t)|^2\,\psi(t)\).</li>
</ul>
<p><em>Operator splitting</em> is now an approximation technique that allows us to treat each of these contributions separately. (If we want: In practice, we will treat the first two together, and the last one separate. But that is a detail, conceptually we could treat all of them differently.) To this end, let us introduce three separate "solutions": </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p>These three "solutions" can be thought of as satisfying the following differential equations: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n). \end{align*}
</p>
<p> In other words, they are all trajectories \(\psi^{(k)}\) that start at \(\psi(t_n)\) and integrate up the effects of exactly one of the three terms. The increments resulting from each of these terms over our time interval are then \(I^{(1)}=\psi^{(1)}(t_{n+1})-\psi(t_n)\), \(I^{(2)}=\psi^{(2)}(t_{n+1})-\psi(t_n)\), and \(I^{(3)}=\psi^{(3)}(t_{n+1})-\psi(t_n)\).</p>
<p>It is now reasonable to assume (this is an approximation!) that the change due to all three of the effects in question is well approximated by the sum of the three separate increments: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1})-\psi(t_n) \approx I^{(1)} + I^{(2)} + I^{(3)}. \end{align*}
</p>
<p> This intuition is indeed correct, though the approximation is not exact: the difference between the exact left hand side and the term \(I^{(1)}+I^{(2)}+I^{(3)}\) (i.e., the difference between the <em>exact</em> increment for the exact solution \(\psi(t)\) when moving from \(t_n\) to \(t_{n+1}\), and the increment composed of the three parts on the right hand side), is proportional to \(\Delta t=t_{n+1}-t_{n}\). In other words, this approach introduces an error of size \({\cal O}(\Delta t)\). Nothing we have done so far has discretized anything in time or space, so the <em>overall</em> error is going to be \({\cal O}(\Delta t)\) plus whatever error we commit when approximating the integrals (the temporal discretization error) plus whatever error we commit when approximating the spatial dependencies of \(\psi\) (the spatial error).</p>
<p>Before we continue with discussions about operator splitting, let us talk about why one would even want to go this way? The answer is simple: For some of the separate equations for the \(\psi^{(k)}\), we may have ways to solve them more efficiently than if we throw everything together and try to solve it at once. For example, and particularly pertinent in the current case: The equation for \(\psi^{(3)}\), i.e., </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, \qquad\qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n), \end{align*}
</p>
<p> or equivalently, </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt, \end{align*}
</p>
<p> can be solved exactly: the equation is solved by </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t) = e^{-i\kappa|\psi(t_n)|^2 (t-t_{n})} \psi(t_n). \end{align*}
</p>
<p> This is easy to see if (i) you plug this solution into the differential equation, and (ii) realize that the magnitude \(|\psi^{(3)}|\) is constant, i.e., the term \(|\psi(t_n)|^2\) in the exponent is in fact equal to \(|\psi^{(3)}(t)|^2\). In other words, the solution of the ODE for \(\psi^{(3)}(t)\) only changes its <em>phase</em>, but the <em>magnitude</em> of the complex-valued function \(\psi^{(3)}(t)\) remains constant. This makes computing \(I^{(3)}\) particularly convenient: we don't actually need to solve any ODE, we can write the solution down by hand. Using the operator splitting approach, none of the methods to compute \(I^{(1)},I^{(2)}\) therefore have to deal with the nonlinear term and all of the associated unpleasantries: we can get away with solving only <em>linear</em> problems, as long as we allow ourselves the luxury of using an operator splitting approach.</p>
<p>Secondly, one often uses operator splitting if the different physical effects described by the different terms have different time scales. Imagine, for example, a case where we really did have some sort of diffusion equation. Diffusion acts slowly, but if \(\kappa\) is large, then the "phase rotation" by the term \(-i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t)\) acts quickly. If we treated everything together, this would imply having to take rather small time steps. But with operator splitting, we can take large time steps \(\Delta t=t_{n+1}-t_{n}\) for the diffusion, and (assuming we didn't have an analytic solution) use an ODE solver with many small time steps to integrate the "phase rotation" equation for \(\psi^{(3)}\) from \(t_n\) to \(t_{n+1}\). In other words, operator splitting allows us to decouple slow and fast time scales and treat them differently, with methods adjusted to each case.</p>
<p><a class="anchor" id="OperatorsplittingtheLiesplittingapproach"></a></p><h3>Operator splitting: the "Lie splitting" approach</h3>
<p>While the method above allows to compute the three contributions \(I^{(k)}\) in parallel, if we want, the method can be made slightly more accurate and easy to implement if we don't let the trajectories for the \(\psi^{(k)}\) start all at \(\psi(t_n)\), but instead let the trajectory for \(\psi^{(2)}\) start at the <em>end point</em> of the trajectory for \(\psi^{(1)}\), namely \(\psi^{(1)}(t_{n+1})\); similarly, we will start the trajectory for \(\psi^{(3)}\) start at the end point of the trajectory for \(\psi^{(2)}\), namely \(\psi^{(2)}(t_{n+1})\). This method is then called "Lie splitting" and has the same order of error as the method above, i.e., the splitting error is \({\cal O}(\Delta t)\).</p>
<p>This variation of operator splitting can be written as follows (carefully compare the initial conditions to the ones above): </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> (Obviously, while the formulas above imply that we should solve these problems in this particular order, it is equally valid to first solve for trajectory 3, then 2, then 1, or any other permutation.)</p>
<p>The integrated forms of these equations are then </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi^{(1)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi^{(2)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> From a practical perspective, this has the advantage that we need to keep around fewer solution vectors: Once \(\psi^{(1)}(t_n)\) has been computed, we don't need \(\psi(t_n)\) any more; once \(\psi^{(2)}(t_n)\) has been computed, we don't need \(\psi^{(1)}(t_n)\) any more. And once \(\psi^{(3)}(t_n)\) has been computed, we can just call it \(\psi(t_{n+1})\) because, if you insert the first into the second, and then into the third equation, you see that the right hand side of \(\psi^{(3)}(t_n)\) now contains the contributions of all three physical effects: </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt+ \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> (Compare this again with the "exact" computation of \(\psi(t_{n+1})\): It only differs in how we approximate \(\psi(t)\) in each of the three integrals.) In other words, Lie splitting is a lot simpler to implement that the original method outlined above because data handling is so much simpler.</p>
<p><a class="anchor" id="OperatorsplittingtheStrangsplittingapproach"></a></p><h3>Operator splitting: the "Strang splitting" approach</h3>
<p>As mentioned above, Lie splitting is only \({\cal O}(\Delta t)\) accurate. This is acceptable if we were to use a first order time discretization, for example using the explicit or implicit Euler methods to solve the differential equations for \(\psi^{(k)}\). This is because these time integration methods introduce an error proportional to \(\Delta t\) themselves, and so the splitting error is proportional to an error that we would introduce anyway, and does not diminish the overall convergence order.</p>
<p>But we typically want to use something higher order &ndash; say, a <a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a> or <a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">BDF2</a> method &ndash; since these are often not more expensive than a simple Euler method. It would be a shame if we were to use a time stepping method that is \({\cal O}(\Delta t^2)\), but then lose the accuracy again through the operator splitting.</p>
<p>This is where the <a href="https://en.wikipedia.org/wiki/Strang_splitting">Strang splitting</a> method comes in. It is easier to explain if we had only two parts, and so let us combine the effects of the Laplace operator and of the potential into one, and the phase rotation into a second effect. (Indeed, this is what we will do in the code since solving the equation with the Laplace equation with or without the potential costs the same &ndash; so we merge these two steps.) The Lie splitting method from above would then do the following: It computes solutions of the following two ODEs, </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)} -i V \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i\kappa |\psi^{(2)}|^2 \,\psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \end{align*}
</p>
<p> and then uses the approximation \(\psi(t_{n+1}) \approx \psi^{(2)}(t_{n+1})\). In other words, we first make one full time step for physical effect one, then one full time step for physical effect two. The solution at the end of the time step is simply the sum of the increments due to each of these physical effects separately.</p>
<p>In contrast, <a href="https://en.wikipedia.org/wiki/Gilbert_Strang">Gil Strang</a> (one of the titans of numerical analysis starting in the mid-20th century) figured out that it is more accurate to first do one half-step for one physical effect, then a full time step for the other physical effect, and then another half step for the first. Which one is which does not matter, but because it is so simple to do the phase rotation, we will use this effect for the half steps and then only need to do one spatial solve with the Laplace operator plus potential. This operator splitting method is now \({\cal O}(\Delta t^2)\) accurate. Written in formulas, this yields the following sequence of steps: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= -i\kappa |\psi^{(1)}|^2 \,\psi^{(1)}, &amp;&amp; \text{for}\; t \in (t_n,t_n+\tfrac 12\Delta t), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= i\frac 12 \Delta \psi^{(2)} -i V \psi^{(2)}, \qquad &amp;&amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_n+\tfrac 12\Delta t), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp;&amp; \text{for}\; t \in (t_n+\tfrac 12\Delta t,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> As before, the first and third step can be computed exactly for this particular equation, yielding </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_n+\tfrac 12\Delta t) &amp;= e^{-i\kappa|\psi(t_n)|^2 \tfrac 12\Delta t} \; \psi(t_n), \\ \psi^{(3)}(t_{n+1}) &amp;= e^{-i\kappa|\psi^{(2)}(t_{n+1})|^2 \tfrac 12\Delta t} \; \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p>This is then how we are going to implement things in this program: In each time step, we execute three steps, namely</p><ul>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by one half time step;</li>
<li>Solving the space-time equation that corresponds to the full step for \(\psi^{(2)}\), namely \(-i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0\), with initial conditions equal to the solution of the first half step above.</li>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by another half time step.</li>
</ul>
<p>This structure will be reflected in an obvious way in the main time loop of the program.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>From the discussion above, it should have become clear that the only partial differential equation we have to solve in each time step is </p><p class="formulaDsp">
\begin{align*} -i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0. \end{align*}
</p>
<p> This equation is linear. Furthermore, we only have to solve it from \(t_n\) to \(t_{n+1}\), i.e., for exactly one time step.</p>
<p>To do this, we will apply the second order accurate Crank-Nicolson scheme that we have already used in some of the other time dependent codes (specifically: <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_26.html">step-26</a>). It reads as follows: </p><p class="formulaDsp">
\begin{align*} -i\frac{\psi^{(n,2)}-\psi^{(n,1)}}{k_{n+1}} - \frac 12 \Delta \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] + V \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] = 0. \end{align*}
</p>
<p> Here, the "previous" solution \(\psi^{(n,1)}\) (or the "initial
condition" for this part of the time step) is the output of the first phase rotation half-step; the output of the current step will be denoted by \(\psi^{(n,2)}\). \(k_{n+1}=t_{n+1}-t_n\) is the length of the time step. (One could argue whether \(\psi^{(n,1)}\) and \(\psi^{(n,1)}\) live at time step \(n\) or \(n+1\) and what their upper indices should be. This is a philosophical discussion without practical impact, and one might think of \(\psi^{(n,1)}\) as something like \(\psi^{(n+\tfrac 13)}\), and \(\psi^{(n,2)}\) as \(\psi^{(n+\tfrac 23)}\) if that helps clarify things &ndash; though, again \(n+\frac 13\) is not to be understood as "one third time step after
 \_form#386" but more like "we've already done one third of the work necessary
for time step \_form#2661".)</p>
<p>If we multiply the whole equation with \(k_{n+1}\) and sort terms with the unknown \(\psi^{(n+1,2)}\) to the left and those with the known \(\psi^{(n,2)}\) to the right, then we obtain the following (spatial) partial differential equation that needs to be solved in each time step: </p><p class="formulaDsp">
\begin{align*} -i\psi^{(n,2)} - \frac 14 k_{n+1} \Delta \psi^{(n,2)} + \frac 12 k_{n+1} V \psi^{(n,2)} = -i\psi^{(n,1)} + \frac 14 k_{n+1} \Delta \psi^{(n,1)} - \frac 12 k_{n+1} V \psi^{(n,1)}. \end{align*}
</p>
<p><a class="anchor" id="Spatialdiscretizationanddealingwithcomplexvariables"></a></p><h3>Spatial discretization and dealing with complex variables</h3>
<p>As mentioned above, the previous tutorial program dealing with complex-valued solutions (namely, <a class="el" href="step_29.html">step-29</a>) separated real and imaginary parts of the solution. It thus reduced everything to real arithmetic. In contrast, we here want to keep things complex-valued.</p>
<p>The first part of this is that we need to define the discretized solution as \(\psi_h^n(\mathbf x)=\sum_j \Psi^n_j \varphi_j(\mathbf x) \approx \psi(\mathbf x,t_n)\) where the \(\varphi_j\) are the usual shape functions (which are real valued) but the expansion coefficients \(\Psi^n_j\) at time step \(n\) are now complex-valued. This is easily done in deal.II: We just have to use <a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt; instead of <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> to store these coefficients.</p>
<p>Of more interest is how to build and solve the linear system. Obviously, this will only be necessary for the second step of the Strang splitting discussed above, with the time discretization of the previous subsection. We obtain the fully discrete version through straightforward substitution of \(\psi^n\) by \(\psi^n_h\) and multiplication by a test function: </p><p class="formulaDsp">
\begin{align*} -iM\Psi^{(n,2)} + \frac 14 k_{n+1} A \Psi^{(n,2)} + \frac 12 k_{n+1} W \Psi^{(n,2)} = -iM\Psi^{(n+1,1)} - \frac 14 k_{n+1} A \Psi^{(n,1)} - \frac 12 k_{n+1} W \Psi^{(n,1)}, \end{align*}
</p>
<p> or written in a more compact way: </p><p class="formulaDsp">
\begin{align*} \left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}. \end{align*}
</p>
<p> Here, the matrices are defined in their obvious ways: </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= (\varphi_i,\varphi_j), \\ A_{ij} &amp;= (\nabla\varphi_i,\nabla\varphi_j), \\ W_{ij} &amp;= (\varphi_i,V \varphi_j). \end{align*}
</p>
<p> Note that all matrices individually are in fact symmetric, real-valued, and at least positive semidefinite, though the same is obviously not true for the system matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and the corresponding matrix \(R = -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W\) on the right hand side.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.34.html">video lecture 34</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>The only remaining important question about the solution procedure is how to solve the complex-valued linear system </p><p class="formulaDsp">
\begin{align*} C \Psi^{(n+1,2)} = R \Psi^{(n+1,1)}, \end{align*}
</p>
<p> with the matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and a right hand side that is easily computed as the product of a known matrix and the previous part-step's solution. As usual, this comes down to the question of what properties the matrix \(C\) has. If it is symmetric and positive definite, then we can for example use the Conjugate Gradient method.</p>
<p>Unfortunately, the matrix's only useful property is that it is complex symmetric, i.e., \(C_{ij}=C_{ji}\), as is easy to see by recalling that \(M,A,W\) are all symmetric. It is not, however, <a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>, which would require that \(C_{ij}=\bar C_{ji}\) where the bar indicates complex conjugation.</p>
<p>Complex symmetry can be exploited for iterative solvers as a quick literature search indicates. We will here not try to become too sophisticated (and indeed leave this to the <a href="#extensions">Possibilities for extensions</a> section below) and instead simply go with the good old standby for problems without properties: A direct solver. That's not optimal, especially for large problems, but it shall suffice for the purposes of a tutorial program. Fortunately, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows solving complex-valued problems.</p>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>Initial conditions for the NLSE are typically chosen to represent particular physical situations. This is beyond the scope of this program, but suffice it to say that these initial conditions are (i) often superpositions of the wave functions of particles located at different points, and that (ii) because \(|\psi(\mathbf x,t)|^2\) corresponds to a particle density function, the integral </p><p class="formulaDsp">
\[ N(t) = \int_\Omega |\psi(\mathbf x,t)|^2 \]
</p>
<p> corresponds to the number of particles in the system. (Clearly, if one were to be physically correct, \(N(t)\) better be a constant if the system is closed, or \(\frac{dN}{dt}&lt;0\) if one has absorbing boundary conditions.) The important point is that one should choose initial conditions so that </p><p class="formulaDsp">
\[ N(0) = \int_\Omega |\psi_0(\mathbf x)|^2 \]
</p>
<p> makes sense.</p>
<p>What we will use here, primarily because it makes for good graphics, is the following: </p><p class="formulaDsp">
\[ \psi_0(\mathbf x) = \sqrt{\sum_{k=1}^4 \alpha_k e^{-\frac{r_k^2}{R^2}}}, \]
</p>
<p> where \(r_k = |\mathbf x-\mathbf x_k|\) is the distance from the (fixed) locations \(\mathbf x_k\), and \(\alpha_k\) are chosen so that each of the Gaussians that we are adding up adds an integer number of particles to \(N(0)\). We achieve this by making sure that </p><p class="formulaDsp">
\[ \int_\Omega \alpha_k e^{-\frac{r_k^2}{R^2}} \]
</p>
<p> is a positive integer. In other words, we need to choose \(\alpha\) as an integer multiple of </p><p class="formulaDsp">
\[ \left(\int_\Omega e^{-\frac{r_k^2}{R^2}}\right)^{-1} = \left(R^d\sqrt{\pi^d}\right)^{-1}, \]
</p>
<p> assuming for the moment that \(\Omega={\mathbb R}^d\) &ndash; which is of course not the case, but we'll ignore the small difference in integral.</p>
<p>Thus, we choose \(\alpha_k=\left(R^d\sqrt{\pi^d}\right)^{-1}\) for all, and \(R=0.1\). This \(R\) is small enough that the difference between the exact (infinite) integral and the integral over \(\Omega\) should not be too concerning. We choose the four points \(\mathbf x_k\) as \((\pm 0.3, 0), (0, \pm 0.3)\) &ndash; also far enough away from the boundary of \(\Omega\) to keep ourselves on the safe side.</p>
<p>For simplicity, we pose the problem on the square \([-1,1]^2\). For boundary conditions, we will use time-independent Neumann conditions of the form </p><p class="formulaDsp">
\[ \nabla\psi(\mathbf x,t)\cdot \mathbf n=0 \qquad\qquad \forall \mathbf x\in\partial\Omega. \]
</p>
<p> This is not a realistic choice of boundary conditions but sufficient for what we want to demonstrate here. We will comment further on this in the <a href="#extensions">Possibilities for extensions</a> section below.</p>
<p>Finally, we choose \(\kappa=1\), and the potential as </p><p class="formulaDsp">
\[ V(\mathbf x) = \begin{cases} 0 &amp; \text{if}\; |\mathbf x|&lt;0.7 \\ 1000 &amp; \text{otherwise}. \end{cases} \]
</p>
<p> Using a large potential makes sure that the wave function \(\psi\) remains small outside the circle of radius 0.7. All of the Gaussians that make up the initial conditions are within this circle, and the solution will mostly oscillate within it, with a small amount of energy radiating into the outside. The use of a large potential also makes sure that the nonphysical boundary condition does not have too large an effect.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with the usual include files, all of which you should have seen before by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Then the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep58.html">Step58</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>The <code>NonlinearSchroedingerEquation</code> class</h3>
<p>Then the main class. It looks very much like the corresponding classes in <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, with the only exception that the matrices and vectors and everything else related to the linear system are now storing elements of type <code>std::complex&lt;double&gt;</code> instead of just <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>NonlinearSchroedingerEquation</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  NonlinearSchroedingerEquation();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_system();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_matrices();</div>
<div class="line">  <span class="keywordtype">void</span> do_half_phase_step();</div>
<div class="line">  <span class="keywordtype">void</span> do_full_spatial_step();</div>
<div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; system_rhs;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>;</div>
<div class="line">  <span class="keywordtype">double</span>       time_step;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial values, as well as a right hand side class. (We will reuse the initial conditions also for the boundary values, which we simply keep constant.) We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not look surprising. The only point of interest is that we here have a complex-valued problem, so we have to provide the second template argument of the <a class="el" href="classFunction.html">Function</a> class (which would otherwise default to <code>double</code>). Furthermore, the return type of the <code><a class="el" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value()</a></code> functions is then of course also complex.</p>
<p>What precisely these functions return has been discussed at the end of the Introduction section.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InitialValues()</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, std::complex&lt;<a class="code" href="hdf5__0_8txt.html#aae153b86de45d3354cd3edd5b992435e">double</a>&gt;&gt;(1)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> std::complex&lt;double&gt;</div>
<div class="line">  <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::complex&lt;double&gt;</div>
<div class="line"><a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">InitialValues&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  static_assert(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div>
<div class="line">                                                  {0, +0.3},</div>
<div class="line">                                                  {+0.3, 0},</div>
<div class="line">                                                  {-0.3, 0}};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> =</div>
<div class="line">    1. / (<a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) * <a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> / 2.));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> - vortex_center;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> += <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> * <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {<a class="code" href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>), 0.};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Potential() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">Potential&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) &gt; 0.7 ? 1000 : 0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>Implementation of the <code>NonlinearSchroedingerEquation</code> class</h3>
<p>We start by specifying the implementation of the constructor of the class. There is nothing of surprise to see here except perhaps that we choose quadratic ( \(Q_2\)) Lagrange elements &ndash; the solution is expected to be smooth, so we choose a higher polynomial degree than the bare minimum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div>
<div class="line">  : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(2)</div>
<div class="line">  , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>(0)</div>
<div class="line">  , time_step(1. / 128)</div>
<div class="line">  , timestep_number(0)</div>
<div class="line">  , <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>(1)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="Settingupdatastructuresandassemblingmatrices"></a> </p><h4>Setting up data structures and assembling matrices</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">  <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(6);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells()</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div>
<div class="line">            &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">  <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">  system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">  rhs_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we assemble the relevant matrices. The way we have written the Crank-Nicolson discretization of the spatial step of the Strang splitting (i.e., the second of the three partial steps in each time step), we were led to the linear system \(\left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}\). In other words, there are two matrices in play here &ndash; one for the left and one for the right hand side. We build these matrices separately. (One could avoid building the right hand side matrix and instead just form the <em>action</em> of the matrix on \(\Psi^{(n,1)}\) in each time step. This may or may not be more efficient, but efficiency is not foremost on our minds for this program.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          quadrature_formula,</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                   <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                   <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  std::vector&lt;double&gt;                  potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">  <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">    {</div>
<div class="line">      cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div>
<div class="line">      cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div>
<div class="line"> </div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">      potential.value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                           potential_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_index)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = {0, 1};</div>
<div class="line"> </div>
<div class="line">                  cell_matrix_lhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                    (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                     time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                     time_step / 2 * potential_values[q_index] *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                    fe_values.JxW(q_index);</div>
<div class="line"> </div>
<div class="line">                  cell_matrix_rhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                    (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                     time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                     time_step / 2 * potential_values[q_index] *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                       fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                    fe_values.JxW(q_index);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_lhs,</div>
<div class="line">                                             <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                             system_matrix);</div>
<div class="line">      <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_rhs,</div>
<div class="line">                                             <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                             rhs_matrix);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementingtheStrangsplittingsteps"></a> </p><h4>Implementing the Strang splitting steps</h4>
<p>Having set up all data structures above, we are now in a position to implement the partial steps that form the Strang splitting scheme. We start with the half-step to advance the phase, and that is used as the first and last part of each time step.</p>
<p>To this end, recall that for the first half step, we needed to compute \(\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}\). Here, \(\psi^{(n,0)}=\psi^{(n)}\) and \(\psi^{(n,1)}\) are functions of space and correspond to the output of the previous complete time step and the result of the first of the three part steps, respectively. A corresponding solution must be computed for the third of the part steps, i.e. \(\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}\), where \(\psi^{(n,3)}=\psi^{(n+1)}\) is the result of the time step as a whole, and its input \(\psi^{(n,2)}\) is the result of the spatial step of the Strang splitting.</p>
<p>An important realization is that while \(\psi^{(n,0)}(\mathbf x)\) may be a finite element function (i.e., is piecewise polynomial), this may not necessarily be the case for the "rotated" function in which we have updated the phase using the exponential factor (recall that the amplitude of that function remains constant as part of that step). In other words, we could compute* \(\psi^{(n,1)}(\mathbf x)\) at every point \(\mathbf x\in\Omega\), but we can't represent it on a mesh because it is not a piecewise polynomial function. The best we can do in a discrete setting is to compute a projection or interpolation. In other words, we can compute \(\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)\) where \(\Pi_h\) is a projection or interpolation operator. The situation is particularly simple if we choose the interpolation: Then, all we need to compute is the value of the right hand side <em>at the node points</em> and use these as nodal values for the vector \(\Psi^{(n,1)}\) of degrees of freedom. This is easily done because evaluating the right hand side at node points for a Lagrange finite element as used here requires us to only look at a single (complex-valued) entry of the node vector. In other words, what we need to do is to compute \(\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j\) where \(j\) loops over all of the entries of our solution vector. This is what the function below does &ndash; in fact, it doesn't even use separate vectors for \(\Psi^{(n,0)}\) and \(\Psi^{(n,1)}\), but just updates the same vector as appropriate.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> : <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>         = {0, 1};</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(<a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a> * magnitude * magnitude * (time_step / 2)) *</div>
<div class="line">              <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The next step is to solve for the linear system in each time step, i.e., the second half step of the Strang splitting we use. Recall that it had the form \(C\Psi^{(n,2)} = R\Psi^{(n,1)}\) where \(C\) and \(R\) are the matrices we assembled earlier.</p>
<p>The way we solve this here is using a direct solver. We first form the right hand side \(r=R\Psi^{(n,1)}\) using the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult()</a> function and put the result into the <code>system_rhs</code> variable. We then call SparseDirectUMFPACK::solver() which takes as argument the matrix \(C\) and the right hand side vector and returns the solution in the same vector <code>system_rhs</code>. The final step is then to put the solution so computed back into the <code>solution</code> variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div>
<div class="line">{</div>
<div class="line">  rhs_matrix.vmult(system_rhs, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div>
<div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a> = system_rhs;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Creatinggraphicaloutput"></a> </p><h4>Creating graphical output</h4>
<p>The last of the helper functions and classes we ought to discuss are the ones that create graphical output. The result of running the half and full steps for the local and spatial parts of the Strang splitting is that we have updated the <code>solution</code> vector \(\Psi^n\) to the correct value at the end of each time step. Its entries contain complex numbers for the solution at the nodes of the finite element mesh.</p>
<p>Complex numbers are not easily visualized. We can output their real and imaginary parts, i.e., the fields \(\text{Re}(\psi_h^{(n)}(\mathbf x))\) and \(\text{Im}(\psi_h^{(n)}(\mathbf x))\), and that is exactly what the <a class="el" href="classDataOut.html">DataOut</a> class does when one attaches as complex-valued vector via <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> and then calls <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. That is indeed what we do below.</p>
<p>But oftentimes we are not particularly interested in real and imaginary parts of the solution vector, but instead in derived quantities such as the magnitude \(|\psi|\) and phase angle \(\text{arg}(\psi)\) of the solution. In the context of quantum systems such as here, the magnitude itself is not so interesting, but instead it is the "amplitude", \(|\psi|^2\) that is a physical property: it corresponds to the probability density of finding a particle in a particular place of state. The way to put computed quantities into output files for visualization &ndash; as used in numerous previous tutorial programs &ndash; is to use the facilities of the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> and derived classes. Specifically, both the amplitude of a complex number and its phase angles are scalar quantities, and so the <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> class is the right tool to base what we want to do on.</p>
<p>Consequently, what we do here is to implement two classes <code>ComplexAmplitude</code> and <code>ComplexPhase</code> that compute for each point at which <a class="el" href="classDataOut.html">DataOut</a> decides to generate output, the amplitudes \(|\psi_h|^2\) and phases \(\text{arg}(\psi_h)\) of the solution for visualization. There is a fair amount of boiler-plate code below, with the only interesting parts of the first of these two classes being how its <code>evaluate_vector_field()</code> function computes the <code>computed_quantities</code> object.</p>
<p>(There is also the rather awkward fact that the <a href="https://en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a> function does not compute what one would naively imagine, namely \(|\psi|\), but returns \(|\psi|^2\) instead. It's certainly quite confusing to have a standard function mis-named in such a way...)</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DataPostprocessors</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ComplexAmplitude();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div>
<div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">    <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                       inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1));</div>
<div class="line">        computed_quantities[q](0) = <a class="code" href="multithreading__0_8txt.html#a0759c0124e216ec36f063ad051f4dba0">std::norm</a>(psi);</div>
<div class="line">      }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The second of these postprocessor classes computes the phase angle of the complex-valued solution at each point. In other words, if we represent \(\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}\), then this class computes \(\varphi(\mathbf x,t)\). The function <a href="https://en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> does this for us, and returns the angle as a real number between \(-\pi\) and \(+\pi\).</p>
<p>For reasons that we will explain in detail in the results section, we do not actually output this value at each location where output is generated. Rather, we take the maximum over all evaluation points of the phase and then fill each evaluation point's output field with this maximum &ndash; in essence, we output the phase angle as a piecewise constant field, where each cell has its own constant value. The reasons for this will become clear once you read through the discussion further down below.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ComplexPhase();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ComplexPhase&lt;dim&gt;::ComplexPhase()</div>
<div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">    <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">        max_phase =</div>
<div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_phase,</div>
<div class="line">                   std::arg(</div>
<div class="line">                     std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                          inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1))));</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a> : computed_quantities)</div>
<div class="line">      <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(0) = max_phase;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace DataPostprocessors</span></div>
</div><!-- fragment --><p>Having so implemented these post-processors, we create output as we always do. As in many other time-dependent tutorial programs, we attach flags to <a class="el" href="classDataOut.html">DataOut</a> that indicate the number of the time step and the current simulation time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div>
<div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;Psi&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_magnitude);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_phase);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, timestep_number));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Runningthesimulation"></a> </p><h4>Running the simulation</h4>
<p>The remaining step is how we set up the overall logic for this program. It's really relatively simple: Set up the data structures; interpolate the initial conditions onto finite element space; then iterate over all time steps, and on each time step perform the three parts of the Strang splitting method. Every tenth time step, we generate graphical output. That's it.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_matrices();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> = 0;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;= end_time; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">      {</div>
<div class="line">        ++timestep_number;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        do_half_phase_step();</div>
<div class="line">        do_full_spatial_step();</div>
<div class="line">        do_half_phase_step();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div>
<div class="line">          output_results();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step58</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The <a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> function</h4>
<p>The rest is again boiler plate and exactly as in almost all of the previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep58.html">Step58</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;2&gt;</a> nse;</div>
<div class="line">      nse.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the code results in screen output like the following: </p><div class="fragment"><div class="line"><a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>: 4096</div>
<div class="line"><a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 16641</div>
<div class="line"> </div>
<div class="line">Time <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> 1 <a class="code" href="distributed__0_8txt.html#adcfa97993e5162228eec03e06ac05330">at</a> t=0</div>
<div class="line">Time <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> 2 <a class="code" href="distributed__0_8txt.html#adcfa97993e5162228eec03e06ac05330">at</a> t=0.00390625</div>
<div class="line">Time <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> 3 <a class="code" href="distributed__0_8txt.html#adcfa97993e5162228eec03e06ac05330">at</a> t=0.0078125</div>
<div class="line">Time <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> 4 <a class="code" href="distributed__0_8txt.html#adcfa97993e5162228eec03e06ac05330">at</a> t=0.0117188</div>
<div class="line">[...]</div>
</div><!-- fragment --><p>Running the program also yields a good number of output files that we will visualize in the following.</p>
<p><a class="anchor" id="Visualizingthesolution"></a></p><h3>Visualizing the solution</h3>
<p>The <code>output_results()</code> function of this program generates output files that consist of a number of variables: The solution (split into its real and imaginary parts), the amplitude, and the phase. If we visualize these four fields, we get images like the following after a few time steps (at time \(t=0.242\), to be precise:</p>
<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="Real part of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="Imaginary part of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="Amplitude of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="Phase of the solution at t=0.242" width="400" class="inline"/> </div> </div><p>While the real and imaginary parts of the solution shown above are not particularly interesting (because, from a physical perspective, the global offset of the phase and therefore the balance between real and imaginary components, is meaningless), it is much more interesting to visualize the amplitude \(|\psi(\mathbf x,t)|^2\) and phase \(\text{arg}(\psi(\mathbf x,t))\) of the solution and, in particular, their evolution. This leads to pictures like the following:</p>
<p>The phase picture shown here clearly has some flaws:</p><ul>
<li>First, phase is a "cyclic quantity", but the color scale uses a fundamentally different color for values close to \(-\pi\) than for values close to \(+\pi\). This is a nuisance &ndash; what we need is a "cyclic color map" that uses the same colors for the two extremes of the range of the phase. Such color maps exist, see <a href="https://nicoguaro.github.io/posts/cyclic_colormaps/">this blog post of Nicolás Guarín-Zapata</a> or <a href="https://stackoverflow.com/questions/23712207/cyclic-colormap-without-visual-distortions-for-use-in-phase-angle-plots">this StackExchange post</a>, for example. The problem is that the author's favorite one of the two big visualization packages, VisIt, does not have any of these color maps built in. In an act of desperation, I therefore had to resort to using Paraview given that it has several of the color maps mentioned in the post above implemented. The picture below uses the <code>nic_Edge</code> map in which both of the extreme values are shown as black.</li>
<li>There is a problem on cells in which the phase wraps around. If at some evaluation point of the cell the phase value is close to \(-\pi\) and at another evaluation point it is close to \(+\pi\), then what we would really like to happen is for the entire cell to have a color close to the extremes. But, instead, visualization programs produce a linear interpolation in which the values within the cell, i.e., between the evaluation points, is linearly interpolated between these two values, covering essentially the entire range of possible phase values and, consequently, cycling through the entire rainbow of colors from dark red to dark green over the course of one cell. The solution to this problem is to just output the phase value on each cell as a piecewise constant. Because averaging values close to the \(-\pi\) and \(+\pi\) is going to result in an average that has nothing to do with the actual phase angle, the <code>ComplexPhase</code> class just uses the <em>maximal</em> phase angle encountered on each cell.</li>
</ul>
<p>With these modifications, the phase plot now looks as follows:</p>
<p align="center"></p>
<p><img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="Phase of the solution at t=0.242, with a cyclic color map" width="400" class="inline"/> </p>
<p>Finally, we can generate a movie out of this. (To be precise, the video uses two more global refinement cycles and a time step half the size of what is used in the program above.) The author of these lines made the movie with VisIt, because that's what he's more familiar with, and using a hacked color map that is also cyclic &ndash; though this color map lacks all of the skill employed by the people who wrote the posts mentioned in the links above. It does, however, show the character of the solution as a wave equation if you look at the shaded part of the domain outside the circle of radius 0.7 in which the potential is zero &ndash; you can see how every time one of the bumps (showing the amplitude \(|\psi_h(\mathbf x,t)|^2\)) bumps into the area where the potential is large: a wave travels outbound from there. Take a look at the video:</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nraszP3GZHk"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>So why did I end up shading the area where the potential \(V(\mathbf x)\) is large? In that outside region, the solution is relatively small. It is also relatively smooth. As a consequence, to some approximate degree, the equation in that region simplifies to </p><p class="formulaDsp">
\[ - i \frac{\partial \psi}{\partial t} + V \psi \approx 0, \]
</p>
<p> or maybe easier to read: </p><p class="formulaDsp">
\[ \frac{\partial \psi}{\partial t} \approx - i V \psi. \]
</p>
<p> To the degree to which this approximation is valid (which, among other things, eliminates the traveling waves you can see in the video), this equation has a solution </p><p class="formulaDsp">
\[ \psi(\mathbf x, t) = \psi(\mathbf x, 0) e^{-i V t}. \]
</p>
<p> Because \(V\) is large, this means that the phase <em>rotates quite rapidly</em>. If you focus on the semi-transparent outer part of the domain, you can see that. If one colors this region in the same way as the inner part of the domain, this rapidly flashing outer part may be psychedelic, but is also distracting of what's happening on the inside; it's also quite hard to actually see the radiating waves that are easy to see at the beginning of the video.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Betterlinearsolvers"></a></p><h4>Better linear solvers </h4>
<p>The solver chosen here is just too simple. It is also not efficient. What we do here is give the matrix to a sparse direct solver in every time step and let it find the solution of the linear system. But we know that we could do far better:</p>
<ul>
<li>First, we should make use of the fact that the matrix doesn't actually change from time step to time step. This is an artifact of the fact that we here have constant boundary values and that we don't change the time step size &ndash; two assumptions that might not be true in actual applications. But at least in cases where this does happen to be the case, it would make sense to only factorize the matrix once (i.e., compute \(L\) and \(U\) factors once) and then use these factors for all following time steps until the matrix \(C\) changes and requires a new factorization. The interface of the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows for this.</li>
<li>Ultimately, however, sparse direct solvers are only efficient for relatively small problems, say up to a few 100,000 unknowns. Beyond this, one needs iterative solvers such as the Conjugate Gradient method (for symmetric and positive definite problems) or GMRES. We have used many of these in other tutorial programs. In all cases, they need to be accompanied by good preconditioners. For the current case, one could in principle use GMRES &ndash; a method that does not require any specific properties of the matrix &ndash; but would be better advised to implement an iterative scheme that exploits the one structural feature we know is true for this problem: That the matrix is complex-symmetric (albeit not Hermitian).</li>
</ul>
<p><a class="anchor" id="Boundaryconditions"></a></p><h4>Boundary conditions </h4>
<p>In order to be usable for actual, realistic problems, solvers for the nonlinear Schr&ouml;dinger equation need to utilize boundary conditions that make sense for the problem at hand. We have here restricted ourselves to simple Neumann boundary conditions &ndash; but these do not actually make sense for the problem. Indeed, the equations are generally posed on an infinite domain. But, since we can't compute on infinite domains, we need to truncate it somewhere and instead pose boundary conditions that make sense for this artificially small domain. The approach widely used is to use the <a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Perfectly Matched Layer</a> method that corresponds to a particular kind of attenuation. It is, in a different context, also used in <a class="el" href="step_62.html">step-62</a>.</p>
<p><a class="anchor" id="Adaptivemeshes"></a></p><h4>Adaptive meshes </h4>
<p>Finally, we know from experience and many other tutorial programs that it is worthwhile to use adaptively refined meshes, rather than the uniform meshes used here. It would, in fact, not be very difficult to add this here: It just requires periodic remeshing and transfer of the solution from one mesh to the next. <a class="el" href="step_26.html">step-26</a> will be a good guide for how this could be implemented.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University</span></div>
<div class="line"><span class="comment"> *         Yong-Yong Cai, Beijing Computational Science Research Center</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep58.html">Step58</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation</a>();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_matrices();</div>
<div class="line">    <span class="keywordtype">void</span> do_half_phase_step();</div>
<div class="line">    <span class="keywordtype">void</span> do_full_spatial_step();</div>
<div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">    SparseMatrix&lt;std::complex&lt;double&gt;&gt; system_matrix;</div>
<div class="line">    SparseMatrix&lt;std::complex&lt;double&gt;&gt; rhs_matrix;</div>
<div class="line"> </div>
<div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; system_rhs;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>;</div>
<div class="line">    <span class="keywordtype">double</span>       time_step;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    InitialValues()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, std::complex&lt;<a class="code" href="hdf5__0_8txt.html#aae153b86de45d3354cd3edd5b992435e">double</a>&gt;&gt;(1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt;</div>
<div class="line">    <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  std::complex&lt;double&gt;</div>
<div class="line">  <a class="code" href="classStep58_1_1InitialValues.html#a152471cc082d1c37b4ca7d071391a3dc">InitialValues&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    static_assert(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div>
<div class="line">                                                    {0, +0.3},</div>
<div class="line">                                                    {+0.3, 0},</div>
<div class="line">                                                    {-0.3, 0}};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> =</div>
<div class="line">      1. / (<a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) * <a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> / 2.));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> - vortex_center;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> += <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> * <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code" href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">std::sqrt</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>), 0.};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Potential() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="classStep58_1_1Potential.html#a926ccbdec2ac6ffb41023a094ca665d3">Potential&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) &gt; 0.7 ? 1000 : 0);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html#a7eb28c4ecb2748883c0e6ce67f7d947e">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation</a>()</div>
<div class="line">    : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(2)</div>
<div class="line">    , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">    , <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>(0)</div>
<div class="line">    , time_step(1. / 128)</div>
<div class="line">    , timestep_number(0)</div>
<div class="line">    , <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>(1)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::setup_system</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(6);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">    rhs_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                     <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                     <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    std::vector&lt;double&gt;                  potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">    <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">      {</div>
<div class="line">        cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div>
<div class="line">        cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div>
<div class="line"> </div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">        potential.value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                             potential_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_index)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>)</div>
<div class="line">                  {</div>
<div class="line">                    <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = {0, 1};</div>
<div class="line"> </div>
<div class="line">                    cell_matrix_lhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                      (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                       time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                       time_step / 2 * potential_values[q_index] *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                      fe_values.JxW(q_index);</div>
<div class="line"> </div>
<div class="line">                    cell_matrix_rhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                      (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                       time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                       time_step / 2 * potential_values[q_index] *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                      fe_values.JxW(q_index);</div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_lhs,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               system_matrix);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_rhs,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               rhs_matrix);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>         = {0, 1};</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a> * magnitude * magnitude * (time_step / 2)) *</div>
<div class="line">                <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step</a>()</div>
<div class="line">  {</div>
<div class="line">    rhs_matrix.vmult(system_rhs, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div>
<div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a> = system_rhs;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>DataPostprocessors</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      ComplexAmplitude();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div>
<div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                         inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1));</div>
<div class="line">          computed_quantities[q](0) = <a class="code" href="multithreading__0_8txt.html#a0759c0124e216ec36f063ad051f4dba0">std::norm</a>(psi);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      ComplexPhase();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    ComplexPhase&lt;dim&gt;::ComplexPhase()</div>
<div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">          max_phase =</div>
<div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_phase,</div>
<div class="line">                     std::arg(</div>
<div class="line">                       std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                            inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1))));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a> : computed_quantities)</div>
<div class="line">        <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(0) = max_phase;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace DataPostprocessors</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::output_results</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div>
<div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;Psi&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_magnitude);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_phase);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, timestep_number));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">    std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_matrices();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> = 0;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;= end_time; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">      {</div>
<div class="line">        ++timestep_number;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        do_half_phase_step();</div>
<div class="line">        do_full_spatial_step();</div>
<div class="line">        do_half_phase_step();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div>
<div class="line">          output_results();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step58</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep58.html">Step58</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;2&gt;</a> nse;</div>
<div class="line">      nse.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 This tutorial depends on <a class="el" href="step_26.html">step-26</a> , <a class="el" href="step_29.html">step-29</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Anoteaboutthecharacteroftheequations">A note about the character of the equations</a><a href="#Anoteaboutthecharacteroftheequations">A note about the character of the equations</a>
        <li><a href="#Thegeneralideaofoperatorsplitting">The general idea of operator splitting</a><a href="#Thegeneralideaofoperatorsplitting">The general idea of operator splitting</a>
        <li><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the "Lie splitting" approach</a><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the "Lie splitting" approach</a>
        <li><a href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the "Strang splitting" approach</a><a href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the "Strang splitting" approach</a>
        <li><a href="#Timediscretization">Time discretization</a><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial discretization and dealing with complex variables</a><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial discretization and dealing with complex variables</a>
        <li><a href="#Linearsolvers">Linear solvers</a><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Definitionofthetestcase">Definition of the test case</a><a href="#Definitionofthetestcase">Definition of the test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The <code>NonlinearSchroedingerEquation</code> class</a><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The <code>NonlinearSchroedingerEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation of the <code>NonlinearSchroedingerEquation</code> class</a><a href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation of the <code>NonlinearSchroedingerEquation</code> class</a>
      <ul>
        <li><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data structures and assembling matrices</a><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data structures and assembling matrices</a>
        <li><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang splitting steps</a><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang splitting steps</a>
        <li><a href="#Creatinggraphicaloutput">Creating graphical output</a><a href="#Creatinggraphicaloutput">Creating graphical output</a>
        <li><a href="#Runningthesimulation">Running the simulation</a><a href="#Runningthesimulation">Running the simulation</a>
        <li><a href="#Themainfunction">The main() function</a><a href="#Themainfunction">The main() function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Visualizingthesolution">Visualizing the solution</a><a href="#Visualizingthesolution">Visualizing the solution</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Betterlinearsolvers"> Better linear solvers </a><a href="#Betterlinearsolvers"> Better linear solvers </a>
        <li><a href="#Boundaryconditions"> Boundary conditions </a><a href="#Boundaryconditions"> Boundary conditions </a>
        <li><a href="#Adaptivemeshes"> Adaptive meshes </a><a href="#Adaptivemeshes"> Adaptive meshes </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
 <br  />
 <em>This program was contributed by Wolfgang Bangerth (Colorado State University) and Yong-Yong Cai (<a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a><a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a>, CSRC) and is the result of the first author's time as a visitor at CSRC.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a href="https://en.wikipedia.org/wiki/Nonlinear_Schr%C3%B6dinger_equation">Nonlinear Schr&ouml;dinger Equation (NLSE)</a> for a function \(\psi=\psi(\mathbf x,t)\) and a potential \(V=V(\mathbf x)\) is a model often used inquantum mechanics and nonlinear optics. If one measures in appropriatequantities (so that \(\hbar=1\) ), then it reads as follows: </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi + V \psi + \kappa |\psi|^2 \psi &amp;= 0 \qquad\qquad &amp; \text{in}\; \Omega\times (0,T), \\ \psi(\mathbf x,0) &amp;= \psi_0(\mathbf x) &amp; \text{in}\; \Omega, \\ \psi(\mathbf x,t) &amp;= 0 &amp; \text{on}\; \partial\Omega\times (0,T). \end{align*}
</p>
<p> If there is no potential, i.e. \(V(\mathbf x)=0\) , then it can be usedto describe the propagation of light in optical fibers. If \(V(\mathbf x)\neq 0\) , the equation is also sometimes called the <a href="https://en.wikipedia.org/wiki/Gross%E2%80%93Pitaevskii_equation">Gross-Pitaevskii equation</a> and can be used to model the time dependent behavior of<a href="https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_condensate">Bose-Einstein condensates</a>. For this particular tutorial program, the physical interpretation ofthe equation is not of much concern to us. Rather, we want to use itas a model that allows us to explain two aspects:</p>
<ul>
<li>It is a <b>complex-valued equation</b> for \(\psi \in H^1(\Omega,{\mathbb C})\) . We have previously seen complex-valued equations in <a class="el" href="step_29.html">step-29</a> , but there have opted to split the equations into real and imaginary parts and consequently ended up solving a system of two real-valued equations. In contrast, the goal here is to show how to solve problems in which we keep everything as complex numbers.</li>
<li>The equation is a nice model problem to explain how <b>operator splitting methods</b> work. This is because it has terms with fundamentally different character: on the one hand, \(- \frac 12 \Delta \psi\) is a regular spatial operator in the way we have seen many times before; on the other hand, \(\kappa |\psi(\mathbf x,t)|^2 \psi\) has no spatial or temporal derivatives, i.e., it is a purely local operator. It turns out that we have efficient methods for each of these terms (in particular, we have analytic solutions for the latter), and that we may be better off treating these terms differently and separately. We will explain this in more detail below.</li>
</ul>
<p><a class="anchor" id="Anoteaboutthecharacteroftheequations"></a></p><h3>A note about the character of the equations</h3>
<p>At first glance, the equations appear to be parabolic and similar tothe heat equation (see <a class="el" href="step_26.html">step-26</a> ) as there is only a single timederivative and two spatial derivatives. But this is misleading.Indeed, that this is not the correct interpretation ismore easily seen if we assume for a moment that the potential \(V=0\) and \(\kappa=0\) . Then we have the equation </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi &amp;= 0. \end{align*}
</p>
<p> If we separate the solution into real and imaginary parts, \(\psi=v+iw\) ,with \(v=\textrm{Re}\;\psi,\; w=\textrm{Im}\;\psi\) ,then we can split the one equation into its real and imaginary partsin the same way as we did in <a class="el" href="step_29.html">step-29</a> : </p><p class="formulaDsp">
\begin{align*} \frac{\partial w}{\partial t} - \frac 12 \Delta v &amp;= 0, \\ -\frac{\partial v}{\partial t} - \frac 12 \Delta w &amp;= 0. \end{align*}
</p>
<p> Not surprisingly, the factor \(i\) in front of the time derivativecouples the real and imaginary parts of the equation. If we want tounderstand this equation further, take the time derivative of one ofthe equations, say </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} - \frac 12 \Delta \frac{\partial v}{\partial t} &amp;= 0, \end{align*}
</p>
<p> (where we have assumed that, at least in some formal sense, we cancommute the spatial and temporal derivatives), and then insert theother equation into it: </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} + \frac 14 \Delta^2 w &amp;= 0. \end{align*}
</p>
<p> This equation is hyperbolic and similar in character to the waveequation. (This will also be obvious if you look at the videoin the "Results" section of this program.) Furthermore, we couldhave arrived at the same equation for \(v\) as well.Consequently, a better assumption for the NLSE is to think ofit as a hyperbolic, wave-propagation equation than as a diffusionequation such as the heat equation. (You may wonder whether it iscorrect that the operator \(\Delta^2\) appears with a positive signwhereas in the wave equation, \(\Delta\) has a negative sign. This isindeed correct: After multiplying by a test function and integratingby parts, we want to come out with a positive (semi-)definiteform. So, from \(-\Delta u\) we obtain \(+(\nabla v,\nabla u)\) . Likewise,after integrating by parts twice, we obtain from \(+\Delta^2 u\) theform \(+(\Delta v,\Delta u)\) . In both cases do we get the desired positivesign.) The real NLSE, of course, also has the terms \(V\psi\) and \(\kappa|\psi|^2\psi\) . However, these are of lower order in the spatialderivatives, and while they are obviously important, they do notchange the character of the equation. In any case, the purpose of this discussion is to figure outwhat time stepping scheme might be appropriate for the equation. Theconclusions is that, as a hyperbolic-kind of equation, we need tochoose a time step that satisfies a CFL-type condition. If we were touse an explicit method (which we will not), we would have to investigatethe eigenvalues of the matrix that corresponds to the spatialoperator. If you followed the discussions of the video lectures( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.26.html">video lecture 26</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.27.html">video lecture 27</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>.) then you will remember that the pattern is that one needs to make surethat \(k^s \propto h^t\) where \(k\) is the time step, \(h\) the mesh width,and \(s,t\) are the orders of temporal and spatial derivatives.Whether you take the original equation ( \(s=1,t=2\) ) or the reformulationfor only the real or imaginary part, the outcome is that we would need tochoose \(k \propto h^2\) if we were to use an explicit time steppingmethod. This is not feasible for the same reasons as in <a class="el" href="step_26.html">step-26</a> forthe heat equation: It would yield impractically small time stepsfor even only modestly refined meshes. Rather, we have to use animplicit time stepping method and can then choose a more balanced \(k \propto h\) . Indeed, we will use the implicit Crank-Nicolsonmethod as we have already done in <a class="el" href="step_23.html">step-23</a> before for the regularwave equation.</p>
<p><a class="anchor" id="Thegeneralideaofoperatorsplitting"></a></p><h3>The general idea of operator splitting</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.30.25.html">video lecture 30.25</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) <br  />
 If one thought of the NLSE as an ordinary differential equation inwhich the right hand side happens to have spatial derivatives, i.e.,write it as <p class="formulaDsp">
\begin{align*} \frac{d\psi}{dt} &amp;= i\frac 12 \Delta \psi -i V \psi -i\kappa |\psi|^2 \psi, \qquad\qquad &amp; \text{for}\; t \in (0,T), \\ \psi(0) &amp;= \psi_0, \end{align*}
</p>
 one may be tempted to "formally solve" it by integrating both sidesover a time interval \([t_{n},t_{n+1}]\) and obtain <p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) -i V \psi(t) -i\kappa |\psi(t)|^2 \psi(t) \right) \; dt. \end{align*}
</p>
 Of course, it's not that simple: the \(\psi(t)\) in the integrand isstill changing over time in accordance with the differential equation,so we cannot just evaluate the integral (or approximate it easily viaquadrature) because we don't know \(\psi(t)\) .But we can write this with separate contributions asfollows, and this will allow us to deal with different terms separately: <p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi(t)|^2 \,\psi(t) \right) \; dt. \end{align*}
</p>
 The way this equation can now be read is as follows: For each time interval \([t_{n},t_{n+1}]\) , the change \(\psi(t_{n+1})-\psi(t_{n})\) in thesolution consists of three contributions:</dd></dl>
<ul>
<li>The contribution of the Laplace operator.</li>
<li>The contribution of the potential \(V\) .</li>
<li>The contribution of the "phase" term \(-i\kappa |\psi(t)|^2\,\psi(t)\) . <em>Operator splitting</em> is now an approximation technique thatallows us to treat each of these contributions separately. (If wewant: In practice, we will treat the first two together, and the lastone separate. But that is a detail, conceptually we could treat all ofthem differently.) To this end, let us introduce three separate "solutions": <p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
</li>
</ul>
<p>These three "solutions" can be thought of as satisfying the followingdifferential equations: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n). \end{align*}
</p>
<p> In other words, they are all trajectories \(\psi^{(k)}\) that start at \(\psi(t_n)\) and integrate up the effects of exactly one of the threeterms. The increments resulting from each of these terms over our timeinterval are then \(I^{(1)}=\psi^{(1)}(t_{n+1})-\psi(t_n)\) , \(I^{(2)}=\psi^{(2)}(t_{n+1})-\psi(t_n)\) , and \(I^{(3)}=\psi^{(3)}(t_{n+1})-\psi(t_n)\) . It is now reasonable to assume (this is an approximation!) that thechange due to all three of the effects in question is well approximatedby the sum of the three separate increments: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1})-\psi(t_n) \approx I^{(1)} + I^{(2)} + I^{(3)}. \end{align*}
</p>
<p> This intuition is indeed correct, though the approximation is notexact: the difference between the exact left hand side and the term \(I^{(1)}+I^{(2)}+I^{(3)}\) (i.e., the difference between the <em>exact</em> incrementfor the exact solution \(\psi(t)\) when moving from \(t_n\) to \(t_{n+1}\) ,and the increment composed of the three parts on the right hand side),is proportional to \(\Delta t=t_{n+1}-t_{n}\) . In other words, thisapproach introduces an error of size \({\cal O}(\Delta t)\) . Nothing wehave done so far has discretized anything in time or space, so the<em>overall</em> error is going to be \({\cal O}(\Delta t)\) plus whatevererror we commit when approximating the integrals (the temporaldiscretization error) plus whatever error we commit when approximatingthe spatial dependencies of \(\psi\) (the spatial error). Before we continue with discussions about operator splitting, let ustalk about why one would even want to go this way? The answer issimple: For some of the separate equations for the \(\psi^{(k)}\) , wemay have ways to solve them more efficiently than if we throweverything together and try to solve it at once. For example, andparticularly pertinent in the current case: The equation for \(\psi^{(3)}\) , i.e., </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, \qquad\qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n), \end{align*}
</p>
<p> or equivalently, </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt, \end{align*}
</p>
<p> can be solved exactly: the equation is solved by </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t) = e^{-i\kappa|\psi(t_n)|^2 (t-t_{n})} \psi(t_n). \end{align*}
</p>
<p> This is easy to see if (i) you plug this solution into thedifferential equation, and (ii) realize that the magnitude \(|\psi^{(3)}|\) is constant, i.e., the term \(|\psi(t_n)|^2\) in theexponent is in fact equal to \(|\psi^{(3)}(t)|^2\) . In other words, thesolution of the ODE for \(\psi^{(3)}(t)\) only changes its <em>phase</em>,but the <em>magnitude</em> of the complex-valued function \(\psi^{(3)}(t)\) remains constant. This makes computing \(I^{(3)}\) particularly convenient:we don't actually need to solve any ODE, we can write the solutiondown by hand. Using the operator splitting approach, none of themethods to compute \(I^{(1)},I^{(2)}\) therefore have to deal with the nonlinearterm and all of the associated unpleasantries: we can get away withsolving only <em>linear</em> problems, as long as we allow ourselves theluxury of using an operator splitting approach. Secondly, one often uses operator splitting if the different physicaleffects described by the different terms have different timescales. Imagine, for example, a case where we really did have somesort of diffusion equation. Diffusion acts slowly, but if \(\kappa\) islarge, then the "phase rotation" by the term \(-i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t)\) acts quickly. If we treatedeverything together, this would imply having to take rather small timesteps. But with operator splitting, we can take large time steps \(\Delta t=t_{n+1}-t_{n}\) for the diffusion, and (assuming we didn'thave an analytic solution) use an ODE solver with many small timesteps to integrate the "phase rotation" equation for \(\psi^{(3)}\) from \(t_n\) to \(t_{n+1}\) . In other words, operator splitting allows us todecouple slow and fast time scales and treat them differently, withmethods adjusted to each case.</p>
<p><a class="anchor" id="OperatorsplittingtheLiesplittingapproach"></a></p><h3>Operator splitting: the "Lie splitting" approach</h3>
<p>While the method above allows to compute the three contributions \(I^{(k)}\) in parallel, if we want, the method can be made slightlymore accurate and easy to implement if we don't let the trajectoriesfor the \(\psi^{(k)}\) start all at \(\psi(t_n)\) , but instead let thetrajectory for \(\psi^{(2)}\) start at the <em>end point</em> of thetrajectory for \(\psi^{(1)}\) , namely \(\psi^{(1)}(t_{n+1})\) ; similarly,we will start the trajectory for \(\psi^{(3)}\) start at the end pointof the trajectory for \(\psi^{(2)}\) , namely \(\psi^{(2)}(t_{n+1})\) . Thismethod is then called "Lie splitting" and has the same order of erroras the method above, i.e., the splitting error is \({\cal O}(\Delta t)\) . This variation of operator splitting can be written asfollows (carefully compare the initial conditions to the ones above): </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> (Obviously, while the formulas above imply that we should solve theseproblems in this particular order, it is equally valid to first solvefor trajectory 3, then 2, then 1, or any other permutation.) The integrated forms of these equations are then </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi^{(1)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi^{(2)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> From a practical perspective, this has the advantage that we needto keep around fewer solution vectors: Once \(\psi^{(1)}(t_n)\) has beencomputed, we don't need \(\psi(t_n)\) any more; once \(\psi^{(2)}(t_n)\) has been computed, we don't need \(\psi^{(1)}(t_n)\) any more. And once \(\psi^{(3)}(t_n)\) has been computed, we can just call it \(\psi(t_{n+1})\) because, if you insert the first into the second, andthen into the third equation, you see that the right hand side of \(\psi^{(3)}(t_n)\) now contains the contributions of all three physicaleffects: </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt+ \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> (Compare this again with the "exact" computation of \(\psi(t_{n+1})\) :It only differs in how we approximate \(\psi(t)\) in each of the three integrals.)In other words, Lie splitting is a lot simpler to implement that theoriginal method outlined above because data handling is so muchsimpler.</p>
<p><a class="anchor" id="OperatorsplittingtheStrangsplittingapproach"></a></p><h3>Operator splitting: the "Strang splitting" approach</h3>
<p>As mentioned above, Lie splitting is only \({\cal O}(\Delta t)\) accurate. This is acceptable if we were to use a first order timediscretization, for example using the explicit or implicit Eulermethods to solve the differential equations for \(\psi^{(k)}\) . This isbecause these time integration methods introduce an error proportionalto \(\Delta t\) themselves, and so the splitting error is proportionalto an error that we would introduce anyway, and does not diminish theoverall convergence order. But we typically want to use something higher order</p>
<ul>
<li>say, a<a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a>or<a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">BDF2</a>method</li>
<li>since these are often not more expensive than asimple Euler method. It would be a shame if we were to use a timestepping method that is \({\cal O}(\Delta t^2)\) , but then lose theaccuracy again through the operator splitting. This is where the <a href="https://en.wikipedia.org/wiki/Strang_splitting">Strang splitting</a> method comes in. It is easier to explain if we had onlytwo parts, and so let us combine the effects of the Laplace operatorand of the potential into one, and the phase rotation into a secondeffect. (Indeed, this is what we will do in the code since solving theequation with the Laplace equation with or without the potential coststhe same</li>
<li>so we merge these two steps.) The Lie splitting methodfrom above would then do the following: It computes solutions of thefollowing two ODEs, <p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)} -i V \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i\kappa |\psi^{(2)}|^2 \,\psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \end{align*}
</p>
 and then uses the approximation \(\psi(t_{n+1}) \approx \psi^{(2)}(t_{n+1})\) . In other words, we first make one full time stepfor physical effect one, then one full time step for physical effecttwo. The solution at the end of the time step is simply the sum of theincrements due to each of these physical effects separately. In contrast,<a href="https://en.wikipedia.org/wiki/Gilbert_Strang">Gil Strang</a>(one of the titans of numerical analysis starting in the mid-20thcentury) figured out that it is more accurate to first doone half-step for one physical effect, then a full time step for theother physical effect, and then another half step for the first. Whichone is which does not matter, but because it is so simple to do thephase rotation, we will use this effect for the half steps and thenonly need to do one spatial solve with the Laplace operator pluspotential. This operator splitting method is now \({\cal O}(\Delta t^2)\) accurate. Written in formulas, this yields the followingsequence of steps: <p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= -i\kappa |\psi^{(1)}|^2 \,\psi^{(1)}, &amp;&amp; \text{for}\; t \in (t_n,t_n+\tfrac 12\Delta t), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= i\frac 12 \Delta \psi^{(2)} -i V \psi^{(2)}, \qquad &amp;&amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_n+\tfrac 12\Delta t), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp;&amp; \text{for}\; t \in (t_n+\tfrac 12\Delta t,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
 As before, the first and third step can be computed exactly for thisparticular equation, yielding <p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_n+\tfrac 12\Delta t) &amp;= e^{-i\kappa|\psi(t_n)|^2 \tfrac 12\Delta t} \; \psi(t_n), \\ \psi^{(3)}(t_{n+1}) &amp;= e^{-i\kappa|\psi^{(2)}(t_{n+1})|^2 \tfrac 12\Delta t} \; \psi^{(2)}(t_{n+1}). \end{align*}
</p>
</li>
</ul>
<p>This is then how we are going to implement things in this program:In each time step, we execute three steps, namely</p>
<ul>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by one half time step;</li>
<li>Solving the space-time equation that corresponds to the full step for \(\psi^{(2)}\) , namely \(-i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0\) , with initial conditions equal to the solution of the first half step above.</li>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by another half time step. This structure will be reflected in an obvious way in the main timeloop of the program.</li>
</ul>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>From the discussion above, it should have become clear that the onlypartial differential equation we have to solve in each time step is </p><p class="formulaDsp">
\begin{align*} -i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0. \end{align*}
</p>
<p> This equation is linear. Furthermore, we only have to solve it from \(t_n\) to \(t_{n+1}\) , i.e., for exactly one time step. To do this, we will apply the second order accurate Crank-Nicolsonscheme that we have already used in some of the other time dependentcodes (specifically: <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_26.html">step-26</a> ). It reads as follows: </p><p class="formulaDsp">
\begin{align*} -i\frac{\psi^{(n,2)}-\psi^{(n,1)}}{k_{n+1}} - \frac 12 \Delta \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] + V \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] = 0. \end{align*}
</p>
<p> Here, the "previous" solution \(\psi^{(n,1)}\) (or the "initialcondition" for this part of the time step) is the output of thefirst phase rotation half-step; the output of the current step willbe denoted by \(\psi^{(n,2)}\) . \(k_{n+1}=t_{n+1}-t_n\) isthe length of the time step. (One could argue whether \(\psi^{(n,1)}\) and \(\psi^{(n,1)}\) live at time step \(n\) or \(n+1\) and what their upperindices should be. This is a philosophical discussion without practicalimpact, and one might think of \(\psi^{(n,1)}\) as something like \(\psi^{(n+\tfrac 13)}\) , and \(\psi^{(n,2)}\) as \(\psi^{(n+\tfrac 23)}\) if that helps clarify things</p>
<ul>
<li>though, again \(n+\frac 13\) is not to be understood as "one third time step after  @f$t_n@f$  " but more like "we've already done one third of the work necessaryfor time step   @f$n+1@f$  ".) If we multiply the whole equation with \(k_{n+1}\) and sort terms withthe unknown \(\psi^{(n+1,2)}\) to the left and those with the known \(\psi^{(n,2)}\) to the right, then we obtain the following (spatial)partial differential equation that needs to be solved in each timestep: <p class="formulaDsp">
\begin{align*} -i\psi^{(n,2)} - \frac 14 k_{n+1} \Delta \psi^{(n,2)} + \frac 12 k_{n+1} V \psi^{(n,2)} = -i\psi^{(n,1)} + \frac 14 k_{n+1} \Delta \psi^{(n,1)} - \frac 12 k_{n+1} V \psi^{(n,1)}. \end{align*}
</p>
</li>
</ul>
<p><a class="anchor" id="Spatialdiscretizationanddealingwithcomplexvariables"></a></p><h3>Spatial discretization and dealing with complex variables</h3>
<p>As mentioned above, the previous tutorial program dealing withcomplex-valued solutions (namely, <a class="el" href="step_29.html">step-29</a> ) separated real and imaginaryparts of the solution. It thus reduced everything to realarithmetic. In contrast, we here want to keep thingscomplex-valued. The first part of this is that we need to define the discretizedsolution as \(\psi_h^n(\mathbf x)=\sum_j \Psi^n_j \varphi_j(\mathbf x) \approx \psi(\mathbf x,t_n)\) where the \(\varphi_j\) are the usual shape functions (which arereal valued) but the expansion coefficients \(\Psi^n_j\) at time step \(n\) are now complex-valued. This is easily done in deal.II: We justhave to use <a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt; instead of <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> tostore these coefficients. Of more interest is how to build and solve the linearsystem. Obviously, this will only be necessary for the second step ofthe Strang splitting discussed above, with the time discretization ofthe previous subsection. We obtain the fully discrete version throughstraightforward substitution of \(\psi^n\) by \(\psi^n_h\) andmultiplication by a test function: </p><p class="formulaDsp">
\begin{align*} -iM\Psi^{(n,2)} + \frac 14 k_{n+1} A \Psi^{(n,2)} + \frac 12 k_{n+1} W \Psi^{(n,2)} = -iM\Psi^{(n+1,1)} - \frac 14 k_{n+1} A \Psi^{(n,1)} - \frac 12 k_{n+1} W \Psi^{(n,1)}, \end{align*}
</p>
<p> or written in a more compact way: </p><p class="formulaDsp">
\begin{align*} \left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}. \end{align*}
</p>
<p> Here, the matrices are defined in their obvious ways: </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= (\varphi_i,\varphi_j), \\ A_{ij} &amp;= (\nabla\varphi_i,\nabla\varphi_j), \\ W_{ij} &amp;= (\varphi_i,V \varphi_j). \end{align*}
</p>
<p> Note that all matrices individually are in fact symmetric,real-valued, and at least positive semidefinite, though the same isobviously not true forthe system matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and the corresponding matrix \(R = -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W\) on the right hand side.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.34.html">video lecture 34</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) <br  />
 The only remaining important question about the solution procedure ishow to solve the complex-valued linear system <p class="formulaDsp">
\begin{align*} C \Psi^{(n+1,2)} = R \Psi^{(n+1,1)}, \end{align*}
</p>
 with the matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and a right hand side that is easily computed as the product ofa known matrix and the previous part-step's solution.As usual, this comes down to the question of what properties thematrix \(C\) has. If it is symmetric and positive definite, then we canfor example use the Conjugate Gradient method. Unfortunately, the matrix's only useful property is that it is complexsymmetric, i.e., \(C_{ij}=C_{ji}\) , as is easy to see by recalling that \(M,A,W\) are all symmetric. It is not, however,<a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>,which would require that \(C_{ij}=\bar C_{ji}\) where the bar indicates complexconjugation. Complex symmetry can be exploited for iterative solvers as a quickliterature search indicates. We will here not try to become toosophisticated (and indeed leave this to the <a href="#extensions">Possibilities for extensions</a> section below) andinstead simply go with the good old standby for problems withoutproperties: A direct solver. That's not optimal, especially for largeproblems, but it shall suffice for the purposes of a tutorial program.Fortunately, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows solving complex-valuedproblems.</dd></dl>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>Initial conditions for the NLSE are typically chosen to representparticular physical situations. This is beyond the scope of thisprogram, but suffice it to say that these initial conditions <a class="el" href="coding__conventions__0_8txt.html#a0ed0482a2ac822aad449d41825a21390">are(i)</a> often superpositions of the wave functions of particles locatedat different points, and that (ii) because \(|\psi(\mathbf x,t)|^2\) corresponds to a particle density function, the integral </p><p class="formulaDsp">
\[ N(t) = \int_\Omega |\psi(\mathbf x,t)|^2 \]
</p>
<p>@_fakenlcorresponds to the number of particles in the system. (Clearly, ifone were to be physically correct, \(N(t)\) better be a constant ifthe system is closed, or \(\frac{dN}{dt}&lt;0\) if one has absorbingboundary conditions.) The important point is that one should chooseinitial conditions so that </p><p class="formulaDsp">
\[ N(0) = \int_\Omega |\psi_0(\mathbf x)|^2 \]
</p>
<p>@_fakenlmakes sense. What we will use here, primarily because it makes for good graphics,is the following: </p><p class="formulaDsp">
\[ \psi_0(\mathbf x) = \sqrt{\sum_{k=1}^4 \alpha_k e^{-\frac{r_k^2}{R^2}}}, \]
</p>
<p>@_fakenlwhere \(r_k = |\mathbf x-\mathbf x_k|\) is the distance from the (fixed)locations \(\mathbf x_k\) , and \(\alpha_k\) are chosen so that each of the Gaussians that we areadding up adds an integer number of particles to \(N(0)\) . We achievethis by making sure that </p><p class="formulaDsp">
\[ \int_\Omega \alpha_k e^{-\frac{r_k^2}{R^2}} \]
</p>
<p>@_fakenlis a positive integer. In other words, we need to choose \(\alpha\) as an integer multiple of </p><p class="formulaDsp">
\[ \left(\int_\Omega e^{-\frac{r_k^2}{R^2}}\right)^{-1} = \left(R^d\sqrt{\pi^d}\right)^{-1}, \]
</p>
<p>@_fakenlassuming for the moment that \(\Omega={\mathbb R}^d\)</p>
<ul>
<li>which isof course not the case, but we'll ignore the small difference inintegral. Thus, we choose \(\alpha_k=\left(R^d\sqrt{\pi^d}\right)^{-1}\) for all, and \(R=0.1\) . This \(R\) is small enough that the difference between theexact (infinite) integral and the integral over \(\Omega\) should not betoo concerning.We choose the four points \(\mathbf x_k\) as \((\pm 0.3, 0), (0, \pm 0.3)\)</li>
<li>also far enough away from the boundary of \(\Omega\) to keepourselves on the safe side. For simplicity, we pose the problem on the square \([-1,1]^2\) . Forboundary conditions, we will use time-independent Neumann conditions of theform <p class="formulaDsp">
\[ \nabla\psi(\mathbf x,t)\cdot \mathbf n=0 \qquad\qquad \forall \mathbf x\in\partial\Omega. \]
</p>
@_fakenlThis is not a realistic choice of boundary conditions but sufficientfor what we want to demonstrate here. We will comment further on thisin the <a href="#extensions">Possibilities for extensions</a> section below. Finally, we choose \(\kappa=1\) , and the potential as <p class="formulaDsp">
\[ V(\mathbf x) = \begin{cases} 0 &amp; \text{if}\; |\mathbf x|&lt;0.7 \\ 1000 &amp; \text{otherwise}. \end{cases} \]
</p>
@_fakenlUsing a large potential makes sure that the wave function \(\psi\) remainssmall outside the circle of radius 0.7. All of the Gaussians that makeup the initial conditions are within this circle, and the solution willmostly oscillate within it, with a small amount of energy radiating intothe outside. The use of a large potential also makes sure that the nonphysicalboundary condition does not have too large an effect.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with the usual include files, all of which you should have seen before by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Then the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep58.html">Step58</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>The <code>NonlinearSchroedingerEquation</code> class</h3>
<p><br  />
 Then the main class. It looks very much like the corresponding classes in <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a> , with the only exception that the matrices and vectors and everything else related to the linear system are now storing elements of type <code>std::complex&lt;double&gt;</code> instead of just <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>NonlinearSchroedingerEquation</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  NonlinearSchroedingerEquation();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_system();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_matrices();</div>
<div class="line">  <span class="keywordtype">void</span> do_half_phase_step();</div>
<div class="line">  <span class="keywordtype">void</span> do_full_spatial_step();</div>
<div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; system_rhs;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>;</div>
<div class="line">  <span class="keywordtype">double</span>       time_step;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial values, as well as a right hand side class. (We will reuse the initial conditions also for the boundary values, which we simply keep constant.) We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not look surprising. The only point of interest is that we here have a complex-valued problem, so we have to provide the second template argument of the <a class="el" href="classFunction.html">Function</a> class (which would otherwise default to <code>double</code>). Furthermore, the return type of the <code><a class="el" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value()</a></code> functions is then of course also complex. <br  />
 What precisely these functions return has been discussed at the end of the Introduction section.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div>
<div class="line">   {</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">     InitialValues()</div>
<div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, std::complex&lt;<a class="code" href="hdf5__0_8txt.html#aae153b86de45d3354cd3edd5b992435e">double</a>&gt;&gt;(1)</div>
<div class="line">     {}</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">virtual</span> std::complex&lt;double&gt;</div>
<div class="line">     <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">   };</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   std::complex&lt;double&gt;</div>
<div class="line">   <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">InitialValues&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{</div>
<div class="line">     static_assert(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div>
<div class="line">  </div>
<div class="line">     (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0,</div>
<div class="line">  </div>
<div class="line">-0.3},</div>
<div class="line">                                                     {0, +0.3},</div>
<div class="line">                                                     {+0.3, 0},</div>
<div class="line">                                                     {-0.3, 0}};</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> =</div>
<div class="line">       1. / (<a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) <a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> / 2.));</div>
<div class="line">  </div>
<div class="line">     <span class="keywordtype">double</span> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> = 0;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div>
<div class="line">       {</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div>
<div class="line">  </div>
<div class="line">- vortex_center;</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div>
<div class="line">  </div>
<div class="line">         <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> += <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r r) / (R R));</div>
<div class="line">       }</div>
<div class="line">  </div>
<div class="line">     <span class="keywordflow">return</span> {<a class="code" href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>), 0.};</div>
<div class="line">   }</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">   {</div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">     Potential() = <span class="keywordflow">default</span>;</div>
<div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">   };</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">Potential&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{</div>
<div class="line">     (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line">  </div>
<div class="line">     <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) &gt; 0.7 ? 1000 : 0);</div>
<div class="line">   }</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>Implementation of the <code>NonlinearSchroedingerEquation</code> class</h3>
<p>We start by specifying the implementation of the constructor of the class. There is nothing of surprise to see here except perhaps that we choose quadratic ( \(Q_2\) ) Lagrange elements</p>
<ul>
<li>the solution is expected to be smooth, so we choose a higher polynomial degree than the bare minimum.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div>
<div class="line">  : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(2)</div>
<div class="line">  , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>(0)</div>
<div class="line">  , time_step(1. / 128)</div>
<div class="line">  , timestep_number(0)</div>
<div class="line">  , <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>(1)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="Settingupdatastructuresandassemblingmatrices"></a> </p><h4>Setting up data structures and assembling matrices</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div>
<div class="line">   {</div>
<div class="line">     <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">  </div>
<div class="line">-1, 1);</div>
<div class="line">     <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(6);</div>
<div class="line">  </div>
<div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells()</div>
<div class="line">               &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line">  </div>
<div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div>
<div class="line">               &lt;&lt; std::endl</div>
<div class="line">               &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">     <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">     <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line">  </div>
<div class="line">     system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">     rhs_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">     system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">   }</div>
</div><!-- fragment --><p>Next, we assemble the relevant matrices. The way we have written the Crank-Nicolson discretization of the spatial step of the Strang splitting (i.e., the second of the three partial steps in each time step), we were led to the linear system \(\left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}\) . In other words, there are two matrices in play here</p>
<ul>
<li>one for the left and one for the right hand side. We build these matrices separately. (One could avoid building the right hand side matrix and instead just form theaction* of the matrix on \(\Psi^{(n,1)}\) in each time step. This may or may not be more efficient, but efficiency is not foremost on our minds for this program.)</li>
</ul>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div>
<div class="line">   {</div>
<div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                             quadrature_formula,</div>
<div class="line">                             <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                               <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line">  </div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                      <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                      <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  </div>
<div class="line">     std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">     std::vector&lt;double&gt;                  potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">     <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div>
<div class="line">  </div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">       {</div>
<div class="line">         cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div>
<div class="line">         cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div>
<div class="line">  </div>
<div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">  </div>
<div class="line">         potential.value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                              potential_values);</div>
<div class="line">  </div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_index)</div>
<div class="line">           {</div>
<div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">               {</div>
<div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>)</div>
<div class="line">                   {</div>
<div class="line">                     <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = {0, 1};</div>
<div class="line">  </div>
<div class="line">                     cell_matrix_lhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                       (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                        time_step / 4 fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                        time_step / 2 potential_values[q_index]</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index))</div>
<div class="line">                       fe_values.JxW(q_index);</div>
<div class="line">  </div>
<div class="line">                     cell_matrix_rhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                       (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)</div>
<div class="line">  </div>
<div class="line">-</div>
<div class="line">                        time_step / 4 fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)</div>
<div class="line">  </div>
<div class="line">-</div>
<div class="line">                        time_step / 2 potential_values[q_index]</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index)</div>
<div class="line">                          fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index))</div>
<div class="line">                       fe_values.JxW(q_index);</div>
<div class="line">                   }</div>
<div class="line">               }</div>
<div class="line">           }</div>
<div class="line">  </div>
<div class="line">         <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">         <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_lhs,</div>
<div class="line">                                                <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                                system_matrix);</div>
<div class="line">         <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_rhs,</div>
<div class="line">                                                <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                                rhs_matrix);</div>
<div class="line">       }</div>
<div class="line">   }</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementingtheStrangsplittingsteps"></a> </p><h4>Implementing the Strang splitting steps</h4>
<p>Having set up all data structures above, we are now in a position to implement the partial steps that form the Strang splitting scheme. We start with the half-step to advance the phase, and that is used as the first and last part of each time step. <br  />
 To this end, recall that for the first half step, we needed to compute \(\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}\) . Here, \(\psi^{(n,0)}=\psi^{(n)}\) and \(\psi^{(n,1)}\) are functions of space and correspond to the output of the previous complete time step and the result of the first of the three part steps, respectively. A corresponding solution must be computed for the third of the part steps, i.e. \(\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}\) , where \(\psi^{(n,3)}=\psi^{(n+1)}\) is the result of the time step as a whole, and its input \(\psi^{(n,2)}\) is the result of the spatial step of the Strang splitting. An important realization is that while \(\psi^{(n,0)}(\mathbf x)\) may be a finite element function (i.e., is piecewise polynomial), this may not necessarily be the case for the "rotated" function in which we have updated the phase using the exponential factor (recall that the amplitude of that function remains constant as part of that step). In other words, we couldcompute* \(\psi^{(n,1)}(\mathbf x)\) at every point \(\mathbf x\in\Omega\) , but we can't represent it on a mesh because it is not a piecewise polynomial function. The best we can do in a discrete setting is to compute a projection or interpolation. In other words, we can compute \(\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)\) where \(\Pi_h\) is a projection or interpolation operator. The situation is particularly simple if we choose the interpolation: Then, all we need to compute is the value of the right hand sideat the node points* and use these as nodal values for the vector \(\Psi^{(n,1)}\) of degrees of freedom. This is easily done because evaluating the right hand side at node points for a Lagrange finite element as used here requires us to only look at a single (complex-valued) entry of the node vector. In other words, what we need to do is to compute \(\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j\) where \(j\) loops over all of the entries of our solution vector. This is what the function below does</p>
<ul>
<li>in fact, it doesn't even use separate vectors for \(\Psi^{(n,0)}\) and \(\Psi^{(n,1)}\) , but just updates the same vector as appropriate.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> : <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>         = {0, 1};</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(<a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a> magnitude magnitude (time_step / 2))</div>
<div class="line">              <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The next step is to solve for the linear system in each time step, i.e., the second half step of the Strang splitting we use. Recall that it had the form \(C\Psi^{(n,2)} = R\Psi^{(n,1)}\) where \(C\) and \(R\) are the matrices we assembled earlier. <br  />
 The way we solve this here is using a direct solver. We first form the right hand side \(r=R\Psi^{(n,1)}\) using the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult()</a> function and put the result into the <code>system_rhs</code> variable. We then call SparseDirectUMFPACK::solver() which takes as argument the matrix \(C\) and the right hand side vector and returns the solution in the same vector <code>system_rhs</code>. The final step is then to put the solution so computed back into the <code>solution</code> variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div>
<div class="line">{</div>
<div class="line">  rhs_matrix.vmult(system_rhs, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div>
<div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a> = system_rhs;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Creatinggraphicaloutput"></a> </p><h4>Creating graphical output</h4>
<p>The last of the helper functions and classes we ought to discuss are the ones that create graphical output. The result of running the half and full steps for the local and spatial parts of the Strang splitting is that we have updated the <code>solution</code> vector \(\Psi^n\) to the correct value at the end of each time step. Its entries contain complex numbers for the solution at the nodes of the finite element mesh. <br  />
 Complex numbers are not easily visualized. We can output their real and imaginary parts, i.e., the fields \(\text{Re}(\psi_h^{(n)}(\mathbf x))\) and \(\text{Im}(\psi_h^{(n)}(\mathbf x))\) , and that is exactly what the <a class="el" href="classDataOut.html">DataOut</a> class does when one attaches as complex-valued vector via <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> and then calls <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. That is indeed what we do below.</p>
<p>But oftentimes we are not particularly interested in real and imaginary parts of the solution vector, but instead in derived quantities such as the magnitude \(|\psi|\) and phase angle \(\text{arg}(\psi)\) of the solution. In the context of quantum systems such as here, the magnitude itself is not so interesting, but instead it is the "amplitude", \(|\psi|^2\) that is a physical property: it corresponds to the probability density of finding a particle in a particular place of state. The way to put computed quantities into output files for visualization</p>
<ul>
<li>as used in numerous previous tutorial programs</li>
<li>is to use the facilities of the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> and derived classes. Specifically, both the amplitude of a complex number and its phase angles are scalar quantities, and so the <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> class is the right tool to base what we want to do on. <br  />
 Consequently, what we do here is to implement two classes <code>ComplexAmplitude</code> and <code>ComplexPhase</code> that compute for each point at which <a class="el" href="classDataOut.html">DataOut</a> decides to generate output, the amplitudes \(|\psi_h|^2\) and phases \(\text{arg}(\psi_h)\) of the solution for visualization. There is a fair amount of boiler-plate code below, with the only interesting parts of the first of these two classes being how its <code>evaluate_vector_field()</code> function computes the <code>computed_quantities</code> object. <br  />
 (There is also the rather awkward fact that the <a href="https://en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a> function does not compute what one would naively imagine, namely \(|\psi|\) , but returns \(|\psi|^2\) instead. It's certainly quite confusing to have a standard function mis-named in such a way...)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DataPostprocessors</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ComplexAmplitude();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div>
<div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">    <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                       inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1));</div>
<div class="line">        computed_quantities[q](0) = <a class="code" href="multithreading__0_8txt.html#a0759c0124e216ec36f063ad051f4dba0">std::norm</a>(psi);</div>
<div class="line">      }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The second of these postprocessor classes computes the phase angle of the complex-valued solution at each point. In other words, if we represent \(\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}\) , then this class computes \(\varphi(\mathbf x,t)\) . The function <a href="https://en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> does this for us, and returns the angle as a real number between \(-\pi\) and \(+\pi\) . <br  />
 For reasons that we will explain in detail in the results section, we do not actually output this value at each location where output is generated. Rather, we take the maximum over all evaluation points of the phase and then fill each evaluation point's output field with this maximum</p>
<ul>
<li>in essence, we output the phase angle as a piecewise constant field, where each cell has its own constant value. The reasons for this will become clear once you read through the discussion further down below.</li>
</ul>
<div class="fragment"><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">     <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">     {</div>
<div class="line">     <span class="keyword">public</span>:</div>
<div class="line">       ComplexPhase();</div>
<div class="line">  </div>
<div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">         <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">     };</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">     ComplexPhase&lt;dim&gt;::ComplexPhase()</div>
<div class="line">       : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">     {}</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">     <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">       <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">     </span>{</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                   inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line">  </div>
<div class="line">       <span class="keywordtype">double</span> max_phase =</div>
<div class="line">  </div>
<div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">         {</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line">  </div>
<div class="line">           max_phase =</div>
<div class="line">             <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_phase,</div>
<div class="line">                      std::arg(</div>
<div class="line">                        std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                             inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1))));</div>
<div class="line">         }</div>
<div class="line">  </div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a> : computed_quantities)</div>
<div class="line">         <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(0) = max_phase;</div>
<div class="line">     }</div>
<div class="line">  </div>
<div class="line">   } <span class="comment">// namespace DataPostprocessors</span></div>
</div><!-- fragment --><p>Having so implemented these post-processors, we create output as we always do. As in many other time-dependent tutorial programs, we attach flags to <a class="el" href="classDataOut.html">DataOut</a> that indicate the number of the time step and the current simulation time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div>
<div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;Psi&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_magnitude);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_phase);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, timestep_number));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Runningthesimulation"></a> </p><h4>Running the simulation</h4>
<p>The remaining step is how we set up the overall logic for this program. It's really relatively simple: Set up the data structures; interpolate the initial conditions onto finite element space; then iterate over all time steps, and on each time step perform the three parts of the Strang splitting method. Every tenth time step, we generate graphical output. That's it.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_matrices();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> = 0;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;= end_time; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">      {</div>
<div class="line">        ++timestep_number;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        do_half_phase_step();</div>
<div class="line">        do_full_spatial_step();</div>
<div class="line">        do_half_phase_step();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div>
<div class="line">          output_results();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step58</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The <a class="el" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> function</h4>
<p>The rest is again boiler plate and exactly as in almost all of the previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep58.html">Step58</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;2&gt;</a> nse;</div>
<div class="line">      nse.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the code results in screen output like the following:<code>Number of active cells: 4096Number of degrees of freedom: 16641 Time step 1 at t=0Time step 2 at t=0.00390625Time step 3 at t=0.0078125Time step 4 at t=0.0117188[...]</code>Running the program also yields a good number of output files that we willvisualize in the following.</p>
<p><a class="anchor" id="Visualizingthesolution"></a></p><h3>Visualizing the solution</h3>
<p>The <code>output_results()</code> function of this program generates output files thatconsist of a number of variables: The solution (split into its real and imaginaryparts), the amplitude, and the phase. If we visualize these four fields, we getimages like the following after a few time steps (at time \(t=0.242\) , to beprecise: </p><div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="Real part of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="Imaginary part of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="Amplitude of the solution at t=0.242" width="400" class="inline"/> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="Phase of the solution at t=0.242" width="400" class="inline"/> </div> </div><p> <br  />
 While the real and imaginary parts of the solution shown above are notparticularly interesting (because, from a physical perspective, theglobal offset of the phase and therefore the balance between real andimaginary components, is meaningless), it is much more interesting tovisualize the amplitude \(|\psi(\mathbf x,t)|^2\) and phase \(\text{arg}(\psi(\mathbf x,t))\) of the solution and, in particular,their evolution. This leads to pictures like the following: The phase picture shown here clearly has some flaws:</p>
<ul>
<li>First, phase is a "cyclic quantity", but the color scale uses a fundamentally different color for values close to \(-\pi\) than for values close to \(+\pi\) . This is a nuisance</li>
<li>what we need is a "cyclic color map" that uses the same colors for the two extremes of the range of the phase. Such color maps exist, see <a href="https://nicoguaro.github.io/posts/cyclic_colormaps/">this blog post of Nicolás Guarín-Zapata</a> or <a href="https://stackoverflow.com/questions/23712207/cyclic-colormap-without-visual-distortions-for-use-in-phase-angle-plots">this StackExchange post</a>, for example. The problem is that the author's favorite one of the two big visualization packages, VisIt, does not have any of these color maps built in. In an act of desperation, I therefore had to resort to using Paraview given that it has several of the color maps mentioned in the post above implemented. The picture below uses the <code>nic_Edge</code> map in which both of the extreme values are shown as black.</li>
<li> align="center"There is a problem on cells in which the phase wraps around. If at some evaluation point of the cell the phase value is close to \(-\pi\) and at another evaluation point it is close to \(+\pi\) , then what we would really like to happen is for the entire cell to have a color close to the extremes. But, instead, visualization programs produce a linear interpolation in which the values within the cell, i.e., between the evaluation points, is linearly interpolated between these two values, covering essentially the entire range of possible phase values and, consequently, cycling through the entire rainbow of colors from dark red to dark green over the course of one cell. The solution to this problem is to just output the phase value on each cell as a piecewise constant. Because averaging values close to the \(-\pi\) and \(+\pi\) is going to result in an average that has nothing to do with the actual phase angle, the <code>ComplexPhase</code> class just uses themaximal* phase angle encountered on each cell. With these modifications, the phase plot now looks as follows: </li>
</ul>
<p><img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="Phase of the solution at t=0.242, with a cyclic color map" width="400" class="inline"/> </p>
<p><br  />
 Finally, we can generate a movie out of this. (To be precise, the videouses two more global refinement cycles and a time step half the sizeof what is used in the program above.) The author of these linesmade the movie with VisIt,because that's what he's more familiar with, and using a hacked color mapthat is also cyclic</p>
<ul>
<li>though this color map lacks all of the skill employed bythe people who wrote the posts mentioned in the links above. Itdoes, however, show the character of the solution as a wave equationif you look at the shaded part of the domain outside the circle ofradius 0.7 in which the potential is zero</li>
<li>you can see how every timeone of the bumps (showing the amplitude \(|\psi_h(\mathbf x,t)|^2\) )bumps into the area where the potential is large: a wave travelsoutbound from there. Take a look at the video:  
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nraszP3GZHk"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</li>
</ul>
<p>So why did I end up shading the area where the potential \(V(\mathbf x)\) islarge? In that outside region, the solution is relatively small. It is alsorelatively smooth. As a consequence, to some approximate degree, theequation in that region simplifies to </p><p class="formulaDsp">
\[ - i \frac{\partial \psi}{\partial t} + V \psi \approx 0, \]
</p>
<p>@_fakenlor maybe easier to read: </p><p class="formulaDsp">
\[ \frac{\partial \psi}{\partial t} \approx - i V \psi. \]
</p>
<p>@_fakenlTo the degree to which this approximation is valid (which, among other things,eliminates the traveling waves you can see in the video), this equation hasa solution </p><p class="formulaDsp">
\[ \psi(\mathbf x, t) = \psi(\mathbf x, 0) e^{-i V t}. \]
</p>
<p>@_fakenlBecause \(V\) is large, this means that the phaserotates quite rapidly*.If you focus on the semi-transparent outer part of the domain, you cansee that. If one colors this region in the same way as the inner part ofthe domain, this rapidly flashing outer part may be psychedelic, but is alsodistracting of what's happening on the inside; it's also quite hard toactually see the radiating waves that are easy to see at the beginningof the video.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Betterlinearsolvers"></a></p><h4>Better linear solvers </h4>
<p>The solver chosen here is just too simple. It is also not efficient.What we do here is give the matrix to a sparse direct solver in everytime step and let it find the solution of the linear system. But weknow that we could do far better:</p>
<ul>
<li>First, we should make use of the fact that the matrix doesn't actually change from time step to time step. This is an artifact of the fact that we here have constant boundary values and that we don't change the time step size</li>
<li>two assumptions that might not be true in actual applications. But at least in cases where this does happen to be the case, it would make sense to only factorize the matrix once (i.e., compute \(L\) and \(U\) factors once) and then use these factors for all following time steps until the matrix \(C\) changes and requires a new factorization. The interface of the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows for this.</li>
<li>Ultimately, however, sparse direct solvers are only efficient for relatively small problems, say up to a few 100,000 unknowns. Beyond this, one needs iterative solvers such as the Conjugate Gradient method (for symmetric and positive definite problems) or GMRES. We have used many of these in other tutorial programs. In all cases, they need to be accompanied by good preconditioners. For the current case, one could in principle use GMRES</li>
<li>a method that does not require any specific properties of the matrix</li>
<li>but would be better advised to implement an iterative scheme that exploits the one structural feature we know is true for this problem: That the matrix is complex-symmetric (albeit not Hermitian).</li>
</ul>
<p><a class="anchor" id="Boundaryconditions"></a></p><h4>Boundary conditions </h4>
<p>In order to be usable for actual, realistic problems, solvers for thenonlinear Schr&ouml;dinger equation need to utilize boundary conditionsthat make sense for the problem at hand. We have here restricted ourselvesto simple Neumann boundary conditions</p>
<ul>
<li>but these do not actually makesense for the problem. Indeed, the equations are generally posed on aninfinite domain. But, since we can't compute on infinite domains, we needto truncate it somewhere and instead pose boundary conditions that makesense for this artificially small domain. The approach widely used is touse the <a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Perfectly Matched Layer</a> method that corresponds to a particularkind of attenuation. It is, in a different context, also used in <a class="el" href="step_62.html">step-62</a> .</li>
</ul>
<p><a class="anchor" id="Adaptivemeshes"></a></p><h4>Adaptive meshes </h4>
<p>Finally, we know from experience and many other tutorial programs thatit is worthwhile to use adaptively refined meshes, rather than the uniformmeshes used here. It would, in fact, not be very difficult to add thishere: It just requires periodic remeshing and transfer of the solutionfrom one mesh to the next. <a class="el" href="step_26.html">step-26</a> will be a good guide for how thiscould be implemented.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University</span></div>
<div class="line"><span class="comment"> *         Yong-Yong Cai, Beijing Computational Science Research Center</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep58.html">Step58</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation</a>();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_matrices();</div>
<div class="line">    <span class="keywordtype">void</span> do_half_phase_step();</div>
<div class="line">    <span class="keywordtype">void</span> do_full_spatial_step();</div>
<div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">    SparseMatrix&lt;std::complex&lt;double&gt;&gt; system_matrix;</div>
<div class="line">    SparseMatrix&lt;std::complex&lt;double&gt;&gt; rhs_matrix;</div>
<div class="line"> </div>
<div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; system_rhs;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span>       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>;</div>
<div class="line">    <span class="keywordtype">double</span>       time_step;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    InitialValues()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, std::complex&lt;<a class="code" href="hdf5__0_8txt.html#aae153b86de45d3354cd3edd5b992435e">double</a>&gt;&gt;(1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt;</div>
<div class="line">    <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  std::complex&lt;double&gt;</div>
<div class="line">  <a class="code" href="classStep58_1_1InitialValues.html#a152471cc082d1c37b4ca7d071391a3dc">InitialValues&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    static_assert(<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div>
<div class="line">                                                    {0, +0.3},</div>
<div class="line">                                                    {+0.3, 0},</div>
<div class="line">                                                    {-0.3, 0}};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> =</div>
<div class="line">      1. / (<a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>) * <a class="code" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> / 2.));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> - vortex_center;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> += <a class="code" href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">alpha</a> * <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code" href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">std::sqrt</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>), 0.};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Potential() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> = 0) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="classStep58_1_1Potential.html#a926ccbdec2ac6ffb41023a094ca665d3">Potential&lt;dim&gt;::value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    (void)<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(<a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>, 0, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>) &gt; 0.7 ? 1000 : 0);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html#a7eb28c4ecb2748883c0e6ce67f7d947e">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation</a>()</div>
<div class="line">    : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(2)</div>
<div class="line">    , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">    , <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>(0)</div>
<div class="line">    , time_step(1. / 128)</div>
<div class="line">    , timestep_number(0)</div>
<div class="line">    , <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a>(1)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::setup_system</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(6);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">    <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">    rhs_matrix.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                     <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>,</div>
<div class="line">                                                     <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    std::vector&lt;double&gt;                  potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">    <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">      {</div>
<div class="line">        cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div>
<div class="line">        cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div>
<div class="line"> </div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">        potential.value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                             potential_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_index)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> = 0; <a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>)</div>
<div class="line">                  {</div>
<div class="line">                    <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = {0, 1};</div>
<div class="line"> </div>
<div class="line">                    cell_matrix_lhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                      (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                       time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) +</div>
<div class="line">                       time_step / 2 * potential_values[q_index] *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                      fe_values.JxW(q_index);</div>
<div class="line"> </div>
<div class="line">                    cell_matrix_rhs(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>) +=</div>
<div class="line">                      (-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                       time_step / 4 * fe_values.shape_grad(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_grad(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index) -</div>
<div class="line">                       time_step / 2 * potential_values[q_index] *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a>, q_index) *</div>
<div class="line">                         fe_values.shape_value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">l</a>, q_index)) *</div>
<div class="line">                      fe_values.JxW(q_index);</div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_lhs,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               system_matrix);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix_rhs,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               rhs_matrix);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>         = {0, 1};</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a> = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> * <a class="code" href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">kappa</a> * magnitude * magnitude * (time_step / 2)) *</div>
<div class="line">                <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step</a>()</div>
<div class="line">  {</div>
<div class="line">    rhs_matrix.vmult(system_rhs, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div>
<div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a> = system_rhs;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>DataPostprocessors</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      ComplexAmplitude();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div>
<div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                         inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1));</div>
<div class="line">          computed_quantities[q](0) = <a class="code" href="multithreading__0_8txt.html#a0759c0124e216ec36f063ad051f4dba0">std::norm</a>(psi);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      ComplexPhase();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">        <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    ComplexPhase&lt;dim&gt;::ComplexPhase()</div>
<div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>() == 1,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>(), 1));</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size() == 2,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q].size(), 2));</div>
<div class="line"> </div>
<div class="line">          max_phase =</div>
<div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_phase,</div>
<div class="line">                     std::arg(</div>
<div class="line">                       std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](0),</div>
<div class="line">                                            inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">solution_values</a>[q](1))));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a> : computed_quantities)</div>
<div class="line">        <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(0) = max_phase;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace DataPostprocessors</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;dim&gt;::output_results</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div>
<div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <span class="stringliteral">&quot;Psi&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_magnitude);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, complex_phase);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a>, timestep_number));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">    std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(filename);</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_matrices();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> = 0;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> &lt;= end_time; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> += time_step)</div>
<div class="line">      {</div>
<div class="line">        ++timestep_number;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        do_half_phase_step();</div>
<div class="line">        do_full_spatial_step();</div>
<div class="line">        do_half_phase_step();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div>
<div class="line">          output_results();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step58</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep58.html">Step58</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classStep58_1_1NonlinearSchroedingerEquation.html">NonlinearSchroedingerEquation&lt;2&gt;</a> nse;</div>
<div class="line">      nse.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassStep58_1_1NonlinearSchroedingerEquation_html"><div class="ttname"><a href="classStep58_1_1NonlinearSchroedingerEquation.html">Step58::NonlinearSchroedingerEquation</a></div><div class="ttdef"><b>Definition:</b> <a href="step-58_8cc_source.html#l00050">step-58.cc:50</a></div></div>
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="aclassFEValues_html_a21f914e63d588e2652a9514620653d77"><div class="ttname"><a href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a></div><div class="ttdeci">void reinit(const TriaIterator&lt; DoFCellAccessor&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_a761f008bdeb7d94a69205ae824deefad"><div class="ttname"><a href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a></div><div class="ttdeci">void interpolate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Function&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_afec1b694405cadb2d251275096ad3563"><div class="ttname"><a href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data output</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00059">distributed_0.txt:59</a></div></div>
<div class="ttc" id="ahdf5__0_8txt_html_aae153b86de45d3354cd3edd5b992435e"><div class="ttname"><a href="hdf5__0_8txt.html#aae153b86de45d3354cd3edd5b992435e">double</a></div><div class="ttdeci">*Namespace containing deal II s HDF5 interface whereas writing and reading raw data in a dataset can be done independently or double</div><div class="ttdef"><b>Definition:</b> <a href="hdf5__0_8txt_source.html#l00045">hdf5_0.txt:45</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_adcfa97993e5162228eec03e06ac05330"><div class="ttname"><a href="distributed__0_8txt.html#adcfa97993e5162228eec03e06ac05330">at</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or and in fact problems solved in this mode are usually so and handling distributed and linear solvers is something for which good external libraries such as Trilinos or PETSc exist that can make things look almost exactly the same as they would if everything was available locally The use of this mode of parallelization is explained in the tutorial and[2.x.6] and will not be discussed here in more detail *The use of truly distributed meshes is somewhat more complex because it changes or makes impossible some of the things that can otherwise be done with deal II DoF etc This module documents these issues with a vantage point at</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00027">distributed_0.txt:27</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a8fba07b9a84b89e6be225f5f95c3e355"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div><div class="ttdeci">the program is just and one can not intelligently work around that *It is sometimes useful to change the behavior of the[2.x.6] macro from aborting a program to throwing exceptions On the other exceptions are not allowed to propagate out of destructors of classes For this there is a variant of the called[2.x.7] that can be used in destructors These use cases are discussed further down below on this page **Dynamic such as whether an output file can be written to *These are things that shouldn t be checked because it is not guaranteed that a program for which the condition is satisfied in a debug mode run</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00022">exceptions_0.txt:22</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html_a904b46a59d224ec214e4816e584cba5f"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html#a904b46a59d224ec214e4816e584cba5f">DataPostprocessorInputs::Vector::solution_values</a></div><div class="ttdeci">std::vector&lt;::Vector&lt; double &gt; &gt; solution_values</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00330">data_postprocessor.h:330</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2namespace__dealii_8h_source.html#l00026">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00070">fe_update_flags.h:70</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="astep-1_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="step-1_8cc_source.html#l00086">step-1.cc:86</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a0759c0124e216ec36f063ad051f4dba0"><div class="ttname"><a href="multithreading__0_8txt.html#a0759c0124e216ec36f063ad051f4dba0">norm</a></div><div class="ttdeci">it should be big enough so that we don t spend more time on scheduling sub ranges to processors but small enough that processors can be efficiently load balanced A rule of thumb appears to be that a sub range is too small if it takes less than instructions to execute it *An example of how to use these functions are vector operations like the addition in[2.x.45] where all three objects are of type we used a[1.x.23] to on the a function object that takes two arguments and returns the sum of the two This is exactly what we needed when we want to add the individual elements of vectors[2.x.46] and[2.x.47] and write the sum of the two into the elements of[2.x.48] The function object that we get here is completely known to the compiler and when it expands the loop that results from[2.x.49] will be as if we had written the loop in its obvious thereby eliminating the overhead of calling an external function there are cases where it is inefficient to call some object or function within each iteration *An example for this case is sparse matrix vector multiplication If you know how data is stored in compressed row format like in the SparseMatrix then a matrix vector product function looks like we compute the dot product of a single row of the matrix with the right hand side vector[2.x.51] and write it into the corresponding element of the[2.x.52] vector The code is made more efficient by utilizing that the elements of the[1.x.28] row follow the ones of the current i e at the beginning of the loop body we do not have to re set the pointers that point to the values and column numbers of each row *Using the[2.x.53] function we could in principle write this code as leaving one argument open and thus allowing the[2.x.56] function to consider the passed function argument as unary Also note that we need to make the source and destination vectors neither of which is what we desired notice the grainsize of a minimum of rows of a matrix that should be processed by an individual CPU core *The point is that while this is it is not since now the function object to be called on each row is not a simple[1.x.32] any there is an implicit function call including argument passing in each iteration of the loop *A more efficient way is to let TBB split the original range into sub and then call a target function not on each individual element of the but on the entire range This is facilitated by the[2.x.61] we call the[2.x.62] function on sub ranges of at least elements so that the initial setup cost can amortize *A related operation is when the loops over elements each produce a result that must then be but let s assume for a moment that it is A sequential implementation would look like this for sparse each of which compute their part of the square of the norm</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00124">multithreading_0.txt:124</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="afe_2fe__q_8h_html"><div class="ttname"><a href="fe_2fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><div class="ttname"><a href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; pow(const ::VectorizedArray&lt; Number, width &gt; &amp;x, const ::VectorizedArray&lt; Number, width &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05727">vectorization.h:5727</a></div></div>
<div class="ttc" id="anumerics_2error__estimator_8h_html"><div class="ttname"><a href="numerics_2error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparse__matrix_8h_source.html#l00542">sparse_matrix.h:542</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_aafea668ad0c451ac7a0fae0f558c36d7"><div class="ttname"><a href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a></div><div class="ttdeci">in the area occupied by these artificial cells</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00037">distributed_0.txt:37</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_a93c780f93105e0daaa76c6c43694b4ae"><div class="ttname"><a href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a></div><div class="ttdeci">void write_vtu(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07232">data_out_base.cc:7232</a></div></div>
<div class="ttc" id="alac_2affine__constraints_8h_html"><div class="ttname"><a href="lac_2affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_ad919e2b915d8e8226aef004c2d8399a8"><div class="ttname"><a href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">exception</a></div><div class="ttdeci">since default values may change in the process of program you cannot know the values of parameters not specified in the input file ****It is often convenient to have something happen as soon as a parameter value is read This could be a check that it is valid that a file that is listed in the parameter file exists **or to initiate something else in such as setting a variable outside the this action could also be initiated once all parameters are read via but it is sometimes[1.x.19] to do it right away *This is facilitated by the and can then do whatever they want with it **e save it somewhere outside the ParameterHandler in C one doesn t usually pass around the address of a but an action can be a function like object(taking a string as argument) that results from calling such as a[1.x.20] that has the form **[1.x.21] *and that is attached to a specific parameter. *A typical example of such an action would be as follows the content of the file equals the default value of the parameter the contents of files are never changed after declaration of a parameter a directory in this file system may not have a file called[2.x.20] in it In that the directory represents a subsection as declared and the directory s name will correspond to the name of the subsection It will then have no files in it at but it may have further directories in the code above will lead to a hierarchical representation of data that looks like this(the content of files is indicated at the right in a different font) this is only used when creating output for exceptions If non empty[2.x.35] is the ParameterHandler object will stop parsing lines after encountering[2.x.36] This is handy when adding extra data that shall be parsed manually If[2.x.37] the parameter handler will skip undefined sections and entries This is useful for partially parsing a parameter for example to obtain only the spatial dimension of the problem By default all entries and subsections are expected to be declared The function sets the value of all parameters it encounters in the input file to the provided value Parameters not explicitly listed in the input file are left at the value they previously which will be the default value provided to and for each parameter all associated actions that may previously have been set by or if an associated action throws an exception</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00241">parameter_handler_0.txt:241</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="asolver__cg__0_8txt_html_a557c71e94a2542d697ca3426b8843cd4"><div class="ttname"><a href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">sqrt</a></div><div class="ttdeci">*This class implements the preconditioned Conjugate but is used in many other tutorial programs as well Like all other solver it can work on any kind of vector and matrix as long as they satisfy certain and defaults to *[2.x.2] **This version of CG is taken from D Braess s book Finite Elements It requires a symmetric the projected matrix[2.x.4] is tri diagonal Since the projection is the eigenvalues of[2.x.5] approximate those of the original preconditioned matrix[2.x.6] In after[2.x.7] where[2.x.8] is the dimension of the original the eigenvalues of both matrices are equal even for small numbers of iteration the condition number of[2.x.9] is a good estimate for the one of *[2.x.10] After[2.x.11] steps the matrix T_m can be written in terms of the coefficients[2.x.12] and[2.x.13] as the tri diagonal matrix with diagonal elements&lt; tt &gt;&lt; tt &gt; alpha_1 beta_0&lt; tt &gt;&lt; tt &gt; sqrt(beta_{m-2&lt;/tt &gt;)/alpha_</div><div class="ttdef"><b>Definition:</b> <a href="solver__cg__0_8txt_source.html#l00011">solver_cg_0.txt:11</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_a553ca864aaf70330d9be86bc78f36d1e"><div class="ttname"><a href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a></div><div class="ttdeci">void distribute_dofs(const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00116">fe_update_flags.h:116</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a2cbf5ad6b464871261dbd054bced18a8"><div class="ttname"><a href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">FiniteElementData::degree</a></div><div class="ttdeci">const unsigned int degree</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__base_8h_source.html#l00428">fe_base.h:428</a></div></div>
<div class="ttc" id="apolynomials__abf__0_8txt_html_a7a716deb19e461cf8ba2a26e01c6a908"><div class="ttname"><a href="polynomials__abf__0_8txt.html#a7a716deb19e461cf8ba2a26e01c6a908">k</a></div><div class="ttdeci">*This class implements the[1.x.0] vector valued Arnold Boffi Falk polynomials as described in the article by Arnold Boffi SIAM J Numer Anal pp **The ABF polynomials are constructed such that the divergence is in the tensor product polynomial space[1.x.1] the polynomial order of each component must be two orders higher in the corresponding yielding the polynomial spaces[1.x.2] and[1.x.3] in resp ******Constructor Creates all basis functions for Raviart Thomas polynomials of given degree[2.x.1] k</div><div class="ttdef"><b>Definition:</b> <a href="polynomials__abf__0_8txt_source.html#l00013">polynomials_abf_0.txt:13</a></div></div>
<div class="ttc" id="anumerics_2vector__tools_8h_html"><div class="ttname"><a href="numerics_2vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_a19f846bda83b7e3f4531daacb40c64e1"><div class="ttname"><a href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; exp(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05647">vectorization.h:5647</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="anumerical__algorithms__0_8txt_html_a852a1e245dd2de4943eeb66beeaf65b1"><div class="ttname"><a href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">vector</a></div><div class="ttdeci">****This module groups a diverse set of classes that generally implement some sort of numerical algorithm on top all the basic and finite element classes in the library They are generally unconnected to each other *Some of the like KellyErrorEstimator and act on solutions already and compute derived quantities in the first two or help transferring a set of vectors from one mesh to another *The namespaces and VectorTools provide an assortment of such as creating a Laplace projecting or interpolating a function onto the present finite element etc The difference to the functions in the DoFTools and FETools functions is that they work on the DoFTools functions only act on a given DoFHandler object without reference to a data vector</div><div class="ttdef"><b>Definition:</b> <a href="numerical__algorithms__0_8txt_source.html#l00008">numerical_algorithms_0.txt:8</a></div></div>
<div class="ttc" id="aclassDataPostprocessor_html_a1ba57b598d24d64365d469a854271c68"><div class="ttname"><a href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field</a></div><div class="ttdeci">virtual void evaluate_vector_field(const DataPostprocessorInputs::Vector&lt; dim &gt; &amp;input_data, std::vector&lt; Vector&lt; double &gt;&gt; &amp;computed_quantities) const</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8cc_source.html#l00037">data_postprocessor.cc:37</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a373fbdacd8c486e675b8d2bff8943192"><div class="ttname"><a href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a></div><div class="ttdeci">void distribute_local_to_global(const InVector &amp;local_vector, const std::vector&lt; size_type &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02250">affine_constraints.h:2250</a></div></div>
<div class="ttc" id="anamespaceStep58_html"><div class="ttname"><a href="namespaceStep58.html">Step58</a></div><div class="ttdef"><b>Definition:</b> <a href="step-58_8cc_source.html#l00045">step-58.cc:45</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html"><div class="ttname"><a href="base_2logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a5abc878123b65e2a7a16e57bba0e282e"><div class="ttname"><a href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a></div><div class="ttdeci">******This module deals with constraints on degrees of freedom The central class to deal with constraints is the AffineConstraints class *Constraints typically come from several for one usually enforces them by requiring that degrees of freedom on the boundary have particular for example[2.x.3] if the boundary condition[2.x.4] requires that the finite element solution[2.x.5] at the location of degree of freedom has the value Such constraints are generated by those versions of the[2.x.6] function that take a AffineConstraints for example no normal as happens in flow problems and is handled by the[2.x.11] function or prescribed tangential as happens in electromagnetic problems and is handled by the[2.x.13] function For the former imagine for example that we are at at vertex where the normal vector has the form[2.x.14] and that and[2.x.17] components of the flow field at this vertex are associated with degrees of and Then the no normal flux condition means that we need to have the condition[2.x.18] The prescribed tangential component leads to similar constraints though there is often something on the right hand side ****If you have hanging node constraints</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00020">constraints_0.txt:20</a></div></div>
<div class="ttc" id="anumerics_2matrix__tools_8h_html"><div class="ttname"><a href="numerics_2matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga0d685aad996180f9851183ae3e29019a"><div class="ttname"><a href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">StandardExceptions::ExcIndexRange</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcIndexRange(int arg1, int arg2, int arg3)</div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="aclassTensor_html_afd0934b4edd71063f66a9c67540e79fc"><div class="ttname"><a href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">Tensor::norm</a></div><div class="ttdeci">numbers::NumberTraits&lt; Number &gt;::real_type norm() const</div></div>
<div class="ttc" id="alac_2dynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="lac_2dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="aclassBlockVector_html_adf4d1d6c3538af95309a95da2ded758c"><div class="ttname"><a href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">BlockVector::reinit</a></div><div class="ttdeci">void reinit(const unsigned int n_blocks, const size_type block_size=0, const bool omit_zeroing_entries=false)</div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html_a6c9d8cfe285d568676bb6e308146c147"><div class="ttname"><a href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">SymmetricTensor::sum</a></div><div class="ttdeci">SymmetricTensor&lt; rank, dim, Number &gt; sum(const SymmetricTensor&lt; rank, dim, Number &gt; &amp;local, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a69730bc7f91dd1be17fd083a66514e73"><div class="ttname"><a href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled to indent allsource files that have been changed recently If you want to make sure thatthe indenting is correct for all your you might want to set up apre commit hook One way to do is to copy[2.x.4] to[2.x.5] and make sure it isexecutable *If the system you are working on has more than one version of[2.x.6] degrees of freedom</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00018">coding_conventions_0.txt:18</a></div></div>
<div class="ttc" id="anamespaceStep31_1_1EquationData_html_a0932f2f724c5bb6bae12cd93de21fdba"><div class="ttname"><a href="namespaceStep31_1_1EquationData.html#a0932f2f724c5bb6bae12cd93de21fdba">Step31::EquationData::kappa</a></div><div class="ttdeci">constexpr double kappa</div><div class="ttdef"><b>Definition:</b> <a href="step-31_8cc_source.html#l00073">step-31.cc:73</a></div></div>
<div class="ttc" id="atrilinos__sparse__matrix__0_8txt_html_ab4e34663c28496ee1b07f40fd5d00fa1"><div class="ttname"><a href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a></div><div class="ttdeci">all column elements of a row are stored on the same processor in any case The vector&lt; tt &gt; n_entries_per_row&lt;/tt &gt; specifies the number of entries in each row of the newly generated matrix **This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix__0_8txt_source.html#l00162">trilinos_sparse_matrix_0.txt:162</a></div></div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2dynamic__sparsity__pattern_8h_source.html#l00340">dynamic_sparsity_pattern.h:340</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparsity__pattern_8h_source.html#l00900">sparsity_pattern.h:900</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_ab544a3bf3301a6dd3e705ee352c5551b"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a></div><div class="ttdeci">T sum(const T &amp;t, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="aclassFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="aclassStep58_1_1Potential_html_a926ccbdec2ac6ffb41023a094ca665d3"><div class="ttname"><a href="classStep58_1_1Potential.html#a926ccbdec2ac6ffb41023a094ca665d3">Step58::Potential::value</a></div><div class="ttdeci">virtual double value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const override</div><div class="ttdef"><b>Definition:</b> <a href="step-58_8cc_source.html#l00146">step-58.cc:146</a></div></div>
<div class="ttc" id="anamespaceStep20_1_1PrescribedSolution_html_a6142e18d25af27882714d1787af4ee59"><div class="ttname"><a href="namespaceStep20_1_1PrescribedSolution.html#a6142e18d25af27882714d1787af4ee59">Step20::PrescribedSolution::alpha</a></div><div class="ttdeci">constexpr double alpha</div><div class="ttdef"><b>Definition:</b> <a href="step-20_8cc_source.html#l00087">step-20.cc:87</a></div></div>
<div class="ttc" id="adofs_2dof__tools_8h_html"><div class="ttname"><a href="dofs_2dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="astructDataOutBase_1_1VtkFlags_html"><div class="ttname"><a href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2data__out__base_8h_source.html#l01065">data_out_base.h:1065</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a6aa80537de93aad86dee48bc73f6600b"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6aa80537de93aad86dee48bc73f6600b">Physics::Elasticity::Kinematics::l</a></div><div class="ttdeci">Tensor&lt; 2, dim, Number &gt; l(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a96ecfde131843f52ee49d0e0c1180134"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications in impossible to get right Higher derivatives are even more impossible to do without computer aid Automatic or symbolic differentiation is a way out of and gets compile time</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="alac_2block__sparse__matrix_8h_html"><div class="ttname"><a href="lac_2block__sparse__matrix_8h.html">block_sparse_matrix.h</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_a8f384576a64c89a6fa8352847523e340"><div class="ttname"><a href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for n_q_points</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00537">fe_evaluation_0.txt:537</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l00516">affine_constraints.h:516</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00124">fe_update_flags.h:124</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01581">exceptions.h:1581</a></div></div>
<div class="ttc" id="alac_2block__vector_8h_html"><div class="ttname"><a href="lac_2block__vector_8h.html">block_vector.h</a></div></div>
<div class="ttc" id="alac_2full__matrix_8h_html"><div class="ttname"><a href="lac_2full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="aclassStep58_1_1NonlinearSchroedingerEquation_html_a7eb28c4ecb2748883c0e6ce67f7d947e"><div class="ttname"><a href="classStep58_1_1NonlinearSchroedingerEquation.html#a7eb28c4ecb2748883c0e6ce67f7d947e">Step58::NonlinearSchroedingerEquation::NonlinearSchroedingerEquation</a></div><div class="ttdeci">NonlinearSchroedingerEquation()</div><div class="ttdef"><b>Definition:</b> <a href="step-58_8cc_source.html#l00159">step-58.cc:159</a></div></div>
<div class="ttc" id="afe__q__0_8txt_html_a1a8eaafa20c4d8c9ab128b62a984738c"><div class="ttname"><a href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a></div><div class="ttdeci">*Implementation of a scalar Lagrange finite element[2.x.0] that yields the finite element space of piecewise polynomials of degree[2.x.1] in each coordinate direction This class is realized using tensor product polynomials based on D Lagrange polynomials with Gauss or given support points *The standard constructor of this class takes the degree[2.x.2] of this finite element it can take a quadrature formula[2.x.3] defining the support points of the Lagrange interpolation in one coordinate direction *For more information about the&lt; tt &gt; spacedim&lt;/tt &gt; template parameter check the documentation of FiniteElement or the one of Triangulation **The constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.4] polynomials of degree[2.x.5] This[2.x.6] object provides all values and derivatives of the shape functions In case a quadrature rule is the constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.7] polynomials with the support points from *[2.x.8] Furthermore the constructor fills the[2.x.9] the[2.x.10] equidistant support points at i where one polynomial is one and all the others are zero For higher polynomial degrees</div><div class="ttdef"><b>Definition:</b> <a href="fe__q__0_8txt_source.html#l00009">fe_q_0.txt:9</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="alac_2sparse__direct_8h_html"><div class="ttname"><a href="lac_2sparse__direct_8h.html">sparse_direct.h</a></div></div>
<div class="ttc" id="astep-69_8cc_html_a66a64d07b4db87c87b639bdcf7b18c82"><div class="ttname"><a href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; local_dof_indices</div><div class="ttdef"><b>Definition:</b> <a href="step-69_8cc_source.html#l00534">step-69.cc:534</a></div></div>
<div class="ttc" id="alac_2vector_8h_html"><div class="ttname"><a href="lac_2vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga6060b2304b8600f5efa0d31eeda0207d"><div class="ttname"><a href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">StandardExceptions::ExcDimensionMismatch</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcDimensionMismatch(std::size_t arg1, std::size_t arg2)</div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_ad3b9cdeadeb3bcdb52af5db70c041a6e"><div class="ttname"><a href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **Constructor Takes all data stored in MatrixFree If applied to problems with more than one finite element or more than one quadrature formula selected during construction of[2.x.343] the appropriate component can be selected by the optional arguments[2.x.344] matrix_free Data object that contains all data[2.x.345] dof_no If matrix_free was set up with multiple DoFHandler this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.346] quad_no If matrix_free was set up with multiple Quadrature this parameter selects the appropriate number of the quadrature formula[2.x.347] first_selected_component If the dof_handler selected by dof_no uses an FESystem consisting of more than one this parameter allows for selecting the component where the current evaluation routine should start Note that one evaluator does not support combining different shape functions in different components In other the same base element of a FESystem needs to be set for the components between[2.x.348] and[2.x.349][2.x.350] active_fe_index If matrix_free was set up with DoFHandler objects with[2.x.351] this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.352] active_quad_index If matrix_free was set up with[2.x.353] this parameter selects the appropriate number of the quadrature formula **Constructor Takes all data stored in MatrixFree for a given cell which allows to automatically identify the active_fe_index and active_quad_index in case of a p adaptive strategy The rest of the arguments are the same as in the constructor above **Constructor that comes with reduced functionality and works similar as FEValues The arguments are similar to the ones passed to the constructor of with the notable difference that FEEvaluation expects a one dimensional quadrature instead of a[2.x.354] dimensional one The finite element can be both scalar or vector but this method always only selects a scalar base element at a the optional argument[2.x.356] allows to specify the index of the base element to be used for evaluation Note that the internal data structures always assume that the base element is non primitive are not supported currently As known from a call to the reinit method with a[2.x.357] is necessary to make the geometry and degrees of freedom of the current class known::If the iterator includes DoFHandler the initialization allows to also read from or write to vectors in the standard way for[2.x.359] types for one cell at a time this approach is much slower than the path with MatrixFree with MPI since index translation has to be done As only one cell at a time is this method does not vectorize over several but only possibly within the element if the evaluate integrate routines are combined inside user an object of type i the underlying mapping and quadrature points do only need to be evaluated once Make sure to not pass an optional object around when you intend to use the FEEvaluation object in parallel to the given one because otherwise the intended sharing may create race conditions **Copy constructor If FEEvaluationBase was constructed from a fe</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00555">fe_evaluation_0.txt:555</a></div></div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html_a713849cd6eeacc629a2b621c19857242"><div class="ttname"><a href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">SparseDirectUMFPACK::solve</a></div><div class="ttdeci">void solve(Vector&lt; double &gt; &amp;rhs_and_solution, const bool transpose=false) const</div><div class="ttdef"><b>Definition:</b> <a href="sparse__direct_8cc_source.html#l00344">sparse_direct.cc:344</a></div></div>
<div class="ttc" id="aclassStep58_1_1InitialValues_html_a152471cc082d1c37b4ca7d071391a3dc"><div class="ttname"><a href="classStep58_1_1InitialValues.html#a152471cc082d1c37b4ca7d071391a3dc">Step58::InitialValues::value</a></div><div class="ttdeci">virtual std::complex&lt; double &gt; value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const override</div><div class="ttdef"><b>Definition:</b> <a href="step-58_8cc_source.html#l00103">step-58.cc:103</a></div></div>
<div class="ttc" id="atable__handler__0_8txt_html_a61e9964f9093088848525ca172895749"><div class="ttname"><a href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a></div><div class="ttdeci">the ConvergenceTable class does something like this *To support both the TableHandler class has a property called[1.x.4] By auto fill mode is but it can be enabled by calling set_auto_fill_mode(). If auto-fill mode is enabled we use the following algorithm call it *[2.x.18] ***If[2.x.19] then we add[2.x.20] copies of the object[2.x.21] to this column is the data type of the given[2.x.23] is a numeric then[2.x.24] is[2.x.25] is the empty string *[2.x.26] ***Add the given value to this column *Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column In other if we have skipped previous invocations of then the padding will enter default values into this column *The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step</div><div class="ttdef"><b>Definition:</b> <a href="table__handler__0_8txt_source.html#l00070">table_handler_0.txt:70</a></div></div>
<div class="ttc" id="aclassQuadrature_html_af9f7d82770fa8126e19113f3e3db755b"><div class="ttname"><a href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">Quadrature::size</a></div><div class="ttdeci">unsigned int size() const</div></div>
<div class="ttc" id="aclassDataPostprocessorScalar_html"><div class="ttname"><a href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00599">data_postprocessor.h:599</a></div></div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html"><div class="ttname"><a href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparse__direct_8h_source.html#l00089">sparse_direct.h:89</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2full__matrix_8h_source.html#l00070">full_matrix.h:70</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00140">function.h:140</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="agroup__CPP11_html_gaace8c98aca00e7e48a619bb5e08084aa"><div class="ttname"><a href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a></div><div class="ttdeci">IteratorRange&lt; active_cell_iterator &gt; active_cell_iterators() const</div></div>
<div class="ttc" id="anamespaceEuler__DG_html_a143bc64b6fa6ced9f11c148a2af3ff09"><div class="ttname"><a href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Euler_DG::Number</a></div><div class="ttdeci">double Number</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00064">step-67.cc:64</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_aafbdfdd72b6cfe4eae5fa7a16385582f"><div class="ttname"><a href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; abs(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05750">vectorization.h:5750</a></div></div>
<div class="ttc" id="anamespaceVectorTools_1_1EvaluationFlags_html_ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9"><div class="ttname"><a href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">VectorTools::EvaluationFlags::max</a></div><div class="ttdeci">@ max</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2vector__tools__evaluate_8h_source.html#l00056">vector_tools_evaluate.h:56</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a33b522422da89e5c080e7405ad49d7c7"><div class="ttname"><a href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElementData::n_dofs_per_cell</a></div><div class="ttdeci">unsigned int n_dofs_per_cell() const</div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespacenumbers_html_a3e24f194a9cb9b6ff4442b8a7a877d4a"><div class="ttname"><a href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition:</b> <a href="base_2numbers_8h_source.html#l00237">numbers.h:237</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_af9f808a82e8c618e2e7a19dd08a9eae3"><div class="ttname"><a href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing or exact solutions Since closed form expressions for equations are often hard to pass along as function deal II uses the Function base class to describe these objects Essentially the interface of this base class requires derived classes to implement the ability to return the value of a function at one or a list of particular locations and function objects can then be used by algorithms like[2.x.1][2.x.2] and other functions *Some functions are needed again and and are therefore already provided in deal II This includes a function with a constant value</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00007">functions_0.txt:7</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2mapping__q1__eulerian_8h_source.html#l00032">mapping_q1_eulerian.h:32</a></div></div>
<div class="ttc" id="alac_2sparse__matrix_8h_html"><div class="ttname"><a href="lac_2sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_ac7280a24690b117454acfb0fa058299c"><div class="ttname"><a href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">DataOutInterface::set_flags</a></div><div class="ttdeci">void set_flags(const FlagType &amp;flags)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08210">data_out_base.cc:8210</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a1611aa37f754086388ca76bcd421cce5"><div class="ttname"><a href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a></div><div class="ttdeci">void close()</div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__postprocessor_8h_source.html#l00319">data_postprocessor.h:319</a></div></div>
<div class="ttc" id="adof__tools__0_8txt_html_aa623f15672a6db0f3f730a81a5b432b4"><div class="ttname"><a href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a></div><div class="ttdeci">previous contents are not deleted **This function generates a matrix such that when a vector of data with as many elements as there are degrees of freedom of this component on the coarse grid is multiplied to this we obtain a vector with as many elements as there are global degrees of freedom on the fine grid All the elements of the other vector components of the finite element fields on the fine grid are not touched Triangulation of the fine grid can be distributed When called in each process has to have a copy of the coarse grid In this function returns transfer representation for a set of locally owned cells The output of this function is a compressed format that can be used to construct corresponding sparse transfer matrix ****Periodic boundary conditions *[2.x.121] *Insert this functions constrains all DoFs associated with the boundary described by[2.x.125] to the respective DoFs of the boundary described by[2.x.126] More the global DoF see below if[2.x.134] and[2.x.135] are not active this function loops recursively over the children of[2.x.136] and[2.x.137] If only one of the two faces is active</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__0_8txt_source.html#l00095">dof_tools_0.txt:95</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="agrid_2grid__generator_8h_html"><div class="ttname"><a href="grid_2grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="atable__0_8txt_html_aa889bb34debce4db8c9ace2f875bdf0d"><div class="ttname"><a href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a></div><div class="ttdeci">tables that store three or more dimensional then there is nothing you can do about the size of these if your program is parallelized via then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file This is inefficient from two the data stored on every process is the and while every process needs to be able to read from a it is not necessary that every process stores its own either by re creating a copy of the table in the other processes memory space if by creating copies in shared memory once for all processes located on each of the machines used by the MPI job ******Integer type used to count the number of elements in this container **Default constructor Set all dimensions to zero **Constructor Initialize the array with the given dimensions in each index component **Constructor Initialize the array with the given dimensions in each index component</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00083">table_0.txt:83</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_aa5b8d3c4b9deb0774dde5c2851e07e1e"><div class="ttname"><a href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">DoFHandler::n_dofs</a></div><div class="ttdeci">types::global_dof_index n_dofs() const</div></div>
<div class="ttc" id="afunction__0_8txt_html_a4f780342f2d5d632f82cf7fd90158a66"><div class="ttname"><a href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a></div><div class="ttdeci">it defaults to i e the first component **Return all components of a vector valued function at a given point&lt; tt &gt; values&lt;/tt &gt; shall have the right size i e **Set&lt; tt &gt; values&lt;/tt &gt; to the point values of the specified component of the function at the&lt; tt &gt; points&lt;/tt &gt; It is assumed that&lt; tt &gt; values&lt;/tt &gt; already has the right size</div><div class="ttdef"><b>Definition:</b> <a href="function__0_8txt_source.html#l00052">function_0.txt:52</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
