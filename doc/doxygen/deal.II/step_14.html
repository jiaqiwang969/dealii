<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_14.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-14 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-14 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_13.html">step-13</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Themaths">The maths</a>
        <li><a href="#Thesoftware">The software</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Evaluatingthesolution">Evaluating the solution</a>
      <ul>
        <li><a href="#TheEvaluationBaseclass">The EvaluationBase class</a>
        <li><a href="#ThePointValueEvaluationclass">The PointValueEvaluation class</a>
        <li><a href="#ThePointXDerivativeEvaluationclass">The PointXDerivativeEvaluation class</a>
        <li><a href="#TheGridOutputclass">The GridOutput class</a>
      </ul>
        <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a>
      <ul>
        <li><a href="#TheLaplacesolverbaseclass">The Laplace solver base class</a>
        <li><a href="#TheLaplaceSolverclass">The Laplace Solver class</a>
        <li><a href="#ThePrimalSolverclass">The PrimalSolver class</a>
        <li><a href="#TheRefinementGlobalandRefinementKellyclasses">The RefinementGlobal and RefinementKelly classes</a>
        <li><a href="#TheRefinementWeightedKellyclass">The RefinementWeightedKelly class</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#TheSetUpBaseandSetUpclasses">The SetUpBase and SetUp classes</a>
        <li><a href="#TheCurvedRidgesclass">The CurvedRidges class</a>
        <li><a href="#TheExercise_2_3class">The Exercise_2_3 class</a>
        <li><a href="#Discussion">Discussion</a>
      </ul>
        <li><a href="#Dualfunctionals">Dual functionals</a>
      <ul>
        <li><a href="#TheDualFunctionalBaseclass">The DualFunctionalBase class</a>
        <li><a href="#ThedualfunctionalPointValueEvaluationclass">The dual functional PointValueEvaluation class</a>
        <li><a href="#ThedualfunctionalPointXDerivativeEvaluationclass">The dual functional PointXDerivativeEvaluation class</a>
      </ul>
        <li><a href="#ExtendingtheLaplaceSolvernamespace">Extending the LaplaceSolver namespace</a>
      <ul>
        <li><a href="#TheDualSolverclass">The DualSolver class</a>
        <li><a href="#TheWeightedResidualclass">The WeightedResidual class</a>
      </ul>
        <li><a href="#Estimatingerrors">Estimating errors</a>
      <ul>
        <li><a href="#Errorestimationdriverfunctions">Error estimation driver functions</a>
        <li><a href="#Estimatingonasinglecell">Estimating on a single cell</a>
        <li><a href="#Computingcelltermerrorcontributions">Computing cell term error contributions</a>
        <li><a href="#Computingedgetermerrorcontributions1">Computing edge term error contributions &mdash; 1</a>
        <li><a href="#Computingedgetermerrorcontributions2">Computing edge term error contributions &mdash; 2</a>
      </ul>
        <li><a href="#Asimulationframework">A simulation framework</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Pointvalues">Point values</a>
        <li><a href="#Comparingrefinementcriteria">Comparing refinement criteria</a>
        <li><a href="#Evaluationofpointstresses">Evaluation of point stresses</a>
        <li><a href="#step13revisited">@ref step_13 "step-13" revisited</a>
        <li><a href="#Conclusionsandoutlook">Conclusions and outlook</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Themaths"></a></p><h3>The maths</h3>
<p>The Heidelberg group of Professor Rolf Rannacher, to which the three initial authors of the deal.II library belonged during their PhD time and partly also afterwards, has been involved with adaptivity and error estimation for finite element discretizations since the mid-1990ies. The main achievement is the development of error estimates for arbitrary functionals of the solution, and of optimal mesh refinement for its computation.</p>
<p>We will not discuss the derivation of these concepts in too great detail, but will implement the main ideas in the present example program. For a thorough introduction into the general idea, we refer to the seminal work of Becker and Rannacher <b>[BR95]</b>, <b>[BR96r]</b>, and the overview article of the same authors in Acta Numerica <b>[BR01]</b>; the first introduces the concept of error estimation and adaptivity for general functional output for the Laplace equation, while the second gives many examples of applications of these concepts to a large number of other, more complicated equations. For applications to individual types of equations, see also the publications by Becker <b>[Bec95]</b>, <b>[Bec98]</b>, Kanschat <b>[Kan96]</b>, <b>[FK97]</b>, Suttmeier <b>[Sut96]</b>, <b>[RS97]</b>, <b>[RS98c]</b>, <b>[RS99]</b>, Bangerth <b>[BR99b]</b>, <b>[Ban00w]</b>, <b>[BR01a]</b>, <b>[Ban02]</b>, and Hartmann <b>[Har02]</b>, <b>[HH01]</b>, <b>[HH01b]</b>. All of these works, from the original introduction by Becker and Rannacher to individual contributions to particular equations, have later been summarized in a book by Bangerth and Rannacher that covers all of these topics, see <b>[BR03]</b>.</p>
<p>The basic idea is the following: in applications, one is not usually interested in the solution per se, but rather in certain aspects of it. For example, in simulations of flow problems, one may want to know the lift or drag of a body immersed in the fluid; it is this quantity that we want to know to best accuracy, and whether the rest of the solution of the describing equations is well resolved is not of primary interest. Likewise, in elasticity one might want to know about values of the stress at certain points to guess whether maximal load values of joints are safe, for example. Or, in radiative transfer problems, mean flux intensities are of interest.</p>
<p>In all the cases just listed, it is the evaluation of a functional \(J(u)\) of the solution which we are interested in, rather than the values of \(u\) everywhere. Since the exact solution \(u\) is not available, but only its numerical approximation \(u_h\), it is sensible to ask whether the computed value \(J(u_h)\) is within certain limits of the exact value \(J(u)\), i.e. we want to bound the error with respect to this functional, \(J(u)-J(u_h)\).</p>
<p>For simplicity of exposition, we henceforth assume that both the quantity of interest \(J\), as well as the equation are linear, and we will in particular show the derivation for the Laplace equation with homogeneous Dirichlet boundary conditions, although the concept is much more general. For this general case, we refer to the references listed above. The goal is to obtain bounds on the error, \(J(e)=J(u)-J(u_h)\). For this, let us denote by \(z\) the solution of a dual problem, defined as follows: </p><p class="formulaDsp">
\[ a(\varphi,z) = J(\varphi) \qquad \forall \varphi, \]
</p>
<p> where \(a(\cdot,\cdot)\) is the bilinear form associated with the differential equation, and the test functions are chosen from the corresponding solution space. Then, taking as special test function \(\varphi=e\) the error, we have that </p><p class="formulaDsp">
\[ J(e) = a(e,z) \]
</p>
<p> and we can, by Galerkin orthogonality, rewrite this as </p><p class="formulaDsp">
\[ J(e) = a(e,z-\varphi_h) \]
</p>
<p> where \(\varphi_h\) can be chosen from the discrete test space in whatever way we find convenient.</p>
<p>Concretely, for Laplace's equation, the error identity reads </p><p class="formulaDsp">
\[ J(e) = (\nabla e, \nabla(z-\varphi_h)). \]
</p>
<p> Because we want to use this formula not only to compute error, but also to refine the mesh, we need to rewrite the expression above as a sum over cells where each cell's contribution can then be used as an error indicator for this cell. Thus, we split the scalar products into terms for each cell, and integrate by parts on each of them: </p><p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (\nabla (u-u_h), \nabla (z-\varphi_h))_K \\ &amp;=&amp; \sum_K (-\Delta (u-u_h), z-\varphi_h)_K + (\partial_n (u-u_h), z-z_h)_{\partial K}. \end{eqnarray*}
</p>
<p> Next we use that \(-\Delta u=f\), and that for solutions of the Laplace equation, the solution is smooth enough that \(\partial_n u\) is continuous almost everywhere &ndash; so the terms involving \(\partial_n u\) on one cell cancels with that on its neighbor, where the normal vector has the opposite sign. (The same is not true for \(\partial_n u_h\), though.) At the boundary of the domain, where there is no neighbor cell with which this term could cancel, the weight \(z-\varphi_h\) can be chosen as zero, and the whole term disappears.</p>
<p>Thus, we have </p><p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-\varphi_h)_K - (\partial_n u_h, z-\varphi_h)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
<p> In a final step, note that when taking the normal derivative of \(u_h\), we mean the value of this quantity as taken from this side of the cell (for the usual Lagrange elements, derivatives are not continuous across edges). We then rewrite the above formula by exchanging half of the edge integral of cell \(K\) with the neighbor cell \(K&#39;\), to obtain </p><p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-\varphi_h)_K - \frac 12 (\partial_n u_h|_K + \partial_{n&#39;} u_h|_{K&#39;}, z-\varphi_h)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
<p> Using that for the normal vectors on adjacent cells we have \(n&#39;=-n\), we define the jump of the normal derivative by </p><p class="formulaDsp">
\[ [\partial_n u_h] \dealcoloneq \partial_n u_h|_K + \partial_{n&#39;} u_h|_{K&#39;} = \partial_n u_h|_K - \partial_n u_h|_{K&#39;}, \]
</p>
<p> and get the final form after setting the discrete function \(\varphi_h\), which is by now still arbitrary, to the point interpolation of the dual solution, \(\varphi_h=I_h z\): </p><p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-I_h z)_K - \frac 12 ([\partial_n u_h], z-I_h z)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
<p>With this, we have obtained an exact representation of the error of the finite element discretization with respect to arbitrary (linear) functionals \(J(\cdot)\). Its structure is a weighted form of a residual estimator, as both \(f+\Delta u_h\) and \([\partial_n u_h]\) are cell and edge residuals that vanish on the exact solution, and \(z-I_h z\) are weights indicating how important the residuals on a certain cell is for the evaluation of the given functional. Furthermore, it is a cell-wise quantity, so we can use it as a mesh refinement criterion. The question, is: how to evaluate it? After all, the evaluation requires knowledge of the dual solution \(z\), which carries the information about the quantity we want to know to best accuracy.</p>
<p>In some, very special cases, this dual solution is known. For example, if the functional \(J(\cdot)\) is the point evaluation, \(J(\varphi)=\varphi(x_0)\), then the dual solution has to satisfy </p><p class="formulaDsp">
\[ -\Delta z = \delta(x-x_0), \]
</p>
<p> with the Dirac delta function on the right hand side, and the dual solution is the Green's function with respect to the point \(x_0\). For simple geometries, this function is analytically known, and we could insert it into the error representation formula.</p>
<p>However, we do not want to restrict ourselves to such special cases. Rather, we will compute the dual solution numerically, and approximate \(z\) by some numerically obtained \(\tilde z\). We note that it is not sufficient to compute this approximation \(\tilde z\) using the same method as used for the primal solution \(u_h\), since then \(\tilde z-I_h \tilde z=0\), and the overall error estimate would be zero. Rather, the approximation \(\tilde z\) has to be from a larger space than the primal finite element space. There are various ways to obtain such an approximation (see the cited literature), and we will choose to compute it with a higher order finite element space. While this is certainly not the most efficient way, it is simple since we already have all we need to do that in place, and it also allows for simple experimenting. For more efficient methods, again refer to the given literature, in particular <b>[BR95]</b>, <b>[BR03]</b>.</p>
<p>With this, we end the discussion of the mathematical side of this program and turn to the actual implementation.</p>
<dl class="section note"><dt>Note</dt><dd>There are two steps above that do not seem necessary if all you care about is computing the error: namely, (i) the subtraction of \(\phi_h\) from \(z\), and (ii) splitting the integral into a sum of cells and integrating by parts on each. Indeed, neither of these two steps change \(J(e)\) at all, as we only ever consider identities above until the substitution of \(z\) by \(\tilde z\). In other words, if you care only about <em>estimating the global error</em> \(J(e)\), then these steps are not necessary. On the other hand, if you want to use the error estimate also as a refinement criterion for each cell of the mesh, then it is necessary to (i) break the estimate into a sum of cells, and (ii) massage the formulas in such a way that each cell's contributions have something to do with the local error. (While the contortions above do not change the value of the <em>sum</em> \(J(e)\), they change the values we compute for each cell \(K\).) To this end, we want to write everything in the form "residual times dual weight" where a "residual" is something that goes to zero as the approximation becomes \(u_h\) better and better. For example, the quantity \(\partial_n u_h\) is not a residual, since it simply converges to the (normal component of) the gradient of the exact solution. On the other hand, \([\partial_n u_h]\) is a residual because it converges to \([\partial_n u]=0\). All of the steps we have taken above in developing the final form of \(J(e)\) have indeed had the goal of bringing the final formula into a form where each term converges to zero as the discrete solution \(u_h\) converges to \(u\). This then allows considering each cell's contribution as an "error indicator" that also converges to zero &ndash; as it should as the mesh is refined.</dd></dl>
<p><a class="anchor" id="Thesoftware"></a></p><h3>The software</h3>
<p>The <a class="el" href="step_14.html">step-14</a> example program builds heavily on the techniques already used in the <a class="el" href="step_13.html">step-13</a> program. Its implementation of the dual weighted residual error estimator explained above is done by deriving a second class, properly called <code>DualSolver</code>, from the <code>Solver</code> base class, and having a class (<code>WeightedResidual</code>) that joins the two again and controls the solution of the primal and dual problem, and then uses both to compute the error indicator for mesh refinement.</p>
<p>The program continues the modular concept of the previous example, by implementing the dual functional, describing quantity of interest, by an abstract base class, and providing two different functionals which implement this interface. Adding a different quantity of interest is thus simple.</p>
<p>One of the more fundamental differences is the handling of data. A common case is that you develop a program that solves a certain equation, and test it with different right hand sides, different domains, different coefficients and boundary values, etc. Usually, these have to match, so that exact solutions are known, or that their combination makes sense at all.</p>
<p>We demonstrate a way how this can be achieved in a simple, yet very flexible way. We will put everything that belongs to a certain setup into one class, and provide a little C++ mortar around it, so that entire setups (domains, coefficients, right hand sides, etc.) can be exchanged by only changing something in <em>one</em> place.</p>
<p>Going this way a little further, we have also centralized all the other parameters that describe how the program is to work in one place, such as the order of the finite element, the maximal number of degrees of freedom, the evaluation objects that shall be executed on the computed solutions, and so on. This allows for simpler configuration of the program, and we will show in a later program how to use a library class that can handle setting these parameters by reading an input file. The general aim is to reduce the places within a program where one may have to look when wanting to change some parameter, as it has turned out in practice that one forgets where they are as programs grow. Furthermore, putting all options describing what the program does in a certain run into a file (that can be stored with the results) helps repeatability of results more than if the various flags were set somewhere in the program, where their exact values are forgotten after the next change to this place.</p>
<p>Unfortunately, the program has become rather long. While this admittedly reduces its usefulness as an example program, we think that it is a very good starting point for development of a program for other kinds of problems, involving different equations than the Laplace equation treated here. Furthermore, it shows everything that we can show you about our way of a posteriori error estimation, and its structure should make it simple for you to adjust this method to other problems, other functionals, other geometries, coefficients, etc.</p>
<p>The author believes that the present program is his masterpiece among the example programs, regarding the mathematical complexity, as well as the simplicity to add extensions. If you use this program as a basis for your own programs, we would kindly like to ask you to state this fact and the name of the author of the example program, Wolfgang Bangerth, in publications that arise from that, of your program consists in a considerable part of the example program.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>Start out with well known things...</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__tools_8h.html">deal.II/fe/fe_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
</div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep14.html">Step14</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="Evaluatingthesolution"></a> </p><h3>Evaluating the solution</h3>
<p>As mentioned in the introduction, significant parts of the program have simply been taken over from the <a class="el" href="step_13.html">step-13</a> example program. We therefore only comment on those things that are new.</p>
<p>First, the framework for evaluation of solutions is unchanged, i.e. the base class is the same, and the class to evaluate the solution at a grid point is unchanged:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Evaluation</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="TheEvaluationBaseclass"></a> </p><h4>The EvaluationBase class</h4>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>EvaluationBase</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>)</div>
<div class="line">{</div>
<div class="line">  refinement_cycle = <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThePointValueEvaluationclass"></a> </p><h4>The PointValueEvaluation class</h4>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">    ExcEvaluationPointNotFound,</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">  : evaluation_point(evaluation_point)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">PointValueEvaluation&lt;dim&gt;::</a></div>
<div class="line"><a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">     operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordtype">double</span> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = 1e20;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">    <span class="keywordflow">if</span> (!evaluation_point_found)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>).distance(evaluation_point) &lt;</div>
<div class="line">            <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter() * 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_dof_index(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>, 0));</div>
<div class="line"> </div>
<div class="line">            evaluation_point_found = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div>
<div class="line">              ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Point value=&quot;</span> &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThePointXDerivativeEvaluationclass"></a> </p><h4>The PointXDerivativeEvaluation class</h4>
<p>Besides the class implementing the evaluation of the solution at one point, we here provide one which evaluates the gradient at a grid point. Since in general the gradient of a finite element function is not continuous at a vertex, we have to be a little bit more careful here. What we do is to loop over all cells, even if we have found the point already on one cell, and use the mean value of the gradient at the vertex taken from all adjacent cells.</p>
<p>Given the interface of the <code>PointValueEvaluation</code> class, the declaration of this class provides little surprise, and neither does the constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PointXDerivativeEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PointXDerivativeEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">    ExcEvaluationPointNotFound,</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">  : evaluation_point(evaluation_point)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>The more interesting things happen inside the function doing the actual evaluation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">PointXDerivativeEvaluation&lt;dim&gt;::</a></div>
<div class="line"><a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">     operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>This time initialize the return value with something useful, since we will have to add up a number of contributions and take the mean value afterwards...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> point_derivative = 0;</div>
</div><!-- fragment --><p>...then have some objects of which the meaning will become clear below...</p>
<div class="fragment"><div class="line"><a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a>             vertex_quadrature;</div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>(),</div>
<div class="line">                        vertex_quadrature,</div>
<div class="line">                        <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; solution_gradients(vertex_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div>
</div><!-- fragment --><p>...and next loop over all cells and their vertices, and count how often the vertex has been found:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> evaluation_point_hits = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>) == evaluation_point)</div>
<div class="line">      {</div>
</div><!-- fragment --><p>Things are now no more as simple, since we can't get the gradient of the finite element field as before, where we simply had to pick one degree of freedom at a vertex.</p>
<p>Rather, we have to evaluate the finite element field on this cell, and at a certain point. As you know, evaluating finite element fields at certain points is done through the <code><a class="el" href="classFEValues.html">FEValues</a></code> class, so we use that. The question is: the <code><a class="el" href="classFEValues.html">FEValues</a></code> object needs to be a given a quadrature formula and can then compute the values of finite element quantities at the quadrature points. Here, we don't want to do quadrature, we simply want to specify some points!</p>
<p>Nevertheless, the same way is chosen: use a special quadrature rule with points at the vertices, since these are what we are interested in. The appropriate rule is the trapezoidal rule, so that is the reason why we used that one above.</p>
<p>Thus: initialize the <code><a class="el" href="classFEValues.html">FEValues</a></code> object on this cell,</p>
<div class="fragment"><div class="line">fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
</div><!-- fragment --><p>and extract the gradients of the solution vector at the vertices:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, solution_gradients);</div>
</div><!-- fragment --><p>Now we have the gradients at all vertices, so pick out that one which belongs to the evaluation point (note that the order of vertices is not necessarily the same as that of the quadrature points):</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0;</div>
<div class="line"><span class="keywordflow">for</span> (; q_point &lt; solution_gradients.size(); ++q_point)</div>
<div class="line">  <span class="keywordflow">if</span> (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point) == evaluation_point)</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p>Check that the evaluation point was indeed found,</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(q_point &lt; solution_gradients.size(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
</div><!-- fragment --><p>and if so take the x-derivative of the gradient there as the value which we are interested in, and increase the counter indicating how often we have added to that variable:</p>
<div class="fragment"><div class="line">point_derivative += solution_gradients[q_point][0];</div>
<div class="line">++evaluation_point_hits;</div>
</div><!-- fragment --><p>Finally break out of the innermost loop iterating over the vertices of the present cell, since if we have found the evaluation point at one vertex it cannot be at a following vertex as well:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we have looped over all cells and vertices, so check whether the point was found:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_hits &gt; 0,</div>
<div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div>
</div><!-- fragment --><p>We have simply summed up the contributions of all adjacent cells, so we still have to compute the mean value. Once this is done, report the status:</p>
<div class="fragment"><div class="line">  point_derivative /= evaluation_point_hits;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Point x-derivative=&quot;</span> &lt;&lt; point_derivative &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheGridOutputclass"></a> </p><h4>The GridOutput class</h4>
<p>Since this program has a more difficult structure (it computed a dual solution in addition to a primal one), writing out the solution is no more done by an evaluation object since we want to write both solutions at once into one file, and that requires some more information than available to the evaluation classes.</p>
<p>However, we also want to look at the grids generated. This again can be done with one such class. Its structure is analog to the <code>SolutionOutput</code> class of the previous example program, so we do not discuss it here in more detail. Furthermore, everything that is used here has already been used in previous example programs.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>GridOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    GridOutput(<span class="keyword">const</span> std::string &amp;output_name_base);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> std::string output_name_base;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  GridOutput&lt;dim&gt;::GridOutput(<span class="keyword">const</span> std::string &amp;output_name_base)</div>
<div class="line">    : output_name_base(output_name_base)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">GridOutput&lt;dim&gt;::operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <span class="comment">/*solution*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) + <span class="stringliteral">&quot;.svg&quot;</span>);</div>
<div class="line">    <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>(), <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Evaluation</span></div>
</div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverclasses"></a> </p><h3>The Laplace solver classes</h3>
<p>Next are the actual solver classes. Again, we discuss only the differences to the previous program.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverbaseclass"></a> </p><h4>The Laplace solver base class</h4>
<p>This class is almost unchanged, with the exception that it declares two more functions: <code>output_solution</code> will be used to generate output files from the actual solutions computed by derived classes, and the <code>set_refinement_cycle</code> function by which the testing framework sets the number of the refinement cycle to a local variable in this class; this number is later used to generate filenames for the solution output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">  : <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>(&amp;coarse_grid)</div>
<div class="line">  , refinement_cycle(<a class="code" href="namespacenumbers.html">numbers</a>::<a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">invalid_unsigned_int</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Base&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">{</div>
<div class="line">  refinement_cycle = <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheLaplaceSolverclass"></a> </p><h4>The Laplace Solver class</h4>
<p>Likewise, the <code>Solver</code> class is entirely unchanged and will thus not be discussed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line">  <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt;  <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;     <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt;&gt; face_quadrature;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                               dof_handler;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                                <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;       boundary_values;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">struct </span>LinearSystem</div>
<div class="line">  {</div>
<div class="line">    LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>;</div>
<div class="line">  };</div>
</div><!-- fragment --><p>The remainder of the class is essentially a copy of <a class="el" href="step_13.html">step-13</a> as well, including the data structures and functions necessary to compute the linear system in parallel using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> framework:</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AssemblyScratchData</div>
<div class="line">  {</div>
<div class="line">    AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>);</div>
<div class="line">    AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>AssemblyCopyData</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> local_assemble_matrix(</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">    AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">    AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                            LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(&amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>)</div>
<div class="line">  , <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(&amp;<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>)</div>
<div class="line">  , face_quadrature(&amp;face_quadrature)</div>
<div class="line">  , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , boundary_values(&amp;boundary_values)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::~Solver()</div>
<div class="line">{</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">Solver&lt;dim&gt;::solve_problem</a>()</div>
<div class="line">{</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">  LinearSystem linear_system(dof_handler);</div>
<div class="line">  assemble_linear_system(linear_system);</div>
<div class="line">  linear_system.solve(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div>
<div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>(dof_handler, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following few functions and constructors are verbatim copies taken from <a class="el" href="step_13.html">step-13</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div>
<div class="line">    <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> worker =</div>
<div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">           AssemblyScratchData &amp;scratch_data,</div>
<div class="line">           AssemblyCopyData &amp;   copy_data) {</div>
<div class="line">      this-&gt;local_assemble_matrix(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, scratch_data, copy_data);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <a class="code" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a> = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div>
<div class="line">    this-&gt;copy_local_to_global(copy_data, linear_system);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div>
<div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">end</a>(),</div>
<div class="line">                  worker,</div>
<div class="line">                  <a class="code" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>,</div>
<div class="line">                  AssemblyScratchData(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, *<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>),</div>
<div class="line">                  AssemblyCopyData());</div>
<div class="line">  linear_system.hanging_node_constraints.condense(linear_system.matrix);</div>
<div class="line"> </div>
<div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                           0,</div>
<div class="line">                                           *boundary_values,</div>
<div class="line">                                           boundary_value_map);</div>
<div class="line"> </div>
<div class="line">  rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line">  linear_system.hanging_node_constraints.condense(linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div>
<div class="line">                                     linear_system.matrix,</div>
<div class="line">                                     <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                     linear_system.rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>)</div>
<div class="line">  : fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">  <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div>
<div class="line">  : fe_values(scratch_data.fe_values.get_fe(),</div>
<div class="line">              scratch_data.fe_values.get_quadrature(),</div>
<div class="line">              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">  AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">  AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>-&gt;<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>-&gt;size();</div>
<div class="line"> </div>
<div class="line">  copy_data.cell_matrix.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  copy_data.local_dof_indices.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  scratch_data.fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">        copy_data.cell_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">          (scratch_data.fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) *</div>
<div class="line">           scratch_data.fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) *</div>
<div class="line">           scratch_data.fe_values.JxW(q_point));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(copy_data.local_dof_indices);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                       LinearSystem &amp;linear_system)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; copy_data.local_dof_indices.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; copy_data.local_dof_indices.size(); ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">      linear_system.matrix.add(copy_data.local_dof_indices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                               copy_data.local_dof_indices[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>],</div>
<div class="line">                               copy_data.cell_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one thread is generated, we don't use the <code><a class="el" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup</a></code> class here, but rather use the one created task object directly to wait for this particular task's exit. The approach is generally the same as the one we have used in <code>Solver::assemble_linear_system()</code> above.</p>
<p>Note that taking the address of the <code><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></code> function is a little tricky, since there are actually three functions of this name, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator <code>&amp;</code> in that case returns a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary <code>mhnc_p</code> (short for <code>pointer to make_hanging_node_constraints</code>) with the right type, and using this pointer instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div>
<div class="line">{</div>
<div class="line">  hanging_node_constraints.clear();</div>
<div class="line"> </div>
<div class="line">  void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div>
<div class="line">    &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div>
</div><!-- fragment --><p>Start a side task then continue on the main thread</p>
<div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div>
<div class="line">  <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
</div><!-- fragment --><p>Wait for the side task to be done before going further</p>
<div class="fragment"><div class="line">  side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line"> </div>
<div class="line">  hanging_node_constraints.close();</div>
<div class="line">  hanging_node_constraints.condense(dsp);</div>
<div class="line">  <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">  <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">Solver&lt;dim&gt;::LinearSystem::solve</a>(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(5000, 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12);</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">  <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(<a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>, 1.2);</div>
<div class="line"> </div>
<div class="line">  cg.solve(<a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">  hanging_node_constraints.distribute(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThePrimalSolverclass"></a> </p><h4>The PrimalSolver class</h4>
<p>The <code>PrimalSolver</code> class is also mostly unchanged except for implementing the <code>output_solution</code> function. We keep the <code>GlobalRefinement</code> and <code>RefinementKelly</code> classes in this program, and they can then rely on the default implementation of this function which simply outputs the primal solution. The class implementing dual weighted error estimators will overload this function itself, to also output the dual solution.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , Solver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                face_quadrature,</div>
<div class="line">                boundary_values)</div>
<div class="line">  , rhs_function(&amp;rhs_function)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::output_solution()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(this-&gt;dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(this-&gt;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                    <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>, <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26">DataOutBase::vtu</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div>
<div class="line">                          *this-&gt;quadrature,</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = this-&gt;fe-&gt;n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = this-&gt;quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  std::vector&lt;double&gt;                  rhs_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">    {</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">      fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">      rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div>
<div class="line">                               rhs_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                          rhs_values[q_point] *               <span class="comment">// f((x_q)</span></div>
<div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));            <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">      <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]) += cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheRefinementGlobalandRefinementKellyclasses"></a> </p><h4>The RefinementGlobal and RefinementKelly classes</h4>
<p>For the following two classes, the same applies as for most of the above: the class is taken from the previous example as-is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">  , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                      <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                      <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                      face_quadrature,</div>
<div class="line">                      rhs_function,</div>
<div class="line">                      boundary_values)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div>
<div class="line">{</div>
<div class="line">  this-&gt;triangulation-&gt;refine_global(1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">RefinementKelly&lt;dim&gt;::RefinementKelly(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">  , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                      <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                      <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                      face_quadrature,</div>
<div class="line">                      rhs_function,</div>
<div class="line">                      boundary_values)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">    this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">    this-&gt;dof_handler,</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div>
<div class="line">    <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#ae3fd76f0fcd93dcbcc9df2df2c6028fb">this</a>-&gt;solution,</div>
<div class="line">    estimated_error_per_cell);</div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div>
<div class="line">                                                  estimated_error_per_cell,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0.03);</div>
<div class="line">  this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheRefinementWeightedKellyclass"></a> </p><h4>The RefinementWeightedKelly class</h4>
<p>This class is a variant of the previous one, in that it allows to weight the refinement indicators we get from the library's Kelly indicator by some function. We include this class since the goal of this example program is to demonstrate automatic refinement criteria even for complex output quantities such as point values or stresses. If we did not solve a dual problem and compute the weights thereof, we would probably be tempted to give a hand-crafted weighting to the indicators to account for the fact that we are going to evaluate these quantities. This class accepts such a weighting function as argument to its constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RefinementWeightedKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RefinementWeightedKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      weighting_function);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; weighting_function;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">RefinementWeightedKelly&lt;dim&gt;::RefinementWeightedKelly(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      weighting_function)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">  , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                      <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                      <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                      face_quadrature,</div>
<div class="line">                      rhs_function,</div>
<div class="line">                      boundary_values)</div>
<div class="line">  , weighting_function(&amp;weighting_function)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>Now, here comes the main function, including the weighting:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RefinementWeightedKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">{</div>
</div><!-- fragment --><p>First compute some residual based error indicators for all cells by a method already implemented in the library. What exactly we compute here is described in more detail in the documentation of that class.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">  this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; dummy_function_map;</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(this-&gt;dof_handler,</div>
<div class="line">                                   *this-&gt;face_quadrature,</div>
<div class="line">                                   dummy_function_map,</div>
<div class="line">                                   this-&gt;solution,</div>
<div class="line">                                   estimated_error_per_cell);</div>
</div><!-- fragment --><p>Next weigh each entry in the vector of indicators by the value of the function given to the constructor, evaluated at the cell center. We need to write the result into the vector entry that corresponds to the current cell, which we can obtain by asking the cell what its index among all active cells is using <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a>. (In reality, this index is zero for the first cell we handle in the loop, one for the second cell, etc., and we could as well just keep track of this index using an integer counter; but using <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a> makes this more explicit.)</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">      estimated_error_per_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) *=</div>
<div class="line">        weighting_function-&gt;value(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;center());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div>
<div class="line">                                                    estimated_error_per_cell,</div>
<div class="line">                                                    0.3,</div>
<div class="line">                                                    0.03);</div>
<div class="line">    this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace LaplaceSolver</span></div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>In this example program, we work with the same data sets as in the previous one, but as it may so happen that someone wants to run the program with different boundary values and right hand side functions, or on a different grid, we show a simple technique to do exactly that. For more clarity, we furthermore pack everything that has to do with equation data into a namespace of its own.</p>
<p>The underlying assumption is that this is a research program, and that there we often have a number of test cases that consist of a domain, a right hand side, boundary values, possibly a specified coefficient, and a number of other parameters. They often vary all at the same time when shifting from one example to another. To make handling such sets of problem description parameters simple is the goal of the following.</p>
<p>Basically, the idea is this: let us have a structure for each set of data, in which we pack everything that describes a test case: here, these are two subclasses, one called <code><a class="el" href="classBoundaryValues.html">BoundaryValues</a></code> for the boundary values of the exact solution, and one called <code><a class="el" href="classRightHandSide.html">RightHandSide</a></code>, and then a way to generate the coarse grid. Since the solution of the previous example program looked like curved ridges, we use this name here for the enclosing class. Note that the names of the two inner classes have to be the same for all enclosing test case classes, and also that we have attached the dimension template argument to the enclosing class rather than to the inner ones, to make further processing simpler. (From a language viewpoint, a namespace would be better to encapsulate these inner classes, rather than a structure. However, namespaces cannot be given as template arguments, so we use a structure to allow a second object to select from within its given argument. The enclosing structure, of course, has no member variables apart from the classes it declares, and a static function to generate the coarse mesh; it will in general never be instantiated.)</p>
<p>The idea is then the following (this is the right time to also take a brief look at the code below): we can generate objects for boundary values and right hand side by simply giving the name of the outer class as a template argument to a class which we call here <code>Data::SetUp</code>, and it then creates objects for the inner classes. In this case, to get all that characterizes the curved ridge solution, we would simply generate an instance of <code>Data::SetUp&lt;Data::CurvedRidge&gt;</code>, and everything we need to know about the solution would be static member variables and functions of that object.</p>
<p>This approach might seem like overkill in this case, but will become very handy once a certain set up is not only characterized by Dirichlet boundary values and a right hand side function, but in addition by material properties, Neumann values, different boundary descriptors, etc. In that case, the <code>SetUp</code> class might consist of a dozen or more objects, and each descriptor class (like the <code>CurvedRidges</code> class below) would have to provide them. Then, you will be happy to be able to change from one set of data to another by only changing the template argument to the <code>SetUp</code> class at one place, rather than at many.</p>
<p>With this framework for different test cases, we are almost finished, but one thing remains: by now we can select statically, by changing one template argument, which data set to choose. In order to be able to do that dynamically, i.e. at run time, we need a base class. This we provide in the obvious way, see below, with virtual abstract functions. It forces us to introduce a second template parameter <code>dim</code> which we need for the base class (which could be avoided using some template magic, but we omit that), but that's all.</p>
<p>Adding new testcases is now simple, you don't have to touch the framework classes, only a structure like the <code>CurvedRidges</code> one is needed.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Data</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="TheSetUpBaseandSetUpclasses"></a> </p><h4>The SetUpBase and SetUp classes</h4>
<p>Based on the above description, the <code>SetUpBase</code> class then looks as follows. To allow using the <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> class with this class, we derived from the <code><a class="el" href="classSubscriptor.html">Subscriptor</a></code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>SetUpBase : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_boundary_values() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_right_hand_side() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">  create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>And now for the derived class that takes the template argument as explained above.</p>
<p>Here we pack the data elements into private variables, and allow access to them through the methods of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>SetUp : <span class="keyword">public</span> SetUpBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_boundary_values() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_right_hand_side() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">  create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> Traits::BoundaryValues boundary_values;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> Traits::RightHandSide  <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>We have to provide definitions for the static member variables of the above class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> Traits::BoundaryValues SetUp&lt;Traits, dim&gt;::boundary_values;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> Traits::RightHandSide <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">SetUp&lt;Traits, dim&gt;::right_hand_side</a>;</div>
</div><!-- fragment --><p>And definitions of the member functions:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;SetUp&lt;Traits, dim&gt;::get_boundary_values()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> boundary_values;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;SetUp&lt;Traits, dim&gt;::get_right_hand_side()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> SetUp&lt;Traits, dim&gt;::create_coarse_grid(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  Traits::create_coarse_grid(coarse_grid);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheCurvedRidgesclass"></a> </p><h4>The CurvedRidges class</h4>
<p>The class that is used to describe the boundary values and right hand side of the <code>curved ridge</code> problem already used in the <a class="el" href="step_13.html">step-13</a> example program is then like so:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>CurvedRidges</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classBoundaryValues.html">BoundaryValues</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">CurvedRidges&lt;dim&gt;::BoundaryValues::value</a>(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordtype">double</span> q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    q += <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div>
<div class="line">  <span class="keywordflow">return</span> exponential;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">CurvedRidges&lt;dim&gt;::RightHandSide::value</a>(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordtype">double</span> q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    q += <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div>
<div class="line">  <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    {</div>
<div class="line">      t1 += <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) * 10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">      t2 += 10 * <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) -</div>
<div class="line">            100 * <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">      t3 += 100 * <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) *</div>
<div class="line">              <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) -</div>
<div class="line">            100 * <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">    }</div>
<div class="line">  t1 = t1 * t1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> CurvedRidges&lt;dim&gt;::create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(coarse_grid, -1, 1);</div>
<div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheExercise_2_3class"></a> </p><h4>The Exercise_2_3 class</h4>
<p>This example program was written while giving practical courses for a lecture on adaptive finite element methods and duality based error estimates. For these courses, we had one exercise, which required to solve the Laplace equation with constant right hand side on a square domain with a square hole in the center, and zero boundary values. Since the implementation of the properties of this problem is so particularly simple here, lets do it. As the number of the exercise was 2.3, we take the liberty to retain this name for the class as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>Exercise_2_3</div>
<div class="line">{</div>
</div><!-- fragment --><p>We need a class to denote the boundary values of the problem. In this case, this is simple: it's the zero function, so don't even declare a class, just an alias:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classBoundaryValues.html">BoundaryValues</a> = <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>;</div>
</div><!-- fragment --><p>Second, a class that denotes the right hand side. Since they are constant, just subclass the corresponding class of the library and be done:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="classRightHandSide.html">RightHandSide</a>()</div>
<div class="line">    : <a class="code" href="namespaceFunctions.html">Functions</a>::<a class="code" href="classFunctions_1_1ConstantFunction.html">ConstantFunction</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(1.)</div>
<div class="line">  {}</div>
<div class="line">};</div>
</div><!-- fragment --><p>Finally a function to generate the coarse grid. This is somewhat more complicated here, see immediately below.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">};</div>
</div><!-- fragment --><p>As stated above, the grid for this example is the square [-1,1]^2 with the square [-1/2,1/2]^2 as hole in it. We create the coarse grid as 4 times 4 cells with the middle four ones missing. To understand how exactly the mesh is going to look, it may be simplest to just look at the "Results" section of this tutorial program first. In general, if you'd like to understand more about creating meshes either from scratch by hand, as we do here, or using other techniques, you should take a look at <a class="el" href="step_49.html">step-49</a>.</p>
<p>Of course, the example has an extension to 3d, but since this function cannot be written in a dimension independent way we choose not to implement this here, but rather only specialize the template for dim=2. If you compile the program for 3d, you'll get a message from the linker that this function is not implemented for 3d, and needs to be provided.</p>
<p>For the creation of this geometry, the library has no predefined method. In this case, the geometry is still simple enough to do the creation by hand, rather than using a mesh generator.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> Exercise_2_3&lt;2&gt;::create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div>
<div class="line">{</div>
</div><!-- fragment --><p>We first define the space dimension, to allow those parts of the function that are actually dimension independent to use this variable. That makes it simpler if you later take this as a starting point to implement a 3d version of this mesh. The next step is then to have a list of vertices. Here, they are 24 (5 times 5, with the middle one omitted). It is probably best to draw a sketch here.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; <a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a> = {</div>
<div class="line">  {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, </div>
<div class="line">  {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, </div>
<div class="line">  {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               </div>
<div class="line">  {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, </div>
<div class="line">  {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};</div>
</div><!-- fragment --><p>Next, we have to define the cells and the vertices they contain.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::array&lt;int, GeometryInfo&lt;dim&gt;::vertices_per_cell&gt;&gt;</div>
<div class="line">  cell_vertices = {{{0, 1, 5, 6}},</div>
<div class="line">                   {{1, 2, 6, 7}},</div>
<div class="line">                   {{2, 3, 7, 8}},</div>
<div class="line">                   {{3, 4, 8, 9}},</div>
<div class="line">                   {{5, 6, 10, 11}},</div>
<div class="line">                   {{8, 9, 12, 13}},</div>
<div class="line">                   {{10, 11, 14, 15}},</div>
<div class="line">                   {{12, 13, 17, 18}},</div>
<div class="line">                   {{14, 15, 19, 20}},</div>
<div class="line">                   {{15, 16, 20, 21}},</div>
<div class="line">                   {{16, 17, 21, 22}},</div>
<div class="line">                   {{17, 18, 22, 23}}};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a> = cell_vertices.size();</div>
</div><!-- fragment --><p>Again, we generate a C++ vector type from this, but this time by looping over the cells (yes, this is boring). Additionally, we set the material indicator to zero for all the cells:</p>
<div class="fragment"><div class="line">std::vector&lt;CellData&lt;dim&gt;&gt; <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>(<a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>, <a class="code" href="structCellData.html">CellData&lt;dim&gt;</a>());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; cell_vertices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].size(); ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">      <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a>[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] = cell_vertices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>][<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>];</div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].material_id = 0;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Finally pass all this information to the library to generate a triangulation. The last parameter may be used to pass information about non-zero boundary indicators at certain faces of the triangulation to the library, but we don't want that here, so we give an empty object:</p>
<div class="fragment"><div class="line">coarse_grid.<a class="code" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a>(<a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a>, <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>, <a class="code" href="structSubCellData.html">SubCellData</a>());</div>
</div><!-- fragment --><p>And since we want that the evaluation point (3/4,3/4) in this example is a grid point, we refine once globally:</p>
<div class="fragment"><div class="line">    coarse_grid.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Data</span></div>
</div><!-- fragment --><p><a class="anchor" id="Discussion"></a> </p><h4>Discussion</h4>
<p>As you have now read through this framework, you may be wondering why we have not chosen to implement the classes implementing a certain setup (like the <code>CurvedRidges</code> class) directly as classes derived from <code>Data::SetUpBase</code>. Indeed, we could have done very well so. The only reason is that then we would have to have member variables for the solution and right hand side classes in the <code>CurvedRidges</code> class, as well as member functions overloading the abstract functions of the base class giving access to these member variables. The <code>SetUp</code> class has the sole reason to relieve us from the need to reiterate these member variables and functions that would be necessary in all such classes. In some way, the template mechanism here only provides a way to have default implementations for a number of functions that depend on external quantities and can thus not be provided using normal virtual functions, at least not without the help of templates.</p>
<p>However, there might be good reasons to actually implement classes derived from <code>Data::SetUpBase</code>, for example if the solution or right hand side classes require constructors that take arguments, which the <code>Data::SetUpBase</code> class cannot provide. In that case, subclassing is a worthwhile strategy. Other possibilities for special cases are to derive from <code>Data::SetUp&lt;SomeSetUp&gt;</code> where <code>SomeSetUp</code> denotes a class, or even to explicitly specialize <code>Data::SetUp&lt;SomeSetUp&gt;</code>. The latter allows to transparently use the way the <code>SetUp</code> class is used for other set-ups, but with special actions taken for special arguments.</p>
<p>A final observation favoring the approach taken here is the following: we have found numerous times that when starting a project, the number of parameters (usually boundary values, right hand side, coarse grid, just as here) was small, and the number of test cases was small as well. One then starts out by handcoding them into a number of <code>switch</code> statements. Over time, projects grow, and so does the number of test cases. The number of <code>switch</code> statements grows with that, and their length as well, and one starts to find ways to consider impossible examples where domains, boundary values, and right hand sides do not fit together any more, and starts losing the overview over the whole structure. Encapsulating everything belonging to a certain test case into a structure of its own has proven worthwhile for this, as it keeps everything that belongs to one test case in one place. Furthermore, it allows to put these things all in one or more files that are only devoted to test cases and their data, without having to bring their actual implementation into contact with the rest of the program.</p>
<p><a class="anchor" id="Dualfunctionals"></a> </p><h3>Dual functionals</h3>
<p>As with the other components of the program, we put everything we need to describe dual functionals into a namespace of its own, and define an abstract base class that provides the interface the class solving the dual problem needs for its work.</p>
<p>We will then implement two such classes, for the evaluation of a point value and of the derivative of the solution at that point. For these functionals we already have the corresponding evaluation objects, so they are complementary.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DualFunctional</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="TheDualFunctionalBaseclass"></a> </p><h4>The DualFunctionalBase class</h4>
<p>First start with the base class for dual functionals. Since for linear problems the characteristics of the dual problem play a role only in the right hand side, we only need to provide for a function that assembles the right hand side for a given discretization:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>DualFunctionalBase : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="ThedualfunctionalPointValueEvaluationclass"></a> </p><h4>The dual functional PointValueEvaluation class</h4>
<p>As a first application, we consider the functional corresponding to the evaluation of the solution's value at a given point which again we assume to be a vertex. Apart from the constructor that takes and stores the evaluation point, this class consists only of the function that implements assembling the right hand side.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">    ExcEvaluationPointNotFound,</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">  : evaluation_point(evaluation_point)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>As for doing the main purpose of the class, assembling the right hand side, let us first consider what is necessary: The right hand side of the dual problem is a vector of values J(phi_i), where J is the error functional, and phi_i is the i-th shape function. Here, J is the evaluation at the point x0, i.e. J(phi_i)=phi_i(x0).</p>
<p>Now, we have assumed that the evaluation point is a vertex. Thus, for the usual finite elements we might be using in this program, we can take for granted that at such a point exactly one shape function is nonzero, and in particular has the value one. Thus, we set the right hand side vector to all-zeros, then seek for the shape function associated with that point and set the corresponding value of the right hand side vector to one:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">PointValueEvaluation&lt;dim&gt;::assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>So, first set everything to zeros...</p>
<div class="fragment"><div class="line"><a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
</div><!-- fragment --><p>...then loop over cells and find the evaluation point among the vertices (or very close to a vertex, which may happen due to floating point round-off):</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>).distance(evaluation_point) &lt;</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter() * 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8)</div>
<div class="line">      {</div>
</div><!-- fragment --><p>Ok, found, so set corresponding entry, and leave function since we are finished:</p>
<div class="fragment"><div class="line">  <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_dof_index(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>, 0)) = 1;</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, a sanity check: if we somehow got here, then we must have missed the evaluation point, so raise an exception unconditionally:</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThedualfunctionalPointXDerivativeEvaluationclass"></a> </p><h4>The dual functional PointXDerivativeEvaluation class</h4>
<p>As second application, we again consider the evaluation of the x-derivative of the solution at one point. Again, the declaration of the class, and the implementation of its constructor is not too interesting:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PointXDerivativeEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PointXDerivativeEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">    ExcEvaluationPointNotFound,</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">  : evaluation_point(evaluation_point)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>What is interesting is the implementation of this functional: here, J(phi_i)=d/dx phi_i(x0).</p>
<p>We could, as in the implementation of the respective evaluation object take the average of the gradients of each shape function phi_i at this evaluation point. However, we take a slightly different approach: we simply take the average over all cells that surround this point. The question which cells <code>surrounds</code> the evaluation point is made dependent on the mesh width by including those cells for which the distance of the cell's midpoint to the evaluation point is less than the cell's diameter.</p>
<p>Taking the average of the gradient over the area/volume of these cells leads to a dual solution which is very close to the one which would result from the point evaluation of the gradient. It is simple to justify theoretically that this does not change the method significantly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> PointXDerivativeEvaluation&lt;dim&gt;::assemble_rhs(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>Again, first set all entries to zero:</p>
<div class="fragment"><div class="line"><a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
</div><!-- fragment --><p>Initialize a <code><a class="el" href="classFEValues.html">FEValues</a></code> object with a quadrature formula, have abbreviations for the number of quadrature points and shape functions...</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>(),</div>
<div class="line">                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                        <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div>
</div><!-- fragment --><p>...and have two objects that are used to store the global indices of the degrees of freedom on a cell, and the values of the gradients of the shape functions at the quadrature points:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">std::vector&lt;unsigned int&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
</div><!-- fragment --><p>Finally have a variable in which we will sum up the area/volume of the cells over which we integrate, by integrating the unit functions on these cells:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> total_volume = 0;</div>
</div><!-- fragment --><p>Then start the loop over all cells, and select those cells which are close enough to the evaluation point:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;center().distance(evaluation_point) &lt;= <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter())</div>
<div class="line">    {</div>
</div><!-- fragment --><p>If we have found such a cell, then initialize the <code><a class="el" href="classFEValues.html">FEValues</a></code> object and integrate the x-component of the gradient of each shape function, as well as the unit function for the total area/volume.</p>
<div class="fragment"><div class="line">fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) +=</div>
<div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)[0] <span class="comment">// (d/dx phi_i(x_q))</span></div>
<div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div>
<div class="line">    total_volume += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>If we have the local contributions, distribute them to the global vector:</p>
<div class="fragment"><div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]) += cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After we have looped over all cells, check whether we have found any at all, by making sure that their volume is non-zero. If not, then the results will be botched, as the right hand side should then still be zero, so throw an exception:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(total_volume &gt; 0,</div>
<div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div>
</div><!-- fragment --><p>Finally, we have by now only integrated the gradients of the shape functions, not taking their mean value. We fix this by dividing by the measure of the volume over which we have integrated:</p>
<div class="fragment"><div class="line">    <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a> /= total_volume;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace DualFunctional</span></div>
</div><!-- fragment --><p><a class="anchor" id="ExtendingtheLaplaceSolvernamespace"></a> </p><h3>Extending the LaplaceSolver namespace</h3>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="TheDualSolverclass"></a> </p><h4>The DualSolver class</h4>
<p>In the same way as the <code>PrimalSolver</code> class above, we now implement a <code>DualSolver</code>. It has all the same features, the only difference is that it does not take a function object denoting a right hand side object, but now takes a <code>DualFunctionalBase</code> object that will assemble the right hand side vector of the dual problem. The rest of the class is rather trivial.</p>
<p>Since both primal and dual solver will use the same triangulation, but different discretizations, it now becomes clear why we have made the <code>Base</code> class a virtual one: since the final class will be derived from both <code>PrimalSolver</code> as well as <code>DualSolver</code>, it would have two <code>Base</code> instances, would we not have marked the inheritance as virtual. Since in many applications the base class would store much more information than just the triangulation which needs to be shared between primal and dual solvers, we do not usually want to use two such base classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>DualSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  DualSolver(</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">    <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;</a>&gt;</div>
<div class="line">               dual_functional;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> boundary_values;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> DualSolver&lt;dim&gt;::boundary_values;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">DualSolver&lt;dim&gt;::DualSolver(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">  <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  , Solver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                face_quadrature,</div>
<div class="line">                boundary_values)</div>
<div class="line">  , dual_functional(&amp;dual_functional)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  dual_functional-&gt;assemble_rhs(this-&gt;dof_handler, <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="TheWeightedResidualclass"></a> </p><h4>The WeightedResidual class</h4>
<p>Here finally comes the main class of this program, the one that implements the dual weighted residual error estimator. It joins the primal and dual solver classes to use them for the computation of primal and dual solutions, and implements the error representation formula for use as error estimate and mesh refinement.</p>
<p>The first few of the functions of this class are mostly overriders of the respective functions of the base class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>WeightedResidual : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;, <span class="keyword">public</span> DualSolver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  WeightedResidual(</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           coarse_grid,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     primal_fe,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     dual_fe,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          rhs_function,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          boundary_values,</div>
<div class="line">    <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
</div><!-- fragment --><p>In the private section, we have two functions that are used to call the <code>solve_problem</code> functions of the primal and dual base classes. These two functions will be called in parallel by the <code>solve_problem</code> function of this class.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve_primal_problem();</div>
<div class="line"><span class="keywordtype">void</span> solve_dual_problem();</div>
</div><!-- fragment --><p>Then declare abbreviations for active cell iterators, to avoid that we have to write this lengthy name over and over again:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> active_cell_iterator =</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div>
</div><!-- fragment --><p>Next, declare a data type that we will us to store the contribution of faces to the error estimator. The idea is that we can compute the face terms from each of the two cells to this face, as they are the same when viewed from both sides. What we will do is to compute them only once, based on some rules explained below which of the two adjacent cells will be in charge to do so. We then store the contribution of each face in a map mapping faces to their values, and only collect the contributions for each cell by looping over the cells a second time and grabbing the values from the map.</p>
<p>The data type of this map is declared here:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> FaceIntegrals =</div>
<div class="line">  <span class="keyword">typename</span> std::map&lt;typename DoFHandler&lt;dim&gt;::face_iterator, <span class="keywordtype">double</span>&gt;;</div>
</div><!-- fragment --><p>In the computation of the error estimates on cells and faces, we need a number of helper objects, such as <code><a class="el" href="classFEValues.html">FEValues</a></code> and <code><a class="el" href="classFEFaceValues.html">FEFaceValues</a></code> functions, but also temporary objects storing the values and gradients of primal and dual solutions, for example. These fields are needed in the three functions that do the integration on cells, and regular and irregular faces, respectively.</p>
<p>There are three reasonable ways to provide these fields: first, as local variables in the function that needs them; second, as member variables of this class; third, as arguments passed to that function.</p>
<p>These three alternatives all have drawbacks: the third that their number is not negligible and would make calling these functions a lengthy enterprise. The second has the drawback that it disallows parallelization, since the threads that will compute the error estimate have to have their own copies of these variables each, so member variables of the enclosing class will not work. The first approach, although straightforward, has a subtle but important drawback: we will call these functions over and over again, many thousands of times maybe; it now turns out that allocating vectors and other objects that need memory from the heap is an expensive business in terms of run-time, since memory allocation is expensive when several threads are involved. It is thus significantly better to allocate the memory only once, and recycle the objects as often as possible.</p>
<p>What to do? Our answer is to use a variant of the third strategy. In fact, this is exactly what the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept is supposed to do (we have already introduced it above, but see also <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a>). To avoid that we have to give these functions a dozen or so arguments, we pack all these variables into two structures, one which is used for the computations on cells, the other doing them on the faces. Both are then joined into the WeightedResidualScratchData class that will serve as the "scratch data" class of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structCellData.html">CellData</a></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                           fe_values;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>;</div>
<div class="line">  std::vector&lt;double&gt; rhs_values;</div>
<div class="line">  std::vector&lt;double&gt; dual_weights;</div>
<div class="line">  std::vector&lt;double&gt; cell_laplacians;</div>
<div class="line">  <a class="code" href="structCellData.html#a3e602fcb3bd076c02539c89f2c563e33">CellData</a>(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>);</div>
<div class="line">  <a class="code" href="structCellData.html#a3e602fcb3bd076c02539c89f2c563e33">CellData</a>(<span class="keyword">const</span> <a class="code" href="structCellData.html">CellData</a> &amp;cell_data);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FaceData</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values_cell;</div>
<div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values_neighbor;</div>
<div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_subface_values_cell;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt;                  jump_residual;</div>
<div class="line">  std::vector&lt;double&gt;                  dual_weights;</div>
<div class="line">  <span class="keyword">typename</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; cell_grads;</div>
<div class="line">  <span class="keyword">typename</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; neighbor_grads;</div>
<div class="line">  FaceData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature);</div>
<div class="line">  FaceData(<span class="keyword">const</span> FaceData &amp;face_data);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>WeightedResidualScratchData</div>
<div class="line">{</div>
<div class="line">  WeightedResidualScratchData(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; primal_fe,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    primal_quadrature,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;primal_face_quadrature,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     primal_solution,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     dual_weights);</div>
<div class="line"> </div>
<div class="line">  WeightedResidualScratchData(</div>
<div class="line">    <span class="keyword">const</span> WeightedResidualScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="structCellData.html">CellData</a>       cell_data;</div>
<div class="line">  FaceData       face_data;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> primal_solution;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_weights;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> generally wants both a scratch object and a copy object. Here, for reasons similar to what we had in <a class="el" href="step_9.html">step-9</a> when discussing the computation of an approximation of the gradient, we don't actually need a "copy data" structure. Since <a class="el" href="namespaceWorkStream.html">WorkStream</a> insists on having one of these, we just declare an empty structure that does nothing other than being there.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>WeightedResidualCopyData</div>
<div class="line">{};</div>
</div><!-- fragment --><p>Regarding the evaluation of the error estimator, we have one driver function that uses <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a> to call the second function on every cell:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> estimate_error(<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> estimate_on_one_cell(<span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                          WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">                          WeightedResidualCopyData &amp;   copy_data,</div>
<div class="line">                          <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;              error_indicators,</div>
<div class="line">                          FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Then we have functions that do the actual integration of the error representation formula. They will treat the terms on the cell interiors, on those faces that have no hanging nodes, and on those faces with hanging nodes, respectively:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> integrate_over_cell(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">                           <a class="code" href="structCellData.html">CellData</a> &amp;                  cell_data,</div>
<div class="line">                           <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> integrate_over_regular_face(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;primal_solution,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dual_weights,</div>
<div class="line">                                   FaceData &amp;            face_data,</div>
<div class="line">                                   FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> integrate_over_irregular_face(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;primal_solution,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dual_weights,</div>
<div class="line">                                     FaceData &amp;            face_data,</div>
<div class="line">                                     FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the implementation of this class, we first have the constructors of the <code><a class="el" href="structCellData.html">CellData</a></code> and <code>FaceData</code> member classes, and the <code>WeightedResidual</code> constructor. They only initialize fields to their correct lengths, so we do not have to discuss them in too much detail:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::CellData::CellData(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">  : fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">              <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">  , <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>(&amp;<a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">  , <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">  , rhs_values(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">  , dual_weights(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">  , cell_laplacians(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::CellData::CellData(<span class="keyword">const</span> <a class="code" href="structCellData.html">CellData</a> &amp;cell_data)</div>
<div class="line">  : fe_values(cell_data.fe_values.get_fe(),</div>
<div class="line">              cell_data.fe_values.get_quadrature(),</div>
<div class="line">              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">  , <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>(cell_data.<a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">  , <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(cell_data.<a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>)</div>
<div class="line">  , rhs_values(cell_data.rhs_values)</div>
<div class="line">  , dual_weights(cell_data.dual_weights)</div>
<div class="line">  , cell_laplacians(cell_data.cell_laplacians)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::FaceData::FaceData(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature)</div>
<div class="line">  : fe_face_values_cell(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                        face_quadrature,</div>
<div class="line">                        <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">  , fe_face_values_neighbor(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            face_quadrature,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">  , fe_subface_values_cell(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, face_quadrature, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">  jump_residual.resize(n_face_q_points);</div>
<div class="line">  dual_weights.resize(n_face_q_points);</div>
<div class="line">  cell_grads.resize(n_face_q_points);</div>
<div class="line">  neighbor_grads.resize(n_face_q_points);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::FaceData::FaceData(<span class="keyword">const</span> FaceData &amp;face_data)</div>
<div class="line">  : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),</div>
<div class="line">                        face_data.fe_face_values_cell.get_quadrature(),</div>
<div class="line">                        <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">  , fe_face_values_neighbor(</div>
<div class="line">      face_data.fe_face_values_neighbor.get_fe(),</div>
<div class="line">      face_data.fe_face_values_neighbor.get_quadrature(),</div>
<div class="line">      <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">        <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">  , fe_subface_values_cell(</div>
<div class="line">      face_data.fe_subface_values_cell.get_fe(),</div>
<div class="line">      face_data.fe_subface_values_cell.get_quadrature(),</div>
<div class="line">      <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">  , jump_residual(face_data.jump_residual)</div>
<div class="line">  , dual_weights(face_data.dual_weights)</div>
<div class="line">  , cell_grads(face_data.cell_grads)</div>
<div class="line">  , neighbor_grads(face_data.neighbor_grads)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::WeightedResidualScratchData::</div>
<div class="line">  WeightedResidualScratchData(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; primal_fe,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    primal_quadrature,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;primal_face_quadrature,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     primal_solution,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     dual_weights)</div>
<div class="line">  : cell_data(primal_fe, primal_quadrature, rhs_function)</div>
<div class="line">  , face_data(primal_fe, primal_face_quadrature)</div>
<div class="line">  , primal_solution(primal_solution)</div>
<div class="line">  , dual_weights(dual_weights)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::WeightedResidualScratchData::</div>
<div class="line">  WeightedResidualScratchData(</div>
<div class="line">    <span class="keyword">const</span> WeightedResidualScratchData &amp;scratch_data)</div>
<div class="line">  : cell_data(scratch_data.cell_data)</div>
<div class="line">  , face_data(scratch_data.face_data)</div>
<div class="line">  , primal_solution(scratch_data.primal_solution)</div>
<div class="line">  , dual_weights(scratch_data.dual_weights)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">WeightedResidual&lt;dim&gt;::WeightedResidual(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           coarse_grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     primal_fe,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     dual_fe,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          rhs_function,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          bv,</div>
<div class="line">  <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional)</div>
<div class="line">  : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">  , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                      primal_fe,</div>
<div class="line">                      <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                      face_quadrature,</div>
<div class="line">                      rhs_function,</div>
<div class="line">                      bv)</div>
<div class="line">  , DualSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                    dual_fe,</div>
<div class="line">                    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                    face_quadrature,</div>
<div class="line">                    dual_functional)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>The next five functions are boring, as they simply relay their work to the base classes. The first calls the primal and dual solvers in parallel, while postprocessing the solution and retrieving the number of degrees of freedom is done by the primal class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">WeightedResidual&lt;dim&gt;::solve_problem</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup&lt;void&gt;</a> <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a>;</div>
<div class="line">  <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a> +=</div>
<div class="line">    <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;WeightedResidual&lt;dim&gt;::solve_primal_problem, *<span class="keyword">this</span>);</div>
<div class="line">  <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a> +=</div>
<div class="line">    <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;WeightedResidual&lt;dim&gt;::solve_dual_problem, *<span class="keyword">this</span>);</div>
<div class="line">  <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a>.join_all();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::solve_primal_problem()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">PrimalSolver&lt;dim&gt;::solve_problem</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::solve_dual_problem()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">DualSolver&lt;dim&gt;::solve_problem</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::postprocess(</div>
<div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  PrimalSolver&lt;dim&gt;::postprocess(<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> WeightedResidual&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> PrimalSolver&lt;dim&gt;::n_dofs();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, it is becoming more interesting: the <code>refine_grid()</code> function asks the error estimator to compute the cell-wise error indicators, then uses their absolute values for mesh refinement.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::refine_grid()</div>
<div class="line">{</div>
</div><!-- fragment --><p>First call the function that computes the cell-wise and global error:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_indicators(this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">estimate_error(error_indicators);</div>
</div><!-- fragment --><p>Then note that marking cells for refinement or coarsening only works if all indicators are positive, to allow their comparison. Thus, drop the signs on all these indicators:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> &amp;error_indicator : error_indicators)</div>
<div class="line">  error_indicator = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(error_indicator);</div>
</div><!-- fragment --><p>Finally, we can select between different strategies for refinement. The default here is to refine those cells with the largest error indicators that make up for a total of 80 per cent of the error, while we coarsen those with the smallest indicators that make up for the bottom 2 per cent of the error.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(*this-&gt;triangulation,</div>
<div class="line">                                                    error_indicators,</div>
<div class="line">                                                    0.8,</div>
<div class="line">                                                    0.02);</div>
<div class="line">  this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since we want to output both the primal and the dual solution, we overload the <code>output_solution</code> function. The only interesting feature of this function is that the primal and dual solutions are defined on different finite element spaces, which is not the format the <code><a class="el" href="classDataOut.html">DataOut</a></code> class expects. Thus, we have to transfer them to a common finite element space. Since we want the solutions only to see them qualitatively, we contend ourselves with interpolating the dual solution to the (smaller) primal space. For the interpolation, there is a library function, that takes a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object including the hanging node constraints. The rest is standard.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::output_solution()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> primal_hanging_node_constraints;</div>
<div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                          primal_hanging_node_constraints);</div>
<div class="line">  primal_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_solution(PrimalSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line">  <a class="code" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                       <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">DualSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                       PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                       primal_hanging_node_constraints,</div>
<div class="line">                       dual_solution);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(PrimalSolver&lt;dim&gt;::dof_handler);</div>
</div><!-- fragment --><p>Add the data vectors for which we want output. Add them both, the <code><a class="el" href="classDataOut.html">DataOut</a></code> functions can handle as many data vectors as you wish to write to output:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">PrimalSolver&lt;dim&gt;::solution</a>, <span class="stringliteral">&quot;primal_solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dual_solution, <span class="stringliteral">&quot;dual_solution&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                    <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>, <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26">DataOutBase::vtu</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Estimatingerrors"></a> </p><h3>Estimating errors</h3>
<p><a class="anchor" id="Errorestimationdriverfunctions"></a> </p><h4>Error estimation driver functions</h4>
<p>As for the actual computation of error estimates, let's start with the function that drives all this, i.e. calls those functions that actually do the work, and finally collects the results.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">WeightedResidual&lt;dim&gt;::estimate_error(<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>The first task in computing the error is to set up vectors that denote the primal solution, and the weights (z-z_h)=(z-I_hz), both in the finite element space for which we have computed the dual solution. For this, we have to interpolate the primal solution to the dual finite element space, and to subtract the interpolation of the computed dual solution to the primal finite element space. Fortunately, the library provides functions for the interpolation into larger or smaller finite element spaces, so this is mostly obvious.</p>
<p>First, let's do that for the primal solution: it is cell-wise interpolated into the finite element space in which we have solved the dual problem: But, again as in the <code>WeightedResidual::output_solution</code> function we first need to create an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object including the hanging node constraints, but this time of the dual finite element space.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> dual_hanging_node_constraints;</div>
<div class="line"><a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                        dual_hanging_node_constraints);</div>
<div class="line">dual_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> primal_solution(DualSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line"><a class="code" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                     <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">PrimalSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                     DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                     dual_hanging_node_constraints,</div>
<div class="line">                     primal_solution);</div>
</div><!-- fragment --><p>Then for computing the interpolation of the numerically approximated dual solution z into the finite element space of the primal solution and subtracting it from z: use the <code>interpolate_difference</code> function, that gives (z-I_hz) in the element space of the dual solution.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> primal_hanging_node_constraints;</div>
<div class="line"><a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                        primal_hanging_node_constraints);</div>
<div class="line">primal_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_weights(DualSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line"><a class="code" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">FETools::interpolation_difference</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                  dual_hanging_node_constraints,</div>
<div class="line">                                  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">DualSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                                  PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                  primal_hanging_node_constraints,</div>
<div class="line">                                  dual_weights);</div>
</div><!-- fragment --><p>Note that this could probably have been more efficient since those constraints have been used previously when assembling matrix and right hand side for the primal problem and writing out the dual solution. We leave the optimization of the program in this respect as an exercise.</p>
<p>Having computed the dual weights we now proceed with computing the cell and face residuals of the primal solution. First we set up a map between face iterators and their jump term contributions of faces to the error estimator. The reason is that we compute the jump terms only once, from one side of the face, and want to collect them only afterwards when looping over all cells a second time.</p>
<p>We initialize this map already with a value of -1e20 for all faces, since this value will stand out in the results if something should go wrong and we fail to compute the value for a face for some reason. Secondly, this initialization already makes the std::map object allocate all objects it may possibly need. This is important since we will write into this structure from parallel threads, and doing so would not be thread-safe if the map needed to allocate memory and thereby reshape its data structures. In other words, the initial initialization relieves us from the necessity to synchronize the threads through a mutex each time they write to (and modify the structure of) this map.</p>
<div class="fragment"><div class="line">FaceIntegrals face_integrals;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> :</div>
<div class="line">     DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_iterators())</div>
<div class="line">    face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>] = -1e20;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> worker = [<span class="keyword">this</span>,</div>
<div class="line">               &amp;error_indicators,</div>
<div class="line">               &amp;face_integrals](<span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">                                WeightedResidualCopyData &amp;   copy_data) {</div>
<div class="line">  this-&gt;estimate_on_one_cell(</div>
<div class="line">    <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, scratch_data, copy_data, error_indicators, face_integrals);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> do_nothing_copier =</div>
<div class="line">  std::function&lt;void(const WeightedResidualCopyData &amp;)&gt;();</div>
</div><!-- fragment --><p>Then hand it all off to <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a> to compute the estimators for all cells in parallel:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div>
<div class="line">  DualSolver&lt;dim&gt;::dof_handler.<a class="code" href="iterators__0_8txt.html#ad83e6d423f9ad63243b1465081bde416">begin_active</a>(),</div>
<div class="line">  DualSolver&lt;dim&gt;::dof_handler.<a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a>(),</div>
<div class="line">  worker,</div>
<div class="line">  do_nothing_copier,</div>
<div class="line">  WeightedResidualScratchData(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">DualSolver&lt;dim&gt;::fe</a>,</div>
<div class="line">                              *<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">DualSolver&lt;dim&gt;::quadrature</a>,</div>
<div class="line">                              *DualSolver&lt;dim&gt;::face_quadrature,</div>
<div class="line">                              *this-&gt;rhs_function,</div>
<div class="line">                              primal_solution,</div>
<div class="line">                              dual_weights),</div>
<div class="line">  WeightedResidualCopyData());</div>
</div><!-- fragment --><p>Once the error contributions are computed, sum them up. For this, note that the cell terms are already set, and that only the edge terms need to be collected. Thus, loop over all cells and their faces, make sure that the contributions of each of the faces are there, and add them up. Only take minus one half of the jump term, since the other half will be taken by the neighboring cell.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> present_cell = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> :</div>
<div class="line">       DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_iterators())</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>) != face_integrals.end(),</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">          error_indicators(present_cell) -= 0.5 * face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>];</div>
<div class="line">        }</div>
<div class="line">      ++present_cell;</div>
<div class="line">    }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Estimated error=&quot;</span></div>
<div class="line">            &lt;&lt; std::accumulate(error_indicators.<a class="code" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a>(),</div>
<div class="line">                               error_indicators.<a class="code" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a>(),</div>
<div class="line">                               0.)</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Estimatingonasinglecell"></a> </p><h4>Estimating on a single cell</h4>
<p>Next we have the function that is called to estimate the error on a single cell. The function may be called multiple times if the library was configured to use multithreading. Here it goes:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::estimate_on_one_cell(</div>
<div class="line">  <span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">  WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">  WeightedResidualCopyData &amp;   copy_data,</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;              error_indicators,</div>
<div class="line">  FaceIntegrals &amp;              face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>Because of <a class="el" href="namespaceWorkStream.html">WorkStream</a>, estimate_on_one_cell requires a <a class="el" href="structCopyData.html">CopyData</a> object even if it is no used. The next line silences a warning about this unused variable.</p>
<div class="fragment"><div class="line">(void)copy_data;</div>
</div><!-- fragment --><p>First task on each cell is to compute the cell residual contributions of this cell, and put them into the <code>error_indicators</code> variable:</p>
<div class="fragment"><div class="line">integrate_over_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                    scratch_data.primal_solution,</div>
<div class="line">                    scratch_data.dual_weights,</div>
<div class="line">                    scratch_data.cell_data,</div>
<div class="line">                    error_indicators);</div>
</div><!-- fragment --><p>After computing the cell terms, turn to the face terms. For this, loop over all faces of the present cell, and see whether something needs to be computed on it:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_indices())</div>
<div class="line">  {</div>
</div><!-- fragment --><p>First, if this face is part of the boundary, then there is nothing to do. However, to make things easier when summing up the contributions of the faces of cells, we enter this face into the list of faces with a zero contribution to the error.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;at_boundary())</div>
<div class="line">  {</div>
<div class="line">    face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] = 0;</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Next, note that since we want to compute the jump terms on each face only once although we access it twice (if it is not at the boundary), we have to define some rules who is responsible for computing on a face:</p>
<p>First, if the neighboring cell is on the same level as this one, i.e. neither further refined not coarser, then the one with the lower index within this level does the work. In other words: if the other one has a lower index, then skip work on this face:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div>
<div class="line">    (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;level() == <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level()) &amp;&amp;</div>
<div class="line">    (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;index() &lt; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;index()))</div>
<div class="line">  <span class="keywordflow">continue</span>;</div>
</div><!-- fragment --><p>Likewise, we always work from the coarser cell if this and its neighbor differ in refinement. Thus, if the neighboring cell is less refined than the present one, then do nothing since we integrate over the subfaces when we visit the coarse cell.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;at_boundary(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>) == <span class="keyword">false</span>)</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;level() &lt; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level())</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
</div><!-- fragment --><p>Now we know that we are in charge here, so actually compute the face jump terms. If the face is a regular one, i.e. the other side's cell is neither coarser not finer than this cell, then call one function, and if the cell on the other side is further refined, then use another function. Note that the case that the cell on the other side is coarser cannot happen since we have decided above that we handle this case when we pass over that other cell.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;has_children() == <span class="keyword">false</span>)</div>
<div class="line">        integrate_over_regular_face(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                    <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                    scratch_data.primal_solution,</div>
<div class="line">                                    scratch_data.dual_weights,</div>
<div class="line">                                    scratch_data.face_data,</div>
<div class="line">                                    face_integrals);</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        integrate_over_irregular_face(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                      <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                      scratch_data.primal_solution,</div>
<div class="line">                                      scratch_data.dual_weights,</div>
<div class="line">                                      scratch_data.face_data,</div>
<div class="line">                                      face_integrals);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Computingcelltermerrorcontributions"></a> </p><h4>Computing cell term error contributions</h4>
<p>As for the actual computation of the error contributions, first turn to the cell terms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_cell(</div>
<div class="line">  <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">  <a class="code" href="structCellData.html">CellData</a> &amp;                  cell_data,</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;             error_indicators)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>The tasks to be done are what appears natural from looking at the error estimation formula: first get the right hand side and Laplacian of the numerical solution at the quadrature points for the cell residual,</p>
<div class="fragment"><div class="line">cell_data.fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">cell_data.right_hand_side-&gt;value_list(</div>
<div class="line">  cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);</div>
<div class="line">cell_data.fe_values.get_function_laplacians(primal_solution,</div>
<div class="line">                                            cell_data.cell_laplacians);</div>
</div><!-- fragment --><p>...then get the dual weights...</p>
<div class="fragment"><div class="line">cell_data.fe_values.get_function_values(dual_weights,</div>
<div class="line">                                        cell_data.dual_weights);</div>
</div><!-- fragment --><p>...and finally build the sum over all quadrature points and store it with the present cell:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; cell_data.fe_values.n_quadrature_points; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">    <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> += ((cell_data.rhs_values[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] + cell_data.cell_laplacians[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">            cell_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * cell_data.fe_values.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line">  error_indicators(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) += <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Computingedgetermerrorcontributions1"></a> </p><h4>Computing edge term error contributions &ndash; 1</h4>
<p>On the other hand, computation of the edge terms for the error estimate is not so simple. First, we have to distinguish between faces with and without hanging nodes. Because it is the simple case, we first consider the case without hanging nodes on a face (let's call this the &lsquo;regular&rsquo; case):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_regular_face(</div>
<div class="line">  <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">  FaceData &amp;                  face_data,</div>
<div class="line">  FaceIntegrals &amp;             face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a> =</div>
<div class="line">    face_data.fe_face_values_cell.n_quadrature_points;</div>
</div><!-- fragment --><p>The first step is to get the values of the gradients at the quadrature points of the finite element field on the present cell. For this, initialize the <code><a class="el" href="classFEFaceValues.html">FEFaceValues</a></code> object corresponding to this side of the face, and extract the gradients using that object.</p>
<div class="fragment"><div class="line">face_data.fe_face_values_cell.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">face_data.fe_face_values_cell.get_function_gradients(</div>
<div class="line">  primal_solution, face_data.cell_grads);</div>
</div><!-- fragment --><p>The second step is then to extract the gradients of the finite element solution at the quadrature points on the other side of the face, i.e. from the neighboring cell.</p>
<p>For this, do a sanity check before: make sure that the neighbor actually exists (yes, we should not have come here if the neighbor did not exist, but in complicated software there are bugs, so better check this), and if this is not the case throw an error.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd">IteratorState::valid</a>,</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
</div><!-- fragment --><p>If we have that, then we need to find out with which face of the neighboring cell we have to work, i.e. the <code>how-many'th</code> the neighbor the present cell is of the cell behind the present face. For this, there is a function, and we put the result into a variable with the name <code>neighbor_neighbor</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_neighbor =</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_of_neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
</div><!-- fragment --><p>Then define an abbreviation for the neighbor cell, initialize the <code><a class="el" href="classFEFaceValues.html">FEFaceValues</a></code> object on that cell, and extract the gradients on that cell:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> active_cell_iterator <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">face_data.fe_face_values_neighbor.reinit(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>, neighbor_neighbor);</div>
<div class="line">face_data.fe_face_values_neighbor.get_function_gradients(</div>
<div class="line">  primal_solution, face_data.neighbor_grads);</div>
</div><!-- fragment --><p>Now that we have the gradients on this and the neighboring cell, compute the jump residual by multiplying the jump in the gradient with the normal vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">  face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] =</div>
<div class="line">    ((face_data.cell_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] - face_data.neighbor_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">     face_data.fe_face_values_cell.normal_vector(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
</div><!-- fragment --><p>Next get the dual weights for this face:</p>
<div class="fragment"><div class="line">face_data.fe_face_values_cell.get_function_values(dual_weights,</div>
<div class="line">                                                  face_data.dual_weights);</div>
</div><!-- fragment --><p>Finally, we have to compute the sum over jump residuals, dual weights, and quadrature weights, to get the result for this face:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> face_integral = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">  face_integral +=</div>
<div class="line">    (face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * face_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] *</div>
<div class="line">     face_data.fe_face_values_cell.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
</div><!-- fragment --><p>Double check that the element already exists and that it was not already written to...</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)) != face_integrals.end(),</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] == -1e20, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
</div><!-- fragment --><p>...then store computed value at assigned location. Note that the stored value does not contain the factor 1/2 that appears in the error representation. The reason is that the term actually does not have this factor if we loop over all faces in the triangulation, but only appears if we write it as a sum over all cells and all faces of each cell; we thus visit the same face twice. We take account of this by using this factor -1/2 later, when we sum up the contributions for each cell individually.</p>
<div class="fragment"><div class="line">  face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] = face_integral;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Computingedgetermerrorcontributions2"></a> </p><h4>Computing edge term error contributions &ndash; 2</h4>
<p>We are still missing the case of faces with hanging nodes. This is what is covered in this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_irregular_face(</div>
<div class="line">  <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">  FaceData &amp;                  face_data,</div>
<div class="line">  FaceIntegrals &amp;             face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>First again two abbreviations, and some consistency checks whether the function is called only on faces for which it is supposed to be called:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a> =</div>
<div class="line">  face_data.fe_face_values_cell.n_quadrature_points;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a> =</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd">IteratorState::valid</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">(void)<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>;</div>
</div><!-- fragment --><p>Then find out which neighbor the present cell is of the adjacent cell. Note that we will operate on the children of this adjacent cell, but that their orientation is the same as that of their mother, i.e. the neighbor direction is the same.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_neighbor =</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_of_neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
</div><!-- fragment --><p>Then simply do everything we did in the previous function for one face for all the sub-faces now:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no = 0; subface_no &lt; <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;n_children();</div>
<div class="line">     ++subface_no)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>Start with some checks again: get an iterator pointing to the cell behind the present subface and check whether its face is a subface of the one we are considering. If that were not the case, then there would be either a bug in the <code>neighbor_neighbor</code> function called above, or &ndash; worse &ndash; some function in the library did not keep to some underlying assumptions about cells, their children, and their faces. In any case, even though this assertion should not be triggered, it does not harm to be cautious, and in optimized mode computations the assertion will be removed anyway.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> active_cell_iterator neighbor_child =</div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_child_on_subface(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>, subface_no);</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(neighbor_child-&gt;face(neighbor_neighbor) ==</div>
<div class="line">         <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;child(subface_no),</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
</div><!-- fragment --><p>Now start the work by again getting the gradient of the solution first at this side of the interface,</p>
<div class="fragment"><div class="line">face_data.fe_subface_values_cell.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>, subface_no);</div>
<div class="line">face_data.fe_subface_values_cell.get_function_gradients(</div>
<div class="line">  primal_solution, face_data.cell_grads);</div>
</div><!-- fragment --><p>then at the other side,</p>
<div class="fragment"><div class="line">face_data.fe_face_values_neighbor.reinit(neighbor_child,</div>
<div class="line">                                         neighbor_neighbor);</div>
<div class="line">face_data.fe_face_values_neighbor.get_function_gradients(</div>
<div class="line">  primal_solution, face_data.neighbor_grads);</div>
</div><!-- fragment --><p>and finally building the jump residuals. Since we take the normal vector from the other cell this time, revert the sign of the first term compared to the other function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">  face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] =</div>
<div class="line">    ((face_data.neighbor_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] - face_data.cell_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">     face_data.fe_face_values_neighbor.normal_vector(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
</div><!-- fragment --><p>Then get dual weights:</p>
<div class="fragment"><div class="line">face_data.fe_face_values_neighbor.get_function_values(</div>
<div class="line">  dual_weights, face_data.dual_weights);</div>
</div><!-- fragment --><p>At last, sum up the contribution of this sub-face, and set it in the global map:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> face_integral = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">    face_integral +=</div>
<div class="line">      (face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * face_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] *</div>
<div class="line">       face_data.fe_face_values_neighbor.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line">  face_integrals[neighbor_child-&gt;face(neighbor_neighbor)] =</div>
<div class="line">    face_integral;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once the contributions of all sub-faces are computed, loop over all sub-faces to collect and store them with the mother face for simple use when later collecting the error terms of cells. Again make safety checks that the entries for the sub-faces have been computed and do not carry an invalid value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no = 0; subface_no &lt; <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;n_children();</div>
<div class="line">     ++subface_no)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)) !=</div>
<div class="line">             face_integrals.end(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)] != -1e20,</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> += face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)];</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Finally store the value with the parent face.</p>
<div class="fragment"><div class="line">    face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>] = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace LaplaceSolver</span></div>
</div><!-- fragment --><p><a class="anchor" id="Asimulationframework"></a> </p><h3>A simulation framework</h3>
<p>In the previous example program, we have had two functions that were used to drive the process of solving on subsequently finer grids. We extend this here to allow for a number of parameters to be passed to these functions, and put all of that into framework class.</p>
<p>You will have noted that this program is built up of a number of small parts (evaluation functions, solver classes implementing various refinement methods, different dual functionals, different problem and data descriptions), which makes the program relatively simple to extend, but also allows to solve a large number of different problems by replacing one part by another. We reflect this flexibility by declaring a structure in the following framework class that holds a number of parameters that may be set to test various combinations of the parts of this program, and which can be used to test it at various problems and discretizations in a simple way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>Framework</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
</div><!-- fragment --><p>First, we declare two abbreviations for simple use of the respective data types:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Evaluator     = Evaluation::EvaluationBase&lt;dim&gt;;</div>
<div class="line"><span class="keyword">using</span> EvaluatorList = std::list&lt;Evaluator *&gt;;</div>
</div><!-- fragment --><p>Then we have the structure which declares all the parameters that may be set. In the default constructor of the structure, these values are all set to default values, for simple use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ProblemDescription</div>
<div class="line">{</div>
</div><!-- fragment --><p>First allow for the degrees of the piecewise polynomials by which the primal and dual problems will be discretized. They default to (bi-, tri-)linear ansatz functions for the primal, and (bi-, tri-)quadratic ones for the dual problem. If a refinement criterion is chosen that does not need the solution of a dual problem, the value of the dual finite element degree is of course ignored.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primal_fe_degree;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dual_fe_degree;</div>
</div><!-- fragment --><p>Then have an object that describes the problem type, i.e. right hand side, domain, boundary values, etc. The pointer needed here defaults to the Null pointer, i.e. you will have to set it in actual instances of this object to make it useful.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;const Data::SetUpBase&lt;dim&gt;&gt; <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
</div><!-- fragment --><p>Since we allow to use different refinement criteria (global refinement, refinement by the Kelly error indicator, possibly with a weight, and using the dual estimator), define a number of enumeration values, and subsequently a variable of that type. It will default to <code>dual_weighted_error_estimator</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> RefinementCriterion</div>
<div class="line">{</div>
<div class="line">  dual_weighted_error_estimator,</div>
<div class="line">  global_refinement,</div>
<div class="line">  kelly_indicator,</div>
<div class="line">  weighted_kelly_indicator</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">RefinementCriterion refinement_criterion;</div>
</div><!-- fragment --><p>Next, an object that describes the dual functional. It is only needed if the dual weighted residual refinement is chosen, and also defaults to a Null pointer.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;&gt;</div>
<div class="line">  dual_functional;</div>
</div><!-- fragment --><p>Then a list of evaluation objects. Its default value is empty, i.e. no evaluation objects.</p>
<div class="fragment"><div class="line">EvaluatorList evaluator_list;</div>
</div><!-- fragment --><p>Next to last, a function that is used as a weight to the <code>RefinementWeightedKelly</code> class. The default value of this pointer is zero, but you have to set it to some other value if you want to use the <code>weighted_kelly_indicator</code> refinement criterion.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;const Function&lt;dim&gt;&gt; kelly_weight;</div>
</div><!-- fragment --><p>Finally, we have a variable that denotes the maximum number of degrees of freedom we allow for the (primal) discretization. If it is exceeded, we stop the process of solving and intermittent mesh refinement. Its default value is 20,000.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degrees_of_freedom;</div>
</div><!-- fragment --><p>Finally the default constructor of this class:</p>
<div class="fragment"><div class="line">  ProblemDescription();</div>
<div class="line">};</div>
</div><!-- fragment --><p>The driver framework class only has one method which calls solver and mesh refinement intermittently, and does some other small tasks in between. Since it does not need data besides the parameters given to it, we make it static:</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>(<span class="keyword">const</span> ProblemDescription &amp;<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>);</div>
<div class="line">};</div>
</div><!-- fragment --><p>As for the implementation, first the constructor of the parameter object, setting all values to their defaults:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Framework&lt;dim&gt;::ProblemDescription::ProblemDescription()</div>
<div class="line">  : primal_fe_degree(1)</div>
<div class="line">  , dual_fe_degree(2)</div>
<div class="line">  , refinement_criterion(dual_weighted_error_estimator)</div>
<div class="line">  , max_degrees_of_freedom(20000)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>Then the function which drives the whole process:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">Framework&lt;dim&gt;::run</a>(<span class="keyword">const</span> ProblemDescription &amp;<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>)</div>
<div class="line">{</div>
</div><!-- fragment --><p>First create a triangulation from the given data object,</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::smoothing_on_refinement</a>);</div>
<div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;create_coarse_grid(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
</div><!-- fragment --><p>then a set of finite elements and appropriate quadrature formula:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       primal_fe(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.primal_fe_degree);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       dual_fe(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree + 1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt; face_quadrature(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree + 1);</div>
</div><!-- fragment --><p>Next, select one of the classes implementing different refinement criteria.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>;</div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.refinement_criterion)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">case</span> ProblemDescription::dual_weighted_error_estimator:</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::WeightedResidual&lt;dim&gt;&gt;(</div>
<div class="line">          <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">          primal_fe,</div>
<div class="line">          dual_fe,</div>
<div class="line">          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">          face_quadrature,</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values(),</div>
<div class="line">          *<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_functional);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">case</span> ProblemDescription::global_refinement:</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div>
<div class="line">          <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">          primal_fe,</div>
<div class="line">          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">          face_quadrature,</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">case</span> ProblemDescription::kelly_indicator:</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div>
<div class="line">          <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">          primal_fe,</div>
<div class="line">          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">          face_quadrature,</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">          <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">case</span> ProblemDescription::weighted_kelly_indicator:</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> =</div>
<div class="line">          std::make_unique&lt;LaplaceSolver::RefinementWeightedKelly&lt;dim&gt;&gt;(</div>
<div class="line">            <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">            primal_fe,</div>
<div class="line">            <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">            face_quadrature,</div>
<div class="line">            <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">            <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values(),</div>
<div class="line">            *<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.kelly_weight);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Now that all objects are in place, run the main loop. The stopping criterion is implemented at the bottom of the loop.</p>
<p>In the loop, first set the new cycle number, then solve the problem, output its <a class="el" href="slepc__solver__0_8txt.html#ab5ec380db8b9ba1020300a15dbe7de30">solution(s)</a>, apply the evaluation objects to it, then decide whether we want to refine the mesh further and solve again on this mesh, or jump out of the loop.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> = 0; <span class="keyword">true</span>; ++<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span> &lt;&lt; <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;set_refinement_cycle(<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>);</div>
<div class="line">    <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;solve_problem();</div>
<div class="line">    <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;output_solution();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom=&quot;</span> &lt;&lt; <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;evaluator : <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list)</div>
<div class="line">      {</div>
<div class="line">        evaluator-&gt;set_refinement_cycle(<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>);</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;postprocess(*evaluator);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;n_dofs() &lt; <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.max_degrees_of_freedom)</div>
<div class="line">      <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;refine_grid();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Clean up the screen after the loop has run:</p>
<div class="fragment"><div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step14</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Here finally comes the main function. It drives the whole process by specifying a set of parameters to be used for the simulation (polynomial degrees, evaluation and dual functionals, etc), and passes them packed into a structure to the frame work class above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep14.html">Step14</a>;</div>
</div><!-- fragment --><p>Describe the problem we want to solve here by passing a descriptor object to the function doing the rest of the work:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> = 2;</div>
<div class="line">Framework&lt;dim&gt;::ProblemDescription <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>;</div>
</div><!-- fragment --><p>First set the refinement criterion we wish to use:</p>
<div class="fragment"><div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.refinement_criterion =</div>
<div class="line">  Framework&lt;dim&gt;::ProblemDescription::dual_weighted_error_estimator;</div>
</div><!-- fragment --><p>Here, we could as well have used <code>global_refinement</code> or <code>weighted_kelly_indicator</code>. Note that the information given about dual finite elements, dual functional, etc is only important for the given choice of refinement criterion, and is ignored otherwise.</p>
<p>Then set the polynomial degrees of primal and dual problem. We choose here bi-linear and bi-quadratic ones:</p>
<div class="fragment"><div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.primal_fe_degree = 1;</div>
<div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree   = 2;</div>
</div><!-- fragment --><p>Then set the description of the test case, i.e. domain, boundary values, and right hand side. These are prepackaged in classes. We take here the description of <code>Exercise_2_3</code>, but you can also use <code>CurvedRidges&lt;dim&gt;</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data =</div>
<div class="line">  std::make_unique&lt;Data::SetUp&lt;Data::Exercise_2_3&lt;dim&gt;, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;&gt;();</div>
</div><!-- fragment --><p>Next set first a dual functional, then a list of evaluation objects. We choose as default the evaluation of the value at an evaluation point, represented by the classes <code>PointValueEvaluation</code> in the namespaces of evaluation and dual functional classes. You can also set the <code>PointXDerivativeEvaluation</code> classes for the x-derivative instead of the value at the evaluation point.</p>
<p>Note that dual functional and evaluation objects should match. However, you can give as many evaluation functionals as you want, so you can have both point value and derivative evaluated after each step. One such additional evaluation is to output the grid in each step.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point(0.75, 0.75);</div>
<div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_functional =</div>
<div class="line">  std::make_unique&lt;DualFunctional::PointValueEvaluation&lt;dim&gt;&gt;(</div>
<div class="line">    evaluation_point);</div>
<div class="line"> </div>
<div class="line">Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(evaluation_point);</div>
<div class="line">Evaluation::GridOutput&lt;dim&gt;           postprocessor2(<span class="stringliteral">&quot;grid&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list.push_back(&amp;postprocessor1);</div>
<div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list.push_back(&amp;postprocessor2);</div>
</div><!-- fragment --><p>Set the maximal number of degrees of freedom after which we want the program to stop refining the mesh further:</p>
<div class="fragment"><div class="line"><a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.max_degrees_of_freedom = 20000;</div>
</div><!-- fragment --><p>Finally pass the descriptor object to a function that runs the entire solution with it:</p>
<div class="fragment"><div class="line">  <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">Framework&lt;dim&gt;::run</a>(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Catch exceptions to give information about things that failed:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Pointvalues"></a></p><h3><a class="el" href="classPoint.html">Point</a> values</h3>
<p>This program offers a lot of possibilities to play around. We can thus only show a small part of all possible results that can be obtained with the help of this program. However, you are encouraged to just try it out, by changing the settings in the main program. Here, we start by simply letting it run, unmodified: </p><div class="fragment"><div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 0</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=72</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.03243</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=0.000702385</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 1</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=67</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0324827</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=0.000888953</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 2</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=130</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0329619</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=0.000454606</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 3</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=307</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0331934</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=0.000241254</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 4</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=718</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0333675</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=7.4912e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 5</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=1665</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0334083</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=3.69111e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 6</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=3975</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.033431</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=1.54218e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 7</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=8934</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0334406</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=6.28359e-06</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 8</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=21799</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>=0.0334444</div>
</div><!-- fragment --><p>First let's look what the program actually computed. On the seventh grid, primal and dual numerical solutions look like this (using a color scheme intended to evoke the snow-capped mountains of Colorado that the original author of this program now calls home): </p><table align="center">
<tr>
<td width="50%"><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.solution-7.9.2.png" alt="" class="inline"/>  </td><td width="50%"><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.solution-7-dual.9.2.png" alt="" class="inline"/>   </td></tr>
</table>
<p>Apparently, the region at the bottom left is so unimportant for the point value evaluation at the top right that the grid is left entirely unrefined there, even though the solution has singularities at the inner corner of that cell! Due to the symmetry in right hand side and domain, the solution should actually look like at the top right in all four corners, but the mesh refinement criterion involving the dual solution chose to refine them differently &ndash; because we said that we really only care about a single function value somewhere at the top right.</p>
<p>Here are some of the meshes that are produced in refinement cycles 0, 2, 4 (top row), and 5, 7, and 8 (bottom row):</p>
<table width="80%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-0.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-2.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-4.9.2.png" alt="" width="100%" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-5.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-7.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.grid-8.9.2.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p>Note the subtle interplay between resolving the corner singularities, and resolving around the point of evaluation. It will be rather difficult to generate such a mesh by hand, as this would involve to judge quantitatively how much which of the four corner singularities should be resolved, and to set the weight compared to the vicinity of the evaluation point.</p>
<p>The program prints the point value and the estimated error in this quantity. From extrapolating it, we can guess that the exact value is somewhere close to 0.0334473, plus or minus 0.0000001 (note that we get almost 6 valid digits from only 22,000 (primal) degrees of freedom. This number cannot be obtained from the value of the functional alone, but I have used the assumption that the error estimator is mostly exact, and extrapolated the computed value plus the estimated error, to get an approximation of the true value. Computing with more degrees of freedom shows that this assumption is indeed valid.</p>
<p>From the computed results, we can generate two graphs: one that shows the convergence of the error \(J(u)-J(u_h)\) (taking the extrapolated value as correct) in the point value, and the value that we get by adding up computed value \(J(u_h)\) and estimated error eta (if the error estimator \(eta\) were exact, then the value \(J(u_h)+\eta\) would equal the exact point value, and the error in this quantity would always be zero; however, since the error estimator is only a - good - approximation to the true error, we can by this only reduce the size of the error). In this graph, we also indicate the complexity \({\cal O}(1/N)\) to show that mesh refinement acts optimal in this case. The second chart compares true and estimated error, and shows that the two are actually very close to each other, even for such a complicated quantity as the point value:</p>
<table width="80%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.error.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.error-estimation.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p><a class="anchor" id="Comparingrefinementcriteria"></a></p><h3>Comparing refinement criteria</h3>
<p>Since we have accepted quite some effort when using the mesh refinement driven by the dual weighted error estimator (for solving the dual problem, and for evaluating the error representation), it is worth while asking whether that effort was successful. To this end, we first compare the achieved error levels for different mesh refinement criteria. To generate this data, simply change the value of the mesh refinement criterion variable in the main program. The results are thus (for the weight in the Kelly indicator, we have chosen the function \(1/(r^2+0.1^2)\), where \(r\) is the distance to the evaluation point; it can be shown that this is the optimal weight if we neglect the effects of boundaries):</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-14.point-value.error-comparison.png" alt="" class="inline"/></p>
<p>Checking these numbers, we see that for global refinement, the error is proportional to \(O(1/(sqrt(N) log(N)))\), and for the dual estimator \(O(1/N)\). Generally speaking, we see that the dual weighted error estimator is better than the other refinement indicators, at least when compared with those that have a similarly regular behavior. The Kelly indicator produces smaller errors, but jumps about the picture rather irregularly, with the error also changing signs sometimes. Therefore, its behavior does not allow to extrapolate the results to larger values of N. Furthermore, if we trust the error estimates of the dual weighted error estimator, the results can be improved by adding the estimated error to the computed values. In terms of reliability, the weighted estimator is thus better than the Kelly indicator, although the latter sometimes produces smaller errors.</p>
<p><a class="anchor" id="Evaluationofpointstresses"></a></p><h3>Evaluation of point stresses</h3>
<p>Besides evaluating the values of the solution at a certain point, the program also offers the possibility to evaluate the x-derivatives at a certain point, and also to tailor mesh refinement for this. To let the program compute these quantities, simply replace the two occurrences of <code>PointValueEvaluation</code> in the main function by <code>PointXDerivativeEvaluation</code>, and let the program run: </p><div class="fragment"><div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 0</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=72</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0719397</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.0126173</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 1</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=61</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0707956</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.00774316</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 2</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=131</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0568671</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.00313426</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 3</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=247</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.053033</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.00136114</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 4</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=532</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0526429</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.000558868</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 5</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=1267</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0526955</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-0.000220116</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 6</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=2864</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0527495</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-9.46731e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 7</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=6409</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.052785</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-4.21543e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 8</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=14183</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.0528028</div>
<div class="line">   Estimated <a class="code" href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a>=-2.04241e-05</div>
<div class="line">Refinement <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>: 9</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>=29902</div>
<div class="line">   <a class="code" href="classPoint.html">Point</a> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>-<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a>=-0.052814</div>
</div><!-- fragment --><p>The solution looks roughly the same as before (the exact solution of course <em>is</em> the same, only the grid changed a little), but the dual solution is now different. A close-up around the point of evaluation shows this: </p><table align="center">
<tr>
<td width="50%"><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.solution-7-dual.png" alt="" class="inline"/>  </td><td width="50%"><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.solution-7-dual-close-up.png" alt="" class="inline"/>  </td></tr>
</table>
<p>This time, the grids in refinement cycles 0, 5, 6, 7, 8, and 9 look like this:</p>
<table align="center" width="80%">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-0.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-5.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-6.9.2.png" alt="" width="100%" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-7.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-8.9.2.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-9.9.2.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p>Note the asymmetry of the grids compared with those we obtained for the point evaluation. This is due to the fact that the domain and the primal solution may be symmetric about the diagonal, but the \(x\)-derivative is not, and the latter enters the refinement criterion.</p>
<p>Then, it is interesting to compare actually computed values of the quantity of interest (i.e. the x-derivative of the solution at one point) with a reference value of -0.0528223... plus or minus 0.0000005. We get this reference value by computing on finer grid after some more mesh refinements, with approximately 130,000 cells. Recall that if the error is \(O(1/N)\) in the optimal case, then taking a mesh with ten times more cells gives us one additional digit in the result.</p>
<p>In the left part of the following chart, you again see the convergence of the error towards this extrapolated value, while on the right you see a comparison of true and estimated error:</p>
<table width="80%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.error.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.point-derivative.error-estimation.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p>After an initial phase where the true error changes its sign, the estimated error matches it quite well, again. Also note the dramatic improvement in the error when using the estimated error to correct the computed value of \(J(u_h)\).</p>
<p><a class="anchor" id="step13revisited"></a></p><h3>step-13 revisited</h3>
<p>If instead of the <code>Exercise_2_3</code> data set, we choose <code>CurvedRidges</code> in the main function, and choose \((0.5,0.5)\) as the evaluation point, then we can redo the computations of the previous example program, to compare whether the results obtained with the help of the dual weighted error estimator are better than those we had previously.</p>
<p>First, the meshes after 9 adaptive refinement cycles obtained with the point evaluation and derivative evaluation refinement criteria, respectively, look like this:</p>
<table width="80%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.step-13.point-value.png" alt="" width="100%" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-14.step-13.point-derivative.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p>The features of the solution can still be seen in the mesh, but since the solution is smooth, the singularities of the dual solution entirely dominate the mesh refinement criterion, and lead to strongly concentrated meshes. The solution after the seventh refinement step looks like the following:</p>
<table width="40%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-14.step-13.solution-7.9.2.png" alt="" width="100%" class="inline"/>  </td></tr>
</table>
<p>Obviously, the solution is worse at some places, but the mesh refinement process should have taken care that these places are not important for computing the point value.</p>
<p>The next point is to compare the new (duality based) mesh refinement criterion with the old ones. These are the results:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-14.step-13.error-comparison.png" alt="" class="inline"/></p>
<p>The results are, well, somewhat mixed. First, the Kelly indicator disqualifies itself by its unsteady behavior, changing the sign of the error several times, and with increasing errors under mesh refinement. The dual weighted error estimator has a monotone decrease in the error, and is better than the weighted Kelly and global refinement, but the margin is not as large as expected. This is, here, due to the fact the global refinement can exploit the regular structure of the meshes around the point of evaluation, which leads to a better order of convergence for the point error. However, if we had a mesh that is not locally rectangular, for example because we had to approximate curved boundaries, or if the coefficients were not constant, then this advantage of globally refinement meshes would vanish, while the good performance of the duality based estimator would remain.</p>
<p><a class="anchor" id="Conclusionsandoutlook"></a></p><h3>Conclusions and outlook</h3>
<p>The results here are not too clearly indicating the superiority of the dual weighted error estimation approach for mesh refinement over other mesh refinement criteria, such as the Kelly indicator. This is due to the relative simplicity of the shown applications. If you are not convinced yet that this approach is indeed superior, you are invited to browse through the literature indicated in the introduction, where plenty of examples are provided where the dual weighted approach can reduce the necessary numerical work by orders of magnitude, making this the only way to compute certain quantities to reasonable accuracies at all.</p>
<p>Besides the objections you may raise against its use as a mesh refinement criterion, consider that accurate knowledge of the error in the quantity one might want to compute is of great use, since we can stop computations when we are satisfied with the accuracy. Using more traditional approaches, it is very difficult to get accurate estimates for arbitrary quantities, except for, maybe, the error in the energy norm, and we will then have no guarantee that the result we computed satisfies any requirements on its accuracy. Also, as was shown for the evaluation of point values and derivatives, the error estimate can be used to extrapolate the results, yielding much higher accuracy in the quantity we want to know.</p>
<p>Leaving these mathematical considerations, we tried to write the program in a modular way, such that implementing another test case, or another evaluation and dual functional is simple. You are encouraged to take the program as a basis for your own experiments, and to play a little.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2002 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, ETH Zurich, 2002</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__tools_8h.html">deal.II/fe/fe_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep14.html">Step14</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>Evaluation</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>EvaluationBase</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>)</div>
<div class="line">    {</div>
<div class="line">      refinement_cycle = <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">        ExcEvaluationPointNotFound,</div>
<div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">      : evaluation_point(evaluation_point)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">PointValueEvaluation&lt;dim&gt;::</a></div>
<div class="line"><a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">         operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordtype">double</span> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = 1e20;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        <span class="keywordflow">if</span> (!evaluation_point_found)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>).distance(evaluation_point) &lt;</div>
<div class="line">                <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter() * 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8)</div>
<div class="line">              {</div>
<div class="line">                <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_dof_index(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>, 0));</div>
<div class="line"> </div>
<div class="line">                evaluation_point_found = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div>
<div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Point value=&quot;</span> &lt;&lt; <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PointXDerivativeEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PointXDerivativeEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceSUNDIALS.html#aa047727a4eb951da92db647e12adb153">DeclException1</a>(</div>
<div class="line">        ExcEvaluationPointNotFound,</div>
<div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">      : evaluation_point(evaluation_point)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">PointXDerivativeEvaluation&lt;dim&gt;::</a></div>
<div class="line"><a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">         operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordtype">double</span> point_derivative = 0;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classQTrapezoid.html">QTrapezoid&lt;dim&gt;</a>             vertex_quadrature;</div>
<div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>(),</div>
<div class="line">                              vertex_quadrature,</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; solution_gradients(vertex_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> evaluation_point_hits = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>) == evaluation_point)</div>
<div class="line">            {</div>
<div class="line">              fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, solution_gradients);</div>
<div class="line"> </div>
<div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0;</div>
<div class="line">              <span class="keywordflow">for</span> (; q_point &lt; solution_gradients.size(); ++q_point)</div>
<div class="line">                <span class="keywordflow">if</span> (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point) == evaluation_point)</div>
<div class="line">                  <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(q_point &lt; solution_gradients.size(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">              point_derivative += solution_gradients[q_point][0];</div>
<div class="line">              ++evaluation_point_hits;</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_hits &gt; 0,</div>
<div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line"> </div>
<div class="line">      point_derivative /= evaluation_point_hits;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Point x-derivative=&quot;</span> &lt;&lt; point_derivative &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>GridOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      GridOutput(<span class="keyword">const</span> std::string &amp;output_name_base);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> std::string output_name_base;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    GridOutput&lt;dim&gt;::GridOutput(<span class="keyword">const</span> std::string &amp;output_name_base)</div>
<div class="line">      : output_name_base(output_name_base)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">GridOutput&lt;dim&gt;::operator()</a>(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; <span class="comment">/*solution*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div>
<div class="line">                        <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) + <span class="stringliteral">&quot;.svg&quot;</span>);</div>
<div class="line">      <a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>(), <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>);</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// namespace Evaluation</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>Base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">      <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">      : <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>(&amp;coarse_grid)</div>
<div class="line">      , refinement_cycle(<a class="code" href="namespacenumbers.html">numbers</a>::<a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">invalid_unsigned_int</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Base&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>)</div>
<div class="line">    {</div>
<div class="line">      refinement_cycle = <a class="code" href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line">      <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt;  <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;     <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt;&gt; face_quadrature;</div>
<div class="line">      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                               dof_handler;</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                                <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;       boundary_values;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">struct </span>LinearSystem</div>
<div class="line">      {</div>
<div class="line">        LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div>
<div class="line">        <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line">        <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>;</div>
<div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>AssemblyScratchData</div>
<div class="line">      {</div>
<div class="line">        AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>);</div>
<div class="line">        AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>AssemblyCopyData</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>;</div>
<div class="line">        std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> local_assemble_matrix(</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">        AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">        AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">      , <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(&amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>)</div>
<div class="line">      , <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(&amp;<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>)</div>
<div class="line">      , face_quadrature(&amp;face_quadrature)</div>
<div class="line">      , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">      , boundary_values(&amp;boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::~Solver()</div>
<div class="line">    {</div>
<div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">Solver&lt;dim&gt;::solve_problem</a>()</div>
<div class="line">    {</div>
<div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line">      <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">      LinearSystem linear_system(dof_handler);</div>
<div class="line">      assemble_linear_system(linear_system);</div>
<div class="line">      linear_system.solve(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div>
<div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>(dof_handler, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div>
<div class="line">        <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> worker =</div>
<div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">               AssemblyScratchData &amp;scratch_data,</div>
<div class="line">               AssemblyCopyData &amp;   copy_data) {</div>
<div class="line">          this-&gt;local_assemble_matrix(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, scratch_data, copy_data);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> <a class="code" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a> = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div>
<div class="line">        this-&gt;copy_local_to_global(copy_data, linear_system);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div>
<div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">end</a>(),</div>
<div class="line">                      worker,</div>
<div class="line">                      <a class="code" href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a>,</div>
<div class="line">                      AssemblyScratchData(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, *<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>),</div>
<div class="line">                      AssemblyCopyData());</div>
<div class="line">      linear_system.hanging_node_constraints.condense(linear_system.matrix);</div>
<div class="line"> </div>
<div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                               0,</div>
<div class="line">                                               *boundary_values,</div>
<div class="line">                                               boundary_value_map);</div>
<div class="line"> </div>
<div class="line">      rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line">      linear_system.hanging_node_constraints.condense(linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div>
<div class="line">                                         linear_system.matrix,</div>
<div class="line">                                         <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                         linear_system.rhs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>)</div>
<div class="line">      : fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">      <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div>
<div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div>
<div class="line">                  scratch_data.fe_values.get_quadrature(),</div>
<div class="line">                  <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">      AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">      AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>-&gt;<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>-&gt;size();</div>
<div class="line"> </div>
<div class="line">      copy_data.cell_matrix.reinit(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">      copy_data.local_dof_indices.resize(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">      scratch_data.fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            copy_data.cell_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=</div>
<div class="line">              (scratch_data.fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) *</div>
<div class="line">               scratch_data.fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point) *</div>
<div class="line">               scratch_data.fe_values.JxW(q_point));</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(copy_data.local_dof_indices);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                           LinearSystem &amp;linear_system)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; copy_data.local_dof_indices.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; copy_data.local_dof_indices.size(); ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">          linear_system.matrix.add(copy_data.local_dof_indices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                                   copy_data.local_dof_indices[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>],</div>
<div class="line">                                   copy_data.cell_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div>
<div class="line">    {</div>
<div class="line">      hanging_node_constraints.clear();</div>
<div class="line"> </div>
<div class="line">      void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div>
<div class="line">        &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div>
<div class="line">        <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line"> </div>
<div class="line">      hanging_node_constraints.close();</div>
<div class="line">      hanging_node_constraints.condense(dsp);</div>
<div class="line">      <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>.reinit(<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line">      <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">Solver&lt;dim&gt;::LinearSystem::solve</a>(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(5000, 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-12);</div>
<div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>;</div>
<div class="line">      <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>.initialize(<a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>, 1.2);</div>
<div class="line"> </div>
<div class="line">      cg.solve(<a class="code" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>, <a class="code" href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a>);</div>
<div class="line"> </div>
<div class="line">      hanging_node_constraints.distribute(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">      , Solver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                    <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                    face_quadrature,</div>
<div class="line">                    boundary_values)</div>
<div class="line">      , rhs_function(&amp;rhs_function)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::output_solution()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(this-&gt;dof_handler);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(this-&gt;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">      std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                        <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>, <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26">DataOutBase::vtu</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div>
<div class="line">                              *this-&gt;quadrature,</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = this-&gt;fe-&gt;<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = this-&gt;quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      std::vector&lt;double&gt;                  rhs_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">      std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        {</div>
<div class="line">          cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">          fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">          rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div>
<div class="line">                                   rhs_values);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">              cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * <span class="comment">// phi_i(x_q)</span></div>
<div class="line">                              rhs_values[q_point] *               <span class="comment">// f((x_q)</span></div>
<div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));            <span class="comment">// dx</span></div>
<div class="line"> </div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]) += cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                          face_quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      this-&gt;triangulation-&gt;refine_global(1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    RefinementKelly&lt;dim&gt;::RefinementKelly(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                          face_quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">        this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">      <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">        this-&gt;dof_handler,</div>
<div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div>
<div class="line">        <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">        <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#ae3fd76f0fcd93dcbcc9df2df2c6028fb">this</a>-&gt;solution,</div>
<div class="line">        estimated_error_per_cell);</div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.3,</div>
<div class="line">                                                      0.03);</div>
<div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>RefinementWeightedKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      RefinementWeightedKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      weighting_function);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; weighting_function;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    RefinementWeightedKelly&lt;dim&gt;::RefinementWeightedKelly(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;       coarse_grid,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      boundary_values,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      weighting_function)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                          face_quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          boundary_values)</div>
<div class="line">      , weighting_function(&amp;weighting_function)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> RefinementWeightedKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">        this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">      std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt; dummy_function_map;</div>
<div class="line">      <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(this-&gt;dof_handler,</div>
<div class="line">                                         *this-&gt;face_quadrature,</div>
<div class="line">                                         dummy_function_map,</div>
<div class="line">                                         this-&gt;solution,</div>
<div class="line">                                         estimated_error_per_cell);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        estimated_error_per_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) *=</div>
<div class="line">          weighting_function-&gt;value(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;center());</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.3,</div>
<div class="line">                                                      0.03);</div>
<div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>Data</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">struct </span>SetUpBase : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_boundary_values() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_right_hand_side() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">      create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid) <span class="keyword">const</span> = 0;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">struct </span>SetUp : <span class="keyword">public</span> SetUpBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_boundary_values() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;get_right_hand_side() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">      create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> Traits::BoundaryValues boundary_values;</div>
<div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> Traits::RightHandSide  <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Traits::BoundaryValues SetUp&lt;Traits, dim&gt;::boundary_values;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Traits::RightHandSide <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">SetUp&lt;Traits, dim&gt;::right_hand_side</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;SetUp&lt;Traits, dim&gt;::get_boundary_values()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> boundary_values;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;SetUp&lt;Traits, dim&gt;::get_right_hand_side()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits, <span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> SetUp&lt;Traits, dim&gt;::create_coarse_grid(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      Traits::create_coarse_grid(coarse_grid);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">struct </span>CurvedRidges</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">class </span><a class="code" href="classBoundaryValues.html">BoundaryValues</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">      {</div>
<div class="line">      <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const</span>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">      {</div>
<div class="line">      <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a>) <span class="keyword">const</span>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span> create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">CurvedRidges&lt;dim&gt;::BoundaryValues::value</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordtype">double</span> q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        q += <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div>
<div class="line">      <span class="keywordflow">return</span> exponential;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">CurvedRidges&lt;dim&gt;::RightHandSide::value</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordtype">double</span> q = <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        q += <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div>
<div class="line">      <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 1; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        {</div>
<div class="line">          t1 += <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) * 10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">          t2 += 10 * <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) -</div>
<div class="line">                100 * <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0);</div>
<div class="line">          t3 += 100 * <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) *</div>
<div class="line">                  <a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0)) -</div>
<div class="line">                100 * <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(10 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) + 5 * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0) * <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(0));</div>
<div class="line">        }</div>
<div class="line">      t1 = t1 * t1;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> CurvedRidges&lt;dim&gt;::create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(coarse_grid, -1, 1);</div>
<div class="line">      coarse_grid.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">struct </span>Exercise_2_3</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using</span> <a class="code" href="classBoundaryValues.html">BoundaryValues</a> = <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">class </span><a class="code" href="classRightHandSide.html">RightHandSide</a> : <span class="keyword">public</span> <a class="code" href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction</a>&lt;dim&gt;</div>
<div class="line">      {</div>
<div class="line">      <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="classRightHandSide.html">RightHandSide</a>()</div>
<div class="line">          : <a class="code" href="namespaceFunctions.html">Functions</a>::<a class="code" href="classFunctions_1_1ConstantFunction.html">ConstantFunction</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(1.)</div>
<div class="line">        {}</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span> create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Exercise_2_3&lt;2&gt;::create_coarse_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> = 2;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; <a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a> = {</div>
<div class="line">        {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, </div>
<div class="line">        {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, </div>
<div class="line">        {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               </div>
<div class="line">        {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, </div>
<div class="line">        {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;std::array&lt;int, GeometryInfo&lt;dim&gt;::vertices_per_cell&gt;&gt;</div>
<div class="line">        cell_vertices = {{{0, 1, 5, 6}},</div>
<div class="line">                         {{1, 2, 6, 7}},</div>
<div class="line">                         {{2, 3, 7, 8}},</div>
<div class="line">                         {{3, 4, 8, 9}},</div>
<div class="line">                         {{5, 6, 10, 11}},</div>
<div class="line">                         {{8, 9, 12, 13}},</div>
<div class="line">                         {{10, 11, 14, 15}},</div>
<div class="line">                         {{12, 13, 17, 18}},</div>
<div class="line">                         {{14, 15, 19, 20}},</div>
<div class="line">                         {{15, 16, 20, 21}},</div>
<div class="line">                         {{16, 17, 21, 22}},</div>
<div class="line">                         {{17, 18, 22, 23}}};</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a> = cell_vertices.size();</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;CellData&lt;dim&gt;&gt; <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>(<a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>, <a class="code" href="structCellData.html">CellData&lt;dim&gt;</a>());</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; cell_vertices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].size(); ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a>[<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>] = cell_vertices[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>][<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>];</div>
<div class="line">          <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].material_id = 0;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      coarse_grid.<a class="code" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a>(<a class="code" href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a>, <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>, <a class="code" href="structSubCellData.html">SubCellData</a>());</div>
<div class="line"> </div>
<div class="line">      coarse_grid.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// namespace Data</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>DualFunctional</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>DualFunctionalBase : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">        ExcEvaluationPointNotFound,</div>
<div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">      : evaluation_point(evaluation_point)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    PointValueEvaluation&lt;dim&gt;::assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_indices())</div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>).distance(evaluation_point) &lt;</div>
<div class="line">              <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter() * 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8)</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;vertex_dof_index(<a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a>, 0)) = 1;</div>
<div class="line">              <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PointXDerivativeEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PointXDerivativeEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceSUNDIALS.html#aa047727a4eb951da92db647e12adb153">DeclException1</a>(</div>
<div class="line">        ExcEvaluationPointNotFound,</div>
<div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div>
<div class="line">      : evaluation_point(evaluation_point)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> PointXDerivativeEvaluation&lt;dim&gt;::assemble_rhs(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;       <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values(dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>(),</div>
<div class="line">                              <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = dof_handler.<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">      std::vector&lt;unsigned int&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> total_volume = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;center().distance(evaluation_point) &lt;= <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;diameter())</div>
<div class="line">          {</div>
<div class="line">            fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">            cell_rhs = 0;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">                  cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) +=</div>
<div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)[0] <span class="comment">// (d/dx phi_i(x_q))</span></div>
<div class="line">                    * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx</span></div>
<div class="line">                total_volume += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">              <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]) += cell_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(total_volume &gt; 0,</div>
<div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a> /= total_volume;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace DualFunctional</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>DualSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      DualSolver(</div>
<div class="line">        <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">        <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;</a>&gt;</div>
<div class="line">                   dual_functional;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> boundary_values;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> DualSolver&lt;dim&gt;::boundary_values;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    DualSolver&lt;dim&gt;::DualSolver(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">      <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">      , Solver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                    <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                    <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                    face_quadrature,</div>
<div class="line">                    boundary_values)</div>
<div class="line">      , dual_functional(&amp;dual_functional)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> DualSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      dual_functional-&gt;assemble_rhs(this-&gt;dof_handler, <a class="code" href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>WeightedResidual : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;, <span class="keyword">public</span> DualSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      WeightedResidual(</div>
<div class="line">        <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           coarse_grid,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     primal_fe,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     dual_fe,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          rhs_function,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          boundary_values,</div>
<div class="line">        <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">solve_problem</a>() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> output_solution() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keywordtype">void</span> solve_primal_problem();</div>
<div class="line">      <span class="keywordtype">void</span> solve_dual_problem();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">using</span> active_cell_iterator =</div>
<div class="line">        <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">using</span> FaceIntegrals =</div>
<div class="line">        <span class="keyword">typename</span> std::map&lt;typename DoFHandler&lt;dim&gt;::face_iterator, <span class="keywordtype">double</span>&gt;;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span><a class="code" href="structCellData.html">CellData</a></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                           fe_values;</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>;</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;double&gt; <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>;</div>
<div class="line">        std::vector&lt;double&gt; rhs_values;</div>
<div class="line">        std::vector&lt;double&gt; dual_weights;</div>
<div class="line">        std::vector&lt;double&gt; cell_laplacians;</div>
<div class="line">        <a class="code" href="structCellData.html">CellData</a>(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>);</div>
<div class="line">        <a class="code" href="structCellData.html">CellData</a>(<span class="keyword">const</span> <a class="code" href="structCellData.html">CellData</a> &amp;cell_data);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>FaceData</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values_cell;</div>
<div class="line">        <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    fe_face_values_neighbor;</div>
<div class="line">        <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_subface_values_cell;</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;double&gt;                  jump_residual;</div>
<div class="line">        std::vector&lt;double&gt;                  dual_weights;</div>
<div class="line">        <span class="keyword">typename</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; cell_grads;</div>
<div class="line">        <span class="keyword">typename</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; neighbor_grads;</div>
<div class="line">        FaceData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature);</div>
<div class="line">        FaceData(<span class="keyword">const</span> FaceData &amp;face_data);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>WeightedResidualScratchData</div>
<div class="line">      {</div>
<div class="line">        WeightedResidualScratchData(</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; primal_fe,</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    primal_quadrature,</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;primal_face_quadrature,</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     primal_solution,</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     dual_weights);</div>
<div class="line"> </div>
<div class="line">        WeightedResidualScratchData(</div>
<div class="line">          <span class="keyword">const</span> WeightedResidualScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="structCellData.html">CellData</a>       cell_data;</div>
<div class="line">        FaceData       face_data;</div>
<div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> primal_solution;</div>
<div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_weights;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>WeightedResidualCopyData</div>
<div class="line">      {};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> estimate_error(<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> estimate_on_one_cell(<span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">                                WeightedResidualCopyData &amp;   copy_data,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;              error_indicators,</div>
<div class="line">                                FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> integrate_over_cell(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">                               <a class="code" href="structCellData.html">CellData</a> &amp;                  cell_data,</div>
<div class="line">                               <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> integrate_over_regular_face(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;primal_solution,</div>
<div class="line">                                       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dual_weights,</div>
<div class="line">                                       FaceData &amp;            face_data,</div>
<div class="line">                                       FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
<div class="line">      <span class="keywordtype">void</span> integrate_over_irregular_face(<span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;primal_solution,</div>
<div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dual_weights,</div>
<div class="line">                                         FaceData &amp;            face_data,</div>
<div class="line">                                         FaceIntegrals &amp;face_integrals) <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::CellData::CellData(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">      : fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                  <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                  <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                    <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">      , <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>(&amp;<a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">      , <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">      , rhs_values(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">      , dual_weights(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">      , cell_laplacians(<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>.<a class="code" href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a>())</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::CellData::CellData(<span class="keyword">const</span> <a class="code" href="structCellData.html">CellData</a> &amp;cell_data)</div>
<div class="line">      : fe_values(cell_data.fe_values.get_fe(),</div>
<div class="line">                  cell_data.fe_values.get_quadrature(),</div>
<div class="line">                  <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                    <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">      , <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>(cell_data.<a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>)</div>
<div class="line">      , <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(cell_data.<a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>)</div>
<div class="line">      , rhs_values(cell_data.rhs_values)</div>
<div class="line">      , dual_weights(cell_data.dual_weights)</div>
<div class="line">      , cell_laplacians(cell_data.cell_laplacians)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::FaceData::FaceData(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;face_quadrature)</div>
<div class="line">      : fe_face_values_cell(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            face_quadrature,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">      , fe_face_values_neighbor(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                                face_quadrature,</div>
<div class="line">                                <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                  <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">      , fe_subface_values_cell(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>, face_quadrature, <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">      jump_residual.resize(n_face_q_points);</div>
<div class="line">      dual_weights.resize(n_face_q_points);</div>
<div class="line">      cell_grads.resize(n_face_q_points);</div>
<div class="line">      neighbor_grads.resize(n_face_q_points);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::FaceData::FaceData(<span class="keyword">const</span> FaceData &amp;face_data)</div>
<div class="line">      : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),</div>
<div class="line">                            face_data.fe_face_values_cell.get_quadrature(),</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">      , fe_face_values_neighbor(</div>
<div class="line">          face_data.fe_face_values_neighbor.get_fe(),</div>
<div class="line">          face_data.fe_face_values_neighbor.get_quadrature(),</div>
<div class="line">          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div>
<div class="line">      , fe_subface_values_cell(</div>
<div class="line">          face_data.fe_subface_values_cell.get_fe(),</div>
<div class="line">          face_data.fe_subface_values_cell.get_quadrature(),</div>
<div class="line">          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div>
<div class="line">      , jump_residual(face_data.jump_residual)</div>
<div class="line">      , dual_weights(face_data.dual_weights)</div>
<div class="line">      , cell_grads(face_data.cell_grads)</div>
<div class="line">      , neighbor_grads(face_data.neighbor_grads)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::WeightedResidualScratchData::</div>
<div class="line">      WeightedResidualScratchData(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; primal_fe,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    primal_quadrature,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;primal_face_quadrature,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;      rhs_function,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     primal_solution,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;     dual_weights)</div>
<div class="line">      : cell_data(primal_fe, primal_quadrature, rhs_function)</div>
<div class="line">      , face_data(primal_fe, primal_face_quadrature)</div>
<div class="line">      , primal_solution(primal_solution)</div>
<div class="line">      , dual_weights(dual_weights)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::WeightedResidualScratchData::</div>
<div class="line">      WeightedResidualScratchData(</div>
<div class="line">        <span class="keyword">const</span> WeightedResidualScratchData &amp;scratch_data)</div>
<div class="line">      : cell_data(scratch_data.cell_data)</div>
<div class="line">      , face_data(scratch_data.face_data)</div>
<div class="line">      , primal_solution(scratch_data.primal_solution)</div>
<div class="line">      , dual_weights(scratch_data.dual_weights)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    WeightedResidual&lt;dim&gt;::WeightedResidual(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;                           coarse_grid,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     primal_fe,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;                     dual_fe,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;                    face_quadrature,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          rhs_function,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;                          bv,</div>
<div class="line">      <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional)</div>
<div class="line">      : Base&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                          primal_fe,</div>
<div class="line">                          <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                          face_quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          bv)</div>
<div class="line">      , DualSolver&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;(coarse_grid,</div>
<div class="line">                        dual_fe,</div>
<div class="line">                        <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                        face_quadrature,</div>
<div class="line">                        dual_functional)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">WeightedResidual&lt;dim&gt;::solve_problem</a>()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup&lt;void&gt;</a> <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a>;</div>
<div class="line">      <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a> +=</div>
<div class="line">        <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;WeightedResidual&lt;dim&gt;::solve_primal_problem, *<span class="keyword">this</span>);</div>
<div class="line">      <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a> +=</div>
<div class="line">        <a class="code" href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a>(&amp;WeightedResidual&lt;dim&gt;::solve_dual_problem, *<span class="keyword">this</span>);</div>
<div class="line">      <a class="code" href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a>.join_all();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::solve_primal_problem()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">PrimalSolver&lt;dim&gt;::solve_problem</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::solve_dual_problem()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">DualSolver&lt;dim&gt;::solve_problem</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::postprocess(</div>
<div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      PrimalSolver&lt;dim&gt;::postprocess(<a class="code" href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> WeightedResidual&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> PrimalSolver&lt;dim&gt;::n_dofs();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_indicators(this-&gt;triangulation-&gt;n_active_cells());</div>
<div class="line">      estimate_error(error_indicators);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">float</span> &amp;error_indicator : error_indicators)</div>
<div class="line">        error_indicator = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(error_indicator);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(*this-&gt;triangulation,</div>
<div class="line">                                                        error_indicators,</div>
<div class="line">                                                        0.8,</div>
<div class="line">                                                        0.02);</div>
<div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::output_solution()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> primal_hanging_node_constraints;</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                              primal_hanging_node_constraints);</div>
<div class="line">      primal_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_solution(PrimalSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line">      <a class="code" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                           <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">DualSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                           PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                           primal_hanging_node_constraints,</div>
<div class="line">                           dual_solution);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(PrimalSolver&lt;dim&gt;::dof_handler);</div>
<div class="line"> </div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">PrimalSolver&lt;dim&gt;::solution</a>, <span class="stringliteral">&quot;primal_solution&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dual_solution, <span class="stringliteral">&quot;dual_solution&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">      std::ofstream <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                        <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a>, <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26">DataOutBase::vtu</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    WeightedResidual&lt;dim&gt;::estimate_error(<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> dual_hanging_node_constraints;</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                              dual_hanging_node_constraints);</div>
<div class="line">      dual_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> primal_solution(DualSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line">      <a class="code" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                           <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">PrimalSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                           DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                           dual_hanging_node_constraints,</div>
<div class="line">                           primal_solution);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> primal_hanging_node_constraints;</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                              primal_hanging_node_constraints);</div>
<div class="line">      primal_hanging_node_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_weights(DualSolver&lt;dim&gt;::dof_handler.n_dofs());</div>
<div class="line">      <a class="code" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">FETools::interpolation_difference</a>(DualSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                        dual_hanging_node_constraints,</div>
<div class="line">                                        <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">DualSolver&lt;dim&gt;::solution</a>,</div>
<div class="line">                                        PrimalSolver&lt;dim&gt;::dof_handler,</div>
<div class="line">                                        primal_hanging_node_constraints,</div>
<div class="line">                                        dual_weights);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      FaceIntegrals face_integrals;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> :</div>
<div class="line">           DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators())</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_iterators())</div>
<div class="line">          face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>] = -1e20;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> worker = [<span class="keyword">this</span>,</div>
<div class="line">                     &amp;error_indicators,</div>
<div class="line">                     &amp;face_integrals](<span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                      WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">                                      WeightedResidualCopyData &amp;   copy_data) {</div>
<div class="line">        this-&gt;estimate_on_one_cell(</div>
<div class="line">          <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, scratch_data, copy_data, error_indicators, face_integrals);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> do_nothing_copier =</div>
<div class="line">        std::function&lt;void(const WeightedResidualCopyData &amp;)&gt;();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div>
<div class="line">        DualSolver&lt;dim&gt;::dof_handler.<a class="code" href="iterators__0_8txt.html#ad83e6d423f9ad63243b1465081bde416">begin_active</a>(),</div>
<div class="line">        DualSolver&lt;dim&gt;::dof_handler.<a class="code" href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a>(),</div>
<div class="line">        worker,</div>
<div class="line">        do_nothing_copier,</div>
<div class="line">        WeightedResidualScratchData(*<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">DualSolver&lt;dim&gt;::fe</a>,</div>
<div class="line">                                    *<a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">DualSolver&lt;dim&gt;::quadrature</a>,</div>
<div class="line">                                    *DualSolver&lt;dim&gt;::face_quadrature,</div>
<div class="line">                                    *this-&gt;rhs_function,</div>
<div class="line">                                    primal_solution,</div>
<div class="line">                                    dual_weights),</div>
<div class="line">        WeightedResidualCopyData());</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> present_cell = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> :</div>
<div class="line">           DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators())</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_iterators())</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>) != face_integrals.end(),</div>
<div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">              error_indicators(present_cell) -= 0.5 * face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>];</div>
<div class="line">            }</div>
<div class="line">          ++present_cell;</div>
<div class="line">        }</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Estimated error=&quot;</span></div>
<div class="line">                &lt;&lt; std::accumulate(error_indicators.<a class="code" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a>(),</div>
<div class="line">                                   error_indicators.<a class="code" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a>(),</div>
<div class="line">                                   0.)</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::estimate_on_one_cell(</div>
<div class="line">      <span class="keyword">const</span> active_cell_iterator &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">      WeightedResidualScratchData &amp;scratch_data,</div>
<div class="line">      WeightedResidualCopyData &amp;   copy_data,</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;              error_indicators,</div>
<div class="line">      FaceIntegrals &amp;              face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      (void)copy_data;</div>
<div class="line"> </div>
<div class="line">      integrate_over_cell(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                          scratch_data.primal_solution,</div>
<div class="line">                          scratch_data.dual_weights,</div>
<div class="line">                          scratch_data.cell_data,</div>
<div class="line">                          error_indicators);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a> : <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face_indices())</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;at_boundary())</div>
<div class="line">            {</div>
<div class="line">              face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] = 0;</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">if</span> ((<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div>
<div class="line">              (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;level() == <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level()) &amp;&amp;</div>
<div class="line">              (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;index() &lt; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;index()))</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;at_boundary(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>) == <span class="keyword">false</span>)</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;level() &lt; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;level())</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;has_children() == <span class="keyword">false</span>)</div>
<div class="line">            integrate_over_regular_face(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                        <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                        scratch_data.primal_solution,</div>
<div class="line">                                        scratch_data.dual_weights,</div>
<div class="line">                                        scratch_data.face_data,</div>
<div class="line">                                        face_integrals);</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            integrate_over_irregular_face(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">                                          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">                                          scratch_data.primal_solution,</div>
<div class="line">                                          scratch_data.dual_weights,</div>
<div class="line">                                          scratch_data.face_data,</div>
<div class="line">                                          face_integrals);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_cell(</div>
<div class="line">      <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">      <a class="code" href="structCellData.html">CellData</a> &amp;                  cell_data,</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;             error_indicators)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      cell_data.fe_values.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">      cell_data.right_hand_side-&gt;value_list(</div>
<div class="line">        cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);</div>
<div class="line">      cell_data.fe_values.get_function_laplacians(primal_solution,</div>
<div class="line">                                                  cell_data.cell_laplacians);</div>
<div class="line"> </div>
<div class="line">      cell_data.fe_values.get_function_values(dual_weights,</div>
<div class="line">                                              cell_data.dual_weights);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; cell_data.fe_values.n_quadrature_points; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> += ((cell_data.rhs_values[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] + cell_data.cell_laplacians[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">                cell_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * cell_data.fe_values.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line">      error_indicators(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;active_cell_index()) += <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_regular_face(</div>
<div class="line">      <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">      FaceData &amp;                  face_data,</div>
<div class="line">      FaceIntegrals &amp;             face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a> =</div>
<div class="line">        face_data.fe_face_values_cell.n_quadrature_points;</div>
<div class="line"> </div>
<div class="line">      face_data.fe_face_values_cell.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">      face_data.fe_face_values_cell.get_function_gradients(</div>
<div class="line">        primal_solution, face_data.cell_grads);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd">IteratorState::valid</a>,</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_neighbor =</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_of_neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">      <span class="keyword">const</span> active_cell_iterator <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">      face_data.fe_face_values_neighbor.reinit(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>, neighbor_neighbor);</div>
<div class="line">      face_data.fe_face_values_neighbor.get_function_gradients(</div>
<div class="line">        primal_solution, face_data.neighbor_grads);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">        face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] =</div>
<div class="line">          ((face_data.cell_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] - face_data.neighbor_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">           face_data.fe_face_values_cell.normal_vector(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line"> </div>
<div class="line">      face_data.fe_face_values_cell.get_function_values(dual_weights,</div>
<div class="line">                                                        face_data.dual_weights);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> face_integral = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">        face_integral +=</div>
<div class="line">          (face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * face_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] *</div>
<div class="line">           face_data.fe_face_values_cell.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)) != face_integrals.end(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] == -1e20, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"> </div>
<div class="line">      face_integrals[<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)] = face_integral;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> WeightedResidual&lt;dim&gt;::integrate_over_irregular_face(</div>
<div class="line">      <span class="keyword">const</span> active_cell_iterator &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      primal_solution,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dual_weights,</div>
<div class="line">      FaceData &amp;                  face_data,</div>
<div class="line">      FaceIntegrals &amp;             face_integrals)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a> =</div>
<div class="line">        face_data.fe_face_values_cell.n_quadrature_points;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::face_iterator <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a> = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::cell_iterator <a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a> =</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd">IteratorState::valid</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      (void)<a class="code" href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_neighbor =</div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_of_neighbor(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no = 0; subface_no &lt; <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;n_children();</div>
<div class="line">           ++subface_no)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> active_cell_iterator neighbor_child =</div>
<div class="line">            <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;neighbor_child_on_subface(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>, subface_no);</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(neighbor_child-&gt;face(neighbor_neighbor) ==</div>
<div class="line">                   <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;face(<a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>)-&gt;child(subface_no),</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"> </div>
<div class="line">          face_data.fe_subface_values_cell.reinit(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, <a class="code" href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a>, subface_no);</div>
<div class="line">          face_data.fe_subface_values_cell.get_function_gradients(</div>
<div class="line">            primal_solution, face_data.cell_grads);</div>
<div class="line">          face_data.fe_face_values_neighbor.reinit(neighbor_child,</div>
<div class="line">                                                   neighbor_neighbor);</div>
<div class="line">          face_data.fe_face_values_neighbor.get_function_gradients(</div>
<div class="line">            primal_solution, face_data.neighbor_grads);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">            face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] =</div>
<div class="line">              ((face_data.neighbor_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] - face_data.cell_grads[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>]) *</div>
<div class="line">               face_data.fe_face_values_neighbor.normal_vector(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line"> </div>
<div class="line">          face_data.fe_face_values_neighbor.get_function_values(</div>
<div class="line">            dual_weights, face_data.dual_weights);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordtype">double</span> face_integral = 0;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> = 0; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>)</div>
<div class="line">            face_integral +=</div>
<div class="line">              (face_data.jump_residual[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] * face_data.dual_weights[<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>] *</div>
<div class="line">               face_data.fe_face_values_neighbor.JxW(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>));</div>
<div class="line">          face_integrals[neighbor_child-&gt;face(neighbor_neighbor)] =</div>
<div class="line">            face_integral;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no = 0; subface_no &lt; <a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;n_children();</div>
<div class="line">           ++subface_no)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)) !=</div>
<div class="line">                   face_integrals.end(),</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)] != -1e20,</div>
<div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> += face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>-&gt;child(subface_no)];</div>
<div class="line">        }</div>
<div class="line">      face_integrals[<a class="code" href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a>] = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">struct </span>Framework</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> Evaluator     = Evaluation::EvaluationBase&lt;dim&gt;;</div>
<div class="line">    <span class="keyword">using</span> EvaluatorList = std::list&lt;Evaluator *&gt;;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>ProblemDescription</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primal_fe_degree;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dual_fe_degree;</div>
<div class="line"> </div>
<div class="line">      std::unique_ptr&lt;const Data::SetUpBase&lt;dim&gt;&gt; <a class="code" href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">enum</span> RefinementCriterion</div>
<div class="line">      {</div>
<div class="line">        dual_weighted_error_estimator,</div>
<div class="line">        global_refinement,</div>
<div class="line">        kelly_indicator,</div>
<div class="line">        weighted_kelly_indicator</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      RefinementCriterion refinement_criterion;</div>
<div class="line"> </div>
<div class="line">      std::unique_ptr&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;&gt;</div>
<div class="line">        dual_functional;</div>
<div class="line"> </div>
<div class="line">      EvaluatorList evaluator_list;</div>
<div class="line"> </div>
<div class="line">      std::unique_ptr&lt;const Function&lt;dim&gt;&gt; kelly_weight;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degrees_of_freedom;</div>
<div class="line"> </div>
<div class="line">      ProblemDescription();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>(<span class="keyword">const</span> ProblemDescription &amp;<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  Framework&lt;dim&gt;::ProblemDescription::ProblemDescription()</div>
<div class="line">    : primal_fe_degree(1)</div>
<div class="line">    , dual_fe_degree(2)</div>
<div class="line">    , refinement_criterion(dual_weighted_error_estimator)</div>
<div class="line">    , max_degrees_of_freedom(20000)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">Framework&lt;dim&gt;::run</a>(<span class="keyword">const</span> ProblemDescription &amp;<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::smoothing_on_refinement</a>);</div>
<div class="line">    <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;create_coarse_grid(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       primal_fe(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.primal_fe_degree);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       dual_fe(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree + 1);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> - 1&gt; face_quadrature(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree + 1);</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>;</div>
<div class="line">    <span class="keywordflow">switch</span> (<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.refinement_criterion)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">case</span> ProblemDescription::dual_weighted_error_estimator:</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::WeightedResidual&lt;dim&gt;&gt;(</div>
<div class="line">              <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">              primal_fe,</div>
<div class="line">              dual_fe,</div>
<div class="line">              <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">              face_quadrature,</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values(),</div>
<div class="line">              *<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_functional);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">case</span> ProblemDescription::global_refinement:</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div>
<div class="line">              <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">              primal_fe,</div>
<div class="line">              <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">              face_quadrature,</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values());</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">case</span> ProblemDescription::kelly_indicator:</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div>
<div class="line">              <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">              primal_fe,</div>
<div class="line">              <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">              face_quadrature,</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">              <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values());</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">case</span> ProblemDescription::weighted_kelly_indicator:</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a> =</div>
<div class="line">              std::make_unique&lt;LaplaceSolver::RefinementWeightedKelly&lt;dim&gt;&gt;(</div>
<div class="line">                <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                primal_fe,</div>
<div class="line">                <a class="code" href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a>,</div>
<div class="line">                face_quadrature,</div>
<div class="line">                <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_right_hand_side(),</div>
<div class="line">                <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data-&gt;get_boundary_values(),</div>
<div class="line">                *<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.kelly_weight);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> = 0; <span class="keyword">true</span>; ++<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span> &lt;&lt; <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;set_refinement_cycle(<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>);</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;solve_problem();</div>
<div class="line">        <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;output_solution();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom=&quot;</span> &lt;&lt; <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;n_dofs()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;evaluator : <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list)</div>
<div class="line">          {</div>
<div class="line">            evaluator-&gt;set_refinement_cycle(<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>);</div>
<div class="line">            <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;postprocess(*evaluator);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;n_dofs() &lt; <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.max_degrees_of_freedom)</div>
<div class="line">          <a class="code" href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a>-&gt;refine_grid();</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step14</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep14.html">Step14</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> = 2;</div>
<div class="line">      <a class="code" href="structStep14_1_1Framework_1_1ProblemDescription.html">Framework&lt;dim&gt;::ProblemDescription</a> <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.refinement_criterion =</div>
<div class="line">        <a class="code" href="structStep14_1_1Framework_1_1ProblemDescription.html#a853a4e95b17bc2222c7bbb12443827c3a0d6f6c3468a390b4a47c39d27af21454">Framework&lt;dim&gt;::ProblemDescription::dual_weighted_error_estimator</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.primal_fe_degree = 1;</div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_fe_degree   = 2;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.data =</div>
<div class="line">        std::make_unique&lt;Data::SetUp&lt;Data::Exercise_2_3&lt;dim&gt;, <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point(0.75, 0.75);</div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.dual_functional =</div>
<div class="line">        std::make_unique&lt;DualFunctional::PointValueEvaluation&lt;dim&gt;&gt;(</div>
<div class="line">          evaluation_point);</div>
<div class="line"> </div>
<div class="line">      Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(evaluation_point);</div>
<div class="line">      <a class="code" href="classStep14_1_1Evaluation_1_1GridOutput.html">Evaluation::GridOutput&lt;dim&gt;</a>           postprocessor2(<span class="stringliteral">&quot;grid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list.push_back(&amp;postprocessor1);</div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.evaluator_list.push_back(&amp;postprocessor2);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>.max_degrees_of_freedom = 20000;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="structStep14_1_1Framework.html#a74f3b5723c4afa3c177e3d6718309321">Framework&lt;dim&gt;::run</a>(<a class="code" href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 This tutorial depends on <a class="el" href="step_13.html">step-13</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Themaths">The maths</a><a href="#Themaths">The maths</a>
        <li><a href="#Thesoftware">The software</a><a href="#Thesoftware">The software</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Evaluatingthesolution">Evaluating the solution</a><a href="#Evaluatingthesolution">Evaluating the solution</a>
      <ul>
        <li><a href="#TheEvaluationBaseclass">The EvaluationBase class</a><a href="#TheEvaluationBaseclass">The EvaluationBase class</a>
        <li><a href="#ThePointValueEvaluationclass">The PointValueEvaluation class</a><a href="#ThePointValueEvaluationclass">The PointValueEvaluation class</a>
        <li><a href="#ThePointXDerivativeEvaluationclass">The PointXDerivativeEvaluation class</a><a href="#ThePointXDerivativeEvaluationclass">The PointXDerivativeEvaluation class</a>
        <li><a href="#TheGridOutputclass">The GridOutput class</a><a href="#TheGridOutputclass">The GridOutput class</a>
      </ul>
        <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a><a href="#TheLaplacesolverclasses">The Laplace solver classes</a>
      <ul>
        <li><a href="#TheLaplacesolverbaseclass">The Laplace solver base class</a><a href="#TheLaplacesolverbaseclass">The Laplace solver base class</a>
        <li><a href="#TheLaplaceSolverclass">The Laplace Solver class</a><a href="#TheLaplaceSolverclass">The Laplace Solver class</a>
        <li><a href="#ThePrimalSolverclass">The PrimalSolver class</a><a href="#ThePrimalSolverclass">The PrimalSolver class</a>
        <li><a href="#TheRefinementGlobalandRefinementKellyclasses">The RefinementGlobal and RefinementKelly classes</a><a href="#TheRefinementGlobalandRefinementKellyclasses">The RefinementGlobal and RefinementKelly classes</a>
        <li><a href="#TheRefinementWeightedKellyclass">The RefinementWeightedKelly class</a><a href="#TheRefinementWeightedKellyclass">The RefinementWeightedKelly class</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#TheSetUpBaseandSetUpclasses">The SetUpBase and SetUp classes</a><a href="#TheSetUpBaseandSetUpclasses">The SetUpBase and SetUp classes</a>
        <li><a href="#TheCurvedRidgesclass">The CurvedRidges class</a><a href="#TheCurvedRidgesclass">The CurvedRidges class</a>
        <li><a href="#TheExercise_2_3class">The Exercise_2_3 class</a><a href="#TheExercise_2_3class">The Exercise_2_3 class</a>
        <li><a href="#Discussion">Discussion</a><a href="#Discussion">Discussion</a>
      </ul>
        <li><a href="#Dualfunctionals">Dual functionals</a><a href="#Dualfunctionals">Dual functionals</a>
      <ul>
        <li><a href="#TheDualFunctionalBaseclass">The DualFunctionalBase class</a><a href="#TheDualFunctionalBaseclass">The DualFunctionalBase class</a>
        <li><a href="#ThedualfunctionalPointValueEvaluationclass">The dual functional PointValueEvaluation class</a><a href="#ThedualfunctionalPointValueEvaluationclass">The dual functional PointValueEvaluation class</a>
        <li><a href="#ThedualfunctionalPointXDerivativeEvaluationclass">The dual functional PointXDerivativeEvaluation class</a><a href="#ThedualfunctionalPointXDerivativeEvaluationclass">The dual functional PointXDerivativeEvaluation class</a>
      </ul>
        <li><a href="#ExtendingtheLaplaceSolvernamespace">Extending the LaplaceSolver namespace</a><a href="#ExtendingtheLaplaceSolvernamespace">Extending the LaplaceSolver namespace</a>
      <ul>
        <li><a href="#TheDualSolverclass">The DualSolver class</a><a href="#TheDualSolverclass">The DualSolver class</a>
        <li><a href="#TheWeightedResidualclass">The WeightedResidual class</a><a href="#TheWeightedResidualclass">The WeightedResidual class</a>
      </ul>
        <li><a href="#Estimatingerrors">Estimating errors</a><a href="#Estimatingerrors">Estimating errors</a>
      <ul>
        <li><a href="#Errorestimationdriverfunctions">Error estimation driver functions</a><a href="#Errorestimationdriverfunctions">Error estimation driver functions</a>
        <li><a href="#Estimatingonasinglecell">Estimating on a single cell</a><a href="#Estimatingonasinglecell">Estimating on a single cell</a>
        <li><a href="#Computingcelltermerrorcontributions">Computing cell term error contributions</a><a href="#Computingcelltermerrorcontributions">Computing cell term error contributions</a>
        <li><a href="#Computingedgetermerrorcontributions1">Computing edge term error contributions &mdash; 1</a><a href="#Computingedgetermerrorcontributions1">Computing edge term error contributions &mdash; 1</a>
        <li><a href="#Computingedgetermerrorcontributions2">Computing edge term error contributions &mdash; 2</a><a href="#Computingedgetermerrorcontributions2">Computing edge term error contributions &mdash; 2</a>
      </ul>
        <li><a href="#Asimulationframework">A simulation framework</a><a href="#Asimulationframework">A simulation framework</a>
        <li><a href="#Themainfunction">The main function</a><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Pointvalues">Point values</a><a href="#Pointvalues">Point values</a>
        <li><a href="#Comparingrefinementcriteria">Comparing refinement criteria</a><a href="#Comparingrefinementcriteria">Comparing refinement criteria</a>
        <li><a href="#Evaluationofpointstresses">Evaluation of point stresses</a><a href="#Evaluationofpointstresses">Evaluation of point stresses</a>
        <li><a href="#step13revisited">@ref step_13 "step-13" revisited</a><a href="#step13revisited">@ref step_13 "step-13" revisited</a>
        <li><a href="#Conclusionsandoutlook">Conclusions and outlook</a><a href="#Conclusionsandoutlook">Conclusions and outlook</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Themaths"></a></p><h3>The maths</h3>
<p>The Heidelberg group of Professor Rolf Rannacher, to which the three initialauthors of the deal.II library belonged during their PhD time and partly alsoafterwards, has been involved with adaptivity and error estimation for finiteelement discretizations since the mid-1990ies. The main achievement is thedevelopment of error estimates for arbitrary functionals of the solution, andof optimal mesh refinement for its computation. We will not discuss the derivation of these concepts in too great detail, butwill implement the main ideas in the present example program. For a thoroughintroduction into the general idea, we refer to the seminal work of Becker andRannacher <b>[BR95]</b> , <b>[BR96r]</b> , and the overview article of the same authors inActa Numerica <b>[BR01]</b> ; the first introduces the concept of errorestimation and adaptivity for general functional output for the Laplaceequation, while the second gives many examples of applications of theseconcepts to a large number of other, more complicated equations. Forapplications to individual types of equations, see also the publications byBecker <b>[Bec95]</b> , <b>[Bec98]</b> , Kanschat <b>[Kan96]</b> , <b>[FK97]</b> , Suttmeier <b>[Sut96]</b> , <b>[RS97]</b> , <b>[RS98c]</b> , <b>[RS99]</b> , Bangerth <b>[BR99b]</b> , <b>[Ban00w]</b> , <b>[BR01a]</b> , <b>[Ban02]</b> , and Hartmann <b>[Har02]</b> , <b>[HH01]</b> , <b>[HH01b]</b> . All of these works, from the original introduction by Becker andRannacher to individual contributions to particular equations, have later beensummarized in a book by Bangerth and Rannacher that covers all of these topics,see <b>[BR03]</b> .</p>
<p>The basic idea is the following: in applications, one is not usuallyinterested in the solution per se, but rather in certain aspects of it. Forexample, in simulations of flow problems, one may want to know the lift ordrag of a body immersed in the fluid; it is this quantity that we want to knowto best accuracy, and whether the rest of the solution of the describingequations is well resolved is not of primary interest. Likewise, in elasticityone might want to know about values of the stress at certain points to guesswhether maximal load values of joints are safe, for example. Or, in radiativetransfer problems, mean flux intensities are of interest. In all the cases just listed, it is the evaluation of a functional \(J(u)\) ofthe solution which we are interested in, rather than the values of \(u\) everywhere. Since the exact solution \(u\) is not available, but only itsnumerical approximation \(u_h\) , it is sensible to ask whether the computedvalue \(J(u_h)\) is within certain limits of the exact value \(J(u)\) , i.e. wewant to bound the error with respect to this functional, \(J(u)-J(u_h)\) . For simplicity of exposition, we henceforth assume that both the quantity ofinterest \(J\) , as well as the equation are linear, and we will in particularshow the derivation for the Laplace equation with homogeneous Dirichletboundary conditions, although the concept is much more general. For thisgeneral case, we refer to the references listed above. The goal is to obtainbounds on the error, \(J(e)=J(u)-J(u_h)\) . For this, let us denote by \(z\) thesolution of a dual problem, defined as follows: </p><p class="formulaDsp">
\[ a(\varphi,z) = J(\varphi) \qquad \forall \varphi, \]
</p>
<p>@_fakenlwhere \(a(\cdot,\cdot)\) is the bilinear form associated with the differentialequation, and the test functions are chosen from the corresponding solutionspace. Then, taking as special test function \(\varphi=e\) the error, we havethat </p><p class="formulaDsp">
\[ J(e) = a(e,z) \]
</p>
<p>@_fakenland we can, by Galerkin orthogonality, rewrite this as </p><p class="formulaDsp">
\[ J(e) = a(e,z-\varphi_h) \]
</p>
<p>@_fakenlwhere \(\varphi_h\) can be chosen from the discrete test space inwhatever way we find convenient. Concretely, for Laplace's equation, the error identity reads </p><p class="formulaDsp">
\[ J(e) = (\nabla e, \nabla(z-\varphi_h)). \]
</p>
<p>@_fakenlBecause we want to use this formula not only to compute error, butalso to refine the mesh, we need to rewrite the expression above as asum over cells where each cell's contribution can then be used as anerror indicator for this cell.Thus, we split the scalar products into terms for each cell, andintegrate by parts on each of them: </p><p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (\nabla (u-u_h), \nabla (z-\varphi_h))_K \\ &amp;=&amp; \sum_K (-\Delta (u-u_h), z-\varphi_h)_K + (\partial_n (u-u_h), z-z_h)_{\partial K}. \end{eqnarray*}
</p>
<p> Next we use that \(-\Delta u=f\) , and that for solutions of the Laplaceequation, the solution is smooth enough that \(\partial_n u\) iscontinuous almost everywhere</p>
<ul>
<li>so the terms involving \(\partial_n u\) on onecell cancels with that on its neighbor, where the normal vector has theopposite sign. (The same is not true for \(\partial_n u_h\) , though.)At the boundary of the domain, where there is no neighbor cellwith which this term could cancel, the weight \(z-\varphi_h\) can be chosen aszero, and the whole term disappears. Thus, we have <p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-\varphi_h)_K - (\partial_n u_h, z-\varphi_h)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
 In a final step, note that when taking the normal derivative of \(u_h\) , we meanthe value of this quantity as taken from this side of the cell (for the usualLagrange elements, derivatives are not continuous across edges). We thenrewrite the above formula by exchanging half of the edge integral of cell \(K\) with the neighbor cell \(K&#39;\) , to obtain <p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-\varphi_h)_K - \frac 12 (\partial_n u_h|_K + \partial_{n&#39;} u_h|_{K&#39;}, z-\varphi_h)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
 Using that for the normal vectors on adjacent cells we have \(n&#39;=-n\) , we define the jump of thenormal derivative by <p class="formulaDsp">
\[ [\partial_n u_h] \dealcoloneq \partial_n u_h|_K + \partial_{n&#39;} u_h|_{K&#39;} = \partial_n u_h|_K - \partial_n u_h|_{K&#39;}, \]
</p>
@_fakenland get the final form after setting the discrete function \(\varphi_h\) , whichis by now still arbitrary, to the point interpolation of the dual solution, \(\varphi_h=I_h z\) : <p class="formulaDsp">
\begin{eqnarray*} J(e) &amp;=&amp; \sum_K (f+\Delta u_h, z-I_h z)_K - \frac 12 ([\partial_n u_h], z-I_h z)_{\partial K\backslash \partial\Omega}. \end{eqnarray*}
</p>
</li>
</ul>
<p>With this, we have obtained an exact representation of the error of the finiteelement discretization with respect to arbitrary (linear) functionals \(J(\cdot)\) . Its structure is a weighted form of a residual estimator, as both \(f+\Delta u_h\) and \([\partial_n u_h]\) are cell and edge residuals that vanishon the exact solution, and \(z-I_h z\) are weights indicating how important theresiduals on a certain cell is for the evaluation of the given functional.Furthermore, it is a cell-wise quantity, so we can use it as a mesh refinementcriterion. The question, is: how to evaluate it? After all, the evaluationrequires knowledge of the dual solution \(z\) , which carries the informationabout the quantity we want to know to best accuracy. In some, very special cases, this dual solution is known. For example, if thefunctional \(J(\cdot)\) is the point evaluation, \(J(\varphi)=\varphi(x_0)\) , thenthe dual solution has to satisfy </p><p class="formulaDsp">
\[ -\Delta z = \delta(x-x_0), \]
</p>
<p>@_fakenlwith the Dirac delta function on the right hand side, and the dual solution isthe Green's function with respect to the point \(x_0\) . For simple geometries,this function is analytically known, and we could insert it into the errorrepresentation formula. However, we do not want to restrict ourselves to such special cases. Rather,we will compute the dual solution numerically, and approximate \(z\) by somenumerically obtained \(\tilde z\) . We note that it is not sufficient to computethis approximation \(\tilde z\) using the same method as used for the primalsolution \(u_h\) , since then \(\tilde z-I_h \tilde z=0\) , and the overall errorestimate would be zero. Rather, the approximation \(\tilde z\) has to be from alarger space than the primal finite element space. There are various ways toobtain such an approximation (see the cited literature), and we will choose tocompute it with a higher order finite element space. While this is certainlynot the most efficient way, it is simple since we already have all we need todo that in place, and it also allows for simple experimenting. For moreefficient methods, again refer to the given literature, in particular <b>[BR95]</b> , <b>[BR03]</b> . With this, we end the discussion of the mathematical side of this program andturn to the actual implementation.</p>
<pre class="fragment">@note   There are two steps above that do not seem necessary if all youcare about is computing the error: namely, (i) the subtraction of  @f$\phi_h@f$   from   @f$z@f$  , and (ii) splitting the integral into a sum of cellsand integrating by parts on each. Indeed, neither of these two stepschange   @f$J(e)@f$   at all, as we only ever consider identities above untilthe substitution of   @f$z@f$   by   @f$\tilde z@f$  . In other words, if you careonly about &lt;i&gt;estimating the global error&lt;/i&gt;   @f$J(e)@f$  , then these stepsare not necessary. On the other hand, if you want to use the errorestimate also as a refinement criterion for each cell of the mesh,then it is necessary to (i) break the estimate into a sum of cells,and (ii) massage the formulas in such a way that each cell'scontributions have something to do with the local error. (While thecontortions above do not change the value of the &lt;i&gt;sum&lt;/i&gt;   @f$J(e)@f$  ,they change the values we compute for each cell   @f$K@f$  .) To this end, wewant to write everything in the form "residual times dual weight"where a "residual" is something that goes to zero as the approximationbecomes   @f$u_h@f$   better and better. For example, the quantity   @f$\partial_n
</pre><p> u_h \( is not a residual, since it simply converges to the (normalcomponent of) the gradient of the exact solution. On the other hand, \)[\partial_n u_h] \( is a residual because it converges to \)[\partial_n u]=0 \( . All of the steps we have taken above in developing the finalform of \)J(e) \( have indeed had the goal of bringing the final formulainto a form where each term converges to zero as the discrete solution \)u_h \( converges to \)u \( . This then allows considering each cell&#39;scontribution as an &quot;error indicator&quot; that also converges to zero - asit should as the mesh is refined. &lt;a name=&quot;Thesoftware&quot;&gt;&lt;/a&gt;&lt;h3&gt;The software&lt;/h3&gt; The @ref step_14 &quot;step-14&quot; example program builds heavily on the techniques already used inthe @ref step_13 &quot;step-13&quot; program. Its implementation of the dual weighted residual errorestimator explained above is done by deriving a second class, properly called &lt;code&gt;DualSolver&lt;/code&gt;, from the &lt;code&gt;Solver&lt;/code&gt; base class, and having a class( &lt;code&gt;WeightedResidual&lt;/code&gt; ) that joins the two again and controls the solutionof the primal and dual problem, and then uses both to compute the errorindicator for mesh refinement. The program continues the modular concept of the previous example, byimplementing the dual functional, describing quantity of interest, by anabstract base class, and providing two different functionals which implementthis interface. Adding a different quantity of interest is thus simple. One of the more fundamental differences is the handling of data. A common caseis that you develop a program that solves a certain equation, and test it withdifferent right hand sides, different domains, different coefficients andboundary values, etc. Usually, these have to match, so that exact solutionsare known, or that their combination makes sense at all. We demonstrate a way how this can be achieved in a simple, yet very flexibleway. We will put everything that belongs to a certain setup into one class,and provide a little C++ mortar around it, so that entire setups (domains,coefficients, right hand sides, etc.) can be exchanged by only changingsomething in &lt;em&gt; one &lt;/em&gt; place. Going this way a little further, we have also centralized all the otherparameters that describe how the program is to work in one place, such as theorder of the finite element, the maximal number of degrees of freedom, theevaluation objects that shall be executed on the computed solutions, and soon. This allows for simpler configuration of the program, and we will show ina later program how to use a library class that can handle setting theseparameters by reading an input file. The general aim is to reduce the placeswithin a program where one may have to look when wanting to change someparameter, as it has turned out in practice that one forgets where they are asprograms grow. Furthermore, putting all options describing what the programdoes in a certain run into a file (that can be stored with the results) helpsrepeatability of results more than if the various flags were set somewhere inthe program, where their exact values are forgotten after the next change tothis place. Unfortunately, the program has become rather long. While this admittedlyreduces its usefulness as an example program, we think that it is a very goodstarting point for development of a program for other kinds of problems,involving different equations than the Laplace equation treated here.Furthermore, it shows everything that we can show you about our way of aposteriori error estimation, and its structure should make it simple for youto adjust this method to other problems, other functionals, other geometries,coefficients, etc. The author believes that the present program is his masterpiece among theexample programs, regarding the mathematical complexity, as well as thesimplicity to add extensions. If you use this program as a basis for your ownprograms, we would kindly like to ask you to state this fact and the name ofthe author of the example program, Wolfgang Bangerth, in publications thatarise from that, of your program consists in a considerable part of theexample program. &lt;a name=&quot;CommProg&quot;&gt;&lt;/a&gt; &lt;h1&gt; The commented program&lt;/h1&gt; Start out with well known things... @code #include &lt;deal.II/base/quadrature_lib.h&gt; #include &lt;deal.II/base/function.h&gt; #include &lt;deal.II/base/logstream.h&gt; #include &lt;deal.II/base/thread_management.h&gt; #include &lt;deal.II/base/work_stream.h&gt; #include &lt;deal.II/lac/vector.h&gt; #include &lt;deal.II/lac/full_matrix.h&gt; #include &lt;deal.II/lac/sparse_matrix.h&gt; #include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt; #include &lt;deal.II/lac/solver_cg.h&gt; #include &lt;deal.II/lac/precondition.h&gt; #include &lt;deal.II/lac/affine_constraints.h&gt; #include &lt;deal.II/grid/tria.h&gt; #include &lt;deal.II/grid/grid_generator.h&gt; #include &lt;deal.II/grid/grid_out.h&gt; #include &lt;deal.II/grid/grid_refinement.h&gt; #include &lt;deal.II/dofs/dof_handler.h&gt; #include &lt;deal.II/dofs/dof_tools.h&gt; #include &lt;deal.II/fe/fe_q.h&gt; #include &lt;deal.II/fe/fe_values.h&gt; #include &lt;deal.II/fe/fe_tools.h&gt; #include &lt;deal.II/numerics/vector_tools.h&gt; #include &lt;deal.II/numerics/matrix_tools.h&gt; #include &lt;deal.II/numerics/data_out.h&gt; #include &lt;deal.II/numerics/error_estimator.h&gt; #include &lt;algorithm&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;numeric&gt; @endcode The last step is as in all previous programs: @code namespace Step14 { using namespace dealii; @endcode &lt;a name=&quot;Evaluatingthesolution&quot;&gt;&lt;/a&gt; &lt;h3&gt;Evaluating the solution&lt;/h3&gt; As mentioned in the introduction, significant parts of the program have simply been taken over from the @ref step_13 &quot;step-13&quot; example program. We therefore only comment on those things that are new. First, the framework for evaluation of solutions is unchanged, i.e. the base class is the same, and the class to evaluate the solution at a grid point is unchanged: @code namespace Evaluation { @endcode &lt;a name=&quot;TheEvaluationBaseclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The EvaluationBase class&lt;/h4&gt; @code template &lt;int dim&gt; class EvaluationBase { public: virtual ~EvaluationBase() = default; void set_refinement_cycle(const unsigned int refinement_cycle); virtual void operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const = 0; protected: unsigned int refinement_cycle; }; template &lt;int dim&gt; void EvaluationBase&lt;dim&gt;::set_refinement_cycle(const unsigned int step) { refinement_cycle = step; } @endcode &lt;a name=&quot;ThePointValueEvaluationclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The PointValueEvaluation class&lt;/h4&gt; @code template &lt;int dim&gt; class PointValueEvaluation : public EvaluationBase&lt;dim&gt; { public: PointValueEvaluation(const Point&lt;dim&gt; &amp;evaluation_point); virtual void operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const override; DeclException1( ExcEvaluationPointNotFound, Point&lt;dim&gt;, &lt;&lt; &quot;The evaluation point &quot; &lt;&lt; arg1 &lt;&lt; &quot; was not found among the vertices of the present grid.&quot;); private: const Point&lt;dim&gt; evaluation_point; }; template &lt;int dim&gt; PointValueEvaluation&lt;dim&gt;::PointValueEvaluation( const Point&lt;dim&gt; &amp;evaluation_point) : evaluation_point(evaluation_point) {} template &lt;int dim&gt; void PointValueEvaluation&lt;dim&gt;:: operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const { double point_value = 1e20; bool evaluation_point_found = false; for (const auto &amp;cell : dof_handler.active_cell_iterators()) if (!evaluation_point_found) for (const auto vertex : cell-&gt;vertex_indices()) if (cell-&gt;vertex(vertex).distance(evaluation_point) &lt; cell-&gt;diameter() 1e-8) { point_value = solution(cell-&gt;vertex_dof_index(vertex, 0)); evaluation_point_found = true; break; } AssertThrow(evaluation_point_found, ExcEvaluationPointNotFound(evaluation_point)); std::cout &lt;&lt; &quot; Point value=&quot; &lt;&lt; point_value &lt;&lt; std::endl; } @endcode &lt;a name=&quot;ThePointXDerivativeEvaluationclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The PointXDerivativeEvaluation class&lt;/h4&gt; Besides the class implementing the evaluation of the solution at one point, we here provide one which evaluates the gradient at a grid point. Since in general the gradient of a finite element function is not continuous at a vertex, we have to be a little bit more careful here. What we do is to loop over all cells, even if we have found the point already on one cell, and use the mean value of the gradient at the vertex taken from all adjacent cells. Given the interface of the &lt;code&gt;PointValueEvaluation&lt;/code&gt; class, the declaration of this class provides little surprise, and neither does the constructor: @code template &lt;int dim&gt; class PointXDerivativeEvaluation : public EvaluationBase&lt;dim&gt; { public: PointXDerivativeEvaluation(const Point&lt;dim&gt; &amp;evaluation_point); virtual void operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const; DeclException1( ExcEvaluationPointNotFound, Point&lt;dim&gt;, &lt;&lt; &quot;The evaluation point &quot; &lt;&lt; arg1 &lt;&lt; &quot; was not found among the vertices of the present grid.&quot;); private: const Point&lt;dim&gt; evaluation_point; }; template &lt;int dim&gt; PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation( const Point&lt;dim&gt; &amp;evaluation_point) : evaluation_point(evaluation_point) {} @endcode The more interesting things happen inside the function doing the actual evaluation: @code template &lt;int dim&gt; void PointXDerivativeEvaluation&lt;dim&gt;:: operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const { @endcode This time initialize the return value with something useful, since we will have to add up a number of contributions and take the mean value afterwards... @code double point_derivative = 0; @endcode ...then have some objects of which the meaning will become clear below... @code QTrapezoid&lt;dim&gt; vertex_quadrature; FEValues&lt;dim&gt; fe_values(dof_handler.get_fe(), vertex_quadrature, update_gradients | update_quadrature_points); std::vector&lt;Tensor&lt;1, dim&gt;&gt; solution_gradients(vertex_quadrature.size()); @endcode ...and next loop over all cells and their vertices, and count how often the vertex has been found: @code unsigned int evaluation_point_hits = 0; for (const auto &amp;cell : dof_handler.active_cell_iterators()) for (const auto vertex : cell-&gt;vertex_indices()) if (cell-&gt;vertex(vertex) == evaluation_point) { @endcode Things are now no more as simple, since we can&#39;t get the gradient of the finite element field as before, where we simply had to pick one degree of freedom at a vertex. Rather, we have to evaluate the finite element field on this cell, and at a certain point. As you know, evaluating finite element fields at certain points is done through the &lt;code&gt;FEValues&lt;/code&gt; class, so we use that. The question is: the &lt;code&gt;FEValues&lt;/code&gt; object needs to be a given a quadrature formula and can then compute the values of finite element quantities at the quadrature points. Here, we don&#39;t want to do quadrature, we simply want to specify some points! Nevertheless, the same way is chosen: use a special quadrature rule with points at the vertices, since these are what we are interested in. The appropriate rule is the trapezoidal rule, so that is the reason why we used that one above. Thus: initialize the &lt;code&gt;FEValues&lt;/code&gt; object on this cell, @code fe_values.reinit(cell); @endcode and extract the gradients of the solution vector at the vertices: @code fe_values.get_function_gradients(solution, solution_gradients); @endcode Now we have the gradients at all vertices, so pick out that one which belongs to the evaluation point (note that the order of vertices is not necessarily the same as that of the quadrature points): @code unsigned int q_point = 0; for (; q_point &lt; solution_gradients.size(); ++q_point) if (fe_values.quadrature_point(q_point) == evaluation_point) break; @endcode Check that the evaluation point was indeed found, @code Assert(q_point &lt; solution_gradients.size(), ExcInternalError()); @endcode and if so take the x-derivative of the gradient there as the value which we are interested in, and increase the counter indicating how often we have added to that variable: @code point_derivative += solution_gradients[q_point][0]; ++evaluation_point_hits; @endcode Finally break out of the innermost loop iterating over the vertices of the present cell, since if we have found the evaluation point at one vertex it cannot be at a following vertex as well: @code break; } @endcode Now we have looped over all cells and vertices, so check whether the point was found: @code AssertThrow(evaluation_point_hits &gt; 0, ExcEvaluationPointNotFound(evaluation_point)); @endcode We have simply summed up the contributions of all adjacent cells, so we still have to compute the mean value. Once this is done, report the status: @code point_derivative /= evaluation_point_hits; std::cout &lt;&lt; &quot; Point x-derivative=&quot; &lt;&lt; point_derivative &lt;&lt; std::endl; } @endcode &lt;a name=&quot;TheGridOutputclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The GridOutput class&lt;/h4&gt; Since this program has a more difficult structure (it computed a dual solution in addition to a primal one), writing out the solution is no more done by an evaluation object since we want to write both solutions at once into one file, and that requires some more information than available to the evaluation classes. However, we also want to look at the grids generated. This again can be done with one such class. Its structure is analog to the &lt;code&gt;SolutionOutput&lt;/code&gt; class of the previous example program, so we do not discuss it here in more detail. Furthermore, everything that is used here has already been used in previous example programs. @code template &lt;int dim&gt; class GridOutput : public EvaluationBase&lt;dim&gt; { public: GridOutput(const std::string &amp;output_name_base); virtual void operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; solution) const override; private: const std::string output_name_base; }; template &lt;int dim&gt; GridOutput&lt;dim&gt;::GridOutput(const std::string &amp;output_name_base) : output_name_base(output_name_base) {} template &lt;int dim&gt; void GridOutput&lt;dim&gt;::operator()(const DoFHandler&lt;dim&gt; &amp;dof_handler, const Vector&lt;double&gt; &amp; /*solution*/ ) const { std::ofstream out(output_name_base + &quot;-&quot; + std::to_string(this-&gt;refinement_cycle) + &quot;.svg&quot;); GridOut().write_svg(dof_handler.get_triangulation(), out); } } // namespace Evaluation @endcode &lt;a name=&quot;TheLaplacesolverclasses&quot;&gt;&lt;/a&gt; &lt;h3&gt;The Laplace solver classes&lt;/h3&gt; Next are the actual solver classes. Again, we discuss only the differences to the previous program. @code namespace LaplaceSolver { @endcode &lt;a name=&quot;TheLaplacesolverbaseclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The Laplace solver base class&lt;/h4&gt; This class is almost unchanged, with the exception that it declares two more functions: &lt;code&gt;output_solution&lt;/code&gt; will be used to generate output files from the actual solutions computed by derived classes, and the &lt;code&gt;set_refinement_cycle&lt;/code&gt; function by which the testing framework sets the number of the refinement cycle to a local variable in this class; this number is later used to generate filenames for the solution output. @code template &lt;int dim&gt; class Base { public: Base(Triangulation&lt;dim&gt; &amp;coarse_grid); virtual ~Base() = default; virtual void solve_problem() = 0; virtual void postprocess( const Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) const = 0; virtual void refine_grid() = 0; virtual unsigned int n_dofs() const = 0; virtual void set_refinement_cycle(const unsigned int cycle); virtual void output_solution() const = 0; protected: const SmartPointer&lt;Triangulation&lt;dim&gt;&gt; triangulation; unsigned int refinement_cycle; }; template &lt;int dim&gt; Base&lt;dim&gt;::Base(Triangulation&lt;dim&gt; &amp;coarse_grid) : triangulation(&amp;coarse_grid) , refinement_cycle(numbers::invalid_unsigned_int) {} template &lt;int dim&gt; void Base&lt;dim&gt;::set_refinement_cycle(const unsigned int cycle) { refinement_cycle = cycle; } @endcode &lt;a name=&quot;TheLaplaceSolverclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The Laplace Solver class&lt;/h4&gt; Likewise, the &lt;code&gt;Solver&lt;/code&gt; class is entirely unchanged and will thus not be discussed. @code template &lt;int dim&gt; class Solver : public virtual Base&lt;dim&gt; { public: Solver(Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; boundary_values); virtual ~Solver() override; virtual void solve_problem() override; virtual void postprocess( const Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) const override; virtual unsigned int n_dofs() const override; protected: const SmartPointer&lt;const FiniteElement&lt;dim&gt;&gt; fe; const SmartPointer&lt;const Quadrature&lt;dim&gt;&gt; quadrature; const SmartPointer&lt;const Quadrature&lt;dim - 1&gt;&gt; face_quadrature; DoFHandler&lt;dim&gt; dof_handler; Vector&lt;double&gt; solution; const SmartPointer&lt;const Function&lt;dim&gt;&gt; boundary_values; virtual void assemble_rhs(Vector&lt;double&gt; &amp;rhs) const = 0; private: struct LinearSystem { LinearSystem(const DoFHandler&lt;dim&gt; &amp;dof_handler); void solve(Vector&lt;double&gt; &amp;solution) const; AffineConstraints&lt;double&gt; hanging_node_constraints; SparsityPattern sparsity_pattern; SparseMatrix&lt;double&gt; matrix; Vector&lt;double&gt; rhs; }; @endcode The remainder of the class is essentially a copy of @ref step_13 &quot;step-13&quot; as well, including the data structures and functions necessary to compute the linear system in parallel using the WorkStream framework: @code struct AssemblyScratchData { AssemblyScratchData(const FiniteElement&lt;dim&gt; &amp;fe, const Quadrature&lt;dim&gt; &amp; quadrature); AssemblyScratchData(const AssemblyScratchData &amp;scratch_data); FEValues&lt;dim&gt; fe_values; }; struct AssemblyCopyData { FullMatrix&lt;double&gt; cell_matrix; std::vector&lt;types::global_dof_index&gt; local_dof_indices; }; void assemble_linear_system(LinearSystem &amp;linear_system); void local_assemble_matrix( const typename DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell, AssemblyScratchData &amp; scratch_data, AssemblyCopyData &amp; copy_data) const; void copy_local_to_global(const AssemblyCopyData &amp;copy_data, LinearSystem &amp; linear_system) const; }; template &lt;int dim&gt; Solver&lt;dim&gt;::Solver(Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; boundary_values) : Base&lt;dim&gt;(triangulation) , fe(&amp;fe) , quadrature(&amp;quadrature) , face_quadrature(&amp;face_quadrature) , dof_handler(triangulation) , boundary_values(&amp;boundary_values) {} template &lt;int dim&gt; Solver&lt;dim&gt;::~Solver() { dof_handler.clear(); } template &lt;int dim&gt; void Solver&lt;dim&gt;::solve_problem() { dof_handler.distribute_dofs(*fe); solution.reinit(dof_handler.n_dofs()); LinearSystem linear_system(dof_handler); assemble_linear_system(linear_system); linear_system.solve(solution); } template &lt;int dim&gt; void Solver&lt;dim&gt;::postprocess( const Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) const { postprocessor(dof_handler, solution); } template &lt;int dim&gt; unsigned int Solver&lt;dim&gt;::n_dofs() const { return dof_handler.n_dofs(); } @endcode The following few functions and constructors are verbatim copies taken from @ref step_13 &quot;step-13&quot; : @code template &lt;int dim&gt; void Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system) { Threads::Task&lt;void&gt; rhs_task = Threads::new_task(&amp;Solver&lt;dim&gt;::assemble_rhs,this, linear_system.rhs); auto worker = [this](const typename DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell, AssemblyScratchData &amp;scratch_data, AssemblyCopyData &amp; copy_data) { this-&gt;local_assemble_matrix(cell, scratch_data, copy_data); }; auto copier = [this, &amp;linear_system](const AssemblyCopyData &amp;copy_data) { this-&gt;copy_local_to_global(copy_data, linear_system); }; WorkStream::run(dof_handler.begin_active(), dof_handler.end(), worker, copier, AssemblyScratchData(*fe,quadrature), AssemblyCopyData()); linear_system.hanging_node_constraints.condense(linear_system.matrix); std::map&lt;types::global_dof_index, double&gt; boundary_value_map; VectorTools::interpolate_boundary_values(dof_handler, 0, boundary_values, boundary_value_map); rhs_task.join(); linear_system.hanging_node_constraints.condense(linear_system.rhs); MatrixTools::apply_boundary_values(boundary_value_map, linear_system.matrix, solution, linear_system.rhs); } template &lt;int dim&gt; Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData( const FiniteElement&lt;dim&gt; &amp;fe, const Quadrature&lt;dim&gt; &amp; quadrature) : fe_values(fe, quadrature, update_gradients | update_JxW_values) {} template &lt;int dim&gt; Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData( const AssemblyScratchData &amp;scratch_data) : fe_values(scratch_data.fe_values.get_fe(), scratch_data.fe_values.get_quadrature(), update_gradients | update_JxW_values) {} template &lt;int dim&gt; void Solver&lt;dim&gt;::local_assemble_matrix( const typename DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell, AssemblyScratchData &amp; scratch_data, AssemblyCopyData &amp; copy_data) const { const unsigned int dofs_per_cell = fe-&gt;n_dofs_per_cell(); const unsigned int n_q_points = quadrature-&gt;size(); copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell); copy_data.local_dof_indices.resize(dofs_per_cell); scratch_data.fe_values.reinit(cell); for (unsigned int q_point = 0; q_point &lt; n_q_points; ++q_point) for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) for (unsigned int j = 0; j &lt; dofs_per_cell; ++j) copy_data.cell_matrix(i, j) += (scratch_data.fe_values.shape_grad(i, q_point) scratch_data.fe_values.shape_grad(j, q_point) scratch_data.fe_values.JxW(q_point)); cell-&gt;get_dof_indices(copy_data.local_dof_indices); } template &lt;int dim&gt; void Solver&lt;dim&gt;::copy_local_to_global(const AssemblyCopyData &amp;copy_data, LinearSystem &amp;linear_system) const { for (unsigned int i = 0; i &lt; copy_data.local_dof_indices.size(); ++i) for (unsigned int j = 0; j &lt; copy_data.local_dof_indices.size(); ++j) linear_system.matrix.add(copy_data.local_dof_indices[i], copy_data.local_dof_indices[j], copy_data.cell_matrix(i, j)); } @endcode Now for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one thread is generated, we don&#39;t use the &lt;code&gt;Threads::TaskGroup&lt;/code&gt; class here, but rather use the one created task object directly to wait for this particular task&#39;s exit. The approach is generally the same as the one we have used in &lt;code&gt;Solver::assemble_linear_system()&lt;/code&gt; above. Note that taking the address of the &lt;code&gt;DoFTools::make_hanging_node_constraints&lt;/code&gt; function is a little tricky, since there are actually three functions of this name, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator &lt;code&gt;&amp;&lt;/code&gt; in that case returns a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary &lt;code&gt;mhnc_p&lt;/code&gt; (short for &lt;code&gt;pointer to make_hanging_node_constraints&lt;/code&gt;) with the right type, and using this pointer instead. @code template &lt;int dim&gt; Solver&lt;dim&gt;::LinearSystem::LinearSystem(const DoFHandler&lt;dim&gt; &amp;dof_handler) { hanging_node_constraints.clear(); void (*mhnc_p)(const DoFHandler&lt;dim&gt; &amp;, AffineConstraints&lt;double&gt; &amp;) = &amp;DoFTools::make_hanging_node_constraints; @endcode Start a side task then continue on the main thread @code Threads::Task&lt;void&gt; side_task = Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints); DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); DoFTools::make_sparsity_pattern(dof_handler, dsp); @endcode Wait for the side task to be done before going further @code side_task.join(); hanging_node_constraints.close(); hanging_node_constraints.condense(dsp); sparsity_pattern.copy_from(dsp); matrix.reinit(sparsity_pattern); rhs.reinit(dof_handler.n_dofs()); } template &lt;int dim&gt; void Solver&lt;dim&gt;::LinearSystem::solve(Vector&lt;double&gt; &amp;solution) const { SolverControl solver_control(5000, 1e-12); SolverCG&lt;Vector&lt;double&gt;&gt; cg(solver_control); PreconditionSSOR&lt;SparseMatrix&lt;double&gt;&gt; preconditioner; preconditioner.initialize(matrix, 1.2); cg.solve(matrix, solution, rhs, preconditioner); hanging_node_constraints.distribute(solution); } @endcode &lt;a name=&quot;ThePrimalSolverclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The PrimalSolver class&lt;/h4&gt; The &lt;code&gt;PrimalSolver&lt;/code&gt; class is also mostly unchanged except for implementing the &lt;code&gt;output_solution&lt;/code&gt; function. We keep the &lt;code&gt;GlobalRefinement&lt;/code&gt; and &lt;code&gt;RefinementKelly&lt;/code&gt; classes in this program, and they can then rely on the default implementation of this function which simply outputs the primal solution. The class implementing dual weighted error estimators will overload this function itself, to also output the dual solution. @code template &lt;int dim&gt; class PrimalSolver : public Solver&lt;dim&gt; { public: PrimalSolver(Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values); virtual void output_solution() const override; protected: const SmartPointer&lt;const Function&lt;dim&gt;&gt; rhs_function; virtual void assemble_rhs(Vector&lt;double&gt; &amp;rhs) const override; }; template &lt;int dim&gt; PrimalSolver&lt;dim&gt;::PrimalSolver(Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values) : Base&lt;dim&gt;(triangulation) , Solver&lt;dim&gt;(triangulation, fe, quadrature, face_quadrature, boundary_values) , rhs_function(&amp;rhs_function) {} template &lt;int dim&gt; void PrimalSolver&lt;dim&gt;::output_solution() const { DataOut&lt;dim&gt; data_out; data_out.attach_dof_handler(this-&gt;dof_handler); data_out.add_data_vector(this-&gt;solution, &quot;solution&quot;); data_out.build_patches(); std::ofstream out(&quot;solution-&quot; + std::to_string(this-&gt;refinement_cycle) + &quot;.vtu&quot;); data_out.write(out, DataOutBase::vtu); } template &lt;int dim&gt; void PrimalSolver&lt;dim&gt;::assemble_rhs(Vector&lt;double&gt; &amp;rhs) const { FEValues&lt;dim&gt; fe_values(*this-&gt;fe, this-&gt;quadrature, update_values | update_quadrature_points | update_JxW_values); const unsigned int dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell(); const unsigned int n_q_points = this-&gt;quadrature-&gt;size(); Vector&lt;double&gt; cell_rhs(dofs_per_cell); std::vector&lt;double&gt; rhs_values(n_q_points); std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); for (const auto &amp;cell : this-&gt;dof_handler.active_cell_iterators()) { cell_rhs = 0; fe_values.reinit(cell); rhs_function-&gt;value_list(fe_values.get_quadrature_points(), rhs_values); for (unsigned int q_point = 0; q_point &lt; n_q_points; ++q_point) for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) cell_rhs(i) += (fe_values.shape_value(i, q_point) // phi_i(x_q) rhs_values[q_point] // f((x_q) fe_values.JxW(q_point)); // dx cell-&gt;get_dof_indices(local_dof_indices); for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) rhs(local_dof_indices[i]) += cell_rhs(i); } } @endcode &lt;a name=&quot;TheRefinementGlobalandRefinementKellyclasses&quot;&gt;&lt;/a&gt; &lt;h4&gt;The RefinementGlobal and RefinementKelly classes&lt;/h4&gt; For the following two classes, the same applies as for most of the above: the class is taken from the previous example as-is: @code template &lt;int dim&gt; class RefinementGlobal : public PrimalSolver&lt;dim&gt; { public: RefinementGlobal(Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values); virtual void refine_grid() override; }; template &lt;int dim&gt; RefinementGlobal&lt;dim&gt;::RefinementGlobal( Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values) : Base&lt;dim&gt;(coarse_grid) , PrimalSolver&lt;dim&gt;(coarse_grid, fe, quadrature, face_quadrature, rhs_function, boundary_values) {} template &lt;int dim&gt; void RefinementGlobal&lt;dim&gt;::refine_grid() { this-&gt;triangulation-&gt;refine_global(1); } template &lt;int dim&gt; class RefinementKelly : public PrimalSolver&lt;dim&gt; { public: RefinementKelly(Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values); virtual void refine_grid() override; }; template &lt;int dim&gt; RefinementKelly&lt;dim&gt;::RefinementKelly( Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values) : Base&lt;dim&gt;(coarse_grid) , PrimalSolver&lt;dim&gt;(coarse_grid, fe, quadrature, face_quadrature, rhs_function, boundary_values) {} template &lt;int dim&gt; void RefinementKelly&lt;dim&gt;::refine_grid() { Vector&lt;float&gt; estimated_error_per_cell( this-&gt;triangulation-&gt;n_active_cells()); KellyErrorEstimator&lt;dim&gt;::estimate( this-&gt;dof_handler, QGauss&lt;dim - 1&gt;(this-&gt;fe-&gt;degree + 1), std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt;(), this-&gt;solution, estimated_error_per_cell); GridRefinement::refine_and_coarsen_fixed_number(*this-&gt;triangulation, estimated_error_per_cell, 0.3, 0.03); this-&gt;triangulation-&gt;execute_coarsening_and_refinement(); } @endcode &lt;a name=&quot;TheRefinementWeightedKellyclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The RefinementWeightedKelly class&lt;/h4&gt; This class is a variant of the previous one, in that it allows to weight the refinement indicators we get from the library&#39;s Kelly indicator by some function. We include this class since the goal of this example program is to demonstrate automatic refinement criteria even for complex output quantities such as point values or stresses. If we did not solve a dual problem and compute the weights thereof, we would probably be tempted to give a hand-crafted weighting to the indicators to account for the fact that we are going to evaluate these quantities. This class accepts such a weighting function as argument to its constructor: @code template &lt;int dim&gt; class RefinementWeightedKelly : public PrimalSolver&lt;dim&gt; { public: RefinementWeightedKelly(Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values, const Function&lt;dim&gt; &amp; weighting_function); virtual void refine_grid() override; private: const SmartPointer&lt;const Function&lt;dim&gt;&gt; weighting_function; }; template &lt;int dim&gt; RefinementWeightedKelly&lt;dim&gt;::RefinementWeightedKelly( Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values, const Function&lt;dim&gt; &amp; weighting_function) : Base&lt;dim&gt;(coarse_grid) , PrimalSolver&lt;dim&gt;(coarse_grid, fe, quadrature, face_quadrature, rhs_function, boundary_values) , weighting_function(&amp;weighting_function) {} @endcode Now, here comes the main function, including the weighting: @code template &lt;int dim&gt; void RefinementWeightedKelly&lt;dim&gt;::refine_grid() { @endcode First compute some residual based error indicators for all cells by a method already implemented in the library. What exactly we compute here is described in more detail in the documentation of that class. @code Vector&lt;float&gt; estimated_error_per_cell( this-&gt;triangulation-&gt;n_active_cells()); std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt; dummy_function_map; KellyErrorEstimator&lt;dim&gt;::estimate(this-&gt;dof_handler, this-&gt;face_quadrature, dummy_function_map, this-&gt;solution, estimated_error_per_cell); @endcode Next weigh each entry in the vector of indicators by the value of the function given to the constructor, evaluated at the cell center. We need to write the result into the vector entry that corresponds to the current cell, which we can obtain by asking the cell what its index among all active cells is using CellAccessor::active_cell_index(). (In reality, this index is zero for the first cell we handle in the loop, one for the second cell, etc., and we could as well just keep track of this index using an integer counter; but using CellAccessor::active_cell_index() makes this more explicit.) @code for (const auto &amp;cell : this-&gt;dof_handler.active_cell_iterators()) estimated_error_per_cell(cell-&gt;active_cell_index())= weighting_function-&gt;value(cell-&gt;center()); GridRefinement::refine_and_coarsen_fixed_number(*this-&gt;triangulation, estimated_error_per_cell, 0.3, 0.03); this-&gt;triangulation-&gt;execute_coarsening_and_refinement(); } } // namespace LaplaceSolver @endcode &lt;a name=&quot;Equationdata&quot;&gt;&lt;/a&gt; &lt;h3&gt;Equation data&lt;/h3&gt; In this example program, we work with the same data sets as in the previous one, but as it may so happen that someone wants to run the program with different boundary values and right hand side functions, or on a different grid, we show a simple technique to do exactly that. For more clarity, we furthermore pack everything that has to do with equation data into a namespace of its own. The underlying assumption is that this is a research program, and that there we often have a number of test cases that consist of a domain, a right hand side, boundary values, possibly a specified coefficient, and a number of other parameters. They often vary all at the same time when shifting from one example to another. To make handling such sets of problem description parameters simple is the goal of the following. Basically, the idea is this: let us have a structure for each set of data, in which we pack everything that describes a test case: here, these are two subclasses, one called &lt;code&gt;BoundaryValues&lt;/code&gt; for the boundary values of the exact solution, and one called &lt;code&gt;RightHandSide&lt;/code&gt; , and then a way to generate the coarse grid. Since the solution of the previous example program looked like curved ridges, we use this name here for the enclosing class. Note that the names of the two inner classes have to be the same for all enclosing test case classes, and also that we have attached the dimension template argument to the enclosing class rather than to the inner ones, to make further processing simpler. (From a language viewpoint, a namespace would be better to encapsulate these inner classes, rather than a structure. However, namespaces cannot be given as template arguments, so we use a structure to allow a second object to select from within its given argument. The enclosing structure, of course, has no member variables apart from the classes it declares, and a static function to generate the coarse mesh; it will in general never be instantiated.) The idea is then the following (this is the right time to also take a brief look at the code below): we can generate objects for boundary values and right hand side by simply giving the name of the outer class as a template argument to a class which we call here &lt;code&gt;Data::SetUp&lt;/code&gt; , and it then creates objects for the inner classes. In this case, to get all that characterizes the curved ridge solution, we would simply generate an instance of &lt;code&gt;Data::SetUp@&lt;Data::CurvedRidge@&gt;&lt;/code&gt; , and everything we need to know about the solution would be static member variables and functions of that object. This approach might seem like overkill in this case, but will become very handy once a certain set up is not only characterized by Dirichlet boundary values and a right hand side function, but in addition by material properties, Neumann values, different boundary descriptors, etc. In that case, the &lt;code&gt;SetUp&lt;/code&gt; class might consist of a dozen or more objects, and each descriptor class (like the &lt;code&gt;CurvedRidges&lt;/code&gt; class below) would have to provide them. Then, you will be happy to be able to change from one set of data to another by only changing the template argument to the &lt;code&gt;SetUp&lt;/code&gt; class at one place, rather than at many. With this framework for different test cases, we are almost finished, but one thing remains: by now we can select statically, by changing one template argument, which data set to choose. In order to be able to do that dynamically, i.e. at run time, we need a base class. This we provide in the obvious way, see below, with virtual abstract functions. It forces us to introduce a second template parameter &lt;code&gt;dim&lt;/code&gt; which we need for the base class (which could be avoided using some template magic, but we omit that), but that&#39;s all. Adding new testcases is now simple, you don&#39;t have to touch the framework classes, only a structure like the &lt;code&gt;CurvedRidges&lt;/code&gt; one is needed. @code namespace Data { @endcode &lt;a name=&quot;TheSetUpBaseandSetUpclasses&quot;&gt;&lt;/a&gt; &lt;h4&gt;The SetUpBase and SetUp classes&lt;/h4&gt; Based on the above description, the &lt;code&gt;SetUpBase&lt;/code&gt; class then looks as follows. To allow using the &lt;code&gt;SmartPointer&lt;/code&gt; class with this class, we derived from the &lt;code&gt;Subscriptor&lt;/code&gt; class. @code template &lt;int dim&gt; struct SetUpBase : public Subscriptor { virtual const Function&lt;dim&gt; &amp;get_boundary_values() const = 0; virtual const Function&lt;dim&gt; &amp;get_right_hand_side() const = 0; virtual void create_coarse_grid(Triangulation&lt;dim&gt; &amp;coarse_grid) const = 0; }; @endcode And now for the derived class that takes the template argument as explained above. Here we pack the data elements into private variables, and allow access to them through the methods of the base class. @code template &lt;class Traits, int dim&gt; struct SetUp : public SetUpBase&lt;dim&gt; { virtual const Function&lt;dim&gt; &amp;get_boundary_values() const override; virtual const Function&lt;dim&gt; &amp;get_right_hand_side() const override; virtual void create_coarse_grid(Triangulation&lt;dim&gt; &amp;coarse_grid) const override; private: static const typename Traits::BoundaryValues boundary_values; static const typename Traits::RightHandSide right_hand_side; }; @endcode We have to provide definitions for the static member variables of the above class: @code template &lt;class Traits, int dim&gt; const typename Traits::BoundaryValues SetUp&lt;Traits, dim&gt;::boundary_values; template &lt;class Traits, int dim&gt; const typename Traits::RightHandSide SetUp&lt;Traits, dim&gt;::right_hand_side; @endcode And definitions of the member functions: @code template &lt;class Traits, int dim&gt; const Function&lt;dim&gt; &amp;SetUp&lt;Traits, dim&gt;::get_boundary_values() const { return boundary_values; } template &lt;class Traits, int dim&gt; const Function&lt;dim&gt; &amp;SetUp&lt;Traits, dim&gt;::get_right_hand_side() const { return right_hand_side; } template &lt;class Traits, int dim&gt; void SetUp&lt;Traits, dim&gt;::create_coarse_grid( Triangulation&lt;dim&gt; &amp;coarse_grid) const { Traits::create_coarse_grid(coarse_grid); } @endcode &lt;a name=&quot;TheCurvedRidgesclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The CurvedRidges class&lt;/h4&gt; The class that is used to describe the boundary values and right hand side of the &lt;code&gt;curved ridge&lt;/code&gt; problem already used in the @ref step_13 &quot;step-13&quot; example program is then like so: @code template &lt;int dim&gt; struct CurvedRidges { class BoundaryValues : public Function&lt;dim&gt; { public: virtual double value(const Point&lt;dim&gt; &amp; p, const unsigned int component) const; }; class RightHandSide : public Function&lt;dim&gt; { public: virtual double value(const Point&lt;dim&gt; &amp; p, const unsigned int component) const; }; static void create_coarse_grid(Triangulation&lt;dim&gt; &amp;coarse_grid); }; template &lt;int dim&gt; double CurvedRidges&lt;dim&gt;::BoundaryValues::value( const Point&lt;dim&gt; &amp;p, const unsigned int /*component*/ ) const { double q = p(0); for (unsigned int i = 1; i &lt; dim; ++i) q += std::sin(10 p(i) + 5 p(0) p(0)); const double exponential = std::exp(q); return exponential; } template &lt;int dim&gt; double CurvedRidges&lt;dim&gt;::RightHandSide::value( const Point&lt;dim&gt; &amp;p, const unsigned int /*component*/ ) const { double q = p(0); for (unsigned int i = 1; i &lt; dim; ++i) q += std::sin(10 p(i) + 5 p(0) p(0)); const double u = std::exp(q); double t1 = 1, t2 = 0, t3 = 0; for (unsigned int i = 1; i &lt; dim; ++i) { t1 += std::cos(10 p(i) + 5 p(0) p(0)) 10 p(0); t2 += 10 std::cos(10 p(i) + 5 p(0) p(0)) - 100 std::sin(10 p(i) + 5 p(0) p(0)) p(0) p(0); t3 += 100 std::cos(10 p(i) + 5 p(0) p(0)) std::cos(10 p(i) + 5 p(0) p(0)) - 100 std::sin(10 p(i) + 5 p(0) p(0)); } t1 = t1 t1; return -u (t1 + t2 + t3); } template &lt;int dim&gt; void CurvedRidges&lt;dim&gt;::create_coarse_grid(Triangulation&lt;dim&gt; &amp;coarse_grid) { GridGenerator::hyper_cube(coarse_grid, -1, 1); coarse_grid.refine_global(2); } @endcode &lt;a name=&quot;TheExercise_2_3class&quot;&gt;&lt;/a&gt; &lt;h4&gt;The Exercise_2_3 class&lt;/h4&gt; This example program was written while giving practical courses for a lecture on adaptive finite element methods and duality based error estimates. For these courses, we had one exercise, which required to solve the Laplace equation with constant right hand side on a square domain with a square hole in the center, and zero boundary values. Since the implementation of the properties of this problem is so particularly simple here, lets do it. As the number of the exercise was 2.3, we take the liberty to retain this name for the class as well. @code template &lt;int dim&gt; struct Exercise_2_3 { @endcode We need a class to denote the boundary values of the problem. In this case, this is simple: it&#39;s the zero function, so don&#39;t even declare a class, just an alias: @code using BoundaryValues = Functions::ZeroFunction&lt;dim&gt;; @endcode Second, a class that denotes the right hand side. Since they are constant, just subclass the corresponding class of the library and be done: @code class RightHandSide : public Functions::ConstantFunction&lt;dim&gt; { public: RightHandSide() : Functions::ConstantFunction&lt;dim&gt;(1.) {} }; @endcode Finally a function to generate the coarse grid. This is somewhat more complicated here, see immediately below. @code static void create_coarse_grid(Triangulation&lt;dim&gt; &amp;coarse_grid); }; @endcode As stated above, the grid for this example is the square [-1,1]^2 with the square [-1/2,1/2]^2 as hole in it. We create the coarse grid as 4 times 4 cells with the middle four ones missing. To understand how exactly the mesh is going to look, it may be simplest to just look at the &quot;Results&quot; section of this tutorial program first. In general, if you&#39;d like to understand more about creating meshes either from scratch by hand, as we do here, or using other techniques, you should take a look at @ref step_49 &quot;step-49&quot; . Of course, the example has an extension to 3d, but since this function cannot be written in a dimension independent way we choose not to implement this here, but rather only specialize the template for dim=2. If you compile the program for 3d, you&#39;ll get a message from the linker that this function is not implemented for 3d, and needs to be provided. For the creation of this geometry, the library has no predefined method. In this case, the geometry is still simple enough to do the creation by hand, rather than using a mesh generator. @code template &lt;&gt; void Exercise_2_3&lt;2&gt;::create_coarse_grid(Triangulation&lt;2&gt; &amp;coarse_grid) { @endcode We first define the space dimension, to allow those parts of the function that are actually dimension independent to use this variable. That makes it simpler if you later take this as a starting point to implement a 3d version of this mesh. The next step is then to have a list of vertices. Here, they are 24 (5 times 5, with the middle one omitted). It is probably best to draw a sketch here. @code const unsigned int dim = 2; const std::vector&lt;Point&lt;2&gt;&gt; vertices = { {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0}, {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}}; @endcode Next, we have to define the cells and the vertices they contain. @code const std::vector&lt;std::array&lt;int, GeometryInfo&lt;dim&gt;::vertices_per_cell&gt;&gt; cell_vertices = {{{0, 1, 5, 6}}, {{1, 2, 6, 7}}, {{2, 3, 7, 8}}, {{3, 4, 8, 9}}, {{5, 6, 10, 11}}, {{8, 9, 12, 13}}, {{10, 11, 14, 15}}, {{12, 13, 17, 18}}, {{14, 15, 19, 20}}, {{15, 16, 20, 21}}, {{16, 17, 21, 22}}, {{17, 18, 22, 23}}}; const unsigned int n_cells = cell_vertices.size(); @endcode Again, we generate a C++ vector type from this, but this time by looping over the cells (yes, this is boring). Additionally, we set the material indicator to zero for all the cells: @code std::vector&lt;CellData&lt;dim&gt;&gt; cells(n_cells, CellData&lt;dim&gt;()); for (unsigned int i = 0; i &lt; n_cells; ++i) { for (unsigned int j = 0; j &lt; cell_vertices[i].size(); ++j) cells[i].vertices[j] = cell_vertices[i][j]; cells[i].material_id = 0; } @endcode Finally pass all this information to the library to generate a triangulation. The last parameter may be used to pass information about non-zero boundary indicators at certain faces of the triangulation to the library, but we don&#39;t want that here, so we give an empty object: @code coarse_grid.create_triangulation(vertices, cells, SubCellData()); @endcode And since we want that the evaluation point (3/4,3/4) in this example is a grid point, we refine once globally: @code coarse_grid.refine_global(1); } } // namespace Data @endcode &lt;a name=&quot;Discussion&quot;&gt;&lt;/a&gt; &lt;h4&gt;Discussion&lt;/h4&gt; As you have now read through this framework, you may be wondering why we have not chosen to implement the classes implementing a certain setup (like the &lt;code&gt;CurvedRidges&lt;/code&gt; class) directly as classes derived from &lt;code&gt;Data::SetUpBase&lt;/code&gt; . Indeed, we could have done very well so. The only reason is that then we would have to have member variables for the solution and right hand side classes in the &lt;code&gt;CurvedRidges&lt;/code&gt; class, as well as member functions overloading the abstract functions of the base class giving access to these member variables. The &lt;code&gt;SetUp&lt;/code&gt; class has the sole reason to relieve us from the need to reiterate these member variables and functions that would be necessary in all such classes. In some way, the template mechanism here only provides a way to have default implementations for a number of functions that depend on external quantities and can thus not be provided using normal virtual functions, at least not without the help of templates. However, there might be good reasons to actually implement classes derived from &lt;code&gt;Data::SetUpBase&lt;/code&gt; , for example if the solution or right hand side classes require constructors that take arguments, which the &lt;code&gt;Data::SetUpBase&lt;/code&gt; class cannot provide. In that case, subclassing is a worthwhile strategy. Other possibilities for special cases are to derive from &lt;code&gt;Data::SetUp@&lt;SomeSetUp@&gt;&lt;/code&gt; where &lt;code&gt;SomeSetUp&lt;/code&gt; denotes a class, or even to explicitly specialize &lt;code&gt;Data::SetUp@&lt;SomeSetUp@&gt;&lt;/code&gt; . The latter allows to transparently use the way the &lt;code&gt;SetUp&lt;/code&gt; class is used for other set-ups, but with special actions taken for special arguments. A final observation favoring the approach taken here is the following: we have found numerous times that when starting a project, the number of parameters (usually boundary values, right hand side, coarse grid, just as here) was small, and the number of test cases was small as well. One then starts out by handcoding them into a number of &lt;code&gt;switch&lt;/code&gt; statements. Over time, projects grow, and so does the number of test cases. The number of &lt;code&gt;switch&lt;/code&gt; statements grows with that, and their length as well, and one starts to find ways to consider impossible examples where domains, boundary values, and right hand sides do not fit together any more, and starts losing the overview over the whole structure. Encapsulating everything belonging to a certain test case into a structure of its own has proven worthwhile for this, as it keeps everything that belongs to one test case in one place. Furthermore, it allows to put these things all in one or more files that are only devoted to test cases and their data, without having to bring their actual implementation into contact with the rest of the program. &lt;a name=&quot;Dualfunctionals&quot;&gt;&lt;/a&gt; &lt;h3&gt;Dual functionals&lt;/h3&gt; As with the other components of the program, we put everything we need to describe dual functionals into a namespace of its own, and define an abstract base class that provides the interface the class solving the dual problem needs for its work. We will then implement two such classes, for the evaluation of a point value and of the derivative of the solution at that point. For these functionals we already have the corresponding evaluation objects, so they are complementary. @code namespace DualFunctional { @endcode &lt;a name=&quot;TheDualFunctionalBaseclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The DualFunctionalBase class&lt;/h4&gt; First start with the base class for dual functionals. Since for linear problems the characteristics of the dual problem play a role only in the right hand side, we only need to provide for a function that assembles the right hand side for a given discretization: @code template &lt;int dim&gt; class DualFunctionalBase : public Subscriptor { public: virtual void assemble_rhs(const DoFHandler&lt;dim&gt; &amp;dof_handler, Vector&lt;double&gt; &amp; rhs) const = 0; }; @endcode &lt;a name=&quot;ThedualfunctionalPointValueEvaluationclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The dual functional PointValueEvaluation class&lt;/h4&gt; As a first application, we consider the functional corresponding to the evaluation of the solution&#39;s value at a given point which again we assume to be a vertex. Apart from the constructor that takes and stores the evaluation point, this class consists only of the function that implements assembling the right hand side. @code template &lt;int dim&gt; class PointValueEvaluation : public DualFunctionalBase&lt;dim&gt; { public: PointValueEvaluation(const Point&lt;dim&gt; &amp;evaluation_point); virtual void assemble_rhs(const DoFHandler&lt;dim&gt; &amp;dof_handler, Vector&lt;double&gt; &amp; rhs) const override; DeclException1( ExcEvaluationPointNotFound, Point&lt;dim&gt;, &lt;&lt; &quot;The evaluation point &quot; &lt;&lt; arg1 &lt;&lt; &quot; was not found among the vertices of the present grid.&quot;); protected: const Point&lt;dim&gt; evaluation_point; }; template &lt;int dim&gt; PointValueEvaluation&lt;dim&gt;::PointValueEvaluation( const Point&lt;dim&gt; &amp;evaluation_point) : evaluation_point(evaluation_point) {} @endcode As for doing the main purpose of the class, assembling the right hand side, let us first consider what is necessary: The right hand side of the dual problem is a vector of values J(phi_i), where J is the error functional, and phi_i is the i-th shape function. Here, J is the evaluation at the point x0, i.e. J(phi_i)=phi_i(x0). Now, we have assumed that the evaluation point is a vertex. Thus, for the usual finite elements we might be using in this program, we can take for granted that at such a point exactly one shape function is nonzero, and in particular has the value one. Thus, we set the right hand side vector to all-zeros, then seek for the shape function associated with that point and set the corresponding value of the right hand side vector to one: @code template &lt;int dim&gt; void PointValueEvaluation&lt;dim&gt;::assemble_rhs(const DoFHandler&lt;dim&gt; &amp;dof_handler, Vector&lt;double&gt; &amp; rhs) const { @endcode So, first set everything to zeros... @code rhs.reinit(dof_handler.n_dofs()); @endcode ...then loop over cells and find the evaluation point among the vertices (or very close to a vertex, which may happen due to floating point round-off): @code for (const auto &amp;cell : dof_handler.active_cell_iterators()) for (const auto vertex : cell-&gt;vertex_indices()) if (cell-&gt;vertex(vertex).distance(evaluation_point) &lt; cell-&gt;diameter() 1e-8) { @endcode Ok, found, so set corresponding entry, and leave function since we are finished: @code rhs(cell-&gt;vertex_dof_index(vertex, 0)) = 1; return; } @endcode Finally, a sanity check: if we somehow got here, then we must have missed the evaluation point, so raise an exception unconditionally: @code AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point)); } @endcode &lt;a name=&quot;ThedualfunctionalPointXDerivativeEvaluationclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The dual functional PointXDerivativeEvaluation class&lt;/h4&gt; As second application, we again consider the evaluation of the x-derivative of the solution at one point. Again, the declaration of the class, and the implementation of its constructor is not too interesting: @code template &lt;int dim&gt; class PointXDerivativeEvaluation : public DualFunctionalBase&lt;dim&gt; { public: PointXDerivativeEvaluation(const Point&lt;dim&gt; &amp;evaluation_point); virtual void assemble_rhs(const DoFHandler&lt;dim&gt; &amp;dof_handler, Vector&lt;double&gt; &amp; rhs) const; DeclException1( ExcEvaluationPointNotFound, Point&lt;dim&gt;, &lt;&lt; &quot;The evaluation point &quot; &lt;&lt; arg1 &lt;&lt; &quot; was not found among the vertices of the present grid.&quot;); protected: const Point&lt;dim&gt; evaluation_point; }; template &lt;int dim&gt; PointXDerivativeEvaluation&lt;dim&gt;::PointXDerivativeEvaluation( const Point&lt;dim&gt; &amp;evaluation_point) : evaluation_point(evaluation_point) {} @endcode What is interesting is the implementation of this functional: here, J(phi_i)=d/dx phi_i(x0). We could, as in the implementation of the respective evaluation object take the average of the gradients of each shape function phi_i at this evaluation point. However, we take a slightly different approach: we simply take the average over all cells that surround this point. The question which cells &lt;code&gt;surrounds&lt;/code&gt; the evaluation point is made dependent on the mesh width by including those cells for which the distance of the cell&#39;s midpoint to the evaluation point is less than the cell&#39;s diameter. Taking the average of the gradient over the area/volume of these cells leads to a dual solution which is very close to the one which would result from the point evaluation of the gradient. It is simple to justify theoretically that this does not change the method significantly. @code template &lt;int dim&gt; void PointXDerivativeEvaluation&lt;dim&gt;::assemble_rhs( const DoFHandler&lt;dim&gt; &amp;dof_handler, Vector&lt;double&gt; &amp; rhs) const { @endcode Again, first set all entries to zero: @code rhs.reinit(dof_handler.n_dofs()); @endcode Initialize a &lt;code&gt;FEValues&lt;/code&gt; object with a quadrature formula, have abbreviations for the number of quadrature points and shape functions... @code QGauss&lt;dim&gt; quadrature(dof_handler.get_fe().degree + 1); FEValues&lt;dim&gt; fe_values(dof_handler.get_fe(), quadrature, update_gradients | update_quadrature_points | update_JxW_values); const unsigned int n_q_points = fe_values.n_quadrature_points; const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell; @endcode ...and have two objects that are used to store the global indices of the degrees of freedom on a cell, and the values of the gradients of the shape functions at the quadrature points: @code Vector&lt;double&gt; cell_rhs(dofs_per_cell); std::vector&lt;unsigned int&gt; local_dof_indices(dofs_per_cell); @endcode Finally have a variable in which we will sum up the area/volume of the cells over which we integrate, by integrating the unit functions on these cells: @code double total_volume = 0; @endcode Then start the loop over all cells, and select those cells which are close enough to the evaluation point: @code for (const auto &amp;cell : dof_handler.active_cell_iterators()) if (cell-&gt;center().distance(evaluation_point) &lt;= cell-&gt;diameter()) { @endcode If we have found such a cell, then initialize the &lt;code&gt;FEValues&lt;/code&gt; object and integrate the x-component of the gradient of each shape function, as well as the unit function for the total area/volume. @code fe_values.reinit(cell); cell_rhs = 0; for (unsigned int q = 0; q &lt; n_q_points; ++q) { for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) cell_rhs(i) += fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q)) fe_values.JxW(q); // dx total_volume += fe_values.JxW(q); } @endcode If we have the local contributions, distribute them to the global vector: @code cell-&gt;get_dof_indices(local_dof_indices); for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) rhs(local_dof_indices[i]) += cell_rhs(i); } @endcode After we have looped over all cells, check whether we have found any at all, by making sure that their volume is non-zero. If not, then the results will be botched, as the right hand side should then still be zero, so throw an exception: @code AssertThrow(total_volume &gt; 0, ExcEvaluationPointNotFound(evaluation_point)); @endcode Finally, we have by now only integrated the gradients of the shape functions, not taking their mean value. We fix this by dividing by the measure of the volume over which we have integrated: @code rhs /= total_volume; } } // namespace DualFunctional @endcode &lt;a name=&quot;ExtendingtheLaplaceSolvernamespace&quot;&gt;&lt;/a&gt; &lt;h3&gt;Extending the LaplaceSolver namespace&lt;/h3&gt; @code namespace LaplaceSolver { @endcode &lt;a name=&quot;TheDualSolverclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The DualSolver class&lt;/h4&gt; In the same way as the &lt;code&gt;PrimalSolver&lt;/code&gt; class above, we now implement a &lt;code&gt;DualSolver&lt;/code&gt; . It has all the same features, the only difference is that it does not take a function object denoting a right hand side object, but now takes a &lt;code&gt;DualFunctionalBase&lt;/code&gt; object that will assemble the right hand side vector of the dual problem. The rest of the class is rather trivial. Since both primal and dual solver will use the same triangulation, but different discretizations, it now becomes clear why we have made the &lt;code&gt;Base&lt;/code&gt; class a virtual one: since the final class will be derived from both &lt;code&gt;PrimalSolver&lt;/code&gt; as well as &lt;code&gt;DualSolver&lt;/code&gt;, it would have two &lt;code&gt;Base&lt;/code&gt; instances, would we not have marked the inheritance as virtual. Since in many applications the base class would store much more information than just the triangulation which needs to be shared between primal and dual solvers, we do not usually want to use two such base classes. @code template &lt;int dim&gt; class DualSolver : public Solver&lt;dim&gt; { public: DualSolver( Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp; face_quadrature, const DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional); protected: const SmartPointer&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;&gt; dual_functional; virtual void assemble_rhs(Vector&lt;double&gt; &amp;rhs) const override; static const Functions::ZeroFunction&lt;dim&gt; boundary_values; }; template &lt;int dim&gt; const Functions::ZeroFunction&lt;dim&gt; DualSolver&lt;dim&gt;::boundary_values; template &lt;int dim&gt; DualSolver&lt;dim&gt;::DualSolver( Triangulation&lt;dim&gt; &amp; triangulation, const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp; face_quadrature, const DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional) : Base&lt;dim&gt;(triangulation) , Solver&lt;dim&gt;(triangulation, fe, quadrature, face_quadrature, boundary_values) , dual_functional(&amp;dual_functional) {} template &lt;int dim&gt; void DualSolver&lt;dim&gt;::assemble_rhs(Vector&lt;double&gt; &amp;rhs) const { dual_functional-&gt;assemble_rhs(this-&gt;dof_handler, rhs); } @endcode &lt;a name=&quot;TheWeightedResidualclass&quot;&gt;&lt;/a&gt; &lt;h4&gt;The WeightedResidual class&lt;/h4&gt; Here finally comes the main class of this program, the one that implements the dual weighted residual error estimator. It joins the primal and dual solver classes to use them for the computation of primal and dual solutions, and implements the error representation formula for use as error estimate and mesh refinement. The first few of the functions of this class are mostly overriders of the respective functions of the base class: @code template &lt;int dim&gt; class WeightedResidual : public PrimalSolver&lt;dim&gt;, public DualSolver&lt;dim&gt; { public: WeightedResidual( Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; primal_fe, const FiniteElement&lt;dim&gt; &amp; dual_fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp; face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; boundary_values, const DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional); virtual void solve_problem() override; virtual void postprocess( const Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) const override; virtual unsigned int n_dofs() const override; virtual void refine_grid() override; virtual void output_solution() const override; private: @endcode In the private section, we have two functions that are used to call the &lt;code&gt;solve_problem&lt;/code&gt; functions of the primal and dual base classes. These two functions will be called in parallel by the &lt;code&gt;solve_problem&lt;/code&gt; function of this class. @code void solve_primal_problem(); void solve_dual_problem(); @endcode Then declare abbreviations for active cell iterators, to avoid that we have to write this lengthy name over and over again: @code using active_cell_iterator = typename DoFHandler&lt;dim&gt;::active_cell_iterator; @endcode Next, declare a data type that we will us to store the contribution of faces to the error estimator. The idea is that we can compute the face terms from each of the two cells to this face, as they are the same when viewed from both sides. What we will do is to compute them only once, based on some rules explained below which of the two adjacent cells will be in charge to do so. We then store the contribution of each face in a map mapping faces to their values, and only collect the contributions for each cell by looping over the cells a second time and grabbing the values from the map. The data type of this map is declared here: @code using FaceIntegrals = typename std::map&lt;typename DoFHandler&lt;dim&gt;::face_iterator, double&gt;; @endcode In the computation of the error estimates on cells and faces, we need a number of helper objects, such as &lt;code&gt;FEValues&lt;/code&gt; and &lt;code&gt;FEFaceValues&lt;/code&gt; functions, but also temporary objects storing the values and gradients of primal and dual solutions, for example. These fields are needed in the three functions that do the integration on cells, and regular and irregular faces, respectively. There are three reasonable ways to provide these fields: first, as local variables in the function that needs them; second, as member variables of this class; third, as arguments passed to that function. These three alternatives all have drawbacks: the third that their number is not negligible and would make calling these functions a lengthy enterprise. The second has the drawback that it disallows parallelization, since the threads that will compute the error estimate have to have their own copies of these variables each, so member variables of the enclosing class will not work. The first approach, although straightforward, has a subtle but important drawback: we will call these functions over and over again, many thousands of times maybe; it now turns out that allocating vectors and other objects that need memory from the heap is an expensive business in terms of run-time, since memory allocation is expensive when several threads are involved. It is thus significantly better to allocate the memory only once, and recycle the objects as often as possible. What to do? Our answer is to use a variant of the third strategy. In fact, this is exactly what the WorkStream concept is supposed to do (we have already introduced it above, but see also @ref threads ). To avoid that we have to give these functions a dozen or so arguments, we pack all these variables into two structures, one which is used for the computations on cells, the other doing them on the faces. Both are then joined into the WeightedResidualScratchData class that will serve as the &quot;scratch data&quot; class of the WorkStream concept: @code struct CellData { FEValues&lt;dim&gt; fe_values; const SmartPointer&lt;const Function&lt;dim&gt;&gt; right_hand_side; std::vector&lt;double&gt; cell_residual; std::vector&lt;double&gt; rhs_values; std::vector&lt;double&gt; dual_weights; std::vector&lt;double&gt; cell_laplacians; CellData(const FiniteElement&lt;dim&gt; &amp;fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Function&lt;dim&gt; &amp; right_hand_side); CellData(const CellData &amp;cell_data); }; struct FaceData { FEFaceValues&lt;dim&gt; fe_face_values_cell; FEFaceValues&lt;dim&gt; fe_face_values_neighbor; FESubfaceValues&lt;dim&gt; fe_subface_values_cell; std::vector&lt;double&gt; jump_residual; std::vector&lt;double&gt; dual_weights; typename std::vector&lt;Tensor&lt;1, dim&gt;&gt; cell_grads; typename std::vector&lt;Tensor&lt;1, dim&gt;&gt; neighbor_grads; FaceData(const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature); FaceData(const FaceData &amp;face_data); }; struct WeightedResidualScratchData { WeightedResidualScratchData( const FiniteElement&lt;dim&gt; &amp; primal_fe, const Quadrature&lt;dim&gt; &amp; primal_quadrature, const Quadrature&lt;dim - 1&gt; &amp;primal_face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights); WeightedResidualScratchData( const WeightedResidualScratchData &amp;scratch_data); CellData cell_data; FaceData face_data; Vector&lt;double&gt; primal_solution; Vector&lt;double&gt; dual_weights; }; @endcode WorkStream::run generally wants both a scratch object and a copy object. Here, for reasons similar to what we had in @ref step_9 &quot;step-9&quot; when discussing the computation of an approximation of the gradient, we don&#39;t actually need a &quot;copy data&quot; structure. Since WorkStream insists on having one of these, we just declare an empty structure that does nothing other than being there. @code struct WeightedResidualCopyData {}; @endcode Regarding the evaluation of the error estimator, we have one driver function that uses WorkStream::run() to call the second function on every cell: @code void estimate_error(Vector&lt;float&gt; &amp;error_indicators) const; void estimate_on_one_cell(const active_cell_iterator &amp; cell, WeightedResidualScratchData &amp;scratch_data, WeightedResidualCopyData &amp; copy_data, Vector&lt;float&gt; &amp; error_indicators, FaceIntegrals &amp;face_integrals) const; @endcode Then we have functions that do the actual integration of the error representation formula. They will treat the terms on the cell interiors, on those faces that have no hanging nodes, and on those faces with hanging nodes, respectively: @code void integrate_over_cell(const active_cell_iterator &amp;cell, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights, CellData &amp; cell_data, Vector&lt;float&gt; &amp;error_indicators) const; void integrate_over_regular_face(const active_cell_iterator &amp;cell, const unsigned int face_no, const Vector&lt;double&gt; &amp;primal_solution, const Vector&lt;double&gt; &amp;dual_weights, FaceData &amp; face_data, FaceIntegrals &amp;face_integrals) const; void integrate_over_irregular_face(const active_cell_iterator &amp;cell, const unsigned int face_no, const Vector&lt;double&gt; &amp;primal_solution, const Vector&lt;double&gt; &amp;dual_weights, FaceData &amp; face_data, FaceIntegrals &amp;face_integrals) const; }; @endcode In the implementation of this class, we first have the constructors of the &lt;code&gt;CellData&lt;/code&gt; and &lt;code&gt;FaceData&lt;/code&gt; member classes, and the &lt;code&gt;WeightedResidual&lt;/code&gt; constructor. They only initialize fields to their correct lengths, so we do not have to discuss them in too much detail: @code template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::CellData::CellData( const FiniteElement&lt;dim&gt; &amp;fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Function&lt;dim&gt; &amp; right_hand_side) : fe_values(fe, quadrature, update_values | update_hessians | update_quadrature_points | update_JxW_values) , right_hand_side(&amp;right_hand_side) , cell_residual(quadrature.size()) , rhs_values(quadrature.size()) , dual_weights(quadrature.size()) , cell_laplacians(quadrature.size()) {} template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::CellData::CellData(const CellData &amp;cell_data) : fe_values(cell_data.fe_values.get_fe(), cell_data.fe_values.get_quadrature(), update_values | update_hessians | update_quadrature_points | update_JxW_values) , right_hand_side(cell_data.right_hand_side) , cell_residual(cell_data.cell_residual) , rhs_values(cell_data.rhs_values) , dual_weights(cell_data.dual_weights) , cell_laplacians(cell_data.cell_laplacians) {} template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::FaceData::FaceData( const FiniteElement&lt;dim&gt; &amp; fe, const Quadrature&lt;dim - 1&gt; &amp;face_quadrature) : fe_face_values_cell(fe, face_quadrature, update_values | update_gradients | update_JxW_values | update_normal_vectors) , fe_face_values_neighbor(fe, face_quadrature, update_values | update_gradients | update_JxW_values | update_normal_vectors) , fe_subface_values_cell(fe, face_quadrature, update_gradients) { const unsigned int n_face_q_points = face_quadrature.size(); jump_residual.resize(n_face_q_points); dual_weights.resize(n_face_q_points); cell_grads.resize(n_face_q_points); neighbor_grads.resize(n_face_q_points); } template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::FaceData::FaceData(const FaceData &amp;face_data) : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(), face_data.fe_face_values_cell.get_quadrature(), update_values | update_gradients | update_JxW_values | update_normal_vectors) , fe_face_values_neighbor( face_data.fe_face_values_neighbor.get_fe(), face_data.fe_face_values_neighbor.get_quadrature(), update_values | update_gradients | update_JxW_values | update_normal_vectors) , fe_subface_values_cell( face_data.fe_subface_values_cell.get_fe(), face_data.fe_subface_values_cell.get_quadrature(), update_gradients) , jump_residual(face_data.jump_residual) , dual_weights(face_data.dual_weights) , cell_grads(face_data.cell_grads) , neighbor_grads(face_data.neighbor_grads) {} template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::WeightedResidualScratchData:: WeightedResidualScratchData( const FiniteElement&lt;dim&gt; &amp; primal_fe, const Quadrature&lt;dim&gt; &amp; primal_quadrature, const Quadrature&lt;dim - 1&gt; &amp;primal_face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights) : cell_data(primal_fe, primal_quadrature, rhs_function) , face_data(primal_fe, primal_face_quadrature) , primal_solution(primal_solution) , dual_weights(dual_weights) {} template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::WeightedResidualScratchData:: WeightedResidualScratchData( const WeightedResidualScratchData &amp;scratch_data) : cell_data(scratch_data.cell_data) , face_data(scratch_data.face_data) , primal_solution(scratch_data.primal_solution) , dual_weights(scratch_data.dual_weights) {} template &lt;int dim&gt; WeightedResidual&lt;dim&gt;::WeightedResidual( Triangulation&lt;dim&gt; &amp; coarse_grid, const FiniteElement&lt;dim&gt; &amp; primal_fe, const FiniteElement&lt;dim&gt; &amp; dual_fe, const Quadrature&lt;dim&gt; &amp; quadrature, const Quadrature&lt;dim - 1&gt; &amp; face_quadrature, const Function&lt;dim&gt; &amp; rhs_function, const Function&lt;dim&gt; &amp; bv, const DualFunctional::DualFunctionalBase&lt;dim&gt; &amp;dual_functional) : Base&lt;dim&gt;(coarse_grid) , PrimalSolver&lt;dim&gt;(coarse_grid, primal_fe, quadrature, face_quadrature, rhs_function, bv) , DualSolver&lt;dim&gt;(coarse_grid, dual_fe, quadrature, face_quadrature, dual_functional) {} @endcode The next five functions are boring, as they simply relay their work to the base classes. The first calls the primal and dual solvers in parallel, while postprocessing the solution and retrieving the number of degrees of freedom is done by the primal class. @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::solve_problem() { Threads::TaskGroup&lt;void&gt; tasks; tasks += Threads::new_task(&amp;WeightedResidual&lt;dim&gt;::solve_primal_problem,this); tasks += Threads::new_task(&amp;WeightedResidual&lt;dim&gt;::solve_dual_problem,this); tasks.join_all(); } template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::solve_primal_problem() { PrimalSolver&lt;dim&gt;::solve_problem(); } template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::solve_dual_problem() { DualSolver&lt;dim&gt;::solve_problem(); } template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::postprocess( const Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) const { PrimalSolver&lt;dim&gt;::postprocess(postprocessor); } template &lt;int dim&gt; unsigned int WeightedResidual&lt;dim&gt;::n_dofs() const { return PrimalSolver&lt;dim&gt;::n_dofs(); } @endcode Now, it is becoming more interesting: the &lt;code&gt;refine_grid()&lt;/code&gt; function asks the error estimator to compute the cell-wise error indicators, then uses their absolute values for mesh refinement. @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::refine_grid() { @endcode First call the function that computes the cell-wise and global error: @code Vector&lt;float&gt; error_indicators(this-&gt;triangulation-&gt;n_active_cells()); estimate_error(error_indicators); @endcode Then note that marking cells for refinement or coarsening only works if all indicators are positive, to allow their comparison. Thus, drop the signs on all these indicators: @code for (float &amp;error_indicator : error_indicators) error_indicator = std::fabs(error_indicator); @endcode Finally, we can select between different strategies for refinement. The default here is to refine those cells with the largest error indicators that make up for a total of 80 per cent of the error, while we coarsen those with the smallest indicators that make up for the bottom 2 per cent of the error. @code GridRefinement::refine_and_coarsen_fixed_fraction(*this-&gt;triangulation, error_indicators, 0.8, 0.02); this-&gt;triangulation-&gt;execute_coarsening_and_refinement(); } @endcode Since we want to output both the primal and the dual solution, we overload the &lt;code&gt;output_solution&lt;/code&gt; function. The only interesting feature of this function is that the primal and dual solutions are defined on different finite element spaces, which is not the format the &lt;code&gt;DataOut&lt;/code&gt; class expects. Thus, we have to transfer them to a common finite element space. Since we want the solutions only to see them qualitatively, we contend ourselves with interpolating the dual solution to the (smaller) primal space. For the interpolation, there is a library function, that takes a AffineConstraints object including the hanging node constraints. The rest is standard. @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::output_solution() const { AffineConstraints&lt;double&gt; primal_hanging_node_constraints; DoFTools::make_hanging_node_constraints(PrimalSolver&lt;dim&gt;::dof_handler, primal_hanging_node_constraints); primal_hanging_node_constraints.close(); Vector&lt;double&gt; dual_solution(PrimalSolver&lt;dim&gt;::dof_handler.n_dofs()); FETools::interpolate(DualSolver&lt;dim&gt;::dof_handler, DualSolver&lt;dim&gt;::solution, PrimalSolver&lt;dim&gt;::dof_handler, primal_hanging_node_constraints, dual_solution); DataOut&lt;dim&gt; data_out; data_out.attach_dof_handler(PrimalSolver&lt;dim&gt;::dof_handler); @endcode Add the data vectors for which we want output. Add them both, the &lt;code&gt;DataOut&lt;/code&gt; functions can handle as many data vectors as you wish to write to output: @code data_out.add_data_vector(PrimalSolver&lt;dim&gt;::solution, &quot;primal_solution&quot;); data_out.add_data_vector(dual_solution, &quot;dual_solution&quot;); data_out.build_patches(); std::ofstream out(&quot;solution-&quot; + std::to_string(this-&gt;refinement_cycle) + &quot;.vtu&quot;); data_out.write(out, DataOutBase::vtu); } @endcode &lt;a name=&quot;Estimatingerrors&quot;&gt;&lt;/a&gt; &lt;h3&gt;Estimating errors&lt;/h3&gt; &lt;a name=&quot;Errorestimationdriverfunctions&quot;&gt;&lt;/a&gt; &lt;h4&gt;Error estimation driver functions&lt;/h4&gt; As for the actual computation of error estimates, let&#39;s start with the function that drives all this, i.e. calls those functions that actually do the work, and finally collects the results. @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::estimate_error(Vector&lt;float&gt; &amp;error_indicators) const { @endcode The first task in computing the error is to set up vectors that denote the primal solution, and the weights (z-z_h)=(z-I_hz), both in the finite element space for which we have computed the dual solution. For this, we have to interpolate the primal solution to the dual finite element space, and to subtract the interpolation of the computed dual solution to the primal finite element space. Fortunately, the library provides functions for the interpolation into larger or smaller finite element spaces, so this is mostly obvious. First, let&#39;s do that for the primal solution: it is cell-wise interpolated into the finite element space in which we have solved the dual problem: But, again as in the &lt;code&gt;WeightedResidual::output_solution&lt;/code&gt; function we first need to create an AffineConstraints object including the hanging node constraints, but this time of the dual finite element space. @code AffineConstraints&lt;double&gt; dual_hanging_node_constraints; DoFTools::make_hanging_node_constraints(DualSolver&lt;dim&gt;::dof_handler, dual_hanging_node_constraints); dual_hanging_node_constraints.close(); Vector&lt;double&gt; primal_solution(DualSolver&lt;dim&gt;::dof_handler.n_dofs()); FETools::interpolate(PrimalSolver&lt;dim&gt;::dof_handler, PrimalSolver&lt;dim&gt;::solution, DualSolver&lt;dim&gt;::dof_handler, dual_hanging_node_constraints, primal_solution); @endcode Then for computing the interpolation of the numerically approximated dual solution z into the finite element space of the primal solution and subtracting it from z: use the &lt;code&gt;interpolate_difference&lt;/code&gt; function, that gives (z-I_hz) in the element space of the dual solution. @code AffineConstraints&lt;double&gt; primal_hanging_node_constraints; DoFTools::make_hanging_node_constraints(PrimalSolver&lt;dim&gt;::dof_handler, primal_hanging_node_constraints); primal_hanging_node_constraints.close(); Vector&lt;double&gt; dual_weights(DualSolver&lt;dim&gt;::dof_handler.n_dofs()); FETools::interpolation_difference(DualSolver&lt;dim&gt;::dof_handler, dual_hanging_node_constraints, DualSolver&lt;dim&gt;::solution, PrimalSolver&lt;dim&gt;::dof_handler, primal_hanging_node_constraints, dual_weights); @endcode Note that this could probably have been more efficient since those constraints have been used previously when assembling matrix and right hand side for the primal problem and writing out the dual solution. We leave the optimization of the program in this respect as an exercise. Having computed the dual weights we now proceed with computing the cell and face residuals of the primal solution. First we set up a map between face iterators and their jump term contributions of faces to the error estimator. The reason is that we compute the jump terms only once, from one side of the face, and want to collect them only afterwards when looping over all cells a second time. We initialize this map already with a value of - e20 for all faces, since this value will stand out in the results if something should go wrong and we fail to compute the value for a face for some reason. Secondly, this initialization already makes the std::map object allocate all objects it may possibly need. This is important since we will write into this structure from parallel threads, and doing so would not be thread-safe if the map needed to allocate memory and thereby reshape its data structures. In other words, the initial initialization relieves us from the necessity to synchronize the threads through a mutex each time they write to (and modify the structure of) this map. @code FaceIntegrals face_integrals; for (const auto &amp;cell : DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators()) for (const auto &amp;face : cell-&gt;face_iterators()) face_integrals[face] = -1e20; auto worker = [this, &amp;error_indicators, &amp;face_integrals](const active_cell_iterator &amp; cell, WeightedResidualScratchData &amp;scratch_data, WeightedResidualCopyData &amp; copy_data) { this-&gt;estimate_on_one_cell( cell, scratch_data, copy_data, error_indicators, face_integrals); }; auto do_nothing_copier = std::function&lt;void(const WeightedResidualCopyData &amp;)&gt;(); @endcode Then hand it all off to WorkStream::run() to compute the estimators for all cells in parallel: @code WorkStream::run( DualSolver&lt;dim&gt;::dof_handler.begin_active(), DualSolver&lt;dim&gt;::dof_handler.end(), worker, do_nothing_copier, WeightedResidualScratchData(*DualSolver&lt;dim&gt;::fe, DualSolver&lt;dim&gt;::quadrature, DualSolver&lt;dim&gt;::face_quadrature, this-&gt;rhs_function, primal_solution, dual_weights), WeightedResidualCopyData()); @endcode Once the error contributions are computed, sum them up. For this, note that the cell terms are already set, and that only the edge terms need to be collected. Thus, loop over all cells and their faces, make sure that the contributions of each of the faces are there, and add them up. Only take minus one half of the jump term, since the other half will be taken by the neighboring cell. @code unsigned int present_cell = 0; for (const auto &amp;cell : DualSolver&lt;dim&gt;::dof_handler.active_cell_iterators()) { for (const auto &amp;face : cell-&gt;face_iterators()) { Assert(face_integrals.find(face) != face_integrals.end(), ExcInternalError()); error_indicators(present_cell) -= 0.5 face_integrals[face]; } ++present_cell; } std::cout &lt;&lt; &quot; Estimated error=&quot; &lt;&lt; std::accumulate(error_indicators.begin(), error_indicators.end(), 0.) &lt;&lt; std::endl; } @endcode &lt;a name=&quot;Estimatingonasinglecell&quot;&gt;&lt;/a&gt; &lt;h4&gt;Estimating on a single cell&lt;/h4&gt; Next we have the function that is called to estimate the error on a single cell. The function may be called multiple times if the library was configured to use multithreading. Here it goes: @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::estimate_on_one_cell( const active_cell_iterator &amp; cell, WeightedResidualScratchData &amp;scratch_data, WeightedResidualCopyData &amp; copy_data, Vector&lt;float&gt; &amp; error_indicators, FaceIntegrals &amp; face_integrals) const { @endcode Because of WorkStream, estimate_on_one_cell requires a CopyData object even if it is no used. The next line silences a warning about this unused variable. @code (void)copy_data; @endcode First task on each cell is to compute the cell residual contributions of this cell, and put them into the &lt;code&gt;error_indicators&lt;/code&gt; variable: @code integrate_over_cell(cell, scratch_data.primal_solution, scratch_data.dual_weights, scratch_data.cell_data, error_indicators); @endcode After computing the cell terms, turn to the face terms. For this, loop over all faces of the present cell, and see whether something needs to be computed on it: @code for (const auto face_no : cell-&gt;face_indices()) { @endcode First, if this face is part of the boundary, then there is nothing to do. However, to make things easier when summing up the contributions of the faces of cells, we enter this face into the list of faces with a zero contribution to the error. @code if (cell-&gt;face(face_no)-&gt;at_boundary()) { face_integrals[cell-&gt;face(face_no)] = 0; continue; } @endcode Next, note that since we want to compute the jump terms on each face only once although we access it twice (if it is not at the boundary), we have to define some rules who is responsible for computing on a face: First, if the neighboring cell is on the same level as this one, i.e. neither further refined not coarser, then the one with the lower index within this level does the work. In other words: if the other one has a lower index, then skip work on this face: @code if ((cell-&gt;neighbor(face_no)-&gt;has_children() == false) &amp;&amp; (cell-&gt;neighbor(face_no)-&gt;level() == cell-&gt;level()) &amp;&amp; (cell-&gt;neighbor(face_no)-&gt;index() &lt; cell-&gt;index())) continue; @endcode Likewise, we always work from the coarser cell if this and its neighbor differ in refinement. Thus, if the neighboring cell is less refined than the present one, then do nothing since we integrate over the subfaces when we visit the coarse cell. @code if (cell-&gt;at_boundary(face_no) == false) if (cell-&gt;neighbor(face_no)-&gt;level() &lt; cell-&gt;level()) continue; @endcode Now we know that we are in charge here, so actually compute the face jump terms. If the face is a regular one, i.e. the other side&#39;s cell is neither coarser not finer than this cell, then call one function, and if the cell on the other side is further refined, then use another function. Note that the case that the cell on the other side is coarser cannot happen since we have decided above that we handle this case when we pass over that other cell. @code if (cell-&gt;face(face_no)-&gt;has_children() == false) integrate_over_regular_face(cell, face_no, scratch_data.primal_solution, scratch_data.dual_weights, scratch_data.face_data, face_integrals); else integrate_over_irregular_face(cell, face_no, scratch_data.primal_solution, scratch_data.dual_weights, scratch_data.face_data, face_integrals); } } @endcode &lt;a name=&quot;Computingcelltermerrorcontributions&quot;&gt;&lt;/a&gt; &lt;h4&gt;Computing cell term error contributions&lt;/h4&gt; As for the actual computation of the error contributions, first turn to the cell terms: @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::integrate_over_cell( const active_cell_iterator &amp;cell, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights, CellData &amp; cell_data, Vector&lt;float&gt; &amp; error_indicators) const { @endcode The tasks to be done are what appears natural from looking at the error estimation formula: first get the right hand side and Laplacian of the numerical solution at the quadrature points for the cell residual, @code cell_data.fe_values.reinit(cell); cell_data.right_hand_side-&gt;value_list( cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values); cell_data.fe_values.get_function_laplacians(primal_solution, cell_data.cell_laplacians); @endcode ...then get the dual weights... @code cell_data.fe_values.get_function_values(dual_weights, cell_data.dual_weights); @endcode ...and finally build the sum over all quadrature points and store it with the present cell: @code double sum = 0; for (unsigned int p = 0; p &lt; cell_data.fe_values.n_quadrature_points; ++p) sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) cell_data.dual_weights[p] cell_data.fe_values.JxW(p)); error_indicators(cell-&gt;active_cell_index()) += sum; } @endcode &lt;a name=&quot;Computingedgetermerrorcontributions1&quot;&gt;&lt;/a&gt; &lt;h4&gt;Computing edge term error contributions -- 1&lt;/h4&gt; On the other hand, computation of the edge terms for the error estimate is not so simple. First, we have to distinguish between faces with and without hanging nodes. Because it is the simple case, we first consider the case without hanging nodes on a face (let&#39;s call this the `regular&#39; case): @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::integrate_over_regular_face( const active_cell_iterator &amp;cell, const unsigned int face_no, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights, FaceData &amp; face_data, FaceIntegrals &amp; face_integrals) const { const unsigned int n_q_points = face_data.fe_face_values_cell.n_quadrature_points; @endcode The first step is to get the values of the gradients at the quadrature points of the finite element field on the present cell. For this, initialize the &lt;code&gt;FEFaceValues&lt;/code&gt; object corresponding to this side of the face, and extract the gradients using that object. @code face_data.fe_face_values_cell.reinit(cell, face_no); face_data.fe_face_values_cell.get_function_gradients( primal_solution, face_data.cell_grads); @endcode The second step is then to extract the gradients of the finite element solution at the quadrature points on the other side of the face, i.e. from the neighboring cell. For this, do a sanity check before: make sure that the neighbor actually exists (yes, we should not have come here if the neighbor did not exist, but in complicated software there are bugs, so better check this), and if this is not the case throw an error. @code Assert(cell-&gt;neighbor(face_no).state() == IteratorState::valid, ExcInternalError()); @endcode If we have that, then we need to find out with which face of the neighboring cell we have to work, i.e. the &lt;code&gt;how-many&#39;th&lt;/code&gt; the neighbor the present cell is of the cell behind the present face. For this, there is a function, and we put the result into a variable with the name &lt;code&gt;neighbor_neighbor&lt;/code&gt; : @code const unsigned int neighbor_neighbor = cell-&gt;neighbor_of_neighbor(face_no); @endcode Then define an abbreviation for the neighbor cell, initialize the &lt;code&gt;FEFaceValues&lt;/code&gt; object on that cell, and extract the gradients on that cell: @code const active_cell_iterator neighbor = cell-&gt;neighbor(face_no); face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor); face_data.fe_face_values_neighbor.get_function_gradients( primal_solution, face_data.neighbor_grads); @endcode Now that we have the gradients on this and the neighboring cell, compute the jump residual by multiplying the jump in the gradient with the normal vector: @code for (unsigned int p = 0; p &lt; n_q_points; ++p) face_data.jump_residual[p] = ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) face_data.fe_face_values_cell.normal_vector(p)); @endcode Next get the dual weights for this face: @code face_data.fe_face_values_cell.get_function_values(dual_weights, face_data.dual_weights); @endcode Finally, we have to compute the sum over jump residuals, dual weights, and quadrature weights, to get the result for this face: @code double face_integral = 0; for (unsigned int p = 0; p &lt; n_q_points; ++p) face_integral += (face_data.jump_residual[p] face_data.dual_weights[p] face_data.fe_face_values_cell.JxW(p)); @endcode Double check that the element already exists and that it was not already written to... @code Assert(face_integrals.find(cell-&gt;face(face_no)) != face_integrals.end(), ExcInternalError()); Assert(face_integrals[cell-&gt;face(face_no)] == -1e20, ExcInternalError()); @endcode ...then store computed value at assigned location. Note that the stored value does not contain the factor 1/2 that appears in the error representation. The reason is that the term actually does not have this factor if we loop over all faces in the triangulation, but only appears if we write it as a sum over all cells and all faces of each cell; we thus visit the same face twice. We take account of this by using this factor - /2 later, when we sum up the contributions for each cell individually. @code face_integrals[cell-&gt;face(face_no)] = face_integral; } @endcode &lt;a name=&quot;Computingedgetermerrorcontributions2&quot;&gt;&lt;/a&gt; &lt;h4&gt;Computing edge term error contributions -- 2&lt;/h4&gt; We are still missing the case of faces with hanging nodes. This is what is covered in this function: @code template &lt;int dim&gt; void WeightedResidual&lt;dim&gt;::integrate_over_irregular_face( const active_cell_iterator &amp;cell, const unsigned int face_no, const Vector&lt;double&gt; &amp; primal_solution, const Vector&lt;double&gt; &amp; dual_weights, FaceData &amp; face_data, FaceIntegrals &amp; face_integrals) const { @endcode First again two abbreviations, and some consistency checks whether the function is called only on faces for which it is supposed to be called: @code const unsigned int n_q_points = face_data.fe_face_values_cell.n_quadrature_points; const typename DoFHandler&lt;dim&gt;::face_iterator face = cell-&gt;face(face_no); const typename DoFHandler&lt;dim&gt;::cell_iterator neighbor = cell-&gt;neighbor(face_no); Assert(neighbor.state() == IteratorState::valid, ExcInternalError()); Assert(neighbor-&gt;has_children(), ExcInternalError()); (void)neighbor; @endcode Then find out which neighbor the present cell is of the adjacent cell. Note that we will operate on the children of this adjacent cell, but that their orientation is the same as that of their mother, i.e. the neighbor direction is the same. @code const unsigned int neighbor_neighbor = cell-&gt;neighbor_of_neighbor(face_no); @endcode Then simply do everything we did in the previous function for one face for all the sub-faces now: @code for (unsigned int subface_no = 0; subface_no &lt; face-&gt;n_children(); ++subface_no) { @endcode Start with some checks again: get an iterator pointing to the cell behind the present subface and check whether its face is a subface of the one we are considering. If that were not the case, then there would be either a bug in the &lt;code&gt;neighbor_neighbor&lt;/code&gt; function called above, or - worse - some function in the library did not keep to some underlying assumptions about cells, their children, and their faces. In any case, even though this assertion should not be triggered, it does not harm to be cautious, and in optimized mode computations the assertion will be removed anyway. @code const active_cell_iterator neighbor_child = cell-&gt;neighbor_child_on_subface(face_no, subface_no); Assert(neighbor_child-&gt;face(neighbor_neighbor) == cell-&gt;face(face_no)-&gt;child(subface_no), ExcInternalError()); @endcode Now start the work by again getting the gradient of the solution first at this side of the interface, @code face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no); face_data.fe_subface_values_cell.get_function_gradients( primal_solution, face_data.cell_grads); @endcode then at the other side, @code face_data.fe_face_values_neighbor.reinit(neighbor_child, neighbor_neighbor); face_data.fe_face_values_neighbor.get_function_gradients( primal_solution, face_data.neighbor_grads); @endcode and finally building the jump residuals. Since we take the normal vector from the other cell this time, revert the sign of the first term compared to the other function: @code for (unsigned int p = 0; p &lt; n_q_points; ++p) face_data.jump_residual[p] = ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) face_data.fe_face_values_neighbor.normal_vector(p)); @endcode Then get dual weights: @code face_data.fe_face_values_neighbor.get_function_values( dual_weights, face_data.dual_weights); @endcode At last, sum up the contribution of this sub-face, and set it in the global map: @code double face_integral = 0; for (unsigned int p = 0; p &lt; n_q_points; ++p) face_integral += (face_data.jump_residual[p] face_data.dual_weights[p] face_data.fe_face_values_neighbor.JxW(p)); face_integrals[neighbor_child-&gt;face(neighbor_neighbor)] = face_integral; } @endcode Once the contributions of all sub-faces are computed, loop over all sub-faces to collect and store them with the mother face for simple use when later collecting the error terms of cells. Again make safety checks that the entries for the sub-faces have been computed and do not carry an invalid value. @code double sum = 0; for (unsigned int subface_no = 0; subface_no &lt; face-&gt;n_children(); ++subface_no) { Assert(face_integrals.find(face-&gt;child(subface_no)) != face_integrals.end(), ExcInternalError()); Assert(face_integrals[face-&gt;child(subface_no)] != -1e20, ExcInternalError()); sum += face_integrals[face-&gt;child(subface_no)]; } @endcode Finally store the value with the parent face. @code face_integrals[face] = sum; } } // namespace LaplaceSolver @endcode &lt;a name=&quot;Asimulationframework&quot;&gt;&lt;/a&gt; &lt;h3&gt;A simulation framework&lt;/h3&gt; In the previous example program, we have had two functions that were used to drive the process of solving on subsequently finer grids. We extend this here to allow for a number of parameters to be passed to these functions, and put all of that into framework class. You will have noted that this program is built up of a number of small parts (evaluation functions, solver classes implementing various refinement methods, different dual functionals, different problem and data descriptions), which makes the program relatively simple to extend, but also allows to solve a large number of different problems by replacing one part by another. We reflect this flexibility by declaring a structure in the following framework class that holds a number of parameters that may be set to test various combinations of the parts of this program, and which can be used to test it at various problems and discretizations in a simple way. @code template &lt;int dim&gt; struct Framework { public: @endcode First, we declare two abbreviations for simple use of the respective data types: @code using Evaluator = Evaluation::EvaluationBase&lt;dim&gt;; using EvaluatorList = std::list&lt;Evaluator&gt;; @endcode Then we have the structure which declares all the parameters that may be set. In the default constructor of the structure, these values are all set to default values, for simple use. @code struct ProblemDescription { @endcode First allow for the degrees of the piecewise polynomials by which the primal and dual problems will be discretized. They default to (bi-, tri-)linear ansatz functions for the primal, and (bi-, tri-)quadratic ones for the dual problem. If a refinement criterion is chosen that does not need the solution of a dual problem, the value of the dual finite element degree is of course ignored. @code unsigned int primal_fe_degree; unsigned int dual_fe_degree; @endcode Then have an object that describes the problem type, i.e. right hand side, domain, boundary values, etc. The pointer needed here defaults to the Null pointer, i.e. you will have to set it in actual instances of this object to make it useful. @code std::unique_ptr&lt;const Data::SetUpBase&lt;dim&gt;&gt; data; @endcode Since we allow to use different refinement criteria (global refinement, refinement by the Kelly error indicator, possibly with a weight, and using the dual estimator), define a number of enumeration values, and subsequently a variable of that type. It will default to &lt;code&gt;dual_weighted_error_estimator&lt;/code&gt; . @code enum RefinementCriterion { dual_weighted_error_estimator, global_refinement, kelly_indicator, weighted_kelly_indicator }; RefinementCriterion refinement_criterion; @endcode Next, an object that describes the dual functional. It is only needed if the dual weighted residual refinement is chosen, and also defaults to a Null pointer. @code std::unique_ptr&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;&gt; dual_functional; @endcode Then a list of evaluation objects. Its default value is empty, i.e. no evaluation objects. @code EvaluatorList evaluator_list; @endcode Next to last, a function that is used as a weight to the &lt;code&gt;RefinementWeightedKelly&lt;/code&gt; class. The default value of this pointer is zero, but you have to set it to some other value if you want to use the &lt;code&gt;weighted_kelly_indicator&lt;/code&gt; refinement criterion. @code std::unique_ptr&lt;const Function&lt;dim&gt;&gt; kelly_weight; @endcode Finally, we have a variable that denotes the maximum number of degrees of freedom we allow for the (primal) discretization. If it is exceeded, we stop the process of solving and intermittent mesh refinement. Its default value is 20,000. @code unsigned int max_degrees_of_freedom; @endcode Finally the default constructor of this class: @code ProblemDescription(); }; @endcode The driver framework class only has one method which calls solver and mesh refinement intermittently, and does some other small tasks in between. Since it does not need data besides the parameters given to it, we make it static: @code static void run(const ProblemDescription &amp;descriptor); }; @endcode As for the implementation, first the constructor of the parameter object, setting all values to their defaults: @code template &lt;int dim&gt; Framework&lt;dim&gt;::ProblemDescription::ProblemDescription() : primal_fe_degree(1) , dual_fe_degree(2) , refinement_criterion(dual_weighted_error_estimator) , max_degrees_of_freedom(20000) {} @endcode Then the function which drives the whole process: @code template &lt;int dim&gt; void Framework&lt;dim&gt;::run(const ProblemDescription &amp;descriptor) { @endcode First create a triangulation from the given data object, @code Triangulation&lt;dim&gt; triangulation( Triangulation&lt;dim&gt;::smoothing_on_refinement); descriptor.data-&gt;create_coarse_grid(triangulation); @endcode then a set of finite elements and appropriate quadrature formula: @code const FE_Q&lt;dim&gt; primal_fe(descriptor.primal_fe_degree); const FE_Q&lt;dim&gt; dual_fe(descriptor.dual_fe_degree); const QGauss&lt;dim&gt; quadrature(descriptor.dual_fe_degree + 1); const QGauss&lt;dim - 1&gt; face_quadrature(descriptor.dual_fe_degree + 1); @endcode Next, select one of the classes implementing different refinement criteria. @code std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver; switch (descriptor.refinement_criterion) { case ProblemDescription::dual_weighted_error_estimator: { solver = std::make_unique&lt;LaplaceSolver::WeightedResidual&lt;dim&gt;&gt;( triangulation, primal_fe, dual_fe, quadrature, face_quadrature, descriptor.data-&gt;get_right_hand_side(), descriptor.data-&gt;get_boundary_values(), descriptor.dual_functional); break; } case ProblemDescription::global_refinement: { solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;( triangulation, primal_fe, quadrature, face_quadrature, descriptor.data-&gt;get_right_hand_side(), descriptor.data-&gt;get_boundary_values()); break; } case ProblemDescription::kelly_indicator: { solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;( triangulation, primal_fe, quadrature, face_quadrature, descriptor.data-&gt;get_right_hand_side(), descriptor.data-&gt;get_boundary_values()); break; } case ProblemDescription::weighted_kelly_indicator: { solver = std::make_unique&lt;LaplaceSolver::RefinementWeightedKelly&lt;dim&gt;&gt;( triangulation, primal_fe, quadrature, face_quadrature, descriptor.data-&gt;get_right_hand_side(), descriptor.data-&gt;get_boundary_values(), descriptor.kelly_weight); break; } default: AssertThrow(false, ExcInternalError()); } @endcode Now that all objects are in place, run the main loop. The stopping criterion is implemented at the bottom of the loop. In the loop, first set the new cycle number, then solve the problem, output its solution(s), apply the evaluation objects to it, then decide whether we want to refine the mesh further and solve again on this mesh, or jump out of the loop. @code for (unsigned int step = 0; true; ++step) { std::cout &lt;&lt; &quot;Refinement cycle: &quot; &lt;&lt; step &lt;&lt; std::endl; solver-&gt;set_refinement_cycle(step); solver-&gt;solve_problem(); solver-&gt;output_solution(); std::cout &lt;&lt; &quot; Number of degrees of freedom=&quot; &lt;&lt; solver-&gt;n_dofs() &lt;&lt; std::endl; for (const auto &amp;evaluator : descriptor.evaluator_list) { evaluator-&gt;set_refinement_cycle(step); solver-&gt;postprocess(*evaluator); } if (solver-&gt;n_dofs() &lt; descriptor.max_degrees_of_freedom) solver-&gt;refine_grid(); else break; } @endcode Clean up the screen after the loop has run: @code std::cout &lt;&lt; std::endl; } } // namespace Step14 @endcode &lt;a name=&quot;Themainfunction&quot;&gt;&lt;/a&gt; &lt;h3&gt;The main function&lt;/h3&gt; Here finally comes the main function. It drives the whole process by specifying a set of parameters to be used for the simulation (polynomial degrees, evaluation and dual functionals, etc), and passes them packed into a structure to the frame work class above. @code int main() { try { using namespace Step14; @endcode Describe the problem we want to solve here by passing a descriptor object to the function doing the rest of the work: @code const unsigned int dim = 2; Framework&lt;dim&gt;::ProblemDescription descriptor; @endcode First set the refinement criterion we wish to use: @code descriptor.refinement_criterion = Framework&lt;dim&gt;::ProblemDescription::dual_weighted_error_estimator; @endcode Here, we could as well have used &lt;code&gt;global_refinement&lt;/code&gt; or &lt;code&gt;weighted_kelly_indicator&lt;/code&gt; . Note that the information given about dual finite elements, dual functional, etc is only important for the given choice of refinement criterion, and is ignored otherwise. Then set the polynomial degrees of primal and dual problem. We choose here bi-linear and bi-quadratic ones: @code descriptor.primal_fe_degree = 1; descriptor.dual_fe_degree = 2; @endcode Then set the description of the test case, i.e. domain, boundary values, and right hand side. These are prepackaged in classes. We take here the description of &lt;code&gt;Exercise_2_3&lt;/code&gt; , but you can also use &lt;code&gt;CurvedRidges@&lt;dim@&gt;&lt;/code&gt; : @code descriptor.data = std::make_unique&lt;Data::SetUp&lt;Data::Exercise_2_3&lt;dim&gt;, dim&gt;&gt;(); @endcode Next set first a dual functional, then a list of evaluation objects. We choose as default the evaluation of the value at an evaluation point, represented by the classes &lt;code&gt;PointValueEvaluation&lt;/code&gt; in the namespaces of evaluation and dual functional classes. You can also set the &lt;code&gt;PointXDerivativeEvaluation&lt;/code&gt; classes for the x-derivative instead of the value at the evaluation point. Note that dual functional and evaluation objects should match. However, you can give as many evaluation functionals as you want, so you can have both point value and derivative evaluated after each step. One such additional evaluation is to output the grid in each step. @code const Point&lt;dim&gt; evaluation_point(0.75, 0.75); descriptor.dual_functional = std::make_unique&lt;DualFunctional::PointValueEvaluation&lt;dim&gt;&gt;( evaluation_point); Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(evaluation_point); Evaluation::GridOutput&lt;dim&gt; postprocessor2(&quot;grid&quot;); descriptor.evaluator_list.push_back(&amp;postprocessor1); descriptor.evaluator_list.push_back(&amp;postprocessor2); @endcode Set the maximal number of degrees of freedom after which we want the program to stop refining the mesh further: @code descriptor.max_degrees_of_freedom = 20000; @endcode Finally pass the descriptor object to a function that runs the entire solution with it: @code Framework&lt;dim&gt;::run(descriptor); } @endcode Catch exceptions to give information about things that failed: @code catch (std::exception &amp;exc) { std::cerr &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl; std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl &lt;&lt; exc.what() &lt;&lt; std::endl &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl; return 1; } catch (...) { std::cerr &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl; std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl; return 1; } return 0; } @endcode &lt;a name=&quot;Results&quot;&gt;&lt;/a&gt;&lt;h1&gt;Results&lt;/h1&gt; &lt;a name=&quot;Pointvalues&quot;&gt;&lt;/a&gt;&lt;h3&gt;Point values&lt;/h3&gt; This program offers a lot of possibilities to play around. We can thusonly show a small part of all possible results that can be obtainedwith the help of this program. However, you are encouraged to just tryit out, by changing the settings in the main program. Here, we startby simply letting it run, unmodified: @code Refinement cycle: 0 Number of degrees of freedom=72 Point value=0.03243 Estimated error=0.000702385 Refinement cycle: 1 Number of degrees of freedom=67 Point value=0.0324827 Estimated error=0.000888953 Refinement cycle: 2 Number of degrees of freedom=130 Point value=0.0329619 Estimated error=0.000454606 Refinement cycle: 3 Number of degrees of freedom=307 Point value=0.0331934 Estimated error=0.000241254 Refinement cycle: 4 Number of degrees of freedom=718 Point value=0.0333675 Estimated error=7.4912e-05 Refinement cycle: 5 Number of degrees of freedom=1665 Point value=0.0334083 Estimated error=3.69111e-05 Refinement cycle: 6 Number of degrees of freedom=3975 Point value=0.033431 Estimated error=1.54218e-05 Refinement cycle: 7 Number of degrees of freedom=8934 Point value=0.0334406 Estimated error=6.28359e-06 Refinement cycle: 8 Number of degrees of freedom=21799 Point value=0.0334444 @endcode First let&#39;s look what the program actually computed. On the seventhgrid, primal and dual numerical solutions look like this (using acolor scheme intended to evoke the snow-capped mountains ofColorado that the original author of this program now callshome): &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td width=&quot;50%&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.solution-7.9.2.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td width=&quot;50%&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.solution-7-dual.9.2.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Apparently, the region at the bottom left is so unimportant for thepoint value evaluation at the top right that the grid is left entirelyunrefined there, even though the solution has singularities at the innercorner of that cell! Dueto the symmetry in right hand side and domain, the solution shouldactually look like at the top right in all four corners, but the meshrefinement criterion involving the dual solution chose to refine themdifferently - because we said that we really only care about a singlefunction value somewhere at the top right. Here are some of the meshes that are produced in refinement cycles 0,2, 4 (top row), and 5, 7, and 8 (bottom row): &lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-0.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-2.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-4.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-5.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-7.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.grid-8.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Note the subtle interplay between resolving the corner singularities,and resolving around the point of evaluation. It will be ratherdifficult to generate such a mesh by hand, as this would involve tojudge quantitatively how much which of the four corner singularitiesshould be resolved, and to set the weight compared to the vicinity ofthe evaluation point. The program prints the point value and the estimated error in thisquantity. From extrapolating it, we can guess that the exact value issomewhere close to 0.0334473, plus or minus 0.0000001 (note that we getalmost 6 valid digits from only 22,000 (primal) degrees offreedom. This number cannot be obtained from the value of thefunctional alone, but I have used the assumption that the errorestimator is mostly exact, and extrapolated the computed value plusthe estimated error, to get an approximation of the truevalue. Computing with more degrees of freedom shows that thisassumption is indeed valid. From the computed results, we can generate two graphs: one that showsthe convergence of the error \)@_fakenlJ(u)-J(u_h) \( (taking theextrapolated value as correct) in the point value, and the value thatwe get by adding up computed value \)J(u_h) \( and estimatederror eta (if the error estimator \)eta \( were exact, then the value \)J(u_h)+\eta \( would equal the exact point value, and the errorin this quantity would always be zero; however, since the errorestimator is only a - good - approximation to the true error, we canby this only reduce the size of the error). In this graph, we alsoindicate the complexity \){\cal O}(1/N) \( to show that mesh refinementacts optimal in this case. The second chart comparestrue and estimated error, and shows that the two are actually veryclose to each other, even for such a complicated quantity as the pointvalue: &lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.error.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.error-estimation.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a name=&quot;Comparingrefinementcriteria&quot;&gt;&lt;/a&gt;&lt;h3&gt;Comparing refinement criteria&lt;/h3&gt; Since we have accepted quite some effort when using the meshrefinement driven by the dual weighted error estimator (for solvingthe dual problem, and for evaluating the error representation), it isworth while asking whether that effort was successful. To this end, wefirst compare the achieved error levels for different mesh refinementcriteria. To generate this data, simply change the value of the meshrefinement criterion variable in the main program. The results arethus (for the weight in the Kelly indicator, we have chosen thefunction \)@_fakenl1/(r^2+0.1^2) \( , where \)r \( is the distance to the evaluation point; it can be shown that this isthe optimal weight if we neglect the effects of boundaries): &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-value.error-comparison.png&quot; alt=&quot;&quot;&gt; Checking these numbers, we see that for global refinement, the erroris proportional to \)@_fakenlO(1/(sqrt(N) log(N))) \( , and for the dualestimator \)O(1/N) \( . Generally speaking, we see that the dualweighted error estimator is better than the other refinementindicators, at least when compared with those that have a similarlyregular behavior. The Kelly indicator produces smaller errors, butjumps about the picture rather irregularly, with the error alsochanging signs sometimes. Therefore, its behavior does not allow toextrapolate the results to larger values of N. Furthermore, if wetrust the error estimates of the dual weighted error estimator, theresults can be improved by adding the estimated error to the computedvalues. In terms of reliability, the weighted estimator is thus betterthan the Kelly indicator, although the latter sometimes producessmaller errors. &lt;a name=&quot;Evaluationofpointstresses&quot;&gt;&lt;/a&gt;&lt;h3&gt;Evaluation of point stresses&lt;/h3&gt; Besides evaluating the values of the solution at a certain point, theprogram also offers the possibility to evaluate the x-derivatives at acertain point, and also to tailor mesh refinement for this. To let theprogram compute these quantities, simply replace the two occurrences of &lt;code&gt;PointValueEvaluation&lt;/code&gt; in the main function by &lt;code&gt;PointXDerivativeEvaluation&lt;/code&gt; , and let the program run: @code Refinement cycle: 0 Number of degrees of freedom=72 Point x-derivative=-0.0719397 Estimated error=-0.0126173 Refinement cycle: 1 Number of degrees of freedom=61 Point x-derivative=-0.0707956 Estimated error=-0.00774316 Refinement cycle: 2 Number of degrees of freedom=131 Point x-derivative=-0.0568671 Estimated error=-0.00313426 Refinement cycle: 3 Number of degrees of freedom=247 Point x-derivative=-0.053033 Estimated error=-0.00136114 Refinement cycle: 4 Number of degrees of freedom=532 Point x-derivative=-0.0526429 Estimated error=-0.000558868 Refinement cycle: 5 Number of degrees of freedom=1267 Point x-derivative=-0.0526955 Estimated error=-0.000220116 Refinement cycle: 6 Number of degrees of freedom=2864 Point x-derivative=-0.0527495 Estimated error=-9.46731e-05 Refinement cycle: 7 Number of degrees of freedom=6409 Point x-derivative=-0.052785 Estimated error=-4.21543e-05 Refinement cycle: 8 Number of degrees of freedom=14183 Point x-derivative=-0.0528028 Estimated error=-2.04241e-05 Refinement cycle: 9 Number of degrees of freedom=29902 Point x-derivative=-0.052814 @endcode The solution looks roughly the same as before (the exact solution ofcourse &lt;em&gt; is &lt;/em&gt; the same, only the grid changed a little), but thedual solution is now different. A close-up around the point ofevaluation shows this: &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td width=&quot;50%&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.solution-7-dual.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td width=&quot;50%&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.solution-7-dual-close-up.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/table&gt; This time, the grids in refinement cycles 0, 5, 6, 7, 8, and 9 looklike this: &lt;table align=&quot;center&quot; width=&quot;80%&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-0.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-5.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-6.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-7.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-8.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.grid-9.9.2.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Note the asymmetry of the grids compared with those we obtained forthe point evaluation. This is due to the fact that the domain and the primalsolution may be symmetric about the diagonal, but the \)@_fakenlx \( -derivative isnot, and the latter enters the refinement criterion. Then, it is interesting to compare actually computed values of thequantity of interest (i.e. the x-derivative of the solution at onepoint) with a reference value of - .0528223... plus or minus0.0000005. We get this reference value by computing on finer grid aftersome more mesh refinements, with approximately 130,000 cells.Recall that if the error is \)@_fakenlO(1/N) \( in the optimal case, thentaking a mesh with ten times more cells gives us one additional digitin the result. In the left part of the following chart, you again see the convergenceof the error towards this extrapolated value, while on the right yousee a comparison of true and estimated error: &lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.error.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-14.point-derivative.error-estimation.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; After an initial phase where the true error changes its sign, theestimated error matches it quite well, again. Also note the dramaticimprovement in the error when using the estimated error to correct thecomputed value of \)@_fakenlJ(u_h) \( . &lt;a name=&quot;step13revisited&quot;&gt;&lt;/a&gt;&lt;h3&gt;step-13 revisited&lt;/h3&gt; If instead of the &lt;code&gt;Exercise_2_3&lt;/code&gt; data set, we choose &lt;code&gt;CurvedRidges&lt;/code&gt; in the main function, and choose \)(0.5,0.5) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="afe_2fe__tools_8h_html"><div class="ttname"><a href="fe_2fe__tools_8h.html">fe_tools.h</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_a1dd48cb744013c448d57f8f77640c08d"><div class="ttname"><a href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">FEValuesBase::shape_value</a></div><div class="ttdeci">const double &amp; shape_value(const unsigned int function_no, const unsigned int point_no) const</div></div>
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="anamespaceFETools_html_a0f2e45e9f0117e1ae3ca704885c96ebc"><div class="ttname"><a href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">FETools::interpolation_difference</a></div><div class="ttdeci">void interpolation_difference(const DoFHandler&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const FiniteElement&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;z1_difference)</div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_aa2b5a089b26d5eb6842e77a0320440b0"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#aa2b5a089b26d5eb6842e77a0320440b0">error</a></div><div class="ttdeci">precision How many digits to use when writing the error</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00041">parsed_convergence_table_0.txt:41</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="anamespaceFunctions_html"><div class="ttname"><a href="namespaceFunctions.html">Functions</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2flow__function_8h_source.html#l00028">flow_function.h:28</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__cg_8h_source.html#l00088">solver_cg.h:88</a></div></div>
<div class="ttc" id="agroup__threads_html_ga664740f5d3f738649ac2811f8d656d11"><div class="ttname"><a href="group__threads.html#ga664740f5d3f738649ac2811f8d656d11">Threads::new_task</a></div><div class="ttdeci">Task&lt; RT &gt; new_task(const std::function&lt; RT()&gt; &amp;function)</div><div class="ttdef"><b>Definition:</b> <a href="base_2thread__management_8h_source.html#l01316">thread_management.h:1316</a></div></div>
<div class="ttc" id="apetsc__precondition__0_8txt_html_a41ebb2d49faa97a3d9eab4b4f13c2742"><div class="ttname"><a href="petsc__precondition__0_8txt.html#a41ebb2d49faa97a3d9eab4b4f13c2742">preconditioner</a></div><div class="ttdeci">*Base class for preconditioner classes using the PETSc functionality The classes in this hierarchy don t do a whole lot except for providing a function that sets the preconditioner and certain parameters on the preconditioning context of the solver These classes are basically here only to allow a similar interface as already used for the deal II solver and preconditioner classes Note that derived classes only provide interfaces to the relevant functionality of PETSc PETSc does not implement all preconditioners for all matrix types In particular some preconditioners are not going to work for parallel jobs such as for example the ILU preconditioner ***Constructor **Destructor **Destroys the preconditioner</div><div class="ttdef"><b>Definition:</b> <a href="petsc__precondition__0_8txt_source.html#l00002">petsc_precondition_0.txt:2</a></div></div>
<div class="ttc" id="afe_2fe__0_8txt_html_ad1bbe5407fe459d8e4e71ba7ed9f7428"><div class="ttname"><a href="fe_2fe__0_8txt.html#ad1bbe5407fe459d8e4e71ba7ed9f7428">neighbor</a></div><div class="ttdeci">it is possible that some of them are in turn constrained leading to longer chains of constraints that the AffineConstraints class will eventually have to sort this is of no concern for the FiniteElement and derived classes since they only act locally on one cell and its immediate neighbor</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__0_8txt_source.html#l00123">fe_0.txt:123</a></div></div>
<div class="ttc" id="anamespaceStep14_html"><div class="ttname"><a href="namespaceStep14.html">Step14</a></div><div class="ttdef"><b>Definition:</b> <a href="step-14_8cc_source.html#l00054">step-14.cc:54</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a8fba07b9a84b89e6be225f5f95c3e355"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div><div class="ttdeci">the program is just and one can not intelligently work around that *It is sometimes useful to change the behavior of the[2.x.6] macro from aborting a program to throwing exceptions On the other exceptions are not allowed to propagate out of destructors of classes For this there is a variant of the called[2.x.7] that can be used in destructors These use cases are discussed further down below on this page **Dynamic such as whether an output file can be written to *These are things that shouldn t be checked because it is not guaranteed that a program for which the condition is satisfied in a debug mode run</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00022">exceptions_0.txt:22</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2namespace__dealii_8h_source.html#l00026">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00070">fe_update_flags.h:70</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="ageodynamics__0_8txt_html_a47b3a2cd492d04754f4796002e14ed13"><div class="ttname"><a href="geodynamics__0_8txt.html#a47b3a2cd492d04754f4796002e14ed13">solver</a></div><div class="ttdeci">all others have started as modifications of one of the tutorial programs *The tutorial programs we propose to write will provide students and researchers with a reference implementation of current numerical technology such as higher order sophisticated linear and nonlinear stabilization etc Providing these as starting points for further development by others will also serve the goal of training a new generation of geodynamicists in modern numerical algorithms *In deal it is fairly simple to extend a set of equations by another for example an additional advected quantity that enters the existing equations as a right hand side or in one of the coefficients Since applications typically use blocked matrices rather than the one big matrix for everything it is also not complicated to find suitable linear solvers for augmented equations deal II is a good tool for trying out more complex formulations of or more complete models and their effects on the accuracy of solutions *deal II provides many interchangeable components that allow rapid prototyping of finite element kinds and stabilization or linear solvers For typically only a few lines of code have to be changed to replace low order by high order elements Through it becomes relatively simple to try out higher order a different block elimination solver</div><div class="ttdef"><b>Definition:</b> <a href="geodynamics__0_8txt_source.html#l00033">geodynamics_0.txt:33</a></div></div>
<div class="ttc" id="astep-1_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="step-1_8cc_source.html#l00086">step-1.cc:86</a></div></div>
<div class="ttc" id="astructCellData_html"><div class="ttname"><a href="structCellData.html">CellData</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria__description_8h_source.html#l00054">tria_description.h:54</a></div></div>
<div class="ttc" id="ampi__remote__point__evaluation__0_8txt_html_a07bb39fb970c095c229ed653f6be7030"><div class="ttname"><a href="mpi__remote__point__evaluation__0_8txt.html#a07bb39fb970c095c229ed653f6be7030">vertex</a></div><div class="ttdeci">*Helper class to access values on non matching grids *The name of the fields are chosen with the method quantities are computed at specified arbitrary positioned which receive the result and resort the result according to the points **Constructor[2.x.1] tolerance Tolerance in terms of unit cell coordinates for determining all cells around a point passed to the class during it might be necessary to adjust the tolerance in order to be able to identify a cell Floating point arithmetic implies that a point in not lie exactly on a vertex</div><div class="ttdef"><b>Definition:</b> <a href="mpi__remote__point__evaluation__0_8txt_source.html#l00005">mpi_remote_point_evaluation_0.txt:5</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_a78e73ad285a8792ff0f9f227b82eb108"><div class="ttname"><a href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">DataOutInterface::write</a></div><div class="ttdeci">void write(std::ostream &amp;out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08134">data_out_base.cc:8134</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="aupdate__flags__0_8txt_html_a5873b8f7eeaefb5e7a99005c6c93b175"><div class="ttname"><a href="update__flags__0_8txt.html#a5873b8f7eeaefb5e7a99005c6c93b175">quadrature</a></div><div class="ttdeci">and a mapping object that provides the Jacobian as well as its determinant Dealing with all these objects would be cumbersome and error prone *On the other these three kinds of objects almost always appear and it is in fact very rare for deal II application codes to do anything with quadrature</div><div class="ttdef"><b>Definition:</b> <a href="update__flags__0_8txt_source.html#l00019">update_flags_0.txt:19</a></div></div>
<div class="ttc" id="afe_2fe__q_8h_html"><div class="ttname"><a href="fe_2fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_a042c4bf0f59fef5e72dbcfbdd56b2782"><div class="ttname"><a href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">DoFHandler::end</a></div><div class="ttdeci">cell_iterator end() const</div></div>
<div class="ttc" id="anamespaceFETools_html_ad29759cb8c51f8d369a371f63be8dde0"><div class="ttname"><a href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate</a></div><div class="ttdeci">void interpolate(const DoFHandler&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const DoFHandler&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</div></div>
<div class="ttc" id="anamespaceGridRefinement_html_a48e5395381ed87155942a61a1edd134d"><div class="ttname"><a href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00322">grid_refinement.cc:322</a></div></div>
<div class="ttc" id="awork__stream__0_8txt_html_ab1f7b2d0d351b91b988585df989cc234"><div class="ttname"><a href="work__stream__0_8txt.html#ab1f7b2d0d351b91b988585df989cc234">copier</a></div><div class="ttdeci">for for the purpose of assembling matrices or evaluating error an item could be a cell The TBB library determines how many threads are but the number of items that may be active at any given time is specified by the argument to the constructor It should be bigger or equal to the number of processor cores **the default is four times the number of cores on the current system *Items are created upon request by the TBB whenever one of the worker threads is idle or is expected to become idle It is then handed off to a worker typically a member function of a main class These worker functions are run in parallel on a number of and there is no guarantee that they are asked to work on items in any particular in particular not necessarily in the order in which items are generated from the iterator range worker functions need additional for example FEValues input data some of which can not be shared among threads To this the which designates a type objects of which are stored with each item and which threads can use as private data without having to share them with other threads The worker functions store their results in objects of template type CopyData These are then handed off to a separate called copier</div><div class="ttdef"><b>Definition:</b> <a href="work__stream__0_8txt_source.html#l00010">work_stream_0.txt:10</a></div></div>
<div class="ttc" id="anumerics_2error__estimator_8h_html"><div class="ttname"><a href="numerics_2error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_a9a3bef554c6d22abe312e10e9475eecf"><div class="ttname"><a href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">DoFHandler::begin_active</a></div><div class="ttdeci">active_cell_iterator begin_active(const unsigned int level=0) const</div></div>
<div class="ttc" id="aclassTriangulation_html_a6ad0b3fb24aae17f4668427a433dea19"><div class="ttname"><a href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global</a></div><div class="ttdeci">void refine_global(const unsigned int times=1)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10781">tria.cc:10781</a></div></div>
<div class="ttc" id="aclassThreads_1_1Task_html"><div class="ttname"><a href="classThreads_1_1Task.html">Threads::Task&lt; void &gt;</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ConstantFunction_html"><div class="ttname"><a href="classFunctions_1_1ConstantFunction.html">Functions::ConstantFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00412">function.h:412</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_aafea668ad0c451ac7a0fae0f558c36d7"><div class="ttname"><a href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a></div><div class="ttdeci">in the area occupied by these artificial cells</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00037">distributed_0.txt:37</a></div></div>
<div class="ttc" id="astructCellData_html_a3e602fcb3bd076c02539c89f2c563e33"><div class="ttname"><a href="structCellData.html#a3e602fcb3bd076c02539c89f2c563e33">CellData::CellData</a></div><div class="ttdeci">CellData(const unsigned int n_vertices=GeometryInfo&lt; structdim &gt;::vertices_per_cell)</div><div class="ttdef"><b>Definition:</b> <a href="tria__description_8cc_source.html#l00033">tria_description.cc:33</a></div></div>
<div class="ttc" id="astructStep14_1_1Framework_html_a74f3b5723c4afa3c177e3d6718309321"><div class="ttname"><a href="structStep14_1_1Framework.html#a74f3b5723c4afa3c177e3d6718309321">Step14::Framework::run</a></div><div class="ttdeci">static void run(const ProblemDescription &amp;descriptor)</div><div class="ttdef"><b>Definition:</b> <a href="step-14_8cc_source.html#l01859">step-14.cc:1859</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga72743302dcb1a0fb1f2f8dc5122d299e"><div class="ttname"><a href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">Patterns::Tools::to_string</a></div><div class="ttdeci">std::string to_string(const T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l02413">patterns.h:2413</a></div></div>
<div class="ttc" id="akinsol__0_8txt_html_a6f62a16b407bb6c63e7b27a45efe9c97"><div class="ttname"><a href="kinsol__0_8txt.html#a6f62a16b407bb6c63e7b27a45efe9c97">rhs</a></div><div class="ttdeci">**Additional parameters that can be passed to the KINSOL class **KINSOL solution strategy KINSOL includes a Newton Krylov solver(both local and global) as well as Picard and fixed point solvers. *[0.x.3] *Standard Newton iteration. *[0.x.4] *Newton iteration with linesearch. *[0.x.5] *Fixed point iteration. *[0.x.6] *Picard iteration. *[0.x.7] *Initialization parameters for KINSOL. Global parameters the computation will be aborted and an assertion will be thrown **A function object that users may supply and that is intended to prepare the linear solver for subsequent calls to in the solution of linear systems[2.x.78] The exact nature of this system depends on the SolutionStrategy that has been selected In the cases and this function is never called The or a function within the linear solver to compute Jacobian related data that is required by the linear solver It may also preprocess that data as needed for which may involve calling a generic more build preconditioners from the assembled Jacobian In any the data so generated may then be used whenever a linear system is solved The point of this function is that but only as frequently as the solver determines that it is appropriate to perform the setup task In this Jacobian related data generated by thereby saving the effort to regenerate the Jacobian matrix and a preconditioner for it whenever possible[2.x.87] current_u Current value of[2.x.88][2.x.89] current_f Current value of[2.x.90] or[2.x.91] This function should then KINSOL does not call on the internal KINSOL convergence tests then KINSOL calls then only a fixed point iteration strategy can be used Notice that this may not or may converge very slowly A call to this function should store in dst the result of[2.x.93] applied to rhs</div><div class="ttdef"><b>Definition:</b> <a href="kinsol__0_8txt_source.html#l00517">kinsol_0.txt:517</a></div></div>
<div class="ttc" id="anamespaceMatrixTools_html_a9ad0eb7a8662628534586716748d62fb"><div class="ttname"><a href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a></div><div class="ttdeci">void apply_boundary_values(const std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, SparseMatrix&lt; number &gt; &amp;matrix, Vector&lt; number &gt; &amp;solution, Vector&lt; number &gt; &amp;right_hand_side, const bool eliminate_columns=true)</div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8cc_source.html#l00081">matrix_tools.cc:81</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_acd358e9b110ccbf4a7f76796d206b9c7"><div class="ttname"><a href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a></div><div class="ttdeci">void point_value(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const Point&lt; spacedim, double &gt; &amp;point, Vector&lt; typename VectorType::value_type &gt; &amp;value)</div></div>
<div class="ttc" id="adata__postprocessor__0_8txt_html_a80e53cb52e5dbb182dd14ee528927a77"><div class="ttname"><a href="data__postprocessor__0_8txt.html#a80e53cb52e5dbb182dd14ee528927a77">postprocessor</a></div><div class="ttdeci">the current data is generated on a coarser mesh for the background color corresponds to the magnitude of the gradient vector and the vector glyphs to the gradient itself It may be surprising at first to see that from each multiple vectors going in different directions But that is because the solution is only the gradient is discontinuous across and so the multiple vectors originating from each vertex simply represent the differing gradients of the solution at each adjacent cell *The output above the gradient[2.x.114] of the solution **corresponds to the temperature gradient if one interpreted[2.x.115] as solving a steady state heat transfer problem It is very small in the central part of the domain because in[2.x.116] we are solving an equation that has a coefficient[2.x.117] that is large in the central part and small on the outside This can be thought as a material that conducts heat and consequently the temperature gradient is small On the other the heat flux corresponds to the quantity[2.x.118] For the solution of that the flux should be continuous across the interface This is easily verified by the following modification of the postprocessor</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor__0_8txt_source.html#l00138">data_postprocessor_0.txt:138</a></div></div>
<div class="ttc" id="abase_2thread__management_8h_html"><div class="ttname"><a href="base_2thread__management_8h.html">thread_management.h</a></div></div>
<div class="ttc" id="alac_2affine__constraints_8h_html"><div class="ttname"><a href="lac_2affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a></div><div class="ttdeci">@ update_hessians</div><div class="ttdoc">Second derivatives of shape functions.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_ad919e2b915d8e8226aef004c2d8399a8"><div class="ttname"><a href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">exception</a></div><div class="ttdeci">since default values may change in the process of program you cannot know the values of parameters not specified in the input file ****It is often convenient to have something happen as soon as a parameter value is read This could be a check that it is valid that a file that is listed in the parameter file exists **or to initiate something else in such as setting a variable outside the this action could also be initiated once all parameters are read via but it is sometimes[1.x.19] to do it right away *This is facilitated by the and can then do whatever they want with it **e save it somewhere outside the ParameterHandler in C one doesn t usually pass around the address of a but an action can be a function like object(taking a string as argument) that results from calling such as a[1.x.20] that has the form **[1.x.21] *and that is attached to a specific parameter. *A typical example of such an action would be as follows the content of the file equals the default value of the parameter the contents of files are never changed after declaration of a parameter a directory in this file system may not have a file called[2.x.20] in it In that the directory represents a subsection as declared and the directory s name will correspond to the name of the subsection It will then have no files in it at but it may have further directories in the code above will lead to a hierarchical representation of data that looks like this(the content of files is indicated at the right in a different font) this is only used when creating output for exceptions If non empty[2.x.35] is the ParameterHandler object will stop parsing lines after encountering[2.x.36] This is handy when adding extra data that shall be parsed manually If[2.x.37] the parameter handler will skip undefined sections and entries This is useful for partially parsing a parameter for example to obtain only the spatial dimension of the problem By default all entries and subsections are expected to be declared The function sets the value of all parameters it encounters in the input file to the provided value Parameters not explicitly listed in the input file are left at the value they previously which will be the default value provided to and for each parameter all associated actions that may previously have been set by or if an associated action throws an exception</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00241">parameter_handler_0.txt:241</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_ad1f4e0deb5d982e8172d82141c634a67"><div class="ttname"><a href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients</a></div><div class="ttdeci">void get_function_gradients(const InputVector &amp;fe_function, std::vector&lt; Tensor&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;gradients) const</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8cc_source.html#l03664">fe_values.cc:3664</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Advection_html_aaff3056f2b80ada5c55d8c5825932c22"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">LocalIntegrators::Advection::cell_residual</a></div><div class="ttdeci">void cell_residual(Vector&lt; double &gt; &amp;result, const FEValuesBase&lt; dim &gt; &amp;fe, const std::vector&lt; Tensor&lt; 1, dim &gt;&gt; &amp;input, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="integrators_2advection_8h_source.html#l00123">advection.h:123</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_a553ca864aaf70330d9be86bc78f36d1e"><div class="ttname"><a href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a></div><div class="ttdeci">void distribute_dofs(const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</div></div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html_a592560ee80355620422a86087f11b9df"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">Differentiation::SD::fabs</a></div><div class="ttdeci">Expression fabs(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00273">symengine_math.cc:273</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00116">fe_update_flags.h:116</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a2cbf5ad6b464871261dbd054bced18a8"><div class="ttname"><a href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">FiniteElementData::degree</a></div><div class="ttdeci">const unsigned int degree</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__base_8h_source.html#l00428">fe_base.h:428</a></div></div>
<div class="ttc" id="aclassSubscriptor_html"><div class="ttname"><a href="classSubscriptor.html">Subscriptor</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2subscriptor_8h_source.html#l00060">subscriptor.h:60</a></div></div>
<div class="ttc" id="anamespaceWorkStream_html_ab8ceb010811941c351803b671a19fb73"><div class="ttname"><a href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a></div><div class="ttdeci">void run(const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)</div><div class="ttdef"><b>Definition:</b> <a href="base_2work__stream_8h_source.html#l01313">work_stream.h:1313</a></div></div>
<div class="ttc" id="anumerics_2vector__tools_8h_html"><div class="ttname"><a href="numerics_2vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="abase_2function_8h_html"><div class="ttname"><a href="base_2function_8h.html">function.h</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_a19f846bda83b7e3f4531daacb40c64e1"><div class="ttname"><a href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; exp(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05647">vectorization.h:5647</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="anamespacetypes_html_aaf4eb6ec214fa642dfd956f11a9cd2d7"><div class="ttname"><a href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a></div><div class="ttdeci">unsigned int boundary_id</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00117">types.h:117</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html"><div class="ttname"><a href="base_2logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_a46aefdb527125dafb59dcba92a0f256e"><div class="ttname"><a href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">FEValuesBase::shape_grad</a></div><div class="ttdeci">const Tensor&lt; 1, spacedim &gt; &amp; shape_grad(const unsigned int function_no, const unsigned int quadrature_point) const</div></div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="anumerics_2matrix__tools_8h_html"><div class="ttname"><a href="numerics_2matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="amapping__fe__0_8txt_html_a0af9c36aca1d2fa34a8615b4521ad4de"><div class="ttname"><a href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">map</a></div><div class="ttdeci">where is the first fundamental form of the map</div><div class="ttdef"><b>Definition:</b> <a href="mapping__fe__0_8txt_source.html#l00084">mapping_fe_0.txt:84</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="aclassTriangulation_html_ab2eeef6a38fa053814433870a9c35a0c"><div class="ttname"><a href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation</a></div><div class="ttdeci">virtual void create_triangulation(const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;vertices, const std::vector&lt; CellData&lt; dim &gt;&gt; &amp;cells, const SubCellData &amp;subcelldata)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10446">tria.cc:10446</a></div></div>
<div class="ttc" id="avector__tools__point__value__0_8txt_html_ac7a5c2ceb5c739d5b51cc7e0eee8100a"><div class="ttname"><a href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a></div><div class="ttdeci">*Assembling of right hand sides **Create a right hand side vector for a point source at point[2.x.1] In other it creates a vector[2.x.2] so that[2.x.3] where[2.x.4] are the shape functions described by[2.x.5] and[2.x.6] is the point at which the delta function is located Prior content of the given[2.x.7] vector is deleted This function is for the case of a scalar finite element This function is typically used in one of these two with different values for right hand sides or and then evaluate the solution at the same point every time You could do this by calling[2.x.8] after each solve</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__point__value__0_8txt_source.html#l00015">vector_tools_point_value_0.txt:15</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_a11c48f86a4f2adf21555e64049ecde8c"><div class="ttname"><a href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05605">vectorization.h:5605</a></div></div>
<div class="ttc" id="alac_2dynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="lac_2dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_a7797f796c0be511fbc7f230ccc22532e"><div class="ttname"><a href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation</a></div><div class="ttdeci">const Triangulation&lt; dim, spacedim &gt; &amp; get_triangulation() const</div></div>
<div class="ttc" id="aclassFiniteElementData_html_ae2fa3b8d578ba488b4f37061bb0278bb"><div class="ttname"><a href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElementData::dofs_per_cell</a></div><div class="ttdeci">const unsigned int dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__base_8h_source.html#l00410">fe_base.h:410</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a></div><div class="ttdeci">@ update_normal_vectors</div><div class="ttdoc">Normal vectors.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00132">fe_update_flags.h:132</a></div></div>
<div class="ttc" id="aclassBoundaryValues_html"><div class="ttname"><a href="classBoundaryValues.html">BoundaryValues</a></div><div class="ttdef"><b>Definition:</b> <a href="step-4_8cc_source.html#l00086">step-4.cc:86</a></div></div>
<div class="ttc" id="anamespaceStep8_html_a8cfe56efd5e932e7421d357e26eab267"><div class="ttname"><a href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">Step8::right_hand_side</a></div><div class="ttdeci">void right_hand_side(const std::vector&lt; Point&lt; dim &gt;&gt; &amp;points, std::vector&lt; Tensor&lt; 1, dim &gt;&gt; &amp;values)</div><div class="ttdef"><b>Definition:</b> <a href="step-8_8cc_source.html#l00090">step-8.cc:90</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="aclassVector_html_a7a2a770cb19d3e5b0b69b08ffc88184f"><div class="ttname"><a href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">Vector::end</a></div><div class="ttdeci">iterator end()</div></div>
<div class="ttc" id="afe__system__0_8txt_html_aec4ff0d63baa29c5fcf5471aef3241f6"><div class="ttname"><a href="fe__system__0_8txt.html#aec4ff0d63baa29c5fcf5471aef3241f6">face_no</a></div><div class="ttdeci">we then get the vector from this temporary object immediately to pass it to the constructor of[2.x.69] destructor is called at the end of the entire expression(after the constructor of[2.x.70] has finished) and destroys the elements of the temporary vector. Voila calls[2.x.169] if&lt; tt &gt; face_no</div><div class="ttdef"><b>Definition:</b> <a href="fe__system__0_8txt_source.html#l00178">fe_system_0.txt:178</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html_a6c9d8cfe285d568676bb6e308146c147"><div class="ttname"><a href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">SymmetricTensor::sum</a></div><div class="ttdeci">SymmetricTensor&lt; rank, dim, Number &gt; sum(const SymmetricTensor&lt; rank, dim, Number &gt; &amp;local, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_ae41b67cfd48e02f6035e39c84f0fb47a"><div class="ttname"><a href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">FEValuesBase::get_quadrature_points</a></div><div class="ttdeci">const std::vector&lt; Point&lt; spacedim &gt; &gt; &amp; get_quadrature_points() const</div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a69730bc7f91dd1be17fd083a66514e73"><div class="ttname"><a href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled to indent allsource files that have been changed recently If you want to make sure thatthe indenting is correct for all your you might want to set up apre commit hook One way to do is to copy[2.x.4] to[2.x.5] and make sure it isexecutable *If the system you are working on has more than one version of[2.x.6] degrees of freedom</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00018">coding_conventions_0.txt:18</a></div></div>
<div class="ttc" id="aclassStep14_1_1Evaluation_1_1GridOutput_html"><div class="ttname"><a href="classStep14_1_1Evaluation_1_1GridOutput.html">Step14::Evaluation::GridOutput</a></div><div class="ttdef"><b>Definition:</b> <a href="step-14_8cc_source.html#l00212">step-14.cc:212</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_af85863b31be0cbd660acba99051e0634"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#af85863b31be0cbd660acba99051e0634">data</a></div><div class="ttdeci">****This module contains classes that are used in the exception mechanism of deal II **Exceptions are used in two different not in static assertions are typically used to check that parameters to functions satisfy certain that internal data structures are and similar assertions For static assertions are used to make sure that two vectors that are added together have the same number of components **everything else would not make any sense anyway *Such checks are performed by the[2.x.3] macro in several thousand places within the library several tutorial programs starting with[2.x.4] show how to do this *If static a assertion is the exception mechanism generates an exception of a type that indicates what exactly goes wrong displays appropriate information including the exact location where the problem was detected and then aborts the program **if you try to add two vectors of different there is nothing that can be done within the program to cope with the you have to go fix the program code instead There is generally not even a reason to[2.x.5] an exception object using the usual C exception mechanism because there is nothing a function higher up could do in such cases to rectify the situation and deal with it in a useful way **it s not that the program received bad data</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00015">exceptions_0.txt:15</a></div></div>
<div class="ttc" id="atrilinos__sparse__matrix__0_8txt_html_ab4e34663c28496ee1b07f40fd5d00fa1"><div class="ttname"><a href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a></div><div class="ttdeci">all column elements of a row are stored on the same processor in any case The vector&lt; tt &gt; n_entries_per_row&lt;/tt &gt; specifies the number of entries in each row of the newly generated matrix **This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix__0_8txt_source.html#l00162">trilinos_sparse_matrix_0.txt:162</a></div></div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2dynamic__sparsity__pattern_8h_source.html#l00340">dynamic_sparsity_pattern.h:340</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparsity__pattern_8h_source.html#l00900">sparsity_pattern.h:900</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_gad107d8d5ae0baa7083cd2e932f9056dd"><div class="ttname"><a href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a></div><div class="ttdeci">#define DeclException1(Exception1, type1, outsequence)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l00586">exceptions.h:586</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_ab544a3bf3301a6dd3e705ee352c5551b"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a></div><div class="ttdeci">T sum(const T &amp;t, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="agroup__Exceptions_html_gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26"><div class="ttname"><a href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a3a648a57947844107f5cbdb012025b26">DataOutBase::vtu</a></div><div class="ttdeci">@ vtu</div><div class="ttdef"><b>Definition:</b> <a href="base_2data__out__base_8h_source.html#l01630">data_out_base.h:1630</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a98c83a8c964d1c88f6f2493b1c2ae26f"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a98c83a8c964d1c88f6f2493b1c2ae26f">out</a></div><div class="ttdeci">and where the chemical species react with each other based on reaction coefficients that also depend nonlinearly and in complicated ways on the chemical and pressure In many the exact formulas for all of these coefficients can take several lines to write out</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="anamespacenumbers_html"><div class="ttname"><a href="namespacenumbers.html">numbers</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2numbers_8h_source.html#l00201">numbers.h:201</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_abade89efb068b71b7ced7082012a2441"><div class="ttname"><a href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValuesBase::JxW</a></div><div class="ttdeci">double JxW(const unsigned int quadrature_point) const</div></div>
<div class="ttc" id="adofs_2dof__tools_8h_html"><div class="ttname"><a href="dofs_2dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="alac_2precondition_8h_html"><div class="ttname"><a href="lac_2precondition_8h.html">precondition.h</a></div></div>
<div class="ttc" id="agrid_2grid__out_8h_html"><div class="ttname"><a href="grid_2grid__out_8h.html">grid_out.h</a></div></div>
<div class="ttc" id="anamespaceGridRefinement_html_ae90dc87c4db158b8d01f6d564ac614e5"><div class="ttname"><a href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max(), const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00390">grid_refinement.cc:390</a></div></div>
<div class="ttc" id="aclassFiniteElement_html"><div class="ttname"><a href="classFiniteElement.html">FiniteElement&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceStep13_html_aa0f61eaaa88e83386181de7e6f590362"><div class="ttname"><a href="namespaceStep13.html#aa0f61eaaa88e83386181de7e6f590362">Step13::solve_problem</a></div><div class="ttdeci">void solve_problem(const std::string &amp;solver_name)</div><div class="ttdef"><b>Definition:</b> <a href="step-13_8cc_source.html#l00730">step-13.cc:730</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_a2b24e414d1a0d32deea919c5e8899811"><div class="ttname"><a href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a></div><div class="ttdeci">([1.x.8]&lt; sub &gt;1&lt;/sub &gt;, [1.x.9]&lt; sub &gt;2&lt;/sub &gt;, [1.x.10]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt; and[1.x.11] accordingly. Then, we can write the simplified equation in coordinates as[1.x.12] We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component(this is where the formulation with the[2.x.33] is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions:first, choose[1.x.13]=([1.x.14]&lt; sub &gt;1&lt;/sub &gt;, 0, 0)&lt; sup &gt;T&lt;/sup &gt;, then[1.x.15]=(0, [1.x.16]&lt; sub &gt;2&lt;/sub &gt;, 0)&lt; sup &gt;T&lt;/sup &gt;, and finally[1.x.17]=(0, 0, [1.x.18]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt;. writing the outcomes below each other, we obtain the system[1.x.19] where we used the standard inner product notation[2.x.34] . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form[1.x.20]([1.x.21], [1.x.22]), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient[1.x.23]:[1.x.24] Very formally, if we believe in operator valued matrices, we can rewrite this in the form[1.x.25]&lt; sup &gt;T&lt;/sup &gt;[1.x.26]=[1.x.27]&lt; sup &gt;T&lt;/sup &gt;[1.x.28] or[1.x.29] *[1.x.30] Now, let us consider a more complex example, the mixed Laplace equations discussed in[2.x.35] in three dimensions:[1.x.31] **Here, we have four solution components:the scalar pressure[2.x.36] and the vector-valued velocity[2.x.37] with three vector components. Note as important difference to the previous example, that the vector space[1.x.32] is not just simply a copy of three identical spaces/*A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows:[1.x.33] **This makes it clear that the solution[1.x.34] *indeed has four components. We note that we could change the ordering of the solution components[2.x.38] and[2.x.39] inside[2.x.40] if we also change columns of the matrix operator.*Next, we need to think about test functions[2.x.41] . We want to multiply both sides of the equation with them, then integrate over[2.x.42] . The result should be a scalar equality. We can achieve this by choosing[2.x.43] also vector valued as[1.x.35] **It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on(in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. *With this in mind, let us multiply by[2.x.44] and integrate to get the following equation which has to hold for all test functions[2.x.45] :[1.x.36] *or equivalently:[1.x.37] ***We get the final form by integrating by part the second term:[1.x.38] **It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector:the form in which we have solution and test functions[2.x.46] that each consist of a number of vector components that we can extract. **[2.x.47] VVFEs[1.x.39] *Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the FESystem class comes in:it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need[2.x.48] copies of the same element, for instance **[1.x.40] *This will generate a vector valued space of dimension[2.x.49], where each component is a continuous bilinear element of type FE_Q. It will have[2.x.50] times as many basis functions as the corresponding FE_Q, and each of these basis functions is a basis function of FE_Q, lifted into one of the components of the vector. *For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces[2.x.51] . One option would be the stable Raviart-Thomas pair **[1.x.41] *The first element in this system is already a vector valued element of dimension[2.x.52], while the second is a regular scalar element. *Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely **[1.x.42] *This system just has[2.x.53] equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer **[1.x.43] *Here, we have a system of two elements, one vector-valued and one scalar, very much like with the[2.x.54] . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely **[1.x.44] *It must be pointed out, that this element is different from **[1.x.45] *While the constructor call is very similar to[2.x.55], the result actually resembles more[2.x.56] in that this element produces[2.x.57] independent components. A more detailed comparison of the resulting FESystem objects is below. *[1.x.46] *FESystem has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table:&lt; table border=&quot;1&quot;&gt;&lt; tr &gt;&lt; th &gt;System Element&lt;/th &gt;[2.x.58][2.x.59][2.x.60]&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.61]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.62]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.63]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.64]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.65]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt;/table &gt; *From this table, it is clear that the FESystem reflects a lot of the structure of the system of differential equations in the cases of the[2.x.66] and the[2.x.67], in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. *At this point, it is important to note that nesting of two FESystem object can give the whole FESystem a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so. *[2.x.68] VVAssembling[1.x.47] The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with[2.x.69] . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. *The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. *[1.x.48] This is essentially how[2.x.70] does it:**[1.x.49] **So here 's what is happening:[2.x.71][2.x.72] The first thing we do is to declare &quot;extractors&quot;(see the FEValuesExtractors namespace). These are objects that don 't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1(i.e. what we call a &quot;physical vector&quot;, always consisting of[2.x.73] components). Here, we declare an object that represents the velocities consisting of[2.x.74] components starting at component zero, and the extractor for the pressure, which is a scalar component at position[2.x.75] . *[2.x.76] We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form(i.e. neglecting boundary terms) looked as follows, based on shape functions[2.x.77] :[1.x.50] *whereas the implementation looked like this:*[1.x.51] *The similarities are pretty obvious. *[2.x.78] Essentially, what happens in above code is this:when you do[2.x.79], a so-called &quot;view&quot; is created, i.e. an object that unlike the full FEValues object represents not all components of a finite element, but only the one(s) represented by the extractor object[2.x.80] or[2.x.81] . *[2.x.82] These views can then be asked for information about these individual components. For example, when you write[2.x.83] you get the value of the pressure component of the[2.x.84] th shape function[2.x.85] at the[2.x.86] th quadrature point. Because the extractor[2.x.87] represents a scalar component, the results of the operator[2.x.88] is a scalar number. On the other hand, the call[2.x.89] would produce the value of a whole set of[2.x.90] components, which would be of type[2.x.91] . *[2.x.92] Other things that can be done with views is to ask for the gradient of a particular shape function 's components described by an extractor. For example,[2.x.93] would represent the gradient of the scalar pressure component, which is of type[2.x.94], whereas the gradient of the velocities components,[2.x.95] is a[2.x.96], i.e. a matrix[2.x.97] that consists of entries[2.x.98] . Finally, both scalar and vector views can be asked for the second derivatives(&quot;Hessians&quot;) and vector views can be asked for the symmetric gradient, defined as[2.x.99] as well as the divergence[2.x.100] .[2.x.101] Other examples of using extractors and views are shown in tutorial programs[2.x.102],[2.x.103],[2.x.104] and several other programs. ***[2.x.105] In the current context, when we talk about a vector(for example in extracting the velocity components above), we mean the word in the sense physics uses it:it has[2.x.106] components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word &quot;vector&quot;(and how we use this word in other contexts in the library, for example in the Vector class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame x</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00090">vector_valued_0.txt:90</a></div></div>
<div class="ttc" id="aadvection__0_8txt_html_a79a3cbbb7583dd309bf1b14dc20895b6"><div class="ttname"><a href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a></div><div class="ttdeci">**its DG formulations All advection operators depend on an advection velocity denoted by[1.x.0] in the formulas below It is denoted as&lt; tt &gt; velocity&lt;/tt &gt; in the parameter lists The functions cell_matrix() and both upwind_value_matrix() are taking the equation in weak form</div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="aclassRightHandSide_html"><div class="ttname"><a href="classRightHandSide.html">RightHandSide</a></div><div class="ttdef"><b>Definition:</b> <a href="step-4_8cc_source.html#l00076">step-4.cc:76</a></div></div>
<div class="ttc" id="abase_2quadrature__lib_8h_html"><div class="ttname"><a href="base_2quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="aclassSmartPointer_html"><div class="ttname"><a href="classSmartPointer.html">SmartPointer</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2smartpointer_8h_source.html#l00067">smartpointer.h:67</a></div></div>
<div class="ttc" id="afunction__time__0_8txt_html_aec9d63e7b1c02618470be701525a5211"><div class="ttname"><a href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">sin</a></div><div class="ttdeci">*Support for time dependent functions The library was also designed for time dependent problems For this the function objects also contain a field which stores the as well as functions manipulating them Time independent problems should not access or even abuse them for other but since one normally does not create thousands of function the gain in generality weighs out the fact that we need not store the time value for not time dependent problems The second advantage is that the derived standard classes like&lt; tt &gt;&lt; tt &gt; ConstantFunction&lt;/tt &gt; etc also work for time dependent problems *Access to the time goes through the following so that derived classes can perform computations which need only be done once for every new time For if a time dependent function had a factor&lt; tt &gt; sin(t)&lt;/tt &gt;</div></div>
<div class="ttc" id="aclassVector_html_af34b888fe493ef2ed188179de69ad7ed"><div class="ttname"><a href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">Vector::begin</a></div><div class="ttdeci">iterator begin()</div></div>
<div class="ttc" id="aclassFESubfaceValues_html"><div class="ttname"><a href="classFESubfaceValues.html">FESubfaceValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_a8f384576a64c89a6fa8352847523e340"><div class="ttname"><a href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for n_q_points</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00537">fe_evaluation_0.txt:537</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga31978c026b8b6b5116df30b8e748f6b7"><div class="ttname"><a href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">StandardExceptions::ExcInternalError</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcInternalError()</div></div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassQTrapezoid_html"><div class="ttname"><a href="classQTrapezoid.html">QTrapezoid</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00126">quadrature_lib.h:126</a></div></div>
<div class="ttc" id="aclassGridOut_html_a1fa6434f6a8d8cda104d47728d30c657"><div class="ttname"><a href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">GridOut::write_svg</a></div><div class="ttdeci">void write_svg(const Triangulation&lt; 2, 2 &gt; &amp;tria, std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l01739">grid_out.cc:1739</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00124">fe_update_flags.h:124</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01581">exceptions.h:1581</a></div></div>
<div class="ttc" id="alac_2full__matrix_8h_html"><div class="ttname"><a href="lac_2full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="alac_2solver__cg_8h_html"><div class="ttname"><a href="lac_2solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="aclassDoFHandler_html_ad316958f8045d9a48094335b23a03a53"><div class="ttname"><a href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">DoFHandler::clear</a></div><div class="ttdeci">void clear()</div></div>
<div class="ttc" id="afe__q__0_8txt_html_a1a8eaafa20c4d8c9ab128b62a984738c"><div class="ttname"><a href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a></div><div class="ttdeci">*Implementation of a scalar Lagrange finite element[2.x.0] that yields the finite element space of piecewise polynomials of degree[2.x.1] in each coordinate direction This class is realized using tensor product polynomials based on D Lagrange polynomials with Gauss or given support points *The standard constructor of this class takes the degree[2.x.2] of this finite element it can take a quadrature formula[2.x.3] defining the support points of the Lagrange interpolation in one coordinate direction *For more information about the&lt; tt &gt; spacedim&lt;/tt &gt; template parameter check the documentation of FiniteElement or the one of Triangulation **The constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.4] polynomials of degree[2.x.5] This[2.x.6] object provides all values and derivatives of the shape functions In case a quadrature rule is the constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.7] polynomials with the support points from *[2.x.8] Furthermore the constructor fills the[2.x.9] the[2.x.10] equidistant support points at i where one polynomial is one and all the others are zero For higher polynomial degrees</div><div class="ttdef"><b>Definition:</b> <a href="fe__q__0_8txt_source.html#l00009">fe_q_0.txt:9</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="abase_2work__stream_8h_html"><div class="ttname"><a href="base_2work__stream_8h.html">work_stream.h</a></div></div>
<div class="ttc" id="aclassThreads_1_1TaskGroup_html"><div class="ttname"><a href="classThreads_1_1TaskGroup.html">Threads::TaskGroup</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2thread__management_8h_source.html#l01472">thread_management.h:1472</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_aa1b7ad9cb0189b0320f211d2fcee5a54"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#aa1b7ad9cb0189b0320f211d2fcee5a54">derivative</a></div><div class="ttdeci">dual numbers do not contain any higher order terms in their first derivative</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00058">automatic_and_symbolic_differentiation_0.txt:58</a></div></div>
<div class="ttc" id="anamespacenumbers_html_a8ae36952c7e0cc778b47b5371b3aeff1"><div class="ttname"><a href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></div><div class="ttdeci">static const unsigned int invalid_unsigned_int</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00179">types.h:179</a></div></div>
<div class="ttc" id="astep-69_8cc_html_a66a64d07b4db87c87b639bdcf7b18c82"><div class="ttname"><a href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; local_dof_indices</div><div class="ttdef"><b>Definition:</b> <a href="step-69_8cc_source.html#l00534">step-69.cc:534</a></div></div>
<div class="ttc" id="alac_2vector_8h_html"><div class="ttname"><a href="lac_2vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a177c697348e3052c514824563807ea3b"><div class="ttname"><a href="coding__conventions__0_8txt.html#a177c697348e3052c514824563807ea3b">end</a></div><div class="ttdeci">**Throughout deal we strive to keep our programming style and the kind ofinterfaces we provide as consistent as possible To this end</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00003">coding_conventions_0.txt:3</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="achunk__sparse__matrix__0_8txt_html_a59317914f0b63e3c2c7c6bd150b8ba3e"><div class="ttname"><a href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a></div><div class="ttdeci">0&lt;/tt &gt;, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. *[0.x.66] *Reinitialize the sparse matrix with the given sparsity pattern. The latter tells the matrix how many nonzero elements there need to be reserved. Regarding memory allocation, the same applies as said above. You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit(const ChunkSparsityPattern &amp;) is not called with a new sparsity structure. The elements of the matrix are set to zero by this function. *[0.x.67] *Release all memory and return to a state just like after having called the default constructor. It also forgets the sparsity pattern it was previously tied to. *[0.x.68] *[2.x.18] Information on the matrix *[0.x.69] *Return whether the object is empty. It is empty if either both dimensions are zero or no ChunkSparsityPattern is associated. *[0.x.70] *Return the dimension of the codomain(or range) space. Note that the matrix is of dimension[2.x.19] . *[0.x.71] *Return the dimension of the domain space. Note that the matrix is of dimension[2.x.20] . *[0.x.72] *Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern matrix</div><div class="ttdef"><b>Definition:</b> <a href="chunk__sparse__matrix__0_8txt_source.html#l00156">chunk_sparse_matrix_0.txt:156</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ZeroFunction_html"><div class="ttname"><a href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00516">function.h:516</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_ad3b9cdeadeb3bcdb52af5db70c041a6e"><div class="ttname"><a href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **Constructor Takes all data stored in MatrixFree If applied to problems with more than one finite element or more than one quadrature formula selected during construction of[2.x.343] the appropriate component can be selected by the optional arguments[2.x.344] matrix_free Data object that contains all data[2.x.345] dof_no If matrix_free was set up with multiple DoFHandler this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.346] quad_no If matrix_free was set up with multiple Quadrature this parameter selects the appropriate number of the quadrature formula[2.x.347] first_selected_component If the dof_handler selected by dof_no uses an FESystem consisting of more than one this parameter allows for selecting the component where the current evaluation routine should start Note that one evaluator does not support combining different shape functions in different components In other the same base element of a FESystem needs to be set for the components between[2.x.348] and[2.x.349][2.x.350] active_fe_index If matrix_free was set up with DoFHandler objects with[2.x.351] this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.352] active_quad_index If matrix_free was set up with[2.x.353] this parameter selects the appropriate number of the quadrature formula **Constructor Takes all data stored in MatrixFree for a given cell which allows to automatically identify the active_fe_index and active_quad_index in case of a p adaptive strategy The rest of the arguments are the same as in the constructor above **Constructor that comes with reduced functionality and works similar as FEValues The arguments are similar to the ones passed to the constructor of with the notable difference that FEEvaluation expects a one dimensional quadrature instead of a[2.x.354] dimensional one The finite element can be both scalar or vector but this method always only selects a scalar base element at a the optional argument[2.x.356] allows to specify the index of the base element to be used for evaluation Note that the internal data structures always assume that the base element is non primitive are not supported currently As known from a call to the reinit method with a[2.x.357] is necessary to make the geometry and degrees of freedom of the current class known::If the iterator includes DoFHandler the initialization allows to also read from or write to vectors in the standard way for[2.x.359] types for one cell at a time this approach is much slower than the path with MatrixFree with MPI since index translation has to be done As only one cell at a time is this method does not vectorize over several but only possibly within the element if the evaluate integrate routines are combined inside user an object of type i the underlying mapping and quadrature points do only need to be evaluated once Make sure to not pass an optional object around when you intend to use the FEEvaluation object in parallel to the given one because otherwise the intended sharing may create race conditions **Copy constructor If FEEvaluationBase was constructed from a fe</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00555">fe_evaluation_0.txt:555</a></div></div>
<div class="ttc" id="anamespaceSUNDIALS_html_aa047727a4eb951da92db647e12adb153"><div class="ttname"><a href="namespaceSUNDIALS.html#aa047727a4eb951da92db647e12adb153">SUNDIALS::DeclException1</a></div><div class="ttdeci">DeclException1(ExcARKodeError, int,&lt;&lt; &quot;One of the SUNDIALS ARKode internal functions &quot;&lt;&lt; &quot; returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;)</div></div>
<div class="ttc" id="aclassFEValuesBase_html_a807c3049bfe81743fc0f237dfc2fbdea"><div class="ttname"><a href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">FEValuesBase::n_quadrature_points</a></div><div class="ttdeci">const unsigned int n_quadrature_points</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l02405">fe_values.h:2405</a></div></div>
<div class="ttc" id="aclassFEValuesBase_html_ab123e5da03736be4977c76fbcb6a2e37"><div class="ttname"><a href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">FEValuesBase::quadrature_point</a></div><div class="ttdeci">const Point&lt; spacedim &gt; &amp; quadrature_point(const unsigned int q) const</div></div>
<div class="ttc" id="atable__handler__0_8txt_html_a61e9964f9093088848525ca172895749"><div class="ttname"><a href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a></div><div class="ttdeci">the ConvergenceTable class does something like this *To support both the TableHandler class has a property called[1.x.4] By auto fill mode is but it can be enabled by calling set_auto_fill_mode(). If auto-fill mode is enabled we use the following algorithm call it *[2.x.18] ***If[2.x.19] then we add[2.x.20] copies of the object[2.x.21] to this column is the data type of the given[2.x.23] is a numeric then[2.x.24] is[2.x.25] is the empty string *[2.x.26] ***Add the given value to this column *Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column In other if we have skipped previous invocations of then the padding will enter default values into this column *The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step</div><div class="ttdef"><b>Definition:</b> <a href="table__handler__0_8txt_source.html#l00070">table_handler_0.txt:70</a></div></div>
<div class="ttc" id="aclassQuadrature_html_af9f7d82770fa8126e19113f3e3db755b"><div class="ttname"><a href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">Quadrature::size</a></div><div class="ttdeci">unsigned int size() const</div></div>
<div class="ttc" id="aclassPreconditionSSOR_html"><div class="ttname"><a href="classPreconditionSSOR.html">PreconditionSSOR</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2precondition_8h_source.html#l00699">precondition.h:699</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_adad35057b6e70ae37d4abe7878683d90"><div class="ttname"><a href="coding__conventions__0_8txt.html#adad35057b6e70ae37d4abe7878683d90">face</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per the child indices of the child cells adjacent to face</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function&lt; dim &gt;</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="adata__out__base__0_8txt_html_ab82e308c7116a3c0e36ead8285942aad"><div class="ttname"><a href="data__out__base__0_8txt.html#ab82e308c7116a3c0e36ead8285942aad">vertices</a></div><div class="ttdeci">several of the example programs show how to do this **All functions take a parameter which is a structure of type&lt; tt &gt; where&lt; tt &gt; X&lt;/tt &gt; is the name of the output format To find out what flags are presently read the documentation of the different structures *Note that usually the output formats used for scientific visualization programs have no or very few like Postscript or Povray need to be given a lot more since there the output file has to contain all details of the light etc **An abstraction layer has been introduced to facilitate coding backends for additional visualization tools It is applicable for data formats separating the information into a field of vertices</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base__0_8txt_source.html#l00029">data_out_base_0.txt:29</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a3eb2ad97e22e5edf45cbc97570908143"><div class="ttname"><a href="multithreading__0_8txt.html#a3eb2ad97e22e5edf45cbc97570908143">tasks</a></div><div class="ttdeci">if only one is the scheduler would first completely execute task before doing or the other way around This model is able to execute much more efficiently in particular if a large number of tasks is available for see for example the discussion below in section[2.x.20] Abstractions for tasks</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00034">multithreading_0.txt:34</a></div></div>
<div class="ttc" id="agrid_2manifold__lib__0_8txt_html_a274eab5e4d4c64f33343b97a843e51ca"><div class="ttname"><a href="grid_2manifold__lib__0_8txt.html#a274eab5e4d4c64f33343b97a843e51ca">descriptor</a></div><div class="ttdeci">*Manifold description for a polar coordinate system *You can use this Manifold object to describe any hypersphere or hyperdisc in two or three both as a co dimension one manifold descriptor or as co dimension zero manifold descriptor</div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib__0_8txt_source.html#l00003">manifold_lib_0.txt:3</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00052">solver_control.h:52</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_ad83e6d423f9ad63243b1465081bde416"><div class="ttname"><a href="iterators__0_8txt.html#ad83e6d423f9ad63243b1465081bde416">begin_active</a></div><div class="ttdeci">****deal II has several classes which are understood conceptually asmeshes Apart from the obvious these for DoFHandler and[2.x.2] All of those define a setof allowing the user to traverse the whole i e theset of etc that comprise the or portions ofit These iterators are all in a sense derived from the TriaIteratorclass the template signature of TriaIterator is this type represents something like a pointer to an objectrepresented by the[2.x.3] class you will not use theactual class names spelled out directly but employ one of the typedefsprovided by the mesh classes such as&lt; code &gt; typename[2.x.4] Before going into let usfirst discuss the concept of before delving into what the accessorsdo *As usual in just as are incremented to the nextelement using&lt; tt &gt; respectively Since there are a number of differentiterators there is actually a whole family of such suchas&lt; tt &gt; begin_active()&lt;/tt &gt;</div></div>
<div class="ttc" id="aclassFEFaceValues_html"><div class="ttname"><a href="classFEFaceValues.html">FEFaceValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="astructSubCellData_html"><div class="ttname"><a href="structSubCellData.html">SubCellData</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria__description_8h_source.html#l00200">tria_description.h:200</a></div></div>
<div class="ttc" id="agroup__CPP11_html_gaace8c98aca00e7e48a619bb5e08084aa"><div class="ttname"><a href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a></div><div class="ttdeci">IteratorRange&lt; active_cell_iterator &gt; active_cell_iterators() const</div></div>
<div class="ttc" id="anamespaceinternal_1_1TriangulationImplementation_html_a9f815604be9b560fea00beef8d720480"><div class="ttname"><a href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">internal::TriangulationImplementation::n_cells</a></div><div class="ttdeci">unsigned int n_cells(const internal::TriangulationImplementation::NumberCache&lt; 1 &gt; &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l12588">tria.cc:12588</a></div></div>
<div class="ttc" id="anamespaceEuler__DG_html_a143bc64b6fa6ced9f11c148a2af3ff09"><div class="ttname"><a href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Euler_DG::Number</a></div><div class="ttdeci">double Number</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00064">step-67.cc:64</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="amg__0_8txt_html_a1dadc108ee1520717957789de4b76416"><div class="ttname"><a href="mg__0_8txt.html#a1dadc108ee1520717957789de4b76416">cycle</a></div><div class="ttdeci">****Classes that have to do with multigrid algorithms *The main class with implementation of the multigrid scheme is Multigrid with its function[2.x.1] It uses the abstract following classes in order to perform the multigrid cycle</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00007">mg_0.txt:7</a></div></div>
<div class="ttc" id="aclassThreads_1_1Task_html_a9aed8f99d2b88bd0d6cfff95e38c3ac7"><div class="ttname"><a href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">Threads::Task::join</a></div><div class="ttdeci">void join() const</div><div class="ttdef"><b>Definition:</b> <a href="base_2thread__management_8h_source.html#l01074">thread_management.h:1074</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aclassQuadrature_html"><div class="ttname"><a href="classQuadrature.html">Quadrature</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2quadrature_8h_source.html#l00075">quadrature.h:75</a></div></div>
<div class="ttc" id="aclassGridOut_html"><div class="ttname"><a href="classGridOut.html">GridOut</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__out_8h_source.html#l01050">grid_out.h:1050</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a33b522422da89e5c080e7405ad49d7c7"><div class="ttname"><a href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElementData::n_dofs_per_cell</a></div><div class="ttdeci">unsigned int n_dofs_per_cell() const</div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_af9f808a82e8c618e2e7a19dd08a9eae3"><div class="ttname"><a href="functions__0_8txt.html#af9f808a82e8c618e2e7a19dd08a9eae3">value</a></div><div class="ttdeci">****Functions are used in various places in deal for example to describe boundary coefficients in forcing or exact solutions Since closed form expressions for equations are often hard to pass along as function deal II uses the Function base class to describe these objects Essentially the interface of this base class requires derived classes to implement the ability to return the value of a function at one or a list of particular locations and function objects can then be used by algorithms like[2.x.1][2.x.2] and other functions *Some functions are needed again and and are therefore already provided in deal II This includes a function with a constant value</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00007">functions_0.txt:7</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="alac_2sparse__matrix_8h_html"><div class="ttname"><a href="lac_2sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_ae3fd76f0fcd93dcbcc9df2df2c6028fb"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#ae3fd76f0fcd93dcbcc9df2df2c6028fb">this</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications in impossible to get right Higher derivatives are even more impossible to do without computer aid Automatic or symbolic differentiation is a way out of this</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a1611aa37f754086388ca76bcd421cce5"><div class="ttname"><a href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a></div><div class="ttdeci">void close()</div></div>
<div class="ttc" id="aclassDoFHandler_html_ac1fedeb50b5f03b13d8b69f86e33f726"><div class="ttname"><a href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">DoFHandler::get_fe</a></div><div class="ttdeci">const FiniteElement&lt; dim, spacedim &gt; &amp; get_fe(const unsigned int index=0) const</div></div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01699">exceptions.h:1699</a></div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="agrid_2grid__generator_8h_html"><div class="ttname"><a href="grid_2grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="astructStep14_1_1Framework_1_1ProblemDescription_html"><div class="ttname"><a href="structStep14_1_1Framework_1_1ProblemDescription.html">Step14::Framework::ProblemDescription</a></div><div class="ttdef"><b>Definition:</b> <a href="step-14_8cc_source.html#l01815">step-14.cc:1815</a></div></div>
<div class="ttc" id="anamespaceIteratorState_html_a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd"><div class="ttname"><a href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507aee11931a347d1d476966f5dcae24a6fd">IteratorState::valid</a></div><div class="ttdeci">@ valid</div><div class="ttdoc">Iterator points to a valid object.</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria__iterator__base_8h_source.html#l00042">tria_iterator_base.h:42</a></div></div>
<div class="ttc" id="amutable__bind__0_8txt_html_a02b3f6970317af2b828ff6864eabf67f"><div class="ttname"><a href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">operator()</a></div><div class="ttdeci">*A version of[2.x.0] that binds all arguments of a function pointer to a stored and allows you to update the tuple between calls An example usage of this class is through the helper function based on its with their reference const and attributes removed Only copy constructible objects are allowed as function arguments If you need to keep some references you may wrap your function into a lambda and each arguments separately **Construct a MutableBind object specifying the and the arguments as a tuple **Construct a MutableBind object specifying only the function By the arguments are left to their default constructor values **Call the original passing as arguments the elements of the tuple of bound arguments **Set the arguments to use in[2.x.2] for next time operator()() is called</div></div>
<div class="ttc" id="atable__0_8txt_html_aa889bb34debce4db8c9ace2f875bdf0d"><div class="ttname"><a href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a></div><div class="ttdeci">tables that store three or more dimensional then there is nothing you can do about the size of these if your program is parallelized via then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file This is inefficient from two the data stored on every process is the and while every process needs to be able to read from a it is not necessary that every process stores its own either by re creating a copy of the table in the other processes memory space if by creating copies in shared memory once for all processes located on each of the machines used by the MPI job ******Integer type used to count the number of elements in this container **Default constructor Set all dimensions to zero **Constructor Initialize the array with the given dimensions in each index component **Constructor Initialize the array with the given dimensions in each index component</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00083">table_0.txt:83</a></div></div>
<div class="ttc" id="aclassDoFHandler_html_aa5b8d3c4b9deb0774dde5c2851e07e1e"><div class="ttname"><a href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">DoFHandler::n_dofs</a></div><div class="ttdeci">types::global_dof_index n_dofs() const</div></div>
<div class="ttc" id="afunction__0_8txt_html_a4f780342f2d5d632f82cf7fd90158a66"><div class="ttname"><a href="function__0_8txt.html#a4f780342f2d5d632f82cf7fd90158a66">size</a></div><div class="ttdeci">it defaults to i e the first component **Return all components of a vector valued function at a given point&lt; tt &gt; values&lt;/tt &gt; shall have the right size i e **Set&lt; tt &gt; values&lt;/tt &gt; to the point values of the specified component of the function at the&lt; tt &gt; points&lt;/tt &gt; It is assumed that&lt; tt &gt; values&lt;/tt &gt; already has the right size</div><div class="ttdef"><b>Definition:</b> <a href="function__0_8txt_source.html#l00052">function_0.txt:52</a></div></div>
<div class="ttc" id="astructStep14_1_1Framework_1_1ProblemDescription_html_a853a4e95b17bc2222c7bbb12443827c3a0d6f6c3468a390b4a47c39d27af21454"><div class="ttname"><a href="structStep14_1_1Framework_1_1ProblemDescription.html#a853a4e95b17bc2222c7bbb12443827c3a0d6f6c3468a390b4a47c39d27af21454">Step14::Framework::ProblemDescription::dual_weighted_error_estimator</a></div><div class="ttdeci">@ dual_weighted_error_estimator</div><div class="ttdef"><b>Definition:</b> <a href="step-14_8cc_source.html#l01824">step-14.cc:1824</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a02f5aa616d7b0799c538fe77d6c6c795"><div class="ttname"><a href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a></div><div class="ttdeci">i e</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00028">coding_conventions_0.txt:28</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
