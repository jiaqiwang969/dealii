<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceLocalIntegrators.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LocalIntegrators Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">LocalIntegrators Namespace Reference<div class="ingroups"><a class="el" href="group__Integrators.html">Integrators A collection of namespaces and functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Library of integrals over cells and faces This namespace contains application specific local integrals for bilinear forms, forms and error estimates. It is a collection of functions organized into namespaces devoted to certain applications. For instance, the namespace <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html" title="Local integrators related to the Laplacian and its DG formulations.">Laplace</a> contains functions for computing cell matrices and cell residuals for the Laplacian operator, as well as functions for the weak boundary conditions by Nitsche or the interior penalty discontinuous Galerkin method. The namespace <a class="el" href="namespaceLocalIntegrators_1_1Maxwell.html" title="Local integrators related to curl operators and their traces. We use the following conventions for cu...">Maxwell</a> does the same for curl-curl type problems. The namespace <a class="el" href="namespaceLocalIntegrators_1_1L2.html" title="Local integrators related to L2-inner products.">L2</a> contains functions for mass matrices and <em>L<sup>2</sup></em>-inner products.  
<a href="namespaceLocalIntegrators.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Advection"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html">Advection</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Advection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to advection along a vector field and its DG formulations All advection operators depend on an advection velocity denoted by <b>w</b> in the formulas below. It is denoted as <code>velocity</code> in the parameter lists. The functions <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix()</a> and both <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a32e7c84d8a003be777ea86194920c907">upwind_value_matrix()</a> are taking the equation in weak form, that is, the directional derivative is on the test function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Divergence"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html">Divergence</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Divergence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to the divergence operator and its trace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Elasticity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Elasticity.html">Elasticity</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Elasticity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to elasticity problems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1GradDiv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1GradDiv.html">GradDiv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1L2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1L2.html">L2</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1L2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to <em>L<sup>2</sup></em>-inner products. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Laplace"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Laplace.html">Laplace</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Laplace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to the Laplacian and its DG formulations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Maxwell"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Maxwell.html">Maxwell</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Maxwell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local integrators related to curl operators and their traces. We use the following conventions for curl operators. First, in three space dimensions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLocalIntegrators_1_1Patches"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Patches.html">Patches</a></td></tr>
<tr class="memdesc:namespaceLocalIntegrators_1_1Patches"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrators writing patches with values in quadrature points. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Library of integrals over cells and faces This namespace contains application specific local integrals for bilinear forms, forms and error estimates. It is a collection of functions organized into namespaces devoted to certain applications. For instance, the namespace <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html" title="Local integrators related to the Laplacian and its DG formulations.">Laplace</a> contains functions for computing cell matrices and cell residuals for the Laplacian operator, as well as functions for the weak boundary conditions by Nitsche or the interior penalty discontinuous Galerkin method. The namespace <a class="el" href="namespaceLocalIntegrators_1_1Maxwell.html" title="Local integrators related to curl operators and their traces. We use the following conventions for cu...">Maxwell</a> does the same for curl-curl type problems. The namespace <a class="el" href="namespaceLocalIntegrators_1_1L2.html" title="Local integrators related to L2-inner products.">L2</a> contains functions for mass matrices and <em>L<sup>2</sup></em>-inner products. </p>
<p>Library of integrals over cells and faces.</p>
<h3>Notational conventions</h3>
<p>In most cases, the action of a function in this namespace can be described by a single integral. We distinguish between integrals over cells <em>Z</em> and over faces <em>F</em>. If an integral is denoted as </p><p class="formulaDsp">
\[ \int_Z u \otimes v \,dx, \]
</p>
<p> it will yield the following results, depending on the type of operation </p><ul>
<li>
If the function returns a matrix, the entry at position <em>(i,j)</em> will be the integrated product of test function <em>v<sub>i</sub></em> and trial function <em>u<sub>j</sub></em> (note the reversion of indices)  </li>
<li>
If the function returns a vector, then the vector entry at position <em>i</em> will be the integrated product of the given function <em>u</em> with the test function <em>v<sub>i</sub></em>.  </li>
<li>
If the function returns a number, then this number is the integral of the two given functions <em>u</em> and <em>v</em>. </li>
</ul>
<p>We will use regular cursive symbols \(u\) for scalars and bold symbols \(\mathbf u\) for vectors. Test functions are always <em>v</em> and trial functions are always <em>u</em>. Parameters are Greek and the face normal vectors are \(\mathbf n = \mathbf n_1 = -\mathbf n_2\) . </p><h3>Signature of functions</h3>
<p><a class="el" href="namespaceFunctions.html">Functions</a> in this namespace follow a generic signature. In the simplest case, you have two related functions</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> (</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>&amp; <a class="code" href="reordering__0_8txt.html#a35b76b360e1396f96a883922476f6d30">M</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a>&amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a> = 1.);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> (</div>
<div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>* <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a>&amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;&amp; <a class="code" href="parameter__handler__0_8txt.html#a141ebbaf93668d52831bbd4ec5a1e949">input</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a> = 1.);</div>
</div><!-- fragment --><p>There is typically a pair of functions for the same operator, the function <code>cell_residual</code> implementing the mapping of the operator from the finite element space into its dual, and the function <code>cell_matrix</code> generating the bilinear form corresponding to the Frechet derivative of <code>cell_residual</code>. The first argument of these functions is the return type, which is </p><ul>
<li>
<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt; for matrices </li>
<li>
<a class="el" href="classBlockVector.html">BlockVector</a>&amp;ltdouble&gt; for vectors </li>
</ul>
<p>The next argument is the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> object representing the finite element for integration. If the integrated operator maps from one finite element space into the dual of another (for instance an off-diagonal matrix in a block system), then first the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> for the trial space and after this the one for the test space are specified. This list is followed by the set of required data in the order </p><ol>
<li>
Data vectors from finite element functions </li>
<li>
Data vectors from other objects </li>
<li>
Additional data </li>
<li>
A factor which is multiplied with the whole result </li>
</ol>
<h3>Usage</h3>
<p>The local integrators can be used wherever a local integration loop would have been implemented instead. The following example is from the implementation of a Stokes solver, using MeshWorker::Assembler::LocalBlocksToGlobalBlocks. The matrices are </p><ul>
<li>
0: The vector Laplacian for the velocity (here with a vector valued element) </li>
<li>
1: The divergence matrix </li>
<li>
2: The pressure mass matrix used in the preconditioner </li>
</ul>
<p>With these matrices, the function called by <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a> could be written like</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>dealii::LocalIntegrators;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">MatrixIntegrator&lt;dim&gt;::cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a>         &amp;dinfo,</div>
<div class="line">                               <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)</div>
<div class="line">{</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">Laplace::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                      info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0));</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#ae2c29fed2a2e800bbb2a888d2f0daedb">Divergence::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(1,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                         info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div>
<div class="line">                         info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(1));</div>
<div class="line"><a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">L2::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(2,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                 info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(1));</div>
<div class="line">}</div>
</div><!-- fragment --><p> See <a class="el" href="step_39.html">step-39</a> for a worked out example of this code.</p>
<p>This namespace contains application specific local integrals for bilinear forms, forms and error estimates. It is a collection of functions organized into namespaces devoted to certain applications. For instance, the namespace <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html" title="Local integrators related to the Laplacian and its DG formulations.">Laplace</a> contains functions for computing cell matrices and cell residuals for the Laplacian operator, as well as functions for the weak boundary conditions by Nitsche or the interior penalty discontinuous Galerkin method. The namespace <a class="el" href="namespaceLocalIntegrators_1_1Maxwell.html" title="Local integrators related to curl operators and their traces. We use the following conventions for cu...">Maxwell</a> does the same for curl-curl type problems.</p>
<p>The namespace <a class="el" href="namespaceLocalIntegrators_1_1L2.html" title="Local integrators related to L2-inner products.">L2</a> contains functions for mass matrices and <em>L<sup>2</sup></em>-inner products.</p>
<h3>Notational conventions</h3>
<p>In most cases, the action of a function in this namespace can be described by a single integral. We distinguish between integrals over cells <em>Z</em> and over faces <em>F</em>. If an integral is denoted as </p><p class="formulaDsp">
\[ \int_Z u \otimes v \,dx, \]
</p>
<p> it will yield the following results, depending on the type of operation </p><ul>
<li>
If the function returns a matrix, the entry at position <em>(i,j)</em> will be the integrated product of test function <em>v<sub>i</sub></em> and trial function <em>u<sub>j</sub></em> (note the reversion of indices) </li>
<li>
If the function returns a vector, then the vector entry at position <em>i</em> will be the integrated product of the given function <em>u</em> with the test function <em>v<sub>i</sub></em>. </li>
<li>
If the function returns a number, then this number is the integral of the two given functions <em>u</em> and <em>v</em>. </li>
</ul>
<p>We will use regular cursive symbols \(u\) for scalars and bold symbols \(\mathbf u\) for vectors. Test functions are always <em>v</em> and trial functions are always <em>u</em>. Parameters are Greek and the face normal vectors are \(\mathbf n = \mathbf n_1 = -\mathbf n_2\).</p>
<h3>Signature of functions</h3>
<p><a class="el" href="namespaceFunctions.html">Functions</a> in this namespace follow a generic signature. In the simplest case, you have two related functions </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a> (</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>&amp; <a class="code" href="reordering__0_8txt.html#a35b76b360e1396f96a883922476f6d30">M</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a>&amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a> = 1.);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> (</div>
<div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>* <a class="code" href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a>&amp; <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;&amp; <a class="code" href="parameter__handler__0_8txt.html#a141ebbaf93668d52831bbd4ec5a1e949">input</a>,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a> = 1.);</div>
</div><!-- fragment --><p>There is typically a pair of functions for the same operator, the function <code>cell_residual</code> implementing the mapping of the operator from the finite element space into its dual, and the function <code>cell_matrix</code> generating the bilinear form corresponding to the Frechet derivative of <code>cell_residual</code>.</p>
<p>The first argument of these functions is the return type, which is </p><ul>
<li>
<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt; for matrices </li>
<li>
<a class="el" href="classBlockVector.html">BlockVector</a>&amp;ltdouble&gt; for vectors </li>
</ul>
<p>The next argument is the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> object representing the finite element for integration. If the integrated operator maps from one finite element space into the dual of another (for instance an off-diagonal matrix in a block system), then first the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> for the trial space and after this the one for the test space are specified.</p>
<p>This list is followed by the set of required data in the order </p><ol>
<li>
Data vectors from finite element functions </li>
<li>
Data vectors from other objects </li>
<li>
Additional data </li>
<li>
A factor which is multiplied with the whole result </li>
</ol>
<h3>Usage</h3>
<p>The local integrators can be used wherever a local integration loop would have been implemented instead. The following example is from the implementation of a Stokes solver, using MeshWorker::Assembler::LocalBlocksToGlobalBlocks. The matrices are </p><ul>
<li>
0: The vector Laplacian for the velocity (here with a vector valued element) </li>
<li>
1: The divergence matrix </li>
<li>
2: The pressure mass matrix used in the preconditioner </li>
</ul>
<p>With these matrices, the function called by <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a> could be written like </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>dealii::LocalIntegrators;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">MatrixIntegrator&lt;dim&gt;::cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a>         &amp;dinfo,</div>
<div class="line">                                 <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">Laplace::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                        info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0));</div>
<div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#ae2c29fed2a2e800bbb2a888d2f0daedb">Divergence::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(1,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                           info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div>
<div class="line">                           info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(1));</div>
<div class="line">  <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">L2::cell_matrix</a> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(2,<span class="keyword">false</span>).<a class="code" href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">matrix</a>,</div>
<div class="line">                   info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(1));</div>
<div class="line">}</div>
</div><!-- fragment --><p> See <a class="el" href="step_39.html">step-39</a> for a worked out example of this code. </p>
</div></div><!-- contents -->
<div class="ttc" id="anamespaceLocalIntegrators_1_1Divergence_html_ae2c29fed2a2e800bbb2a888d2f0daedb"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Divergence.html#ae2c29fed2a2e800bbb2a888d2f0daedb">LocalIntegrators::Divergence::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const FEValuesBase&lt; dim &gt; &amp;fetest, double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="integrators_2divergence_8h_source.html#l00055">divergence.h:55</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_a141ebbaf93668d52831bbd4ec5a1e949"><div class="ttname"><a href="parameter__handler__0_8txt.html#a141ebbaf93668d52831bbd4ec5a1e949">input</a></div><div class="ttdeci">if you have code where no sensible default value for a parameter is you can then catch and ignore this exception The parameter[2.x.43] defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the for example to override an earlier default value **Attach an action to the parameter with name[2.x.46] in the current section The action needs to be a function like object that takes the value of the parameter as as well as examples The action is executed in three different even those that are not actually specified in the input the action is executed whenever the parameter with which it is associated is read from the input</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00289">parameter_handler_0.txt:289</a></div></div>
<div class="ttc" id="aclassBlockVector_html"><div class="ttname"><a href="classBlockVector.html">BlockVector&lt; double &gt;</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Laplace_html_a733b581e72bfe9d27cc59501a35bcd30"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="integrators_2laplace_8h_source.html#l00052">laplace.h:52</a></div></div>
<div class="ttc" id="aclassMeshWorker_1_1IntegrationInfo_html_a32fa7363be71ba320bcdc94f6d677843"><div class="ttname"><a href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">MeshWorker::IntegrationInfo::fe_values</a></div><div class="ttdeci">const FEValuesBase&lt; dim, spacedim &gt; &amp; fe_values() const</div><div class="ttdoc">Access to finite element.</div><div class="ttdef"><b>Definition:</b> <a href="meshworker_2integration__info_8h_source.html#l00645">integration_info.h:645</a></div></div>
<div class="ttc" id="aclassMeshWorker_1_1IntegrationInfo_html"><div class="ttname"><a href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="meshworker_2integration__info_8h_source.html#l00071">integration_info.h:71</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Advection_html_aaff3056f2b80ada5c55d8c5825932c22"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">LocalIntegrators::Advection::cell_residual</a></div><div class="ttdeci">void cell_residual(Vector&lt; double &gt; &amp;result, const FEValuesBase&lt; dim &gt; &amp;fe, const std::vector&lt; Tensor&lt; 1, dim &gt;&gt; &amp;input, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="integrators_2advection_8h_source.html#l00123">advection.h:123</a></div></div>
<div class="ttc" id="anumerical__algorithms__0_8txt_html_a852a1e245dd2de4943eeb66beeaf65b1"><div class="ttname"><a href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">vector</a></div><div class="ttdeci">****This module groups a diverse set of classes that generally implement some sort of numerical algorithm on top all the basic and finite element classes in the library They are generally unconnected to each other *Some of the like KellyErrorEstimator and act on solutions already and compute derived quantities in the first two or help transferring a set of vectors from one mesh to another *The namespaces and VectorTools provide an assortment of such as creating a Laplace projecting or interpolating a function onto the present finite element etc The difference to the functions in the DoFTools and FETools functions is that they work on the DoFTools functions only act on a given DoFHandler object without reference to a data vector</div><div class="ttdef"><b>Definition:</b> <a href="numerical__algorithms__0_8txt_source.html#l00008">numerical_algorithms_0.txt:8</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
<div class="ttc" id="avector__0_8txt_html_aaf255149898cc5cea8c1fa1e76fffe6f"><div class="ttname"><a href="vector__0_8txt.html#aaf255149898cc5cea8c1fa1e76fffe6f">v</a></div><div class="ttdeci">0 v</div><div class="ttdef"><b>Definition:</b> <a href="vector__0_8txt_source.html#l00062">vector_0.txt:62</a></div></div>
<div class="ttc" id="aclassMeshWorker_1_1LocalResults_html_a06c5d817ce47a4c26966df1cdcebeac4"><div class="ttname"><a href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">MeshWorker::LocalResults&lt; double &gt;::matrix</a></div><div class="ttdeci">MatrixBlock&lt; FullMatrix&lt; double &gt; &gt; &amp; matrix(const unsigned int i, const bool external=false)</div><div class="ttdef"><b>Definition:</b> <a href="meshworker_2local__results_8h_source.html#l00549">local_results.h:549</a></div></div>
<div class="ttc" id="aadvection__0_8txt_html_a79a3cbbb7583dd309bf1b14dc20895b6"><div class="ttname"><a href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a></div><div class="ttdeci">**its DG formulations All advection operators depend on an advection velocity denoted by[1.x.0] in the formulas below It is denoted as&lt; tt &gt; velocity&lt;/tt &gt; in the parameter lists The functions cell_matrix() and both upwind_value_matrix() are taking the equation in weak form</div></div>
<div class="ttc" id="aclassFEValuesBase_html"><div class="ttname"><a href="classFEValuesBase.html">FEValuesBase</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00036">fe.h:36</a></div></div>
<div class="ttc" id="asparse__decomposition__0_8txt_html_aa36e69f7b51d00cbf24c899c1490950c"><div class="ttname"><a href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a></div><div class="ttdeci">Preconditioners *[2.x.1] **Abstract base class for incomplete decompositions of a sparse matrix into sparse factors This class can t be used by itself but only as the base class of derived classes that actually implement particular decompositions such as SparseILU or SparseMIC *The decomposition is stored as a sparse matrix which is why this class is derived from the SparseMatrix Since it is not a matrix in the usual the derivation is&lt; tt &gt; protected&lt;/tt &gt; rather than&lt; tt &gt; public&lt;/tt &gt; ***Sparse decompositions are frequently used with additional fill i the sparsity structure of the decomposition is denser than that of the matrix to be decomposed The i e the sparsity pattern of the decomposition is a superset of the sparsity pattern in the original matrix *Such fill in can be accomplished by various one of which is the copy constructor of the SparsityPattern class that allows the addition of side diagonals to a given sparsity structure ***While objects of this class can not be used derived classes such as SparseILU and SparseMIC can be used in the usual form as preconditioners For this each it copies the sparsity of[2.x.3] and adds a specific number of extra off diagonal entries specified by *[2.x.4] By setting[2.x.5] the sparsity is not recreated but the sparsity of the previous as for example several Newton iteration steps on the same triangulation The default is *[2.x.6] It is possible to give a user defined sparsity to[2.x.7] no sparsity is created but[2.x.8] is used to store the decomposed matrix For restrictions on the sparsity see section Fill in above ***It is enough to override the like the true or the Cholesky decomposition if that decomposition needs fine tuned diagonal strengthening on a per row it may override the but only its derived classes **Deletes all member variables Leaves the class in the state that it had directly after calling the constructor **Parameters for SparseDecomposition **Constructor For the parameters see below **times the sum of absolute row entries is added to the diagonal entries Per this value is i e the diagonal is not strengthened **By the[2.x.10] function creates its own sparsity This sparsity has the same SparsityPattern as[2.x.11] with some extra off diagonals the number of which is specified by[2.x.12] The user can give a SparsityPattern to[2.x.13] Then this sparsity is used and the[2.x.14] argument is ignored **If this flag is true the as for example several Newton iteration steps on the same triangulation **When a SparsityPattern is given to this the as well as filtering out some elements in the matrix **This function needs to be called before an object of this class is used as preconditioner For more detail about possible parameters see the class documentation and the documentation of the[2.x.17] class According to this function creates a new SparsityPattern or keeps the previous sparsity or takes the sparsity given by the user to[2.x.19] this function performs the LU decomposition After this function is called the preconditioner is ready to be determines the strengthening factor(through get_strengthen_diagonal()) sf and multiplies the diagonal entry with[2.x.28] . *[0.x.23] *In the decomposition phase</div></div>
<div class="ttc" id="areordering__0_8txt_html_a35b76b360e1396f96a883922476f6d30"><div class="ttname"><a href="reordering__0_8txt.html#a35b76b360e1396f96a883922476f6d30">M</a></div><div class="ttdeci">if it is not then it aborts in linear time as well *Both algorithms are described in the paper On orienting edges of unstructured two and three dimensional R M W W L ACM Transactions on Mathematical A preprint is available as *[1.x.19] **Prior to the implementation of the algorithms described we used a branch and cut algorithm initially implemented in by Wolfgang Bangerth Although it is no longer here is how it and why it doesn t always work for large meshes since its run time can be exponential in bad cases *The first observation is that although there are problems are usually local For in the second example mentioned if we had numbered the cells in a way that neighboring cells have similar cell then the amount of backtracking needed is greatly reduced in the implementation of the the first step is to renumber the cells in a Cuthill McKee and so on this represents finding zones of cells consecutively further away from the initial cells and number them in this front marching way This already greatly improves locality of problems and consequently reduced the necessary amount of backtracking *The second point is that we can use some methods to prune the which usually lead to a valid orientation of all cells very quickly *The first such method is based on the observation that if we fail to insert one cell with number then this may not be due to cell N unless N is a direct neighbor of N The reason is for M</div><div class="ttdef"><b>Definition:</b> <a href="reordering__0_8txt_source.html#l00112">reordering_0.txt:112</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_ad3b9cdeadeb3bcdb52af5db70c041a6e"><div class="ttname"><a href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **Constructor Takes all data stored in MatrixFree If applied to problems with more than one finite element or more than one quadrature formula selected during construction of[2.x.343] the appropriate component can be selected by the optional arguments[2.x.344] matrix_free Data object that contains all data[2.x.345] dof_no If matrix_free was set up with multiple DoFHandler this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.346] quad_no If matrix_free was set up with multiple Quadrature this parameter selects the appropriate number of the quadrature formula[2.x.347] first_selected_component If the dof_handler selected by dof_no uses an FESystem consisting of more than one this parameter allows for selecting the component where the current evaluation routine should start Note that one evaluator does not support combining different shape functions in different components In other the same base element of a FESystem needs to be set for the components between[2.x.348] and[2.x.349][2.x.350] active_fe_index If matrix_free was set up with DoFHandler objects with[2.x.351] this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.352] active_quad_index If matrix_free was set up with[2.x.353] this parameter selects the appropriate number of the quadrature formula **Constructor Takes all data stored in MatrixFree for a given cell which allows to automatically identify the active_fe_index and active_quad_index in case of a p adaptive strategy The rest of the arguments are the same as in the constructor above **Constructor that comes with reduced functionality and works similar as FEValues The arguments are similar to the ones passed to the constructor of with the notable difference that FEEvaluation expects a one dimensional quadrature instead of a[2.x.354] dimensional one The finite element can be both scalar or vector but this method always only selects a scalar base element at a the optional argument[2.x.356] allows to specify the index of the base element to be used for evaluation Note that the internal data structures always assume that the base element is non primitive are not supported currently As known from a call to the reinit method with a[2.x.357] is necessary to make the geometry and degrees of freedom of the current class known::If the iterator includes DoFHandler the initialization allows to also read from or write to vectors in the standard way for[2.x.359] types for one cell at a time this approach is much slower than the path with MatrixFree with MPI since index translation has to be done As only one cell at a time is this method does not vectorize over several but only possibly within the element if the evaluate integrate routines are combined inside user an object of type i the underlying mapping and quadrature points do only need to be evaluated once Make sure to not pass an optional object around when you intend to use the FEEvaluation object in parallel to the given one because otherwise the intended sharing may create race conditions **Copy constructor If FEEvaluationBase was constructed from a fe</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00555">fe_evaluation_0.txt:555</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="aclassMatrixBlock_html_a33610e6dfbd57d6ff0aa23e8582676bf"><div class="ttname"><a href="classMatrixBlock.html#a33610e6dfbd57d6ff0aa23e8582676bf">MatrixBlock::matrix</a></div><div class="ttdeci">MatrixType matrix</div><div class="ttdef"><b>Definition:</b> <a href="lac_2matrix__block_8h_source.html#l00326">matrix_block.h:326</a></div></div>
<div class="ttc" id="aclassMeshWorker_1_1DoFInfo_html"><div class="ttname"><a href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="meshworker_2dof__info_8h_source.html#l00069">dof_info.h:69</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
