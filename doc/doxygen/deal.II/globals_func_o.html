<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/globals_func_o.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: File Members</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="contents">
&#160;

<h3><a id="index_o"></a>- o -</h3><ul>
<li>O()
: <a class="el" href="base_2utilities__0_8txt.html#a327ba1a6237ec37b823125ef77868fee">utilities_0.txt</a>
, <a class="el" href="particle__handler__0_8txt.html#a5c33cce7677dfe3df0e2e6b7aede83b6">particle_handler_0.txt</a>
</li>
<li>object()
: <a class="el" href="data__out__base__0_8txt.html#a6e099a8ccb314750a9d7e4ab6887ffc9">data_out_base_0.txt</a>
, <a class="el" href="fe_2fe__values__0_8txt.html#a25ceede01919505daef588a7eba77ddc">fe_values_0.txt</a>
, <a class="el" href="cuda__matrix__free__0_8txt.html#ac87b0d368d3ee7de4bbf14dbdb75c86b">cuda_matrix_free_0.txt</a>
, <a class="el" href="parameter__handler__0_8txt.html#aac35764232639bb358eaa5ffa956f5fd">parameter_handler_0.txt</a>
, <a class="el" href="simple__0_8txt.html#a255589c4bb313077fb9f31020ebbd920">simple_0.txt</a>
, <a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">particle_0.txt</a>
, <a class="el" href="parsed__convergence__table__0_8txt.html#a1ffde06d4882b8e1b3b35bf500d8cd0f">parsed_convergence_table_0.txt</a>
, <a class="el" href="dof__faces__0_8txt.html#ac52db78746a9d830c32d5c1aa35b1b2a">dof_faces_0.txt</a>
</li>
<li>objects()
: <a class="el" href="history__0_8txt.html#ab2a23aad3c848cc83759e2c8253bf4fd">history_0.txt</a>
, <a class="el" href="dofs__0_8txt.html#ad13ea7bfec9f556e94f4d5786ffbde48">dofs_0.txt</a>
, <a class="el" href="reordering__0_8txt.html#acb1d751b91ceb32669df21af6c70f3b2">reordering_0.txt</a>
, <a class="el" href="A-headers_2utilities__0_8txt.html#a3f2e2725d7dec240142b882c03101481">utilities_0.txt</a>
, <a class="el" href="tensor__accessors__0_8txt.html#ad7fe8c92914fe167dae28999386fedeb">tensor_accessors_0.txt</a>
</li>
<li>octree()
: <a class="el" href="iterators__0_8txt.html#ab22a9760338ba5bdab41781440461e05">iterators_0.txt</a>
</li>
<li>of()
: <a class="el" href="thread__management__0_8txt.html#a034bd0e5d923b2bd9059f245498ec367">thread_management_0.txt</a>
, <a class="el" href="distributed_2grid__refinement__0_8txt.html#a9453de029de6d46beecad963d866ac51">grid_refinement_0.txt</a>
, <a class="el" href="repartitioning__policy__tools__0_8txt.html#a58a7f38a2404881669d67da63660e148">repartitioning_policy_tools_0.txt</a>
, <a class="el" href="dof__tools__0_8txt.html#a30dbd456562275778d32035b6096319d">dof_tools_0.txt</a>
, <a class="el" href="mapping__q1__0_8txt.html#ab385ce3d77d734d3123a23a90cd8c373">mapping_q1_0.txt</a>
, <a class="el" href="grid_2manifold__0_8txt.html#a9aa0d9ef179bccd9b4095c016e6329d4">manifold_0.txt</a>
, <a class="el" href="fe__collection__0_8txt.html#a4e0582155709df67a14eeafc2d4621e7">fe_collection_0.txt</a>
, <a class="el" href="mapping__collection__0_8txt.html#abd79df5d3988a55fadb29ccba9eaa416">mapping_collection_0.txt</a>
, <a class="el" href="parpack__solver__0_8txt.html#a59016ec751e9f7cbf7451927a31a3187">parpack_solver_0.txt</a>
, <a class="el" href="precondition__block__base__0_8txt.html#af28d937e3557ac142863618a5cfef47b">precondition_block_base_0.txt</a>
, <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">copy_data_0.txt</a>
</li>
<li>omatcopy()
: <a class="el" href="lac_2blas__extension__templates_8h.html#a89ad3a4b3234ee9d516ef0ac222b22ea">blas_extension_templates.h</a>
</li>
<li>on()
: <a class="el" href="matrix__free__0_8txt.html#a188e94c924da4f44b8fbe5d70648ad15">matrix_free_0.txt</a>
, <a class="el" href="data__postprocessor__0_8txt.html#a232fd208d0a301873073f51d8474883a">data_postprocessor_0.txt</a>
</li>
<li>one()
: <a class="el" href="fe__raviart__thomas__0_8txt.html#a4fd7c31504076b1a46b14eedcc135a6a">fe_raviart_thomas_0.txt</a>
, <a class="el" href="fe__rt__bubbles__0_8txt.html#ad2e4404538d5721e1b54fabe907232f5">fe_rt_bubbles_0.txt</a>
</li>
<li>ones()
: <a class="el" href="A-headers_2manifold__0_8txt.html#adeaaf04b7a13c42b6a6c7ff87ce84306">manifold_0.txt</a>
, <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#aa0df0b583336df6e9db0f463cec67a4e">mg_transfer_global_coarsening_0.txt</a>
</li>
<li>only()
: <a class="el" href="trilinos__precondition__0_8txt.html#a410ad518e45e9e36fccdc47f77b5db30">trilinos_precondition_0.txt</a>
</li>
<li>operations()
: <a class="el" href="la__vector__0_8txt.html#aa76aa86a8ffc67346d11ad310d91c8d4">la_vector_0.txt</a>
, <a class="el" href="trilinos__sparse__matrix__0_8txt.html#a8dc50c01a34b2025c594dcf248d277dd">trilinos_sparse_matrix_0.txt</a>
</li>
<li>operator()
: <a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">precondition_selector_0.txt</a>
, <a class="el" href="read__write__vector__0_8txt.html#aa3188339341f9aacdb66e11e2dcc14f5">read_write_vector_0.txt</a>
, <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">solver_0.txt</a>
</li>
<li>operator applied to the pressure space. Since only a single matrix is needed for the other blocks, using BlockSparseMatrix or similar would be a waste of memory. *While the add()
: <a class="el" href="matrix__block__0_8txt.html#a4944d814fd1cde78e692e9ff8e6761d9">matrix_block_0.txt</a>
</li>
<li>operator by Nitsche, vector valued version, namely on the face[1.x.12] the vector[1.x.13] Here,[1.x.14] is the finite element function whose values and gradient are given in the arguments&lt; tt &gt;input&lt;/tt &gt; and&lt; tt &gt;Dinput&lt;/tt &gt;, respectively.[1.x.15] is the inhomogeneous boundary value in the argument&lt; tt &gt;data&lt;/tt &gt;.[2.x.5] is the usual penalty parameter. *[0.x.8] *Flux for the interior penalty method for the Laplacian, namely on the face[1.x.16] the matrices associated with the bilinear form[1.x.17] The penalty parameter should always be the mean value of the penalties needed for stability on each side. In the case of constant coefficients, it can be computed using compute_penalty()
: <a class="el" href="laplace__0_8txt.html#a4929ca9ddcae1fc8398fe8a91c3a027f">laplace_0.txt</a>
</li>
<li>operator can be notified of parameter changes by the calling routine. The outer iteration can notify()
: <a class="el" href="operator__0_8txt.html#adfed33e578dd7ff0c94118f248066985">operator_0.txt</a>
</li>
<li>operator computing the explicit part of the scheme. This will receive in its input data the value at the current time with name &quot;Current time solution&quot;. It should obtain the current time and time step size from explicit_data()
: <a class="el" href="theta__timestepping__0_8txt.html#ab8a2ce1df3db068abe409f816aeabd2b">theta_timestepping_0.txt</a>
</li>
<li>operator computing the residual. *[0.x.9] *The operator applying the inverse derivative to the residual. *[0.x.10] *The operator handling the output in case the debug_vectors is true. Call the initialize function first. *[0.x.11] *This flag is set by the function assemble()
: <a class="el" href="newton__0_8txt.html#a7f36ca838672093d13e5a9844c3cdabf">newton_0.txt</a>
</li>
<li>operator evaluation framework. It is currently only compatible with a subset of the elements provided by the library which have a special structure, namely those where the basis can be described as a tensor product of one-dimensional polynomials. This opens for efficient transformation between vector entries and values or gradients in quadrature points with a technique that is called sum factorization. This technique has its origin in the spectral element community, started by the work of Orszag in 1980. While this technique is initially nothing else than a particular technique for assembling vectors()
: <a class="el" href="matrixfree__0_8txt.html#a11e63efb8c35ff75c313cdbd7601e1dc">matrixfree_0.txt</a>
</li>
<li>operator evaluation in[2.x.15] arithmetic operations, considerably less than[2.x.16] for the naive forward transformation and[2.x.17] for setting up the inverse of[2.x.18] . *Interestingly, the exact inverse of the matrix[2.x.19] can be found through tensor products due to an article by[1.x.2] from 1964, **[1.x.3] *where[2.x.20] is the matrix of eigenvectors to the generalized eigenvalue problem in the given tensor direction[2.x.21] :**[1.x.4] *and[2.x.22] is the diagonal matrix representing the generalized eigenvalues[2.x.23] . Note that the vectors[2.x.24] are such that they simultaneously diagonalize[2.x.25] and[2.x.26], i.e.[2.x.27] and[2.x.28] . This method of matrix inversion is called fast diagonalization method. *This class requires LAPACK support. *Note that this class allows for two modes of usage. The first is a use case with run time constants for the matrix dimensions that is achieved by setting the optional template parameter&lt; tt &gt;n_rows_1d&lt;/tt &gt; to **- . The second mode of usage that is faster allows to set the template parameter as a compile time constant, giving significantly faster code in particular for small sizes of the matrix. *[2.x.29] dim Dimension of the problem. Currently, 1D, 2D, and 3D codes are implemented. *[2.x.30] Number Arithmetic type of the underlying array elements. Note that the underlying LAPACK implementation supports only float and double numbers, so only these two types are currently supported by the generic class. Nevertheless, a template specialization for the vectorized types VectorizedArray&lt; float &gt; and VectorizedArray&lt; double &gt; exists. This is necessary to perform LAPACK calculations for each vectorization lane, i.e. for the supported float and double numbers. *[2.x.31] n_rows_1d Compile-time number of rows of 1D matrices()
: <a class="el" href="tensor__product__matrix__0_8txt.html#a796c1f834c925c7beaa43c12d50fef79">tensor_product_matrix_0.txt</a>
</li>
<li>operator in order to be able to see the output in every step. *[1.x.11] *The next step is providing the vectors to be used.&lt; tt &gt;value&lt;/tt &gt; is filled with the initial value and is also the vector where the solution at each timestep will be. Because the interface of Operator has to be able to handle several vectors, we need to store it in an AnyData object. Since our problem has no additional parameters, the input AnyData object remains empty. *[1.x.12] *Finally, we are ready to tell the solver, that we are starting at the initial timestep and run it. *[1.x.13] *Besides the main function, we need to define the members functions of the implicit and explicit operators.First the constructor, which simply copies the system matrix into the member pointer for later use. *[1.x.14] *Now we need to study the application of the implicit and explicit operator.We assume that the pointer[2.x.8] points to the matrix created in the main program()
: <a class="el" href="theta__timestepping__0_8txt.html#a6d78b4531371d106e9acaa790ad46aec">theta_timestepping_0.txt</a>
</li>
<li>operator in space and[2.x.17] is the adjusted time step size[2.x.18] . *[0.x.20] *The operator solving the implicit part of the scheme. It will receive in its input data the vector &quot;Previous time&quot;. Information on the timestep should be obtained from implicit_data()
: <a class="el" href="theta__timestepping__0_8txt.html#a11e81741d1e80e3b48001fbbe37e5029">theta_timestepping_0.txt</a>
</li>
<li>operator in strong form[1.x.4] \warning This is not the residual consistent with cell_matrix()
: <a class="el" href="advection__0_8txt.html#ada5253c5a17e72c4a2e04ccdff2bafd1">advection_0.txt</a>
</li>
<li>operator in weak form[1.x.2] *[0.x.3] *Vector-valued Laplacian residual operator in weak form[1.x.3] *[0.x.4] *Weak boundary condition of Nitsche type for the Laplacian, namely on the face[1.x.4] the matrix[1.x.5] Here,[2.x.2] is the&lt; tt &gt;penalty&lt;/tt &gt; parameter suitably computed with compute_penalty()
: <a class="el" href="laplace__0_8txt.html#a99be1b79b0833deb813662a0fb7f90ca">laplace_0.txt</a>
</li>
<li>operator is almost the same, except that we change the sign in front of the timestep and use the inverse of the matrix. *[1.x.18] **[0.x.2] *Constructor, receiving the two operators stored in #op_explicit and #op_implicit. For their meaning, see the description of those variables. *[0.x.3] *The timestepping scheme.[2.x.11] in is ignored by ThetaTimestepping, but is merged into the AnyData objects used as input for the operators#op_explicit and #op_implicit.[2.x.12] out in its first argument must contain a pointer to a VectorType instance, which contains the initial value when the operator is called. It contains the final value when the operator returns. *[0.x.4] *Register an event triggered by an outer iteration. *[0.x.5] *Define an operator which will output the result in each step. Note that no output will be generated without this. *[0.x.6] *Declare parameters in a parameter handler. *[0.x.7] *Read the parameters in the ParameterHandler. *[0.x.8] *The current time in the timestepping scheme. *[0.x.9] *The weight between implicit and explicit part. *[0.x.10] *Set a new weight and return the old *[0.x.11] *The data handed to the #op_explicit time stepping operator.The time in here is the time at the beginning of the current step, the time step is()
: <a class="el" href="theta__timestepping__0_8txt.html#a18b2499e5e977fb7aa9d524f8724f01a">theta_timestepping_0.txt</a>
</li>
<li>operator is an object with an operator()
: <a class="el" href="operator__0_8txt.html#a501fbb500c02b2a32ad28c9899f12a9d">operator_0.txt</a>
</li>
<li>operator is applied to each component separately.[2.x.2] M:The advection matrix obtained as result[2.x.3] fe:The FEValues object describing the local trial function space. #update_values and #update_gradients, and #update_JxW_values must be set.[2.x.4] fetest:The FEValues object describing the local test function space. #update_values and #update_gradients must be set.[2.x.5] velocity:The advection velocity, a vector of dimension&lt; tt &gt;dim&lt;/tt &gt;. Each component may either contain a vector of length one, in which case a constant velocity is assumed, or a vector with as many entries as quadrature points if the velocity is not constant.[2.x.6] factor is an optional multiplication factor for the result. *[0.x.2] *Scalar advection residual operator in strong form[1.x.3] \warning This is not the residual consistent with cell_matrix()
: <a class="el" href="advection__0_8txt.html#a1f696fca3aed1a9636f0b760d304e74d">advection_0.txt</a>
</li>
<li>operator is associated with a matrix[2.x.29] then the restriction of this matrix[2.x.30] to a single child cell is returned here. The matrix[2.x.31] is the concatenation or the sum of the cell matrices[2.x.32] P_i, depending on the #restriction_is_additive_flags. This distinguishes interpolation()
: <a class="el" href="fe__nedelec__0_8txt.html#a5ea9c7088177954a24549b6014e56225">fe_nedelec_0.txt</a>
</li>
<li>operator is constructed with a functional payload. In either case, this constructor yields an object that can not actually be used for any linear operator operations, and will throw an exception upon invocation. *[0.x.2] *Default copy constructor. *[0.x.3] *Templated copy constructor that creates a LinearOperator object from an object[2.x.22] for which the conversion function[2.x.23] is defined. *[0.x.4] *Default copy assignment operator.*[0.x.5] *Templated copy assignment operator for an object[2.x.24] for which the conversion function[2.x.25] is defined. *[0.x.6] *Application of the LinearOperator object to a vector u of the[2.x.26] space giving a vector v of the[2.x.27] space. *[0.x.7] *Application of the LinearOperator object to a vector u of the[2.x.28] space. The result is added to the vector v. *[0.x.8] *Application of the transpose LinearOperator object to a vector u of the[2.x.29] space giving a vector v of the[2.x.30] space. *[0.x.9] *Application of the transpose LinearOperator object to a vector[2.x.31] of the[2.x.32] space.The result is added to the vector[2.x.33] *[0.x.10] *Initializes a vector v of the Range space to be directly usable as the destination parameter in an application of vmult. Similar to the reinit functions of the vector classes, the boolean determines whether a fast initialization is done, i.e., if it is set to false the content of the vector is set to 0. *[0.x.11] *Initializes a vector of the Domain space to be directly usable as the source parameter in an application of vmult. Similar to the reinit functions of the vector classes, the boolean determines whether a fast initialization is done, i.e., if it is set to false the content of the vector is set to 0. *[0.x.12] *[2.x.34] In-place vector space operations *[0.x.13] *Addition with a LinearOperator[2.x.35] with the same[2.x.36] and[2.x.37] *[0.x.14] *Subtraction with a LinearOperator[2.x.38] with the same[2.x.39] and[2.x.40] *[0.x.15] *Composition of the LinearOperator with an endomorphism[2.x.41] of the[2.x.42] space. *[0.x.16] *Scalar multiplication of the LinearOperator with[2.x.43] from the right. *[0.x.17] *This bool is used to determine whether a linear operator is a null operator.In this case the class is able to optimize some operations like multiplication or addition. *[0.x.18] *[2.x.44] Vector space operations **[0.x.19] *[2.x.45] LinearOperator *Addition of two linear operators[2.x.46] and[2.x.47] given by[2.x.48] ***[2.x.49] **[0.x.20] *[2.x.50] LinearOperator *Subtraction of two linear operators[2.x.51] and[2.x.52] given by[2.x.53] ***[2.x.54] **[0.x.21] *[2.x.55] LinearOperator *Scalar multiplication of a ScalarOperator object[2.x.56] with[2.x.57] from the left. *The[2.x.58] and[2.x.59] types must implement the following[2.x.60] member functions accepting the appropriate scalar Number type for rescaling:***[1.x.4] ****[2.x.61] **[0.x.22] *[2.x.62] LinearOperator *Scalar multiplication of a ScalarOperator object from the right. *The[2.x.63] and[2.x.64] types must implement the following[2.x.65] member functions for rescaling:***[1.x.5] ****[2.x.66] **[0.x.23] *[2.x.67] Composition and manipulation of a LinearOperator **[0.x.24] *[2.x.68] LinearOperator *Composition of two linear operators[2.x.69] and[2.x.70] given by[2.x.71] ***[2.x.72] **[0.x.25] *[2.x.73] LinearOperator *Return the transpose linear operations of[2.x.74] ****[2.x.75] **[0.x.26] *[2.x.76] LinearOperator *Return an object representing the inverse of the LinearOperator[2.x.77] *The function takes references[2.x.78] and[2.x.79] to an iterative solver and a preconditioner that are used in the[2.x.80] implementations of the LinearOperator object. *The LinearOperator object that is created stores a reference to[2.x.81] and[2.x.82] Thus, both objects must remain a valid reference for the whole lifetime of the LinearOperator object. Internal data structures of the[2.x.83] object will be modified upon invocation of[2.x.84] . ****[2.x.85] **[0.x.27] *[2.x.86] LinearOperator *Variant of above function that takes a LinearOperator[2.x.87] as preconditioner argument. ***[2.x.88] **[0.x.28] *[2.x.89] LinearOperator *Variant of above function without a preconditioner argument. In this case the identity_operator()
: <a class="el" href="linear__operator__0_8txt.html#a3eeceb8da07a394761506549f81e8787">linear_operator_0.txt</a>
</li>
<li>operator is declared as deleted and can not be used. *[0.x.20] *Move assignment operator.*[0.x.21] *[2.x.30] *[0.x.22] *Return a handle on the DoFHandler object which we are using. *[0.x.23] *Implement the copy operator needed for the iterator classes. *[0.x.24] *Copy operator used by the iterator class. Keeps the previously set dof handler, but sets the object coordinates of the TriaAccessor. *[0.x.25] *Tell the caller whether get_active_or_mg_dof_indices()
: <a class="el" href="dof__accessor__0_8txt.html#a163f66e586565bf49b058d7e570158b4">dof_accessor_0.txt</a>
</li>
<li>operator is declared as deleted and can not be used. *[0.x.23] *Declare the data type that this accessor class expects to get passed from the iterator classes. Since the pure triangulation iterators need no additional data, this data type is[2.x.19] *[0.x.24] *Constructor. Protected, thus only callable from friend classes. *[0.x.25] *Copy constructor. Creates an object with exactly the same data. *[0.x.26] *Copy operator.Since this is only called from iterators, do not return anything, since the iterator will return itself. This method is protected, since it is only to be called from the iterator class. *[0.x.27] *Copy operator.Creates an object with exactly the same data. *[0.x.28] *Comparison operator for accessors. This operator is used when comparing iterators into objects of a triangulation, for example when putting them into a[2.x.20] If #structure_dimension is less than #dimension, we simply compare the index of such an object because faces and edges do not have levels. If #structure_dimension equals #dimension, we compare the level first, and the index only if levels are equal. *[0.x.29] *Compare for equality. *[0.x.30] *Compare for inequality. *[0.x.31] *[2.x.21] Advancement of iterators *[0.x.32] *[2.x.22] *[0.x.33] *This operator advances the iterator to the next element. For[2.x.23] only:The next element is next on this level if there are more. If the present element is the last on this level, the first on the next level is accessed. *[0.x.34] *This operator moves the iterator to the previous element. For[2.x.24] only:The previous element is previous on this level if&lt; tt &gt;index &gt;0&lt;/tt &gt;. If the present element is the first on this level, the last on the previous level is accessed. *[0.x.35] *[2.x.25] *[0.x.36] *Access to the other objects of a Triangulation with same dimension. *[0.x.37] *Data type to be used for passing parameters from iterators to the accessor classes in a unified way, no matter what the type of number of these parameters is. *[0.x.38] *[2.x.26] Iterator address and state *[0.x.39] *[2.x.27] *[0.x.40] *For cells, this function returns the level within the mesh hierarchy at which this cell is located. For all other objects, the function returns zero. *[2.x.28] Within a Triangulation object, cells are uniquely identified by a pair[2.x.29] where the former is the cell 's refinement level and the latter is the index of the cell within this refinement level()
: <a class="el" href="tria__accessor__0_8txt.html#a8d959ab5b7fcc7324b97a9502eb363f8">tria_accessor_0.txt</a>
</li>
<li>operator is to make the ThreadLocalStorage object look more like the object it represents on the current thread.[2.x.6] t The object to be copied into the storage space used for the current thread.[2.x.7] The current object, after the changes have been made *[0.x.13] *Move the given argument into the storage space used to represent the current thread. Calling this function as&lt; code &gt;tls_data=object&lt;/code &gt; is equivalent to calling&lt; code &gt;tls_data.get()
: <a class="el" href="thread__local__storage__0_8txt.html#af4e70367634ecd9e4d093f29eb4bf62b">thread_local_storage_0.txt</a>
</li>
<li>operator maps from one finite element space into the dual of another()
: <a class="el" href="local__integrators__0_8txt.html#a522a854bbc87540ee6a41129ddfabcb3">local_integrators_0.txt</a>
</li>
<li>operator might seem dangerous, it is useful in cases where one would like to have code like&lt; tt &gt;switch()
: <a class="el" href="geometry__info__0_8txt.html#aebd5fb5989f8101af5c9ddaca43422b4">geometry_info_0.txt</a>
</li>
<li>operator only exists to allow for the obvious notation&lt; tt &gt;matrix=0&lt;/tt &gt;, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. *[0.x.11] *Release all memory and return to a state just like after having called the default constructor. It also forgets the sparsity pattern it was previously tied to. This calls[2.x.5] on all sub-matrices and then resets this object to have no blocks at all. *[0.x.12] *Reinitialize the sparse matrix with the given sparsity pattern. The latter tells the matrix how many nonzero elements there need to be reserved. Basically, this function only calls[2.x.6] of the sub- matrices with the block sparsity patterns of the parameter. You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit()
: <a class="el" href="block__sparse__matrix__0_8txt.html#ade573047f005fed5446581cd2ab16f27">block_sparse_matrix_0.txt</a>
</li>
<li>operator only exists to allow for the obvious notation&lt; tt &gt;matrix=0&lt;/tt &gt;, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. *[0.x.8] *Set matrix to zero dimensions and release memory. *[0.x.9] *Initialize to given block numbers. After this operation, the matrix will have the block dimensions provided. Each block will have zero dimensions and must be initialized subsequently. After setting the sizes of the blocks, collect_sizes()
: <a class="el" href="block__sparse__matrix__ez__0_8txt.html#a885cf688dbb43579796cbf7ff5d53eac">block_sparse_matrix_ez_0.txt</a>
</li>
<li>operator only exists to allow for the obvious notation&lt; tt &gt;matrix=0&lt;/tt &gt;, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. *[0.x.9] *Resize the matrix, by setting the number of block rows and columns. This deletes all blocks and replaces them with uninitialized ones, i.e. ones for which also the sizes are not yet set. You have to do that by calling the[2.x.5] functions of the blocks themselves. Do not forget to call collect_sizes()
: <a class="el" href="petsc__block__sparse__matrix__0_8txt.html#a5a5db996f0aa1edb87c8e7e1c9bf4b17">petsc_block_sparse_matrix_0.txt</a>
, <a class="el" href="trilinos__block__sparse__matrix__0_8txt.html#a5a5db996f0aa1edb87c8e7e1c9bf4b17">trilinos_block_sparse_matrix_0.txt</a>
</li>
<li>operator only exists to allow for the obvious notation&lt; tt &gt;matrix=0&lt;/tt &gt;, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. *[0.x.36] *Release all memory and return to a state just like after having called the default constructor. *[0.x.37] *Set the element()
: <a class="el" href="petsc__matrix__base__0_8txt.html#a7ca472aeb2b6bef3da08d6b49bf56bb6">petsc_matrix_base_0.txt</a>
</li>
<li>operator only on selected blocks would be the setting of the[2.x.4] tutorial program:This problem has three[1.x.1], one for the velocity, one for the pressure, and one for temperature. The time lag scheme used for temporal evolution splits the temperature equation away from the Stokes system in velocity and pressure. However, there are cross terms like the velocity that enters the temperature advection-diffusion equation or the temperature that enters the right hand side of the velocity. In order to be sure that MatrixFree uses the same integer indexing to the different blocks, one needs to put all the three blocks into the same MatrixFree object. However, when solving a linear system the operators involved either address the first two in the Stokes solver, or the last one for the temperature solver. In the former case, a BlockVector of two components would be selected with a vector selecting the blocks {0, 1} in MatrixFree, whereas in the latter, a non-block vector selecting the block {2} would be used. A second application of selection is in problems with a Newton-type iteration or problems with inhomogeneous boundary conditions. In such a case, one has to deal with two different sets of constraints:One set of constraints applies to the solution vector which might include hanging node constraints or periodicity constraints but no constraints on inhomogeneous Dirichlet boundaries. Before the nonlinear iteration, the boundary values are set to the expected value in the vector, representing the initial guess. In each iteration of the Newton method, a linear system subject to zero Dirichlet boundary conditions is solved that is then added to the initial guess. This setup can be realized by using a vector of two pointers pointing to the same DoFHandler object and a vector of two pointers to the two AffineConstraints objects. If the first AffineConstraints object is the one including the zero Dirichlet constraints, one would give a[2.x.5] int &gt;()
: <a class="el" href="operators__0_8txt.html#ad4105f36a351a058f8089ee9ced88626">operators_0.txt</a>
</li>
<li>operator overloading[2.x.16] . The first method generates new, compilable code based on some input function that, when executed, returns the derivatives of the input function. The second exploits the capability of&lt; tt &gt;C++&lt;/tt &gt; operator definitions to be overloaded for custom class types. Therefore a class that represents such an auto-differentiable number can, following each mathematical operation performed on or with it, in principle evaluate and keep track of its value as well as that of its directional derivative()
: <a class="el" href="automatic__and__symbolic__differentiation__0_8txt.html#a4f126569b97aa87bb7966d0847c3efff">automatic_and_symbolic_differentiation_0.txt</a>
</li>
<li>operator preserves the divergence of a function weakly. *[0.x.8] *Fields of cell-independent data. For information about the general purpose of this class, see the documentation of the base class. *[0.x.9] *Array with shape function values in quadrature points. There is one row for each shape function, containing values for each quadrature point. Since the shape functions are vector-valued()
: <a class="el" href="fe__abf__0_8txt.html#a3c20316c62c2592cc69989ca2241c70d">fe_abf_0.txt</a>
</li>
<li>operator preserves the divergence of a function weakly. *[0.x.8] *These are the factors multiplied to a function in the #generalized_face_support_points when computing the integration. They are organized such that there is one row for each generalized face support point and one column for each degree of freedom on the face. See the[2.x.19] &quot;glossary entry on generalized support points&quot; for more information. *[0.x.9] *Precomputed factors for interpolation of interior degrees of freedom. The rationale for this Table is the same as for #boundary_weights. Only, this table has a third coordinate for the space direction of the component evaluated. *[0.x.10] *Fill the necessary tables defined in base classes such as[2.x.20] declared in fe.cc. We need to fill it with the correct values in case of non-standard, flipped()
: <a class="el" href="fe__raviart__thomas__0_8txt.html#a348eb3bdfa697c1611bbd4418dac078d">fe_raviart_thomas_0.txt</a>
</li>
<li>operator specifically does not check the following member variables of the current class:************- restriction matrices, ************- prolongation matrices of this object and the argument. This is because these member variables may be initialized only on demand by derived classes, rather than being available immediately. Consequently, comparing these members would not only be costly because these are generally big arrays, but also because their computation may be expensive. On the other hand, derived classes for which these arrays may differ for two objects even though the above list compares as equal, will probably want to implement their own operator==()
: <a class="el" href="fe_2fe__0_8txt.html#a25cc0d864a97a07c918e854b54950ce9">fe_0.txt</a>
</li>
<li>operator that simply converts the thread-local object to the data type that it stores. This function is equivalent to calling the get()
: <a class="el" href="thread__local__storage__0_8txt.html#a6b70862bca8a9071fe2a7016c6f38c2a">thread_local_storage_0.txt</a>
</li>
<li>operator that wraps SUNDIALS functionality. *[0.x.1] *Apply this LinearOperator to[2.x.0] and store the result in[2.x.1] *[0.x.2] *Constructor.[2.x.2] A_data Data required by[2.x.3][2.x.4] a_times_fn A function pointer to the function that computes A *v *[0.x.3] *Data necessary to evaluate a_times_fn. *[0.x.4] *%Function pointer declared by SUNDIALS to evaluate the matrix vector product. *[0.x.5] *A linear operator that wraps preconditioner functionality as specified by SUNDIALS. The vmult()
: <a class="el" href="sunlinsol__wrapper__0_8txt.html#aa0cdaadcc30e53cbc3dbb1e2d4113db9">sunlinsol_wrapper_0.txt</a>
</li>
<li>operator to a comparison relationship. The way this works is pretty much as when you would want to define a comparison relationship for vectors:either all elements of the first vector are smaller, equal, or larger than those of the second vector, or some are and some are not. This operator is pretty much the same:if both arguments are[2.x.12] or[2.x.13], then the returned value is that value. On the other hand, if one of the values is[2.x.14], then the returned value is that of the other argument. If either argument is[2.x.15], or if the two arguments are[2.x.16] and[2.x.17], then the returned value is[2.x.18] . *[0.x.8] *Internal data structure for setting up FiniteElementData. It stores for each object the()
: <a class="el" href="fe__base__0_8txt.html#a6ff94febd079bddc376a3bdbc79744bc">fe_base_0.txt</a>
</li>
<li>operator to even and odd parts of the input vector separately:see the documentation of the EvaluatorTensorProduct specialization for more information. *[0.x.4] *Use symmetry in Legendre and similar polynomial spaces where the shape functions with even number are symmetric about the center of the quadrature points()
: <a class="el" href="tensor__product__kernels__0_8txt.html#ac0c1001733247e691eeec92a52e76f2e">tensor_product_kernels_0.txt</a>
</li>
<li>operator to get a representation of the matrix that represents this preconditioner. We use this inside the actual solver, where we need to pass this matrix to the PETSc solvers. *[0.x.11] *A class that implements the interface to use the PETSc Jacobi preconditioner. See the comment in the base class[2.x.1] for when this preconditioner may or may not work. *[2.x.2] *[0.x.12] *Standardized data struct to pipe additional flags to the preconditioner. *[0.x.13] *Empty Constructor. You need to call initialize()
: <a class="el" href="petsc__precondition__0_8txt.html#ae1f3649a67c0c74d518771fd4b420884">petsc_precondition_0.txt</a>
</li>
<li>operator to the data type of the matrix. *[0.x.26] *Set the element of the matrix we presently point to to[2.x.1] *[0.x.27] *Add[2.x.2] to the element of the matrix we presently point to. *[0.x.28] *Subtract[2.x.3] from the element of the matrix we presently point to. *[0.x.29] *Multiply the element of the matrix we presently point to by[2.x.4] *[0.x.30] *Divide the element of the matrix we presently point to by[2.x.5] *[0.x.31] *Pointer to the accessor that denotes which element we presently point to. *[0.x.32] *Typedef for the type()
: <a class="el" href="trilinos__sparse__matrix__0_8txt.html#a4a43c52346c7aec00273a669ff49f8e5">trilinos_sparse_matrix_0.txt</a>
</li>
<li>operator to the residual, and consequently, the action of the preconditioner[1.x.8] is implemented as&lt; tt &gt;vmult()
: <a class="el" href="preconditioners__0_8txt.html#a7d523e95b49e0b459878b8c4423e6fb9">preconditioners_0.txt</a>
</li>
<li>operator used by TBB to work on a given[2.x.2] of chunks[range.begin()
: <a class="el" href="vector__operations__internal__0_8txt.html#a588d7591a29904fefe10f733cdfeeeb4">vector_operations_internal_0.txt</a>
</li>
<li>operator used by Trilinos solvers. ***[2.x.17] Many use cases of LinearOperator lead to intermediate expressions requiring a PackagedOperation. In order to include all necessary header files in one go consider using **[1.x.3] **In order to use the full LinearOperator and PackagedOperation ***[2.x.18] To ensure that the correct payload is provided, wrapper functions for linear operators have been provided within the respective TrilinosWrappers()
: <a class="el" href="linear__operator__0_8txt.html#a941c3c1ebdfe992fce5cf86b3c086562">linear_operator_0.txt</a>
</li>
<li>operator which outputs update flags as a set of or 'd text values. *[2.x.8] **[0.x.25] *Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or&lt; tt &gt;operator|&lt;/tt &gt; would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type UpdateFlags. *[2.x.9] **[0.x.26] *Global operator which sets the bits from the second argument also in the first one. *[2.x.10] **[0.x.27] *Global operator which returns an object in which all bits are set which are set in the first as well as the second argument. This operator exists since if it did not then the result of the bit-and&lt; tt &gt;operator&amp;&lt;/tt &gt; would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type UpdateFlags. *[2.x.11] **[0.x.28] *Global operator which clears all the bits in the first argument if they are not also set in the second argument. *[2.x.12] **[0.x.29] *This enum definition is used for storing similarities of the current cell to the previously visited cell. This information is used for reusing data when calling the method[2.x.13]()
: <a class="el" href="fe__update__flags__0_8txt.html#aad041cae4b568ed0fddae32e6e0d024a">fe_update_flags_0.txt</a>
</li>
<li>operator!=()
: <a class="el" href="base_2aligned__vector_8h.html#a5194e9bde680a0b5d359cd17fc1de808">aligned_vector.h</a>
, <a class="el" href="base_2synchronous__iterator_8h.html#a284b63fe54c610c5d708bf994cd61853">synchronous_iterator.h</a>
, <a class="el" href="origin_2base_2aligned__vector_8h.html#a5194e9bde680a0b5d359cd17fc1de808">aligned_vector.h</a>
, <a class="el" href="origin_2base_2synchronous__iterator_8h.html#a284b63fe54c610c5d708bf994cd61853">synchronous_iterator.h</a>
, <a class="el" href="translator_2base_2aligned__vector_8h.html#a5194e9bde680a0b5d359cd17fc1de808">aligned_vector.h</a>
, <a class="el" href="translator_2base_2synchronous__iterator_8h.html#a284b63fe54c610c5d708bf994cd61853">synchronous_iterator.h</a>
</li>
<li>operator&amp;()
: <a class="el" href="fe_2fe__update__flags_8h.html#aa4de2d23ede5c57054414ce38cfc4199">fe_update_flags.h</a>
</li>
<li>operator&amp;=()
: <a class="el" href="fe_2fe__update__flags_8h.html#adfeef7e9f5d12f89ca786d3bad516502">fe_update_flags.h</a>
</li>
<li>operator()()
: <a class="el" href="mutable__bind__0_8txt.html#a02b3f6970317af2b828ff6864eabf67f">mutable_bind_0.txt</a>
, <a class="el" href="simple__0_8txt.html#a4e6964f451a33a28869a5c7ffd2ad5de">simple_0.txt</a>
</li>
<li>operator*()
: <a class="el" href="base_2tensor_8h.html#a6af378a072e8881e65058bd937de898a">tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#ab848bd1da37f381f87cb5eaf51de6019">vectorization.h</a>
, <a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">linear_operator.h</a>
, <a class="el" href="group__LAOperators.html#gae64fff253a63070b2662a17edcfe4a44">packaged_operation.h</a>
, <a class="el" href="origin_2base_2complex__overloads_8h.html#a3058a38ab93aea6945b91da6cfad8391">complex_overloads.h</a>
, <a class="el" href="origin_2base_2point_8h.html#a6e6e7f011b51cb20e2ab2e5bfe5cf4a5">point.h</a>
, <a class="el" href="origin_2base_2polynomials__barycentric_8h.html#afd8cfc116d8a8e2c2ad18ef9d08d9f9e">polynomials_barycentric.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#aa28e6ee3c69c87b294aed4281d975643">symmetric_tensor.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a7d3cac921f59d70d5b65a638bb7a8046">tensor.h</a>
, <a class="el" href="origin_2base_2vectorization_8h.html#a5d3c20131d629237718a4662d7efcd72">vectorization.h</a>
, <a class="el" href="translator_2base_2complex__overloads_8h.html#a3058a38ab93aea6945b91da6cfad8391">complex_overloads.h</a>
, <a class="el" href="translator_2base_2point_8h.html#a6e6e7f011b51cb20e2ab2e5bfe5cf4a5">point.h</a>
, <a class="el" href="translator_2base_2polynomials__barycentric_8h.html#afd8cfc116d8a8e2c2ad18ef9d08d9f9e">polynomials_barycentric.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#aa28e6ee3c69c87b294aed4281d975643">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a7d3cac921f59d70d5b65a638bb7a8046">tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a5d3c20131d629237718a4662d7efcd72">vectorization.h</a>
, <a class="el" href="base_2complex__overloads_8h.html#a285c79b547d28de482e34d02cee71bb2">complex_overloads.h</a>
, <a class="el" href="base_2point_8h.html#af9b78c6f821c17d862d818dbacbf1813">point.h</a>
, <a class="el" href="base_2polynomials__barycentric_8h.html#afd8cfc116d8a8e2c2ad18ef9d08d9f9e">polynomials_barycentric.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#abf6cce115919f046d183a86603c3460c">symmetric_tensor.h</a>
, <a class="el" href="base_2tensor_8h.html#a866270925a280330ae3e2bd05e648dc4">tensor.h</a>
</li>
<li>operator*and[2.x.24] are the interpolated boundary values **- thus the name. The use of[2.x.25] instead of[2.x.26] as boundary values imposes an additional error()
: <a class="el" href="vector__tools__boundary__0_8txt.html#a4e0ac2eec5afddbf232a5a4e3c610bea">vector_tools_boundary_0.txt</a>
</li>
<li>operator*with Number and produce Number as an output to be a valid type *[0.x.11] *Empty constructor. Does nothing. Be careful when using 'values' and related methods because they need to be filled with the other pointer *[0.x.12] *Constructor, taking the data from ShapeInfo *[0.x.13] *This function applies the tensor product kernel, corresponding to a multiplication of 1D stripes, along the given[2.x.11] of the tensor data in the input array. This function allows the[2.x.12] and[2.x.13] arrays to alias for the case n_rows==n_columns, i.e., it is safe to perform the contraction in place where[2.x.14] and[2.x.15] point to the same address. For the case n_rows !=n_columns, the output is in general not correct.[2.x.16] direction Direction that is evaluated[2.x.17] contract_over_rows If true, the tensor contraction sums over the rows in the given[2.x.18] array, otherwise it sums over the columns[2.x.19] add If true, the result is added to the output vector, else the computed values overwrite the content in the output[2.x.20] one_line If true, the kernel is only applied along a single 1D stripe within a dim-dimensional tensor, not the full n_rows^dim points as in the[2.x.21] case.[2.x.22] shape_data Transformation matrix with[2.x.23] rows and[2.x.24] columns, stored in row-major format[2.x.25] in Pointer to the start of the input data vector[2.x.26] out Pointer to the start of the output data vector *[0.x.14] *This function applies the tensor product operation to produce face values from cell values. As opposed to the apply method, this method assumes that the directions orthogonal to the face have n_rows degrees of freedom per direction and not n_columns for those directions lower than the one currently applied. In other words, apply_face()
: <a class="el" href="tensor__product__kernels__0_8txt.html#a505359037295fa118b67ce8190271e39">tensor_product_kernels_0.txt</a>
</li>
<li>operator*with Number and produce Number as an output to be a valid type *[0.x.16] *Empty constructor. Does nothing. Be careful when using 'values' and related methods because they need to be filled with the other constructor *[0.x.17] *Constructor, taking the data from ShapeInfo *[0.x.18] *Constructor, taking the data from ShapeInfo *[0.x.19] *Internal evaluator for 1d-3d shape function using the tensor product form of the basis functions. This class specializes the general application of tensor-product based elements for &quot;symmetric&quot; finite elements, i.e., when the shape functions are symmetric about 0.5 and the quadrature points are, too.[2.x.39] dim Space dimension in which this class is applied[2.x.40] n_rows Number of rows in the transformation matrix, which corresponds to the number of 1d shape functions in the usual tensor contraction setting[2.x.41] n_columns Number of columns in the transformation matrix, which corresponds to the number of 1d shape functions in the usual tensor contraction setting[2.x.42] Number Abstract number type for input and output arrays[2.x.43] Number2 Abstract number type for coefficient arrays()
: <a class="el" href="tensor__product__kernels__0_8txt.html#a21b516a2d0dff183abd04969e0d71d34">tensor_product_kernels_0.txt</a>
</li>
<li>operator*with Number and produce Number as an output to be a valid type *[0.x.20] *Constructor, taking the data from ShapeInfo *[0.x.21] *Internal evaluator for 1d-3d shape function using the tensor product form of the basis functions. This class implements a different approach to the symmetric case for values, gradients, and Hessians also treated with the above functions:It is possible to reduce the cost per dimension from N^2 to N^2/2, where N is the number of 1D dofs()
: <a class="el" href="tensor__product__kernels__0_8txt.html#afd6f966c5f4fd65caafe627182d5a68e">tensor_product_kernels_0.txt</a>
</li>
<li>operator*with Number and produce Number as an output to be a valid type *[0.x.22] *Empty constructor. Does nothing. Be careful when using 'values' and related methods because they need to be filled with the other constructor passing in at least an array for the values. *[0.x.23] *Constructor, taking the data from ShapeInfo()
: <a class="el" href="tensor__product__kernels__0_8txt.html#a601920107faff62c7175aeccdf79e743">tensor_product_kernels_0.txt</a>
</li>
<li>operator*with Number and produce Number as an output to be a valid type *[0.x.27] *Empty constructor. Does nothing. Be careful when using 'values' and related methods because they need to be filled with the other constructor passing in at least an array for the values. *[0.x.28] *Constructor, taking the data from ShapeInfo()
: <a class="el" href="tensor__product__kernels__0_8txt.html#a0fb739e83829d4462c7b1b757b1d7667">tensor_product_kernels_0.txt</a>
</li>
<li>operator*with Number to be valid *[0.x.10] *Internal evaluator for shape function in arbitrary dimension using the tensor product form of the basis functions.[2.x.6] dim Space dimension in which this class is applied[2.x.7] n_rows Number of rows in the transformation matrix, which corresponds to the number of 1d shape functions in the usual tensor contraction setting[2.x.8] n_columns Number of columns in the transformation matrix, which corresponds to the number of 1d shape functions in the usual tensor contraction setting[2.x.9] Number Abstract number type for input and output arrays[2.x.10] Number2 Abstract number type for coefficient arrays()
: <a class="el" href="tensor__product__kernels__0_8txt.html#a6a27a349412c73a2e261180a9b0501a2">tensor_product_kernels_0.txt</a>
</li>
<li>operator+()
: <a class="el" href="base_2polynomials__barycentric_8h.html#a59f255e4673e6ba9773f671c90215e26">polynomials_barycentric.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#abbfe82642874a4a3b1e666f7276d512b">symmetric_tensor.h</a>
, <a class="el" href="base_2synchronous__iterator_8h.html#a70cd340b9830113c86896c83a9cdd63d">synchronous_iterator.h</a>
, <a class="el" href="base_2tensor_8h.html#ab976c32648a69f93416e35b2c6c82800">tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#ad938a80e7098f4bf2193b14a14e73460">vectorization.h</a>
, <a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">linear_operator.h</a>
, <a class="el" href="group__LAOperators.html#gafa632ef2b50c80c96ed831ac7cfcb018">packaged_operation.h</a>
, <a class="el" href="origin_2base_2polynomials__barycentric_8h.html#a59f255e4673e6ba9773f671c90215e26">polynomials_barycentric.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#a883cff560f9a94aaabc55e0a78e69738">symmetric_tensor.h</a>
, <a class="el" href="origin_2base_2synchronous__iterator_8h.html#a7cc51bf79f64537336c01fc00c25bd59">synchronous_iterator.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a9cb3a2803cdef8c678b05390d338381d">tensor.h</a>
, <a class="el" href="origin_2base_2vectorization_8h.html#a38a9ab28bc787b738f68b35a621db43b">vectorization.h</a>
, <a class="el" href="translator_2base_2polynomials__barycentric_8h.html#a59f255e4673e6ba9773f671c90215e26">polynomials_barycentric.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#a883cff560f9a94aaabc55e0a78e69738">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2synchronous__iterator_8h.html#a7cc51bf79f64537336c01fc00c25bd59">synchronous_iterator.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a9cb3a2803cdef8c678b05390d338381d">tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a38a9ab28bc787b738f68b35a621db43b">vectorization.h</a>
</li>
<li>operator++()
: <a class="el" href="base_2synchronous__iterator_8h.html#a574336a8166e3537d57c0d677df48ce9">synchronous_iterator.h</a>
</li>
<li>operator++&lt;/tt &gt;, and decremented to the previous elementusing&lt; tt &gt;operator**-&lt;/tt &gt;. One can also jump&lt; tt &gt;n&lt;/tt &gt; elements ahead usingthe addition operator,&lt;tt &gt;it=it+n&lt;/tt &gt;, and correspondingly to move a numberof elements back. In addition, and keeping with the tradition of the standardtemplate library, meshes provide member functions&lt; tt &gt;begin()
: <a class="el" href="iterators__0_8txt.html#a58af1d43205c7eb787389f58013ccf72">iterators_0.txt</a>
</li>
<li>operator,as well as functions for the weak boundary conditions by Nitsche or the interior penalty discontinuous Galerkin method. The namespace Maxwell does the same for curl-curl type problems. *The namespace L2 contains functions for mass matrices and[1.x.0]-inner products. *[1.x.1] *In most cases, the action of a function in this namespace can be described by a single integral. We distinguish between integrals over cells[1.x.2] and over faces[1.x.3]. If an integral is denoted as[1.x.4] it will yield the following results, depending on the type of operation[2.x.1][2.x.2] If the function returns a matrix, the entry at position[1.x.5] will be the integrated product of test function[1.x.6] and trial function[1.x.7]()
: <a class="el" href="local__integrators__0_8txt.html#ade3c1e76ea515c052679dc39eb573a6c">local_integrators_0.txt</a>
</li>
<li>operator,being the interface used by multigrid methods. Any implementation will be done by derived classes. **[0.x.10] *Virtual destructor. *[0.x.11] *Solution operator.*[0.x.12] *Base class used to declare the operations needed by a concrete class implementing prolongation and restriction of vectors in the multigrid context. This class is abstract and has no implementation of these operations. *There are several derived classes, reflecting the fact that vector types and numbering of the fine-grid discretization and of the multi-level implementation are independent. *If you use multigrid for a single PDE or for your complete system of equations, you will use MGTransferPrebuilt together with Multigrid. The vector types used on the fine grid as well as for the multilevel operations may be Vector or BlockVector. In both cases, MGTransferPrebuilt will operate on all components of the solution. ***[2.x.1] For the following, it is important to realize the difference between a solution[2.x.2] &quot;component&quot; and a solution[2.x.3] &quot;block&quot;. The distinction only applies if vector valued elements are used, but is quite important then. This is reflected in the fact that it is not possible right now to use transfer classes based on MGTransferComponentBase for genuine vector valued elements, but descendants of MGTransferBlockBase would have to be applied. In the following text, we will use the term[2.x.4] block[2.x.5], but remark that it might refer to components as well. *[2.x.6] update the following documentation, since it does not reflect the latest changes in structure. *For mixed systems, it may be required to do multigrid only for a single component or for some components. The classes MGTransferSelect and MGTransferBlock handle these cases. *MGTransferSelect is used if you use multigrid()
: <a class="el" href="mg__base__0_8txt.html#a7fd584e26e68e91e339f842db3ce9b9a">mg_base_0.txt</a>
</li>
<li>operator,grant access to arbitrary elements relative to the one presently pointed to. *[0.x.18] *Prefix increment operator.This operator advances the iterator to the next element and returns a reference to&lt; tt &gt; *this&lt;/tt &gt;. *[0.x.19] *Postfix increment operator.This operator advances the iterator to the next element and returns a copy of the old value of this iterator. *[0.x.20] *Prefix decrement operator.This operator retracts the iterator to the previous element and returns a reference to&lt; tt &gt; *this&lt;/tt &gt;. *[0.x.21] *Postfix decrement operator.This operator retracts the iterator to the previous element and returns a copy of the old value of this iterator. *[0.x.22] *Compare for equality of iterators. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. *[0.x.23] *Compare for inequality of iterators. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. *[0.x.24] *Check whether this iterators points to an element previous to the one pointed to by the given argument. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. *[0.x.25] *Comparison operator alike to the one above. *[0.x.26] *Comparison operator alike to the one above. *[0.x.27] *Comparison operator alike to the one above. *[0.x.28] *Return the distance between the two iterators, in elements. *[0.x.29] *Return an iterator which is the given number of elements in front of the present one. *[0.x.30] *Return an iterator which is the given number of elements behind the present one. *[0.x.31] *Move the iterator&lt; tt &gt;d&lt;/tt &gt; elements forward at once, and return the result. *[0.x.32] *Move the iterator&lt; tt &gt;d&lt;/tt &gt; elements backward at once, and return the result. *[0.x.33] *[2.x.4] Exceptions[2.x.5] *[0.x.34] *Exception thrown when one performs arithmetical comparisons on iterators belonging to two different block vectors. *[0.x.35] *Pointer to the block vector object to which this iterator points. Depending on the value of the&lt; tt &gt;Constness&lt;/tt &gt; template argument of this class, this is a&lt; tt &gt;const &lt;/tt &gt; or non-&lt; tt &gt;const &lt;/tt &gt; pointer. *[0.x.36] *Global index of the element to which we presently point. *[0.x.37] *Current block and index within this block of the element presently pointed to. *[0.x.38] *Indices of the global element address at which we have to move on to another block when moving forward and backward. These indices are kept as a cache since this is much more efficient than always asking the parent object. *[0.x.39] *Move forward one element. *[0.x.40] *Move backward one element. *[0.x.41] *A vector composed of several blocks each representing a vector of its own. *The BlockVector is a collection of vectors of a given type()
: <a class="el" href="block__vector__base__0_8txt.html#aa025bf98f5e865a44e31f6d4b620f1d9">block_vector_base_0.txt</a>
</li>
<li>operator,i.e. you can write statements like **[1.x.0] **Iterators are used whenever a loop over all lines, quads, cells etc. is to be performed. These loops can then be coded like this:**[1.x.1] **Note the usage of&lt; tt &gt;++cell&lt;/tt &gt; instead of&lt; tt &gt;cell++&lt;/tt &gt; since this does not involve temporaries and copying. It is recommended to use a fixed value&lt; tt &gt;end&lt;/tt &gt; inside the loop instead of&lt; tt &gt;tria.end()
: <a class="el" href="tria__iterator__0_8txt.html#a3364d6c9302cebf4b0dc8c3524e5f782">tria_iterator_0.txt</a>
</li>
<li>operator,non-[2.x.0] version. *[0.x.5] *Dereferencing operator,returns a pointer of the particle pointed to. Usage is thus like&lt; tt &gt;i-&gt;get_id()
: <a class="el" href="particle__iterator__0_8txt.html#a34d8a2a19b0fd73987b47a15f26f5392">particle_iterator_0.txt</a>
</li>
<li>operator,non-[2.x.36] version. *[0.x.14] *Dereferencing operator,returns a reference of the cell pointed to. Usage is thus like&lt; tt &gt;i-&gt;index()
: <a class="el" href="tria__iterator__0_8txt.html#a536e2fb09156cb7c56a61c3272c4c266">tria_iterator_0.txt</a>
</li>
<li>operator,where we use the pointers to the Triangulation from a TriaAccessorBase object, while the additional data is used according to the actual type of Accessor. *[0.x.66] *Similar conversion operator to the above one, but does a check whether the iterator points to a used element, and is active, which is necessary for raw iterators. Since usual iterators are also raw iterators, this constructor works also for parameters of type&lt; tt &gt;TriaIterator&lt; OtherAccessor &gt;&lt;/tt &gt;.[2.x.88] The argument passed to this constructor must either be()
: <a class="el" href="tria__iterator__0_8txt.html#a47727d4882e7630329bd9dfb1c35ae5f">tria_iterator_0.txt</a>
</li>
<li>operator,where we use the pointers to the Triangulation from a TriaAccessorBase object, while the additional data is used according to the actual type of Accessor. *[0.x.9] *Conversion constructor. Same as above with the difference that it converts from TriaIterator classes()
: <a class="el" href="tria__iterator__0_8txt.html#a3b6feab77b97990bc596f03765580a52">tria_iterator_0.txt</a>
</li>
<li>operator-()
: <a class="el" href="base_2symmetric__tensor_8h.html#ab9eafd3162685be6f5991c38a6199bb8">symmetric_tensor.h</a>
, <a class="el" href="base_2tensor_8h.html#a2ed2c7983fc5c58b67291507d41c20d0">tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#a655230f65541b3787d1f71fa57a44072">vectorization.h</a>
, <a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">linear_operator.h</a>
, <a class="el" href="group__LAOperators.html#gaab5209738cb7a57b293ee76a5f822429">packaged_operation.h</a>
, <a class="el" href="origin_2base_2polynomials__barycentric_8h.html#aff6b259f6f4087a4bb96fa30d32ab168">polynomials_barycentric.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#a8d66b3bdb36bc91fadbfa6c7284579b6">symmetric_tensor.h</a>
, <a class="el" href="origin_2base_2synchronous__iterator_8h.html#a71c22609d610106398fcf6b3fff02579">synchronous_iterator.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a38b26f57984d5dfa128522e0daf1b8eb">tensor.h</a>
, <a class="el" href="origin_2base_2vectorization_8h.html#a20a48ed6753e463282e446c19dc49c75">vectorization.h</a>
, <a class="el" href="translator_2base_2polynomials__barycentric_8h.html#aff6b259f6f4087a4bb96fa30d32ab168">polynomials_barycentric.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#af09db057a033608a0e95b59d3a192cb6">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2synchronous__iterator_8h.html#a71c22609d610106398fcf6b3fff02579">synchronous_iterator.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a916f0915292f2a8ddc8b54f4b07fd000">tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a20a48ed6753e463282e446c19dc49c75">vectorization.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#a8d66b3bdb36bc91fadbfa6c7284579b6">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a38b26f57984d5dfa128522e0daf1b8eb">tensor.h</a>
, <a class="el" href="group__LAOperators.html#gaa5b434083f131cddd947fc2ac8a16774">packaged_operation.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#af09db057a033608a0e95b59d3a192cb6">symmetric_tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#aad492519b2494af83eaa083eee9a7d7f">vectorization.h</a>
, <a class="el" href="base_2polynomials__barycentric_8h.html#aff6b259f6f4087a4bb96fa30d32ab168">polynomials_barycentric.h</a>
, <a class="el" href="base_2synchronous__iterator_8h.html#a71c22609d610106398fcf6b3fff02579">synchronous_iterator.h</a>
</li>
<li>operator--()
: <a class="el" href="dynamic__sparsity__pattern__0_8txt.html#a30e2fc5a7d2b0d0169f9e8682421e6ed">dynamic_sparsity_pattern_0.txt</a>
</li>
<li>operator.*[0.x.11] *Copy assignment is deleted. *[0.x.12] *Reinitialize the sparse matrix. The sparse matrix on the host is copied to the device and the elementes are reordered according to the format supported by cuSPARSE. *[0.x.13] *[2.x.6] Information on the matrix *[0.x.14] *Return the dimension of the codomain()
: <a class="el" href="cuda__sparse__matrix__0_8txt.html#aee8712834e769588b8fdc9c7fd458bdc">cuda_sparse_matrix_0.txt</a>
</li>
<li>operator.*[0.x.12] *Embedding matrix between grids. The identity operator from a coarse grid space into a fine grid space is associated with a matrix[2.x.33] The restriction of this matrix[2.x.34] to a single child cell is returned here. The matrix[2.x.35] is the concatenation, not the sum of the cell matrices[2.x.36] P_i. That is, if the same non-zero entry&lt; tt &gt;j, k&lt;/tt &gt; exists in two different child matrices[2.x.37] the value should be the same in both matrices and it is copied into the matrix[2.x.38] only once. Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator.These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix. *[0.x.13] *Return a list of constant modes of the element. *[0.x.14] *Only for internal use. Its full name is[2.x.39] function and it creates the[2.x.40] vector that is needed within the constructor to be passed to the constructor of[2.x.41] FiniteElementData. If the optional argument&lt; tt &gt;dg&lt;/tt &gt; is true, the vector returned will have all degrees of freedom assigned to the cell, none on the faces and edges. *[0.x.15] *Initialize the[2.x.42] field of the FiniteElement class and fill the tables with interpolation weights()
: <a class="el" href="fe__nedelec__0_8txt.html#a85b6f1f7d172f937673856ffa353851f">fe_nedelec_0.txt</a>
</li>
<li>operator.*[0.x.169] *Definition for the vector type for the range space of the operator.*[0.x.170] *[2.x.101] Constructors/destructor *[0.x.171] *Default constructor *[2.x.102] By design, the resulting object is inoperable since there is insufficient information with which to construct the domain and range maps. *[0.x.172] *Constructor for a sparse matrix based on an exemplary matrix *[0.x.173] *Constructor for a preconditioner based on an exemplary matrix *[0.x.174] *Constructor for a preconditioner based on an exemplary preconditioner *[0.x.175] *Default copy constructor *[0.x.176] *Composite copy constructor This is required for PackagedOperations as it sets up the domain and range maps, and composite&lt; tt &gt;vmult&lt;/tt &gt; and&lt; tt &gt;Tvmult&lt;/tt &gt; operations based on the combined operation of both operations *[0.x.177] *Destructor *[0.x.178] *Return a payload configured for identity operations *[0.x.179] *Return a payload configured for null operations *[0.x.180] *Return a payload configured for transpose operations *[0.x.181] *Return a payload configured for inverse operations Invoking this factory function will configure two additional functions, namely&lt; tt &gt;inv_vmult&lt;/tt &gt; and&lt; tt &gt;inv_Tvmult&lt;/tt &gt;, both of which wrap inverse operations. The&lt; tt &gt;vmult&lt;/tt &gt; and&lt; tt &gt;Tvmult&lt;/tt &gt; operations retain the standard definitions inherited from[2.x.103] *[2.x.104] This function is enabled only if the solver and preconditioner derive from the respective TrilinosWrappers base classes. The C++compiler will therefore only consider this function if the following criterion are satisfied:1. the[2.x.105] derives from[2.x.106] and 2. the[2.x.107] derives from[2.x.108] *[0.x.182] *Return a payload configured for inverse operations Invoking this factory function will configure two additional functions, namely&lt; tt &gt;inv_vmult&lt;/tt &gt; and&lt; tt &gt;inv_Tvmult&lt;/tt &gt;, both of which are disabled because the[2.x.109] or[2.x.110] are not compatible with Epetra_MultiVector. The&lt; tt &gt;vmult&lt;/tt &gt; and&lt; tt &gt;Tvmult&lt;/tt &gt; operations retain the standard definitions inherited from[2.x.111] *[2.x.112] The C++compiler will only consider this function if the following criterion are satisfied:1. the[2.x.113] does not derive from[2.x.114] and 2. the[2.x.115] does not derive from[2.x.116] *[0.x.183] *[2.x.117] LinearOperator functionality *[0.x.184] *Return an IndexSet that defines the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with/operate on. *[0.x.185] *Return an IndexSet that defines the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that result from matrix-vector products. *[0.x.186] *Return the MPI communicator object in use with this Payload. *[0.x.187] *Sets an internal flag so that all operations performed by the matrix, i.e., multiplications, are done in transposed order. *[2.x.118] This does not reshape the matrix to transposed form directly, so care should be taken when using this flag. *[0.x.188] *The standard matrix-vector operation to be performed by the payload when Apply is called. *[2.x.119] This is not called by a LinearOperator, but rather by Trilinos functions that expect this to mimic the action of the LinearOperator. *[0.x.189] *The standard transpose matrix-vector operation to be performed by the payload when Apply is called. *[2.x.120] This is not called by a LinearOperator, but rather by Trilinos functions that expect this to mimic the action of the LinearOperator. *[0.x.190] *The inverse matrix-vector operation to be performed by the payload when ApplyInverse is called. *[2.x.121] This is not called by a LinearOperator, but rather by Trilinos functions that expect this to mimic the action of the InverseOperator. *[0.x.191] *The inverse transpose matrix-vector operation to be performed by the payload when ApplyInverse is called. *[2.x.122] This is not called by a LinearOperator, but rather by Trilinos functions that expect this to mimic the action of the InverseOperator. *[0.x.192] *[2.x.123] Core Epetra_Operator functionality *[0.x.193] *Return the status of the transpose flag for this operator This overloads the same function from the Trilinos class Epetra_Operator. *[0.x.194] *Sets an internal flag so that all operations performed by the matrix, i.e., multiplications, are done in transposed order. This overloads the same function from the Trilinos class Epetra_Operator. *[2.x.124] This does not reshape the matrix to transposed form directly, so care should be taken when using this flag. When the flag is set to true()
: <a class="el" href="trilinos__sparse__matrix__0_8txt.html#a3af0e26831fb28ecfb416c0751227c3b">trilinos_sparse_matrix_0.txt</a>
</li>
<li>operator.*[0.x.18] *This operator assigns a scalar to a matrix. To avoid confusion with the semantics of this function, zero is the only value allowed for&lt; tt &gt;d&lt;/tt &gt;, allowing you to clear a matrix in an intuitive way.[2.x.14] *[0.x.19] *Copy operator to create a full matrix that equals the identity matrix of the size of the argument. This way, one can easily create an identity matrix of size[2.x.15] by saying *[1.x.1] **[0.x.20] *Assignment operator for a LapackFullMatrix. The calling matrix must be of the same size as the LAPACK matrix. *[0.x.21] *Assignment from different matrix classes. This assignment operator uses iterators of the typename MatrixType. Therefore, sparse matrices are possible sources. *[0.x.22] *Transposing assignment from different matrix classes. This assignment operator uses iterators of the typename MatrixType. Therefore, sparse matrices are possible sources. *[0.x.23] *Fill matrix with elements extracted from a tensor, taking rows included between&lt; tt &gt;r_i&lt;/tt &gt; and&lt; tt &gt;r_j&lt;/tt &gt; and columns between&lt; tt &gt;c_i&lt;/tt &gt; and&lt; tt &gt;c_j&lt;/tt &gt;. The resulting matrix is then inserted in the destination matrix at position&lt; tt &gt;()
: <a class="el" href="full__matrix__0_8txt.html#a94618cd943e6f0412c3168992b67f147">full_matrix_0.txt</a>
</li>
<li>operator.*[0.x.20] *Move assignment operator.Move another BlockIndices object onto the current one by transferring its contents. *[0.x.21] *Compare whether two objects are the same, i.e. whether the number of blocks and the sizes of all blocks are equal. *[0.x.22] *Swap the contents of these two objects. *[0.x.23] *Determine an estimate for the memory consumption()
: <a class="el" href="block__indices__0_8txt.html#aa12189d696c3d9ff760906c7359f6cc2">block_indices_0.txt</a>
</li>
<li>operator.*[0.x.30] *Index operator.*[0.x.31] *Store the data given to the constructor. *[0.x.32] *Provide a class that stores symmetric tensors of rank 2, 4,... efficiently, i.e. only store those off-diagonal elements of the full tensor that are not redundant. For example, for symmetric[2.x.5] tensors, this would be the elements 11, 22, and 12, while the element 21 is equal to the 12 element. Within this documentation, second order symmetric tensors are denoted as bold-faced upper-case Latin letters such as[2.x.6] or bold-faced Greek letters such as[2.x.7],[2.x.8] . The Cartesian coordinates of a second-order tensor such as[2.x.9] are represented as[2.x.10] where[2.x.11] are indices ranging from 0 to&lt; tt &gt;dim-1&lt;/tt &gt;. *Using this class for symmetric tensors of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It is also more efficient than using the more general&lt; tt &gt;Tensor&lt;/tt &gt; class, since fewer elements are stored, and the class automatically makes sure that the tensor represents a symmetric object. *For tensors of higher rank, the savings in storage are even higher. For example for the[2.x.12] tensors of rank 4, only 36 instead of the full 81 entries have to be stored. These rank 4 tensors are denoted by blackboard-style upper-case Latin letters such as[2.x.13] with components[2.x.14] . *While the definition of a symmetric rank-2 tensor is obvious, tensors of rank 4 are considered symmetric if they are operators mapping symmetric rank-2 tensors onto symmetric rank-2 tensors. This so-called minor symmetry of the rank 4 tensor requires that for every set of four indices[2.x.15], the identity[2.x.16] holds. However, it does not imply the relation[2.x.17] . Consequently, symmetric tensors of rank 4 as understood here are only tensors that map symmetric tensors onto symmetric tensors, but they do not necessarily induce a symmetric scalar product[2.x.18] or even a positive()
: <a class="el" href="symmetric__tensor__0_8txt.html#afbd18bd838ff9dbb4db003fe59cd5900">symmetric_tensor_0.txt</a>
</li>
<li>operator.*[0.x.52] *Dereferencing operator.*[0.x.53] *Comparison. True, if both iterators point to the same matrix position. *[0.x.54] *Inverse of&lt; tt &gt;==&lt;/tt &gt;. *[0.x.55] *Comparison operator.Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller. *[0.x.56] *Store an object of the accessor class. *[0.x.57] *import functions from private base class *[0.x.58] *Execute block Jacobi preconditioning. This function will automatically use the inverse matrices if they exist, if not then BlockJacobi will need much time inverting the diagonal block matrices in each preconditioning step. *[0.x.59] *Same as[2.x.34] since Jacobi is symmetric. *[0.x.60] *Execute block Jacobi preconditioning, adding to[2.x.35] This function will automatically use the inverse matrices if they exist, if not then BlockJacobi will need much time inverting the diagonal block matrices in each preconditioning step. *[0.x.61] *Same as[2.x.36] since Jacobi is symmetric. *[0.x.62] *Perform one step of the Jacobi iteration. *[0.x.63] *Perform one step of the Jacobi iteration. *[0.x.64] *Iterator starting at the first entry. *[0.x.65] *Final iterator. *[0.x.66] *Iterator starting at the first entry of row[2.x.37] *[0.x.67] *Final iterator of row[2.x.38] *[0.x.68] *Actual implementation of the preconditioner. Depending on[2.x.39] the result of preconditioning is added to the destination vector. *[0.x.69] *Block SOR preconditioning. This class satisfies the[2.x.40] &quot;relaxation concept&quot;. *The functions[2.x.41] and[2.x.42] execute a()
: <a class="el" href="precondition__block__0_8txt.html#aa8c6bb6791512df56004d3546be77e5f">precondition_block_0.txt</a>
</li>
<li>operator.*[0.x.7] *Move constructor. Create a new IndexSet by transferring the internal data of the input set. *[0.x.8] *Move assignment operator.Transfer the internal data of the input set into the current one. *[0.x.9] *Constructor from a Trilinos Epetra_BlockMap. *[0.x.10] *Remove all indices from this index set. The index set retains its size, however. *[0.x.11] *Set the maximal size of the indices upon which this object operates. This function can only be called if the index set does not yet contain any elements. This can be achieved by calling clear()
: <a class="el" href="index__set__0_8txt.html#a20c827374fef3c3d795d889a2549c9fd">index_set_0.txt</a>
</li>
<li>operator.*The class essentially consists of[2.x.0] objects that store the knowledge of how to apply the linear operator by implementing the abstract[2.x.1] interface:**[1.x.0] **But, in contrast to a usual matrix object, the domain and range of the linear operator are also bound to the LinearOperator class on the type level. Because of this,[2.x.2] has two additional function objects **[1.x.1] *that store the knowledge how to initialize()
: <a class="el" href="linear__operator__0_8txt.html#a4381615e550cc651ce9efa6d52689880">linear_operator_0.txt</a>
</li>
<li>operator.*We construct the definition of the Schur complement in the following way:*Consider a general system of linear equations that can be decomposed into two major sets of equations:[1.x.0] *where[2.x.2] represent general subblocks of the matrix[2.x.3] and, similarly, general subvectors of[2.x.4] are given by[2.x.5] . *This is equivalent to the following two statements:[1.x.1] **Assuming that[2.x.6] are both square and invertible, we could then perform one of two possible substitutions,[1.x.2] *which amount to performing block Gaussian elimination on this system of equations. *For the purpose of the current implementation, we choose to substitute()
: <a class="el" href="schur__complement__0_8txt.html#acbced5cec253d7b728389bd6877f5e08">schur_complement_0.txt</a>
</li>
<li>operator.Be careful with this thing, it may eat up huge amounts of computing time! It is most commonly used for internal consistency checks of programs. *[0.x.35] *Number of rows of this matrix. Note that the matrix is of dimension[1.x.2]. *[0.x.36] *Number of columns of this matrix. Note that the matrix is of dimension[1.x.3]. *[0.x.37] *Return whether the matrix contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. *[0.x.38] *Return the square of the norm of the vector&lt; tt &gt;v&lt;/tt &gt; induced by this matrix, i.e.[1.x.4]. This is useful, e.g. in the finite element context, where the[1.x.5] norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function. Obviously, the matrix needs to be quadratic for this operation, and for the result to actually be a norm it also needs to be either real symmetric or complex hermitian. The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense. *[0.x.39] *Build the matrix scalar product&lt; tt &gt;u&lt; sup &gt;T&lt;/sup &gt; M v&lt;/tt &gt;. This function is mostly useful when building the cellwise scalar product of two functions in the finite element context. The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense. *[0.x.40] *Return the[1.x.6]-norm of the matrix, where[2.x.40]()
: <a class="el" href="full__matrix__0_8txt.html#a8b1800e65c6d2e230066a403c62b6f82">full_matrix_0.txt</a>
</li>
<li>operator.For this the same holds as for the copy constructor:it is declared, defined and fine to be called, but the latter only for empty objects. *[0.x.41] *Reallocate memory and set up data structures for a new matrix with&lt; tt &gt;m&lt;/tt &gt;rows and&lt; tt &gt;n&lt;/tt &gt; columns, with at most&lt; tt &gt;max_per_row&lt;/tt &gt; nonzero entries per row. This function simply maps its operations to the other&lt; tt &gt;reinit&lt;/tt &gt; function. *[0.x.42] *Reallocate memory for a matrix of size&lt; tt &gt;m x n&lt;/tt &gt;. The number of entries for each row is taken from the array&lt; tt &gt;row_lengths&lt;/tt &gt; which has to give this number of each row&lt; tt &gt;i=1...m&lt;/tt &gt;. If&lt; tt &gt;m *n==0&lt;/tt &gt; all memory is freed, resulting in a total reinitialization of the object. If it is nonzero, new memory is only allocated if the new size extends the old one. This is done to save time and to avoid fragmentation of the heap. If the number of rows equals the number of columns then diagonal elements are stored first in each row to allow optimized access in relaxation methods of SparseMatrix. *[0.x.43] *Same as above, but with an ArrayView argument instead. *[0.x.44] *This function compresses the sparsity structure that this object represents. It does so by eliminating unused entries and sorting the remaining ones to allow faster access by usage of binary search algorithms. A special sorting scheme is used for the diagonal entry of quadratic matrices, which is always the first entry of each row. The memory which is no more needed is released. SparseMatrix objects require the ChunkSparsityPattern objects they are initialized with to be compressed, to reduce memory requirements. *[0.x.45] *This function can be used as a replacement for reinit()
: <a class="el" href="chunk__sparsity__pattern__0_8txt.html#aadc01fdae07378277a59731f4dc0af7f">chunk_sparsity_pattern_0.txt</a>
</li>
<li>operator.It is deleted as copying this base class without knowing the concrete kind of matrix stored may both miss important details and be expensive if the matrix is large. *[0.x.34] *Destructor. Made virtual so that one can use pointers to this class. *[0.x.35] *This operator assigns a scalar to a matrix. Since this does usually not make much sense()
: <a class="el" href="petsc__matrix__base__0_8txt.html#a5f4a6c37ceb7d4d3d5e5b075040c8798">petsc_matrix_base_0.txt</a>
</li>
<li>operator.Like the copy constructor, this may be called for objects with empty blocks only. *[0.x.7] *This operator assigns a scalar to a matrix. Since this does usually not make much sense()
: <a class="el" href="block__sparse__matrix__ez__0_8txt.html#a83b5fdff26de83d1bc94e490d2373819">block_sparse_matrix_ez_0.txt</a>
</li>
<li>operator.Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller. This function is only valid if both iterators point into the same sparsity pattern. *[0.x.12] *The sparsity pattern we operate on accessed. *[0.x.13] *The accessor of the()
: <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a84ee7fa26df11a90b18d67985a663c68">chunk_sparsity_pattern_0.txt</a>
</li>
<li>operator.Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller. This function is only valid if both iterators point into the same sparsity pattern. *[0.x.12] *The sparsity pattern we operate on accessed. *[0.x.13] *The row we currently point into. *[0.x.14] *A pointer to the element within the current row that we currently point to. *[0.x.15] *A pointer to the end of the current row. We store this to make comparison against the end of line iterator cheaper as it otherwise needs to do the IndexSet translation from row index to the index within the 'lines' array of DynamicSparsityPattern. *[0.x.16] *Move the accessor to the next nonzero entry in the matrix. *[0.x.17] *An iterator class for walking over the elements of a sparsity pattern. The typical use for these iterators is to iterate over the elements of a sparsity pattern()
: <a class="el" href="dynamic__sparsity__pattern__0_8txt.html#a54bad8a5f913ec61b386761d8d94dbfb">dynamic_sparsity_pattern_0.txt</a>
</li>
<li>operator.Returns level zero. *[0.x.4] *Implementation of a type with which to store the level of an accessor object. We only need it for the case that&lt; tt &gt;structdim==dim&lt;/tt &gt;. Otherwise, an empty object is sufficient. *[0.x.5] *A namespace that contains exception classes used by the accessor classes. **[0.x.6] **[2.x.0] *[0.x.7] *The cell is not an[2.x.1] &quot;active&quot; cell, but it already has children. Some operations, like setting refinement flags or accessing degrees of freedom are only possible on active cells. *[2.x.2] *[0.x.8] *Trying to access the children of a cell which is in fact active. *[2.x.3] *[0.x.9] *Trying to access the parent of a cell which is in the coarsest level of the triangulation. *[2.x.4] *[0.x.10] **[2.x.5] *[0.x.11] **[2.x.6] *[0.x.12] **[2.x.7] *[0.x.13] **[2.x.8] *[0.x.14] **[2.x.9] *[0.x.15] *You are trying to access the level of a face, but faces have no inherent level. The level of a face can only be determined by the level of an adjacent face, which in turn implies that a face can have several levels. *[2.x.10] *[0.x.16] *You are trying to get the periodic neighbor for a face, which does not have a periodic neighbor. For more information on this, refer to[2.x.11] &quot;entry for periodic boundaries&quot;. *[2.x.12] *[0.x.17] **[2.x.13] *[0.x.18] *A base class for the accessor classes used by TriaRawIterator and derived classes. *This class offers only the basic functionality required by the iterators()
: <a class="el" href="tria__accessor__0_8txt.html#a11057c23d23041ddbd4a19c31acdcb44">tria_accessor_0.txt</a>
</li>
<li>operator.Simply copy all members of the referenced object to the current object. *[0.x.7] *Move assignment operator.Simply move all members of the referenced object to the current object. *[0.x.8] *Determine an estimate for the memory consumption()
: <a class="el" href="number__cache__0_8txt.html#aead56db844dba6ee599d6e3d161c6728">number_cache_0.txt</a>
</li>
<li>operator.The implementation in the current class checks for equality of the following pieces of information between the current object and the one given as argument, in this order:********- the dynamic type()
: <a class="el" href="fe_2fe__0_8txt.html#a1e486a0d0e7a9e771216804632ce77ec">fe_0.txt</a>
</li>
<li>operator.These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix. If projection matrices are not implemented in the derived finite element class, this function aborts with ExcEmbeddingVoid. You can check whether this is the case by calling the prolongation_is_implemented()
: <a class="el" href="fe__q__base__0_8txt.html#aeae95c06818292d22439c276744e69a7">fe_q_base_0.txt</a>
</li>
<li>operator.This assignment operator can be safely called once the class is closed and data added, but this is provided primarily to allow a[2.x.37] object declared in a class to be reinitialized later in the class. Using the assignment operator when the object contains data could be expensive. *[0.x.6] *Deconstructor. *[0.x.7] *Add a single point to the class. The support points()
: <a class="el" href="point__value__history__0_8txt.html#aac096aad4caf95beea8c9d57b61439b8">point_value_history_0.txt</a>
</li>
<li>operator.This implies that all of the necessary functionality of the specific Trilinos operator has been overloaded within the Payload class. This includes operator-vector multiplication and inverse operator-vector multiplication, where the operator can be either a[2.x.15] or a[2.x.16] and the vector is a native Trilinos vector. *Another case where payloads provide a crucial supplement to the LinearOperator class are when composite operations are constructed()
: <a class="el" href="linear__operator__0_8txt.html#aaf8d2ae6dc0ec0ccbe0d6625e487f734">linear_operator_0.txt</a>
</li>
<li>operator.This is needed because the default copy operator of this class is deleted()
: <a class="el" href="block__matrix__base__0_8txt.html#a490b617e6a9e12abf26fabf902b179fc">block_matrix_base_0.txt</a>
</li>
<li>operator.This operator is deleted since exception objects are not copyable. *[0.x.5] *Set the file name and line of where the exception appeared as well as the violated condition and the name of the exception as a char pointer. This function also populates the stacktrace. *[0.x.6] *Override the standard function that returns the description of the error. *[0.x.7] *Get exception name. *[0.x.8] *Print out the general part of the error information. *[0.x.9] *Print more specific information about the exception which occurred. Overload this function in your own exception classes. *[0.x.10] *Print a stacktrace, if one has been recorded previously, to the given stream. *[0.x.11] *Name of the file this exception happens in. *[0.x.12] *Line number in this file. *[0.x.13] *Name of the function, pretty printed. *[0.x.14] *The violated condition, as a string. *[0.x.15] *Name of the exception and call sequence. *[0.x.16] *A backtrace to the position where the problem happened, if the system supports this. *[0.x.17] *The number of stacktrace frames that are stored in the previous variable. Zero if the system does not support stack traces. *[0.x.18] *array of pointers that contains the raw stack trace *[0.x.19] *Internal function that generates the c_string. Called by what()
: <a class="el" href="base_2exceptions__0_8txt.html#a732f409e739466a5eb54673d6c428335">exceptions_0.txt</a>
</li>
<li>operator/()
: <a class="el" href="origin_2base_2vectorization_8h.html#a7219be7ffd3e9edee8e7466b8c9e6a11">vectorization.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a6d00b8128b9d1afd9713d4bbdc5645b0">tensor.h</a>
, <a class="el" href="origin_2base_2complex__overloads_8h.html#a51cd4cb105e11fd0706a6394032f7da5">complex_overloads.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a21fef54ecf5c963b12f2f99188d5549f">vectorization.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#ad3809dc10bfba8a0b70903a9edd37d36">symmetric_tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#af6f25b89d500cb7729727d9fb88aba1d">vectorization.h</a>
, <a class="el" href="base_2tensor_8h.html#a071fce7ab1078d6407cb42ff790ef0ce">tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a7219be7ffd3e9edee8e7466b8c9e6a11">vectorization.h</a>
, <a class="el" href="base_2complex__overloads_8h.html#a05126e195996c09abcdd8e869b2c586d">complex_overloads.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#aebab187fb523e9e43f22a24139306b0b">vectorization.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#ad3809dc10bfba8a0b70903a9edd37d36">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a6d00b8128b9d1afd9713d4bbdc5645b0">tensor.h</a>
, <a class="el" href="base_2complex__overloads_8h.html#a7f70eb5194c9ccd5d61863e8f5210891">complex_overloads.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#aeb639496012bec64ed8d5f045e7d9111">symmetric_tensor.h</a>
, <a class="el" href="base_2tensor_8h.html#a361b2cfdd860d356ad80c91147c76327">tensor.h</a>
, <a class="el" href="base_2vectorization_8h.html#ac8b532bf8e52de9bdf6f50a32e0e7850">vectorization.h</a>
, <a class="el" href="origin_2base_2complex__overloads_8h.html#a849cfbde1fe9ffa52c2a7751d6c6b922">complex_overloads.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#a1bcb3aef56ca24c3a8f05bf6e8f725c6">symmetric_tensor.h</a>
, <a class="el" href="origin_2base_2vectorization_8h.html#a4cb9f95aeaf6a543d6e77ae7688de53a">vectorization.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a7eb7473ab9ff22e283ff95f8600a5ea2">tensor.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#a1bcb3aef56ca24c3a8f05bf6e8f725c6">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a7eb7473ab9ff22e283ff95f8600a5ea2">tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a4cb9f95aeaf6a543d6e77ae7688de53a">vectorization.h</a>
</li>
<li>operator:fill all components of the vector that are locally stored with the given scalar value. *[0.x.13] *Copy operator for arguments of the same type. *[0.x.14] *Reinitialize the BlockVector to contain[2.x.8] of size[2.x.9] block_size, each of which stores[2.x.10] elements locally. The[2.x.11] argument denotes which MPI channel each of these blocks shall communicate. If&lt; tt &gt;omit_zeroing_entries==false&lt;/tt &gt;, the vector is filled with zeros. *[0.x.15] *Reinitialize the BlockVector such that it contains&lt; tt &gt;block_sizes.size()
: <a class="el" href="petsc__block__vector__0_8txt.html#ac47d21eb0ec39d647f79e62d9acb7cfc">petsc_block_vector_0.txt</a>
</li>
<li>operator:fill all components of the vector with the given scalar value. *[0.x.15] *Copy operator for arguments of the same type. Resize the present vector if necessary. *[0.x.16] *Copy operator for template arguments of different types. Resize the present vector if necessary. *[0.x.17] *Copy a regular vector into a block vector. *[0.x.18] *Copy the content of a PETSc vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match. This operator is only available if deal.II was configured with PETSc. *[0.x.19] *Copy the content of a Trilinos vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match. This operator is only available if deal.II was configured with Trilinos. *[0.x.20] *Reinitialize the BlockVector to contain&lt; tt &gt;num_blocks&lt;/tt &gt; blocks of size&lt; tt &gt;block_size&lt;/tt &gt; each. If the second argument is left at its default value, then the block vector allocates the specified number of blocks but leaves them at zero size. You then need to later reinitialize the individual blocks, and call collect_sizes()
: <a class="el" href="la__parallel__block__vector__0_8txt.html#ac3157305b1f26639e50e4abb24f4f7e3">la_parallel_block_vector_0.txt</a>
</li>
<li>operator&lt;()
: <a class="el" href="base_2synchronous__iterator_8h.html#a846cec28b937d6011fac140081fcc978">synchronous_iterator.h</a>
</li>
<li>operator&lt;&lt;()
: <a class="el" href="translator_2fe_2component__mask_8h.html#a834e891fdd0598ab619b77940b2361c8">component_mask.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#ac7222180cf9feaae9ec65eebed3add75">symmetric_tensor.h</a>
, <a class="el" href="fe_2component__mask_8h.html#a834e891fdd0598ab619b77940b2361c8">component_mask.h</a>
, <a class="el" href="origin_2base_2polynomials__barycentric_8h.html#a01152ac3d588621b062bf8f500a22eb4">polynomials_barycentric.h</a>
, <a class="el" href="lac_2block__indices_8h.html#aa984c6bb0eb18200b2f40aafa7219c87">block_indices.h</a>
, <a class="el" href="grid_2cell__id_8h.html#aa313c9a01c040694fd29768c19bfd425">cell_id.h</a>
, <a class="el" href="origin_2base_2logstream_8h.html#a964cfb99372c4c0efc74f5ce305385f1">logstream.h</a>
, <a class="el" href="translator_2lac_2vector_8h.html#a8ac5a3c3ab381830b7fe68e5a2637055">vector.h</a>
, <a class="el" href="base_2vectorization_8h.html#a3676d2de40d79d2ab01808334e9a69b9">vectorization.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#a351a3d35263baee19d033e5c68bc8539">symmetric_tensor.h</a>
, <a class="el" href="grid_2tria__iterator_8h.html#ab4bfbe4e50feee1140207ce9adf0216c">tria_iterator.h</a>
, <a class="el" href="base_2logstream_8h.html#a964cfb99372c4c0efc74f5ce305385f1">logstream.h</a>
, <a class="el" href="translator_2grid_2tria__iterator_8h.html#ab4bfbe4e50feee1140207ce9adf0216c">tria_iterator.h</a>
, <a class="el" href="component__mask_8cc.html#a834e891fdd0598ab619b77940b2361c8">component_mask.cc</a>
, <a class="el" href="origin_2grid_2tria__iterator_8h.html#a564039d902573652fbc504b703329f3a">tria_iterator.h</a>
, <a class="el" href="base_2table__indices_8h.html#a423db0fb9dd4ed207e5383f473626e30">table_indices.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#aa6dbdfaae175fb64daf4370a78da8a77">tensor.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#aa5cd683fd58a42e393c546cc4abedeed">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2vectorization_8h.html#a600920aba9e31a12c5330b4f2adeae11">vectorization.h</a>
, <a class="el" href="translator_2lac_2block__indices_8h.html#aa984c6bb0eb18200b2f40aafa7219c87">block_indices.h</a>
, <a class="el" href="fe_2block__mask_8h.html#a0d0fa3fc1277d8340a897faa5cfd1a5e">block_mask.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#aa6dbdfaae175fb64daf4370a78da8a77">tensor.h</a>
, <a class="el" href="translator_2grid_2tria__iterator_8h.html#a564039d902573652fbc504b703329f3a">tria_iterator.h</a>
, <a class="el" href="translator_2fe_2fe__update__flags_8h.html#aed2a2046c26951643fa970ca4b18df79">fe_update_flags.h</a>
, <a class="el" href="translator_2base_2polynomials__barycentric_8h.html#a01152ac3d588621b062bf8f500a22eb4">polynomials_barycentric.h</a>
, <a class="el" href="translator_2base_2logstream_8h.html#a964cfb99372c4c0efc74f5ce305385f1">logstream.h</a>
, <a class="el" href="fe_2fe__update__flags_8h.html#aed2a2046c26951643fa970ca4b18df79">fe_update_flags.h</a>
, <a class="el" href="origin_2grid_2tria__iterator_8h.html#ab4bfbe4e50feee1140207ce9adf0216c">tria_iterator.h</a>
, <a class="el" href="origin_2fe_2block__mask_8h.html#a0d0fa3fc1277d8340a897faa5cfd1a5e">block_mask.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#aed228386c60c5fd56031d4f034eca97f">tensor.h</a>
, <a class="el" href="origin_2base_2point_8h.html#a5aad2c0785788ee020e0dc6ce6517dbd">point.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#ac7222180cf9feaae9ec65eebed3add75">symmetric_tensor.h</a>
, <a class="el" href="translator_2grid_2cell__id_8h.html#aa313c9a01c040694fd29768c19bfd425">cell_id.h</a>
, <a class="el" href="base_2tensor_8h.html#a26060566f66f799dab8bbe04289ed81b">tensor.h</a>
, <a class="el" href="origin_2lac_2block__indices_8h.html#aa984c6bb0eb18200b2f40aafa7219c87">block_indices.h</a>
, <a class="el" href="group__Vectors.html#ga8ac5a3c3ab381830b7fe68e5a2637055">vector.h</a>
, <a class="el" href="origin_2grid_2cell__id_8h.html#aa313c9a01c040694fd29768c19bfd425">cell_id.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#aed228386c60c5fd56031d4f034eca97f">tensor.h</a>
, <a class="el" href="translator_2fe_2block__mask_8h.html#a0d0fa3fc1277d8340a897faa5cfd1a5e">block_mask.h</a>
, <a class="el" href="grid_2tria__iterator_8h.html#a7b830e27e4921f92a1e32a2dab67c2d1">tria_iterator.h</a>
, <a class="el" href="origin_2base_2vectorization_8h.html#a600920aba9e31a12c5330b4f2adeae11">vectorization.h</a>
, <a class="el" href="origin_2fe_2fe__update__flags_8h.html#aed2a2046c26951643fa970ca4b18df79">fe_update_flags.h</a>
, <a class="el" href="origin_2fe_2component__mask_8h.html#a834e891fdd0598ab619b77940b2361c8">component_mask.h</a>
, <a class="el" href="base_2point_8h.html#a1721760589cb258f22d6e4a662fc087f">point.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#a59b659c28a047326146ab82a4cba92bd">symmetric_tensor.h</a>
, <a class="el" href="lac_2vector_8h.html#ga8ac5a3c3ab381830b7fe68e5a2637055">vector.h</a>
, <a class="el" href="block__mask_8cc.html#a0d0fa3fc1277d8340a897faa5cfd1a5e">block_mask.cc</a>
, <a class="el" href="translator_2base_2point_8h.html#a5aad2c0785788ee020e0dc6ce6517dbd">point.h</a>
, <a class="el" href="base_2polynomials__barycentric_8h.html#a01152ac3d588621b062bf8f500a22eb4">polynomials_barycentric.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#a59b659c28a047326146ab82a4cba92bd">symmetric_tensor.h</a>
</li>
<li>operator=()
: <a class="el" href="chunk__sparse__matrix__0_8txt.html#aa747ba884f098177e9bf2b2422a461a9">chunk_sparse_matrix_0.txt</a>
, <a class="el" href="sparse__matrix__0_8txt.html#a0a97fe9ce2d799dcd354353924575b04">sparse_matrix_0.txt</a>
</li>
<li>operator==()
: <a class="el" href="translator_2base_2aligned__vector_8h.html#ad12008400b484088aa5e775e6d2262ab">aligned_vector.h</a>
, <a class="el" href="base_2vectorization_8h.html#a60e4e5dd338cf4353bbdccc117fa883d">vectorization.h</a>
, <a class="el" href="base_2aligned__vector_8h.html#ad12008400b484088aa5e775e6d2262ab">aligned_vector.h</a>
</li>
<li>operator&gt;&gt;()
: <a class="el" href="origin_2base_2point_8h.html#a99d6fde57c60ebba0a20a2f698378041">point.h</a>
, <a class="el" href="translator_2grid_2cell__id_8h.html#ab004349393d13da22bd85337fa047ca1">cell_id.h</a>
, <a class="el" href="base_2point_8h.html#acbd773cc366b40253098dedf38268e55">point.h</a>
, <a class="el" href="grid_2cell__id_8h.html#ab004349393d13da22bd85337fa047ca1">cell_id.h</a>
</li>
<li>operator[1.x.10], which is implemented by vmult()
: <a class="el" href="precondition__0_8txt.html#a0a9fcbce35e83f9dfea427fca5296864">precondition_0.txt</a>
</li>
<li>operator[2.x.22] i_o_i Another iterator over iterators.[2.x.23] Returns whether the current iterator points to a different object than the iterator represented by the argument. *[0.x.18] *Implicit conversion operator.[2.x.24] When you call this conversion operator()
: <a class="el" href="iterator__range__0_8txt.html#a39ee279f4f2629a8533cc8f4128f7b00">iterator_range_0.txt</a>
</li>
<li>operator[2.x.35] to[2.x.36] For a non-defective operator[2.x.37] with a complete set of eigenpairs[2.x.38], the action of a polynomial filter[2.x.39] is given by[2.x.40], where[2.x.41] . Thus by appropriately choosing the polynomial filter, one can alter the eigenmodes contained in[2.x.42] . This function uses Chebyshev polynomials of first kind. Below is an example of polynomial[2.x.43] of degree[2.x.44] normalized to unity at[2.x.45] .[2.x.46] By introducing a linear mapping[2.x.47] from[2.x.48] to[2.x.49], we can dump the corresponding modes in[2.x.50] The higher the polynomial degree[2.x.51], the more rapid it grows outside of the[2.x.52] . In order to avoid numerical overflow, we normalize polynomial filter to unity at[2.x.53] Thus, the filtered operator is[2.x.54] . The action of the Chebyshev filter only requires evaluation of[2.x.55] of[2.x.56] and is based on the recursion equation for Chebyshev polynomial of degree[2.x.57] :[2.x.58] with[2.x.59] and[2.x.60] .[2.x.61] is used to allocate memory for temporary objects. This function implements the algorithm()
: <a class="el" href="lac_2utilities__0_8txt.html#a5603a473442dde2f052e23216f49b3de">utilities_0.txt</a>
</li>
<li>operator[2.x.9] and deformation gradient[2.x.10] as discussed for namespace[2.x.11] *As a further point on notation, we will follow Holzapfel()
: <a class="el" href="physics__0_8txt.html#a80b951dcdfab48c4260bfc2a337f2e9a">physics_0.txt</a>
</li>
<li>operator[]&lt;/tt &gt; is getting access to something with&lt; tt &gt;N-1&lt;/tt &gt; indices, we have to implement these accessor classes recursively, with stopping when we have only one index left. For the latter case, a specialization of this class is declared below, where calling&lt; tt &gt;operator[]&lt;/tt &gt; gives you access to the objects actually stored by the table. In the value given to the index operator needs to be checked whether it is inside its bounds, for which we need to know which index of the table we are actually accessing presently. This is done through the template parameter&lt; tt &gt;P&lt;/tt &gt;:it indicates, how many remaining indices there are. For a vector,&lt; tt &gt;P&lt;/tt &gt; may only be one()
: <a class="el" href="table__0_8txt.html#a41f2bc91f1a5a1e075023f0dc39ee3a7">table_0.txt</a>
</li>
<li>operator[]&lt;/tt &gt; returns the object doing the block-smoothing on a single level. This function stores pointers to the level matrices and smoothing operator for each level. *[0.x.4] *Empty all vectors. *[0.x.5] *Switch on/off reversed. This is mutually exclusive with transpose()
: <a class="el" href="mg__block__smoother__0_8txt.html#a9edf7772a75c7c706140f0e18dace669">mg_block_smoother_0.txt</a>
</li>
<li>operator[]&lt;/tt &gt;, an object with&lt; tt &gt;P=1&lt;/tt &gt; emerges. As stated for the entire namespace, you will not usually have to do with these classes directly, and should not try to use their interface directly as it may change without notice. In fact, since the constructors are made private, you will not even be able to generate objects of this class, as they are only thought as temporaries for access to elements of the table class, not for passing them around as arguments of functions, etc. This class is an adaptation of a similar class used for the Table class. *[0.x.19] *Import two alias from the switch class above. *[0.x.20] *Constructor. Take a reference to the tensor object which we will access. The second argument denotes the values of previous indices into the tensor. For example, for a rank-4 tensor, if P=2, then we will already have had two successive element selections()
: <a class="el" href="symmetric__tensor__0_8txt.html#a53f48e4be2f303137b6b9968b7bd51c0">symmetric_tensor_0.txt</a>
</li>
<li>operator[]&lt;/tt &gt;. These are quite technical, since they have to do their work recursively()
: <a class="el" href="table__0_8txt.html#ab2edf981aa114bd800f0ab6bb01fe24d">table_0.txt</a>
</li>
<li>operator[]expressions on FEValues, FEFaceValues, and FESubfaceValues objects extract certain components of a vector-valued element. The result of applying an extractor to these objects is an object with corresponding type from the namespace FEValuesViews. There are extractors for single scalar components, vector components consisting of[2.x.0] elements, and second order symmetric tensors consisting of[2.x.1] components, as well as second order nonsymmetric tensors. *One can think of extractors as the equivalent of an index, or an index range. In the case of scalar extractors()
: <a class="el" href="fe__values__extractors__0_8txt.html#a2fa5de7534e0c09715df14eba8169f9a">fe_values_extractors_0.txt</a>
</li>
<li>operators()
: <a class="el" href="automatic__and__symbolic__differentiation__0_8txt.html#ac8631d771173dfaeee801c6f1085e04e">automatic_and_symbolic_differentiation_0.txt</a>
</li>
<li>operator|()
: <a class="el" href="translator_2base_2parameter__handler_8h.html#ab39bd31c18965eb64eb5c52000292fa7">parameter_handler.h</a>
, <a class="el" href="fe_2fe__update__flags_8h.html#a7e748a6f08c90e3177731f6c84222862">fe_update_flags.h</a>
, <a class="el" href="base_2parameter__handler_8h.html#ab39bd31c18965eb64eb5c52000292fa7">parameter_handler.h</a>
, <a class="el" href="translator_2fe_2fe__update__flags_8h.html#a7e748a6f08c90e3177731f6c84222862">fe_update_flags.h</a>
</li>
<li>operator|=()
: <a class="el" href="fe_2fe__update__flags_8h.html#a04ba2e434854044efb76e6631d34b48a">fe_update_flags.h</a>
</li>
<li>options()
: <a class="el" href="fe__evaluation__0_8txt.html#ab2bac069ff963c296ce7b1fa86af6dfa">fe_evaluation_0.txt</a>
</li>
<li>or()
: <a class="el" href="tria__iterator__0_8txt.html#ab1c3345ebf45822a07f54a5d76f4b197">tria_iterator_0.txt</a>
, <a class="el" href="precondition__block__0_8txt.html#ac5876f69c6e7c12262dd198345437161">precondition_block_0.txt</a>
, <a class="el" href="relaxation__block__0_8txt.html#ab42ad18e7cca17d496ef3211f486dee8">relaxation_block_0.txt</a>
</li>
<li>order()
: <a class="el" href="discrete__time__0_8txt.html#ae5720ea6fe1e553eddf83251ba807936">discrete_time_0.txt</a>
, <a class="el" href="grid__generator__0_8txt.html#a4669279d9409e7c6a8e5e4f8adc77d0f">grid_generator_0.txt</a>
, <a class="el" href="coding__conventions__0_8txt.html#a9367b41b9e2d1b54657d63b3fa7adeef">coding_conventions_0.txt</a>
</li>
<li>orgqr()
: <a class="el" href="origin_2lac_2lapack__templates_8h.html#a1befa98b10e7654bccbcd3ef0d9a0d38">lapack_templates.h</a>
</li>
<li>orientation()
: <a class="el" href="face__info__0_8txt.html#a665bad87cdf9aba154e065607f9e469c">face_info_0.txt</a>
</li>
<li>Orientations()
: <a class="el" href="opencascade_2utilities__0_8txt.html#a6c53761eb9a34c36a0933b6797d797a7">utilities_0.txt</a>
</li>
<li>orientations()
: <a class="el" href="qprojector__0_8txt.html#a62f2339fdb9c579fb6f008d86ec2b685">qprojector_0.txt</a>
, <a class="el" href="shape__info__0_8txt.html#a96e9c4d119e7efdfa6dea47dbedd85de">shape_info_0.txt</a>
</li>
<li>ormqr()
: <a class="el" href="translator_2lac_2lapack__templates_8h.html#aeb716fcb2745755d426babdde0575ac8">lapack_templates.h</a>
</li>
<li>other()
: <a class="el" href="fe_2fe__0_8txt.html#af2de735e7461adaa61b6f405f516188d">fe_0.txt</a>
</li>
<li>out()
: <a class="el" href="fe_2fe__0_8txt.html#a684b829198012b5a810f3f34513ab0f3">fe_0.txt</a>
, <a class="el" href="la__parallel__block__vector__0_8txt.html#a38646e394cbb4630086107945fff0c2f">la_parallel_block_vector_0.txt</a>
, <a class="el" href="newton__0_8txt.html#a27b06a2d8538976cbc61c99d753beb83">newton_0.txt</a>
</li>
<li>outer_product()
: <a class="el" href="base_2tensor_8h.html#a0b76d52ead3fafce2f9c8e06cd1762ba">tensor.h</a>
, <a class="el" href="origin_2base_2symmetric__tensor_8h.html#a3a3cbccb55a4b868ddf6527eaa9d7989">symmetric_tensor.h</a>
, <a class="el" href="origin_2base_2tensor_8h.html#a855c0ce9ff2e6854210f8a7dc018322d">tensor.h</a>
, <a class="el" href="base_2symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">symmetric_tensor.h</a>
, <a class="el" href="translator_2base_2tensor_8h.html#a855c0ce9ff2e6854210f8a7dc018322d">tensor.h</a>
, <a class="el" href="translator_2base_2symmetric__tensor_8h.html#a3a3cbccb55a4b868ddf6527eaa9d7989">symmetric_tensor.h</a>
</li>
<li>output_indices()
: <a class="el" href="tensor__product__polynomials__0_8txt.html#a9011907b344adf1de41bb7f4e2dacfcf">tensor_product_polynomials_0.txt</a>
, <a class="el" href="polynomial__space__0_8txt.html#aee6c5c058a1b79341bb1b189bd689776">polynomial_space_0.txt</a>
</li>
<li>output_table()
: <a class="el" href="parsed__convergence__table__0_8txt.html#ab18b726b93f64984da8da760e8759218">parsed_convergence_table_0.txt</a>
</li>
<li>ownership()
: <a class="el" href="fe__nothing__0_8txt.html#ae5a974491f1774cd77999e7ead4c5d9c">fe_nothing_0.txt</a>
</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
