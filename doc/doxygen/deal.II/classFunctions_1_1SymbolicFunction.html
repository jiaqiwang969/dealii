<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFunctions_1_1SymbolicFunction.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Functions::SymbolicFunction&lt; dim, RangeNumberType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1SymbolicFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::SymbolicFunction&lt; dim, RangeNumberType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions Functions are used in various places in</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2symbolic__function_8h_source.html">deal.II/base/symbolic_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::SymbolicFunction&lt; dim, RangeNumberType &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17c9b367699488976bff775edf760299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a17c9b367699488976bff775edf760299">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2d8b005e27545f4674fc11914bed2d10">function</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a08995fe68ad866724ea1a53076513ad5">coordinate_symbols</a>=<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a>=<a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;), const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a>={})</td></tr>
<tr class="separator:a17c9b367699488976bff775edf760299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d679291388c3f241a44018b66367f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d679291388c3f241a44018b66367f01">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;expressions)</td></tr>
<tr class="separator:a4d679291388c3f241a44018b66367f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;substitutions)</td></tr>
<tr class="separator:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="coding__conventions__0_8txt.html#adfe0ebb079600ac17e42324297ef7c2f">arguments</a>)</td></tr>
<tr class="separator:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f7270359aff87df84713a51ca3c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a832f7270359aff87df84713a51ca3c82">get_coordinate_symbols</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a832f7270359aff87df84713a51ca3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3dacfbccafff4a1a3b8995c11c17a659">get_time_symbol</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a25b60982e08ae821b8036bc8ddf6fdee">get_symbolic_function_expressions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836518865a1d95bf9d544dd436b4f8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a836518865a1d95bf9d544dd436b4f8b1">get_user_substitution_map</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a836518865a1d95bf9d544dd436b4f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d90574552874e70a063ad089874d9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4d90574552874e70a063ad089874d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c14db38b7164318a2be05f3d52b736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:ac8c14db38b7164318a2be05f3d52b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a18793ed91ba97a1ecf8dfb5ef82a8e25">gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3c6de7f3694cda9d0baf759db0b1a9f8">laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c28ed9485acf9222de2d79b738cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#aa99c28ed9485acf9222de2d79b738cd0">hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:aa99c28ed9485acf9222de2d79b738cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d1523aac8e490301d025be11f4777"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a028d1523aac8e490301d025be11f4777"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a028d1523aac8e490301d025be11f4777">print</a> (StreamType &amp;<a class="el" href="la__parallel__block__vector__0_8txt.html#a38646e394cbb4630086107945fff0c2f">out</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a028d1523aac8e490301d025be11f4777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c9b367699488976bff775edf760299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a17c9b367699488976bff775edf760299">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2d8b005e27545f4674fc11914bed2d10">function</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a08995fe68ad866724ea1a53076513ad5">coordinate_symbols</a>=<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a>=<a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;), const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a>={})</td></tr>
<tr class="separator:a17c9b367699488976bff775edf760299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d679291388c3f241a44018b66367f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d679291388c3f241a44018b66367f01">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;expressions)</td></tr>
<tr class="separator:a4d679291388c3f241a44018b66367f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;substitutions)</td></tr>
<tr class="separator:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="coding__conventions__0_8txt.html#adfe0ebb079600ac17e42324297ef7c2f">arguments</a>)</td></tr>
<tr class="separator:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f7270359aff87df84713a51ca3c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a832f7270359aff87df84713a51ca3c82">get_coordinate_symbols</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a832f7270359aff87df84713a51ca3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3dacfbccafff4a1a3b8995c11c17a659">get_time_symbol</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a25b60982e08ae821b8036bc8ddf6fdee">get_symbolic_function_expressions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836518865a1d95bf9d544dd436b4f8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a836518865a1d95bf9d544dd436b4f8b1">get_user_substitution_map</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a836518865a1d95bf9d544dd436b4f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d90574552874e70a063ad089874d9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4d90574552874e70a063ad089874d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c14db38b7164318a2be05f3d52b736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:ac8c14db38b7164318a2be05f3d52b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a18793ed91ba97a1ecf8dfb5ef82a8e25">gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3c6de7f3694cda9d0baf759db0b1a9f8">laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c28ed9485acf9222de2d79b738cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#aa99c28ed9485acf9222de2d79b738cd0">hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:aa99c28ed9485acf9222de2d79b738cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ab183ee4afeb9c27cc6bd03c2b13ec69d">print</a> (StreamType &amp;<a class="el" href="la__parallel__block__vector__0_8txt.html#a38646e394cbb4630086107945fff0c2f">out</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c9b367699488976bff775edf760299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a17c9b367699488976bff775edf760299">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2d8b005e27545f4674fc11914bed2d10">function</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a08995fe68ad866724ea1a53076513ad5">coordinate_symbols</a>=<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a>=<a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;), const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a>={})</td></tr>
<tr class="separator:a17c9b367699488976bff775edf760299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d679291388c3f241a44018b66367f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d679291388c3f241a44018b66367f01">SymbolicFunction</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;expressions)</td></tr>
<tr class="separator:a4d679291388c3f241a44018b66367f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;substitutions)</td></tr>
<tr class="separator:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="coding__conventions__0_8txt.html#adfe0ebb079600ac17e42324297ef7c2f">arguments</a>)</td></tr>
<tr class="separator:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f7270359aff87df84713a51ca3c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a832f7270359aff87df84713a51ca3c82">get_coordinate_symbols</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a832f7270359aff87df84713a51ca3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3dacfbccafff4a1a3b8995c11c17a659">get_time_symbol</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a25b60982e08ae821b8036bc8ddf6fdee">get_symbolic_function_expressions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836518865a1d95bf9d544dd436b4f8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a836518865a1d95bf9d544dd436b4f8b1">get_user_substitution_map</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a836518865a1d95bf9d544dd436b4f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d90574552874e70a063ad089874d9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4d90574552874e70a063ad089874d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c14db38b7164318a2be05f3d52b736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:ac8c14db38b7164318a2be05f3d52b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a18793ed91ba97a1ecf8dfb5ef82a8e25">gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3c6de7f3694cda9d0baf759db0b1a9f8">laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c28ed9485acf9222de2d79b738cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#aa99c28ed9485acf9222de2d79b738cd0">hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> override</td></tr>
<tr class="separator:aa99c28ed9485acf9222de2d79b738cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ab183ee4afeb9c27cc6bd03c2b13ec69d">print</a> (StreamType &amp;<a class="el" href="la__parallel__block__vector__0_8txt.html#a38646e394cbb4630086107945fff0c2f">out</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ab183ee4afeb9c27cc6bd03c2b13ec69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316ebc05d21989d573024f8a23c49cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae316ebc05d21989d573024f8a23c49cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316ebc05d21989d573024f8a23c49cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae316ebc05d21989d573024f8a23c49cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316ebc05d21989d573024f8a23c49cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae316ebc05d21989d573024f8a23c49cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fc1114e95e702e6696721f71528db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a562fc1114e95e702e6696721f71528db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fc1114e95e702e6696721f71528db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a562fc1114e95e702e6696721f71528db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fc1114e95e702e6696721f71528db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a562fc1114e95e702e6696721f71528db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041dde994d40c068e00661197ac75a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aa041dde994d40c068e00661197ac75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041dde994d40c068e00661197ac75a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aa041dde994d40c068e00661197ac75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041dde994d40c068e00661197ac75a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aa041dde994d40c068e00661197ac75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">vector_gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">vector_gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">vector_gradient</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf557f137782b46e85461235d5bd47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcf557f137782b46e85461235d5bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf557f137782b46e85461235d5bd47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcf557f137782b46e85461235d5bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf557f137782b46e85461235d5bd47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcf557f137782b46e85461235d5bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f7bff0fb455c042086f98bd003ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">vector_gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a109f7bff0fb455c042086f98bd003ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f7bff0fb455c042086f98bd003ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">vector_gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a109f7bff0fb455c042086f98bd003ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f7bff0fb455c042086f98bd003ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">vector_gradient_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="line__minimization__0_8txt.html#ab9da9934f59b216964641fa6de18b773">gradients</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a109f7bff0fb455c042086f98bd003ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33430fb1069660fb8cfe599181aceefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">vector_laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a33430fb1069660fb8cfe599181aceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33430fb1069660fb8cfe599181aceefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">vector_laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a33430fb1069660fb8cfe599181aceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33430fb1069660fb8cfe599181aceefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">vector_laplacian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a33430fb1069660fb8cfe599181aceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80353c3a581fa918ea555c3e1c7353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aae80353c3a581fa918ea555c3e1c7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80353c3a581fa918ea555c3e1c7353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aae80353c3a581fa918ea555c3e1c7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80353c3a581fa918ea555c3e1c7353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:aae80353c3a581fa918ea555c3e1c7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ff5ce8fddc37866077976df598f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">vector_laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a6582ff5ce8fddc37866077976df598f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ff5ce8fddc37866077976df598f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">vector_laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a6582ff5ce8fddc37866077976df598f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ff5ce8fddc37866077976df598f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">vector_laplacian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a6582ff5ce8fddc37866077976df598f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="vector__tools__boundary__0_8txt.html#ad5d74707449246401c828f2ad820ab69">component</a>=0) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&gt;&gt; &amp;<a class="el" href="vector__tools__0_8txt.html#a2eab42f23d29c952a751bc76e5e109ee">values</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2718abd675ea2999ce0687c8cf871d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a> ()</td></tr>
<tr class="separator:a2718abd675ea2999ce0687c8cf871d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2718abd675ea2999ce0687c8cf871d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a> ()</td></tr>
<tr class="separator:a2718abd675ea2999ce0687c8cf871d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2718abd675ea2999ce0687c8cf871d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a> ()</td></tr>
<tr class="separator:a2718abd675ea2999ce0687c8cf871d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a></td></tr>
<tr class="separator:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acc93ac7b685f9fe84ad7acbfedfcceb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#acc93ac7b685f9fe84ad7acbfedfcceb6">dimension</a></td></tr>
<tr class="separator:acc93ac7b685f9fe84ad7acbfedfcceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae55e876e8b12f682ac61c2813e11b512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ae55e876e8b12f682ac61c2813e11b512">create_evaluation_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="fe__field__function__0_8txt.html#a1ad3501ac8b2af2a49edabb9e5af5697">point</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae55e876e8b12f682ac61c2813e11b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d31b290d25c474d8f6f5fee15d15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a250d31b290d25c474d8f6f5fee15d15f">update_values</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a250d31b290d25c474d8f6f5fee15d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48156a0255a46c28018453a45456bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a48156a0255a46c28018453a45456bd3f">update_first_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a48156a0255a46c28018453a45456bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd97b22b242e8a5943822f3699143bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#afcd97b22b242e8a5943822f3699143bd">update_second_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcd97b22b242e8a5943822f3699143bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55e876e8b12f682ac61c2813e11b512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ae55e876e8b12f682ac61c2813e11b512">create_evaluation_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="fe__field__function__0_8txt.html#a1ad3501ac8b2af2a49edabb9e5af5697">point</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae55e876e8b12f682ac61c2813e11b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d31b290d25c474d8f6f5fee15d15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a250d31b290d25c474d8f6f5fee15d15f">update_values</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a250d31b290d25c474d8f6f5fee15d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48156a0255a46c28018453a45456bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a48156a0255a46c28018453a45456bd3f">update_first_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a48156a0255a46c28018453a45456bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd97b22b242e8a5943822f3699143bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#afcd97b22b242e8a5943822f3699143bd">update_second_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcd97b22b242e8a5943822f3699143bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55e876e8b12f682ac61c2813e11b512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ae55e876e8b12f682ac61c2813e11b512">create_evaluation_substitution_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="fe__field__function__0_8txt.html#a1ad3501ac8b2af2a49edabb9e5af5697">point</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae55e876e8b12f682ac61c2813e11b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d31b290d25c474d8f6f5fee15d15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a250d31b290d25c474d8f6f5fee15d15f">update_values</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a250d31b290d25c474d8f6f5fee15d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48156a0255a46c28018453a45456bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a48156a0255a46c28018453a45456bd3f">update_first_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a48156a0255a46c28018453a45456bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd97b22b242e8a5943822f3699143bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#afcd97b22b242e8a5943822f3699143bd">update_second_derivatives</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:afcd97b22b242e8a5943822f3699143bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8cce44d44eb4c0842dd29eb54ae0cebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a8cce44d44eb4c0842dd29eb54ae0cebf">user_function</a></td></tr>
<tr class="separator:a8cce44d44eb4c0842dd29eb54ae0cebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648084b629c8192e4c2c0fcee7ca5fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a></td></tr>
<tr class="separator:a648084b629c8192e4c2c0fcee7ca5fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b2e0ff9e3bf0062a5eb0167c8c46ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a94b2e0ff9e3bf0062a5eb0167c8c46ac">additional_function_arguments</a></td></tr>
<tr class="separator:a94b2e0ff9e3bf0062a5eb0167c8c46ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8b005e27545f4674fc11914bed2d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2d8b005e27545f4674fc11914bed2d10">function</a></td></tr>
<tr class="separator:a2d8b005e27545f4674fc11914bed2d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc72838c9154a619dd654c6e171d922a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#afc72838c9154a619dd654c6e171d922a">function_gradient</a></td></tr>
<tr class="separator:afc72838c9154a619dd654c6e171d922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a15e934221d9153f98ccd7ae796b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a25a15e934221d9153f98ccd7ae796b6b">function_hessian</a></td></tr>
<tr class="separator:a25a15e934221d9153f98ccd7ae796b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfe811e0cea64e705da9d095630dbff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a6bfe811e0cea64e705da9d095630dbff">function_laplacian</a></td></tr>
<tr class="separator:a6bfe811e0cea64e705da9d095630dbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08995fe68ad866724ea1a53076513ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a08995fe68ad866724ea1a53076513ad5">coordinate_symbols</a></td></tr>
<tr class="separator:a08995fe68ad866724ea1a53076513ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3f87cbc1405dd3604863b365bfb1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a></td></tr>
<tr class="separator:abc3f87cbc1405dd3604863b365bfb1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a></td></tr>
<tr class="separator:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, std::string, std::string,&lt;&lt; &quot;Object <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg2&lt;&lt; &quot; is still <a class="el" href="kinsol__0_8txt.html#a19e73f3d7e2bbefc4ec076d97de80570">used</a> <a class="el" href="data__out__dof__data__0_8txt.html#a17832850ea240be223f45ca3fc9e3ad8">by</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\<a class="el" href="tensor__polynomials__base__0_8txt.html#afdd52dfdef2425462b558c76cd7a3c49">n\n</a>&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> <a class="el" href="any__data__0_8txt.html#ac7bd1b0fa154f30c162b019580dacc97">entry</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> Frequently Asked Questions <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> &quot;&lt;&lt; &quot;<a class="el" href="petsc__matrix__base__0_8txt.html#aeb98faf2dc1f3bc185b173eaba26928b">deal.II</a> (linked <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="matrix__free__0_8txt.html#a415c819fcc6f671265057640dc18ad44">from</a> http://www.dealii.org/) <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> &quot;&lt;&lt; &quot;<a class="el" href="vector__tools__constraints__0_8txt.html#a5bb8955c98135fbb60012ceeee4b7839">a</a> lot <a class="el" href="petsc__matrix__base__0_8txt.html#a91d0bc46add3efe5a167829805522d28">more</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a> <a class="el" href="data__postprocessor__0_8txt.html#a232fd208d0a301873073f51d8474883a">on</a> what <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="vector__tools__integrate__difference__0_8txt.html#a314323b5102f87ea7e2b4a1aba773b82">error</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a767c487cfadd1a8705c06e38b12838d5">means</a> <a class="el" href="histogram__0_8txt.html#a289e95579c441f9a994ce0a00f5a114a">and</a> &quot;&lt;&lt; &quot;<a class="el" href="fe__poly__tensor__0_8txt.html#a698742fc4e3c5d9a3746b1a9703c1045">how</a> <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> fix <a class="el" href="vector__0_8txt.html#a32dac5cdfac1128c9e998de82a6f4d51">programs</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="function__restriction__0_8txt.html#a79f2798b238440d7e1841d2cf4711885">which</a> <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">object</a> <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> cannot <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a> unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; *<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> validity, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;identifier=&quot;&quot;) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tria__iterator__0_8txt.html#ac9bf02a383d06131223d3dc343d9db1f">version</a>)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, std::string, std::string,&lt;&lt; &quot;Object <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg2&lt;&lt; &quot; is still <a class="el" href="kinsol__0_8txt.html#a19e73f3d7e2bbefc4ec076d97de80570">used</a> <a class="el" href="data__out__dof__data__0_8txt.html#a17832850ea240be223f45ca3fc9e3ad8">by</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\<a class="el" href="tensor__polynomials__base__0_8txt.html#afdd52dfdef2425462b558c76cd7a3c49">n\n</a>&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> <a class="el" href="any__data__0_8txt.html#ac7bd1b0fa154f30c162b019580dacc97">entry</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> Frequently Asked Questions <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> &quot;&lt;&lt; &quot;<a class="el" href="petsc__matrix__base__0_8txt.html#aeb98faf2dc1f3bc185b173eaba26928b">deal.II</a> (linked <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="matrix__free__0_8txt.html#a415c819fcc6f671265057640dc18ad44">from</a> http://www.dealii.org/) <a class="el" href="chunk__sparse__matrix__0_8txt.html#aae7ed603ea40c1e6a20bb18bab713802">for</a> &quot;&lt;&lt; &quot;<a class="el" href="vector__tools__constraints__0_8txt.html#a5bb8955c98135fbb60012ceeee4b7839">a</a> lot <a class="el" href="petsc__matrix__base__0_8txt.html#a91d0bc46add3efe5a167829805522d28">more</a> <a class="el" href="particles_2partitioner__0_8txt.html#aebeefe540d7186696ccb0c5517c2bd98">information</a> <a class="el" href="data__postprocessor__0_8txt.html#a232fd208d0a301873073f51d8474883a">on</a> what <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="vector__tools__integrate__difference__0_8txt.html#a314323b5102f87ea7e2b4a1aba773b82">error</a> <a class="el" href="chunk__sparsity__pattern__0_8txt.html#a767c487cfadd1a8705c06e38b12838d5">means</a> <a class="el" href="histogram__0_8txt.html#a289e95579c441f9a994ce0a00f5a114a">and</a> &quot;&lt;&lt; &quot;<a class="el" href="fe__poly__tensor__0_8txt.html#a698742fc4e3c5d9a3746b1a9703c1045">how</a> <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> fix <a class="el" href="vector__0_8txt.html#a32dac5cdfac1128c9e998de82a6f4d51">programs</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="function__restriction__0_8txt.html#a79f2798b238440d7e1841d2cf4711885">which</a> <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes <a class="el" href="error__estimator__0_8txt.html#a4ec80ded5cb4f47bcabf0a970c68075b">to</a> <a class="el" href="data__postprocessor__0_8txt.html#a600bd43d5bd41af065e85ec3e40fed92">this</a> <a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">object</a> <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> <a class="el" href="glossary__0_8txt.html#a93b103a7f521d431e3489028bb7f9e9f">class</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> cannot <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a> unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="grid_2manifold__0_8txt.html#ac23a4ff7d359fbeb8dbe7993e2ae9c5e">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename RangeNumberType = double&gt;<br />
class Functions::SymbolicFunction&lt; dim, RangeNumberType &gt;</h3>

<p>A <a class="el" href="classFunction.html">Function</a> class that leverages symbolic differentiation to compute gradients, Laplacians, Hessians, and time derivatives. This class can be used to define functions using methods provided by the <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> namespace. In particular, one can define a symbolic evaluation point (the argument of the function), as well as a symbolic expression. The symbolic gradients and the symbolic Hessians are computed at construction time, and when a substitution in the symbolic functions is requested by the user using the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>. Whenever one of the evaluation methods is called, a substitution is attempted with the coordinate symbols argument replaced by the evaluation point and the symbolic time replaced by the current time, as returned by the <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a> method. The user has to make sure that at evaluation time argument substitution provides a fully evaluated expression (i.e., no other symbols are contained in the function expression, except numerical values), or an exception will be thrown. Additional symbols can be partially evaluated or substituted by storing them in a user supplied substitution maps, that can be updated by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> or the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> methods. The simplest use case of this class is given in the following example: </p><div class="fragment"><div class="line">SymbolicFunction&lt;2&gt; fun(<span class="stringliteral">&quot;x^2+y; t*x*y&quot;</span>);</div>
<div class="line">fun.set_time(3.0);</div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(1.0, 2.0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="function__tools__0_8txt.html#a1a2acf608502527a80c0aeecdc12c908">a</a> = fun.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> / 0); <span class="comment">// a = 3.0</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="mg__0_8txt.html#a05d914308ac970c97c941a291a81ccc1">b</a> = fun.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> / 1); <span class="comment">// b = 6.0</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> df_dt = fun.time_derivative();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = df_dt.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> / 0); <span class="comment">// c = 0.0</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = df_dt.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> / 1); <span class="comment">// d = 2.0</span></div>
</div><!-- fragment --><p> where a <a class="el" href="classFunction.html">Function</a> with two components is defined using a string containing their expressions separated by semicolons. A more involved example, that explicitly uses <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> objects, is given by </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a>;</div>
<div class="line"><span class="comment">// Create a position Tensor&lt;1,2,Differentiation::SD::Expression&gt;</span></div>
<div class="line"><span class="comment">// with symbols &quot;x&quot; and &quot;y&quot;, and the symbol &quot;t&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a> = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">SymbolicFunction&lt;2&gt;::get_default_coordinate_symbols</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> t = <a class="code" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">make_symbol</a>(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use directly x[0] (the symbol &quot;x&quot;), x[1] (the symbol &quot;y&quot;), and t</span></div>
<div class="line"><span class="comment">// (the symbol &quot;t&quot;).</span></div>
<div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a> = <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>[0])*<a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>[1])*<a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(t);</div>
<div class="line"><span class="comment">// Alternatively, you can achieve the same result parsing a string:</span></div>
<div class="line"><span class="comment">// Expression f(&quot;sin(x)*cos(y)*sin(t)&quot;, true);</span></div>
<div class="line">SymbolicFunction&lt;2&gt; <span class="keyword">function</span>({<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>}, <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the function, its gradient, and its Laplacian</span></div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(1.0, 2.0);</div>
<div class="line"><span class="keyword">auto</span> fp = <span class="keyword">function</span>.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> gradfp = <span class="keyword">function</span>.gradient(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> lapfp = <span class="keyword">function</span>.laplacian(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the time derivative of the function, its gradient, and its</span></div>
<div class="line"><span class="comment">// Laplacian</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> = <span class="keyword">function</span>.time_derivative();</div>
<div class="line"><span class="keyword">auto</span> dt_fp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> dt_gradfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.gradient(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> dt_lapfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.laplacian(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
</div><!-- fragment --><p> Partial substitution is possible (i.e., you can define the function using additional symbols). However, as soon as you evaluate the function, you have to make sure that all extraneous symbols (i.e., those not referring to the spacial <code>coordinate_symbols</code> or to the <code>time_symbol</code> variable) have been substituted with numerical values, or expressions of the spatial or temporal argument, by calling the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> or the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> methods. If your function requires additional arguments to be evaluated, you can specify them by calling the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> method. If you call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> and <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> with the same argument, the effect on the function evaluation will be the same, however, the internal behavior and function derivatives will be different. The method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> performs the substitution once (the first time it is required), and then stores internally a copy of the resulting expression, together with its derivatives (if required). These are then used in all subsequent evaluations. Calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> will evaluate the passed substitution map on the fly during evaluation time,after* all derivatives have been computed. </p><dl class="section note"><dt>Note</dt><dd>The difference between this class and the <a class="el" href="classFunctionParser.html">FunctionParser</a> class is that this class allows to compute first and second order derivatives (in a symbolic way), while the <a class="el" href="classFunctionParser.html">FunctionParser</a> class computes first order derivatives only, using finite differences. For complicated expressions, this class may be slower than the <a class="el" href="classFunctionParser.html">FunctionParser</a> class.</dd></dl>
<p>A <a class="el" href="classFunction.html">Function</a> class that leverages symbolic differentiation to compute gradients, Laplacians, Hessians, and time derivatives.</p>
<p>This class can be used to define functions using methods provided by the <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> namespace. In particular, one can define a symbolic evaluation point (the argument of the function), as well as a symbolic expression.</p>
<p>The symbolic gradients and the symbolic Hessians are computed at construction time, and when a substitution in the symbolic functions is requested by the user using the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>.</p>
<p>Whenever one of the evaluation methods is called, a substitution is attempted with the coordinate symbols argument replaced by the evaluation point and the symbolic time replaced by the current time, as returned by the <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a> method. The user has to make sure that at evaluation time argument substitution provides a fully evaluated expression (i.e., no other symbols are contained in the function expression, except numerical values), or an exception will be thrown. Additional symbols can be partially evaluated or substituted by storing them in a user supplied substitution maps, that can be updated by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> or the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> methods.</p>
<p>The simplest use case of this class is given in the following example: </p><div class="fragment"><div class="line">SymbolicFunction&lt;2&gt; fun(<span class="stringliteral">&quot;x^2+y; t*x*y&quot;</span>);</div>
<div class="line">fun.set_time(3.0);</div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(1.0, 2.0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="function__tools__0_8txt.html#a1a2acf608502527a80c0aeecdc12c908">a</a> = fun.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / * <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> * / 0); <span class="comment">// a = 3.0</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="mg__0_8txt.html#a05d914308ac970c97c941a291a81ccc1">b</a> = fun.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / * <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> * / 1); <span class="comment">// b = 6.0</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> df_dt = fun.time_derivative();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a> = df_dt.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / * <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> * / 0); <span class="comment">// c = 0.0</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a> = df_dt.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, / * <a class="code" href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a> * / 1); <span class="comment">// d = 2.0</span></div>
</div><!-- fragment --><p> where a <a class="el" href="classFunction.html">Function</a> with two components is defined using a string containing their expressions separated by semicolons.</p>
<p>A more involved example, that explicitly uses <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> objects, is given by </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a>;</div>
<div class="line"><span class="comment">// Create a position Tensor&lt;1,2,Differentiation::SD::Expression&gt;</span></div>
<div class="line"><span class="comment">// with symbols &quot;x&quot; and &quot;y&quot;, and the symbol &quot;t&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a> = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">SymbolicFunction&lt;2&gt;::get_default_coordinate_symbols</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> t = <a class="code" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">make_symbol</a>(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use directly x[0] (the symbol &quot;x&quot;), x[1] (the symbol &quot;y&quot;), and t</span></div>
<div class="line"><span class="comment">// (the symbol &quot;t&quot;).</span></div>
<div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a> = <a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>[0])*<a class="code" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>[1])*<a class="code" href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">std::sin</a>(t);</div>
<div class="line"><span class="comment">// Alternatively, you can achieve the same result parsing a string:</span></div>
<div class="line"><span class="comment">// Expression f(&quot;sin(x)*cos(y)*sin(t)&quot;, true);</span></div>
<div class="line">SymbolicFunction&lt;2&gt; <span class="keyword">function</span>({<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a>}, <a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the function, its gradient, and its Laplacian</span></div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>(1.0, 2.0);</div>
<div class="line"><span class="keyword">auto</span> fp = <span class="keyword">function</span>.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> gradfp = <span class="keyword">function</span>.gradient(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> lapfp = <span class="keyword">function</span>.laplacian(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the time derivative of the function, its gradient, and its</span></div>
<div class="line"><span class="comment">// Laplacian</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> = <span class="keyword">function</span>.time_derivative();</div>
<div class="line"><span class="keyword">auto</span> dt_fp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.value(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> dt_gradfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.gradient(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
<div class="line"><span class="keyword">auto</span> dt_lapfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.laplacian(<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>);</div>
</div><!-- fragment --><p>Partial substitution is possible (i.e., you can define the function using additional symbols). However, as soon as you evaluate the function, you have to make sure that all extraneous symbols (i.e., those not referring to the spacial <code>coordinate_symbols</code> or to the <code>time_symbol</code> variable) have been substituted with numerical values, or expressions of the spatial or temporal argument, by calling the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> or the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> methods.</p>
<p>If your function requires additional arguments to be evaluated, you can specify them by calling the <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> method.</p>
<p>If you call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> and <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> with the same argument, the effect on the function evaluation will be the same, however, the internal behavior and function derivatives will be different. The method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> performs the substitution once (the first time it is required), and then stores internally a copy of the resulting expression, together with its derivatives (if required). These are then used in all subsequent evaluations. Calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a> will evaluate the passed substitution map on the fly during evaluation time, <em>after</em> all derivatives have been computed.</p>
<dl class="section note"><dt>Note</dt><dd>The difference between this class and the <a class="el" href="classFunctionParser.html">FunctionParser</a> class is that this class allows to compute first and second order derivatives (in a symbolic way), while the <a class="el" href="classFunctionParser.html">FunctionParser</a> class computes first order derivatives only, using finite differences. For complicated expressions, this class may be slower than the <a class="el" href="classFunctionParser.html">FunctionParser</a> class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00144">144</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="base_2function_8h_source.html#l00163">163</a> of file <a class="el" href="base_2function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2function_8h_source.html#l00170">170</a> of file <a class="el" href="origin_2base_2function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type&gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2function_8h_source.html#l00163">163</a> of file <a class="el" href="translator_2base_2function_8h_source.html">function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a17c9b367699488976bff775edf760299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9b367699488976bff775edf760299">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinate_symbols</em> = <code><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>time_symbol</em> = <code><a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>user_substitution_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. The resulting <a class="el" href="classFunction.html">Function</a> object will have as many components as there are entries in the vector of symbolic expressions <code>function</code>. The vector <code>function</code> should contain a list of symbolic expression involving the coordinate symbols argument <code>coordinate_symbols</code> and possibly the symbolic time argument <code>time_symbol</code>. It is possible to define it in terms of other symbols, as long as the optional parameter <code>user_substitution_map</code> replaces all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code>. This is useful if, for example, you want to express formulas in terms of material parameters that you want to name symbolically, rather than through their numeric values when defining the formula, or when you want to express your formula in terms of polar coordinates rather than cartesian ones, and you want the symbolic engine to compute the derivatives for you. You may later update the symbol map contained in <code>user_substitution_map</code> by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>A vector of symbolic expressions of type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, representing the components of this <a class="el" href="classFunction.html">Function</a>.</td></tr>
    <tr><td class="paramname">coordinate_symbols</td><td>A tensor of symbols representing coordinates, used as input argument in the symbolic expressions contained in the <code>function</code> vector. The default <code>coordinate_symbols</code> is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three.</td></tr>
    <tr><td class="paramname">time_symbol</td><td>A symbolic variable representing time. It defaults to a symbolic variable named "t".</td></tr>
    <tr><td class="paramname">user_substitution_map</td><td>Any other symbol that may be contained in the symbolic function needs to be specified in this map. The map may be empty, and the functions may still contain unevaluated symbols, provided that you call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> and provide a replacement of all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code> before any evaluation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d679291388c3f241a44018b66367f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d679291388c3f241a44018b66367f01">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes a single string that describes the function expression as a semicolon separated list of expressions. The symbolic expression can use the default argument and the default symbolic time variable, plus any additional symbols that you may need, provided that you update the user substitution map that substitutes all of them before you try to evaluate the function or its derivatives, by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>, and that you provide all the additional function arguments of your function using the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a>. </p>

</div>
</div>
<a id="a17c9b367699488976bff775edf760299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9b367699488976bff775edf760299">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinate_symbols</em> = <code><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>time_symbol</em> = <code><a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>user_substitution_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<p>The resulting <a class="el" href="classFunction.html">Function</a> object will have as many components as there are entries in the vector of symbolic expressions <code>function</code>.</p>
<p>The vector <code>function</code> should contain a list of symbolic expression involving the coordinate symbols argument <code>coordinate_symbols</code> and possibly the symbolic time argument <code>time_symbol</code>. It is possible to define it in terms of other symbols, as long as the optional parameter <code>user_substitution_map</code> replaces all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code>. This is useful if, for example, you want to express formulas in terms of material parameters that you want to name symbolically, rather than through their numeric values when defining the formula, or when you want to express your formula in terms of polar coordinates rather than cartesian ones, and you want the symbolic engine to compute the derivatives for you. You may later update the symbol map contained in <code>user_substitution_map</code> by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>A vector of symbolic expressions of type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, representing the components of this <a class="el" href="classFunction.html">Function</a>.</td></tr>
    <tr><td class="paramname">coordinate_symbols</td><td>A tensor of symbols representing coordinates, used as input argument in the symbolic expressions contained in the <code>function</code> vector. The default <code>coordinate_symbols</code> is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three.</td></tr>
    <tr><td class="paramname">time_symbol</td><td>A symbolic variable representing time. It defaults to a symbolic variable named "t".</td></tr>
    <tr><td class="paramname">user_substitution_map</td><td>Any other symbol that may be contained in the symbolic function needs to be specified in this map. The map may be empty, and the functions may still contain unevaluated symbols, provided that you call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> and provide a replacement of all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code> before any evaluation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d679291388c3f241a44018b66367f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d679291388c3f241a44018b66367f01">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes a single string that describes the function expression as a semicolon separated list of expressions.</p>
<p>The symbolic expression can use the default argument and the default symbolic time variable, plus any additional symbols that you may need, provided that you update the user substitution map that substitutes all of them before you try to evaluate the function or its derivatives, by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>, and that you provide all the additional function arguments of your function using the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a>. </p>

</div>
</div>
<a id="a17c9b367699488976bff775edf760299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9b367699488976bff775edf760299">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinate_symbols</em> = <code><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>time_symbol</em> = <code><a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>user_substitution_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. The resulting <a class="el" href="classFunction.html">Function</a> object will have as many components as there are entries in the vector of symbolic expressions <code>function</code>. The vector <code>function</code> should contain a list of symbolic expression involving the coordinate symbols argument <code>coordinate_symbols</code> and possibly the symbolic time argument <code>time_symbol</code>. It is possible to define it in terms of other symbols, as long as the optional parameter <code>user_substitution_map</code> replaces all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code>. This is useful if, for example, you want to express formulas in terms of material parameters that you want to name symbolically, rather than through their numeric values when defining the formula, or when you want to express your formula in terms of polar coordinates rather than cartesian ones, and you want the symbolic engine to compute the derivatives for you. You may later update the symbol map contained in <code>user_substitution_map</code> by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>A vector of symbolic expressions of type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, representing the components of this <a class="el" href="classFunction.html">Function</a>.</td></tr>
    <tr><td class="paramname">coordinate_symbols</td><td>A tensor of symbols representing coordinates, used as input argument in the symbolic expressions contained in the <code>function</code> vector. The default <code>coordinate_symbols</code> is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three.</td></tr>
    <tr><td class="paramname">time_symbol</td><td>A symbolic variable representing time. It defaults to a symbolic variable named "t".</td></tr>
    <tr><td class="paramname">user_substitution_map</td><td>Any other symbol that may be contained in the symbolic function needs to be specified in this map. The map may be empty, and the functions may still contain unevaluated symbols, provided that you call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> and provide a replacement of all symbols except <code>coordinate_symbols</code> and <code>time_symbol</code> before any evaluation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d679291388c3f241a44018b66367f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d679291388c3f241a44018b66367f01">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes a single string that describes the function expression as a semicolon separated list of expressions. The symbolic expression can use the default argument and the default symbolic time variable, plus any additional symbols that you may need, provided that you update the user substitution map that substitutes all of them before you try to evaluate the function or its derivatives, by calling <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>, and that you provide all the additional function arguments of your function using the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98ed0e06b9e5da65ab6ce09bd27473d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ed0e06b9e5da65ab6ce09bd27473d7">&#9670;&nbsp;</a></span>update_user_substitution_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_user_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store and apply the substitution map <code>substitutions</code> to each symbolic component of this <a class="el" href="classFunction.html">Function</a> object. Notice that this method will trigger a recomputation of the gradients, Hessians, and Laplacians of each component. </p>

</div>
</div>
<a id="a7ad742d6b3841d324f6d092ff2b62c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad742d6b3841d324f6d092ff2b62c41">&#9670;&nbsp;</a></span>set_additional_function_arguments() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::set_additional_function_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the additional <code>arguments</code> to be substituted in next evaluation step. Notice that the <code>arguments</code> are substitutedafter* evaluating the <code>permanent_user_substitution_map</code>, and after all derivatives are computed. If the additional arguments you pass still depend on the coordinate or time symbols, then evaluation of derivatives will result in a partial derivative evaluation. This method provides a way to evaluate functions that depend on more arguments than simply the coordinates and time. If you want to compute the total derivative w.r.t. to complicated symbolic expressions, you should call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> instead. </p>

</div>
</div>
<a id="a2718abd675ea2999ce0687c8cf871d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2718abd675ea2999ce0687c8cf871d2e">&#9670;&nbsp;</a></span>get_default_coordinate_symbols() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_default_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a tensor of coordinate symbols that can be used to define the expressions of this symbolic function object. The default argument is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three. </p>

</div>
</div>
<a id="a832f7270359aff87df84713a51ca3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f7270359aff87df84713a51ca3c82">&#9670;&nbsp;</a></span>get_coordinate_symbols() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual arguments used for the coordinates in the symbolic function. This object does not include any user-defined arguments. </p>

</div>
</div>
<a id="a3dacfbccafff4a1a3b8995c11c17a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dacfbccafff4a1a3b8995c11c17a659">&#9670;&nbsp;</a></span>get_time_symbol() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_time_symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic time in use in this symbolic function. </p>

</div>
</div>
<a id="a25b60982e08ae821b8036bc8ddf6fdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b60982e08ae821b8036bc8ddf6fdee">&#9670;&nbsp;</a></span>get_symbolic_function_expressions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_symbolic_function_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic expressions used in this symbolic function. </p>

</div>
</div>
<a id="a836518865a1d95bf9d544dd436b4f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836518865a1d95bf9d544dd436b4f8b1">&#9670;&nbsp;</a></span>get_user_substitution_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_user_substitution_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently stored <code>user_substitution_map</code>. </p>

</div>
</div>
<a id="a4d90574552874e70a063ad089874d9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d90574552874e70a063ad089874d9ba">&#9670;&nbsp;</a></span>time_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::time_derivative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> object that represents the time derivative of this function. The spatial argument, the symbolic time, and the currently stored user substitution map are forwarded to the new function. </p>

</div>
</div>
<a id="ac8c14db38b7164318a2be05f3d52b736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c14db38b7164318a2be05f3d52b736">&#9670;&nbsp;</a></span>value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a18793ed91ba97a1ecf8dfb5ef82a8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18793ed91ba97a1ecf8dfb5ef82a8e25">&#9670;&nbsp;</a></span>gradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a3c6de7f3694cda9d0baf759db0b1a9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6de7f3694cda9d0baf759db0b1a9f8">&#9670;&nbsp;</a></span>laplacian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa99c28ed9485acf9222de2d79b738cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c28ed9485acf9222de2d79b738cd0">&#9670;&nbsp;</a></span>hessian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a028d1523aac8e490301d025be11f4777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028d1523aac8e490301d025be11f4777">&#9670;&nbsp;</a></span>print() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType &gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamType &amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the stored arguments and function expression, as it would be evaluated when calling the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00448">448</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="ae55e876e8b12f682ac61c2813e11b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e876e8b12f682ac61c2813e11b512">&#9670;&nbsp;</a></span>create_evaluation_substitution_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::create_evaluation_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a substitution map that replaces the argument with the values of <code>point</code>, the symbolic time with the value of this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a>, and any additional arguments with the substitution map given by <code>additional_function_arguments</code>. </p>

</div>
</div>
<a id="a250d31b290d25c474d8f6f5fee15d15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d31b290d25c474d8f6f5fee15d15f">&#9670;&nbsp;</a></span>update_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic value of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="a48156a0255a46c28018453a45456bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48156a0255a46c28018453a45456bd3f">&#9670;&nbsp;</a></span>update_first_derivatives() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_first_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic gradient of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="afcd97b22b242e8a5943822f3699143bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd97b22b242e8a5943822f3699143bd">&#9670;&nbsp;</a></span>update_second_derivatives() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_second_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic Hessian and the symbolic Lapalacian of the function. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="a98ed0e06b9e5da65ab6ce09bd27473d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ed0e06b9e5da65ab6ce09bd27473d7">&#9670;&nbsp;</a></span>update_user_substitution_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_user_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store and apply the substitution map <code>substitutions</code> to each symbolic component of this <a class="el" href="classFunction.html">Function</a> object.</p>
<p>Notice that this method will trigger a recomputation of the gradients, Hessians, and Laplacians of each component. </p>

</div>
</div>
<a id="a7ad742d6b3841d324f6d092ff2b62c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad742d6b3841d324f6d092ff2b62c41">&#9670;&nbsp;</a></span>set_additional_function_arguments() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::set_additional_function_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the additional <code>arguments</code> to be substituted in next evaluation step.</p>
<p>Notice that the <code>arguments</code> are substituted <em>after</em> evaluating the <code>permanent_user_substitution_map</code>, and after all derivatives are computed. If the additional arguments you pass still depend on the coordinate or time symbols, then evaluation of derivatives will result in a partial derivative evaluation.</p>
<p>This method provides a way to evaluate functions that depend on more arguments than simply the coordinates and time. If you want to compute the total derivative w.r.t. to complicated symbolic expressions, you should call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> instead. </p>

</div>
</div>
<a id="a2718abd675ea2999ce0687c8cf871d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2718abd675ea2999ce0687c8cf871d2e">&#9670;&nbsp;</a></span>get_default_coordinate_symbols() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_default_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a tensor of coordinate symbols that can be used to define the expressions of this symbolic function object.</p>
<p>The default argument is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three. </p>

</div>
</div>
<a id="a832f7270359aff87df84713a51ca3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f7270359aff87df84713a51ca3c82">&#9670;&nbsp;</a></span>get_coordinate_symbols() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual arguments used for the coordinates in the symbolic function. This object does not include any user-defined arguments. </p>

</div>
</div>
<a id="a3dacfbccafff4a1a3b8995c11c17a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dacfbccafff4a1a3b8995c11c17a659">&#9670;&nbsp;</a></span>get_time_symbol() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_time_symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic time in use in this symbolic function. </p>

</div>
</div>
<a id="a25b60982e08ae821b8036bc8ddf6fdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b60982e08ae821b8036bc8ddf6fdee">&#9670;&nbsp;</a></span>get_symbolic_function_expressions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_symbolic_function_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic expressions used in this symbolic function. </p>

</div>
</div>
<a id="a836518865a1d95bf9d544dd436b4f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836518865a1d95bf9d544dd436b4f8b1">&#9670;&nbsp;</a></span>get_user_substitution_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_user_substitution_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently stored <code>user_substitution_map</code>. </p>

</div>
</div>
<a id="a4d90574552874e70a063ad089874d9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d90574552874e70a063ad089874d9ba">&#9670;&nbsp;</a></span>time_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::time_derivative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> object that represents the time derivative of this function. The spatial argument, the symbolic time, and the currently stored user substitution map are forwarded to the new function. </p>

</div>
</div>
<a id="ac8c14db38b7164318a2be05f3d52b736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c14db38b7164318a2be05f3d52b736">&#9670;&nbsp;</a></span>value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a18793ed91ba97a1ecf8dfb5ef82a8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18793ed91ba97a1ecf8dfb5ef82a8e25">&#9670;&nbsp;</a></span>gradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a3c6de7f3694cda9d0baf759db0b1a9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6de7f3694cda9d0baf759db0b1a9f8">&#9670;&nbsp;</a></span>laplacian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa99c28ed9485acf9222de2d79b738cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c28ed9485acf9222de2d79b738cd0">&#9670;&nbsp;</a></span>hessian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ab183ee4afeb9c27cc6bd03c2b13ec69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab183ee4afeb9c27cc6bd03c2b13ec69d">&#9670;&nbsp;</a></span>print() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the stored arguments and function expression, as it would be evaluated when calling the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a>. </p>

</div>
</div>
<a id="ae55e876e8b12f682ac61c2813e11b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e876e8b12f682ac61c2813e11b512">&#9670;&nbsp;</a></span>create_evaluation_substitution_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::create_evaluation_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a substitution map that replaces the argument with the values of <code>point</code>, the symbolic time with the value of this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a>, and any additional arguments with the substitution map given by <code>additional_function_arguments</code>. </p>

</div>
</div>
<a id="a250d31b290d25c474d8f6f5fee15d15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d31b290d25c474d8f6f5fee15d15f">&#9670;&nbsp;</a></span>update_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic value of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="a48156a0255a46c28018453a45456bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48156a0255a46c28018453a45456bd3f">&#9670;&nbsp;</a></span>update_first_derivatives() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_first_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic gradient of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="afcd97b22b242e8a5943822f3699143bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd97b22b242e8a5943822f3699143bd">&#9670;&nbsp;</a></span>update_second_derivatives() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_second_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic Hessian and the symbolic Lapalacian of the function. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="a98ed0e06b9e5da65ab6ce09bd27473d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ed0e06b9e5da65ab6ce09bd27473d7">&#9670;&nbsp;</a></span>update_user_substitution_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_user_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store and apply the substitution map <code>substitutions</code> to each symbolic component of this <a class="el" href="classFunction.html">Function</a> object. Notice that this method will trigger a recomputation of the gradients, Hessians, and Laplacians of each component. </p>

</div>
</div>
<a id="a7ad742d6b3841d324f6d092ff2b62c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad742d6b3841d324f6d092ff2b62c41">&#9670;&nbsp;</a></span>set_additional_function_arguments() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::set_additional_function_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the additional <code>arguments</code> to be substituted in next evaluation step. Notice that the <code>arguments</code> are substitutedafter* evaluating the <code>permanent_user_substitution_map</code>, and after all derivatives are computed. If the additional arguments you pass still depend on the coordinate or time symbols, then evaluation of derivatives will result in a partial derivative evaluation. This method provides a way to evaluate functions that depend on more arguments than simply the coordinates and time. If you want to compute the total derivative w.r.t. to complicated symbolic expressions, you should call <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a> instead. </p>

</div>
</div>
<a id="a2718abd675ea2999ce0687c8cf871d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2718abd675ea2999ce0687c8cf871d2e">&#9670;&nbsp;</a></span>get_default_coordinate_symbols() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_default_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a tensor of coordinate symbols that can be used to define the expressions of this symbolic function object. The default argument is a <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> containing the symbols "x" for <code>dim</code> equal to one, "x", "y" for <code>dim</code> equal to two, and "x", "y", "z" for <code>dim</code> equal to three. </p>

</div>
</div>
<a id="a832f7270359aff87df84713a51ca3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f7270359aff87df84713a51ca3c82">&#9670;&nbsp;</a></span>get_coordinate_symbols() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual arguments used for the coordinates in the symbolic function. This object does not include any user-defined arguments. </p>

</div>
</div>
<a id="a3dacfbccafff4a1a3b8995c11c17a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dacfbccafff4a1a3b8995c11c17a659">&#9670;&nbsp;</a></span>get_time_symbol() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_time_symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic time in use in this symbolic function. </p>

</div>
</div>
<a id="a25b60982e08ae821b8036bc8ddf6fdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b60982e08ae821b8036bc8ddf6fdee">&#9670;&nbsp;</a></span>get_symbolic_function_expressions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_symbolic_function_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actual symbolic expressions used in this symbolic function. </p>

</div>
</div>
<a id="a836518865a1d95bf9d544dd436b4f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836518865a1d95bf9d544dd436b4f8b1">&#9670;&nbsp;</a></span>get_user_substitution_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::get_user_substitution_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently stored <code>user_substitution_map</code>. </p>

</div>
</div>
<a id="a4d90574552874e70a063ad089874d9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d90574552874e70a063ad089874d9ba">&#9670;&nbsp;</a></span>time_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::time_derivative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> object that represents the time derivative of this function. The spatial argument, the symbolic time, and the currently stored user substitution map are forwarded to the new function. </p>

</div>
</div>
<a id="ac8c14db38b7164318a2be05f3d52b736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c14db38b7164318a2be05f3d52b736">&#9670;&nbsp;</a></span>value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a18793ed91ba97a1ecf8dfb5ef82a8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18793ed91ba97a1ecf8dfb5ef82a8e25">&#9670;&nbsp;</a></span>gradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a3c6de7f3694cda9d0baf759db0b1a9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6de7f3694cda9d0baf759db0b1a9f8">&#9670;&nbsp;</a></span>laplacian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa99c28ed9485acf9222de2d79b738cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c28ed9485acf9222de2d79b738cd0">&#9670;&nbsp;</a></span>hessian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">Function&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ab183ee4afeb9c27cc6bd03c2b13ec69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab183ee4afeb9c27cc6bd03c2b13ec69d">&#9670;&nbsp;</a></span>print() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the stored arguments and function expression, as it would be evaluated when calling the method <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a>. </p>

</div>
</div>
<a id="ae55e876e8b12f682ac61c2813e11b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e876e8b12f682ac61c2813e11b512">&#9670;&nbsp;</a></span>create_evaluation_substitution_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::create_evaluation_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a substitution map that replaces the argument with the values of <code>point</code>, the symbolic time with the value of this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a>, and any additional arguments with the substitution map given by <code>additional_function_arguments</code>. </p>

</div>
</div>
<a id="a250d31b290d25c474d8f6f5fee15d15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d31b290d25c474d8f6f5fee15d15f">&#9670;&nbsp;</a></span>update_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic value of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="a48156a0255a46c28018453a45456bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48156a0255a46c28018453a45456bd3f">&#9670;&nbsp;</a></span>update_first_derivatives() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_first_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic gradient of the function, applying the user substitution map. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="afcd97b22b242e8a5943822f3699143bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd97b22b242e8a5943822f3699143bd">&#9670;&nbsp;</a></span>update_second_derivatives() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::update_second_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recompute the symbolic Hessian and the symbolic Lapalacian of the function. This may be an expensive computation, and it is called only if necessary. </p>

</div>
</div>
<a id="ae316ebc05d21989d573024f8a23c49cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316ebc05d21989d573024f8a23c49cb">&#9670;&nbsp;</a></span>vector_value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all components of a vector-valued function at a given point. <code>values</code> shall have the right size beforehand, i.e. <a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>. The default implementation will call <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each component. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ae316ebc05d21989d573024f8a23c49cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316ebc05d21989d573024f8a23c49cb">&#9670;&nbsp;</a></span>vector_value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all components of a vector-valued function at a given point.</p>
<p><code>values</code> shall have the right size beforehand, i.e. <a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>.</p>
<p>The default implementation will call <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each component. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ae316ebc05d21989d573024f8a23c49cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316ebc05d21989d573024f8a23c49cb">&#9670;&nbsp;</a></span>vector_value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all components of a vector-valued function at a given point. <code>values</code> shall have the right size beforehand, i.e. <a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>. The default implementation will call <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each component. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a562fc1114e95e702e6696721f71528db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fc1114e95e702e6696721f71528db">&#9670;&nbsp;</a></span>value_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. By default, this function repeatedly calls <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a562fc1114e95e702e6696721f71528db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fc1114e95e702e6696721f71528db">&#9670;&nbsp;</a></span>value_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>By default, this function repeatedly calls <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a562fc1114e95e702e6696721f71528db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fc1114e95e702e6696721f71528db">&#9670;&nbsp;</a></span>value_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. By default, this function repeatedly calls <a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa041dde994d40c068e00661197ac75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041dde994d40c068e00661197ac75a6">&#9670;&nbsp;</a></span>vector_value_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array, and that all elements be vectors with the same number of components as this function has. By default, this function repeatedly calls <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa041dde994d40c068e00661197ac75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041dde994d40c068e00661197ac75a6">&#9670;&nbsp;</a></span>vector_value_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array, and that all elements be vectors with the same number of components as this function has.</p>
<p>By default, this function repeatedly calls <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa041dde994d40c068e00661197ac75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041dde994d40c068e00661197ac75a6">&#9670;&nbsp;</a></span>vector_value_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array, and that all elements be vectors with the same number of components as this function has. By default, this function repeatedly calls <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point. The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point. The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="af4509a9d71dc1a1ca05cb6205161dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4509a9d71dc1a1ca05cb6205161dc60">&#9670;&nbsp;</a></span>vector_gradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="af4509a9d71dc1a1ca05cb6205161dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4509a9d71dc1a1ca05cb6205161dc60">&#9670;&nbsp;</a></span>vector_gradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="af4509a9d71dc1a1ca05cb6205161dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4509a9d71dc1a1ca05cb6205161dc60">&#9670;&nbsp;</a></span>vector_gradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="afcf557f137782b46e85461235d5bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf557f137782b46e85461235d5bd47d">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the specified component of the function at the <code>points</code>. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="afcf557f137782b46e85461235d5bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf557f137782b46e85461235d5bd47d">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the specified component of the function at the <code>points</code>. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="afcf557f137782b46e85461235d5bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf557f137782b46e85461235d5bd47d">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the specified component of the function at the <code>points</code>. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point. The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point. The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a109f7bff0fb455c042086f98bd003ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109f7bff0fb455c042086f98bd003ede">&#9670;&nbsp;</a></span>vector_gradient_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>, for all components. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. The outer loop over <code>gradients</code> is over the points in the list, the inner loop over the different components of the function. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a109f7bff0fb455c042086f98bd003ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109f7bff0fb455c042086f98bd003ede">&#9670;&nbsp;</a></span>vector_gradient_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>, for all components. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>The outer loop over <code>gradients</code> is over the points in the list, the inner loop over the different components of the function. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a109f7bff0fb455c042086f98bd003ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109f7bff0fb455c042086f98bd003ede">&#9670;&nbsp;</a></span>vector_gradient_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>, for all components. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. The outer loop over <code>gradients</code> is over the points in the list, the inner loop over the different components of the function. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a33430fb1069660fb8cfe599181aceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33430fb1069660fb8cfe599181aceefa">&#9670;&nbsp;</a></span>vector_laplacian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a33430fb1069660fb8cfe599181aceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33430fb1069660fb8cfe599181aceefa">&#9670;&nbsp;</a></span>vector_laplacian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a33430fb1069660fb8cfe599181aceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33430fb1069660fb8cfe599181aceefa">&#9670;&nbsp;</a></span>vector_laplacian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="aae80353c3a581fa918ea555c3e1c7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae80353c3a581fa918ea555c3e1c7353">&#9670;&nbsp;</a></span>laplacian_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points. </p>

</div>
</div>
<a id="aae80353c3a581fa918ea555c3e1c7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae80353c3a581fa918ea555c3e1c7353">&#9670;&nbsp;</a></span>laplacian_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points. </p>

</div>
</div>
<a id="aae80353c3a581fa918ea555c3e1c7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae80353c3a581fa918ea555c3e1c7353">&#9670;&nbsp;</a></span>laplacian_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points. </p>

</div>
</div>
<a id="a6582ff5ce8fddc37866077976df598f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ff5ce8fddc37866077976df598f9">&#9670;&nbsp;</a></span>vector_laplacian_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points. </p>

</div>
</div>
<a id="a6582ff5ce8fddc37866077976df598f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ff5ce8fddc37866077976df598f9">&#9670;&nbsp;</a></span>vector_laplacian_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points. </p>

</div>
</div>
<a id="a6582ff5ce8fddc37866077976df598f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ff5ce8fddc37866077976df598f9">&#9670;&nbsp;</a></span>vector_laplacian_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points. </p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object. This function is virtual and can be overloaded by derived classes. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object.</p>
<p>This function is virtual and can be overloaded by derived classes. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> std::size_t <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object. This function is virtual and can be overloaded by derived classes. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, double &gt;</a>.</p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="time__dependent__0_8txt.html#aec4741ed233852c8c3d33ac036f9de89">virtual</a> void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8cce44d44eb4c0842dd29eb54ae0cebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cce44d44eb4c0842dd29eb54ae0cebf">&#9670;&nbsp;</a></span>user_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::user_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The components of this symbolic function, before any subustitution took place. This is immutable, and generated at construction time. Before any evaluation takes place, the <code>user_substitution_map</code> is applied to this object, and the result is stored in the internal variable function. During evaluation, the <code>symbolic_coordinate</code>, the <code>symbolic_time</code>, and any remaining symbols are substituted with the input evaluation point, the current time, and the content of <code>additional_function_arguments</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00362">362</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a648084b629c8192e4c2c0fcee7ca5fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648084b629c8192e4c2c0fcee7ca5fd7">&#9670;&nbsp;</a></span>user_substitution_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::user_substitution_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the user substitution map used for expression substitutions. This may be updated with a call to <a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map()</a>. Notice that the function may still have unresolved symbols, provided that they are resolved by a call to <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00371">371</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a94b2e0ff9e3bf0062a5eb0167c8c46ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b2e0ff9e3bf0062a5eb0167c8c46ac">&#9670;&nbsp;</a></span>additional_function_arguments</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a9726517c175f63fcada747504b174e63">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::additional_function_arguments</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a user substitution map used for additional argument substitutions. This will be updated by a call to <a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments()</a>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00379">379</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a2d8b005e27545f4674fc11914bed2d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8b005e27545f4674fc11914bed2d10">&#9670;&nbsp;</a></span>function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual components of this symbolic function. This is obtained from the <code>user_function</code>, after applying the <code>user_substitution_map</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00387">387</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="afc72838c9154a619dd654c6e171d922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc72838c9154a619dd654c6e171d922a">&#9670;&nbsp;</a></span>function_gradient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::function_gradient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The gradients of each component of this symbolic function. This is obtained by computing the symbolic gradient of the object <code>function</code>, that is, after applying the <code>user_substitution_map</code> to <code>user_function</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00397">397</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a25a15e934221d9153f98ccd7ae796b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a15e934221d9153f98ccd7ae796b6b">&#9670;&nbsp;</a></span>function_hessian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::function_hessian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Hessians of each component of this symbolic function. This is obtained by computing the symbolic Hessian of the object <code>function</code>, that is, after applying the <code>user_substitution_map</code> to <code>user_function</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00407">407</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a6bfe811e0cea64e705da9d095630dbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfe811e0cea64e705da9d095630dbff">&#9670;&nbsp;</a></span>function_laplacian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::function_laplacian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Laplacians of each component of this symbolic function. This is obtained by computing the symbolic Laplacian of the object <code>function</code>, that is, after applying the <code>user_substitution_map</code> to <code>user_function</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00416">416</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a08995fe68ad866724ea1a53076513ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08995fe68ad866724ea1a53076513ad5">&#9670;&nbsp;</a></span>coordinate_symbols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::coordinate_symbols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The coordinate symbols argument of the function. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00422">422</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="abc3f87cbc1405dd3604863b365bfb1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3f87cbc1405dd3604863b365bfb1cc">&#9670;&nbsp;</a></span>time_symbol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, RangeNumberType &gt;::time_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The symbolic time argument of the function. </p>

<p class="definition">Definition at line <a class="el" href="base_2symbolic__function_8h_source.html#l00428">428</a> of file <a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="acc93ac7b685f9fe84ad7acbfedfcceb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc93ac7b685f9fe84ad7acbfedfcceb6">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sparsity__0_8txt.html#a9e8da5812fd9a4b6f626664964de293c">static</a> <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export the value of the template parameter as a static member constant. Sometimes useful for some expression template programming. </p>

<p class="definition">Definition at line <a class="el" href="base_2function_8h_source.html#l00150">150</a> of file <a class="el" href="base_2function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a7248c7e11dc434fb7d16cdc5e41e3770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7248c7e11dc434fb7d16cdc5e41e3770">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>  &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vector components. </p>

<p class="definition">Definition at line <a class="el" href="base_2function_8h_source.html#l00156">156</a> of file <a class="el" href="base_2function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a8932e3ec9ed7b6f6d6a91c23f82e36d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932e3ec9ed7b6f6d6a91c23f82e36d8">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;::real_type  &gt;::time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the present time. </p>

<p class="definition">Definition at line <a class="el" href="base_2function__time_8h_source.html#l00107">107</a> of file <a class="el" href="base_2function__time_8h_source.html">function_time.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="base_2symbolic__function_8h_source.html">symbolic_function.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="amg__0_8txt_html_a05d914308ac970c97c941a291a81ccc1"><div class="ttname"><a href="mg__0_8txt.html#a05d914308ac970c97c941a291a81ccc1">b</a></div><div class="ttdeci">which is a wrapper around Multigrid with the standard interface of deal II[2.x.9] Preconditioners PreconditionMG also uses the classes inheriting from for instance where it uses[2.x.10] and[2.x.11] which transfer between the global vector and the level vectors we have several auxiliary namely which stores an object on each level **See b</div><div class="ttdef"><b>Definition:</b> <a href="mg__0_8txt_source.html#l00011">mg_0.txt:11</a></div></div>
<div class="ttc" id="amapping__info__0_8txt_html_aaed09e22b1fee38bd2273caeedfb0e90"><div class="ttname"><a href="mapping__info__0_8txt.html#aaed09e22b1fee38bd2273caeedfb0e90">c</a></div><div class="ttdeci">*An enum to identify various types of cells and faces The most general type is what we typically compute in the FEValues context but for many geometries we can save significant storage ***The cell or face is Cartesian **The cell or face can be described with an affine mapping **The face is i the normal factor on a face is the same on all quadrature points This type is not assigned for cells **There is no special information available for compressing the representation of the object under consideration **Definition of a structure that stores all cached data related to the evaluated geometry from the mapping In order to support hp adaptivity and compressed storage length can be different for different rows it allows to jump at the data of individual rows similar to compressed row storage in sparse matrices We have two different start indices for fields with different sizes The first category of offsets are the indices for Jacobians of the transformation from unit to real second JxW and normal vectors We keep separate arrays for all these data structures because a user code might access only some of them In such a one array will be gone through in a contiguous order with access to all which makes it easy for the processor to prefetch data Having all data in a single array would require some strides in the access which is much more complicated for the processor to called which contains the quadrature weights and permutations of how to go through quadrature points in case of face data The latter comes in a vector for the support of hp with several data fields for the individual quadrature formulas ***Constructor Does nothing **Set up the lengths in the various members of this struct **Set up the lengths in the various members of this struct **Returns the memory consumption in bytes **Number of quadrature points applied on the given cell or face **Original one dimensional quadrature formula applied on the given cell or face **Quadrature formula applied on the given cell or face **Quadrature weights separated by dimension for use in specific situations **A cached vector of quadrature weights in the given number the evaluation of basis functions is not in the correct order if a face is not in the standard orientation to a given element This data structure is used to re order the data evaluated on quadrature points to represent the correct order **A class describing the layout of the sections in the[2.x.2] field and also includes some data that depends on the number of quadrature points in the hp context such as the inner quadrature formula and re indexing for faces that are not in the standard orientation **Collection of quadrature formulae applied on the given face *Only filled for since faces might be quadrilateral or triangle shaped **Stores the index offset into the arrays[2.x.4][2.x.5][2.x.6] and the second derivatives Note that affine cells have shorter fields of where the others have lengths equal to the number of quadrature points of the given cell **The storage of the Jacobian i the inverse and transposed Jacobians of the transformation from the unit to the real cell Indexed by[2.x.9] Contains two fields for access from both sides for interior but the default only the upper diagonal and diagonal part are needed The first index runs through the starting with the diagonal and then continuing row i and so on The second index is the spatial coordinate Indexed by[2.x.12] Contains two fields for access from both sides for interior but the default including a compression scheme for Cartesian cells where we do not need to store the full data on all points Indexed by *[2.x.16] *Clears all data fields except the descriptor vector **Returns the quadrature index for a given number of quadrature points If not in hp mode or if the index is not this function always returns index this function does not check whether the given degree is actually present **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **Returns the memory consumption in bytes **The class that stores all geometry dependent data related with cell interiors for use in the matrix free class ***Compute the information in the given cells and faces The cells are specified by the level and the index within the a mapping and several quadrature formulas are given **Update the information in the given cells and faces that is the result of a change in the given mapping keeping the quadrature formulas and other unknowns unchanged This call is only valid if[2.x.20] has been called before **Return the type of a given cell as detected during initialization **Clear all data fields in this class **Return the memory consumption of this class in bytes **Prints a detailed summary of memory consumption in the different structures of this class to the given output stream **The given update flags for computing the geometry on the cells **The given update flags for computing the geometry on the boundary faces **The given update flags for computing the geometry on the interior faces **The given update flags for computing the geometry on the faces for cell centric loops **Stores whether a cell is has constant transform data() or is whether it represents an affine whether it is a flat face where the normal vector is the same throughout the or is following the[2.x.21] variable for the cell types **The pointer to the underlying[2.x.22] object **The pointer to the first entry of mapping_collection **Reference cell type related to each quadrature and active quadrature index **Internal function to compute the geometry for the case the mapping is a MappingQ and a single quadrature formula per i it uses a polynomial description of the cell especially when several different quadrature formulas are and consumes less memory[2.x.23] tria The triangulation to be used for setup[2.x.24] cells The actual cells of the triangulation to be worked given as a tuple of the level and index within the level as used in the main initialization of the class ::x faces The description of the connectivity from faces to cells as filled in the MatrixFree class **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Computes the information in the given called within initialize **Helper function to determine which update flags must be set in the internal functions to initialize all data as requested by the user **A helper class to extract either cell or face data from mapping info for use in FEEvaluationBase **A class that is used to compare floating point c</div><div class="ttdef"><b>Definition:</b> <a href="mapping__info__0_8txt_source.html#l00116">mapping_info_0.txt:116</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="aclassFunctions_1_1SymbolicFunction_html_a4d90574552874e70a063ad089874d9ba"><div class="ttname"><a href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">Functions::SymbolicFunction::time_derivative</a></div><div class="ttdeci">SymbolicFunction&lt; dim, RangeNumberType &gt; time_derivative() const</div></div>
<div class="ttc" id="afunction__tools__0_8txt_html_a1a2acf608502527a80c0aeecdc12c908"><div class="ttname"><a href="function__tools__0_8txt.html#a1a2acf608502527a80c0aeecdc12c908">a</a></div><div class="ttdeci">*Estimate bounds on the value and bounds on each gradient component of a over a by approximating it by a order Taylor polynomial starting from the box center Each lower and upper bound is returned as a[2.x.1]</div><div class="ttdef"><b>Definition:</b> <a href="function__tools__0_8txt_source.html#l00002">function_tools_0.txt:2</a></div></div>
<div class="ttc" id="abase_2vectorization_8h_html_a11c48f86a4f2adf21555e64049ecde8c"><div class="ttname"><a href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="base_2vectorization_8h_source.html#l05605">vectorization.h:5605</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_a2b24e414d1a0d32deea919c5e8899811"><div class="ttname"><a href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a></div><div class="ttdeci">([1.x.8]&lt; sub &gt;1&lt;/sub &gt;, [1.x.9]&lt; sub &gt;2&lt;/sub &gt;, [1.x.10]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt; and[1.x.11] accordingly. Then, we can write the simplified equation in coordinates as[1.x.12] We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component(this is where the formulation with the[2.x.33] is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions:first, choose[1.x.13]=([1.x.14]&lt; sub &gt;1&lt;/sub &gt;, 0, 0)&lt; sup &gt;T&lt;/sup &gt;, then[1.x.15]=(0, [1.x.16]&lt; sub &gt;2&lt;/sub &gt;, 0)&lt; sup &gt;T&lt;/sup &gt;, and finally[1.x.17]=(0, 0, [1.x.18]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt;. writing the outcomes below each other, we obtain the system[1.x.19] where we used the standard inner product notation[2.x.34] . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form[1.x.20]([1.x.21], [1.x.22]), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient[1.x.23]:[1.x.24] Very formally, if we believe in operator valued matrices, we can rewrite this in the form[1.x.25]&lt; sup &gt;T&lt;/sup &gt;[1.x.26]=[1.x.27]&lt; sup &gt;T&lt;/sup &gt;[1.x.28] or[1.x.29] *[1.x.30] Now, let us consider a more complex example, the mixed Laplace equations discussed in[2.x.35] in three dimensions:[1.x.31] **Here, we have four solution components:the scalar pressure[2.x.36] and the vector-valued velocity[2.x.37] with three vector components. Note as important difference to the previous example, that the vector space[1.x.32] is not just simply a copy of three identical spaces/*A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows:[1.x.33] **This makes it clear that the solution[1.x.34] *indeed has four components. We note that we could change the ordering of the solution components[2.x.38] and[2.x.39] inside[2.x.40] if we also change columns of the matrix operator.*Next, we need to think about test functions[2.x.41] . We want to multiply both sides of the equation with them, then integrate over[2.x.42] . The result should be a scalar equality. We can achieve this by choosing[2.x.43] also vector valued as[1.x.35] **It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on(in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. *With this in mind, let us multiply by[2.x.44] and integrate to get the following equation which has to hold for all test functions[2.x.45] :[1.x.36] *or equivalently:[1.x.37] ***We get the final form by integrating by part the second term:[1.x.38] **It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector:the form in which we have solution and test functions[2.x.46] that each consist of a number of vector components that we can extract. **[2.x.47] VVFEs[1.x.39] *Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the FESystem class comes in:it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need[2.x.48] copies of the same element, for instance **[1.x.40] *This will generate a vector valued space of dimension[2.x.49], where each component is a continuous bilinear element of type FE_Q. It will have[2.x.50] times as many basis functions as the corresponding FE_Q, and each of these basis functions is a basis function of FE_Q, lifted into one of the components of the vector. *For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces[2.x.51] . One option would be the stable Raviart-Thomas pair **[1.x.41] *The first element in this system is already a vector valued element of dimension[2.x.52], while the second is a regular scalar element. *Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely **[1.x.42] *This system just has[2.x.53] equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer **[1.x.43] *Here, we have a system of two elements, one vector-valued and one scalar, very much like with the[2.x.54] . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely **[1.x.44] *It must be pointed out, that this element is different from **[1.x.45] *While the constructor call is very similar to[2.x.55], the result actually resembles more[2.x.56] in that this element produces[2.x.57] independent components. A more detailed comparison of the resulting FESystem objects is below. *[1.x.46] *FESystem has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table:&lt; table border=&quot;1&quot;&gt;&lt; tr &gt;&lt; th &gt;System Element&lt;/th &gt;[2.x.58][2.x.59][2.x.60]&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.61]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.62]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.63]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.64]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.65]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt;/table &gt; *From this table, it is clear that the FESystem reflects a lot of the structure of the system of differential equations in the cases of the[2.x.66] and the[2.x.67], in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. *At this point, it is important to note that nesting of two FESystem object can give the whole FESystem a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so. *[2.x.68] VVAssembling[1.x.47] The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with[2.x.69] . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. *The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. *[1.x.48] This is essentially how[2.x.70] does it:**[1.x.49] **So here 's what is happening:[2.x.71][2.x.72] The first thing we do is to declare &quot;extractors&quot;(see the FEValuesExtractors namespace). These are objects that don 't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1(i.e. what we call a &quot;physical vector&quot;, always consisting of[2.x.73] components). Here, we declare an object that represents the velocities consisting of[2.x.74] components starting at component zero, and the extractor for the pressure, which is a scalar component at position[2.x.75] . *[2.x.76] We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form(i.e. neglecting boundary terms) looked as follows, based on shape functions[2.x.77] :[1.x.50] *whereas the implementation looked like this:*[1.x.51] *The similarities are pretty obvious. *[2.x.78] Essentially, what happens in above code is this:when you do[2.x.79], a so-called &quot;view&quot; is created, i.e. an object that unlike the full FEValues object represents not all components of a finite element, but only the one(s) represented by the extractor object[2.x.80] or[2.x.81] . *[2.x.82] These views can then be asked for information about these individual components. For example, when you write[2.x.83] you get the value of the pressure component of the[2.x.84] th shape function[2.x.85] at the[2.x.86] th quadrature point. Because the extractor[2.x.87] represents a scalar component, the results of the operator[2.x.88] is a scalar number. On the other hand, the call[2.x.89] would produce the value of a whole set of[2.x.90] components, which would be of type[2.x.91] . *[2.x.92] Other things that can be done with views is to ask for the gradient of a particular shape function 's components described by an extractor. For example,[2.x.93] would represent the gradient of the scalar pressure component, which is of type[2.x.94], whereas the gradient of the velocities components,[2.x.95] is a[2.x.96], i.e. a matrix[2.x.97] that consists of entries[2.x.98] . Finally, both scalar and vector views can be asked for the second derivatives(&quot;Hessians&quot;) and vector views can be asked for the symmetric gradient, defined as[2.x.99] as well as the divergence[2.x.100] .[2.x.101] Other examples of using extractors and views are shown in tutorial programs[2.x.102],[2.x.103],[2.x.104] and several other programs. ***[2.x.105] In the current context, when we talk about a vector(for example in extracting the velocity components above), we mean the word in the sense physics uses it:it has[2.x.106] components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word &quot;vector&quot;(and how we use this word in other contexts in the library, for example in the Vector class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame x</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00090">vector_valued_0.txt:90</a></div></div>
<div class="ttc" id="aclassDifferentiation_1_1SD_1_1Expression_html"><div class="ttname"><a href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a></div><div class="ttdef"><b>Definition:</b> <a href="differentiation_2sd_2symengine__number__types_8h_source.html#l00177">symengine_number_types.h:177</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a4874d3f2becad91b2bdda53a5539ff54"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a4874d3f2becad91b2bdda53a5539ff54">f</a></div><div class="ttdeci">pow(2x+1, y)` and computing the derivatives `diff(f, x)` and `diff(f, y)`. At this point there is no assumption of what `x` and `y` represent f</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="afunction__time__0_8txt_html_aec9d63e7b1c02618470be701525a5211"><div class="ttname"><a href="function__time__0_8txt.html#aec9d63e7b1c02618470be701525a5211">sin</a></div><div class="ttdeci">*Support for time dependent functions The library was also designed for time dependent problems For this the function objects also contain a field which stores the as well as functions manipulating them Time independent problems should not access or even abuse them for other but since one normally does not create thousands of function the gain in generality weighs out the fact that we need not store the time value for not time dependent problems The second advantage is that the derived standard classes like&lt; tt &gt;&lt; tt &gt; ConstantFunction&lt;/tt &gt; etc also work for time dependent problems *Access to the time goes through the following so that derived classes can perform computations which need only be done once for every new time For if a time dependent function had a factor&lt; tt &gt; sin(t)&lt;/tt &gt;</div></div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html_af71e229940cc126030592c5195289113"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a></div><div class="ttdeci">Expression make_symbol(const std::string &amp;symbol)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__scalar__operations_8cc_source.html#l00041">symengine_scalar_operations.cc:41</a></div></div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a></div><div class="ttdef"><b>Definition:</b> <a href="differentiation_2sd_2symengine__math_8h_source.html#l00031">symengine_math.h:31</a></div></div>
<div class="ttc" id="aclassFunctions_1_1SymbolicFunction_html_a2718abd675ea2999ce0687c8cf871d2e"><div class="ttname"><a href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">Functions::SymbolicFunction::get_default_coordinate_symbols</a></div><div class="ttdeci">static Tensor&lt; 1, dim, Differentiation::SD::Expression &gt; get_default_coordinate_symbols()</div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="atable__0_8txt_html_aa889bb34debce4db8c9ace2f875bdf0d"><div class="ttname"><a href="table__0_8txt.html#aa889bb34debce4db8c9ace2f875bdf0d">component</a></div><div class="ttdeci">tables that store three or more dimensional then there is nothing you can do about the size of these if your program is parallelized via then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file This is inefficient from two the data stored on every process is the and while every process needs to be able to read from a it is not necessary that every process stores its own either by re creating a copy of the table in the other processes memory space if by creating copies in shared memory once for all processes located on each of the machines used by the MPI job ******Integer type used to count the number of elements in this container **Default constructor Set all dimensions to zero **Constructor Initialize the array with the given dimensions in each index component **Constructor Initialize the array with the given dimensions in each index component</div><div class="ttdef"><b>Definition:</b> <a href="table__0_8txt_source.html#l00083">table_0.txt:83</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
