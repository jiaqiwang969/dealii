<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__vector__valued.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Handling vector valued problems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Handling vector valued problems<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector-valued problems are systems of partial differential equations. These are problems where the solution variable is not a scalar function, but a vector-valued function or a set of functions. This includes, for example:  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Handling vector valued problems:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFEValuesViews"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceFEValuesExtractors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMask.html">BlockMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComponentMask.html">ComponentMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html">FESystem&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1SymmetricTensor_3_012_00_01dim_00_01spacedim_01_4.html">FEValuesViews::SymmetricTensor&lt; 2, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Tensor_3_012_00_01dim_00_01spacedim_01_4.html">FEValuesViews::Tensor&lt; 2, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt; rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor&lt; rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlock.html">MatrixBlock&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html">MatrixBlockVector&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGMatrixBlockVector.html">MGMatrixBlockVector&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Vector-valued problems are systems of partial differential equations. These are problems where the solution variable is not a scalar function, but a vector-valued function or a set of functions. This includes, for example: </p>
<ul>
<li>
The elasticity equation discussed in <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_17.html">step-17</a> , and <a class="el" href="step_18.html">step-18</a> in which the solution is the vector-valued displacement at each point. </li>
<li>
The mixed Laplace equation and its extensions discussed in <a class="el" href="step_20.html">step-20</a> , and <a class="el" href="step_21.html">step-21</a> in which the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
The Stokes equation and its extensions discussed in <a class="el" href="step_22.html">step-22</a> , and <a class="el" href="step_31.html">step-31</a> in which again the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
Complex-valued solutions consisting of real and imaginary parts, as discussed for example in <a class="el" href="step_29.html">step-29</a> . </li>
</ul>
<p>This page gives an overview of how to implement such vector-valued problems easily in deal.II. In particular, it explains the usage of the class <a class="el" href="classFESystem.html">FESystem</a>, which allows us to write code for systems of partial differential very much like we write code for single equations. </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.html">video lecture 21</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) <table class="tutorial" width="50%">
<tr>
<th><b>Table of contents</b> </th></tr>
<tr>
<td width="100%" valign="top"><ol>
<li>
<a class="el" href="group__vector__valued.html#VVExamples">Examples of vector-valued problems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVFEs">Describing finite element spaces</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAssembling">Assembling linear systems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAlternative">An alternative approach</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVBlockSolvers">Block solvers</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVExtracting">Extracting data from solutions</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVOutput">Generating graphical output</a> </li>
</ol>
</td></tr>
</table>
</dd></dl>
<p><a class="anchor" id="VVExamples"></a></p><h3>Examples of vector-valued problems</h3>
<p>The way one deals systematically with vector-valued problems is not fundamentally different from scalar problems: first, we need a weak (variational) formulation of the problem that takes into account all the solution variables. After we did so, generating the system matrix and solving the linear system follows the same outlines that we are used to already. </p><h4>Linear elasticity</h4>
<p>Let us take for example the elasticity problem from <a class="el" href="step_8.html">step-8</a> and even simplify it by choosing \(\lambda = 0\) and \(\mu = 1\) to highlight the important concepts. Therefore, let consider the following weak formulation: find \(\mathbf u \in \mathbf V = H^1_0(\Omega; \mathbb R^3)\) such that for all \(\mathbf v\in V\) holds </p><p class="formulaDsp">
\[ a(u,v) \equiv 2\int_{\Omega} \mathbf D\mathbf u : \mathbf D\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
<p> Here, <b>D</b> denotes the symmetric gradient defined by \(\mathbf Du = \tfrac12 (\nabla \mathbf u + (\nabla \mathbf u)^T)\) and the colon indicates double contraction of two tensors of rank 2 (the Frobenius inner product). This bilinear form looks indeed very much like the bilinear form of the Poisson problem in <a class="el" href="step_3.html">step-3</a> . The only differences are </p><ol>
<li>
We replaced the gradient operator by the symmetric gradient; this is actually not a significant difference, and everything said here is true if your replace \(\mathbf D\) by \(\nabla\) . Indeed, let us do this to simplify the discussion: <p class="formulaDsp">
\[ a(u,v) \equiv \int_{\Omega} \nabla\mathbf u : \nabla\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
 Note though, that this system is not very exciting, since we could solve for the three components of <b>u</b> separately. </li>
<li>
The trial and test functions are now from the space \(H^1_0(\Omega; \mathbb R^3)\) , which can be viewed as three copies of the scalar space \(H^1_0(\Omega)\) . And this is exactly, how we are going to implement this space below, using <a class="el" href="classFESystem.html">FESystem</a>. </li>
</ol>
<p>But for now, let us look at the system a little more closely. First, let us exploit that <b>u</b>=(<em>u</em><sub>1</sub>,<em>u</em><sub>2</sub>,<em>u</em><sub>3</sub>)<sup>T</sup> and <b>v</b> accordingly. Then, we can write the simplified equation in coordinates as </p><p class="formulaDsp">
\[ a(u,v) = \int_\Omega \bigl(\nabla u_1\cdot \nabla v_1 +\nabla u_2\cdot \nabla v_2+\nabla u_3\cdot \nabla v_3\bigr)\,dx = \int_\Omega \bigl(f_1v_1 + f_2 v_2 + f_3 v_3\bigr)\,dx. \]
</p>
<p> We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component (this is where the formulation with the \(\mathbf D\) is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions: first, choose <b>v</b>=(<em>v</em><sub>1</sub>,0,0)<sup>T</sup>, then <b>v</b>=(0,<em>v</em><sub>2</sub>,0)<sup>T</sup>, and finally <b>v</b>=(0,0,<em>v</em><sub>3</sub>)<sup>T</sup>. writing the outcomes below each other, we obtain the system </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) &amp;&amp;&amp; = (f_1, v_1) \\ &amp; (\nabla u_2,\nabla v_2) &amp;&amp; = (f_2, v_2) \\ &amp;&amp; (\nabla u_3,\nabla v_3) &amp; = (f_3, v_3) \end{matrix} \]
</p>
<p> where we used the standard inner product notation \((\mathbf f,\mathbf g) = \int_\Omega \mathbf f \cdot \mathbf g \,dx\) . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form <em>a</em>(<em>u</em>,<em>v</em>), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient <b>D</b>: </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) + (\partial_1 u_1,\partial_1 v_1) &amp; (\partial_1 u_2,\partial_2 v_1) &amp; (\partial_1 u_3,\partial_3 v_1) &amp; = (f_1, v_1) \\ (\partial_2 u_1,\partial_1 v_2) &amp; (\nabla u_2,\nabla v_2) + (\partial_2 u_2,\partial_2 v_2) &amp; (\partial_2 u_3,\partial_3 v_2) &amp; = (f_2, v_2) \\ (\partial_3 u_1,\partial_1 v_3) &amp; (\partial_3 u_2,\partial_2 v_3) &amp; (\nabla u_3,\nabla v_3) + (\partial_3 u_3,\partial_3 v_3) &amp; = (f_3, v_3) \end{matrix}. \]
</p>
<p> Very formally, if we believe in operator valued matrices, we can rewrite this in the form <b>v</b><sup>T</sup><b>Au</b> = <b>v</b><sup>T</sup><b>f</b> or </p><p class="formulaDsp">
\[ \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} (\nabla \cdot,\nabla \cdot) + (\partial_1 \cdot,\partial_1 \cdot) &amp; (\partial_1 \cdot,\partial_2 \cdot) &amp; (\partial_1 \cdot,\partial_3 \cdot) \\ (\partial_2 \cdot,\partial_1 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_2 \cdot,\partial_2 \cdot) &amp; (\partial_2 \cdot,\partial_3 \cdot) \\ (\partial_3 \cdot,\partial_1 \cdot) &amp; (\partial_3 \cdot,\partial_2 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_3 \cdot,\partial_3 \cdot) \end{pmatrix} \begin{pmatrix} u_1 \\ u_2 \\ u_3 \end{pmatrix} = \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} f_1 \\ f_2 \\ f_3\end{pmatrix} \]
</p>
 <h4>Mixed elliptic problems</h4>
<p>Now, let us consider a more complex example, the mixed Laplace equations discussed in step-20 in three dimensions: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{u} + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; f, \end{eqnarray*}
</p>
<p>Here, we have four solution components: the scalar pressure \(p \in L^2(\Omega)\) and the vector-valued velocity \(\mathbf u \in \mathbf V = H^{\text{div}}_0(\Omega)\) with three vector components. Note as important difference to the previous example, that the vector space <b>V</b> is not just simply a copy of three identical spaces/ A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) = \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \end{eqnarray*}
</p>
<p>This makes it clear that the solution </p><p class="formulaDsp">
\begin{eqnarray*} U = \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \end{eqnarray*}
</p>
<p> indeed has four components. We note that we could change the ordering of the solution components \(\textbf u\) and \(p\) inside \(U\) if we also change columns of the matrix operator. Next, we need to think about test functions \(V\) . We want to multiply both sides of the equation with them, then integrate over \(\Omega\) . The result should be a scalar equality. We can achieve this by choosing \(V\) also vector valued as </p><p class="formulaDsp">
\begin{eqnarray*} V = \left( \begin{array}{c} \mathbf v \\ q \end{array} \right). \end{eqnarray*}
</p>
<p>It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on (in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. With this in mind, let us multiply by \(V\) and integrate to get the following equation which has to hold for all test functions \(V\) : </p><p class="formulaDsp">
\begin{eqnarray*} \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \ dx = \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \ dx, \end{eqnarray*}
</p>
<p> or equivalently: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) + (\mathbf v, \nabla p) - (q, \mathrm{div}\ \mathbf u) = (q,f), \end{eqnarray*}
</p>
<p>We get the final form by integrating by part the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) - (\mathrm{div}\ \mathbf v, p) - (q, \mathrm{div}\ \mathbf u) = (q,f) - (\mathbf n\cdot\mathbf v, p)_{\partial\Omega}. \end{eqnarray*}
</p>
<p>It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector: the form in which we have solution and test functions \(U,V\) that each consist of a number of vector components that we can extract.</p>
<p><a class="anchor" id="VVFEs"></a></p><h3>Describing finite element spaces</h3>
<p>Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the <a class="el" href="classFESystem.html">FESystem</a> class comes in: it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need <code>dim</code> copies of the same element, for instance</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> elasticity_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
</div><!-- fragment --><p> This will generate a vector valued space of dimension <code>dim</code> , where each component is a continuous bilinear element of type <a class="el" href="classFE__Q.html">FE_Q</a>. It will have <code>dim</code> times as many basis functions as the corresponding <a class="el" href="classFE__Q.html">FE_Q</a>, and each of these basis functions is a basis function of <a class="el" href="classFE__Q.html">FE_Q</a>, lifted into one of the components of the vector. For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces \(\mathbf V_h \times Q_h \subset H^{\text{div}}_0(\Omega) \times L^2_0(\Omega)\) . One option would be the stable Raviart-Thomas pair</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> rt_element (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas&lt;dim&gt;</a>(1), 1,</div>
<div class="line">                          <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),          1);</div>
</div><!-- fragment --><p> The first element in this system is already a vector valued element of dimension <code>dim</code> , while the second is a regular scalar element. Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_1 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1);</div>
</div><!-- fragment --><p> This system just has <code>dim+1</code> equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_equal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>), 1,</div>
<div class="line">                                 <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),                     1);</div>
</div><!-- fragment --><p> Here, we have a system of two elements, one vector-valued and one scalar, very much like with the <code>rt_element</code> . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_unequal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>), 1,</div>
<div class="line">                                   <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2),                     1);</div>
</div><!-- fragment --><p> It must be pointed out, that this element is different from</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_2 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,</div>
<div class="line">                                        <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2), 1);</div>
</div><!-- fragment --><p> While the constructor call is very similar to <code>rt_element</code> , the result actually resembles more <code>ldg_convoluted_element_1</code> in that this element produces <code>dim+1</code> independent components. A more detailed comparison of the resulting <a class="el" href="classFESystem.html">FESystem</a> objects is below. </p><h4>Internal structure of <a class="el" href="classFESystem.html">FESystem</a></h4>
<p><a class="el" href="classFESystem.html">FESystem</a> has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table: </p><table border="1">
<tr>
<th>System Element </th><th><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElementData::n_blocks()</a> </th><th><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> </th><th><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">FiniteElement::n_base_elements()</a>  </th></tr>
<tr>
<td><code>elasticity_element</code></td><td><code>dim</code></td><td><code>dim</code> </td><td>1  </td></tr>
<tr>
<td><code>rt_element</code></td><td>2</td><td><code>dim+1</code> </td><td>2  </td></tr>
<tr>
<td><code>ldg_equal_element</code></td><td>2</td><td><code>dim+1</code> </td><td>2  </td></tr>
<tr>
<td><code>ldg_convoluted_element_1</code></td><td><code>dim+1</code></td><td><code>dim+1</code> </td><td>1  </td></tr>
<tr>
<td><code>ldg_convoluted_element_2</code></td><td><code>dim+1</code></td><td><code>dim+1</code> </td><td>2  </td></tr>
</table>
<p>From this table, it is clear that the <a class="el" href="classFESystem.html">FESystem</a> reflects a lot of the structure of the system of differential equations in the cases of the <code>rt_element</code> and the <code>ldg_equal_element</code> , in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. At this point, it is important to note that nesting of two <a class="el" href="classFESystem.html">FESystem</a> object can give the whole <a class="el" href="classFESystem.html">FESystem</a> a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so.<a class="anchor" id="VVAssembling"></a></p><h3>Assembling linear systems</h3>
<p>The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with <a class="el" href="step_3.html">step-3</a> . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. </p><h4>A single <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></h4>
<p>This is essentially how <a class="el" href="step_20.html">step-20</a> does it:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a> (0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">typename <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line"> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line"> endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line"> {</div>
<div class="line">   fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">   local_matrix = 0;</div>
<div class="line">   local_rhs = 0;</div>
<div class="line"> </div>
<div class="line">   <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>.value_list (fe_values.get_quadrature_points(),</div>
<div class="line">                               rhs_values);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">       {</div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">           local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += (fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">-</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">-</div>
<div class="line">                                 fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q))</div>
<div class="line">                                 fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">         local_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) +=</div>
<div class="line"> </div>
<div class="line">- fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                         rhs_values[q]</div>
<div class="line">                         fe_values.JxW(q);</div>
<div class="line">       }</div>
</div><!-- fragment --><p>So here's what is happening: </p><ul>
<li>
The first thing we do is to declare "extractors" (see the <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a> namespace). These are objects that don't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1 (i.e. what we call a "physical vector", always consisting of <code>dim</code> components). Here, we declare an object that represents the velocities consisting of <code>dim</code> components starting at component zero, and the extractor for the pressure, which is a scalar component at position <code>dim</code> . </li>
<li>
We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form (i.e. neglecting boundary terms) looked as follows, based on shape functions \(V_i=\left(\begin{array}{c}\mathbf v_i \\ q_i\end{array}\right), V_j=\left(\begin{array}{c}\mathbf v_j \\ q_j\end{array}\right)\) : <p class="formulaDsp">
\begin{eqnarray*} (\mathbf v_i, \mathbf v_j) - (\mathrm{div}\ \mathbf v_i, q_j) - (q_i, \mathrm{div}\ \mathbf v_j) \end{eqnarray*}
</p>
 whereas the implementation looked like this: <div class="fragment"><div class="line">           local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += (fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">-</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">-</div>
<div class="line">                                 fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q)</div>
<div class="line">                                 fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                                )</div>
<div class="line">                                fe_values.JxW(q);</div>
</div><!-- fragment --> The similarities are pretty obvious. </li>
<li>
Essentially, what happens in above code is this: when you do <code>fe_values[pressure]</code> , a so-called "view" is created, i.e. an object that unlike the full <a class="el" href="classFEValues.html">FEValues</a> object represents not all components of a finite element, but only the one(s) represented by the extractor object <code>pressure</code> or <code>velocities</code> . </li>
<li>
These views can then be asked for information about these individual components. For example, when you write <code>fe_values[pressure].value(i,q)</code> you get the value of the pressure component of the \(i\) th shape function \(V_i\) at the \(q\) th quadrature point. Because the extractor <code>pressure</code> represents a scalar component, the results of the operator <code>fe_values[pressure].value(i,q)</code> is a scalar number. On the other hand, the call <code>fe_values[velocities].value(i,q)</code> would produce the value of a whole set of <code>dim</code> components, which would be of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> . </li>
<li>
Other things that can be done with views is to ask for the gradient of a particular shape function's components described by an extractor. For example, <code>fe_values[pressure].gradient(i,q)</code> would represent the gradient of the scalar pressure component, which is of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> , whereas the gradient of the velocities components, <code>fe_values[velocities].gradient(i,q)</code> is a <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt;</code> , i.e. a matrix \(G_{ij}\) that consists of entries \(G_{ij}=\frac{\partial\phi_i}{\partial x_j}\) . Finally, both scalar and vector views can be asked for the second derivatives ("Hessians") and vector views can be asked for the symmetric gradient, defined as \(S_{ij}=\frac 12 \left[\frac{\partial\phi_i}{\partial x_j} + \frac{\partial\phi_j}{\partial x_i}\right]\) as well as the divergence \(\sum_{d=0}^{dim-1} \frac{\partial\phi_d}{\partial x_d}\) . </li>
</ul>
<p>Other examples of using extractors and views are shown in tutorial programs <a class="el" href="step_21.html">step-21</a> , <a class="el" href="step_22.html">step-22</a> , <a class="el" href="step_31.html">step-31</a> and several other programs.</p>
<dl class="section note"><dt>Note</dt><dd>In the current context, when we talk about a vector (for example in extracting the velocity components above), we mean the word in the sense physics uses it: it has <code>spacedim</code> components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word "vector" (and how we use this word in other contexts in the library, for example in the <a class="el" href="classVector.html">Vector</a> class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame; however, these are really just a collection of scalar variables, since they do not change if the coordinate system is rotated, unlike the components of a velocity vector, and consequently, this <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> class should not be used for this case.</dd></dl>
<p><a class="anchor" id="VVAlternative"></a></p><h3>An alternative approach</h3>
<p>There are situations in which one can optimize the assembly of a matrix or right hand side vector a bit, using knowledge of the finite element in use. Consider, for example, the bilinear form of the elasticity equations which we are concerned with first in <a class="el" href="step_8.html">step-8</a> : </p><p class="formulaDsp">
\[ a({\mathbf u}, {\mathbf v}) = \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega, + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega, \]
</p>
<p> Here, \(\mathbf u\) is a vector function with <code>dim</code> components, \(\mathbf v\) the corresponding test function, and \(\lambda,\mu\) are material parameters. Given our discussions above, the obvious way to implement this bilinear form would be as follows, using an extractor object that interprets all <code>dim</code> components of the finite element as single vector, rather than disjoint scalar components:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a> (0);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_i_grad</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].gradient (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_j_grad</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].gradient (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            +=  (lambda_values[q_point]</div>
<div class="line">                 phi_i_div phi_j_div</div>
<div class="line">                 +</div>
<div class="line">                 mu_values[q_point]</div>
<div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, phi_j_grad)</div>
<div class="line">                 +</div>
<div class="line">                 mu_values[q_point]</div>
<div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(phi_j_grad))</div>
<div class="line">                )</div>
<div class="line">                fe_values.JxW(q_point);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Now, this is not the code used in <a class="el" href="step_8.html">step-8</a> . In fact, if one used the above code over the one implemented in that program, it would run about 8 per cent slower. It can be improved (bringing down the penalty to about 4 per cent) by taking a close look at the bilinear form. In fact, we can transform it as follows: </p><p class="formulaDsp">
\begin{eqnarray*} a({\mathbf u}, {\mathbf v}) &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \partial_i u_j, \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \frac 12[\partial_i u_j + \partial_j u_i], \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \varepsilon(\mathbf u), \varepsilon(\mathbf v) \right)_\Omega, \end{eqnarray*}
</p>
<p> where \(\varepsilon(\mathbf u) = \frac 12 \left([\nabla\mathbf u] + [\nabla\mathbf u]^T\right)\) is the symmetrized gradient. In the second to last step, we used that the scalar product between an arbitrary tensor \(\nabla\mathbf u\) and a symmetric tensor \(\frac 12[\partial_i v_j + \partial_j v_i]\) equals the scalar product of the symmetric part of the former with the second tensor. Using the techniques discussed above, the obvious way to implement this goes like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_i_symmgrad</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].symmetric_gradient (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_j_symmgrad</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].symmetric_gradient (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            +=  (phi_i_div phi_j_div</div>
<div class="line">                 lambda_values[q_point]</div>
<div class="line">                 +</div>
<div class="line">                 2</div>
<div class="line">                 (phi_i_symmgrad phi_j_symmgrad)</div>
<div class="line">                 mu_values[q_point])</div>
<div class="line">                fe_values.JxW(q_point);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>So if, again, this is not the code we use in <a class="el" href="step_8.html">step-8</a> , what do we do there? The answer rests on the finite element we use. In <a class="el" href="step_8.html">step-8</a> , we use the following element:</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
</div><!-- fragment --><p> In other words, the finite element we use consists of <code>dim</code> copies of the same scalar element. This is what we call a <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> element: an element that may be vector-valued but where each shape function has exactly one non-zero component. In other words: if the \(x\) -component of a displacement shape function is nonzero, then the \(y\) - and \(z\) -components must be zero and similarly for the other components. What this means is that also derived quantities based on shape functions inherit this sparsity property. For example: the divergence \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z) + \partial_y\varphi_y(x,y,z) + \partial_z\varphi_z(x,y,z)\) of a vector-valued shape function \(\Phi(x,y,z)=(\varphi_x(x,y,z), \varphi_y(x,y,z), \varphi_z(x,y,z))^T\) is, in the present case, either \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z)\) , \(\mathrm{div}\ \Phi(x,y,z)=\partial_y\varphi_y(x,y,z)\) , or \(\mathrm{div}\ \Phi(x,y,z)=\partial_z\varphi_z(x,y,z)\) , because exactly one of the \(\varphi_\ast\) is nonzero. Knowing this means that we can save a number of computations that, if we were to do them, would only yield zeros to add up. In a similar vein, if only one component of a shape function is nonzero, then only one row of its gradient \(\nabla\Phi\) is nonzero. What this means for terms like \((\mu \nabla\Phi_i,\nabla\Phi_j)\) , where the scalar product between two tensors is defined as \((\tau, \gamma)_\Omega=\int_\Omega \sum_{i,j=1}^d \tau_{ij} \gamma_{ij}\) , is that the term is only nonzero if both tensors have their nonzero entries in the same row, which means that the two shape functions have to have their single nonzero component in the same location. If we use this sort of knowledge, then we can in a first step avoid computing gradient tensors if we can determine up front that their scalar product will be nonzero, in a second step avoid building the entire tensors and only get its nonzero components, and in a final step simplify the scalar product by only considering that index \(i\) for the one nonzero row, rather than multiplying and adding up zeros. The vehicle for all this is the ability to determine which vector component is going to be nonzero. This information is provided by the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> function. What can be done with it, using the example above, is explained in detail in <a class="el" href="step_8.html">step-8</a> .</p>
<p><a class="anchor" id="VVBlockSolvers"></a></p><h3>Block solvers</h3>
<p>Using techniques as shown above, it isn't particularly complicated to assemble the linear system, i.e. matrix and right hand side, for a vector-valued problem. However, then it also has to be solved. This is more complicated. Naively, one could just consider the matrix as a whole. For most problems, this matrix is not going to be definite (except for special cases like the elasticity equations covered in <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a> ). It will, often, also not be symmetric. This rather general class of matrices presents problems for iterative solvers: the lack of structural properties prevents the use of most efficient methods and preconditioners. While it can be done, the solution process will therefore most often be slower than necessary. The answer to this problem is to make use of the structure of the problem. For example, for the mixed Laplace equations discussed above, the operator has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \end{eqnarray*}
</p>
<p>It would be nice if this structure could be recovered in the linear system as well. For example, after discretization, we would like to have a matrix with the following block structure: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right), \end{eqnarray*}
</p>
<p> where \(M\) represents the mass matrix that results from discretizing the identity operator \(\mathbf 1\) and \(B\) the equivalent of the gradient operator. By default, this is not what happens, however. Rather, deal.II assigns numbers to degrees of freedom in a rather random manner. Consequently, if you form a vector out of the values of degrees of freedom will not be neatly ordered in a vector like </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{c} U \\ P \end{array} \right). \end{eqnarray*}
</p>
<p> Rather, it will be a permutation of this, with numbers of degrees of freedom corresponding to velocities and pressures intermixed. Consequently, the system matrix will also not have the nice structure mentioned above, but with the same permutation or rows and columns. But then we still have to make use of it, i.e. we have to come up with a solver that uses the structure. For example, in <a class="el" href="step_20.html">step-20</a> , we do a block elimination of the linear system </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right) \left( \begin{array}{c} U \\ P \end{array} \right) = \left( \begin{array}{c} F \\ G \end{array} \right). \end{eqnarray*}
</p>
<p> What this system means, of course, is </p><p class="formulaDsp">
\begin{eqnarray*} MU + BP &amp;=&amp; F,\\ B^TU &amp;=&amp; G. \end{eqnarray*}
</p>
<p>So, if we multiply the first equation by \(B^TM^{-1}\) and subtract the second from the result, we get </p><p class="formulaDsp">
\begin{eqnarray*} B^TM^{-1}BP &amp;=&amp; B^TM^{-1}F-G. \end{eqnarray*}
</p>
<p>This is an equation that now only contains the pressure variables. If we can solve it, we can in a second step solve for the velocities using </p><p class="formulaDsp">
\begin{eqnarray*} MU = F-BP. \end{eqnarray*}
</p>
<p>This has the advantage that the matrices \(B^TM^{-1}B\) and \(M\) that we have to solve with are both symmetric and positive definite, as opposed to the large whole matrix we had before. How a solver like this is implemented is explained in more detail in <a class="el" href="step_20.html">@ref step_20 </a>step-20"  ", <a class="el" href="step_31.html">step-31</a> , and a few other tutorial programs. What we would like to point out here is that we now need a way to extract certain parts of a matrix or vector: if we are to multiply, say, the \(U\) part of the solution vector by the \(M\) part of the global matrix, then we need to have a way to access these parts of the whole. This is where the <a class="el" href="classBlockVector.html">BlockVector</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, and similar classes come in. For all practical purposes, then can be used as regular vectors or sparse matrices, i.e. they offer element access, provide the usual vector operations and implement, for example, matrix-vector multiplications. In other words, assembling matrices and right hand sides works in exactly the same way as for the non-block versions. That said, internally they store the elements of vectors and matrices in "blocks"; for example, instead of using one large array, the <a class="el" href="classBlockVector.html">BlockVector</a> class stores it as a set of arrays each of which we call a block. The advantage is that, while the whole thing can be used as a vector, one can also access an individual block which then, again, is a vector with all the vector operations. To show how to do this, let us consider the second equation \(MU=F-BP\) to be solved above. This can be achieved using the following sequence similar to what we have in <a class="el" href="step_20.html">step-20</a> :</p>
<div class="fragment"><div class="line"> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0).size());</div>
<div class="line"> system_matrix.block(0,1).vmult (tmp, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1));</div>
<div class="line"> tmp=</div>
<div class="line"> </div>
<div class="line">-1;</div>
<div class="line"> tmp += system_rhs.block(0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0).size(),</div>
<div class="line">                               1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8*tmp.l2_norm());</div>
<div class="line"> <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control, vector_memory);</div>
<div class="line"> </div>
<div class="line"> cg.solve (system_matrix.block(0,0),</div>
<div class="line">           <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0),</div>
<div class="line">           tmp,</div>
<div class="line">           <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div>
</div><!-- fragment --><p>What's happening here is that we allocate a temporary vector with as many elements as the first block of the solution vector, i.e. the velocity component \(U\) , has. We then set this temporary vector equal to the \((0,1)\) block of the matrix, i.e. \(B\) , times component 1 of the solution which is the previously computed pressure \(P\) . The result is multiplied by \(-1\) , and component 0 of the right hand side, \(F\) is added to it. The temporary vector now contains \(F-BP\) . The rest of the code snippet simply solves a linear system with \(F-BP\) as right hand side and the \((0,0)\) block of the global matrix, i.e. \(M\) . Using block vectors and matrices in this way therefore allows us to quite easily write rather complicated solvers making use of the block structure of a linear system.</p>
<p><a class="anchor" id="VVExtracting"></a></p><h3>Extracting data from solutions</h3>
<p>Once one has computed a solution, it is often necessary to evaluate it at quadrature points, for example to evaluate nonlinear residuals for the next Newton iteration, to evaluate the finite element residual for error estimators, or to compute the right hand side for the next time step in a time dependent problem. The way this is done us to again use an <a class="el" href="classFEValues.html">FEValues</a> object to evaluate the shape functions at quadrature points, and with those also the values of a finite element function. For the example of the mixed Laplace problem above, consider the following code after solving:</p>
<div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; local_solution_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>,</div>
<div class="line">                                                   <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line"> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line"> endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line"> {</div>
<div class="line">   fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">   fe_values.get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                  local_solution_values);</div>
</div><!-- fragment --><p>After this, the variable <code>local_solution_values</code> is a list of vectors of a length equal to the number of quadrature points we have initialized the <a class="el" href="classFEValues.html">FEValues</a> object with; each of these vectors has <code>dim+1</code> elements containing the values of the <code>dim</code> velocities and the one pressure at a quadrature point. We can use these values to then construct other things like residuals. However, the construct is a bit awkward. First, we have a <code>std::vector</code> of <code><a class="el" href="classVector.html">Vector</a></code> s, which always looks strange. It is also inefficient because it implies dynamic memory allocation for the outer vector as well as for all the inner vectors. Secondly, maybe we are only interested in the velocities, for example to solve an advection problem in a second stage (as, for example, in <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_31.html">step-31</a> ). In that case, one would have to hand-extract these values like so:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">      <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = local_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>);</div>
<div class="line"> </div>
<div class="line">    ... <span class="keywordflow">do</span> <a class="code" href="base_2utilities__0_8txt.html#a065972a6fe9aa6a602ec82e81ad24464">something</a> <a class="code" href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a> <span class="keyword">this</span> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a> ...</div>
</div><!-- fragment --><p> Note how we convert from a <a class="el" href="classVector.html">Vector</a> (which is simply a collection of vector elements) into a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> because the velocity is a quantity characterized by <code>dim</code> elements that have certain transformation properties under rotations of the coordinate system. This code can be written more elegantly and efficiently using code like the following:</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; local_velocity_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a> (0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line"> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line"> endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line"> {</div>
<div class="line">   fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">   fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                              local_velocity_values);</div>
</div><!-- fragment --><p>As a result, we here get the velocities right away, and in the right data type (because we have described, using the extractor, that the first <code>dim</code> components of the finite element belong together, forming a tensor). The code is also more efficient: it requires less dynamic memory allocation because the <a class="el" href="classTensor.html">Tensor</a> class allocates its components as member variables rather than on the heap, and we save cycles because we don't even bother computing the values of the pressure variable at the quadrature points. On the other hand, if we had been interested in only the pressure and not the velocities, then the following code extracting scalar values would have done:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; local_pressure_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line"> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line"> endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line"> {</div>
<div class="line">   fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">   fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                            local_pressure_values);</div>
</div><!-- fragment --><p>In similar cases, one sometimes needs the gradients or second derivatives of the solution, or of individual scalar or vector components. To get at those of all components of the solution, the functions <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients</a> and <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">FEValuesBase::get_function_hessians</a> are the equivalent of the function <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values</a> used above. Likewise, to extract the gradients of scalar components, <a class="el" href="classFEValuesViews_1_1Scalar.html#a8073486fd29629a2e6caa56d7be06fff">FEValuesViews::Scalar::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Scalar.html#ad3c3ec313b98641126f8bc291be01256">FEValuesViews::Scalar::get_function_hessians</a> do the job. For vector- (tensor-)valued quantities, there are functions <a class="el" href="classFEValuesViews_1_1Vector.html#aa469aee7243e38f768456b05a8508b12">FEValuesViews::Vector::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#ad301452a86ba9e30350a1d23140d9097">FEValuesViews::Vector::get_function_hessians</a>, and in addition <a class="el" href="classFEValuesViews_1_1Vector.html#a2ee7e08308ff6fda2247b8110bdae1b6">FEValuesViews::Vector::get_function_symmetric_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#a0e9bede28d8dc1cae196fedbe52f2818">FEValuesViews::Vector::get_function_divergences</a>. Moreover, there is a shortcut available in case when only the Laplacians of the solution (which is the trace of the hessians) is needed, usable for both scalar and vector-valued problems as <a class="el" href="classFEValuesViews_1_1Scalar.html#ace2d43a069e46e5af4afdc53a453aa3a">FEValuesViews::Scalar::get_function_laplacians</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#ae6cdbbcca2f7a8067d5646cad8be8b46">FEValuesViews::Vector::get_function_laplacians</a>.</p>
<p><a class="anchor" id="VVOutput"></a></p><h3>Generating graphical output</h3>
<p>As mentioned above, an <a class="el" href="classFESystem.html">FESystem</a> object may hold multiple vector components, but it doesn't have a notion what they actually mean. As an example, take the object</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1);</div>
</div><!-- fragment --><p> It has <code>dim+1</code> vector components, but what do they mean? Are they the <code>dim</code> components of a velocity vector plus one pressure? Are they the pressure plus the <code>dim</code> velocity components? Or are they a collection of scalars? The point is that the <a class="el" href="classFESystem.html">FESystem</a> class doesn't care. The <em>interpretation</em> of what the components mean is up to the person who uses the element later, for example in assembling a linear form, or in extracting data solution components for a linearized system in the next Newton step. In almost all cases, this interpretation happens at the place where it is needed. There is one case where one has to be explicit, however, and that is in generating graphical output. The reason is that many file formats for visualization want data that represents vectors (e.g. velocities, displacements, etc) to be stored separately from scalars (pressures, densities, etc), and there often is no way to group a bunch of scalars into a vector field from within a visualization program. To achieve this, we need to let the <a class="el" href="classDataOut.html">DataOut</a> class and friends know which components of the <a class="el" href="classFESystem.html">FESystem</a> form vectors (with <code>dim</code> components) and which are scalars. This is shown, for example, in <a class="el" href="step_22.html">step-22</a> where we generate output as follows:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line"> data_component_interpretation</div>
<div class="line"> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">data_component_interpretation</div>
<div class="line"> .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, solution_names,</div>
<div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div>
<div class="line">                         data_component_interpretation);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> ();</div>
</div><!-- fragment --><p> In other words, we here create an array of <code>dim+1</code> elements in which we store which elements of the finite element are vectors and which are scalars; the array is filled with <code>dim</code> copies of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a> and a single trailing element of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a> . The array is then given as an extra argument to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> to explain how the data in the given solution vector is to be interpreted. Visualization programs like VisIt and Paraview will then offer to show these <code>dim</code> components as vector fields, rather than as individual scalar fields.</p>
<ul>
<li>
The elasticity equation discussed in <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_17.html">step-17</a>, and <a class="el" href="step_18.html">step-18</a> in which the solution is the vector-valued displacement at each point. </li>
<li>
The mixed Laplace equation and its extensions discussed in <a class="el" href="step_20.html">step-20</a>, and <a class="el" href="step_21.html">step-21</a> in which the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
The Stokes equation and its extensions discussed in <a class="el" href="step_22.html">step-22</a>, and <a class="el" href="step_31.html">step-31</a> in which again the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
Complex-valued solutions consisting of real and imaginary parts, as discussed for example in <a class="el" href="step_29.html">step-29</a>. </li>
</ul>
<p>This page gives an overview of how to implement such vector-valued problems easily in deal.II. In particular, it explains the usage of the class <a class="el" href="classFESystem.html">FESystem</a>, which allows us to write code for systems of partial differential very much like we write code for single equations.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.html">video lecture 21</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<table class="tutorial" width="50%">
<tr>
<th><b>Table of contents</b> </th></tr>
<tr>
<td width="100%" valign="top"><ol>
<li>
<a class="el" href="group__vector__valued.html#VVExamples">Examples of vector-valued problems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVFEs">Describing finite element spaces</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAssembling">Assembling linear systems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAlternative">An alternative approach</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVBlockSolvers">Block solvers</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVExtracting">Extracting data from solutions</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVOutput">Generating graphical output</a> </li>
</ol>
</td></tr>
</table>
<p><a class="anchor" id="VVExamples"></a> </p><h3>Examples of vector-valued problems</h3>
<p>The way one deals systematically with vector-valued problems is not fundamentally different from scalar problems: first, we need a weak (variational) formulation of the problem that takes into account all the solution variables. After we did so, generating the system matrix and solving the linear system follows the same outlines that we are used to already.</p>
<h4>Linear elasticity</h4>
<p>Let us take for example the elasticity problem from <a class="el" href="step_8.html">step-8</a> and even simplify it by choosing \(\lambda = 0\) and \(\mu = 1\) to highlight the important concepts. Therefore, let consider the following weak formulation: find \(\mathbf u \in \mathbf V = H^1_0(\Omega; \mathbb R^3)\) such that for all \(\mathbf v\in V\) holds </p><p class="formulaDsp">
\[ a(u,v) \equiv 2\int_{\Omega} \mathbf D\mathbf u : \mathbf D\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
<p> Here, <b>D</b> denotes the symmetric gradient defined by \(\mathbf Du = \tfrac12 (\nabla \mathbf u + (\nabla \mathbf u)^T)\) and the colon indicates double contraction of two tensors of rank 2 (the Frobenius inner product). This bilinear form looks indeed very much like the bilinear form of the Poisson problem in <a class="el" href="step_3.html">step-3</a>. The only differences are </p><ol>
<li>
<p class="startli">We replaced the gradient operator by the symmetric gradient; this is actually not a significant difference, and everything said here is true if your replace \(\mathbf D\) by \(\nabla\). Indeed, let us do this to simplify the discussion: </p><p class="formulaDsp">
\[ a(u,v) \equiv \int_{\Omega} \nabla\mathbf u : \nabla\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
<p> Note though, that this system is not very exciting, since we could solve for the three components of <b>u</b> separately.</p>
<p class="endli"></p>
</li>
<li>
The trial and test functions are now from the space \(H^1_0(\Omega; \mathbb R^3)\), which can be viewed as three copies of the scalar space \(H^1_0(\Omega)\). And this is exactly, how we are going to implement this space below, using <a class="el" href="classFESystem.html">FESystem</a>. </li>
</ol>
<p>But for now, let us look at the system a little more closely. First, let us exploit that <b>u</b>=(<em>u</em><sub>1</sub>,<em>u</em><sub>2</sub>,<em>u</em><sub>3</sub>)<sup>T</sup> and <b>v</b> accordingly. Then, we can write the simplified equation in coordinates as </p><p class="formulaDsp">
\[ a(u,v) = \int_\Omega \bigl(\nabla u_1\cdot \nabla v_1 +\nabla u_2\cdot \nabla v_2+\nabla u_3\cdot \nabla v_3\bigr)\,dx = \int_\Omega \bigl(f_1v_1 + f_2 v_2 + f_3 v_3\bigr)\,dx. \]
</p>
<p> We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component (this is where the formulation with the \(\mathbf D\) is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions: first, choose <b>v</b>=(<em>v</em><sub>1</sub>,0,0)<sup>T</sup>, then <b>v</b>=(0,<em>v</em><sub>2</sub>,0)<sup>T</sup>, and finally <b>v</b>=(0,0,<em>v</em><sub>3</sub>)<sup>T</sup>. writing the outcomes below each other, we obtain the system </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) &amp;&amp;&amp; = (f_1, v_1) \\ &amp; (\nabla u_2,\nabla v_2) &amp;&amp; = (f_2, v_2) \\ &amp;&amp; (\nabla u_3,\nabla v_3) &amp; = (f_3, v_3) \end{matrix} \]
</p>
<p> where we used the standard inner product notation \((\mathbf f,\mathbf g) = \int_\Omega \mathbf f \cdot \mathbf g \,dx\). It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form <em>a</em>(<em>u</em>,<em>v</em>), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient <b>D</b>: </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) + (\partial_1 u_1,\partial_1 v_1) &amp; (\partial_1 u_2,\partial_2 v_1) &amp; (\partial_1 u_3,\partial_3 v_1) &amp; = (f_1, v_1) \\ (\partial_2 u_1,\partial_1 v_2) &amp; (\nabla u_2,\nabla v_2) + (\partial_2 u_2,\partial_2 v_2) &amp; (\partial_2 u_3,\partial_3 v_2) &amp; = (f_2, v_2) \\ (\partial_3 u_1,\partial_1 v_3) &amp; (\partial_3 u_2,\partial_2 v_3) &amp; (\nabla u_3,\nabla v_3) + (\partial_3 u_3,\partial_3 v_3) &amp; = (f_3, v_3) \end{matrix}. \]
</p>
<p> Very formally, if we believe in operator valued matrices, we can rewrite this in the form <b>v</b><sup>T</sup><b>Au</b> = <b>v</b><sup>T</sup><b>f</b> or </p><p class="formulaDsp">
\[ \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} (\nabla \cdot,\nabla \cdot) + (\partial_1 \cdot,\partial_1 \cdot) &amp; (\partial_1 \cdot,\partial_2 \cdot) &amp; (\partial_1 \cdot,\partial_3 \cdot) \\ (\partial_2 \cdot,\partial_1 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_2 \cdot,\partial_2 \cdot) &amp; (\partial_2 \cdot,\partial_3 \cdot) \\ (\partial_3 \cdot,\partial_1 \cdot) &amp; (\partial_3 \cdot,\partial_2 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_3 \cdot,\partial_3 \cdot) \end{pmatrix} \begin{pmatrix} u_1 \\ u_2 \\ u_3 \end{pmatrix} = \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} f_1 \\ f_2 \\ f_3\end{pmatrix} \]
</p>
<h4>Mixed elliptic problems</h4>
<p>Now, let us consider a more complex example, the mixed Laplace equations discussed in <a class="el" href="step_20.html">step-20</a> in three dimensions: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{u} + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; f, \end{eqnarray*}
</p>
<p>Here, we have four solution components: the scalar pressure \(p \in L^2(\Omega)\) and the vector-valued velocity \(\mathbf u \in \mathbf V = H^{\text{div}}_0(\Omega)\) with three vector components. Note as important difference to the previous example, that the vector space <b>V</b> is not just simply a copy of three identical spaces/</p>
<p>A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) = \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \end{eqnarray*}
</p>
<p>This makes it clear that the solution </p><p class="formulaDsp">
\begin{eqnarray*} U = \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \end{eqnarray*}
</p>
<p> indeed has four components. We note that we could change the ordering of the solution components \(\textbf u\) and \(p\) inside \(U\) if we also change columns of the matrix operator.</p>
<p>Next, we need to think about test functions \(V\). We want to multiply both sides of the equation with them, then integrate over \(\Omega\). The result should be a scalar equality. We can achieve this by choosing \(V\) also vector valued as </p><p class="formulaDsp">
\begin{eqnarray*} V = \left( \begin{array}{c} \mathbf v \\ q \end{array} \right). \end{eqnarray*}
</p>
<p>It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on (in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want.</p>
<p>With this in mind, let us multiply by \(V\) and integrate to get the following equation which has to hold for all test functions \(V\): </p><p class="formulaDsp">
\begin{eqnarray*} \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \ dx = \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \ dx, \end{eqnarray*}
</p>
<p> or equivalently: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) + (\mathbf v, \nabla p) - (q, \mathrm{div}\ \mathbf u) = (q,f), \end{eqnarray*}
</p>
<p>We get the final form by integrating by part the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) - (\mathrm{div}\ \mathbf v, p) - (q, \mathrm{div}\ \mathbf u) = (q,f) - (\mathbf n\cdot\mathbf v, p)_{\partial\Omega}. \end{eqnarray*}
</p>
<p>It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector: the form in which we have solution and test functions \(U,V\) that each consist of a number of vector components that we can extract.</p>
<p><a class="anchor" id="VVFEs"></a> </p><h3>Describing finite element spaces</h3>
<p>Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the <a class="el" href="classFESystem.html">FESystem</a> class comes in: it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need <code>dim</code> copies of the same element, for instance </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> elasticity_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
</div><!-- fragment --><p> This will generate a vector valued space of dimension <code>dim</code>, where each component is a continuous bilinear element of type <a class="el" href="classFE__Q.html">FE_Q</a>. It will have <code>dim</code> times as many basis functions as the corresponding <a class="el" href="classFE__Q.html">FE_Q</a>, and each of these basis functions is a basis function of <a class="el" href="classFE__Q.html">FE_Q</a>, lifted into one of the components of the vector.</p>
<p>For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces \(\mathbf V_h \times Q_h \subset H^{\text{div}}_0(\Omega) \times L^2_0(\Omega)\). One option would be the stable Raviart-Thomas pair </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> rt_element (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas&lt;dim&gt;</a>(1), 1,</div>
<div class="line">                          <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),          1);</div>
</div><!-- fragment --><p> The first element in this system is already a vector valued element of dimension <code>dim</code>, while the second is a regular scalar element.</p>
<p>Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_1 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1);</div>
</div><!-- fragment --><p> This system just has <code>dim+1</code> equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_equal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>), 1,</div>
<div class="line">                                 <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),                     1);</div>
</div><!-- fragment --><p> Here, we have a system of two elements, one vector-valued and one scalar, very much like with the <code>rt_element</code>. Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_unequal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>), 1,</div>
<div class="line">                                   <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2),                     1);</div>
</div><!-- fragment --><p> It must be pointed out, that this element is different from </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_2 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,</div>
<div class="line">                                        <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2), 1);</div>
</div><!-- fragment --><p> While the constructor call is very similar to <code>rt_element</code>, the result actually resembles more <code>ldg_convoluted_element_1</code> in that this element produces <code>dim+1</code> independent components. A more detailed comparison of the resulting <a class="el" href="classFESystem.html">FESystem</a> objects is below.</p>
<h4>Internal structure of <a class="el" href="classFESystem.html">FESystem</a></h4>
<p><a class="el" href="classFESystem.html">FESystem</a> has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table: </p><table border="1">
<tr>
<th>System Element </th><th><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElementData::n_blocks()</a> </th><th><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> </th><th><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">FiniteElement::n_base_elements()</a>  </th></tr>
<tr>
<td><code>elasticity_element</code></td><td><code>dim</code></td><td><code>dim</code></td><td>1  </td></tr>
<tr>
<td><code>rt_element</code></td><td>2</td><td><code>dim+1</code></td><td>2  </td></tr>
<tr>
<td><code>ldg_equal_element</code></td><td>2</td><td><code>dim+1</code></td><td>2  </td></tr>
<tr>
<td><code>ldg_convoluted_element_1</code></td><td><code>dim+1</code></td><td><code>dim+1</code></td><td>1  </td></tr>
<tr>
<td><code>ldg_convoluted_element_2</code></td><td><code>dim+1</code></td><td><code>dim+1</code></td><td>2  </td></tr>
</table>
<p>From this table, it is clear that the <a class="el" href="classFESystem.html">FESystem</a> reflects a lot of the structure of the system of differential equations in the cases of the <code>rt_element</code> and the <code>ldg_equal_element</code>, in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below.</p>
<p>At this point, it is important to note that nesting of two <a class="el" href="classFESystem.html">FESystem</a> object can give the whole <a class="el" href="classFESystem.html">FESystem</a> a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so.</p>
<p><a class="anchor" id="VVAssembling"></a> </p><h3>Assembling linear systems</h3>
<p>The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with <a class="el" href="step_3.html">step-3</a>. Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below.</p>
<p>The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled.</p>
<h4>A single <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></h4>
<p>This is essentially how <a class="el" href="step_20.html">step-20</a> does it: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a> (0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">typename <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line">  endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">  {</div>
<div class="line">    fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">    local_matrix = 0;</div>
<div class="line">    local_rhs = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">right_hand_side</a>.value_list (fe_values.get_quadrature_points(),</div>
<div class="line">                                rhs_values);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += (fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                                  fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                                  -</div>
<div class="line">                                  fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                                  fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                                  -</div>
<div class="line">                                  fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                                  fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)) *</div>
<div class="line">                                  fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">          local_rhs(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) += - fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                          rhs_values[q] *</div>
<div class="line">                          fe_values.JxW(q);</div>
<div class="line">        }</div>
</div><!-- fragment --><p>So here's what is happening: </p><ul>
<li>
<p class="startli">The first thing we do is to declare "extractors" (see the <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a> namespace). These are objects that don't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1 (i.e. what we call a "physical vector", always consisting of <code>dim</code> components). Here, we declare an object that represents the velocities consisting of <code>dim</code> components starting at component zero, and the extractor for the pressure, which is a scalar component at position <code>dim</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form (i.e. neglecting boundary terms) looked as follows, based on shape functions \(V_i=\left(\begin{array}{c}\mathbf v_i \\ q_i\end{array}\right), V_j=\left(\begin{array}{c}\mathbf v_j \\ q_j\end{array}\right)\): </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v_i, \mathbf v_j) - (\mathrm{div}\ \mathbf v_i, q_j) - (q_i, \mathrm{div}\ \mathbf v_j) \end{eqnarray*}
</p>
<p> whereas the implementation looked like this: </p><div class="fragment"><div class="line">local_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) += (fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                      fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                      -</div>
<div class="line">                      fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                      fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                      -</div>
<div class="line">                      fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].value (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q) *</div>
<div class="line">                      fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q)</div>
<div class="line">                     ) *</div>
<div class="line">                     fe_values.JxW(q);</div>
</div><!-- fragment --><p> The similarities are pretty obvious.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Essentially, what happens in above code is this: when you do <code>fe_values[pressure]</code>, a so-called "view" is created, i.e. an object that unlike the full <a class="el" href="classFEValues.html">FEValues</a> object represents not all components of a finite element, but only the one(s) represented by the extractor object <code>pressure</code> or <code>velocities</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">These views can then be asked for information about these individual components. For example, when you write <code>fe_values[pressure].value(i,q)</code> you get the value of the pressure component of the \(i\)th shape function \(V_i\) at the \(q\)th quadrature point. Because the extractor <code>pressure</code> represents a scalar component, the results of the operator <code>fe_values[pressure].value(i,q)</code> is a scalar number. On the other hand, the call <code>fe_values[velocities].value(i,q)</code> would produce the value of a whole set of <code>dim</code> components, which would be of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>.</p>
<p class="endli"></p>
</li>
<li>
Other things that can be done with views is to ask for the gradient of a particular shape function's components described by an extractor. For example, <code>fe_values[pressure].gradient(i,q)</code> would represent the gradient of the scalar pressure component, which is of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>, whereas the gradient of the velocities components, <code>fe_values[velocities].gradient(i,q)</code> is a <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt;</code>, i.e. a matrix \(G_{ij}\) that consists of entries \(G_{ij}=\frac{\partial\phi_i}{\partial x_j}\). Finally, both scalar and vector views can be asked for the second derivatives ("Hessians") and vector views can be asked for the symmetric gradient, defined as \(S_{ij}=\frac 12 \left[\frac{\partial\phi_i}{\partial x_j} + \frac{\partial\phi_j}{\partial x_i}\right]\) as well as the divergence \(\sum_{d=0}^{dim-1} \frac{\partial\phi_d}{\partial x_d}\). </li>
</ul>
<p>Other examples of using extractors and views are shown in tutorial programs <a class="el" href="step_21.html">step-21</a>, <a class="el" href="step_22.html">step-22</a>, <a class="el" href="step_31.html">step-31</a> and several other programs.</p>
<dl class="section note"><dt>Note</dt><dd>In the current context, when we talk about a vector (for example in extracting the velocity components above), we mean the word in the sense physics uses it: it has <code>spacedim</code> components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word "vector" (and how we use this word in other contexts in the library, for example in the <a class="el" href="classVector.html">Vector</a> class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame; however, these are really just a collection of scalar variables, since they do not change if the coordinate system is rotated, unlike the components of a velocity vector, and consequently, this <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> class should not be used for this case.</dd></dl>
<p><a class="anchor" id="VVAlternative"></a> </p><h3>An alternative approach</h3>
<p>There are situations in which one can optimize the assembly of a matrix or right hand side vector a bit, using knowledge of the finite element in use. Consider, for example, the bilinear form of the elasticity equations which we are concerned with first in <a class="el" href="step_8.html">step-8</a>:</p>
<p class="formulaDsp">
\[ a({\mathbf u}, {\mathbf v}) = \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega, + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega, \]
</p>
<p>Here, \(\mathbf u\) is a vector function with <code>dim</code> components, \(\mathbf v\) the corresponding test function, and \(\lambda,\mu\) are material parameters. Given our discussions above, the obvious way to implement this bilinear form would be as follows, using an extractor object that interprets all <code>dim</code> components of the finite element as single vector, rather than disjoint scalar components:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a> (0);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_i_grad</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].gradient (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_j_grad</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].gradient (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            +=  (lambda_values[q_point] *</div>
<div class="line">                 phi_i_div * phi_j_div</div>
<div class="line">                 +</div>
<div class="line">                 mu_values[q_point] *</div>
<div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, phi_j_grad)</div>
<div class="line">                 +</div>
<div class="line">                 mu_values[q_point] *</div>
<div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(phi_j_grad))</div>
<div class="line">                ) *</div>
<div class="line">                fe_values.JxW(q_point);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Now, this is not the code used in <a class="el" href="step_8.html">step-8</a>. In fact, if one used the above code over the one implemented in that program, it would run about 8 per cent slower. It can be improved (bringing down the penalty to about 4 per cent) by taking a close look at the bilinear form. In fact, we can transform it as follows: </p><p class="formulaDsp">
\begin{eqnarray*} a({\mathbf u}, {\mathbf v}) &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \partial_i u_j, \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \frac 12[\partial_i u_j + \partial_j u_i], \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \varepsilon(\mathbf u), \varepsilon(\mathbf v) \right)_\Omega, \end{eqnarray*}
</p>
<p> where \(\varepsilon(\mathbf u) = \frac 12 \left([\nabla\mathbf u] + [\nabla\mathbf u]^T\right)\) is the symmetrized gradient. In the second to last step, we used that the scalar product between an arbitrary tensor \(\nabla\mathbf u\) and a symmetric tensor \(\frac 12[\partial_i v_j + \partial_j v_i]\) equals the scalar product of the symmetric part of the former with the second tensor. Using the techniques discussed above, the obvious way to implement this goes like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_i_symmgrad</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].symmetric_gradient (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div>
<div class="line">        = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,q_point);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>=0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>&lt;<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_j_symmgrad</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].symmetric_gradient (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div>
<div class="line">            = fe_values[<a class="code" href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">displacements</a>].divergence (<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>,q_point);</div>
<div class="line"> </div>
<div class="line">          <a class="code" href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>,<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            +=  (phi_i_div * phi_j_div *</div>
<div class="line">                 lambda_values[q_point]</div>
<div class="line">                 +</div>
<div class="line">                 2 *</div>
<div class="line">                 (phi_i_symmgrad * phi_j_symmgrad) *</div>
<div class="line">                 mu_values[q_point]) *</div>
<div class="line">                fe_values.JxW(q_point);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>So if, again, this is not the code we use in <a class="el" href="step_8.html">step-8</a>, what do we do there? The answer rests on the finite element we use. In <a class="el" href="step_8.html">step-8</a>, we use the following element: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
</div><!-- fragment --><p> In other words, the finite element we use consists of <code>dim</code> copies of the same scalar element. This is what we call a <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> element: an element that may be vector-valued but where each shape function has exactly one non-zero component. In other words: if the \(x\)-component of a displacement shape function is nonzero, then the \(y\)- and \(z\)-components must be zero and similarly for the other components. What this means is that also derived quantities based on shape functions inherit this sparsity property. For example: the divergence \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z) + \partial_y\varphi_y(x,y,z) + \partial_z\varphi_z(x,y,z)\) of a vector-valued shape function \(\Phi(x,y,z)=(\varphi_x(x,y,z), \varphi_y(x,y,z), \varphi_z(x,y,z))^T\) is, in the present case, either \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z)\), \(\mathrm{div}\ \Phi(x,y,z)=\partial_y\varphi_y(x,y,z)\), or \(\mathrm{div}\ \Phi(x,y,z)=\partial_z\varphi_z(x,y,z)\), because exactly one of the \(\varphi_\ast\) is nonzero. Knowing this means that we can save a number of computations that, if we were to do them, would only yield zeros to add up.</p>
<p>In a similar vein, if only one component of a shape function is nonzero, then only one row of its gradient \(\nabla\Phi\) is nonzero. What this means for terms like \((\mu \nabla\Phi_i,\nabla\Phi_j)\), where the scalar product between two tensors is defined as \((\tau, \gamma)_\Omega=\int_\Omega \sum_{i,j=1}^d \tau_{ij} \gamma_{ij}\), is that the term is only nonzero if both tensors have their nonzero entries in the same row, which means that the two shape functions have to have their single nonzero component in the same location.</p>
<p>If we use this sort of knowledge, then we can in a first step avoid computing gradient tensors if we can determine up front that their scalar product will be nonzero, in a second step avoid building the entire tensors and only get its nonzero components, and in a final step simplify the scalar product by only considering that index \(i\) for the one nonzero row, rather than multiplying and adding up zeros.</p>
<p>The vehicle for all this is the ability to determine which vector component is going to be nonzero. This information is provided by the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> function. What can be done with it, using the example above, is explained in detail in <a class="el" href="step_8.html">step-8</a>.</p>
<p><a class="anchor" id="VVBlockSolvers"></a> </p><h3>Block solvers</h3>
<p>Using techniques as shown above, it isn't particularly complicated to assemble the linear system, i.e. matrix and right hand side, for a vector-valued problem. However, then it also has to be solved. This is more complicated. Naively, one could just consider the matrix as a whole. For most problems, this matrix is not going to be definite (except for special cases like the elasticity equations covered in <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a>). It will, often, also not be symmetric. This rather general class of matrices presents problems for iterative solvers: the lack of structural properties prevents the use of most efficient methods and preconditioners. While it can be done, the solution process will therefore most often be slower than necessary.</p>
<p>The answer to this problem is to make use of the structure of the problem. For example, for the mixed Laplace equations discussed above, the operator has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \end{eqnarray*}
</p>
<p>It would be nice if this structure could be recovered in the linear system as well. For example, after discretization, we would like to have a matrix with the following block structure: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right), \end{eqnarray*}
</p>
<p> where \(M\) represents the mass matrix that results from discretizing the identity operator \(\mathbf 1\) and \(B\) the equivalent of the gradient operator.</p>
<p>By default, this is not what happens, however. Rather, deal.II assigns numbers to degrees of freedom in a rather random manner. Consequently, if you form a vector out of the values of degrees of freedom will not be neatly ordered in a vector like </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{c} U \\ P \end{array} \right). \end{eqnarray*}
</p>
<p> Rather, it will be a permutation of this, with numbers of degrees of freedom corresponding to velocities and pressures intermixed. Consequently, the system matrix will also not have the nice structure mentioned above, but with the same permutation or rows and columns.</p>
<p>What is needed is to re-enumerate degrees of freedom so that velocities come first and pressures last. This can be done using the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function, as explained in <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_21.html">step-21</a>, <a class="el" href="step_22.html">step-22</a>, and <a class="el" href="step_31.html">step-31</a>. After this, at least the degrees of freedom are partitioned properly.</p>
<p>But then we still have to make use of it, i.e. we have to come up with a solver that uses the structure. For example, in <a class="el" href="step_20.html">step-20</a>, we do a block elimination of the linear system </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right) \left( \begin{array}{c} U \\ P \end{array} \right) = \left( \begin{array}{c} F \\ G \end{array} \right). \end{eqnarray*}
</p>
<p> What this system means, of course, is </p><p class="formulaDsp">
\begin{eqnarray*} MU + BP &amp;=&amp; F,\\ B^TU &amp;=&amp; G. \end{eqnarray*}
</p>
<p>So, if we multiply the first equation by \(B^TM^{-1}\) and subtract the second from the result, we get </p><p class="formulaDsp">
\begin{eqnarray*} B^TM^{-1}BP &amp;=&amp; B^TM^{-1}F-G. \end{eqnarray*}
</p>
<p>This is an equation that now only contains the pressure variables. If we can solve it, we can in a second step solve for the velocities using </p><p class="formulaDsp">
\begin{eqnarray*} MU = F-BP. \end{eqnarray*}
</p>
<p>This has the advantage that the matrices \(B^TM^{-1}B\) and \(M\) that we have to solve with are both symmetric and positive definite, as opposed to the large whole matrix we had before.</p>
<p>How a solver like this is implemented is explained in more detail in <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_31.html">step-31</a>, and a few other tutorial programs. What we would like to point out here is that we now need a way to extract certain parts of a matrix or vector: if we are to multiply, say, the \(U\) part of the solution vector by the \(M\) part of the global matrix, then we need to have a way to access these parts of the whole.</p>
<p>This is where the <a class="el" href="classBlockVector.html">BlockVector</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, and similar classes come in. For all practical purposes, then can be used as regular vectors or sparse matrices, i.e. they offer element access, provide the usual vector operations and implement, for example, matrix-vector multiplications. In other words, assembling matrices and right hand sides works in exactly the same way as for the non-block versions. That said, internally they store the elements of vectors and matrices in "blocks"; for example, instead of using one large array, the <a class="el" href="classBlockVector.html">BlockVector</a> class stores it as a set of arrays each of which we call a block. The advantage is that, while the whole thing can be used as a vector, one can also access an individual block which then, again, is a vector with all the vector operations.</p>
<p>To show how to do this, let us consider the second equation \(MU=F-BP\) to be solved above. This can be achieved using the following sequence similar to what we have in <a class="el" href="step_20.html">step-20</a>: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0).size());</div>
<div class="line">system_matrix.block(0,1).vmult (tmp, <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(1));</div>
<div class="line">tmp *= -1;</div>
<div class="line">tmp += system_rhs.block(0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0).size(),</div>
<div class="line">                              1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-8*tmp.l2_norm());</div>
<div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control, vector_memory);</div>
<div class="line"> </div>
<div class="line">cg.solve (system_matrix.block(0,0),</div>
<div class="line">          <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>.block(0),</div>
<div class="line">          tmp,</div>
<div class="line">          <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div>
</div><!-- fragment --><p>What's happening here is that we allocate a temporary vector with as many elements as the first block of the solution vector, i.e. the velocity component \(U\), has. We then set this temporary vector equal to the \((0,1)\) block of the matrix, i.e. \(B\), times component 1 of the solution which is the previously computed pressure \(P\). The result is multiplied by \(-1\), and component 0 of the right hand side, \(F\) is added to it. The temporary vector now contains \(F-BP\). The rest of the code snippet simply solves a linear system with \(F-BP\) as right hand side and the \((0,0)\) block of the global matrix, i.e. \(M\). Using block vectors and matrices in this way therefore allows us to quite easily write rather complicated solvers making use of the block structure of a linear system.</p>
<p><a class="anchor" id="VVExtracting"></a> </p><h3>Extracting data from solutions</h3>
<p>Once one has computed a solution, it is often necessary to evaluate it at quadrature points, for example to evaluate nonlinear residuals for the next Newton iteration, to evaluate the finite element residual for error estimators, or to compute the right hand side for the next time step in a time dependent problem.</p>
<p>The way this is done us to again use an <a class="el" href="classFEValues.html">FEValues</a> object to evaluate the shape functions at quadrature points, and with those also the values of a finite element function. For the example of the mixed Laplace problem above, consider the following code after solving: </p><div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; local_solution_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>,</div>
<div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line">  endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">  {</div>
<div class="line">    fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    fe_values.get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                   local_solution_values);</div>
</div><!-- fragment --><p>After this, the variable <code>local_solution_values</code> is a list of vectors of a length equal to the number of quadrature points we have initialized the <a class="el" href="classFEValues.html">FEValues</a> object with; each of these vectors has <code>dim+1</code> elements containing the values of the <code>dim</code> velocities and the one pressure at a quadrature point.</p>
<p>We can use these values to then construct other things like residuals. However, the construct is a bit awkward. First, we have a <code>std::vector</code> of <code><a class="el" href="classVector.html">Vector</a></code>s, which always looks strange. It is also inefficient because it implies dynamic memory allocation for the outer vector as well as for all the inner vectors. Secondly, maybe we are only interested in the velocities, for example to solve an advection problem in a second stage (as, for example, in <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_31.html">step-31</a>). In that case, one would have to hand-extract these values like so: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>&lt;<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>)</div>
<div class="line">      <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a>[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>] = local_solution_values[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">d</a>);</div>
<div class="line"> </div>
<div class="line">    ... <span class="keywordflow">do</span> <a class="code" href="base_2utilities__0_8txt.html#a065972a6fe9aa6a602ec82e81ad24464">something</a> <a class="code" href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a> <span class="keyword">this</span> <a class="code" href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a> ...</div>
</div><!-- fragment --><p> Note how we convert from a <a class="el" href="classVector.html">Vector</a> (which is simply a collection of vector elements) into a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> because the velocity is a quantity characterized by <code>dim</code> elements that have certain transformation properties under rotations of the coordinate system.</p>
<p>This code can be written more elegantly and efficiently using code like the following: </p><div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; local_velocity_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> <a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a> (0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line">  endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">  {</div>
<div class="line">    fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    fe_values[<a class="code" href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a>].get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                               local_velocity_values);</div>
</div><!-- fragment --><p>As a result, we here get the velocities right away, and in the right data type (because we have described, using the extractor, that the first <code>dim</code> components of the finite element belong together, forming a tensor). The code is also more efficient: it requires less dynamic memory allocation because the <a class="el" href="classTensor.html">Tensor</a> class allocates its components as member variables rather than on the heap, and we save cycles because we don't even bother computing the values of the pressure variable at the quadrature points. On the other hand, if we had been interested in only the pressure and not the velocities, then the following code extracting scalar values would have done: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; local_pressure_values (<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> <a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a> (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> = dof_handler.begin_active(),</div>
<div class="line">  endc = dof_handler.end();</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>!=endc; ++<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">  {</div>
<div class="line">    fe_values.reinit (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line"> </div>
<div class="line">    fe_values[<a class="code" href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a>].get_function_values (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">                                             local_pressure_values);</div>
</div><!-- fragment --><p>In similar cases, one sometimes needs the gradients or second derivatives of the solution, or of individual scalar or vector components. To get at those of all components of the solution, the functions <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients</a> and <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">FEValuesBase::get_function_hessians</a> are the equivalent of the function <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values</a> used above.</p>
<p>Likewise, to extract the gradients of scalar components, <a class="el" href="classFEValuesViews_1_1Scalar.html#a8073486fd29629a2e6caa56d7be06fff">FEValuesViews::Scalar::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Scalar.html#ad3c3ec313b98641126f8bc291be01256">FEValuesViews::Scalar::get_function_hessians</a> do the job. For vector- (tensor-)valued quantities, there are functions <a class="el" href="classFEValuesViews_1_1Vector.html#aa469aee7243e38f768456b05a8508b12">FEValuesViews::Vector::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#ad301452a86ba9e30350a1d23140d9097">FEValuesViews::Vector::get_function_hessians</a>, and in addition <a class="el" href="classFEValuesViews_1_1Vector.html#a2ee7e08308ff6fda2247b8110bdae1b6">FEValuesViews::Vector::get_function_symmetric_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#a0e9bede28d8dc1cae196fedbe52f2818">FEValuesViews::Vector::get_function_divergences</a>.</p>
<p>Moreover, there is a shortcut available in case when only the Laplacians of the solution (which is the trace of the hessians) is needed, usable for both scalar and vector-valued problems as <a class="el" href="classFEValuesViews_1_1Scalar.html#ace2d43a069e46e5af4afdc53a453aa3a">FEValuesViews::Scalar::get_function_laplacians</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#ae6cdbbcca2f7a8067d5646cad8be8b46">FEValuesViews::Vector::get_function_laplacians</a>.</p>
<p><a class="anchor" id="VVOutput"></a> </p><h3>Generating graphical output</h3>
<p>As mentioned above, an <a class="el" href="classFESystem.html">FESystem</a> object may hold multiple vector components, but it doesn't have a notion what they actually mean. As an example, take the object </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>+1);</div>
</div><!-- fragment --><p> It has <code>dim+1</code> vector components, but what do they mean? Are they the <code>dim</code> components of a velocity vector plus one pressure? Are they the pressure plus the <code>dim</code> velocity components? Or are they a collection of scalars?</p>
<p>The point is that the <a class="el" href="classFESystem.html">FESystem</a> class doesn't care. The <em>interpretation</em> of what the components mean is up to the person who uses the element later, for example in assembling a linear form, or in extracting data solution components for a linearized system in the next Newton step. In almost all cases, this interpretation happens at the place where it is needed.</p>
<p>There is one case where one has to be explicit, however, and that is in generating graphical output. The reason is that many file formats for visualization want data that represents vectors (e.g. velocities, displacements, etc) to be stored separately from scalars (pressures, densities, etc), and there often is no way to group a bunch of scalars into a vector field from within a visualization program.</p>
<p>To achieve this, we need to let the <a class="el" href="classDataOut.html">DataOut</a> class and friends know which components of the <a class="el" href="classFESystem.html">FESystem</a> form vectors (with <code>dim</code> components) and which are scalars. This is shown, for example, in <a class="el" href="step_22.html">step-22</a> where we generate output as follows: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">  data_component_interpretation</div>
<div class="line">  (<a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">data_component_interpretation</div>
<div class="line">  .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (<a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>, solution_names,</div>
<div class="line">                          <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div>
<div class="line">                          data_component_interpretation);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> ();</div>
</div><!-- fragment --><p> In other words, we here create an array of <code>dim+1</code> elements in which we store which elements of the finite element are vectors and which are scalars; the array is filled with <code>dim</code> copies of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a> and a single trailing element of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a> . The array is then given as an extra argument to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> to explain how the data in the given solution vector is to be interpreted. Visualization programs like VisIt and Paraview will then offer to show these <code>dim</code> components as vector fields, rather than as individual scalar fields. </p>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="aclassFE__DGQ_html"><div class="ttname"><a href="classFE__DGQ.html">FE_DGQ&lt; dim &gt;</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_af35ca33203cd802325d779be7b6b41e8"><div class="ttname"><a href="multithreading__0_8txt.html#af35ca33203cd802325d779be7b6b41e8">with</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin with</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00139">multithreading_0.txt:139</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__cg_8h_source.html#l00088">solver_cg.h:88</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html"><div class="ttname"><a href="classSymmetricTensor.html">SymmetricTensor&lt; 2, dim &gt;</a></div></div>
<div class="ttc" id="aclassFE__RaviartThomas_html"><div class="ttname"><a href="classFE__RaviartThomas.html">FE_RaviartThomas</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__raviart__thomas_8h_source.html#l00092">fe_raviart_thomas.h:92</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__extractors_8h_source.html#l00095">fe_values_extractors.h:95</a></div></div>
<div class="ttc" id="abase_2utilities__0_8txt_html_a065972a6fe9aa6a602ec82e81ad24464"><div class="ttname"><a href="base_2utilities__0_8txt.html#a065972a6fe9aa6a602ec82e81ad24464">something</a></div><div class="ttdeci">for each remove leading and trailing spaces The default value of the delimiter is a so that the function splits comma separated lists of strings To make data input from tables if the input string ends in a then this last delimiter is ignored For **yields the same element list of output[2.x.37] as you would get if the input had been **or **As a consequence of this a call like **yields a one element list Because of the trimming of the single element is the empty string This function can digest the case that the delimiter is a space In this it returns all words in the string Combined with the rules this implies that **yields again the element list of output[2.x.38] from above despite the presence of space at the end of the string **yields an empty list regardless of the number of spaces in the string **Specialization of usually a documentation or something</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities__0_8txt_source.html#l00063">utilities_0.txt:63</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a93f65b0385560a34ec1d3c5ec5a882b8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a93f65b0385560a34ec1d3c5ec5a882b8">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a9b7d9c85221484e1998f6869d98cba8b">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__component__interpretation_8h_source.html#l00062">data_component_interpretation.h:62</a></div></div>
<div class="ttc" id="aclassPreconditionIdentity_html"><div class="ttname"><a href="classPreconditionIdentity.html">PreconditionIdentity</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2precondition_8h_source.html#l00082">precondition.h:82</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Vector_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__extractors_8h_source.html#l00140">fe_values_extractors.h:140</a></div></div>
<div class="ttc" id="amg__transfer__0_8txt_html_a6b401cd9c6154fc787311f58ab910002"><div class="ttname"><a href="mg__transfer__0_8txt.html#a6b401cd9c6154fc787311f58ab910002">pressure</a></div><div class="ttdeci">MGTransferBase is defined in mg_base h ***Implementation of transfer between the global vectors and the multigrid levels for use in the derived class MGTransferPrebuilt and other classes ***Reset the object to the state it had right after the default constructor **Transfer from a vector on the global grid to vectors defined on each of the levels separately for the active degrees of freedom In for a globally refined mesh only the finest level in[2.x.0] is filled as a plain copy of[2.x.1] All the other level objects are left untouched **Transfer from multi level vector to normal vector Copies data from active portions of an MGVector into the respective positions of a&lt; tt &gt; Vector&lt; number &gt;&lt;/tt &gt; In order to keep the result constrained degrees of freedom are set to zero **Add a multi level vector to a normal vector Works as the previous but probably not for continuous elements **If this object operates on BlockVector we need to describe how the individual vector components are mapped to the blocks of a vector For for a Stokes we have dim vector components for velocity and pressure</div><div class="ttdef"><b>Definition:</b> <a href="mg__transfer__0_8txt_source.html#l00017">mg_transfer_0.txt:17</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa4924d31df0211f3fb9db3bbe1af0d1c">DataComponentInterpretation::component_is_scalar</a></div><div class="ttdeci">@ component_is_scalar</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__component__interpretation_8h_source.html#l00055">data_component_interpretation.h:55</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 2, dim &gt;</a></div></div>
<div class="ttc" id="anamespaceStep8_html_a8cfe56efd5e932e7421d357e26eab267"><div class="ttname"><a href="namespaceStep8.html#a8cfe56efd5e932e7421d357e26eab267">Step8::right_hand_side</a></div><div class="ttdeci">void right_hand_side(const std::vector&lt; Point&lt; dim &gt;&gt; &amp;points, std::vector&lt; Tensor&lt; 1, dim &gt;&gt; &amp;values)</div><div class="ttdef"><b>Definition:</b> <a href="step-8_8cc_source.html#l00090">step-8.cc:90</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="aA-headers_2fe__0_8txt_html_abbd000c1bb0a029706ba0d8934597f39"><div class="ttname"><a href="A-headers_2fe__0_8txt.html#abbd000c1bb0a029706ba0d8934597f39">velocity</a></div><div class="ttdeci">****All classes related to shape functions and to access to shape functions This concerns the actual values of finite elements For the numbering of degrees of freedom refer to the module on *[2.x.1] The classes and functions of this module fall into several sub groups that are discussed in their respective sub modules listed above In the FETools class provides functions that provide information on finite elements transformations between elements etc *In the grand scheme of the pieces of this module interact with a variety of other parts of the without actually implementing a concrete element For the FiniteElement base class declares the virtual functions a derived class has to implement if it wants to describe a finite element space Likewise the FiniteElementData holds variables that describe certain values characterizing a finite element such as the number of degrees of freedom per vertex line or face *On the other classes like FE_Poly and FE_PolyTensor are higher abstractions They describe finite elements that are built atop polynomial descriptions of the shape functions on the unit cell Classes derived from them then only have to provide a description of the particular polynomial from which a finite element is built For the FE_Q class that implements the usual Lagrange elements uses the FE_Poly base class to generate a finite element by providing it with a set of Lagrange interpolation polynomials corresponding to an equidistant subdivision of interpolation points the FESystem class is used for vector valued problems There one may want to couple a number of for Navier Stokes one may want to use three Q1 elements for the three components of the velocity</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2fe__0_8txt_source.html#l00021">fe_0.txt:21</a></div></div>
<div class="ttc" id="aadvection__0_8txt_html_a79a3cbbb7583dd309bf1b14dc20895b6"><div class="ttname"><a href="advection__0_8txt.html#a79a3cbbb7583dd309bf1b14dc20895b6">cell_matrix</a></div><div class="ttdeci">**its DG formulations All advection operators depend on an advection velocity denoted by[1.x.0] in the formulas below It is denoted as&lt; tt &gt; velocity&lt;/tt &gt; in the parameter lists The functions cell_matrix() and both upwind_value_matrix() are taking the equation in weak form</div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_a8f384576a64c89a6fa8352847523e340"><div class="ttname"><a href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for n_q_points</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00537">fe_evaluation_0.txt:537</a></div></div>
<div class="ttc" id="anamespaceSAND_1_1ValueExtractors_html_a8cd7076dfb3722290a423c54fc25f28d"><div class="ttname"><a href="namespaceSAND_1_1ValueExtractors.html#a8cd7076dfb3722290a423c54fc25f28d">SAND::ValueExtractors::displacements</a></div><div class="ttdeci">const FEValuesExtractors::Vector displacements(SolutionComponents::displacement&lt; dim &gt;)</div></div>
<div class="ttc" id="aclassSymmetricTensor_html_a07b7c41cb9adfb6a07c0e3824cd7cb8b"><div class="ttname"><a href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">SymmetricTensor::double_contract</a></div><div class="ttdeci">constexpr void double_contract(SymmetricTensor&lt; 2, 1, typename ProductType&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const SymmetricTensor&lt; 4, 1, Number &gt; &amp;t, const SymmetricTensor&lt; 2, 1, OtherNumber &gt; &amp;s)</div><div class="ttdef"><b>Definition:</b> <a href="base_2symmetric__tensor_8h_source.html#l03863">symmetric_tensor.h:3863</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00052">solver_control.h:52</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_aaee87206b92ccb284e9c77fa5d847637"><div class="ttname"><a href="vector__valued__0_8txt.html#aaee87206b92ccb284e9c77fa5d847637">velocities</a></div><div class="ttdeci">each of these vectors has[2.x.174] elements containing the values of the[2.x.175] velocities and the one pressure at a quadrature point *We can use these values to then construct other things like residuals the construct is a bit awkward we have a[2.x.176] which always looks strange It is also inefficient because it implies dynamic memory allocation for the outer vector as well as for all the inner vectors maybe we are only interested in the velocities</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00155">vector_valued_0.txt:155</a></div></div>
<div class="ttc" id="aclassFESystem_html"><div class="ttname"><a href="classFESystem.html">FESystem&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassDerivativeForm_html_a3c201452e8dd28e4f5be4a316cb9305f"><div class="ttname"><a href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">DerivativeForm::transpose</a></div><div class="ttdeci">DerivativeForm&lt; 1, spacedim, dim, Number &gt; transpose(const DerivativeForm&lt; 1, dim, spacedim, Number &gt; &amp;DF)</div><div class="ttdef"><b>Definition:</b> <a href="base_2derivative__form_8h_source.html#l00550">derivative_form.h:550</a></div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a02f5aa616d7b0799c538fe77d6c6c795"><div class="ttname"><a href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a></div><div class="ttdeci">i e</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00028">coding_conventions_0.txt:28</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
