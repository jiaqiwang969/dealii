<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridTools Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations This module groups functions and</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceGridTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridTools_1_1Cache.html">Cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1CellDataTransferBuffer.html">CellDataTransferBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridTools_1_1MarchingCubeAlgorithm.html">MarchingCubeAlgorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable.html">OrientationLookupTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_011_01_4.html">OrientationLookupTable&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_012_01_4.html">OrientationLookupTable&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_013_01_4.html">OrientationLookupTable&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a995b90803c22dbe67fc6d510494b2e51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF
<br />
 }</td></tr>
<tr class="separator:a995b90803c22dbe67fc6d510494b2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995b90803c22dbe67fc6d510494b2e51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF
<br />
 }</td></tr>
<tr class="separator:a995b90803c22dbe67fc6d510494b2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995b90803c22dbe67fc6d510494b2e51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1">update_all</a> = 0xFFF
<br />
 }</td></tr>
<tr class="separator:a995b90803c22dbe67fc6d510494b2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae72f0f1401743f54382de4415737484f"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:ae72f0f1401743f54382de4415737484f"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae72f0f1401743f54382de4415737484f">operator&lt;&lt;</a> (StreamType &amp;<a class="el" href="kinsol__0_8txt.html#aef7db8db372670631e9759ab5a3941aa">s</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> u)</td></tr>
<tr class="separator:ae72f0f1401743f54382de4415737484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad16a1564283fb76f8dc55443b0e6ee53">operator~</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1)</td></tr>
<tr class="separator:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3d72a001ae5c9adb7362dca6a9141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0cb3d72a001ae5c9adb7362dca6a9141">operator|=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a0cb3d72a001ae5c9adb7362dca6a9141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5220ca0de1f1ffbfdc02fdcb42cc79c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5220ca0de1f1ffbfdc02fdcb42cc79c6">operator&amp;</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a5220ca0de1f1ffbfdc02fdcb42cc79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc539eba69fd137a13b1e974f70bcd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aefc539eba69fd137a13b1e974f70bcd9">operator&amp;=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:aefc539eba69fd137a13b1e974f70bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03981bc3a24576a6cfbc0a305c723eec"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a03981bc3a24576a6cfbc0a305c723eec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a03981bc3a24576a6cfbc0a305c723eec">laplace_transform</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; *<a class="el" href="step-6_8cc.html#a1db959d9c7cd11fe5ef7c81311b1736d">coefficient</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> solve_for_absolute_positions)</td></tr>
<tr class="separator:a03981bc3a24576a6cfbc0a305c723eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af203f92d771fec1b638c3d032a816592"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af203f92d771fec1b638c3d032a816592"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename ::<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af203f92d771fec1b638c3d032a816592">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>)</td></tr>
<tr class="separator:af203f92d771fec1b638c3d032a816592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memTemplParams" colspan="2">template&lt;typename CellIterator &gt; </td></tr>
<tr class="memitem:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a675fa3d8d6ce094fe29a59991b5d6421">match_periodic_face_pairs</a> (<a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; std::pair&lt; CellIterator, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;pairs1, <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; std::pair&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a>, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;pairs2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; CellIterator &gt;&gt; &amp;matched_pairs, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CellIterator::AccessorType::space_dimension &gt; &amp;offset, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>)</td></tr>
<tr class="separator:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213a31f196cd53ccbcc809e567934442"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a213a31f196cd53ccbcc809e567934442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">collect_periodic_faces</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>)</td></tr>
<tr class="separator:a213a31f196cd53ccbcc809e567934442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132f7057487b35446876f2d84aaaf6df"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a132f7057487b35446876f2d84aaaf6df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a132f7057487b35446876f2d84aaaf6df">orthogonal_equality</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;point1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;point2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;offset, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>)</td></tr>
<tr class="separator:a132f7057487b35446876f2d84aaaf6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a062e05c51d27f3da00f2a1aa37bd3a43">cell_measure&lt; 1 &gt;</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&gt; &amp;all_vertices, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2994e9cd1a025e9fdd7cb411d68ec57">cell_measure&lt; 2 &gt;</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;all_vertices, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275c6633e25410e091b89af0756d4333"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a275c6633e25410e091b89af0756d4333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a275c6633e25410e091b89af0756d4333">cell_measure&lt; 3 &gt;</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;all_vertices, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a275c6633e25410e091b89af0756d4333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ba100e8116931dcf4055f667762c8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a366ba100e8116931dcf4055f667762c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a366ba100e8116931dcf4055f667762c8">rotate</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="transformations__0_8txt.html#af022c44cf59dee0308cae04efe471c60">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a366ba100e8116931dcf4055f667762c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0a5fdacaa512a29dac48ad9b11ac159a">rotate</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="transformations__0_8txt.html#af022c44cf59dee0308cae04efe471c60">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Information about meshes and cells</h2></td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria)</td></tr>
<tr class="separator:acd5ccc543d561cfb086b571d1f7818cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9e8169dc4981e90ba5d2386a87efa042">volume</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;() .<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a> <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;()))</td></tr>
<tr class="separator:a9e8169dc4981e90ba5d2386a87efa042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">minimal_cell_diameter</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;() .<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a> <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;()))</td></tr>
<tr class="separator:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">maximal_cell_diameter</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;() .<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a> <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;()))</td></tr>
<tr class="separator:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">cell_measure</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;all_vertices, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>(&amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a290ae00a4f293af389264a5f8135051a">cell_measure</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;all_vertices, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a290ae00a4f293af389264a5f8135051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0625c2914fc4add7336c3ae9c88beedd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0625c2914fc4add7336c3ae9c88beedd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0625c2914fc4add7336c3ae9c88beedd">affine_cell_approximation</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="tria__description__0_8txt.html#ab9794fed393d30ede16b29457b9275e6">vertices</a>)</td></tr>
<tr class="separator:a0625c2914fc4add7336c3ae9c88beedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b0cf2feadb3374ed24f70d99e6e7740">compute_aspect_ratio_of_cells</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classQuadrature.html">Quadrature</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="shape__info__0_8txt.html#a49b6551d518e3adedf2f7240002097fb">quadrature</a>)</td></tr>
<tr class="separator:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa6477e53e65dfbcaa0b2add902f4350e">compute_maximum_aspect_ratio</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classQuadrature.html">Quadrature</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="shape__info__0_8txt.html#a49b6551d518e3adedf2f7240002097fb">quadrature</a>)</td></tr>
<tr class="separator:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae1ec55abefa31cf001fd29d8d4d993f1">compute_bounding_box</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dabf3b16d026c82b72af584b5bbbfcc"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a6dabf3b16d026c82b72af584b5bbbfcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6dabf3b16d026c82b72af584b5bbbfcc">project_to_object</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Iterator &amp;<a class="el" href="particle__0_8txt.html#aa5453bb7f5639b588c4baf9c9e74a5f1">object</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;trial_point)</td></tr>
<tr class="separator:a6dabf3b16d026c82b72af584b5bbbfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06527a9436669439941b304ac073e85"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af06527a9436669439941b304ac073e85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af06527a9436669439941b304ac073e85">get_coarse_mesh_description</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria)</td></tr>
<tr class="separator:af06527a9436669439941b304ac073e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Rotating, stretching and otherwise transforming meshes</h2></td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Transformation , int spacedim&gt; </td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Transformation &amp;<a class="el" href="mapping__q__generic__0_8txt.html#abf4d10ca4ac7cfbd875bff415a017ffb">transformation</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">shift</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;shift_vector, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a4b953611883979e3f920f800bd855df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">rotate</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="transformations__0_8txt.html#af022c44cf59dee0308cae04efe471c60">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a910bb99ec34eac082da97c08e7dd17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a580cbf329f016024a2e6b9d7eb9eed69">rotate</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="transformations__0_8txt.html#af022c44cf59dee0308cae04efe471c60">angle</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="function__lib__0_8txt.html#a925c199018edf3de4c4751c5b02271cd">axis</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, 3 &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">laplace_transform</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; *<a class="el" href="step-6_8cc.html#a1db959d9c7cd11fe5ef7c81311b1736d">coefficient</a>=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> solve_for_absolute_positions=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1baa65a240caf7a5033f47b07b17f86f">get_all_vertices_at_boundary</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria)</td></tr>
<tr class="separator:a1baa65a240caf7a5033f47b07b17f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> scaling_factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a0967563badadd81f77f62622dd8bc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">distort_random</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> keep_boundary=<a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> seed=boost::random::mt19937::default_seed)</td></tr>
<tr class="separator:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">remove_hanging_nodes</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> isotropic=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> max_iterations=100)</td></tr>
<tr class="separator:a62b77b07123012706fbadf91d8f022b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a40336842aa2faac805746dc10c7c604f">remove_anisotropy</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> max_ratio=1.6180339887, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> max_iterations=5)</td></tr>
<tr class="separator:a40336842aa2faac805746dc10c7c604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">regularize_corner_cells</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> limit_angle_fraction=.75)</td></tr>
<tr class="separator:a3f129213c63c92a6ed84c6f2a906048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Finding cells and vertices of a triangulation</h2></td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">compute_point_locations</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;cache, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a8e8bb9211264d2106758ac4d7184117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;cache, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a5a845642f4d205352931267b58055d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#afe6eff31d194dd4beafc9eb6a22c5e27">distributed_compute_point_locations</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;cache, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;local_points, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;global_bboxes, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10)</td></tr>
<tr class="separator:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">extract_used_vertices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="particle__iterator__0_8txt.html#a8814ad7ef6b3df9a381316a0106e3a09">container</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;() .<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a> <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;()))</td></tr>
<tr class="separator:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="tria__description__0_8txt.html#ab9794fed393d30ede16b29457b9275e6">vertices</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>)</td></tr>
<tr class="separator:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a07919e120e98a6a0139ffe8c9f4a2a8b">find_closest_vertex</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84f7b02080d7740cdb0fe73f3917af36">find_closest_vertex</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a84f7b02080d7740cdb0fe73f3917af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">find_cells_adjacent_to_vertex</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="particle__iterator__0_8txt.html#a8814ad7ef6b3df9a381316a0106e3a09">container</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> vertex_index)</td></tr>
<tr class="separator:addb822f0e3068e48640ecc981ee6c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10)</td></tr>
<tr class="separator:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2272fe8a72156bc2628aa07c5123e"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a9df2272fe8a72156bc2628aa07c5123e"><td class="memTemplItemLeft" align="right" valign="top">MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9df2272fe8a72156bc2628aa07c5123e">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10)</td></tr>
<tr class="separator:a9df2272fe8a72156bc2628aa07c5123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f04de5b8fee18233b4a2dbb81eb64ea"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0f04de5b8fee18233b4a2dbb81eb64ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0f04de5b8fee18233b4a2dbb81eb64ea">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10)</td></tr>
<tr class="separator:a0f04de5b8fee18233b4a2dbb81eb64ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f673ed723568e41c72a3634e4d12db"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a59f673ed723568e41c72a3634e4d12db"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a59f673ed723568e41c72a3634e4d12db">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;cache, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10)</td></tr>
<tr class="separator:a59f673ed723568e41c72a3634e4d12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2881f45ff9aa67db94aeb46437797cf4"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a2881f45ff9aa67db94aeb46437797cf4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2881f45ff9aa67db94aeb46437797cf4">find_active_cell_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; &amp;<a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">vertex_to_cell_map</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;vertex_to_cell_centers, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;cell_hint=typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;used_vertices_rtree=<a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt;{}, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; *relevant_cell_bounding_boxes_rtree=<a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a>)</td></tr>
<tr class="separator:a2881f45ff9aa67db94aeb46437797cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">find_all_active_cells_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;first_cell)</td></tr>
<tr class="separator:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af7daaed7cdd68d2b8f70d2dde1df3061">find_all_active_cells_around_point</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="multithreading__0_8txt.html#a0bfb8de17844b28306aa6934b1d7c696">p</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>=1<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e5380ad5f46c2c11ba134d0a5291d6"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a12e5380ad5f46c2c11ba134d0a5291d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a12e5380ad5f46c2c11ba134d0a5291d6">get_active_child_cells</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::cell_iterator &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#a8e9328f1f25ef75085320c149b93bb42">cell</a>)</td></tr>
<tr class="separator:a12e5380ad5f46c2c11ba134d0a5291d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30ccceb7c9216efc44dd4af561e0bea0">get_active_neighbors</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#a8e9328f1f25ef75085320c149b93bb42">cell</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; &amp;active_neighbors)</td></tr>
<tr class="separator:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">compute_active_cell_halo_layer</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a51acc74a2c56fc9cab517235be235cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a98e89706e7e925b16d42d288c462e9d8">compute_cell_halo_layer_on_level</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::cell_iterator &amp;)&gt; &amp;predicate, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>)</td></tr>
<tr class="separator:a98e89706e7e925b16d42d288c462e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6d0674004143aed7f492a3ae7bcb2e3d">compute_ghost_cell_halo_layer</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>)</td></tr>
<tr class="separator:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a599f59fd9beccda86d7980c30a9b1f6a">compute_active_cell_layer_within_distance</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> layer_thickness)</td></tr>
<tr class="separator:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d10102639460701c67f7e79afc06f"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aa21d10102639460701c67f7e79afc06f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa21d10102639460701c67f7e79afc06f">compute_ghost_cell_layer_within_distance</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> layer_thickness)</td></tr>
<tr class="separator:aa21d10102639460701c67f7e79afc06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt;, <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0374dd9eae73c3c2badaa479e8ba8d55">compute_bounding_box</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08438d4ad901817b7b638ce733fd664d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a08438d4ad901817b7b638ce733fd664d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">compute_mesh_predicate_bounding_box</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> refinement_level=0, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> allow_merge=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> max_boxes=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a08438d4ad901817b7b638ce733fd664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">guess_point_owner</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;global_bboxes, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>)</td></tr>
<tr class="separator:a84063935e67e3a3bb5afadc7b00599ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a327cb9de55959193994a994047592ec9">guess_point_owner</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;covering_rtree, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#af03f5f6ab2a471e8151c1243c39efbbe">points</a>)</td></tr>
<tr class="separator:a327cb9de55959193994a994047592ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">vertex_to_cell_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">vertex_to_cell_centers_directions</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; &amp;vertex_to_cells)</td></tr>
<tr class="separator:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2d9ac4e5783a4c13911c576064b255be">find_closest_vertex_of_cell</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;<a class="el" href="vector__tools__point__value__0_8txt.html#a8e9328f1f25ef75085320c149b93bb42">cell</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="block__sparsity__pattern__0_8txt.html#afb2043cfb8f98c9976576592241ee1ed">position</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="mapping__data__on__the__fly__0_8txt.html#a76818ed30da9d93332946da6eead1e70">mapping</a>=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;() .<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a> <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;()))</td></tr>
<tr class="separator:a2d9ac4e5783a4c13911c576064b255be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="namespacetypes.html#afe941afb42dfe05bb0d4def860881229">types::global_vertex_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#adf1ec4049da3c61cb29eb294199e7e53">compute_local_to_global_vertex_index_map</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;<a class="el" href="data__out__faces__0_8txt.html#ac3a8b3e2b8ec4f742c9f1901d79bc7df">triangulation</a>)</td></tr>
<tr class="separator:adf1ec4049da3c61cb29eb294199e7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aed82bbc9838a9123bf567014ae9990dd">get_longest_direction</a> (typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator <a class="el" href="vector__tools__point__value__0_8txt.html#a8e9328f1f25ef75085320c149b93bb42">cell</a>)</td></tr>
<tr class="separator:aed82bbc9838a9123bf567014ae9990dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with periodic domains</h2></td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality</a> (std::bitset&lt; 3 &gt; &amp;<a class="el" href="face__info__0_8txt.html#a665bad87cdf9aba154e065607f9e469c">orientation</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;face1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;face2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;())</td></tr>
<tr class="separator:ac2a1903382c6cff07b33d456a641f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ace05eb85711971f65123e569fead988c">orthogonal_equality</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;face1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;face2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;())</td></tr>
<tr class="separator:ace05eb85711971f65123e569fead988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee88c4dce5066a41183b5dd70289b9df"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:aee88c4dce5066a41183b5dd70289b9df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id1, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id2, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;())</td></tr>
<tr class="separator:aee88c4dce5066a41183b5dd70289b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab22eef800535f9e85a1723a6a36fd0f6">collect_periodic_faces</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> b_id, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="tensor__product__matrix__0_8txt.html#ac68174f5122a850626f450681ee00fe2">direction</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;<a class="el" href="chunk__sparse__matrix__0_8txt.html#a59317914f0b63e3c2c7c6bd150b8ba3e">matrix</a>=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;())</td></tr>
<tr class="separator:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary and manifold ids</h2></td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> reset_boundary_ids=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5861f4e358367a1e12221a7e6832755f">map_boundary_to_manifold_ids</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;src_boundary_ids, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; &amp;dst_manifold_ids, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a> &gt; &amp;reset_boundary_ids={})</td></tr>
<tr class="separator:ga5861f4e358367a1e12221a7e6832755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga306131b2b48ca10bb9a51e189806193c">copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> compute_face_ids=<a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a>)</td></tr>
<tr class="separator:ga306131b2b48ca10bb9a51e189806193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae8bdd10dc34f9ebb869b30bfaf70ff32">assign_co_dimensional_manifold_indicators</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; &amp;)&gt; &amp;disambiguation_function=[](<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; &amp;manifold_ids) { <a class="el" href="smoothness__estimator__0_8txt.html#a5ae52af4a7adfdcbe761fcec5e287b9d">if</a>(<a class="el" href="particles_2partitioner__0_8txt.html#a1181a6d726887f89e803c051f97a64d9">manifold_ids.size</a>()==1) <a class="el" href="kinsol__0_8txt.html#a6b87a69af173cce696c01b4dba762660">return</a> *<a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">manifold_ids.begin</a>();<a class="el" href="distributed__0_8txt.html#afbef545315e0adf43b132473bc29bf6f">else</a> <a class="el" href="kinsol__0_8txt.html#a6b87a69af173cce696c01b4dba762660">return</a> <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>;}, <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> overwrite_only_flat_manifold_ids=<a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a>)</td></tr>
<tr class="separator:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9565dbf2f8e45fee28e40806870e2c98"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename MeshType &gt; </td></tr>
<tr class="memitem:ga9565dbf2f8e45fee28e40806870e2c98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9565dbf2f8e45fee28e40806870e2c98">exchange_cell_data_to_ghosts</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; std_cxx17::optional&lt; DataType &gt;(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;pack, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> DataType &amp;)&gt; &amp;unpack, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;cell_filter=<a class="el" href="structalways__return.html">always_return</a>&lt; typename MeshType::active_cell_iterator, <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt;{<a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a>})</td></tr>
<tr class="separator:ga9565dbf2f8e45fee28e40806870e2c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf50b74d325f8e814bd03ef7654f880c"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename MeshType &gt; </td></tr>
<tr class="memitem:gaaf50b74d325f8e814bd03ef7654f880c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaf50b74d325f8e814bd03ef7654f880c">exchange_cell_data_to_level_ghosts</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;<a class="el" href="tria__description__0_8txt.html#a9576f61a4c9e93fc0248b9ad250768a1">mesh</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; std_cxx17::optional&lt; DataType &gt;(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::level_cell_iterator &amp;)&gt; &amp;pack, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; void(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::level_cell_iterator &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> DataType &amp;)&gt; &amp;unpack, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::level_cell_iterator &amp;)&gt; &amp;cell_filter=<a class="el" href="structalways__return.html">always_return</a>&lt; typename MeshType::level_cell_iterator, <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt;{ <a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a>})</td></tr>
<tr class="separator:gaaf50b74d325f8e814bd03ef7654f880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe16a0bf926dd422545ce1ccf0834de"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:gaabe16a0bf926dd422545ce1ccf0834de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaabe16a0bf926dd422545ce1ccf0834de">exchange_local_bounding_boxes</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;local_bboxes, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_communicator)</td></tr>
<tr class="separator:gaabe16a0bf926dd422545ce1ccf0834de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc7618edb481adb919ff49abe5b31d6"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:gacbc7618edb481adb919ff49abe5b31d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gacbc7618edb481adb919ff49abe5b31d6">build_global_description_tree</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;local_description, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_communicator)</td></tr>
<tr class="separator:gacbc7618edb481adb919ff49abe5b31d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae36862c413167cf798e4b076dbc991"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga1ae36862c413167cf798e4b076dbc991"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1ae36862c413167cf798e4b076dbc991">collect_coinciding_vertices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;coinciding_vertex_groups, <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;vertex_to_coinciding_vertex_group)</td></tr>
<tr class="separator:ga1ae36862c413167cf798e4b076dbc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6d5b53684824212c789514167fd326"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga7f6d5b53684824212c789514167fd326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt;::<a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7f6d5b53684824212c789514167fd326">compute_vertices_with_ghost_neighbors</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;tria)</td></tr>
<tr class="separator:ga7f6d5b53684824212c789514167fd326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a995b90803c22dbe67fc6d510494b2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b90803c22dbe67fc6d510494b2e51">&#9670;&nbsp;</a></span>CacheUpdateFlags <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">GridTools::CacheUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="classGridTools_1_1Cache.html">Cache</a> class to select what information to update. You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|(CacheUpdateFlags,CacheUpdateFlags)</a></code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00033">33</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a995b90803c22dbe67fc6d510494b2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b90803c22dbe67fc6d510494b2e51">&#9670;&nbsp;</a></span>CacheUpdateFlags <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">GridTools::CacheUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="classGridTools_1_1Cache.html">Cache</a> class to select what information to update.</p>
<p>You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|(CacheUpdateFlags,CacheUpdateFlags)</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2grid_2grid__tools__cache__update__flags_8h_source.html#l00033">33</a> of file <a class="el" href="origin_2grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a995b90803c22dbe67fc6d510494b2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b90803c22dbe67fc6d510494b2e51">&#9670;&nbsp;</a></span>CacheUpdateFlags <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">GridTools::CacheUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="classGridTools_1_1Cache.html">Cache</a> class to select what information to update. You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|(CacheUpdateFlags,CacheUpdateFlags)</a></code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aca59eae3f44c532239b9fbeeac74a097"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51acafed90942b010d3c0cdc04e3708e958"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a101016a63351657e358168f21348abc8"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b45aad863a7c2e1e1ca5ef95a2be2b4"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aed935a3ca61947da7ce76357daa43329"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51afbda891fae242a1191d5e39263a5cc09"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a284a331d078f1e72d1fc0ae8aaeb11cf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a7aee6a3b1007882d0a9ba9ac5657ae07"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a573418a5bf656bb4e7734fe3f6e3f5f4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a1a8581bd3970feae49029b5b12eeb4c1"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2grid_2grid__tools__cache__update__flags_8h_source.html#l00033">33</a> of file <a class="el" href="translator_2grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd5ccc543d561cfb086b571d1f7818cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5ccc543d561cfb086b571d1f7818cb">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of a triangulation. The diameter is computed using only the vertices, i.e. if the diameter should be larger than the maximal distance between boundary vertices due to a higher order mapping, then this function will not catch this. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00081">81</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9e8169dc4981e90ba5d2386a87efa042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8169dc4981e90ba5d2386a87efa042">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a>&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the volume (i.e. the dim-dimensional measure) of the triangulation. We compute the measure using the integral \(\sum_K \int_K 1 \; dx\) where \(K\) are the cells of the given triangulation. The integral is approximated via quadrature for which we need the mapping argument. If the triangulation is a dim-dimensional one embedded in a higher dimensional space of dimension spacedim, then the value returned is the dim-dimensional measure. For example, for a two-dimensional triangulation in three-dimensional space, the value returned is the area of the surface so described. (This obviously makes sense since the spacedim-dimensional measure of a dim-dimensional triangulation would always be zero if dim &lt; spacedim. This function also works for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, in which case the function is a collective operation.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation.</td></tr>
    <tr><td class="paramname">mapping</td><td>An optional argument used to denote the mapping that should be used when describing whether cells are bounded by straight or curved faces. The default is to use a \(Q_1\) mapping, which corresponds to straight lines bounding the cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dim-dimensional measure of the domain described by the triangulation, as discussed above.</dd></dl>
<p>Compute the volume (i.e. the dim-dimensional measure) of the triangulation. We compute the measure using the integral \(\sum_K \int_K 1 \; dx\) where \(K\) are the cells of the given triangulation. The integral is approximated via quadrature for which we need the mapping argument.</p>
<p>If the triangulation is a dim-dimensional one embedded in a higher dimensional space of dimension spacedim, then the value returned is the dim-dimensional measure. For example, for a two-dimensional triangulation in three-dimensional space, the value returned is the area of the surface so described. (This obviously makes sense since the spacedim-dimensional measure of a dim-dimensional triangulation would always be zero if dim &lt; spacedim.</p>
<p>This function also works for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, in which case the function is a collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation. </td></tr>
    <tr><td class="paramname">mapping</td><td>An optional argument used to denote the mapping that should be used when describing whether cells are bounded by straight or curved faces. The default is to use a \(Q_1\) mapping, which corresponds to straight lines bounding the cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dim-dimensional measure of the domain described by the triangulation, as discussed above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00137">137</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a47c293eff2ec7ce4b90ba08b35d1f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c293eff2ec7ce4b90ba08b35d1f2e2">&#9670;&nbsp;</a></span>minimal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::minimal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a>&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the diameter of the smallest active cell of a triangulation. See <a class="el" href="step_24.html">step-24</a> for an example of use of this function. Notice that, even if you pass a non-trivial mapping, the returned value is computed only using information on the vertices of the triangulation, possibly transformed by the mapping. While this is accurate most of the times, it may fail to give the correct result when the triangulation contains very distorted cells. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04309">4309</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae8409fa9cb46a0070abc4da7de0f47f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8409fa9cb46a0070abc4da7de0f47f2">&#9670;&nbsp;</a></span>maximal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::maximal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a>&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the diameter of the largest active cell of a triangulation. Notice that, even if you pass a non-trivial mapping to this function, the returned value is computed only using information on the vertices of the triangulation, possibly transformed by the mapping. While this is accurate most of the times, it may fail to give the correct result when the triangulation contains very distorted cells. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04336">4336</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a33fcabb522b0dc88c2959a1712e90fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fcabb522b0dc88c2959a1712e90fc1">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>vertex_indices</em>[GeometryInfo&lt; dim &gt;::vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code> , but this function also works for cells that do not exist except that you make it up by naming its vertices from the list. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use the more general function which takes an <a class="el" href="classArrayView.html">ArrayView</a> instead.</dd></dl>
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000135">Deprecated:</a></b></dt><dd>Use the more general function which takes an <a class="el" href="classArrayView.html">ArrayView</a> instead. </dd></dl>
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code> , but this function also works for cells that do not exist except that you make it up by naming its vertices from the list. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000232">Deprecated:</a></b></dt><dd>Use the more general function which takes an <a class="el" href="classArrayView.html">ArrayView</a> instead.</dd></dl>

</div>
</div>
<a id="a290ae00a4f293af389264a5f8135051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ae00a4f293af389264a5f8135051a">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices()</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code> , but this function also works for cells that do not exist except that you make it up by naming its vertices from the list. The parameter <code>vertex_indices</code> is expected to have <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a> entries. A std::vector is implicitly convertible to an <a class="el" href="classArrayView.html">ArrayView</a>, so it can be passed directly. See the <a class="el" href="classArrayView.html">ArrayView</a> class for more information. </p><dl class="section note"><dt>Note</dt><dd>This function is only implemented for codimension zero objects.</dd></dl>
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices()</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list.</p>
<p>The parameter <code>vertex_indices</code> is expected to have <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a> entries. A std::vector is implicitly convertible to an <a class="el" href="classArrayView.html">ArrayView</a>, so it can be passed directly. See the <a class="el" href="classArrayView.html">ArrayView</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only implemented for codimension zero objects. </dd></dl>

</div>
</div>
<a id="a0625c2914fc4add7336c3ae9c88beedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0625c2914fc4add7336c3ae9c88beedd">&#9670;&nbsp;</a></span>affine_cell_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; GridTools::affine_cell_approximation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes an affine approximation of the map from the unit coordinates to the real coordinates of the form \(p_\text{real} = A p_\text{unit} + b \) by a least squares fit of this affine function to the \(2^\text{dim}\) vertices representing a quadrilateral or hexahedral cell in <code>spacedim</code> dimensions. The result is returned as a pair with the matrix <em>A</em> as the first argument and the vector <em>b</em> describing distance of the plane to the origin. For any valid mesh cell whose geometry is not degenerate, this operation results in a unique affine mapping, even in cases where the actual transformation by a bi-/trilinear or higher order mapping might be singular. The result is exact in case the transformation from the unit to the real cell is indeed affine, such as in one dimension or for Cartesian and affine (parallelogram) meshes in 2D/3D. This approximation is underlying the function <a class="el" href="classTriaAccessor.html#a3eb24d5074a9a7bf216bd82f5d0dc618">TriaAccessor::real_to_unit_cell_affine_approximation()</a> function. For exact transformations to the unit cell, use <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00288">288</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9b0cf2feadb3374ed24f70d99e6e7740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0cf2feadb3374ed24f70d99e6e7740">&#9670;&nbsp;</a></span>compute_aspect_ratio_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; GridTools::compute_aspect_ratio_of_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classQuadrature.html">Quadrature</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes an aspect ratio measure for all locally-owned active cells and fills a vector with one entry per cell, given a <code>triangulation</code> and <code>mapping</code>. The size of the vector that is returned equals the number of active cells. The vector contains zero for non locally-owned cells. The aspect ratio of a cell is defined as the ratio of the maximum to minimum singular value of the Jacobian, taking the maximum over all quadrature points of a quadrature rule specified via <code>quadrature</code>. For example, for the special case of rectangular elements in 2d with dimensions \(a\) and \(b\) ( \(a \geq b\) ), this function returns the usual aspect ratio definition \(a/b\) . The above definition using singular values is a generalization to arbitrarily deformed elements. This function is intended to be used for \(d=2,3\) space dimensions, but it can also be used for \(d=1\) returning a value of 1. </p><dl class="section note"><dt>Note</dt><dd>Inverted elements do not throw an exception. Instead, a value of inf is written into the vector in case of inverted elements. </dd>
<dd>
Make sure to use enough quadrature points for a precise calculation of the aspect ratio in case of deformed elements. </dd>
<dd>
In parallel computations the return value will have the length n_active_cells but the aspect ratio is only computed for the cells that are locally owned and placed at index <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a>, respectively. All other values are set to 0.</dd></dl>
<p>Computes an aspect ratio measure for all locally-owned active cells and fills a vector with one entry per cell, given a <code>triangulation</code> and <code>mapping</code>. The size of the vector that is returned equals the number of active cells. The vector contains zero for non locally-owned cells. The aspect ratio of a cell is defined as the ratio of the maximum to minimum singular value of the Jacobian, taking the maximum over all quadrature points of a quadrature rule specified via <code>quadrature</code>. For example, for the special case of rectangular elements in 2d with dimensions \(a\) and \(b\) ( \(a \geq b\)), this function returns the usual aspect ratio definition \(a/b\). The above definition using singular values is a generalization to arbitrarily deformed elements. This function is intended to be used for \(d=2,3\) space dimensions, but it can also be used for \(d=1\) returning a value of 1.</p>
<dl class="section note"><dt>Note</dt><dd>Inverted elements do not throw an exception. Instead, a value of inf is written into the vector in case of inverted elements.</dd>
<dd>
Make sure to use enough quadrature points for a precise calculation of the aspect ratio in case of deformed elements.</dd>
<dd>
In parallel computations the return value will have the length n_active_cells but the aspect ratio is only computed for the cells that are locally owned and placed at index <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a>, respectively. All other values are set to 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00312">312</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa6477e53e65dfbcaa0b2add902f4350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6477e53e65dfbcaa0b2add902f4350e">&#9670;&nbsp;</a></span>compute_maximum_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> GridTools::compute_maximum_aspect_ratio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classQuadrature.html">Quadrature</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the maximum aspect ratio by taking the maximum over all cells. </p><dl class="section note"><dt>Note</dt><dd>When running in parallel with a <a class="el" href="classTriangulation.html">Triangulation</a> that supports MPI, this is a collective call and the return value is the maximum over all processors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00378">378</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae1ec55abefa31cf001fd29d8d4d993f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ec55abefa31cf001fd29d8d4d993f1">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the smallest box containing the entire triangulation. If the input triangulation is a <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code>, then each processor will compute a bounding box enclosing all locally owned, ghost, and artificial cells. In the case of a domain without curved boundaries, these bounding boxes will all agree between processors because the union of the areas occupied by artificial and ghost cells equals the union of the areas occupied by the cells that other processors own. However, if the domain has curved boundaries, this is no longer the case. The bounding box returned may be appropriate for the current processor, but different from the bounding boxes computed on other processors. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00394">394</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a6dabf3b16d026c82b72af584b5bbbfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dabf3b16d026c82b72af584b5bbbfcc">&#9670;&nbsp;</a></span>project_to_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; GridTools::project_to_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>trial_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the point on the geometrical object <code>object</code> closest to the given point <code>trial_point</code>. For example, if <code>object</code> is a one-dimensional line or edge, then the returned point will be a point on the geodesic that connects the vertices as the manifold associated with the object sees it (i.e., the geometric line may be curved if it lives in a higher dimensional space). If the iterator points to a quadrilateral in a higher dimensional space, then the returned point lies within the convex hull of the vertices of the quad as seen by the associated manifold. </p><dl class="section note"><dt>Note</dt><dd>This projection is usually not well-posed since there may be multiple points on the object that minimize the distance. The algorithm used in this function is robust (and the output is guaranteed to be on the given <code>object</code>) but may only provide a few correct digits if the object has high curvature. If your manifold supports it then the specialized function <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold::project_to_manifold()</a> may perform better. </dd></dl>

</div>
</div>
<a id="af06527a9436669439941b304ac073e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06527a9436669439941b304ac073e85">&#9670;&nbsp;</a></span>get_coarse_mesh_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt;, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a> &gt; GridTools::get_coarse_mesh_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the arrays that define the coarse mesh of a <a class="el" href="classTriangulation.html">Triangulation</a>. This function is the inverse of <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a>. The return value is a tuple with the vector of vertices, the vector of cells, and a <a class="el" href="structSubCellData.html">SubCellData</a> structure. The latter contains additional information about faces and lines. This function is useful in cases where one needs to deconstruct a <a class="el" href="classTriangulation.html">Triangulation</a> or manipulate the numbering of the vertices in some way: an example is <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00534">534</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa502b615730af32271d9da4206939a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa502b615730af32271d9da4206939a81">&#9670;&nbsp;</a></span>delete_unused_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_unused_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are not referenced by any of the cells. This function is called by all <code>GridIn::read_*</code> functions to eliminate vertices that are listed in the input files but are not used by the cells in the input file. While these vertices should not be in the input from the beginning, they sometimes are, most often when some cells have been removed by hand without wanting to update the vertex lists, as they might be lengthy. This function is called by all <code>GridIn::read_*</code> functions as the triangulation class requires them to be called with used vertices only. This is so, since the vertices are copied verbatim by that class, so we have to eliminate unused vertices beforehand. Not implemented for the codimension one case. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00626">626</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2fb09f2e9812f04661f9ca79e598e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb09f2e9812f04661f9ca79e598e197">&#9670;&nbsp;</a></span>delete_duplicated_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_duplicated_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>considered_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are duplicated, due to the input of a structured grid, for example. If these vertices are not removed, the faces bounded by these vertices become part of the boundary, even if they are in the interior of the mesh. This function is called by some <code>GridIn::read_*</code> functions. Only the vertices with indices in <code>considered_vertices</code> are tested for equality. This speeds up the algorithm, which is, for worst-case hyper cube geometries \(O(N^{3/2})\) in 2D and \(O(N^{5/3})\) in 3D: quite slow. However, if you wish to consider all vertices, simply pass an empty vector. In that case, the function fills <code>considered_vertices</code> with all vertices. Two vertices are considered equal if their difference in each coordinate direction is less than <code>tol</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00731">731</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a26e0f86b3a9310f1952cfe29e1fe7bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e0f86b3a9310f1952cfe29e1fe7bd4">&#9670;&nbsp;</a></span>invert_all_negative_measure_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::invert_all_negative_measure_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Grids generated by grid generators may have an orientation of cells which is the inverse of the orientation required by deal.II. In 2d and 3d this function checks whether all cells have negative or positive measure/volume. In the former case, all cells are inverted. It does nothing in 1d. The inversion of cells might also work when only a subset of all cells have negative volume. However, grids consisting of a mixture of negative and positively oriented cells are very likely to be broken. Therefore, an exception is thrown, in case cells are not uniformly oriented. </p><dl class="section note"><dt>Note</dt><dd>This function should be called before <a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">GridTools::consistently_order_cells()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_vertices</td><td>The vertices of the mesh.</td></tr>
    <tr><td class="paramname">cells</td><td>The array of <a class="el" href="structCellData.html">CellData</a> objects that describe the mesh's topology.</td></tr>
  </table>
  </dd>
</dl>
<p>Grids generated by grid generators may have an orientation of cells which is the inverse of the orientation required by deal.II.</p>
<p>In 2d and 3d this function checks whether all cells have negative or positive measure/volume. In the former case, all cells are inverted. It does nothing in 1d.</p>
<p>The inversion of cells might also work when only a subset of all cells have negative volume. However, grids consisting of a mixture of negative and positively oriented cells are very likely to be broken. Therefore, an exception is thrown, in case cells are not uniformly oriented.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called before <a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">GridTools::consistently_order_cells()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_vertices</td><td>The vertices of the mesh. </td></tr>
    <tr><td class="paramname">cells</td><td>The array of <a class="el" href="structCellData.html">CellData</a> objects that describe the mesh's topology. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00863">863</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8d5f04ca06ef2667c468296f538716e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f04ca06ef2667c468296f538716e7">&#9670;&nbsp;</a></span>consistently_order_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::consistently_order_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structCellData.html">CellData</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of <a class="el" href="structCellData.html">CellData</a> objects describing a mesh, reorder their vertices so that all lines are consistently oriented. The expectations on orientation and a discussion of this function are available in the <a class="el" href="group__reordering.html">reordering module</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cells</td><td>The array of <a class="el" href="structCellData.html">CellData</a> objects that describe the mesh's topology. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01921">1921</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a212e99cf0d923cebfa04f1d23fa60b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e99cf0d923cebfa04f1d23fa60b04">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Transformation , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Transformation &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the vertices of the given triangulation by applying the function object provided as first argument to all its vertices. The transformation given as argument is used to transform each vertex. Its respective type has to offer a function-like syntax, i.e. the predicate is either an object of a type that has an <code><a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">operator()</a></code>, or it is a pointer to the function. In either case, argument and return value have to be of type <code><a class="el" href="classPoint.html">Point</a> &lt;spacedim&gt;</code>. </p><dl class="section note"><dt>Note</dt><dd>The transformations that make sense to use with this function should have a Jacobian with a positive determinant. For example, rotation, shearing, stretching, or scaling all satisfy this (though there is no requirement that the transformation used actually is linear, as all of these examples are). On the other hand, reflections or inversions have a negative determinant of the Jacobian. The current function has no way of asserting a positive determinant of the Jacobian, but if you happen to use such a transformation, the result will be a triangulation in which cells have a negative volume. </dd>
<dd>
If you are using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you will have hanging nodes in your local <a class="el" href="classTriangulation.html">Triangulation</a> even if your "global" mesh has no hanging nodes. This will cause issues with wrong positioning of hanging nodes in ghost cells if you call the current functions: The vertices of all locally owned cells will be correct, but the vertices of some ghost cells may not. This means that computations like <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> may give wrong answers. </dd>
<dd>
This function is in general not compatible with manifolds attached to the triangulation. For example, in order to refine the grid (using manifolds) after the grid transformation, you have to make sure that the original manifold is still valid for the transformed geometry. This does not hold in general, and it is necessary to clear the manifold and attach a new one for the transformed geometry in these cases. If you want to perform refinements according to the original manifold description attached to the triangulation, you should first do the refinements, subsequently deactivate all manifolds, and finally call the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function. The result is a triangulation with correctly transformed vertices, but otherwise straight-sided elements. The following procedure is recommended <div class="fragment"><div class="line">...</div>
<div class="line">triangulation.refine_global(n_refinements);</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.reset_all_manifolds();</div>
<div class="line">Transformation&lt;dim&gt; <a class="code" href="mapping__fe__0_8txt.html#a03f4bc472ac44f06faa3d699da9af068">transformation</a>;</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(<a class="code" href="mapping__fe__0_8txt.html#a03f4bc472ac44f06faa3d699da9af068">transformation</a>, <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line">...</div>
</div><!-- fragment --> This function is used in the "Possibilities for extensions" section of <a class="el" href="step_38.html">step-38</a> . It is also used in <a class="el" href="step_49.html">step-49</a> and <a class="el" href="step_53.html">step-53</a> .</dd></dl>
<p>Transform the vertices of the given triangulation by applying the function object provided as first argument to all its vertices.</p>
<p>The transformation given as argument is used to transform each vertex. Its respective type has to offer a function-like syntax, i.e. the predicate is either an object of a type that has an <code><a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">operator()</a></code>, or it is a pointer to the function. In either case, argument and return value have to be of type <code><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The transformations that make sense to use with this function should have a Jacobian with a positive determinant. For example, rotation, shearing, stretching, or scaling all satisfy this (though there is no requirement that the transformation used actually is linear, as all of these examples are). On the other hand, reflections or inversions have a negative determinant of the Jacobian. The current function has no way of asserting a positive determinant of the Jacobian, but if you happen to use such a transformation, the result will be a triangulation in which cells have a negative volume.</dd>
<dd>
If you are using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you will have hanging nodes in your local <a class="el" href="classTriangulation.html">Triangulation</a> even if your "global" mesh has no hanging nodes. This will cause issues with wrong positioning of hanging nodes in ghost cells if you call the current functions: The vertices of all locally owned cells will be correct, but the vertices of some ghost cells may not. This means that computations like <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> may give wrong answers.</dd>
<dd>
This function is in general not compatible with manifolds attached to the triangulation. For example, in order to refine the grid (using manifolds) after the grid transformation, you have to make sure that the original manifold is still valid for the transformed geometry. This does not hold in general, and it is necessary to clear the manifold and attach a new one for the transformed geometry in these cases. If you want to perform refinements according to the original manifold description attached to the triangulation, you should first do the refinements, subsequently deactivate all manifolds, and finally call the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function. The result is a triangulation with correctly transformed vertices, but otherwise straight-sided elements. The following procedure is recommended <div class="fragment"><div class="line">...</div>
<div class="line">triangulation.refine_global(n_refinements);</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.reset_all_manifolds();</div>
<div class="line">Transformation&lt;dim&gt; <a class="code" href="mapping__fe__0_8txt.html#a03f4bc472ac44f06faa3d699da9af068">transformation</a>;</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(<a class="code" href="mapping__fe__0_8txt.html#a03f4bc472ac44f06faa3d699da9af068">transformation</a>, <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line">...</div>
</div><!-- fragment --></dd></dl>
<p>This function is used in the "Possibilities for extensions" section of <a class="el" href="step_38.html">step-38</a>. It is also used in <a class="el" href="step_49.html">step-49</a> and <a class="el" href="step_53.html">step-53</a>. </p>

</div>
</div>
<a id="a4b953611883979e3f920f800bd855df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b953611883979e3f920f800bd855df3">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift each vertex of the triangulation by the given shift vector. This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02022">2022</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a910bb99ec34eac082da97c08e7dd17c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910bb99ec34eac082da97c08e7dd17c3">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given two-dimensional triangulation in counter-clockwise sense around the origin of the coordinate system by the given angle (given in radians, rather than degrees). This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p><dl class="section note"><dt>Note</dt><dd>This function is only supported for dim=2. </dd></dl>

</div>
</div>
<a id="a580cbf329f016024a2e6b9d7eb9eed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580cbf329f016024a2e6b9d7eb9eed69">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given <code>triangulation</code> in counter-clockwise direction around the axis with the given index. Otherwise like the function above.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>Angle in radians to rotate the <a class="el" href="classTriangulation.html">Triangulation</a> by.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Index of the coordinate axis to rotate around, keeping that coordinate fixed (0=x axis, 1=y axis, 2=z axis).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object to rotate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for dim=1, 2, and 3.</dd></dl>
<p>Rotate all vertices of the given <code>triangulation</code> in counter-clockwise direction around the axis with the given index. Otherwise like the function above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>Angle in radians to rotate the <a class="el" href="classTriangulation.html">Triangulation</a> by. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Index of the coordinate axis to rotate around, keeping that coordinate fixed (0=x axis, 1=y axis, 2=z axis). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object to rotate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for dim=1, 2, and 3. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02031">2031</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">&#9670;&nbsp;</a></span>laplace_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em> = <code><a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given triangulation smoothly to a different domain where, typically, each of the vertices at the boundary of the triangulation is mapped to the corresponding points in the <code>new_points</code> map. The unknown displacement field \(u_d(\mathbf x)\) in direction \(d\) is obtained from the minimization problem </p><p class="formulaDsp">
\[ \min\, \int \frac{1}{2} c(\mathbf x) \mathbf \nabla u_d(\mathbf x) \cdot \mathbf \nabla u_d(\mathbf x) \,\rm d x \]
</p>
<p> subject to prescribed constraints. The minimizer is obtained by solving the Laplace equation of the dim components of a displacement field that maps the current domain into one described by <code>new_points</code> . Linear finite elements with four Gaussian quadrature points in each direction are used. The difference between the vertex positions specified in <code>new_points</code> and their current value in <code>tria</code> therefore represents the prescribed values of this displacement field at the boundary of the domain, or more precisely at all of those locations for which <code>new_points</code> provides values (which may be at part of the boundary, or even in the interior of the domain). The function then evaluates this displacement field at each unconstrained vertex and uses it to place the mapped vertex where the displacement field locates it. Because the solution of the Laplace equation is smooth, this guarantees a smooth mapping from the old domain to the new one.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>The locations where a subset of the existing vertices are to be placed. Typically, this would be a map from the vertex indices of all nodes on the boundary to their new locations, thus completely specifying the geometry of the mapped domain. However, it may also include interior points if necessary and it does not need to include all boundary vertices (although you then lose control over the exact shape of the mapped domain).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. This object is changed in- place, i.e., the previous locations of vertices are overwritten.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>An optional coefficient for the Laplace problem. Larger values make cells less prone to deformation (effectively increasing their stiffness). The coefficient is evaluated in the coordinate system of the old, undeformed configuration of the triangulation as input, i.e., before the transformation is applied. Should this function be provided, sensible results can only be expected if all coefficients are positive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solve_for_absolute_positions</td><td>If set to <code>true</code> , the minimization problem is formulated with respect to the final vertex positions as opposed to their displacement. The two formulations are equivalent for the homogeneous problem (default value of <code>coefficient</code>), but they result in very different mesh motion otherwise. Since in most cases one will be using a non-constant coefficient in displacement formulation, the default value of this parameter is <code>false</code> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not currently implemented for the 1d case.</dd></dl>
<p>Transform the given triangulation smoothly to a different domain where, typically, each of the vertices at the boundary of the triangulation is mapped to the corresponding points in the <code>new_points</code> map.</p>
<p>The unknown displacement field \(u_d(\mathbf x)\) in direction \(d\) is obtained from the minimization problem </p><p class="formulaDsp">
\[ \min\, \int \frac{1}{2} c(\mathbf x) \mathbf \nabla u_d(\mathbf x) \cdot \mathbf \nabla u_d(\mathbf x) \,\rm d x \]
</p>
<p> subject to prescribed constraints. The minimizer is obtained by solving the Laplace equation of the dim components of a displacement field that maps the current domain into one described by <code>new_points</code> . Linear finite elements with four Gaussian quadrature points in each direction are used. The difference between the vertex positions specified in <code>new_points</code> and their current value in <code>tria</code> therefore represents the prescribed values of this displacement field at the boundary of the domain, or more precisely at all of those locations for which <code>new_points</code> provides values (which may be at part of the boundary, or even in the interior of the domain). The function then evaluates this displacement field at each unconstrained vertex and uses it to place the mapped vertex where the displacement field locates it. Because the solution of the Laplace equation is smooth, this guarantees a smooth mapping from the old domain to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>The locations where a subset of the existing vertices are to be placed. Typically, this would be a map from the vertex indices of all nodes on the boundary to their new locations, thus completely specifying the geometry of the mapped domain. However, it may also include interior points if necessary and it does not need to include all boundary vertices (although you then lose control over the exact shape of the mapped domain).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. This object is changed in- place, i.e., the previous locations of vertices are overwritten.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>An optional coefficient for the Laplace problem. Larger values make cells less prone to deformation (effectively increasing their stiffness). The coefficient is evaluated in the coordinate system of the old, undeformed configuration of the triangulation as input, i.e., before the transformation is applied. Should this function be provided, sensible results can only be expected if all coefficients are positive.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solve_for_absolute_positions</td><td>If set to <code>true</code>, the minimization problem is formulated with respect to the final vertex positions as opposed to their displacement. The two formulations are equivalent for the homogeneous problem (default value of <code>coefficient</code>), but they result in very different mesh motion otherwise. Since in most cases one will be using a non-constant coefficient in displacement formulation, the default value of this parameter is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not currently implemented for the 1d case. </dd></dl>

</div>
</div>
<a id="a1baa65a240caf7a5033f47b07b17f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baa65a240caf7a5033f47b07b17f86f">&#9670;&nbsp;</a></span>get_all_vertices_at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; GridTools::get_all_vertices_at_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a std::map with all vertices of faces located in the boundary </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02185">2185</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a0967563badadd81f77f62622dd8bc2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0967563badadd81f77f62622dd8bc2cd">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire triangulation by the given factor. To preserve the orientation of the triangulation, the factor must be positive. This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02042">2042</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac4e8aecd2cf74d3476e0daa11a00248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8aecd2cf74d3476e0daa11a00248b">&#9670;&nbsp;</a></span>distort_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::distort_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code><a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code>boost::random::mt19937::default_seed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distort the given triangulation by randomly moving around all the vertices of the grid. The direction of movement of each vertex is random, while the length of the shift vector has a value of <code>factor</code> times the minimal length of the active edges adjacent to this vertex. Note that <code>factor</code> should obviously be well below <code>0.5</code>. If <code>keep_boundary</code> is set to <code>true</code> (which is the default), then boundary vertices are not moved. <code>seed</code> is used for the initialization of the random engine. Its default value initializes the engine with the same state as in previous versions of deal.II.</p>
<p>Distort a triangulation in some random way. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02217">2217</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a62b77b07123012706fbadf91d8f022b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b77b07123012706fbadf91d8f022b3">&#9670;&nbsp;</a></span>remove_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_hanging_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove hanging nodes from a grid. If the <code>isotropic</code> parameter is set to <code>false</code> (default) this function detects cells with hanging nodes and refines the neighbours in the direction that removes hanging nodes. If the <code>isotropic</code> parameter is set to <code>true</code>, the neighbours refinement is made in each directions. In order to remove all hanging nodes this procedure has to be repeated: this could require a large number of iterations. To avoid this a max number ( <code>max_iterations</code>) of iteration is provided. Consider the following grid: </p><div class="image">
<img src="remove_hanging_nodes-hanging.png" alt=""/>
<div class="caption">
<code>isotropic</code> == <code>false</code> would return: <div class="image">
<img src="remove_hanging_nodes-aniso.png" alt=""/>
<div class="caption">
<code>isotropic</code> == <code>true</code> would return: <div class="image">
<img src="remove_hanging_nodes-isotro.png" alt=""/>
<div class="caption">
@param [in,out] tria Triangulation to refine.@param [in] isotropic If true refine cells in each directions, otherwise (default value) refine the cell in the direction that removes hanging node.@param [in] max_iterations At each step only closest cells to hanging nodes are refined. The code may require a lot of iterations to remove all hanging nodes. <code>max_iterations</code> is the maximum number of iteration allowed. If <code>max_iterations</code> == numbers::invalid_unsigned_int this function continues refining until there are no hanging nodes.</div></div>
 @note In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a>. Remove hanging nodes from a grid. If the <code>isotropic</code> parameter is set to <code>false</code> (default) this function detects cells with hanging nodes and refines the neighbours in the direction that removes hanging nodes. If the <code>isotropic</code> parameter is set to <code>true</code>, the neighbours refinement is made in each directions. In order to remove all hanging nodes this procedure has to be repeated: this could require a large number of iterations. To avoid this a max number (<code>max_iterations</code>) of iteration is provided. Consider the following grid: <div class="image">
<img src="remove_hanging_nodes-hanging.png" alt=""/>
</div>
 <code>isotropic</code> == <code>false</code> would return: <div class="image">
<img src="remove_hanging_nodes-aniso.png" alt=""/>
</div>
 <code>isotropic</code> == <code>true</code> would return: <div class="image">
<img src="remove_hanging_nodes-isotro.png" alt=""/>
</div>
 @param tria <a class="el" href="classTriangulation.html">Triangulation</a> to refine. @param isotropic If true refine cells in each directions, otherwise (default value) refine the cell in the direction that removes hanging node. @param max_iterations At each step only closest cells to hanging nodes are refined. The code may require a lot of iterations to remove all hanging nodes. <code>max_iterations</code> is the maximum number of iteration allowed. If <code>max_iterations</code> == <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> this function continues refining until there are no hanging nodes. @note In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a>. </div></div>
</div></div>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05084">5084</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a40336842aa2faac805746dc10c7c604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40336842aa2faac805746dc10c7c604f">&#9670;&nbsp;</a></span>remove_anisotropy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_anisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>max_ratio</em> = <code>1.6180339887</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a mesh anisotropically such that the resulting mesh is composed by cells with maximum ratio between dimensions less than <code>max_ratio</code>. This procedure requires an algorithm that may not terminate. Consequently, it is possible to set a maximum number of iterations through the <code>max_iterations</code> parameter. Starting from a cell like this: </p><div class="image">
<img src="remove_anisotropy-coarse.png" alt=""/>
<div class="caption">
This function would return: <div class="image">
<img src="remove_anisotropy-refined.png" alt=""/>
<div class="caption">
@param [in,out] tria Triangulation to refine.@param [in] max_ratio Maximum value allowed among the ratio between the dimensions of each cell.@param [in] max_iterations Maximum number of iterations allowed.</div></div>
 @note In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a> and <a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">GridTools::remove_hanging_nodes</a>. Refine a mesh anisotropically such that the resulting mesh is composed by cells with maximum ratio between dimensions less than <code>max_ratio</code>. This procedure requires an algorithm that may not terminate. Consequently, it is possible to set a maximum number of iterations through the <code>max_iterations</code> parameter. Starting from a cell like this: <div class="image">
<img src="remove_anisotropy-coarse.png" alt=""/>
</div>
 This function would return: <div class="image">
<img src="remove_anisotropy-refined.png" alt=""/>
</div>
 @param tria <a class="el" href="classTriangulation.html">Triangulation</a> to refine. @param max_ratio Maximum value allowed among the ratio between the dimensions of each cell. @param max_iterations Maximum number of iterations allowed. @note In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a> and <a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">GridTools::remove_hanging_nodes</a>. </div></div>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05117">5117</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3f129213c63c92a6ed84c6f2a906048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f129213c63c92a6ed84c6f2a906048b">&#9670;&nbsp;</a></span>regularize_corner_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::regularize_corner_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>limit_angle_fraction</em> = <code>.75</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p align="center">Analyze the boundary cells of a mesh, and if one cell is found at a corner position (with dim adjacent faces on the boundary), and its dim-dimensional angle fraction exceeds <code>limit_angle_fraction</code>, refine globally once, and replace the children of such cell with children where the corner is no longer offending the given angle fraction. If no boundary cells exist with two adjacent faces on the boundary, then the triangulation is left untouched. If instead we do have cells with dim adjacent faces on the boundary, then the fraction between the dim-dimensional solid angle and dim*pi/2 is checked against the parameter <code>limit_angle_fraction</code>. If it is higher, the grid is refined once, and the children of the offending cell are replaced with some cells that instead respect the limit. After this process the triangulation is flattened, and all <a class="el" href="classManifold.html">Manifold</a> objects are restored as they were in the original triangulation. An example is given by the following mesh, obtained by attaching a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to a mesh generated using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div>
</div><!-- fragment --> <div class="image">
<img src="regularize_mesh_01.png" alt=""/>
</div>
 <p align="center">The four cells that were originally the corners of a square will give you some troubles during computations, as the jacobian of the transformation from the reference cell to those cells will go to zero, affecting the error constants of the finite element estimates. Those cells have a corner with an angle that is very close to 180 degrees, i.e., an angle fraction very close to one. The same code, adding a call to regularize_corner_cells: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
</div><!-- fragment --><p> generates a mesh that has a much better behavior w.r.t. the jacobian of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a>: </p>
<div class="image">
<img src="regularize_mesh_02.png" alt=""/>
</div>
 <p align="center">This mesh is very similar to the one obtained by <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>. However, using <a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a> one has the freedom to choose when to apply the regularization, i.e., one could in principle first refine a few times, and then call the regularize_corner_cells function: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div>
</div><!-- fragment --><p> This generates the following mesh: </p>
<div class="image">
<img src="regularize_mesh_03.png" alt=""/>
</div>
 <p>The function is currently implemented only for dim = 2 and will throw an exception if called with dim = 3.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to regularize.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_angle_fraction</td><td>Maximum ratio of angle or solid angle that is allowed for a corner element in the mesh.</td></tr>
  </table>
  </dd>
</dl>
<p>Analyze the boundary cells of a mesh, and if one cell is found at a corner position (with dim adjacent faces on the boundary), and its dim-dimensional angle fraction exceeds <code>limit_angle_fraction</code>, refine globally once, and replace the children of such cell with children where the corner is no longer offending the given angle fraction.</p>
<p>If no boundary cells exist with two adjacent faces on the boundary, then the triangulation is left untouched. If instead we do have cells with dim adjacent faces on the boundary, then the fraction between the dim-dimensional solid angle and dim*pi/2 is checked against the parameter <code>limit_angle_fraction</code>. If it is higher, the grid is refined once, and the children of the offending cell are replaced with some cells that instead respect the limit. After this process the triangulation is flattened, and all <a class="el" href="classManifold.html">Manifold</a> objects are restored as they were in the original triangulation.</p>
<p>An example is given by the following mesh, obtained by attaching a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to a mesh generated using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div>
</div><!-- fragment --><p align="center"></p>
<div class="image">
<img src="regularize_mesh_01.png" alt=""/>
</div>
 <p>The four cells that were originally the corners of a square will give you some troubles during computations, as the jacobian of the transformation from the reference cell to those cells will go to zero, affecting the error constants of the finite element estimates.</p>
<p>Those cells have a corner with an angle that is very close to 180 degrees, i.e., an angle fraction very close to one.</p>
<p>The same code, adding a call to regularize_corner_cells: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
</div><!-- fragment --><p> generates a mesh that has a much better behavior w.r.t. the jacobian of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a>:</p>
<p align="center"></p>
<div class="image">
<img src="regularize_mesh_02.png" alt=""/>
</div>
 <p>This mesh is very similar to the one obtained by <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>. However, using <a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a> one has the freedom to choose when to apply the regularization, i.e., one could in principle first refine a few times, and then call the regularize_corner_cells function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div>
<div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div>
</div><!-- fragment --><p>This generates the following mesh:</p>
<p align="center"></p>
<div class="image">
<img src="regularize_mesh_03.png" alt=""/>
</div>
 <p>The function is currently implemented only for dim = 2 and will throw an exception if called with dim = 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to regularize.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_angle_fraction</td><td>Maximum ratio of angle or solid angle that is allowed for a corner element in the mesh. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05146">5146</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8e8bb9211264d2106758ac4d7184117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bb9211264d2106758ac4d7184117e">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classTriangulation.html">Triangulation</a>'s <code>cache</code> and a list of <code>points</code>, call <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> on each element of <code>points</code>, and return <code>cells</code>, reference positions <code>qpoints</code>, and a mapping <code>maps</code> from local to global indices into <code>points</code> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>The triangulation's <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The point's vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_hint</td><td>(optional) A cell iterator for a cell which likely contains the first point of <code>points</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:</dd></dl>
<ul>
<li><code>cells</code> : A vector of all the cells containing at least one of the <code>points</code> .</li>
<li><code>qpoints</code> : A vector of vectors of points. <code>qpoints</code>[i] contains the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li><code>indices</code> : A vector of vectors of integers, containing the mapping between local numbering in <code>qpoints</code> , and global index in <code>points</code> . If <code>points</code>[a] and <code>points</code>[b] are the only two points that fall in <code>cells</code>[c], then <code>qpoints</code>[c][0] and <code>qpoints</code>[c][1] are the reference positions of <code>points</code>[a] and <code>points</code>[b] in <code>cells</code>[c], and <code>indices</code>[c][0] = a, <code>indices</code>[c][1] = b. The function Mapping::transform_unit_to_real(qpoints[c][0]) returns <code>points</code>[a]. The algorithm builds an rtree of <code>points</code> to sort them spatially, before attempting to call <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a>. <dl class="section note"><dt>Note</dt><dd>This function is not implemented for the codimension one case (<code>spacedim != dim</code>). </dd>
<dd>
If a point is not found inside the mesh, or is lying inside an artificial cell of a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, the point is silently ignored. If you want to infer for which points the search failed, use the function <a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all()</a> that also returns a vector of indices indicating the points for which the search failed. </dd>
<dd>
The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line"><a class="code" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;</div>
<div class="line"><a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd>
<dd>
This function optimizes the search by making use of <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, which either returns a cached rtree or builds and stores one. Building an rtree might hinder the performance if the function is called only once on few points.</dd></dl>
Given a <a class="el" href="classTriangulation.html">Triangulation</a>'s <code>cache</code> and a list of <code>points</code>, call <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> on each element of <code>points</code>, and return <code>cells</code>, reference positions <code>qpoints</code>, and a mapping <code>maps</code> from local to global indices into <code>points</code> .</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>The triangulation's <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The point's vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_hint</td><td>(optional) A cell iterator for a cell which likely contains the first point of <code>points</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li><code>cells</code> : A vector of all the cells containing at least one of the <code>points</code> .</li>
<li><code>qpoints</code> : A vector of vectors of points. <code>qpoints</code>[i] contains the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li><code>indices</code> : A vector of vectors of integers, containing the mapping between local numbering in <code>qpoints</code> , and global index in <code>points</code> .</li>
</ul>
</dd></dl>
<p>If <code>points</code>[a] and <code>points</code>[b] are the only two points that fall in <code>cells</code>[c], then <code>qpoints</code>[c][0] and <code>qpoints</code>[c][1] are the reference positions of <code>points</code>[a] and <code>points</code>[b] in <code>cells</code>[c], and <code>indices</code>[c][0] = a, <code>indices</code>[c][1] = b. The function Mapping::transform_unit_to_real(qpoints[c][0]) returns <code>points</code>[a].</p>
<p>The algorithm builds an rtree of <code>points</code> to sort them spatially, before attempting to call <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for the codimension one case (<code>spacedim != dim</code>).</dd>
<dd>
If a point is not found inside the mesh, or is lying inside an artificial cell of a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, the point is silently ignored. If you want to infer for which points the search failed, use the function <a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all()</a> that also returns a vector of indices indicating the points for which the search failed.</dd>
<dd>
The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line"><a class="code" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;</div>
<div class="line">  <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page.</dd>
<dd>
This function optimizes the search by making use of <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, which either returns a cached rtree or builds and stores one. Building an rtree might hinder the performance if the function is called only once on few points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05461">5461</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a5a845642f4d205352931267b58055d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a845642f4d205352931267b58055d62">&#9670;&nbsp;</a></span>compute_point_locations_try_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations_try_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>, but while <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">compute_point_locations()</a> silently ignores all points for which <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> fails, this function also returns a vector containing the indices of the points for which <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> failed. </p><dl class="section return"><dt>Returns</dt><dd>A tuple containing four elements; the first three are documented in <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. The last element of the <code>return_type</code> contains the indices of points which are neither found inside the mesh nor lie in artificial cells. The <code>return_type</code> equals the following tuple type: <div class="fragment"><div class="line"><a class="code" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;</div>
<div class="line">  <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;</div>
<div class="line">     <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim,spacedim&gt;::active_cell_iterator</a>&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">  std::vector&lt;unsigned int&gt;</div>
<div class="line">&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for the codimension one case (<code>spacedim != dim</code>). </dd>
<dd>
This function optimizes the search by making use of <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, which either returns a cached rtree or builds and stores one. Building an rtree might hinder the performance if the function is called only once on few points. For a more detailed documentation see <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05490">5490</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="afe6eff31d194dd4beafc9eb6a22c5e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6eff31d194dd4beafc9eb6a22c5e27">&#9670;&nbsp;</a></span>distributed_compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::distributed_compute_point_locations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <code>cache</code> and a list of <code>local_points</code> for each process, find the points lying on the locally owned part of the mesh and compute the quadrature rules for them. Distributed compute point locations is a function similar to <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> but working for <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> objects and, unlike its serial version, also for a distributed triangulation (see <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>).</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_points</td><td>the array of points owned by the current process. Every process can have a different array of points which can be empty and not contained within the locally owned part of the triangulation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td>a vector of vectors of bounding boxes; it describes the locally owned part of the mesh for each process. The bounding boxes describing which part of the mesh is locally owned by process with rank rk are contained in global_bboxes[rk]. The local description can be obtained from <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a>; then the global one can be obtained using either <a class="el" href="group__manifold.html#gaabe16a0bf926dd422545ce1ccf0834de">GridTools::exchange_local_bounding_boxes</a> or <a class="el" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the quadrature information The elements of the output tuple are:</dd></dl>
<ul>
<li>cells : a vector of all cells containing at least one point.</li>
<li>qpoints : a vector of vector of points; containing in <code>qpoints</code>[i] the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li>maps : a vector of vector of integers, containing the mapping between the numbering in qpoints (previous element of the tuple), and the vector of local points of the process owning the points.</li>
<li>points : a vector of vector of points. <code>points</code>[i][j] is the point in the real space corresponding. to <code>qpoints</code>[i][j] . Notice <code>points</code> are the points lying on the locally owned part of the mesh; thus these can be either copies of <code>local_points</code> or points received from other processes i.e. local_points for other processes</li>
<li>owners : a vector of vectors; <code>owners</code>[i][j] contains the rank of the process owning the point[i][j] (previous element of the tuple). The function uses the triangulation's mpi communicator: for this reason it throws an assert error if the <a class="el" href="classTriangulation.html">Triangulation</a> is not derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> . In a serial execution the first three elements of the tuple are the same as in <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> . Note: this function is a collective operation. <dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line"><a class="code" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;</div>
<div class="line"><a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;Point&lt;spacedim&gt;&gt;&gt;,</div>
<div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page.</dd></dl>
Given a <code>cache</code> and a list of <code>local_points</code> for each process, find the points lying on the locally owned part of the mesh and compute the quadrature rules for them. Distributed compute point locations is a function similar to <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> but working for <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> objects and, unlike its serial version, also for a distributed triangulation (see <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_points</td><td>the array of points owned by the current process. Every process can have a different array of points which can be empty and not contained within the locally owned part of the triangulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td>a vector of vectors of bounding boxes; it describes the locally owned part of the mesh for each process. The bounding boxes describing which part of the mesh is locally owned by process with rank rk are contained in global_bboxes[rk]. The local description can be obtained from <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a>; then the global one can be obtained using either <a class="el" href="group__manifold.html#gaabe16a0bf926dd422545ce1ccf0834de">GridTools::exchange_local_bounding_boxes</a> or <a class="el" href="namespaceUtilities_1_1MPI.html#a5520ba264c2ecb9dac7e6eee24dfb4ec">Utilities::MPI::all_gather</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the quadrature information</dd></dl>
<p>The elements of the output tuple are:</p><ul>
<li>cells : a vector of all cells containing at least one point.</li>
<li>qpoints : a vector of vector of points; containing in <code>qpoints</code>[i] the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li>maps : a vector of vector of integers, containing the mapping between the numbering in qpoints (previous element of the tuple), and the vector of local points of the process owning the points.</li>
<li>points : a vector of vector of points. <code>points</code>[i][j] is the point in the real space corresponding. to <code>qpoints</code>[i][j] . Notice <code>points</code> are the points lying on the locally owned part of the mesh; thus these can be either copies of <code>local_points</code> or points received from other processes i.e. local_points for other processes</li>
<li>owners : a vector of vectors; <code>owners</code>[i][j] contains the rank of the process owning the point[i][j] (previous element of the tuple).</li>
</ul>
<p>The function uses the triangulation's mpi communicator: for this reason it throws an assert error if the <a class="el" href="classTriangulation.html">Triangulation</a> is not derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> .</p>
<p>In a serial execution the first three elements of the tuple are the same as in <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> .</p>
<p>Note: this function is a collective operation.</p>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line"><a class="code" href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">std::tuple</a>&lt;</div>
<div class="line">  <a class="code" href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">std::vector</a>&lt;</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;Point&lt;spacedim&gt;&gt;&gt;,</div>
<div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05658">5658</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a30077cfce9e6234e386fbd4286bc2dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30077cfce9e6234e386fbd4286bc2dd7">&#9670;&nbsp;</a></span>extract_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; GridTools::extract_used_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a>&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a map `vertex index</p>
<p>-&gt; <a class="el" href="classPoint.html">Point&lt;spacedim&gt;</a><code>containing the used vertices of the given </code>container`. The key of the returned map (i.e., the first element of the pair above) is the global index in the triangulation, whereas the value of each pair is the physical location of the corresponding vertex. The used vertices are obtained by looping over all cells, and querying for each cell where its vertices are through the (optional) <code>mapping</code> argument. In serial <a class="el" href="classTriangulation.html">Triangulation</a> objects and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> objects, the size of the returned map equals <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a> (not <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a>). Note that in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, only vertices in locally owned cells and ghost cells are returned, as for all other vertices their real location might not be known (e.g. for distributed computations using <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>). If you use the default <code>mapping</code>, the returned map satisfies the following equality: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> used_vertices = <a class="code" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">extract_used_vertices</a>(tria);</div>
<div class="line"><span class="keyword">auto</span> all_vertices = tria.<a class="code" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;id_and_v : used_vertices)</div>
<div class="line">all_vertices[id_and_v.first] == id_and_v.second; <span class="comment">// true</span></div>
</div><!-- fragment --><p> Notice that the above is not satisfied for mappings that change the location of vertices, like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>. <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to extract vertices from.</td></tr>
    <tr><td class="paramname">mapping</td><td>The mapping to use to compute the points locations.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a map <code>vertex index -&gt; <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code> containing the used vertices of the given <code>container</code>. The key of the returned map (i.e., the first element of the pair above) is the global index in the triangulation, whereas the value of each pair is the physical location of the corresponding vertex. The used vertices are obtained by looping over all cells, and querying for each cell where its vertices are through the (optional) <code>mapping</code> argument.</p>
<p>In serial <a class="el" href="classTriangulation.html">Triangulation</a> objects and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> objects, the size of the returned map equals <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a> (not <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a>). Note that in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, only vertices in locally owned cells and ghost cells are returned, as for all other vertices their real location might not be known (e.g. for distributed computations using <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>).</p>
<p>If you use the default <code>mapping</code>, the returned map satisfies the following equality:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> used_vertices = <a class="code" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">extract_used_vertices</a>(tria);</div>
<div class="line"><span class="keyword">auto</span> all_vertices = tria.<a class="code" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;id_and_v : used_vertices)</div>
<div class="line">  all_vertices[id_and_v.first] == id_and_v.second; <span class="comment">// true</span></div>
</div><!-- fragment --><p>Notice that the above is not satisfied for mappings that change the location of vertices, like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>.</p>
<p><a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to extract vertices from. </td></tr>
    <tr><td class="paramname">mapping</td><td>The mapping to use to compute the points locations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06210">6210</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1f49d6a42c3dbabc53a86571e874cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f49d6a42c3dbabc53a86571e874cc3f">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the closest vertex to a given point in the map of vertices passed as the first argument.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>A map of index-&gt;vertex, as returned by <a class="el" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">GridTools::extract_used_vertices()</a>.</td></tr>
    <tr><td class="paramname">p</td><td>The target point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex that is closest to the target point <code>p</code>.</dd></dl>
<p>Find and return the index of the closest vertex to a given point in the map of vertices passed as the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>A map of index-&gt;vertex, as returned by <a class="el" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">GridTools::extract_used_vertices()</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The target point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex that is closest to the target point <code>p</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06229">6229</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a07919e120e98a6a0139ffe8c9f4a2a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07919e120e98a6a0139ffe8c9f4a2a8b">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point. This function uses the locations of vertices as stored in the triangulation. This is usually sufficient, unless you are using a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> that moves the vertices around (for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>). In this case, you should call the function with the same name and with an additional <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> argument.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found.</dd></dl>
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point.</p>
<p>This function uses the locations of vertices as stored in the triangulation. This is usually sufficient, unless you are using a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> that moves the vertices around (for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>). In this case, you should call the function with the same name and with an additional <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02440">2440</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a84f7b02080d7740cdb0fe73f3917af36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f7b02080d7740cdb0fe73f3917af36">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point. Use the given mapping to compute the actual location of the vertices. If the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> does not modify the position of the mesh vertices (like, for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> does), then this function is equivalent to the one with the same name, and without the <code>mapping</code> argument.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>A mapping used to compute the vertex locations</td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found.</dd></dl>
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point. Use the given mapping to compute the actual location of the vertices.</p>
<p>If the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. This class declares the interface for the functionality to d...">Mapping</a> does not modify the position of the mesh vertices (like, for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> does), then this function is equivalent to the one with the same name, and without the <code>mapping</code> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>A mapping used to compute the vertex locations </td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02506">2506</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="addb822f0e3068e48640ecc981ee6c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb822f0e3068e48640ecc981ee6c1e6">&#9670;&nbsp;</a></span>find_cells_adjacent_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; GridTools::find_cells_adjacent_to_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return a vector of iterators to active cells that surround a given vertex with index <code>vertex_index</code>. For locally refined grids, the vertex itself might not be a vertex of all adjacent cells that are returned. However, it will always be either a vertex of a cell or be a hanging node located on a face or an edge of it.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">vertex_index</td><td>The index of the vertex for which we try to find adjacent cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cells that lie adjacent to the given vertex. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It isn't entirely clear at this time whether the function does the right thing with anisotropically refined meshes. It needs to be checked for this case.</dd></dl>
<p>Find and return a vector of iterators to active cells that surround a given vertex with index <code>vertex_index</code>.</p>
<p>For locally refined grids, the vertex itself might not be a vertex of all adjacent cells that are returned. However, it will always be either a vertex of a cell or be a hanging node located on a face or an edge of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">vertex_index</td><td>The index of the vertex for which we try to find adjacent cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cells that lie adjacent to the given vertex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It isn't entirely clear at this time whether the function does the right thing with anisotropically refined meshes. It needs to be checked for this case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02568">2568</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2e10aeb1c8e76110a84b6945eac3aaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e10aeb1c8e76110a84b6945eac3aaf0">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an active non-artificial cell that surrounds a given point <code>p</code>. The return type is a pair of an iterator to the active cell along with the unit cell coordinates of the point. The algorithm used in this function proceeds by first looking for the vertex located closest to the given point, see <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>. Secondly, all adjacent cells to this vertex are found in the mesh, see <a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">GridTools::find_cells_adjacent_to_vertex()</a>. Lastly, for each of these cells, the function tests whether the point is inside. This check is performed using the given <code>mapping</code> argument to determine whether cells have straight or curved boundaries. If a point lies on the boundary of two or more cells, then the algorithm tries to identify the cell that is of highest refinement level. If the point requested does not lie in a locally-owned or ghost cell, then this function will return the (invalid) MeshType&lt;dim,   spacedim&gt;::end() iterator. This case can be handled similarly to the various <code>std::find()</code> and <code><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">std::lower_bound()</a></code> functions.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>The mapping used to determine whether the given point is inside a given cell.</td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of <code>bool</code>s indicating whether an entry in the vertex array should be considered (and the others must be ignored) as the potentially closest vertex to the specified point. On specifying a non-default <code>marked_vertices</code>, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex()</a> would only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to <a class="el" href="distributed_2tria__0_8txt.html#a7a64162bc6c76ef03e4963ab8e6dafed">n_vertices()</a> of the triangulation (as opposed to n_used_vertices() ). The motivation of using <code>marked_vertices</code> is to cut down the search space of vertices if one has a priori knowledge of a collection of vertices that the point of interest may be close to. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of an iterators into the mesh that points to the surrounding cell, and of the unit cell coordinates of that point. This local position might be located slightly outside an actual unit cell, due to numerical roundoff. Therefore, the point returned by this function should be projected onto the unit cell, using <a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">GeometryInfo::project_to_unit_cell()</a>. This is not automatically performed by the algorithm. The returned cell can be a locally-owned cell or a ghost cell (but not an artificial cell). The returned cell might be a ghost cell even if the given point is a vertex of a locally owned cell. The reason behind is that this is the only way to guarantee that all processors that participate in a parallel triangulation will agree which cell contains a point. For example, if two processors come together at one vertex and the function is called with this vertex, then one processor will return a locally owned cell and the other one a ghost cell.</dd></dl>
<p>Find an active non-artificial cell that surrounds a given point <code>p</code>. The return type is a pair of an iterator to the active cell along with the unit cell coordinates of the point.</p>
<p>The algorithm used in this function proceeds by first looking for the vertex located closest to the given point, see <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>. Secondly, all adjacent cells to this vertex are found in the mesh, see <a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">GridTools::find_cells_adjacent_to_vertex()</a>. Lastly, for each of these cells, the function tests whether the point is inside. This check is performed using the given <code>mapping</code> argument to determine whether cells have straight or curved boundaries.</p>
<p>If a point lies on the boundary of two or more cells, then the algorithm tries to identify the cell that is of highest refinement level.</p>
<p>If the point requested does not lie in a locally-owned or ghost cell, then this function will return the (invalid) MeshType&lt;dim, spacedim&gt;::end() iterator. This case can be handled similarly to the various <code>std::find()</code> and <code><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">std::lower_bound()</a></code> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>The mapping used to determine whether the given point is inside a given cell. </td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of <code>bool</code>s indicating whether an entry in the vertex array should be considered (and the others must be ignored) as the potentially closest vertex to the specified point. On specifying a non-default <code>marked_vertices</code>, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex()</a> would only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to <a class="el" href="distributed_2tria__0_8txt.html#a7a64162bc6c76ef03e4963ab8e6dafed">n_vertices()</a> of the triangulation (as opposed to n_used_vertices() ). The motivation of using <code>marked_vertices</code> is to cut down the search space of vertices if one has a priori knowledge of a collection of vertices that the point of interest may be close to. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of an iterators into the mesh that points to the surrounding cell, and of the unit cell coordinates of that point. This local position might be located slightly outside an actual unit cell, due to numerical roundoff. Therefore, the point returned by this function should be projected onto the unit cell, using <a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">GeometryInfo::project_to_unit_cell()</a>. This is not automatically performed by the algorithm. The returned cell can be a locally-owned cell or a ghost cell (but not an artificial cell). The returned cell might be a ghost cell even if the given point is a vertex of a locally owned cell. The reason behind is that this is the only way to guarantee that all processors that participate in a parallel triangulation will agree which cell contains a point. For example, if two processors come together at one vertex and the function is called with this vertex, then one processor will return a locally owned cell and the other one a ghost cell. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00436">436</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a9df2272fe8a72156bc2628aa07c5123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2272fe8a72156bc2628aa07c5123e">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the above function that assumes straight boundaries and as a consequence simply calls the above function using <a class="el" href="classMappingQ1.html">MappingQ1</a> for the mapping argument. </p><dl class="section return"><dt>Returns</dt><dd>An iterator into the mesh that points to the surrounding cell. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00412">412</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a0f04de5b8fee18233b4a2dbb81eb64ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f04de5b8fee18233b4a2dbb81eb64ea">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another version where we use that mapping on a given cell that corresponds to the active finite element index of that cell. This is obviously only useful for hp-problems, since the active finite element index for all other DoF handlers is always zero. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01258">1258</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a59f673ed723568e41c72a3634e4d12db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f673ed723568e41c72a3634e4d12db">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finding an active non-artificial cell around a point can be very expensive in terms of computational costs. This function aims at providing a fast version of the above functions by using a space-tree to speed up the geometry search.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Object with information about the space-tree of a triangulation, see <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>.</td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell.</td></tr>
    <tr><td class="paramname">cell_hint</td><td>Gives a hint for the geometry search, which is beneficial if a-priori knowledge is available regarding the cell on which the point may likely be located. A typical use case would be that this search has to be done for an array of points that are close to each other and where the adjacent cell of the previous point is a good hint for the next point in the array. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>See above.</td></tr>
    <tr><td class="paramname">tolerance</td><td>See above. The following code example shows how to use this function: <div class="fragment"><div class="line"><a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a45c57074a631760cdab557f450e880e0">mapping</a>);</div>
<div class="line"><span class="keyword">auto</span> cell_hint = <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a>();</div>
<div class="line"><a class="code" href="sparse__vanka__0_8txt.html#a96771f1712564cc2701caa2fdfb4965d">std::vector&lt;bool&gt;</a> marked_vertices = {};</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a> = 1.e-10;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;dim&gt;&gt; <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>; <span class="comment">// a vector of many points</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">for(<span class="keyword">auto</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> : <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>)</div>
<div class="line">{</div>
<div class="line"><span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>(</div>
<div class="line">  cache, <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, cell_hint, marked_vertices, <a class="code" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (cell_and_ref_point.first != <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.end())</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// use current cell as hint for the next point</span></div>
<div class="line">   cell_hint = cell_and_ref_point.first;</div>
<div class="line">   <span class="comment">// do something with cell_and_ref_point</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line"> {</div>
<div class="line">    <span class="comment">// The function did not find a locally owned or ghost cell in which</span></div>
<div class="line">    <span class="comment">// the point is located. We ought to handle this somehow here.</span></div>
<div class="line"> }</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Finding an active non-artificial cell around a point can be very expensive in terms of computational costs. This function aims at providing a fast version of the above functions by using a space-tree to speed up the geometry search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Object with information about the space-tree of a triangulation, see <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
    <tr><td class="paramname">cell_hint</td><td>Gives a hint for the geometry search, which is beneficial if a-priori knowledge is available regarding the cell on which the point may likely be located. A typical use case would be that this search has to be done for an array of points that are close to each other and where the adjacent cell of the previous point is a good hint for the next point in the array. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>See above. </td></tr>
    <tr><td class="paramname">tolerance</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code example shows how to use this function:</p>
<div class="fragment"><div class="line"><a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a45c57074a631760cdab557f450e880e0">mapping</a>);</div>
<div class="line"><span class="keyword">auto</span> cell_hint = <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a>();</div>
<div class="line"><a class="code" href="sparse__vanka__0_8txt.html#a96771f1712564cc2701caa2fdfb4965d">std::vector&lt;bool&gt;</a> marked_vertices = {};</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a> = 1.e-10;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;dim&gt;&gt; <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>; <span class="comment">// a vector of many points</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">for(<span class="keyword">auto</span> <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> : <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>(</div>
<div class="line">    cache, <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, cell_hint, marked_vertices, <a class="code" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cell_and_ref_point.first != <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.end())</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// use current cell as hint for the next point</span></div>
<div class="line">     cell_hint = cell_and_ref_point.first;</div>
<div class="line">     <span class="comment">// do something with cell_and_ref_point</span></div>
<div class="line">     ...</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// The function did not find a locally owned or ghost cell in which</span></div>
<div class="line">      <span class="comment">// the point is located. We ought to handle this somehow here.</span></div>
<div class="line">   }</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06246">6246</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2881f45ff9aa67db94aeb46437797cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2881f45ff9aa67db94aeb46437797cf4">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;MeshType&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>used_vertices_rtree</em> = <code><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;,&#160;unsigned&#160;<a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&gt;&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; *&#160;</td>
          <td class="paramname"><em>relevant_cell_bounding_boxes_rtree</em> = <code><a class="el" href="fe__interface__values__0_8txt.html#a7afb86fa5db4a209b125ed3572c5579a">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the previous function that exploits an already existing map between vertices and cells (constructed using the function <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>), a map of vertex_to_cell_centers (obtained through <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a>), and optionally an RTree constructed from the used vertices of the <a class="el" href="classTriangulation.html">Triangulation</a>. </p><dl class="section note"><dt>Note</dt><dd>All of these structures can be queried from a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object. Note, however, that in this case MeshType has to be <a class="el" href="classTriangulation.html">Triangulation</a>, so that it might be more appropriate to directly call the function above with argument <code>cache</code> in this case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02782">2782</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aef086f558e9e1c6148e3fa8c62e7a066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef086f558e9e1c6148e3fa8c62e7a066">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As compared to the functions above, this function identifies all active non-artificial cells around a point for a given tolerance level <code>tolerance</code> in terms of unit coordinates. Given a first cell with reference coordinates as parameter <code>first_cell</code>, e.g. obtained by one of the functions above, all corresponding neighboring cells with points in unit coordinates are also identified. This function is useful e.g. for discontinuous function spaces where, for the case the given point <code>p</code> lies on a vertex, edge or face, several cells might hold independent values of the solution that get combined in some way in a user code. This function is used as follows </p><div class="fragment"><div class="line"><span class="keyword">auto</span> first_pair = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>(...);</div>
<div class="line"><span class="keyword">auto</span> all_cells  = <a class="code" href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">GridTools::find_all_active_cells_around_point</a>(</div>
<div class="line">                           <a class="code" href="mpi__remote__point__evaluation__0_8txt.html#a45c57074a631760cdab557f450e880e0">mapping</a>, <a class="code" href="distributed__0_8txt.html#a1a9fea1222a1f75ee681b6805de5f7fc">mesh</a>, <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>, <a class="code" href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a>, first_pair);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00599">599</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="af7daaed7cdd68d2b8f70d2dde1df3061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7daaed7cdd68d2b8f70d2dde1df3061">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; std::pair&lt; typename MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant of the previous function that internally calls one of the functions <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> to obtain a first cell, and subsequently adds all other active non-artificial cells by calling the function <a class="el" href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">find_all_active_cells_around_point()</a> above. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00571">571</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a12e5380ad5f46c2c11ba134d0a5291d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e5380ad5f46c2c11ba134d0a5291d6">&#9670;&nbsp;</a></span>get_active_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::get_active_child_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all descendants of the given cell that are active. For example, if the current cell is once refined but none of its children are any further refined, then the returned list will contain all its children. If the current cell is already active, then the returned list is empty (because the cell has no children that may be active). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active descendants of the given cell </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since in C++ the MeshType template argument can not be deduced from a function call, you will have to specify it after the function name, as for example in <div class="fragment"><div class="line">GridTools::get_active_child_cells&lt;DoFHandler&lt;dim&gt; &gt; (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30ccceb7c9216efc44dd4af561e0bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ccceb7c9216efc44dd4af561e0bea0">&#9670;&nbsp;</a></span>get_active_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_active_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the active cells around a given cell <code>cell</code> and return them in the vector <code>active_neighbors</code>. These neighbors are specifically the <em>face</em> neighbors of a cell or, if that neighbor is further refined, its active children that border on that face. On the other hand, the neighbors returned do not include cells that lie, for example, diagonally opposite to a vertex but are not face neighbors themselves. (In 3d, it also does not include cells that are adjacent to one of the edges of the current cell, but are not face neighbors.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">active_neighbors</td><td>A list of active descendants of the given cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since in C++ the MeshType template argument can not be deduced from a function call, you will have to specify it after the function name, as for example in <div class="fragment"><div class="line">GridTools::get_active_neighbors&lt;DoFHandler&lt;dim&gt;&gt;(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>, active_neighbors)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a51acc74a2c56fc9cab517235be235cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acc74a2c56fc9cab517235be235cdc">&#9670;&nbsp;</a></span>compute_active_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_active_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the active cell layer around a subdomain (set of active cells) in the <code>mesh</code> (i.e. those that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>. An example of a custom predicate is one that checks for a given material id </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">pred_mat_id(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">return</span> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;material_id() ==  1;</div>
<div class="line">}</div>
</div><!-- fragment --><p> and we can then extract the layer of cells around this material with the following call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(tria, pred_mat_id&lt;dim&gt;);</div>
</div><!-- fragment --><p> Predicates that are frequently useful can be found in namespace <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a>. For example, it is possible to extract a layer of cells around all of those cells with a given material id, </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div>
<div class="line">tria, <a class="code" href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a>(1, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p> or around all cells with one of a set of active FE indices for a <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div>
<div class="line">hp_dof_handler, <a class="code" href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a>({1,2}, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p> Note that in the last two examples we ensure that the predicate returns true only for locally owned cells. This means that the halo layer will not contain any artificial cells. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td>A function (or object of a type with an <a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">operator()</a>) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells sharing at least one common vertex with the predicated subdomain.</dd></dl>
<p>Extract and return the active cell layer around a subdomain (set of active cells) in the <code>mesh</code> (i.e. those that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>An example of a custom predicate is one that checks for a given material id </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">pred_mat_id(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp; <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;material_id() ==  1;</div>
<div class="line">}</div>
</div><!-- fragment --><p> and we can then extract the layer of cells around this material with the following call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(tria, pred_mat_id&lt;dim&gt;);</div>
</div><!-- fragment --><p>Predicates that are frequently useful can be found in namespace <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a>. For example, it is possible to extract a layer of cells around all of those cells with a given material id, </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div>
<div class="line">  tria, <a class="code" href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a>(1, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p> or around all cells with one of a set of active FE indices for a <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div>
<div class="line">  hp_dof_handler, <a class="code" href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a>({1,2}, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p> Note that in the last two examples we ensure that the predicate returns true only for locally owned cells. This means that the halo layer will not contain any artificial cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td>A function (or object of a type with an <a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">operator()</a>) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells sharing at least one common vertex with the predicated subdomain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00738">738</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a98e89706e7e925b16d42d288c462e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e89706e7e925b16d42d288c462e9d8">&#9670;&nbsp;</a></span>compute_cell_halo_layer_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::cell_iterator &gt; GridTools::compute_cell_halo_layer_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the cell layer around a subdomain (set of cells) on a specified level of the <code>mesh</code> (i.e. those cells on that level that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00775">775</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a6d0674004143aed7f492a3ae7bcb2e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0674004143aed7f492a3ae7bcb2e3d">&#9670;&nbsp;</a></span>compute_ghost_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_ghost_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return ghost cells which are the active cell layer around all locally owned cells. This is most relevant for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> where it will return a subset of all ghost cells on a processor, but for <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this will return all the ghost cells. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of ghost cells </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00856">856</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a599f59fd9beccda86d7980c30a9b1f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599f59fd9beccda86d7980c30a9b1f6a">&#9670;&nbsp;</a></span>compute_active_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_active_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the set of active cells within a geometric distance of <code>layer_thickness</code> around a subdomain (set of active cells) in the <code>mesh</code>. Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>The function first computes the cells that form the 'surface' of the subdomain that consists of all of the active cells for which the predicate is true. Using <a class="el" href="namespaceGridTools.html#ae1ec55abefa31cf001fd29d8d4d993f1">compute_bounding_box()</a>, a bounding box is computed for this subdomain and extended by <code>layer_thickness</code>. These cells are called interior subdomain boundary cells. The active cells with all of their vertices outside the extended bounding box are ignored. The cells that are inside the extended bounding box are then checked for their proximity to the interior subdomain boundary cells. This implies checking the distance between a pair of arbitrarily oriented cells, which is not trivial in general. To simplify this, the algorithm checks the distance between the two enclosing spheres of the cells. This will definitely result in slightly more cells being marked but also greatly simplifies the arithmetic complexity of the algorithm.</p>
<div class="image">
<img src="active_cell_layer_within_distance.png" alt=""/>
</div>
<p> The image shows a mesh generated by <a class="el" href="grid__generator__0_8txt.html#a70107564cf8c0fb4f6caab72293d801f">subdivided_hyper_rectangle()</a>. The cells are marked using three different colors. If the grey colored cells in the image are the cells for which the predicate is true, then the function <a class="el" href="namespaceGridTools.html#a599f59fd9beccda86d7980c30a9b1f6a">compute_active_cell_layer_within_distance()</a> will return a set of cell iterators corresponding to the cells colored in red. The red colored cells are the active cells that are within a given distance to the grey colored cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramname">predicate</td><td>A function (or object of a type with an <a class="el" href="precondition__selector__0_8txt.html#a1400415a03f0fadabafb87fd8e6287cc">operator()</a>) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
    <tr><td class="paramname">layer_thickness</td><td>specifies the geometric distance within which the function searches for active cells from the predicate domain. If the minimal distance between the enclosing sphere of the an active cell and the enclosing sphere of any of the cells for which the <code>predicate</code> returns <code>true</code> is less than <code>layer_thickness</code>, then the active cell is an <em>active_cell_within_distance</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells within a given geometric distance <code>layer_thickness</code> from the set of active cells for which the <code>predicate</code> returns <code>true</code>.</dd></dl>
<p>See <a class="el" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">compute_active_cell_halo_layer()</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00878">878</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aa21d10102639460701c67f7e79afc06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21d10102639460701c67f7e79afc06f">&#9670;&nbsp;</a></span>compute_ghost_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_ghost_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return a set of ghost cells which are within a <code>layer_thickness</code> around all locally owned cells. This is most relevant for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> where it will return a subset of all ghost cells on a process, but for <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this will return all the ghost cells. All the cells for the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> class that are not owned by the current processor can be considered as ghost cells; in particular, they do not only form a single layer of cells around the locally owned ones. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramname">layer_thickness</td><td>specifies the geometric distance within which the function searches for active cells from the locally owned cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subset of ghost cells within a given geometric distance of <code>layer_thickness</code> from the locally owned cells of a current process. Also see <a class="el" href="namespaceGridTools.html#a6d0674004143aed7f492a3ae7bcb2e3d">compute_ghost_cell_halo_layer()</a> and <a class="el" href="namespaceGridTools.html#a599f59fd9beccda86d7980c30a9b1f6a">compute_active_cell_layer_within_distance()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01022">1022</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a0374dd9eae73c3c2badaa479e8ba8d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0374dd9eae73c3c2badaa479e8ba8d55">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt;, <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt; &gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and return a bounding box, defined through a pair of points bottom left and top right, that surrounds a subdomain of the <code>mesh</code>. Here, the "subdomain" consists of exactly all of those active cells for which the <code>predicate</code> returns <code>true</code>. For a description of how <code>predicate</code> works, see <a class="el" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">compute_active_cell_halo_layer()</a>. </p><dl class="section note"><dt>Note</dt><dd>This function was written before the <a class="el" href="classBoundingBox.html">BoundingBox</a> class was invented. Consequently, it returns a pair of points, rather than a <a class="el" href="classBoundingBox.html">BoundingBox</a> object as one may expect. However, <a class="el" href="classBoundingBox.html">BoundingBox</a> has a conversion constructor from pairs of points, so the result of this function can still be assigned to a <a class="el" href="classBoundingBox.html">BoundingBox</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01058">1058</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a08438d4ad901817b7b638ce733fd664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08438d4ad901817b7b638ce733fd664d">&#9670;&nbsp;</a></span>compute_mesh_predicate_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; MeshType::space_dimension &gt; &gt; GridTools::compute_mesh_predicate_bounding_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>refinement_level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>allow_merge</em> = <code><a class="el" href="grid__reordering__0_8txt.html#a1acd522474ab485130d27acd3bbf5480">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>max_boxes</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a collection of bounding boxes so that all active cells for which the given predicate is true, are completely enclosed in at least one of the bounding boxes. Notice the cover is only guaranteed to contain all these active cells but it's not necessarily exact i.e. it can include a bigger area than their union. For each cell at a given refinement level containing active cells for which <code>predicate</code> is true, the function creates a bounding box of its children for which <code>predicate</code> is true. This results in a cover of all active cells for which <code>predicate</code> is true; the parameters <code>allow_merge</code> and <code>max_boxes</code> are used to reduce the number of cells at a computational cost and covering a bigger n-dimensional volume. The parameters to control the algorithm are:</p>
<ul>
<li><code>predicate</code> : the property of the cells to enclose e.g. <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a> . The predicate is tested only on active cells.</li>
<li><code>refinement_level</code> : it defines the level at which the initial bounding box are created. The refinement should be set to a coarse refinement level. A bounding box is created for each active cell at coarser level than <code>refinement_level</code>; if <code>refinement_level</code> is higher than the number of levels of the triangulation an exception is thrown.</li>
<li><code>allow_merge</code> : This flag allows for box merging and, by default, is false. The algorithm has a cost of O(N^2) where N is the number of the bounding boxes created from the refinement level; for this reason, if the flag is set to true, make sure to choose wisely a coarse enough <code>refinement_level</code>.</li>
<li><code>max_boxes</code> : the maximum number of bounding boxes to compute. If more are created the smaller ones are merged with neighbors. By default after merging the boxes which can be expressed as a single one no more boxes are merged. See the <a class="el" href="classBoundingBox.html#a2ee80a34bb8b1d1b6727959e8ef992ad">BoundingBox::get_neighbor_type</a> () function for details. Notice only neighboring cells are merged (see the <code>get_neighbor_type</code> function in bounding box class): if the target number of bounding boxes max_boxes can't be reached by merging neighbors an exception is thrown The following image describes an example of the algorithm with <code>refinement_level</code> = 2, <code>allow_merge</code> = true and <code>max_boxes</code> = 1. The cells with the property predicate are in red, the area of a bounding box is slightly orange. <div class="image">
<img src="bounding_box_predicate.png" alt=""/>
</div>
</li>
<li>1. In black we can see the cells of the current level.</li>
<li>2. For each cell containing the red area a bounding box is created: by default these are returned.</li>
<li>3. Because <code>allow_merge</code> = true the number of bounding boxes is reduced while not changing the cover. If <code>max_boxes</code> was left as default or bigger than 1 these two boxes would be returned.</li>
<li>4. Because <code>max_boxes</code> = 1 the smallest bounding box is merged to the bigger one. Notice it is important to choose the parameters wisely. For instance, <code>allow_merge</code> = false and <code>refinement_level</code> = 1 returns the very same bounding box but with a fraction of the computational cost. This function does not take into account the curvature of cells and thus it is not suited for handling curved geometry: the mapping is assumed to be linear. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03052">3052</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a84063935e67e3a3bb5afadc7b00599ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84063935e67e3a3bb5afadc7b00599ac">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an array of points, use the global bounding box description obtained using <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a> to guess, for each of them, which process might own it.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td><a class="el" href="classVector.html">Vector</a> of bounding boxes describing the portion of mesh with a property for each process.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Array of points to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:</dd></dl>
<ul>
<li>A vector indicized with ranks of processes. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners. <dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">         std::map&lt; unsigned int, unsigned int&gt;,</div>
<div class="line">         std::map&lt; unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page.</dd></dl>
Given an array of points, use the global bounding box description obtained using <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a> to guess, for each of them, which process might own it.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td><a class="el" href="classVector.html">Vector</a> of bounding boxes describing the portion of mesh with a property for each process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Array of points to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li>A vector indicized with ranks of processes. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">           std::map&lt; unsigned int, unsigned int&gt;,</div>
<div class="line">           std::map&lt; unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03199">3199</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a327cb9de55959193994a994047592ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327cb9de55959193994a994047592ec9">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>covering_rtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a covering rtree (see <a class="el" href="classGridTools_1_1Cache.html#a376c8ecad23b1c000c6c36feae17b386">GridTools::Cache::get_covering_rtree()</a>), and an array of points, find a superset of processes which, individually, may own the cell containing the points. For further details see <a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">GridTools::guess_point_owner</a>; here only different input/output types are reported:</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covering_rtree</td><td>RTRee which enables us to identify which process(es) in a parallel computation may own the cell that surrounds a given point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>A vector of points to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:</dd></dl>
<ul>
<li>A map indexed by processor ranks. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner; these are points for which a single possible owner was found.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners; these are points for which multiple possible owners were found. <dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">         std::map&lt;unsigned int, unsigned int&gt;,</div>
<div class="line">         std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page.</dd></dl>
Given a covering rtree (see <a class="el" href="classGridTools_1_1Cache.html#a376c8ecad23b1c000c6c36feae17b386">GridTools::Cache::get_covering_rtree()</a>), and an array of points, find a superset of processes which, individually, may own the cell containing the points.</li>
</ul>
<p>For further details see <a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">GridTools::guess_point_owner</a>; here only different input/output types are reported:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covering_rtree</td><td>RTRee which enables us to identify which process(es) in a parallel computation may own the cell that surrounds a given point.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>A vector of points to consider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li>A map indexed by processor ranks. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner; these are points for which a single possible owner was found.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners; these are points for which multiple possible owners were found.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;,</div>
<div class="line">           std::map&lt;unsigned int, unsigned int&gt;,</div>
<div class="line">           std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div>
</div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03247">3247</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9b7e2ca8ecd26a472e5225ba91a58acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e2ca8ecd26a472e5225ba91a58acb">&#9670;&nbsp;</a></span>vertex_to_cell_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &gt; GridTools::vertex_to_cell_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the adjacent cells of all the vertices. If a vertex is also a hanging node, the associated coarse cell is also returned. The vertices are ordered by the vertex index. This is the number returned by the function <code>cell-&gt;vertex_index()</code> . Notice that only the indices marked in the array returned by <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation&lt;dim,spacedim&gt;::get_used_vertices()</a> are used.</p>
<p>Return the adjacent cells of all the vertices. If a vertex is also a hanging node, the associated coarse cell is also returned. The vertices are ordered by the vertex index. This is the number returned by the function <code>cell-&gt;vertex_index()</code>. Notice that only the indices marked in the array returned by <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation&lt;dim,spacedim&gt;::get_used_vertices()</a> are used. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03297">3297</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a79eddc6b744c7c83d9bc020dfa509e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eddc6b744c7c83d9bc020dfa509e19">&#9670;&nbsp;</a></span>vertex_to_cell_centers_directions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &gt; &gt; GridTools::vertex_to_cell_centers_directions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of normalized tensors for each vertex-cell combination of the output of <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a> (which is expected as input parameter for this function). Each tensor represents a geometric vector from the vertex to the respective cell center. An assertion will be thrown if the size of the input vector is not equal to the number of vertices of the triangulation. result[v][c] is a unit <a class="el" href="classTensor.html">Tensor</a> for vertex index v, indicating the direction of the center of the c-th cell with respect to the vertex v. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02696">2696</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2d9ac4e5783a4c13911c576064b255be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9ac4e5783a4c13911c576064b255be">&#9670;&nbsp;</a></span>find_closest_vertex_of_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> GridTools::find_closest_vertex_of_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classMapping.html">Mapping</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.<a class="el" href="concepts__0_8txt.html#a6fecb4a4ea81eaa3fd313b2fc0ab36c9">template</a>&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>,&#160;<a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local vertex index of cell <code>cell</code> that is closest to the given location <code>position</code>. The location of the vertices is extracted from the (optional) <code>mapping</code> argument, to guarantee that the correct answer is returned when the underlying mapping modifies the position of the vertices. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02970">2970</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="adf1ec4049da3c61cb29eb294199e7e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1ec4049da3c61cb29eb294199e7e53">&#9670;&nbsp;</a></span>compute_local_to_global_vertex_index_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="namespacetypes.html#afe941afb42dfe05bb0d4def860881229">types::global_vertex_index</a> &gt; GridTools::compute_local_to_global_vertex_index_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a globally unique index for each vertex and hanging node associated with a locally owned active cell. The vertices of a ghost cell that are hanging nodes of a locally owned cells have a global index. However, the other vertices of the cells that do not <em>touch</em> an active cell do not have a global index on this processor. The key of the map is the local index of the vertex and the value is the global index. The indices need to be recomputed after refinement or coarsening and may be different. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03346">3346</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aed82bbc9838a9123bf567014ae9990dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82bbc9838a9123bf567014ae9990dd">&#9670;&nbsp;</a></span>get_longest_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; GridTools::get_longest_direction </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the highest value among ratios between extents in each of the coordinate directions of a <code>cell</code>. Moreover, return the dimension relative to the highest elongation.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>an iterator pointing to the cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;unsigned int, double&gt; such that the <code>first</code> value is the dimension of the highest elongation and the <code>second</code> value is the ratio among the dimensions of the <code>cell</code>.</dd></dl>
<p>Return the highest value among ratios between extents in each of the coordinate directions of a <code>cell</code>. Moreover, return the dimension relative to the highest elongation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>an iterator pointing to the cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;unsigned int, double&gt; such that the <code>first</code> value is the dimension of the highest elongation and the <code>second</code> value is the ratio among the dimensions of the <code>cell</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05052">5052</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a002fd376a184234ccbf5eca8f8fd7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002fd376a184234ccbf5eca8f8fd7012">&#9670;&nbsp;</a></span>get_face_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common face. The diagonal entries of the sparsity pattern are also set. The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03699">3699</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ab54e2fb68484ddaedaab56de13323169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54e2fb68484ddaedaab56de13323169">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set. The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03733">3733</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="acec0e25e2e5b5c9f359516d85ef29950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0e25e2e5b5c9f359516d85ef29950">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern for a given level mesh in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set. The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03762">3762</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a99eba8e3b388258eda37a2724579dd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eba8e3b388258eda37a2724579dd1d">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use graph partitioner to partition the active cells making up the entire domain. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell- &gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code>. Use the third argument to select between partitioning algorithms provided by METIS or ZOLTAN. METIS is the default partitioner. If deal.II was not installed with ZOLTAN or METIS, this function will generate an error when corresponding partition method is chosen, unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without packages installed, and only requires them installed when multiple partitions are required. </p><dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner.</dd></dl>
<p>Use graph partitioner to partition the active cells making up the entire domain. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code>.</p>
<p>Use the third argument to select between partitioning algorithms provided by METIS or ZOLTAN. METIS is the default partitioner.</p>
<p>If deal.II was not installed with ZOLTAN or METIS, this function will generate an error when corresponding partition method is chosen, unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without packages installed, and only requires them installed when multiple partitions are required.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03798">3798</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a72956e32f5a1091a6c8731b545e7fcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72956e32f5a1091a6c8731b545e7fcbf">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs the same operation as the one above, except that it takes into consideration a specific set of <code>cell_weights</code>, which allow the partitioner to balance the graph while taking into consideration the computational effort expended on each cell. </p><dl class="section note"><dt>Note</dt><dd>If the <code>cell_weights</code> vector is empty, then no weighting is taken into consideration. If not then the size of this vector must equal to the number of active cells in the triangulation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03849">3849</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3c475677bc29b764e9fa5978d4d41f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c475677bc29b764e9fa5978d4d41f77">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the previous one, i.e. it partitions a triangulation using a partitioning algorithm into a number of subdomains identified by the <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code> flag. The difference to the previous function is the second argument, a sparsity pattern that represents the connectivity pattern between cells. While the function above builds it directly from the triangulation by considering which cells neighbor each other, this function can take a more refined connectivity graph. The sparsity pattern needs to be of size \(N\times N\) , where \(N\) is the number of active cells in the triangulation. If the sparsity pattern contains an entry at position \((i,j)\) , then this means that cells \(i\) and \(j\) (in the order in which they are traversed by active cell iterators) are to be considered connected; partitioning algorithm will then try to partition the domain in such a way that (i) the subdomains are of roughly equal size, and (ii) a minimal number of connections are broken. This function is mainly useful in cases where connections between cells exist that are not present in the triangulation alone (otherwise the previous function would be the simpler one to use). Such connections may include that certain parts of the boundary of a domain are coupled through symmetric boundary conditions or integrals (e.g. friction contact between the two sides of a crack in the domain), or if a numerical scheme is used that not only connects immediate neighbors but a larger neighborhood of cells (e.g. when solving integral equations). In addition, this function may be useful in cases where the default sparsity pattern is not entirely sufficient. This can happen because the default is to just consider face neighbors, not neighboring cells that are connected by edges or vertices. While the latter couple when using continuous finite elements, they are typically still closely connected in the neighborship graph, and partitioning algorithm will not usually cut important connections in this case. However, if there are vertices in the mesh where many cells (many more than the common 4 or 6 in 2d and 3d, respectively) come together, then there will be a significant number of cells that are connected across a vertex, but several degrees removed in the connectivity graph built only using face neighbors. In a case like this, partitioning algorithm may sometimes make bad decisions and you may want to build your own connectivity graph. </p><dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner.</dd></dl>
<p>This function does the same as the previous one, i.e. it partitions a triangulation using a partitioning algorithm into a number of subdomains identified by the <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code> flag.</p>
<p>The difference to the previous function is the second argument, a sparsity pattern that represents the connectivity pattern between cells.</p>
<p>While the function above builds it directly from the triangulation by considering which cells neighbor each other, this function can take a more refined connectivity graph. The sparsity pattern needs to be of size \(N\times N\), where \(N\) is the number of active cells in the triangulation. If the sparsity pattern contains an entry at position \((i,j)\), then this means that cells \(i\) and \(j\) (in the order in which they are traversed by active cell iterators) are to be considered connected; partitioning algorithm will then try to partition the domain in such a way that (i) the subdomains are of roughly equal size, and (ii) a minimal number of connections are broken.</p>
<p>This function is mainly useful in cases where connections between cells exist that are not present in the triangulation alone (otherwise the previous function would be the simpler one to use). Such connections may include that certain parts of the boundary of a domain are coupled through symmetric boundary conditions or integrals (e.g. friction contact between the two sides of a crack in the domain), or if a numerical scheme is used that not only connects immediate neighbors but a larger neighborhood of cells (e.g. when solving integral equations).</p>
<p>In addition, this function may be useful in cases where the default sparsity pattern is not entirely sufficient. This can happen because the default is to just consider face neighbors, not neighboring cells that are connected by edges or vertices. While the latter couple when using continuous finite elements, they are typically still closely connected in the neighborship graph, and partitioning algorithm will not usually cut important connections in this case. However, if there are vertices in the mesh where many cells (many more than the common 4 or 6 in 2d and 3d, respectively) come together, then there will be a significant number of cells that are connected across a vertex, but several degrees removed in the connectivity graph built only using face neighbors. In a case like this, partitioning algorithm may sometimes make bad decisions and you may want to build your own connectivity graph.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03891">3891</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="af499f992ff3d4716f7f15c55d68ade02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af499f992ff3d4716f7f15c55d68ade02">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs the same operation as the one above, except that it takes into consideration a specific set of <code>cell_weights</code>, which allow the partitioner to balance the graph while taking into consideration the computational effort expended on each cell. </p><dl class="section note"><dt>Note</dt><dd>If the <code>cell_weights</code> vector is empty, then no weighting is taken into consideration. If not then the size of this vector must equal to the number of active cells in the triangulation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03944">3944</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1951822ebc7a80fb21aea5d4cd6dac6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951822ebc7a80fb21aea5d4cd6dac6c">&#9670;&nbsp;</a></span>partition_triangulation_zorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation_zorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>group_siblings</em> = <code><a class="el" href="fe__q__base__0_8txt.html#a9601151adeb0e47ff412484e56e370d5">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a partitioning of the active cells making up the entire domain using the same partitioning scheme as in the p4est library if the flag <code>group_siblings</code> is set to true (default behavior of this function). After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell- &gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>If the flag <code>group_siblings</code> is set to false, children of a cell might be placed on different processors even though they are all active, which is an assumption made by p4est. By relaxing this, we can create partitions owning a single cell (also for refined meshes).</dd></dl>
<p>Generates a partitioning of the active cells making up the entire domain using the same partitioning scheme as in the p4est library if the flag <code>group_siblings</code> is set to true (default behavior of this function). After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>If the flag <code>group_siblings</code> is set to false, children of a cell might be placed on different processors even though they are all active, which is an assumption made by p4est. By relaxing this, we can create partitions owning a single cell (also for refined meshes). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04025">4025</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a70d37431a097d36fb7152c41e0352b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d37431a097d36fb7152c41e0352b5e">&#9670;&nbsp;</a></span>partition_multigrid_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_multigrid_levels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partitions the cells of a multigrid hierarchy by assigning level subdomain ids using the "youngest child" rule, that is, each cell in the hierarchy is owned by the processor who owns its left most child in the forest, and active cells have the same subdomain id and level subdomain id. You can access the level subdomain id of a cell by using <code>cell- &gt;level_subdomain_id()</code>. Note: This function assumes that the active cells have already been partitioned.</p>
<p>Partitions the cells of a multigrid hierarchy by assigning level subdomain ids using the "youngest child" rule, that is, each cell in the hierarchy is owned by the processor who owns its left most child in the forest, and active cells have the same subdomain id and level subdomain id. You can access the level subdomain id of a cell by using <code>cell-&gt;level_subdomain_id()</code>.</p>
<p>Note: This function assumes that the active cells have already been partitioned. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04130">4130</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac41d959ae1723a898b616c3320241ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41d959ae1723a898b616c3320241ffe">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classCellId.html">CellId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to ask for the owning subdomain of cells identified by <a class="el" href="classCellId.html">CellId</a> objects that do not have to exist on the current process. </p><dl class="section note"><dt>Note</dt><dd>This function has not been implemented yet for <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04158">4158</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae0cb61bdd7e17c6b1589bdd16891e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb61bdd7e17c6b1589bdd16891e561">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell, return in the output array to which subdomain (as given by the <code>cell-&gt;<a class="el" href="tria__levels__0_8txt.html#a26cab9b2fe6e7f95a4102fbd722c02b1">subdomain_id()</a></code> function) it belongs. The output array is supposed to have the right size already when calling this function. This function returns the association of each cell with one subdomain. If you are looking for the association of each <em>DoF</em> with a subdomain, use the <code><a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">DoFTools::get_subdomain_association</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04252">4252</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8c212a30784bec20b1ae13fad3fd579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c212a30784bec20b1ae13fad3fd579c">&#9670;&nbsp;</a></span>count_cells_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> GridTools::count_cells_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many cells are uniquely associated with the given <code>subdomain</code> index. This function may return zero if there are no cells with the given <code>subdomain</code> index. This can happen, for example, if you try to partition a coarse mesh into more partitions (one for each processor) than there are cells in the mesh. This function returns the number of cells associated with one subdomain. If you are looking for the association of <em>DoFs</em> with this subdomain, use the <code><a class="el" href="namespaceDoFTools.html#ac704c6d311cd0f289d625427e03708ac">DoFTools::count_dofs_with_subdomain_association</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04266">4266</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a33b3f1dcc53c868171f1bb0a3793a96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3f1dcc53c868171f1bb0a3793a96e">&#9670;&nbsp;</a></span>get_locally_owned_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; GridTools::get_locally_owned_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a triangulation, return a mask that represents which of its vertices are "owned" by the current process in the same way as we talk about locally owned cells or degrees of freedom (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> and <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">GlossLocallyOwnedDof</a> ). For the purpose of this function, we define a locally owned vertex as follows: a vertex is owned by that processor with the smallest subdomain id (which equals the MPI rank of that processor) among all owners of cells adjacent to this vertex. In other words, vertices that are in the interior of a partition of the triangulation are owned by the owner of this partition; for vertices that lie on the boundary between two or more partitions, the owner is the processor with the least subdomain_id among all adjacent subdomains. For sequential triangulations (as opposed to, for example, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), every user vertex is of course owned by the current processor, i.e., the function returns <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a>. For parallel triangulations, the returned mask is a subset of what <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a> returns.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation of which the function evaluates which vertices are locally owned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subset of vertices, as described above. The length of the returned array equals <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation.n_vertices()</a> and may, consequently, be larger than <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>.</dd></dl>
<p>For a triangulation, return a mask that represents which of its vertices are "owned" by the current process in the same way as we talk about locally owned cells or degrees of freedom (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> and <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">GlossLocallyOwnedDof</a>). For the purpose of this function, we define a locally owned vertex as follows: a vertex is owned by that processor with the smallest subdomain id (which equals the MPI rank of that processor) among all owners of cells adjacent to this vertex. In other words, vertices that are in the interior of a partition of the triangulation are owned by the owner of this partition; for vertices that lie on the boundary between two or more partitions, the owner is the processor with the least subdomain_id among all adjacent subdomains.</p>
<p>For sequential triangulations (as opposed to, for example, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), every user vertex is of course owned by the current processor, i.e., the function returns <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a>. For parallel triangulations, the returned mask is a subset of what <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a> returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation of which the function evaluates which vertices are locally owned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subset of vertices, as described above. The length of the returned array equals <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation.n_vertices()</a> and may, consequently, be larger than <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04282">4282</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a32a5016c746ad756046ecff264dfa60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a5016c746ad756046ecff264dfa60d">&#9670;&nbsp;</a></span>get_finest_common_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tria__objects__0_8txt.html#a98f82f403ed91139649aef16b25f739c">std::list</a>&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt; GridTools::get_finest_common_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two meshes (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) that are based on the same coarse mesh, this function figures out a set of cells that are matched between the two meshes and where at most one of the meshes is more refined on this cell. In other words, it finds the smallest cells that are common to both meshes, and that together completely cover the domain. This function is useful, for example, in time-dependent or nonlinear application, where one has to integrate a solution defined on one mesh (e.g., the one from the previous time step or nonlinear iteration) against the shape functions of another mesh (the next time step, the next nonlinear iteration). If, for example, the new mesh is finer, then one has to obtain the solution on the coarse mesh (mesh_1) and interpolate it to the children of the corresponding cell of mesh_2. Conversely, if the new mesh is coarser, one has to express the coarse cell shape function by a linear combination of fine cell shape functions. In either case, one needs to loop over the finest cells that are common to both triangulations. This function returns a list of pairs of matching iterators to cells in the two meshes that can be used to this end. Note that the list of these iterators is not necessarily ordered, and does also not necessarily coincide with the order in which cells are traversed in one, or both, of the meshes given as arguments. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can only be used with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> when both meshes use the same <a class="el" href="classTriangulation.html">Triangulation</a> since, with a distributed <a class="el" href="classTriangulation.html">Triangulation</a>, not all cells are stored locally, so the resulting list may not cover the entire domain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01106">1106</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aae387b14cb19f14e3dbd3e0e1a3e3ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae387b14cb19f14e3dbd3e0e1a3e3ba2">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the two triangulations are based on the same coarse mesh. This is determined by checking whether they have the same number of cells on the coarsest level, and then checking that they have the same vertices. The two meshes may have different refinement histories beyond the coarse mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01211">1211</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="abb75c70b1760c88a852413a1a9fae107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75c70b1760c88a852413a1a9fae107">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but working on arguments of type <a class="el" href="classDoFHandler.html">DoFHandler</a>. This function is provided to allow calling have_same_coarse_mesh for all types of containers representing triangulations or the classes built on triangulations. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01247">1247</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a1c7bb95bc2bbb09d6f02651d7be1527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7bb95bc2bbb09d6f02651d7be1527d">&#9670;&nbsp;</a></span>fix_up_distorted_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::DistortedCellList GridTools::fix_up_distorted_child_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::DistortedCellList &amp;&#160;</td>
          <td class="paramname"><em>distorted_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a triangulation and a list of cells whose children have become distorted as a result of mesh refinement, try to fix these cells up by moving the center node around. The function returns a list of cells with distorted children that couldn't be fixed up for whatever reason. The returned list is therefore a subset of the input argument. For a definition of the concept of distorted cells, see the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry</a>. The first argument passed to the current function is typically the exception thrown by the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement</a> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04802">4802</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aaec69b92488f0dd0d61ff66445327f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec69b92488f0dd0d61ff66445327f0d">&#9670;&nbsp;</a></span>get_patch_around_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename MeshType::active_cell_iterator &gt; GridTools::get_patch_around_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of all the active neighbor cells of the given, active cell. Here, a neighbor is defined as one having at least part of a face in common with the given cell, but not edge (in 3d) or vertex neighbors (in 2d and 3d). The first element of the returned list is the cell provided as argument. The remaining ones are neighbors: The function loops over all faces of that given cell and checks if that face is not on the boundary of the domain. Then, if the neighbor cell does not have any children (i.e., it is either at the same refinement level as the current cell, or coarser) then this neighbor cell is added to the list of cells. Otherwise, if the neighbor cell is refined and therefore has children, then this function loops over all subfaces of current face adds the neighbors behind these sub-faces to the list to be returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. In C++, the compiler can not determine <code>MeshType</code> from the function call. You need to specify it as an explicit template argument following the function name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells that form the patch around the given cell </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. This also requires manipulating the degrees of freedom associated with the cells of a patch. To this end, there are further functions working on patches in namespace <a class="el" href="namespaceDoFTools.html">DoFTools</a>. </dd>
<dd>
In the context of a parallel distributed computation, it only makes sense to call this function on locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these.</dd></dl>
<p>This function returns a list of all the active neighbor cells of the given, active cell. Here, a neighbor is defined as one having at least part of a face in common with the given cell, but not edge (in 3d) or vertex neighbors (in 2d and 3d).</p>
<p>The first element of the returned list is the cell provided as argument. The remaining ones are neighbors: The function loops over all faces of that given cell and checks if that face is not on the boundary of the domain. Then, if the neighbor cell does not have any children (i.e., it is either at the same refinement level as the current cell, or coarser) then this neighbor cell is added to the list of cells. Otherwise, if the neighbor cell is refined and therefore has children, then this function loops over all subfaces of current face adds the neighbors behind these sub-faces to the list to be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. In C++, the compiler can not determine <code>MeshType</code> from the function call. You need to specify it as an explicit template argument following the function name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells that form the patch around the given cell</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. This also requires manipulating the degrees of freedom associated with the cells of a patch. To this end, there are further functions working on patches in namespace <a class="el" href="namespaceDoFTools.html">DoFTools</a>.</dd>
<dd>
In the context of a parallel distributed computation, it only makes sense to call this function on locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01389">1389</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a1cb9de754873e0401df4a51bacf0556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb9de754873e0401df4a51bacf0556c">&#9670;&nbsp;</a></span>get_cells_at_coarsest_common_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename Container::cell_iterator &gt; GridTools::get_cells_at_coarsest_common_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of active cells (hereafter named <code>patch_cells</code>) as input argument, and returns a vector of their parent cells with the coarsest common level of refinement. In other words, find that set of cells living at the same refinement level so that all cells in the input vector are children of the cells in the set, or are in the set itself. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type has to satisfy the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a> ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_cells</td><td>A vector of active cells for which this function finds the parents at the coarsest common level. This vector of cells typically results from calling the function <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of cells with the coarsest common level of refinement of the input cells.</dd></dl>
<p>This function takes a vector of active cells (hereafter named <code>patch_cells</code>) as input argument, and returns a vector of their parent cells with the coarsest common level of refinement. In other words, find that set of cells living at the same refinement level so that all cells in the input vector are children of the cells in the set, or are in the set itself.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type has to satisfy the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_cells</td><td>A vector of active cells for which this function finds the parents at the coarsest common level. This vector of cells typically results from calling the function <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of cells with the coarsest common level of refinement of the input cells. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01436">1436</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aca3b216d4efc9d4add312c055a5ec95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b216d4efc9d4add312c055a5ec95f">&#9670;&nbsp;</a></span>build_triangulation_from_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::build_triangulation_from_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="symmetric__tensor__0_8txt.html#a6edfde50c98e496c6d723c198719a0cd">Container::dimension</a>, Container::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="symmetric__tensor__0_8txt.html#a6edfde50c98e496c6d723c198719a0cd">Container::dimension</a>, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_to_global_tria_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function constructs a <a class="el" href="classTriangulation.html">Triangulation</a> (named <code>local_triangulation</code>) from a given vector of active cells. This vector (which we think of the cells corresponding to a "patch") contains active cells that are part of an existing global <a class="el" href="classTriangulation.html">Triangulation</a>. The goal of this function is to build a local <a class="el" href="classTriangulation.html">Triangulation</a> that contains only the active cells given in <code>patch</code> (and potentially a minimum number of additional cells required to form a valid <a class="el" href="classTriangulation.html">Triangulation</a>). The function also returns a map that allows to identify the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> and corresponding cells in the input list.</p>
<p>The function copies the location of vertices of cells from the cells of the source triangulation to the triangulation that is built from the list of patch cells. This adds support for triangulations which have been perturbed or smoothed in some manner which makes the triangulation deviate from the standard deal.II refinement strategy of placing new vertices at midpoints of faces or edges.</p>
<p>The operation implemented by this function is frequently used in the definition of error estimators that need to solve "local" problems on each cell and its neighbors. A similar construction is necessary in the definition of the Clement interpolation operator in which one needs to solve a local problem on all cells within the support of a shape function. This function then builds a complete <a class="el" href="classTriangulation.html">Triangulation</a> from a list of cells that make up such a patch; one can then later attach a <a class="el" href="classDoFHandler.html">DoFHandler</a> to such a <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>If the list of input cells contains only cells at the same refinement level, then the output <a class="el" href="classTriangulation.html">Triangulation</a> simply consists of a <a class="el" href="classTriangulation.html">Triangulation</a> containing only exactly these patch cells. On the other hand, if the input cells live on different refinement levels, i.e., the <a class="el" href="classTriangulation.html">Triangulation</a> of which they are part is adaptively refined, then the construction of the output <a class="el" href="classTriangulation.html">Triangulation</a> is not so simple because the coarsest level of a <a class="el" href="classTriangulation.html">Triangulation</a> can not contain hanging nodes. Rather, we first have to find the common refinement level of all input cells, along with their common parents (see <a class="el" href="namespaceGridTools.html#a1cb9de754873e0401df4a51bacf0556c">GridTools::get_cells_at_coarsest_common_level()</a>), build a <a class="el" href="classTriangulation.html">Triangulation</a> from those, and then adaptively refine it so that the input cells all also exist in the output <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>A consequence of this procedure is that the output <a class="el" href="classTriangulation.html">Triangulation</a> may contain more active cells than the ones that exist in the input vector. On the other hand, one typically wants to solve the local problem not on the entire output <a class="el" href="classTriangulation.html">Triangulation</a>, but only on those cells of it that correspond to cells in the input list. In this case, a user typically wants to assign degrees of freedom only on cells that are part of the "patch", and somehow ignore those excessive cells. The current function supports this common requirement by setting the user flag for the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> that match with cells in the input list. Cells which are not part of the original patch will not have their <code>user_flag</code> set; we can then avoid assigning degrees of freedom using the <a class="el" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a> element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type that satisfies the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A vector of active cells from a common triangulation. These cells may or may not all be at the same refinement level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_triangulation</td><td>A triangulation whose active cells correspond to the given vector of active cells in <code>patch</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">patch_to_global_tria_map</td><td>A map between the local triangulation which is built as explained above, and the cell iterators in the input list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01482">1482</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a90221d4afe481ab23792286fe21e71dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90221d4afe481ab23792286fe21e71dd">&#9670;&nbsp;</a></span>get_dof_to_support_patch_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;::active_cell_iterator &gt; &gt; GridTools::get_dof_to_support_patch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function runs through the degrees of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> and for each dof constructs a vector of active_cell_iterators representing the cells of support of the associated basis element at that degree of freedom. This function was originally designed for the implementation of local projections, for instance the Clement interpolant, in conjunction with other local patch functions like <a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">GridTools::build_triangulation_from_patch</a>. <a class="el" href="classDoFHandler.html">DoFHandler</a>'s built on top of <a class="el" href="classTriangulation.html">Triangulation</a> or parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> are supported and handled appropriately. The result is the patch of cells representing the support of the basis element associated to the degree of freedom. For instance using an <a class="el" href="classFE__Q.html">FE_Q</a> finite element, we obtain the standard patch of cells touching the degree of freedom and then add other cells that take care of possible hanging node constraints. Using a <a class="el" href="classFE__DGQ.html">FE_DGQ</a> finite element, the degrees of freedom are logically considered to be "interior" to the cells so the patch would consist exclusively of the single cell on which the degree of freedom is located.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> which could be built on a <a class="el" href="classTriangulation.html">Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with a finite element that has degrees of freedom that are logically associated to a vertex, line, quad, or hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from the global_dof_index of degrees of freedom on locally relevant cells to vectors containing <a class="el" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a> of cells in the support of the basis function at that degree of freedom.</dd></dl>
<p>This function runs through the degrees of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> and for each dof constructs a vector of active_cell_iterators representing the cells of support of the associated basis element at that degree of freedom. This function was originally designed for the implementation of local projections, for instance the Clement interpolant, in conjunction with other local patch functions like <a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">GridTools::build_triangulation_from_patch</a>.</p>
<p><a class="el" href="classDoFHandler.html">DoFHandler</a>'s built on top of <a class="el" href="classTriangulation.html">Triangulation</a> or parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> are supported and handled appropriately.</p>
<p>The result is the patch of cells representing the support of the basis element associated to the degree of freedom. For instance using an <a class="el" href="classFE__Q.html">FE_Q</a> finite element, we obtain the standard patch of cells touching the degree of freedom and then add other cells that take care of possible hanging node constraints. Using a <a class="el" href="classFE__DGQ.html">FE_DGQ</a> finite element, the degrees of freedom are logically considered to be "interior" to the cells so the patch would consist exclusively of the single cell on which the degree of freedom is located.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> which could be built on a <a class="el" href="classTriangulation.html">Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with a finite element that has degrees of freedom that are logically associated to a vertex, line, quad, or hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from the global_dof_index of degrees of freedom on locally relevant cells to vectors containing <a class="el" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a> of cells in the support of the basis function at that degree of freedom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01699">1699</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ac2a1903382c6cff07b33d456a641f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a1903382c6cff07b33d456a641f6d9">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;FaceIterator::AccessorType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An orthogonal equality test for faces. <code>face1</code> and <code>face2</code> are considered equal, if a one to one matching between its vertices can be achieved via an orthogonal equality relation. Here, two vertices <code>v_1</code> and <code>v_2</code> are considered equal, if \(M\cdot v_1 + offset - v_2\) is parallel to the unit vector in unit direction <code>direction</code>. If the parameter <code>matrix</code> is a reference to a spacedim x spacedim matrix, \(M\) is set to <code>matrix</code>, otherwise \(M\) is the identity matrix. If the matching was successful, the <em>relative</em> orientation of <code>face1</code> with respect to <code>face2</code> is returned in the bitset <code>orientation</code>, where </p><div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[0]</div>
<div class="line"> </div>
<div class="line">-&gt; <a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a></div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[1]</div>
<div class="line"> </div>
<div class="line">-&gt; <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a></div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[2]</div>
<div class="line"> </div>
<div class="line">-&gt; <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a></div>
</div><!-- fragment --><p> In 2D <code>face_orientation</code> is always <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>. More precisely in 3d: <code>face_orientation</code>: <code>true</code> if <code>face1</code> and <code>face2</code> have the same orientation. Otherwise, the vertex indices of <code>face1</code> match the vertex indices of <code>face2</code> in the following manner: </p><div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">1</div>
<div class="line"> </div>
<div class="line">- 3            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">0</div>
<div class="line"> </div>
<div class="line">- 2            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
</div><!-- fragment --><p> <code>face_flip</code>: <code>true</code> if the matched vertices are rotated by 180 degrees: </p><div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">1</div>
<div class="line"> </div>
<div class="line">- 0            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">3</div>
<div class="line"> </div>
<div class="line">- 2            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
</div><!-- fragment --><p> <code>face_rotation</code>: <code>true</code> if the matched vertices are rotated by 90 degrees counterclockwise: </p><div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">0</div>
<div class="line"> </div>
<div class="line">- 2            2</div>
<div class="line"> </div>
<div class="line">- 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">1</div>
<div class="line"> </div>
<div class="line">- 3            0</div>
<div class="line"> </div>
<div class="line">- 1</div>
</div><!-- fragment --><p> and any combination of that... More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article.</p>
<p>An orthogonal equality test for faces.</p>
<p><code>face1</code> and <code>face2</code> are considered equal, if a one to one matching between its vertices can be achieved via an orthogonal equality relation.</p>
<p>Here, two vertices <code>v_1</code> and <code>v_2</code> are considered equal, if \(M\cdot v_1 + offset - v_2\) is parallel to the unit vector in unit direction <code>direction</code>. If the parameter <code>matrix</code> is a reference to a spacedim x spacedim matrix, \(M\) is set to <code>matrix</code>, otherwise \(M\) is the identity matrix.</p>
<p>If the matching was successful, the <em>relative</em> orientation of <code>face1</code> with respect to <code>face2</code> is returned in the bitset <code>orientation</code>, where </p><div class="fragment"><div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[0] -&gt; <a class="code" href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a></div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[1] -&gt; <a class="code" href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a></div>
<div class="line"><a class="code" href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a>[2] -&gt; <a class="code" href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a></div>
</div><!-- fragment --><p>In 2D <code>face_orientation</code> is always <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>. More precisely in 3d:</p>
<p><code>face_orientation</code>: <code>true</code> if <code>face1</code> and <code>face2</code> have the same orientation. Otherwise, the vertex indices of <code>face1</code> match the vertex indices of <code>face2</code> in the following manner:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">1 - 3            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">0 - 2            0 - 1</div>
</div><!-- fragment --><p><code>face_flip</code>: <code>true</code> if the matched vertices are rotated by 180 degrees:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">1 - 0            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">3 - 2            0 - 1</div>
</div><!-- fragment --><p><code>face_rotation</code>: <code>true</code> if the matched vertices are rotated by 90 degrees counterclockwise:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"> </div>
<div class="line">0 - 2            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">1 - 3            0 - 1</div>
</div><!-- fragment --><p>and any combination of that... More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02414">2414</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ace05eb85711971f65123e569fead988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace05eb85711971f65123e569fead988c">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;FaceIterator::AccessorType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as above, but doesn't return the actual orientation </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02467">2467</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ae72f0f1401743f54382de4415737484f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f0f1401743f54382de4415737484f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">GridTools::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator which outputs assemble flags as a set of or'd text values. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00111">111</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a10dd90fb8c8cd12d2d1215a4cc4f270d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dd90fb8c8cd12d2d1215a4cc4f270d">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">GridTools::operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <code>operator |</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00135">135</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="ad16a1564283fb76f8dc55443b0e6ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16a1564283fb76f8dc55443b0e6ee53">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are not set in the argument. This operator exists since if it did not then the result of the bit-negation <code>operator ~</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00151">151</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a0cb3d72a001ae5c9adb7362dca6a9141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb3d72a001ae5c9adb7362dca6a9141">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">GridTools::operator</a>|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which sets the bits from the second argument also in the first one. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00166">166</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a5220ca0de1f1ffbfdc02fdcb42cc79c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5220ca0de1f1ffbfdc02fdcb42cc79c6">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">GridTools::operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are set in the first as well as the second argument. This operator exists since if it did not then the result of the bit-and <code>operator &amp;</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00183">183</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="aefc539eba69fd137a13b1e974f70bcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc539eba69fd137a13b1e974f70bcd9">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp; <a class="el" href="solver__0_8txt.html#a840632236ca6e80e973c83ccf2ced958">GridTools::operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which clears all the bits in the first argument if they are not also set in the second argument. <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html#l00198">198</a> of file <a class="el" href="grid_2grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="aee88c4dce5066a41183b5dd70289b9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee88c4dce5066a41183b5dd70289b9df">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;MeshType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will collect periodic face pairs on the coarsest mesh level of the given <code>mesh</code> (a <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) and add them to the vector <code>matched_pairs</code> leaving the original contents intact.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a>.</p>
<p>The bitset that is returned inside of <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> encodes the <em>relative</em> orientation of the first face with respect to the second face, see the documentation of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> for further details.</p>
<p>The <code>direction</code> refers to the space direction in which periodicity is enforced. When matching periodic faces this vector component is ignored.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary. This can be used to implement conditions such as \(u(0,y)=u(1,y+1)\).</p>
<p>Optionally, a \(dim\times dim\) rotation <code>matrix</code> can be specified that describes how vector valued DoFs of the first face should be modified prior to constraining to the DoFs of the second face. The <code>matrix</code> is used in two places. First, <code>matrix</code> will be supplied to <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> and used for matching faces: Two vertices \(v_1\) and \(v_2\) match if \(\text{matrix}\cdot v_1 + \text{offset} - v_2\) is parallel to the unit vector in unit direction <code>direction</code>. (For more details see <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a>, the glossary <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">glossary entry on periodic conditions</a> and <a class="el" href="step_45.html">step-45</a>). Second, <code>matrix</code> will be stored in the <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> collection <code>matched_pairs</code> for further use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The created std::vector can be used in <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> and in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity()</a> to enforce periodicity algebraically.</dd>
<dd>
Because elements will be added to <code>matched_pairs</code> (and existing entries will be preserved), it is possible to call this function several times with different boundary ids to generate a vector with all periodic pairs.</dd>
<dd>
Since the periodic face pairs are found on the coarsest mesh level, it is necessary to ensure that the coarsest level faces have the correct boundary indicators set. In general, this means that one must first set all boundary indicators on the coarse grid before performing any global or local grid refinement. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02189">2189</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ab22eef800535f9e85a1723a6a36fd0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22eef800535f9e85a1723a6a36fd0f6">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;MeshType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces()</a> only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_ids this function defines a 'left' boundary as all faces with local face index <code>2*direction</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*direction+1</code> and boundary indicator <code>b_id</code>. Faces with coordinates only differing in the <code>direction</code> component are identified.</p>
<p>This function will collect periodic face pairs on the coarsest mesh level and add them to <code>matched_pairs</code> leaving the original contents intact.</p>
<p>See above function for further details.</p>
<dl class="section note"><dt>Note</dt><dd>This version of <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces()</a> will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>. </dd></dl>

</div>
</div>
<a id="a9b96d83a9f10a39048e1613fa8da8cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b96d83a9f10a39048e1613fa8da8cea">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumberOfPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The <a class="el" href="generators__0_8txt.html#a52d07c1744d923546e9cafc255f70465">number</a> <a class="el" href="copy__data__0_8txt.html#ad2652187ccefa4786a264b05b284b040">of</a> partitions you gave <a class="el" href="grid__generator__0_8txt.html#ab587b856781570b837e9fb6b42d51116">is</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fe__raviart__thomas__0_8txt.html#a8d1cf95cc7b7823aec3fb45189ff7fa1">but</a> must <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a> greater <a class="el" href="vector__tools__constraints__0_8txt.html#aefdb996ee7d624d74a665761984945ed">than</a> zero.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a27708777444134752f8cc8138857df28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27708777444134752f8cc8138857df28">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcNonExistentSubdomain&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The <a class="el" href="tria__base__0_8txt.html#abdc65ec121afd29bf1bccebd2d467267">subdomain</a> <a class="el" href="vector__tools__interpolate__0_8txt.html#a100b4e5e97e0f9089c81a43fd33c32c5">id</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; has <a class="el" href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a> <a class="el" href="numerics_2data__out__0_8txt.html#a8c57d1ea17c1f302f623c4edd1bb41c4">cells</a> associated <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> it.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a088ac82f79509dbe1dc9e8d25bc7e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088ac82f79509dbe1dc9e8d25bc7e50a">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcTriangulationHasBeenRefined&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a1b3154f24e33be2d7f42a123c0654958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3154f24e33be2d7f42a123c0654958">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcScalingFactorNotPositive&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The scaling <a class="el" href="sparse__decomposition__0_8txt.html#aa36e69f7b51d00cbf24c899c1490950c">factor</a> must <a class="el" href="tria__iterator__0_8txt.html#ae2c744f7850c09a43eafeafedf8e2619">be</a>&#160;</td>
          <td class="paramname"><em>positive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fe__raviart__thomas__0_8txt.html#a8d1cf95cc7b7823aec3fb45189ff7fa1">but</a> <a class="el" href="point__value__history__0_8txt.html#a0e6b11ac5f75ce3d8f49f448e960b421">it</a> <a class="el" href="grid__generator__0_8txt.html#ab587b856781570b837e9fb6b42d51116">is</a> &quot;&lt;&lt; arg1&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a0d361c91586d139eebcf2404caeae61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d361c91586d139eebcf2404caeae61a">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcVertexNotUsed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The <a class="el" href="matrix__tools__0_8txt.html#ad7a187dd3e69d0afd283cd08ebfc23ab">given</a> <a class="el" href="polynomials__barycentric__0_8txt.html#aea0bfb5ef47f6eb9c265caab2b94b8d1">vertex</a> <a class="el" href="grid_2manifold__0_8txt.html#aa3b93e70343218f73e9e61ccbb7f1589">with</a> <a class="el" href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">index</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; is <a class="el" href="matrix__free__0_8txt.html#aaa1256056e47f82858c53b9796768300">not</a> <a class="el" href="kinsol__0_8txt.html#a19e73f3d7e2bbefc4ec076d97de80570">used</a> <a class="el" href="tria__description__0_8txt.html#a11901ff80013804497fa645646431eae">in</a> <a class="el" href="vector__tools__project__0_8txt.html#a0f636bbf8ef44dc0f3b278cf16adb0a7">the</a> <a class="el" href="matrix__tools__0_8txt.html#ad7a187dd3e69d0afd283cd08ebfc23ab">given</a> triangulation.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a03981bc3a24576a6cfbc0a305c723eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03981bc3a24576a6cfbc0a305c723eec">&#9670;&nbsp;</a></span>laplace_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFunction.html">Function</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a> &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02086">2086</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="af203f92d771fec1b638c3d032a816592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203f92d771fec1b638c3d032a816592">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename ::<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.<a class="el" href="petsc__matrix__base__0_8txt.html#a03bf6e03f3fc2623b819b781e67fa3fb">e</a>-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another version where we use that mapping on a given cell that corresponds to the active finite element index of that cell. This is obviously only useful for hp-problems, since the active finite element index for all other DoF handlers is always zero. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01258">1258</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a675fa3d8d6ce094fe29a59991b5d6421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675fa3d8d6ce094fe29a59991b5d6421">&#9670;&nbsp;</a></span>match_periodic_face_pairs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::match_periodic_face_pairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; std::pair&lt; CellIterator, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="histogram__0_8txt.html#a1f28b62a413a3352bc54e62ef004750e">std::set</a>&lt; std::pair&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a>, unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; CellIterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CellIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02014">2014</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a213a31f196cd53ccbcc809e567934442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213a31f196cd53ccbcc809e567934442">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02108">2108</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a132f7057487b35446876f2d84aaaf6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132f7057487b35446876f2d84aaaf6df">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02278">2278</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a062e05c51d27f3da00f2a1aa37bd3a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062e05c51d27f3da00f2a1aa37bd3a43">&#9670;&nbsp;</a></span>cell_measure&lt; 1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00032">32</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="ac2994e9cd1a025e9fdd7cb411d68ec57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2994e9cd1a025e9fdd7cb411d68ec57">&#9670;&nbsp;</a></span>cell_measure&lt; 2 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 2 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00045">45</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a275c6633e25410e091b89af0756d4333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275c6633e25410e091b89af0756d4333">&#9670;&nbsp;</a></span>cell_measure&lt; 3 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 3 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00119">119</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a366ba100e8116931dcf4055f667762c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ba100e8116931dcf4055f667762c8">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00427">427</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a0a5fdacaa512a29dac48ad9b11ac159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5fdacaa512a29dac48ad9b11ac159a">&#9670;&nbsp;</a></span>rotate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00436">436</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="afe__raviart__thomas__0_8txt_html_ac6ea408671d88ada97f59c4743d57c2d"><div class="ttname"><a href="fe__raviart__thomas__0_8txt.html#ac6ea408671d88ada97f59c4743d57c2d">face_flip</a></div><div class="ttdeci">ii the shape functions are defined so that certain integrals over the faces are either zero or rather than the common case of certain point values being either zero or the degree of the element denotes the polynomial degree of the[1.x.1] contained in the finite element even if the space may contain shape functions of higher polynomial degree The lowest order element is consequently i the Raviart Thomas element of degree even though the functions of this space are in general polynomials of degree one in each variable This choice of degree implies that the approximation order of the function itself as with usual polynomial spaces The numbering so chosen implies the sequence *[1.x.3] This class is not implemented for the codimension one the[2.x.7] node values are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials Since the normal trace of the RT space of degree[1.x.6] on an edge face is the the moments are taken with respect to this space **Higher order RT spaces have interior nodes These are moments taken with respect to the gradient of functions in[1.x.9] on the which will be computed by quadrature rules themselves The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy The points needed are those of QGauss&lt; sub &gt; k&lt;/sub &gt; on each face as well as QGauss&lt; sub &gt; k&lt;/sub &gt; in the interior of the with[2.x.9] and[2.x.10] replaced by appropriate values **This function returns[2.x.11] if the shape function[2.x.12] has non zero function values somewhere on the face[2.x.13] Right this is only implemented for RT0 in returns always *[2.x.14] *Return a list of constant modes of the element This method is currently not correctly implemented because it returns ones for all components **Only for internal use Its full name is[2.x.15] function and it creates the[2.x.16] vector that is needed within the constructor to be passed to the constructor of[2.x.17] FiniteElementData **Initialize the[2.x.18] field of the FiniteElement class and fill the tables with interpolation this restriction face_flip</div><div class="ttdef"><b>Definition:</b> <a href="fe__raviart__thomas__0_8txt_source.html#l00043">fe_raviart_thomas_0.txt:43</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a3f129213c63c92a6ed84c6f2a906048b"><div class="ttname"><a href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a></div><div class="ttdeci">void regularize_corner_cells(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double limit_angle_fraction=.75)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l05146">grid_tools.cc:5146</a></div></div>
<div class="ttc" id="aclassIteratorFilters_1_1ActiveFEIndexEqualTo_html"><div class="ttname"><a href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2filtered__iterator_8h_source.html#l00287">filtered_iterator.h:287</a></div></div>
<div class="ttc" id="aclassIteratorFilters_1_1MaterialIdEqualTo_html"><div class="ttname"><a href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2filtered__iterator_8h_source.html#l00237">filtered_iterator.h:237</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="aclassTriangulation_html_afb3059d54432e0d739534e5330bb7b3a"><div class="ttname"><a href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a></div><div class="ttdeci">const std::vector&lt; Point&lt; spacedim &gt; &gt; &amp; get_vertices() const</div></div>
<div class="ttc" id="amapping__fe__0_8txt_html_a03f4bc472ac44f06faa3d699da9af068"><div class="ttname"><a href="mapping__fe__0_8txt.html#a03f4bc472ac44f06faa3d699da9af068">transformation</a></div><div class="ttdeci">if which itself is stored in the[2.x.17] field of this structure Computed on each cell **Tensors of contravariant transformation at each of the quadrature points The contravariant matrix is the Jacobian of the transformation</div><div class="ttdef"><b>Definition:</b> <a href="mapping__fe__0_8txt_source.html#l00086">mapping_fe_0.txt:86</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="ampi__remote__point__evaluation__0_8txt_html_a45c57074a631760cdab557f450e880e0"><div class="ttname"><a href="mpi__remote__point__evaluation__0_8txt.html#a45c57074a631760cdab557f450e880e0">mapping</a></div><div class="ttdeci">*Helper class to access values on non matching grids *The name of the fields are chosen with the method quantities are computed at specified arbitrary positioned which receive the result and resort the result according to the points **Constructor[2.x.1] tolerance Tolerance in terms of unit cell coordinates for determining all cells around a point passed to the class during it might be necessary to adjust the tolerance in order to be able to identify a cell Floating point arithmetic implies that a point in not lie exactly on a or face[2.x.2] enforce_unique_mapping Enforce unique mapping</div><div class="ttdef"><b>Definition:</b> <a href="mpi__remote__point__evaluation__0_8txt_source.html#l00005">mpi_remote_point_evaluation_0.txt:5</a></div></div>
<div class="ttc" id="aclassTriangulation_html_a6ad0b3fb24aae17f4668427a433dea19"><div class="ttname"><a href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global</a></div><div class="ttdeci">void refine_global(const unsigned int times=1)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10781">tria.cc:10781</a></div></div>
<div class="ttc" id="aclassSphericalManifold_html"><div class="ttname"><a href="classSphericalManifold.html">SphericalManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00214">manifold_lib.h:214</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a51acc74a2c56fc9cab517235be235cdc"><div class="ttname"><a href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a></div><div class="ttdeci">std::vector&lt; typename MeshType::active_cell_iterator &gt; compute_active_cell_halo_layer(const MeshType &amp;mesh, const std::function&lt; bool(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools__dof__handlers_8cc_source.html#l00738">grid_tools_dof_handlers.cc:738</a></div></div>
<div class="ttc" id="atrilinos__precondition__0_8txt_html_ae2e38e4f182c566122b10d662b9d3f89"><div class="ttname"><a href="trilinos__precondition__0_8txt.html#ae2e38e4f182c566122b10d662b9d3f89">tolerance</a></div><div class="ttdeci">more required fill in elements require this parameter to be set to a higher integer value The AdditionalData data structure allows to set preconditioner options Besides the fill in these options are some options for and a parameter&lt; tt &gt; overlap&lt;/tt &gt; that determines if and how much overlap there should be between the matrix partitions on the various MPI processes The default settings are for the additional fill for the absolute augmentation tolerance</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition__0_8txt_source.html#l00174">trilinos_precondition_0.txt:174</a></div></div>
<div class="ttc" id="agroup__manifold_html_ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><div class="ttname"><a href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a></div><div class="ttdeci">void set_manifold(const types::manifold_id number, const Manifold&lt; dim, spacedim &gt; &amp;manifold_object)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10154">tria.cc:10154</a></div></div>
<div class="ttc" id="anumerical__algorithms__0_8txt_html_a852a1e245dd2de4943eeb66beeaf65b1"><div class="ttname"><a href="numerical__algorithms__0_8txt.html#a852a1e245dd2de4943eeb66beeaf65b1">vector</a></div><div class="ttdeci">****This module groups a diverse set of classes that generally implement some sort of numerical algorithm on top all the basic and finite element classes in the library They are generally unconnected to each other *Some of the like KellyErrorEstimator and act on solutions already and compute derived quantities in the first two or help transferring a set of vectors from one mesh to another *The namespaces and VectorTools provide an assortment of such as creating a Laplace projecting or interpolating a function onto the present finite element etc The difference to the functions in the DoFTools and FETools functions is that they work on the DoFTools functions only act on a given DoFHandler object without reference to a data vector</div><div class="ttdef"><b>Definition:</b> <a href="numerical__algorithms__0_8txt_source.html#l00008">numerical_algorithms_0.txt:8</a></div></div>
<div class="ttc" id="agroup__Iterators_html_ga08c836c1e503743e8073eb615603aab9"><div class="ttname"><a href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a></div><div class="ttdeci">TriaActiveIterator&lt; CellAccessor&lt; dim, spacedim &gt; &gt; active_cell_iterator</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01242">tria.h:1242</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a553c97770c66367cd8861ec511390650"><div class="ttname"><a href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a></div><div class="ttdeci">for if the values of a function need to be evaluated at quadrature points</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00182">multithreading_0.txt:182</a></div></div>
<div class="ttc" id="aclassGridTools_1_1Cache_html"><div class="ttname"><a href="classGridTools_1_1Cache.html">GridTools::Cache&lt; dim, dim &gt;</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a92326c330a7cac5981f8418bf63af7af"><div class="ttname"><a href="geometry__info__0_8txt.html#a92326c330a7cac5981f8418bf63af7af">orientation</a></div><div class="ttdeci">if then the returned values are[2.x.224] where[2.x.225] are the two three dimensional vectors that are tangential to the quad mapped into three dimensional space This function is used in order to determine how distorted a cell this field stores the coordinate direction in which its normal vector points In&lt; tt &gt; dim&lt;/tt &gt; dimension these are the&lt; tt &gt; *dim&lt;/tt &gt; first entries corresponding to a normal vector pointing in the positive or negative coordinate respectively Note that this is only the[2.x.227] standard orientation[2.x.228] of faces At least actual faces of cells in a triangulation can also have the opposite orientation</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00566">geometry_info_0.txt:566</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a2e10aeb1c8e76110a84b6945eac3aaf0"><div class="ttname"><a href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a></div><div class="ttdeci">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, Point&lt; dim &gt; &gt; find_active_cell_around_point(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const Point&lt; spacedim &gt; &amp;p, const std::vector&lt; bool &gt; &amp;marked_vertices={}, const double tolerance=1.e-10)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools__dof__handlers_8cc_source.html#l00436">grid_tools_dof_handlers.cc:436</a></div></div>
<div class="ttc" id="afe__raviart__thomas__0_8txt_html_abddfd52613d27285fd6ca5d28773658d"><div class="ttname"><a href="fe__raviart__thomas__0_8txt.html#abddfd52613d27285fd6ca5d28773658d">face_rotation</a></div><div class="ttdeci">ii the shape functions are defined so that certain integrals over the faces are either zero or rather than the common case of certain point values being either zero or the degree of the element denotes the polynomial degree of the[1.x.1] contained in the finite element even if the space may contain shape functions of higher polynomial degree The lowest order element is consequently i the Raviart Thomas element of degree even though the functions of this space are in general polynomials of degree one in each variable This choice of degree implies that the approximation order of the function itself as with usual polynomial spaces The numbering so chosen implies the sequence *[1.x.3] This class is not implemented for the codimension one the[2.x.7] node values are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials Since the normal trace of the RT space of degree[1.x.6] on an edge face is the the moments are taken with respect to this space **Higher order RT spaces have interior nodes These are moments taken with respect to the gradient of functions in[1.x.9] on the which will be computed by quadrature rules themselves The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy The points needed are those of QGauss&lt; sub &gt; k&lt;/sub &gt; on each face as well as QGauss&lt; sub &gt; k&lt;/sub &gt; in the interior of the with[2.x.9] and[2.x.10] replaced by appropriate values **This function returns[2.x.11] if the shape function[2.x.12] has non zero function values somewhere on the face[2.x.13] Right this is only implemented for RT0 in returns always *[2.x.14] *Return a list of constant modes of the element This method is currently not correctly implemented because it returns ones for all components **Only for internal use Its full name is[2.x.15] function and it creates the[2.x.16] vector that is needed within the constructor to be passed to the constructor of[2.x.17] FiniteElementData **Initialize the[2.x.18] field of the FiniteElement class and fill the tables with interpolation this restriction face_rotation</div><div class="ttdef"><b>Definition:</b> <a href="fe__raviart__thomas__0_8txt_source.html#l00043">fe_raviart_thomas_0.txt:43</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_a1a9fea1222a1f75ee681b6805de5f7fc"><div class="ttname"><a href="distributed__0_8txt.html#a1a9fea1222a1f75ee681b6805de5f7fc">mesh</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire mesh</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aclassTriaActiveIterator_html"><div class="ttname"><a href="classTriaActiveIterator.html">TriaActiveIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria__iterator_8h_source.html#l00749">tria_iterator.h:749</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a30077cfce9e6234e386fbd4286bc2dd7"><div class="ttname"><a href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">GridTools::extract_used_vertices</a></div><div class="ttdeci">std::map&lt; unsigned int, Point&lt; spacedim &gt; &gt; extract_used_vertices(const Triangulation&lt; dim, spacedim &gt; &amp;container, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l06210">grid_tools.cc:6210</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a212e99cf0d923cebfa04f1d23fa60b04"><div class="ttname"><a href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a></div><div class="ttdeci">void transform(const Transformation &amp;transformation, Triangulation&lt; dim, spacedim &gt; &amp;triangulation)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="agroup__manifold_html_ga1f1ea841946c94c079388ecf9ad2c00c"><div class="ttname"><a href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">Triangulation::set_all_manifold_ids_on_boundary</a></div><div class="ttdeci">void set_all_manifold_ids_on_boundary(const types::manifold_id number)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8cc_source.html#l10201">tria.cc:10201</a></div></div>
<div class="ttc" id="amutable__bind__0_8txt_html_a5a49c39376217ea6431e7e112013da28"><div class="ttname"><a href="mutable__bind__0_8txt.html#a5a49c39376217ea6431e7e112013da28">tuple</a></div><div class="ttdeci">*A version of[2.x.0] that binds all arguments of a function pointer to a stored tuple</div><div class="ttdef"><b>Definition:</b> <a href="mutable__bind__0_8txt_source.html#l00002">mutable_bind_0.txt:2</a></div></div>
<div class="ttc" id="asparse__vanka__0_8txt_html_a96771f1712564cc2701caa2fdfb4965d"><div class="ttname"><a href="sparse__vanka__0_8txt.html#a96771f1712564cc2701caa2fdfb4965d">vector&lt; bool &gt;</a></div><div class="ttdeci">this elimination is done by the modification of the right hand and in the end these degrees of freedom do not occur in the matrix and solution vector any more at all *This system is solved and the values are updated into the destination vector the matrices are built up such that the degree of freedom associated with the Lagrange multiplier is the first one usually the upper left entry in the matrix is zero It is not clear to so it must persist longer than the Vanka object The same is true for the matrix The matrix[2.x.11] which is passed here may or may not be the same matrix for which this object shall act as preconditioner In it is conceivable that the preconditioner is build up for one matrix but is used for subsequent steps in a nonlinear process as where the matrix changes in each step slightly **Destructor Delete all allocated matrices **Parameters for SparseVanka **Constructor For the parameters see below **Constructor For the parameters see below[2.x.12] The use of this constructor is deprecated **the second and third parameters are ignored **Indices of those degrees of freedom that we shall work on **If the default constructor is used then this function needs to be called before an object of this class is used as preconditioner For more detail about possible parameters see the class documentation and the documentation of the[2.x.13] class After this function is called the preconditioner is ready to be only values for allowed indices are written to[2.x.27] so the application of this function only does what is announced in the general documentation if the given mask sets all values to zero The reason for providing the mask anyway is that in derived classes we may want to apply the preconditioner to parts of the matrix in order to parallelize the application it is important to only write to some slices of[2.x.28] in order to eliminate the dependencies of threads of each other If a null pointer is passed instead of a pointer to then it is assumed that we shall work on all degrees of freedom This is then equivalent to calling the function with a&lt; tt &gt; vector&lt; bool &gt;(n_dofs, true)&lt;/tt &gt;. The[2.x.30] of this class of course calls this function with a null pointer *[0.x.17] *Determine an estimate for the memory consumption(in bytes) of this object. *[0.x.18] *Pointer to the matrix. *[0.x.19] *Indices of those degrees of freedom that we shall work on. *[0.x.20] *Array of inverse matrices</div></div>
<div class="ttc" id="anamespaceGridTools_html_aef086f558e9e1c6148e3fa8c62e7a066"><div class="ttname"><a href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">GridTools::find_all_active_cells_around_point</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, Point&lt; dim &gt; &gt; &gt; find_all_active_cells_around_point(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const Point&lt; spacedim &gt; &amp;p, const double tolerance, const std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, Point&lt; dim &gt;&gt; &amp;first_cell)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools__dof__handlers_8cc_source.html#l00599">grid_tools_dof_handlers.cc:599</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a3c7e76b7aa721e073bb9d0a192b85df2"><div class="ttname"><a href="geometry__info__0_8txt.html#a3c7e76b7aa721e073bb9d0a192b85df2">face_orientation</a></div><div class="ttdeci">false&lt;/tt &gt; argument. *The information which child cell is at which position of which face is most often used when computing jump terms across faces with hanging nodes, using objects of type FESubfaceValues. Sitting on one cell, you would look at a face and figure out which child of the neighbor is sitting on a given subface between the present and the neighboring cell. To avoid having to query the standard orientation of the faces of the two cells every time in such cases, you should use a function call like&lt; tt &gt;cell-&gt;neighbor_child_on_subface(face_no, subface_no)&lt;/tt &gt;, which returns the correct result both in 2d(where face orientations are immaterial) and 3d(where it is necessary to use the face orientation as additional argument to[2.x.142] *For anisotropic refinement, the child cells can not be numbered according to adjacent vertices, thus the following conventions are used:**[1.x.27] ****[1.x.28] ****[1.x.29] ****[1.x.30] ****[1.x.31] ****[1.x.32] **This information can also be obtained by the[2.x.143] function. *[1.x.33] *We define the following coordinate system for the explicit coordinates of the vertices of the unit cell:**[1.x.34] **By the convention laid down as above, the vertices have the following coordinates(lexicographic, with x running fastest):[2.x.144][2.x.145] Vertex 0:&lt; tt &gt;(0, 0, 0)&lt;/tt &gt; face_orientation</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00444">geometry_info_0.txt:444</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
