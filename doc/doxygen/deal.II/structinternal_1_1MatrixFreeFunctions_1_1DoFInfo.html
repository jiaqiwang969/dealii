<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: internal::MatrixFreeFunctions::DoFInfo Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceinternal.html">internal</a></li><li class="navelem"><a class="el" href="namespaceinternal_1_1MatrixFreeFunctions.html">MatrixFreeFunctions</a></li><li class="navelem"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">internal::MatrixFreeFunctions::DoFInfo Struct Reference<div class="ingroups"><a class="el" href="group__matrixfree.html">Matrix-free infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix__free_2dof__info_8h_source.html">deal.II/matrix_free/dof_info.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">IndexStorageVariants</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>
<br />
 }</td></tr>
<tr class="separator:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d58d76ae885e59efcf6a0c307d744e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">DoFAccessIndex</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2
<br />
 }</td></tr>
<tr class="separator:a05d58d76ae885e59efcf6a0c307d744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">IndexStorageVariants</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>
<br />
 }</td></tr>
<tr class="separator:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d58d76ae885e59efcf6a0c307d744e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">DoFAccessIndex</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2
<br />
 }</td></tr>
<tr class="separator:a05d58d76ae885e59efcf6a0c307d744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">IndexStorageVariants</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0">IndexStorageVariants::full</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d">IndexStorageVariants::interleaved_contiguous</a>, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64">IndexStorageVariants::interleaved_contiguous_strided</a>, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b">IndexStorageVariants::interleaved_contiguous_mixed_strides</a>
<br />
 }</td></tr>
<tr class="separator:a6369c97edd8ea0d2cd7c028b20ee8f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d58d76ae885e59efcf6a0c307d744e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">DoFAccessIndex</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55">dof_access_face_interior</a> = 0, 
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2">dof_access_face_exterior</a> = 1, 
<br />
&#160;&#160;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e">dof_access_cell</a> = 2
<br />
 }</td></tr>
<tr class="separator:a05d58d76ae885e59efcf6a0c307d744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21d81f1240fc58b90fb26cd108b9531c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a21d81f1240fc58b90fb26cd108b9531c">DoFInfo</a> ()</td></tr>
<tr class="separator:a21d81f1240fc58b90fb26cd108b9531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78878121c845c9cb0d18482aeca1b26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ab78878121c845c9cb0d18482aeca1b26">DoFInfo</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ab78878121c845c9cb0d18482aeca1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97772de07b255ab66a1cb4932b4c845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#af97772de07b255ab66a1cb4932b4c845">DoFInfo</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:af97772de07b255ab66a1cb4932b4c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005463048738bbb7814b4e581f34efe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a005463048738bbb7814b4e581f34efe3">~DoFInfo</a> ()=default</td></tr>
<tr class="separator:a005463048738bbb7814b4e581f34efe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a2d809c363447d4ecafee2f915073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ad40a2d809c363447d4ecafee2f915073">operator=</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ad40a2d809c363447d4ecafee2f915073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a7b1aa91b3929c27da3aac7474e5a6fa9">operator=</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38858344192a7f84707e4bf924b5d9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a38858344192a7f84707e4bf924b5d9a9">clear</a> ()</td></tr>
<tr class="separator:a38858344192a7f84707e4bf924b5d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de471c386cdaa3b88906599db12f4e1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3de471c386cdaa3b88906599db12f4e1">fe_index_from_degree</a> (const unsigned <a class="el" href="classint.html">int</a> first_selected_component, const unsigned <a class="el" href="classint.html">int</a> fe_degree) const</td></tr>
<tr class="separator:a3de471c386cdaa3b88906599db12f4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaae471fd6ff7a2cecaac81736a60771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#abaae471fd6ff7a2cecaac81736a60771">get_dof_indices_on_cell_batch</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;locall_indices, const unsigned <a class="el" href="classint.html">int</a> cell, const <a class="el" href="classbool.html">bool</a> with_constraints=true) const</td></tr>
<tr class="separator:abaae471fd6ff7a2cecaac81736a60771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aae4d1ade3752808df2f15882eef27e6d">read_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;local_indices, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;lexicographic_inv, const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const unsigned <a class="el" href="classint.html">int</a> cell_number, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_values, <a class="el" href="classbool.html">bool</a> &amp;cell_at_boundary)</td></tr>
<tr class="separator:aae4d1ade3752808df2f15882eef27e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7609137d338d9dba9f71b955ef5be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a9cf7609137d338d9dba9f71b955ef5be">assign_ghosts</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;boundary_cells, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:a9cf7609137d338d9dba9f71b955ef5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065a9af6526fabb0f734401bd4d9f761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a065a9af6526fabb0f734401bd4d9f761">reorder_cells</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a065a9af6526fabb0f734401bd4d9f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3f9c294edfcbc88ce9917f71cb53e722">compute_cell_index_compression</a> (const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a2440d06b3b672c6f027b2e2b5bc726e4">compute_face_index_compression</a> (const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ae1e4e70a1c48646db1723d8874ec13dd">make_connectivity_graph</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity) const</td></tr>
<tr class="separator:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aa9e9b2d975825f1f7d311fd014a4ba43">compute_tight_partitioners</a> (const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;shape_info, const unsigned <a class="el" href="classint.html">int</a> n_owned_cells, const unsigned <a class="el" href="classint.html">int</a> n_lanes, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;inner_faces, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;ghosted_faces, const <a class="el" href="classbool.html">bool</a> fill_cell_centric, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551317c655f02a56ad38888adaafaff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a551317c655f02a56ad38888adaafaff0">compute_shared_memory_contiguous_indices</a> (std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;cell_indices_contiguous_sm)</td></tr>
<tr class="separator:a551317c655f02a56ad38888adaafaff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5745c4934cc344a4b466f493b37f7449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5745c4934cc344a4b466f493b37f7449">compute_dof_renumbering</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering)</td></tr>
<tr class="separator:a5745c4934cc344a4b466f493b37f7449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a1a7106b8b9e9c0cb68b2368c83c79e50">compute_vector_zero_access_pattern</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853239498bd0538bfa4a8d4e9fae80be"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a853239498bd0538bfa4a8d4e9fae80be">memory_consumption</a> () const</td></tr>
<tr class="separator:a853239498bd0538bfa4a8d4e9fae80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a65280e0f83efa154c59689ec66f2a7cb">print_memory_consumption</a> (StreamType &amp;out, const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;size_info) const</td></tr>
<tr class="separator:a65280e0f83efa154c59689ec66f2a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a0e06543035320ffb26149ddf0d2893a9">print</a> (const std::vector&lt; Number &gt; &amp;constraint_pool_data, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, std::ostream &amp;out) const</td></tr>
<tr class="separator:a0e06543035320ffb26149ddf0d2893a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d81f1240fc58b90fb26cd108b9531c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a21d81f1240fc58b90fb26cd108b9531c">DoFInfo</a> ()</td></tr>
<tr class="separator:a21d81f1240fc58b90fb26cd108b9531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78878121c845c9cb0d18482aeca1b26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ab78878121c845c9cb0d18482aeca1b26">DoFInfo</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ab78878121c845c9cb0d18482aeca1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97772de07b255ab66a1cb4932b4c845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#af97772de07b255ab66a1cb4932b4c845">DoFInfo</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:af97772de07b255ab66a1cb4932b4c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005463048738bbb7814b4e581f34efe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a005463048738bbb7814b4e581f34efe3">~DoFInfo</a> ()=default</td></tr>
<tr class="separator:a005463048738bbb7814b4e581f34efe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a2d809c363447d4ecafee2f915073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ad40a2d809c363447d4ecafee2f915073">operator=</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ad40a2d809c363447d4ecafee2f915073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a7b1aa91b3929c27da3aac7474e5a6fa9">operator=</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38858344192a7f84707e4bf924b5d9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a38858344192a7f84707e4bf924b5d9a9">clear</a> ()</td></tr>
<tr class="separator:a38858344192a7f84707e4bf924b5d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de471c386cdaa3b88906599db12f4e1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3de471c386cdaa3b88906599db12f4e1">fe_index_from_degree</a> (const unsigned <a class="el" href="classint.html">int</a> first_selected_component, const unsigned <a class="el" href="classint.html">int</a> fe_degree) const</td></tr>
<tr class="separator:a3de471c386cdaa3b88906599db12f4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaae471fd6ff7a2cecaac81736a60771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#abaae471fd6ff7a2cecaac81736a60771">get_dof_indices_on_cell_batch</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;locall_indices, const unsigned <a class="el" href="classint.html">int</a> cell, const <a class="el" href="classbool.html">bool</a> with_constraints=true) const</td></tr>
<tr class="separator:abaae471fd6ff7a2cecaac81736a60771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aae4d1ade3752808df2f15882eef27e6d">read_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;local_indices, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;lexicographic_inv, const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const unsigned <a class="el" href="classint.html">int</a> cell_number, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_values, <a class="el" href="classbool.html">bool</a> &amp;cell_at_boundary)</td></tr>
<tr class="separator:aae4d1ade3752808df2f15882eef27e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7609137d338d9dba9f71b955ef5be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a9cf7609137d338d9dba9f71b955ef5be">assign_ghosts</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;boundary_cells, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:a9cf7609137d338d9dba9f71b955ef5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065a9af6526fabb0f734401bd4d9f761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a065a9af6526fabb0f734401bd4d9f761">reorder_cells</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a065a9af6526fabb0f734401bd4d9f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3f9c294edfcbc88ce9917f71cb53e722">compute_cell_index_compression</a> (const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a2440d06b3b672c6f027b2e2b5bc726e4">compute_face_index_compression</a> (const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ae1e4e70a1c48646db1723d8874ec13dd">make_connectivity_graph</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity) const</td></tr>
<tr class="separator:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aa9e9b2d975825f1f7d311fd014a4ba43">compute_tight_partitioners</a> (const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;shape_info, const unsigned <a class="el" href="classint.html">int</a> n_owned_cells, const unsigned <a class="el" href="classint.html">int</a> n_lanes, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;inner_faces, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;ghosted_faces, const <a class="el" href="classbool.html">bool</a> fill_cell_centric, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551317c655f02a56ad38888adaafaff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a551317c655f02a56ad38888adaafaff0">compute_shared_memory_contiguous_indices</a> (std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;cell_indices_contiguous_sm)</td></tr>
<tr class="separator:a551317c655f02a56ad38888adaafaff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5745c4934cc344a4b466f493b37f7449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5745c4934cc344a4b466f493b37f7449">compute_dof_renumbering</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering)</td></tr>
<tr class="separator:a5745c4934cc344a4b466f493b37f7449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a1a7106b8b9e9c0cb68b2368c83c79e50">compute_vector_zero_access_pattern</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853239498bd0538bfa4a8d4e9fae80be"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a853239498bd0538bfa4a8d4e9fae80be">memory_consumption</a> () const</td></tr>
<tr class="separator:a853239498bd0538bfa4a8d4e9fae80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a65280e0f83efa154c59689ec66f2a7cb">print_memory_consumption</a> (StreamType &amp;out, const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;size_info) const</td></tr>
<tr class="separator:a65280e0f83efa154c59689ec66f2a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a0e06543035320ffb26149ddf0d2893a9">print</a> (const std::vector&lt; Number &gt; &amp;constraint_pool_data, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, std::ostream &amp;out) const</td></tr>
<tr class="separator:a0e06543035320ffb26149ddf0d2893a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d81f1240fc58b90fb26cd108b9531c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a21d81f1240fc58b90fb26cd108b9531c">DoFInfo</a> ()</td></tr>
<tr class="separator:a21d81f1240fc58b90fb26cd108b9531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78878121c845c9cb0d18482aeca1b26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ab78878121c845c9cb0d18482aeca1b26">DoFInfo</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ab78878121c845c9cb0d18482aeca1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97772de07b255ab66a1cb4932b4c845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#af97772de07b255ab66a1cb4932b4c845">DoFInfo</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:af97772de07b255ab66a1cb4932b4c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005463048738bbb7814b4e581f34efe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a005463048738bbb7814b4e581f34efe3">~DoFInfo</a> ()=default</td></tr>
<tr class="separator:a005463048738bbb7814b4e581f34efe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a2d809c363447d4ecafee2f915073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ad40a2d809c363447d4ecafee2f915073">operator=</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;)=default</td></tr>
<tr class="separator:ad40a2d809c363447d4ecafee2f915073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a7b1aa91b3929c27da3aac7474e5a6fa9">operator=</a> (<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7b1aa91b3929c27da3aac7474e5a6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38858344192a7f84707e4bf924b5d9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a38858344192a7f84707e4bf924b5d9a9">clear</a> ()</td></tr>
<tr class="separator:a38858344192a7f84707e4bf924b5d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de471c386cdaa3b88906599db12f4e1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3de471c386cdaa3b88906599db12f4e1">fe_index_from_degree</a> (const unsigned <a class="el" href="classint.html">int</a> first_selected_component, const unsigned <a class="el" href="classint.html">int</a> fe_degree) const</td></tr>
<tr class="separator:a3de471c386cdaa3b88906599db12f4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaae471fd6ff7a2cecaac81736a60771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#abaae471fd6ff7a2cecaac81736a60771">get_dof_indices_on_cell_batch</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;locall_indices, const unsigned <a class="el" href="classint.html">int</a> cell, const <a class="el" href="classbool.html">bool</a> with_constraints=true) const</td></tr>
<tr class="separator:abaae471fd6ff7a2cecaac81736a60771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:aae4d1ade3752808df2f15882eef27e6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aae4d1ade3752808df2f15882eef27e6d">read_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;local_indices, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;lexicographic_inv, const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const unsigned <a class="el" href="classint.html">int</a> cell_number, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_values, <a class="el" href="classbool.html">bool</a> &amp;cell_at_boundary)</td></tr>
<tr class="separator:aae4d1ade3752808df2f15882eef27e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7609137d338d9dba9f71b955ef5be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a9cf7609137d338d9dba9f71b955ef5be">assign_ghosts</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;boundary_cells, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:a9cf7609137d338d9dba9f71b955ef5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065a9af6526fabb0f734401bd4d9f761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a065a9af6526fabb0f734401bd4d9f761">reorder_cells</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a065a9af6526fabb0f734401bd4d9f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3f9c294edfcbc88ce9917f71cb53e722">compute_cell_index_compression</a> (const std::vector&lt; unsigned char &gt; &amp;irregular_cells)</td></tr>
<tr class="separator:a3f9c294edfcbc88ce9917f71cb53e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a2440d06b3b672c6f027b2e2b5bc726e4">compute_face_index_compression</a> (const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a2440d06b3b672c6f027b2e2b5bc726e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ae1e4e70a1c48646db1723d8874ec13dd">make_connectivity_graph</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity) const</td></tr>
<tr class="separator:ae1e4e70a1c48646db1723d8874ec13dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aa9e9b2d975825f1f7d311fd014a4ba43">compute_tight_partitioners</a> (const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;shape_info, const unsigned <a class="el" href="classint.html">int</a> n_owned_cells, const unsigned <a class="el" href="classint.html">int</a> n_lanes, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;inner_faces, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;ghosted_faces, const <a class="el" href="classbool.html">bool</a> fill_cell_centric, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator_sm, const <a class="el" href="classbool.html">bool</a> use_vector_data_exchanger_full)</td></tr>
<tr class="separator:aa9e9b2d975825f1f7d311fd014a4ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551317c655f02a56ad38888adaafaff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a551317c655f02a56ad38888adaafaff0">compute_shared_memory_contiguous_indices</a> (std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;cell_indices_contiguous_sm)</td></tr>
<tr class="separator:a551317c655f02a56ad38888adaafaff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5745c4934cc344a4b466f493b37f7449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5745c4934cc344a4b466f493b37f7449">compute_dof_renumbering</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering)</td></tr>
<tr class="separator:a5745c4934cc344a4b466f493b37f7449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplParams" colspan="2">template&lt;int length&gt; </td></tr>
<tr class="memitem:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a1a7106b8b9e9c0cb68b2368c83c79e50">compute_vector_zero_access_pattern</a> (const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;task_info, const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;faces)</td></tr>
<tr class="separator:a1a7106b8b9e9c0cb68b2368c83c79e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853239498bd0538bfa4a8d4e9fae80be"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a853239498bd0538bfa4a8d4e9fae80be">memory_consumption</a> () const</td></tr>
<tr class="separator:a853239498bd0538bfa4a8d4e9fae80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a65280e0f83efa154c59689ec66f2a7cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a65280e0f83efa154c59689ec66f2a7cb">print_memory_consumption</a> (StreamType &amp;out, const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;size_info) const</td></tr>
<tr class="separator:a65280e0f83efa154c59689ec66f2a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a0e06543035320ffb26149ddf0d2893a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a0e06543035320ffb26149ddf0d2893a9">print</a> (const std::vector&lt; Number &gt; &amp;constraint_pool_data, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;constraint_pool_row_index, std::ostream &amp;out) const</td></tr>
<tr class="separator:a0e06543035320ffb26149ddf0d2893a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a953d425f250ef41a844c3ab5c6e51026"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a953d425f250ef41a844c3ab5c6e51026">dimension</a></td></tr>
<tr class="separator:a953d425f250ef41a844c3ab5c6e51026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a63e0b4346f8c4e0a2092bf8272320"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a58a63e0b4346f8c4e0a2092bf8272320">vectorization_length</a></td></tr>
<tr class="separator:a58a63e0b4346f8c4e0a2092bf8272320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073bb3418c65afe7155d5b4ba4ab45d"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">IndexStorageVariants</a> &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a4073bb3418c65afe7155d5b4ba4ab45d">index_storage_variants</a></td></tr>
<tr class="separator:a4073bb3418c65afe7155d5b4ba4ab45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6589b329695ab39d6495decb13bc69c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ac6589b329695ab39d6495decb13bc69c">row_starts</a></td></tr>
<tr class="separator:ac6589b329695ab39d6495decb13bc69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c418afc10d6b55f0c5dab42d7a2970b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a3c418afc10d6b55f0c5dab42d7a2970b">dof_indices</a></td></tr>
<tr class="separator:a3c418afc10d6b55f0c5dab42d7a2970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4727218fdfd29d4efa2811030e8a8c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned short, unsigned short &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a4e4727218fdfd29d4efa2811030e8a8c">constraint_indicator</a></td></tr>
<tr class="separator:a4e4727218fdfd29d4efa2811030e8a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a215a095cd438b24a28ebb22896b8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ad7a215a095cd438b24a28ebb22896b8d">dof_indices_interleaved</a></td></tr>
<tr class="separator:ad7a215a095cd438b24a28ebb22896b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145dceaf9fda9a1ad64d93fb2b31811f"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a145dceaf9fda9a1ad64d93fb2b31811f">dof_indices_contiguous</a></td></tr>
<tr class="separator:a145dceaf9fda9a1ad64d93fb2b31811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93322f37f2d9cf9bc29ea81701ad3df7"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a93322f37f2d9cf9bc29ea81701ad3df7">dof_indices_contiguous_sm</a></td></tr>
<tr class="separator:a93322f37f2d9cf9bc29ea81701ad3df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe167e1aa9037e41bf1501fc20178908"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#afe167e1aa9037e41bf1501fc20178908">dof_indices_interleave_strides</a></td></tr>
<tr class="separator:afe167e1aa9037e41bf1501fc20178908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09302f9fcf4fbf31532ecb07d536cc99"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; unsigned char &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a09302f9fcf4fbf31532ecb07d536cc99">n_vectorization_lanes_filled</a></td></tr>
<tr class="separator:a09302f9fcf4fbf31532ecb07d536cc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5468cac6872750f4d3ea1aefd46770cc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5468cac6872750f4d3ea1aefd46770cc">vector_partitioner</a></td></tr>
<tr class="separator:a5468cac6872750f4d3ea1aefd46770cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59de4fd7794f93abfcc57c415838f7ac"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1VectorDataExchange_1_1Base.html">internal::MatrixFreeFunctions::VectorDataExchange::Base</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a59de4fd7794f93abfcc57c415838f7ac">vector_exchanger</a></td></tr>
<tr class="separator:a59de4fd7794f93abfcc57c415838f7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae450dfe53f306bd830d82dc795335c03"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::shared_ptr&lt; const <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1VectorDataExchange_1_1Base.html">internal::MatrixFreeFunctions::VectorDataExchange::Base</a> &gt;, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ae450dfe53f306bd830d82dc795335c03">vector_exchanger_face_variants</a></td></tr>
<tr class="separator:ae450dfe53f306bd830d82dc795335c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea7ac3279565124aa25b359e400b3c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5ea7ac3279565124aa25b359e400b3c8">constrained_dofs</a></td></tr>
<tr class="separator:a5ea7ac3279565124aa25b359e400b3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42555b435b16773abac60c68117ce925"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a42555b435b16773abac60c68117ce925">row_starts_plain_indices</a></td></tr>
<tr class="separator:a42555b435b16773abac60c68117ce925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880996b14e5afcc2b33b2a5f944f4d1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a880996b14e5afcc2b33b2a5f944f4d1d">plain_dof_indices</a></td></tr>
<tr class="separator:a880996b14e5afcc2b33b2a5f944f4d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a52e6cac05be6d4c9782f3375beef0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a36a52e6cac05be6d4c9782f3375beef0">global_base_element_offset</a></td></tr>
<tr class="separator:a36a52e6cac05be6d4c9782f3375beef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3fc38a5be0b3d0d05c02abe2e7754b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a2e3fc38a5be0b3d0d05c02abe2e7754b">n_base_elements</a></td></tr>
<tr class="separator:a2e3fc38a5be0b3d0d05c02abe2e7754b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c85910ea8813c205df9400a53f48f48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a5c85910ea8813c205df9400a53f48f48">n_components</a></td></tr>
<tr class="separator:a5c85910ea8813c205df9400a53f48f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795ecfd661ab94ba6cefebc543681413"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a795ecfd661ab94ba6cefebc543681413">start_components</a></td></tr>
<tr class="separator:a795ecfd661ab94ba6cefebc543681413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea0dffcb4b43065166129a4b12d3322"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a4ea0dffcb4b43065166129a4b12d3322">component_to_base_index</a></td></tr>
<tr class="separator:a4ea0dffcb4b43065166129a4b12d3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba47d7560960ed13c26957c64995e019"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#aba47d7560960ed13c26957c64995e019">component_dof_indices_offset</a></td></tr>
<tr class="separator:aba47d7560960ed13c26957c64995e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ff71f7f72b26d8fdaa768d35742cff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a14ff71f7f72b26d8fdaa768d35742cff">dofs_per_cell</a></td></tr>
<tr class="separator:a14ff71f7f72b26d8fdaa768d35742cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba75235fe8bf8397468f9657aaf0197"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#acba75235fe8bf8397468f9657aaf0197">dofs_per_face</a></td></tr>
<tr class="separator:acba75235fe8bf8397468f9657aaf0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746e2ed60aaa2dcbee14187853382211"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a746e2ed60aaa2dcbee14187853382211">store_plain_indices</a></td></tr>
<tr class="separator:a746e2ed60aaa2dcbee14187853382211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76079b289a37b0afd41145824ac6d66d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a76079b289a37b0afd41145824ac6d66d">cell_active_fe_index</a></td></tr>
<tr class="separator:a76079b289a37b0afd41145824ac6d66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b69afee93e6b4ec02e36ed0e25f6b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a389b69afee93e6b4ec02e36ed0e25f6b">max_fe_index</a></td></tr>
<tr class="separator:a389b69afee93e6b4ec02e36ed0e25f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c307b5046f01a1f94aed6187f79bbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a02c307b5046f01a1f94aed6187f79bbb">fe_index_conversion</a></td></tr>
<tr class="separator:a02c307b5046f01a1f94aed6187f79bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dec49473e137815191717f4ffc75e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a23dec49473e137815191717f4ffc75e9">ghost_dofs</a></td></tr>
<tr class="separator:a23dec49473e137815191717f4ffc75e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462c86eb6d5935fa2fa8eef84792248d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a462c86eb6d5935fa2fa8eef84792248d">vector_zero_range_list_index</a></td></tr>
<tr class="separator:a462c86eb6d5935fa2fa8eef84792248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583b90a9e2f2cd2ebcd27da53df1e67d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a583b90a9e2f2cd2ebcd27da53df1e67d">vector_zero_range_list</a></td></tr>
<tr class="separator:a583b90a9e2f2cd2ebcd27da53df1e67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9585d41f72cbd51903fa1a4f5792e1b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ac9585d41f72cbd51903fa1a4f5792e1b">cell_loop_pre_list_index</a></td></tr>
<tr class="separator:ac9585d41f72cbd51903fa1a4f5792e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c94facf5601340ba6d16b96372bd1ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a1c94facf5601340ba6d16b96372bd1ea">cell_loop_pre_list</a></td></tr>
<tr class="separator:a1c94facf5601340ba6d16b96372bd1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05306ef04310ec8d8ef1d7abae75fbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ad05306ef04310ec8d8ef1d7abae75fbb">cell_loop_post_list_index</a></td></tr>
<tr class="separator:ad05306ef04310ec8d8ef1d7abae75fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf914a8a12d3e7c84b085007f0da74c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a4cf914a8a12d3e7c84b085007f0da74c">cell_loop_post_list</a></td></tr>
<tr class="separator:a4cf914a8a12d3e7c84b085007f0da74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac67ec41e4ebafdbe56ea2c4d4be6137c"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#ac67ec41e4ebafdbe56ea2c4d4be6137c">chunk_size_zero_vector</a> = 64</td></tr>
<tr class="separator:ac67ec41e4ebafdbe56ea2c4d4be6137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class that stores the indices of the degrees of freedom for all the cells. Essentially, this is a smart number cache in the style of a <a class="el" href="classDoFHandler.html">DoFHandler</a> that also embeds the description of constraints directly on the cell level without the need to refer to the external <a class="el" href="namespaceinternal_1_1AffineConstraints.html">AffineConstraints</a> object. This class only stores index relations. The weights for hanging node constraints are stored in a different field. This is because a different field allows for the same compressed weight data on different DoFHandlers for vector-valued problems. There, the indices might be constrained differently on different components (e.g. Dirichlet conditions only on selected components), whereas the weights from hanging nodes are the same and need to be stored only once. The combination will be handled in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00100">100</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6369c97edd8ea0d2cd7c028b20ee8f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369c97edd8ea0d2cd7c028b20ee8f39">&#9670;&nbsp;</a></span>IndexStorageVariants <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">internal::MatrixFreeFunctions::DoFInfo::IndexStorageVariants</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enum for various storage variants of the indices. This storage format is used to implement more efficient indexing schemes in case the underlying data structures allow for them, and to inform the access functions in <a class="el" href="classFEEvaluationBase.html#a27779f5e7ac08bcc8c3fd1d78698ad45">FEEvaluationBase::read_write_operation()</a> on which array to get the data from. One example of more efficient storage is the enum value <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, which means that one can get the indices to all degrees of freedom of a cell by reading only the first index for each cell, whereas all subsequent indices are merely an offset from the first index. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries.</p>
<p>The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells.</p>
<p>For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00356">356</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a05d58d76ae885e59efcf6a0c307d744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d58d76ae885e59efcf6a0c307d744e">&#9670;&nbsp;</a></span>DoFAccessIndex <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum used to distinguish the data arrays for the vectorization type in cells and faces. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00452">452</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a6369c97edd8ea0d2cd7c028b20ee8f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369c97edd8ea0d2cd7c028b20ee8f39">&#9670;&nbsp;</a></span>IndexStorageVariants <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">internal::MatrixFreeFunctions::DoFInfo::IndexStorageVariants</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enum for various storage variants of the indices. This storage format is used to implement more efficient indexing schemes in case the underlying data structures allow for them, and to inform the access functions in <a class="el" href="classFEEvaluationBase.html#a27779f5e7ac08bcc8c3fd1d78698ad45">FEEvaluationBase::read_write_operation()</a> on which array to get the data from. One example of more efficient storage is the enum value <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, which means that one can get the indices to all degrees of freedom of a cell by reading only the first index for each cell, whereas all subsequent indices are merely an offset from the first index. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries.</p>
<p>The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells.</p>
<p>For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2matrix__free_2dof__info_8h_source.html#l00346">346</a> of file <a class="el" href="origin_2matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a05d58d76ae885e59efcf6a0c307d744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d58d76ae885e59efcf6a0c307d744e">&#9670;&nbsp;</a></span>DoFAccessIndex <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum used to distinguish the data arrays for the vectorization type in cells and faces. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2matrix__free_2dof__info_8h_source.html#l00433">433</a> of file <a class="el" href="origin_2matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a6369c97edd8ea0d2cd7c028b20ee8f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369c97edd8ea0d2cd7c028b20ee8f39">&#9670;&nbsp;</a></span>IndexStorageVariants <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">internal::MatrixFreeFunctions::DoFInfo::IndexStorageVariants</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enum for various storage variants of the indices. This storage format is used to implement more efficient indexing schemes in case the underlying data structures allow for them, and to inform the access functions in <a class="el" href="classFEEvaluationBase.html#a27779f5e7ac08bcc8c3fd1d78698ad45">FEEvaluationBase::read_write_operation()</a> on which array to get the data from. One example of more efficient storage is the enum value <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>, which means that one can get the indices to all degrees of freedom of a cell by reading only the first index for each cell, whereas all subsequent indices are merely an offset from the first index. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries.</p>
<p>The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells.</p>
<p>For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>This value indicates that no index compression was found and the only valid storage is to access all indices present on the cell, possibly including constraints. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623"></a>interleaved&#160;</td><td class="fielddoc"><p>This value indicates that the indices are interleaved for access with vectorized gather and scatter operation. This storage variant is possible in case there are no constraints on the cell and the indices in the batch of cells are not pointing to the same global index in different slots of a vectorized array (in order to support scatter operations). For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_interleaved</code> with the index <code>row_starts[cell_index*n_vectorization*n_components].first</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623"></a>contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices within a cell are all contiguous, and one can get the index to the cell by reading that single value for each of the cells in the cell batch. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a6a03c5a5755c72ea37b308c011d9808d"></a>interleaved_contiguous&#160;</td><td class="fielddoc"><p>This value indicates that the indices with a cell are contiguous and interleaved for vectorization, i.e., the first DoF index on a cell to the four or eight cells in the vectorization batch come first, than the second DoF index, and so on. Furthermore, the interleaving between cells implies that only the batches for vectorization can be accessed efficiently, whereas there is a strided access for getting only some of the entries. The two additional categories <code>interleaved_contiguous_strided</code> and <code>interleaved_contiguous_mixed_strides</code> are a consequence of this storage type. The former is for faces where at least one of the two adjacent sides will break with the interleaved storage. We then have to make a strided access as described in the next category. The last category <code>interleaved_contiguous_mixed_strides</code> appears in the ghost layer, see the more detailed description of that category below. Again, this is something that cannot be avoided in general once we interleave the indices between cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39a215da70e1b01f5bf761278af7b11df64"></a>interleaved_contiguous_strided&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous storage, but for the case when the interleaved indices are only contiguous within the degrees of freedom, but not also over the components of a vectorized array. This happens typically on faces with DG where the cells have <code>interleaved_contiguous</code> storage but the faces' numbering is not the same as the cell's numbering. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6369c97edd8ea0d2cd7c028b20ee8f39ab2def76ca33445e9920e5f67f336920b"></a>interleaved_contiguous_mixed_strides&#160;</td><td class="fielddoc"><p>Similar to interleaved_contiguous_separate storage, but for the case when the interleaved indices are not <code>n_vectorization apart</code>. This happens typically within the ghost layer of DG where the remote owner has applied an interleaved storage and the current processor only sees some of the cells. For a cell/face of this index type, the data access in <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> is directed to the array <code>dof_indices_contiguous</code> with the index <code>cell_index*n_vectorization*n_components</code>, including the array <code>dof_indices_interleave_strides</code> for the information about the actual stride. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2matrix__free_2dof__info_8h_source.html#l00356">356</a> of file <a class="el" href="translator_2matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a05d58d76ae885e59efcf6a0c307d744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d58d76ae885e59efcf6a0c307d744e">&#9670;&nbsp;</a></span>DoFAccessIndex <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum used to distinguish the data arrays for the vectorization type in cells and faces. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744ea1abe832f6892f7d5bf05a659bff42c55"></a>dof_access_face_interior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as interior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eadba30ca4e1abe319aa7fdf9b9d3ce5a2"></a>dof_access_face_exterior&#160;</td><td class="fielddoc"><p>The data index for the faces designated as exterior </p>
</td></tr>
<tr><td class="fieldname"><a id="a05d58d76ae885e59efcf6a0c307d744eaef8c1bef0f8af3ebf122fb893a88125e"></a>dof_access_cell&#160;</td><td class="fielddoc"><p>The data index for the cells </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2matrix__free_2dof__info_8h_source.html#l00452">452</a> of file <a class="el" href="translator_2matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21d81f1240fc58b90fb26cd108b9531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d81f1240fc58b90fb26cd108b9531c">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00031">31</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="ab78878121c845c9cb0d18482aeca1b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78878121c845c9cb0d18482aeca1b26">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="af97772de07b255ab66a1cb4932b4c845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97772de07b255ab66a1cb4932b4c845">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="a005463048738bbb7814b4e581f34efe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005463048738bbb7814b4e581f34efe3">&#9670;&nbsp;</a></span>~DoFInfo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::~DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a21d81f1240fc58b90fb26cd108b9531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d81f1240fc58b90fb26cd108b9531c">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. </p>

</div>
</div>
<a id="ab78878121c845c9cb0d18482aeca1b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78878121c845c9cb0d18482aeca1b26">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="af97772de07b255ab66a1cb4932b4c845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97772de07b255ab66a1cb4932b4c845">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="a005463048738bbb7814b4e581f34efe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005463048738bbb7814b4e581f34efe3">&#9670;&nbsp;</a></span>~DoFInfo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::~DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a21d81f1240fc58b90fb26cd108b9531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d81f1240fc58b90fb26cd108b9531c">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. </p>

</div>
</div>
<a id="ab78878121c845c9cb0d18482aeca1b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78878121c845c9cb0d18482aeca1b26">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="af97772de07b255ab66a1cb4932b4c845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97772de07b255ab66a1cb4932b4c845">&#9670;&nbsp;</a></span>DoFInfo() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::DoFInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="a005463048738bbb7814b4e581f34efe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005463048738bbb7814b4e581f34efe3">&#9670;&nbsp;</a></span>~DoFInfo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::MatrixFreeFunctions::DoFInfo::~DoFInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad40a2d809c363447d4ecafee2f915073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a2d809c363447d4ecafee2f915073">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator. </p>

</div>
</div>
<a id="a7b1aa91b3929c27da3aac7474e5a6fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1aa91b3929c27da3aac7474e5a6fa9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a38858344192a7f84707e4bf924b5d9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38858344192a7f84707e4bf924b5d9a9">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all data fields in this class. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00039">39</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a3de471c386cdaa3b88906599db12f4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de471c386cdaa3b88906599db12f4e1">&#9670;&nbsp;</a></span>fe_index_from_degree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::fe_index_from_degree </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the FE index for a given finite element degree. If not in hp- mode, this function always returns index 0. If an index is not found in hp-mode, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. </p>

</div>
</div>
<a id="abaae471fd6ff7a2cecaac81736a60771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaae471fd6ff7a2cecaac81736a60771">&#9670;&nbsp;</a></span>get_dof_indices_on_cell_batch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::get_dof_indices_on_cell_batch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locall_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_constraints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the vector <code>locall_indices</code> with locally owned degrees of freedom stored on the cell block <code>cell</code>. If <code>with_constraints</code> is <code>true</code>, then the returned vector will contain indices required to resolve constraints. The image below illustrates the output of this function for cell blocks zero and one with zero Dirichlet boundary conditions at the bottom of the domain. Note that due to the presence of constraints, the DoFs returned by this function for the case <code>with_constraints = true</code> are not a simple union of per cell DoFs on the cell block <code>cell</code>. </p><div class="image">
<img src="dofinfo_get_dof_indices.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>The returned indices may contain duplicates. The unique set can be obtain using <code>std::sort()</code> followed by <code>std::unique()</code> and <code>std::vector::erase()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00073">73</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="aae4d1ade3752808df2f15882eef27e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4d1ade3752808df2f15882eef27e6d">&#9670;&nbsp;</a></span>read_dof_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::read_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lexicographic_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_at_boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This internal method takes the local indices on a cell and fills them into this class. It resolves the constraints and distributes the results. Ghost indices, i.e., indices that are located on another processor, get a temporary number by this function, and will later be assigned the correct index after all the ghost indices have been collected by the call to <code>assign_ghosts</code>. </p>

</div>
</div>
<a id="a9cf7609137d338d9dba9f71b955ef5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7609137d338d9dba9f71b955ef5be">&#9670;&nbsp;</a></span>assign_ghosts() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::assign_ghosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method assigns the correct indices to ghost indices from the temporary numbering employed by the <code>read_dof_indices</code> function. The numbers are localized with respect to the MPI process, and ghosts start at the end of the locally owned range. This way, we get direct access to all vector entries. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00141">141</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a065a9af6526fabb0f734401bd4d9f761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065a9af6526fabb0f734401bd4d9f761">&#9670;&nbsp;</a></span>reorder_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::reorder_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method reorders the way cells are gone through based on a given renumbering of the cells. It also takes <code>vectorization_length</code> cells together and interprets them as one cell only, as is needed for vectorization. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00271">271</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a3f9c294edfcbc88ce9917f71cb53e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9c294edfcbc88ce9917f71cb53e722">&#9670;&nbsp;</a></span>compute_cell_index_compression() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_cell_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the cell indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00473">473</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a2440d06b3b672c6f027b2e2b5bc726e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2440d06b3b672c6f027b2e2b5bc726e4">&#9670;&nbsp;</a></span>compute_face_index_compression() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_face_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the face indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

</div>
</div>
<a id="ae1e4e70a1c48646db1723d8874ec13dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e4e70a1c48646db1723d8874ec13dd">&#9670;&nbsp;</a></span>make_connectivity_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::make_connectivity_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the connectivity of the currently stored indices in terms of connections between the individual cells and fills the structure into a sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l01302">1302</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="aa9e9b2d975825f1f7d311fd014a4ba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e9b2d975825f1f7d311fd014a4ba43">&#9670;&nbsp;</a></span>compute_tight_partitioners() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_tight_partitioners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_owned_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_lanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ghosted_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>fill_cell_centric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case face integrals are enabled, find out whether certain loops over the unknowns only access a subset of all the ghost dofs we keep in the main partitioner. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l00803">803</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a551317c655f02a56ad38888adaafaff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551317c655f02a56ad38888adaafaff0">&#9670;&nbsp;</a></span>compute_shared_memory_contiguous_indices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_shared_memory_contiguous_indices </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_indices_contiguous_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>cell_indices_contiguous_sm</code> containing the local index of cells of macro faces (inner/outer) and macro faces compute dof_indices_contiguous_sm. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l01153">1153</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a5745c4934cc344a4b466f493b37f7449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5745c4934cc344a4b466f493b37f7449">&#9670;&nbsp;</a></span>compute_dof_renumbering() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_dof_renumbering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a renumbering of the degrees of freedom to improve the data access patterns for this class that can be utilized by the categories in the IndexStorageVariants enum. For example, the index ordering can be improved for typical DG elements by interleaving the degrees of freedom from batches of cells, which avoids the explicit data transposition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>. Currently, these more advanced features are not implemented, so there is only limited value of this function. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l01379">1379</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a1a7106b8b9e9c0cb68b2368c83c79e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7106b8b9e9c0cb68b2368c83c79e50">&#9670;&nbsp;</a></span>compute_vector_zero_access_pattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_vector_zero_access_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the array that defines how to zero selected ranges in the result vector within the cell loop, filling the two member variables <code>vector_zero_range_list_index</code> and <code>vector_zero_range_list</code>. The intent of this pattern is to zero the vector entries in close temporal proximity to the first access and thus keeping the vector entries in cache. </p>

</div>
</div>
<a id="a853239498bd0538bfa4a8d4e9fae80be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853239498bd0538bfa4a8d4e9fae80be">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t internal::MatrixFreeFunctions::DoFInfo::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption in bytes of this class. </p>

<p class="definition">Definition at line <a class="el" href="dof__info_8cc_source.html#l01437">1437</a> of file <a class="el" href="dof__info_8cc_source.html">dof_info.cc</a>.</p>

</div>
</div>
<a id="a65280e0f83efa154c59689ec66f2a7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65280e0f83efa154c59689ec66f2a7cb">&#9670;&nbsp;</a></span>print_memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>size_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

</div>
</div>
<a id="a0e06543035320ffb26149ddf0d2893a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e06543035320ffb26149ddf0d2893a9">&#9670;&nbsp;</a></span>print() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a representation of the indices in the class to the given output stream. </p>

</div>
</div>
<a id="ad40a2d809c363447d4ecafee2f915073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a2d809c363447d4ecafee2f915073">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator. </p>

</div>
</div>
<a id="a7b1aa91b3929c27da3aac7474e5a6fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1aa91b3929c27da3aac7474e5a6fa9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a38858344192a7f84707e4bf924b5d9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38858344192a7f84707e4bf924b5d9a9">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all data fields in this class. </p>

</div>
</div>
<a id="a3de471c386cdaa3b88906599db12f4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de471c386cdaa3b88906599db12f4e1">&#9670;&nbsp;</a></span>fe_index_from_degree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::fe_index_from_degree </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the FE index for a given finite element degree. If not in hp- mode, this function always returns index 0. If an index is not found in hp-mode, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. </p>

</div>
</div>
<a id="abaae471fd6ff7a2cecaac81736a60771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaae471fd6ff7a2cecaac81736a60771">&#9670;&nbsp;</a></span>get_dof_indices_on_cell_batch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::get_dof_indices_on_cell_batch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locall_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_constraints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the vector <code>locall_indices</code> with locally owned degrees of freedom stored on the cell block <code>cell</code>. If <code>with_constraints</code> is <code>true</code>, then the returned vector will contain indices required to resolve constraints.</p>
<p>The image below illustrates the output of this function for cell blocks zero and one with zero Dirichlet boundary conditions at the bottom of the domain. Note that due to the presence of constraints, the DoFs returned by this function for the case <code>with_constraints = true</code> are not a simple union of per cell DoFs on the cell block <code>cell</code>.</p>
<div class="image">
<img src="dofinfo_get_dof_indices.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd>The returned indices may contain duplicates. The unique set can be obtain using <code>std::sort()</code> followed by <code>std::unique()</code> and <code>std::vector::erase()</code>. </dd></dl>

</div>
</div>
<a id="aae4d1ade3752808df2f15882eef27e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4d1ade3752808df2f15882eef27e6d">&#9670;&nbsp;</a></span>read_dof_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::read_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lexicographic_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_at_boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This internal method takes the local indices on a cell and fills them into this class. It resolves the constraints and distributes the results. Ghost indices, i.e., indices that are located on another processor, get a temporary number by this function, and will later be assigned the correct index after all the ghost indices have been collected by the call to <code>assign_ghosts</code>. </p>

</div>
</div>
<a id="a9cf7609137d338d9dba9f71b955ef5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7609137d338d9dba9f71b955ef5be">&#9670;&nbsp;</a></span>assign_ghosts() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::assign_ghosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method assigns the correct indices to ghost indices from the temporary numbering employed by the <code>read_dof_indices</code> function. The numbers are localized with respect to the MPI process, and ghosts start at the end of the locally owned range. This way, we get direct access to all vector entries. </p>

</div>
</div>
<a id="a065a9af6526fabb0f734401bd4d9f761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065a9af6526fabb0f734401bd4d9f761">&#9670;&nbsp;</a></span>reorder_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::reorder_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method reorders the way cells are gone through based on a given renumbering of the cells. It also takes <code>vectorization_length</code> cells together and interprets them as one cell only, as is needed for vectorization. </p>

</div>
</div>
<a id="a3f9c294edfcbc88ce9917f71cb53e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9c294edfcbc88ce9917f71cb53e722">&#9670;&nbsp;</a></span>compute_cell_index_compression() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_cell_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the cell indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

</div>
</div>
<a id="a2440d06b3b672c6f027b2e2b5bc726e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2440d06b3b672c6f027b2e2b5bc726e4">&#9670;&nbsp;</a></span>compute_face_index_compression() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_face_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the face indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

</div>
</div>
<a id="ae1e4e70a1c48646db1723d8874ec13dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e4e70a1c48646db1723d8874ec13dd">&#9670;&nbsp;</a></span>make_connectivity_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::make_connectivity_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the connectivity of the currently stored indices in terms of connections between the individual cells and fills the structure into a sparsity pattern. </p>

</div>
</div>
<a id="aa9e9b2d975825f1f7d311fd014a4ba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e9b2d975825f1f7d311fd014a4ba43">&#9670;&nbsp;</a></span>compute_tight_partitioners() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_tight_partitioners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_owned_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_lanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ghosted_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>fill_cell_centric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case face integrals are enabled, find out whether certain loops over the unknowns only access a subset of all the ghost dofs we keep in the main partitioner. </p>

</div>
</div>
<a id="a551317c655f02a56ad38888adaafaff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551317c655f02a56ad38888adaafaff0">&#9670;&nbsp;</a></span>compute_shared_memory_contiguous_indices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_shared_memory_contiguous_indices </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_indices_contiguous_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>cell_indices_contiguous_sm</code> containing the local index of cells of macro faces (inner/outer) and macro faces compute dof_indices_contiguous_sm. </p>

</div>
</div>
<a id="a5745c4934cc344a4b466f493b37f7449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5745c4934cc344a4b466f493b37f7449">&#9670;&nbsp;</a></span>compute_dof_renumbering() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_dof_renumbering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a renumbering of the degrees of freedom to improve the data access patterns for this class that can be utilized by the categories in the IndexStorageVariants enum. For example, the index ordering can be improved for typical DG elements by interleaving the degrees of freedom from batches of cells, which avoids the explicit data transposition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>. Currently, these more advanced features are not implemented, so there is only limited value of this function. </p>

</div>
</div>
<a id="a1a7106b8b9e9c0cb68b2368c83c79e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7106b8b9e9c0cb68b2368c83c79e50">&#9670;&nbsp;</a></span>compute_vector_zero_access_pattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_vector_zero_access_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the array that defines how to zero selected ranges in the result vector within the cell loop, filling the two member variables <code>vector_zero_range_list_index</code> and <code>vector_zero_range_list</code>.</p>
<p>The intent of this pattern is to zero the vector entries in close temporal proximity to the first access and thus keeping the vector entries in cache. </p>

</div>
</div>
<a id="a853239498bd0538bfa4a8d4e9fae80be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853239498bd0538bfa4a8d4e9fae80be">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t internal::MatrixFreeFunctions::DoFInfo::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption in bytes of this class. </p>

</div>
</div>
<a id="a65280e0f83efa154c59689ec66f2a7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65280e0f83efa154c59689ec66f2a7cb">&#9670;&nbsp;</a></span>print_memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>size_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

</div>
</div>
<a id="a0e06543035320ffb26149ddf0d2893a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e06543035320ffb26149ddf0d2893a9">&#9670;&nbsp;</a></span>print() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a representation of the indices in the class to the given output stream. </p>

</div>
</div>
<a id="ad40a2d809c363447d4ecafee2f915073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a2d809c363447d4ecafee2f915073">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator. </p>

</div>
</div>
<a id="a7b1aa91b3929c27da3aac7474e5a6fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1aa91b3929c27da3aac7474e5a6fa9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a>&amp; internal::MatrixFreeFunctions::DoFInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a38858344192a7f84707e4bf924b5d9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38858344192a7f84707e4bf924b5d9a9">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all data fields in this class. </p>

</div>
</div>
<a id="a3de471c386cdaa3b88906599db12f4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de471c386cdaa3b88906599db12f4e1">&#9670;&nbsp;</a></span>fe_index_from_degree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::fe_index_from_degree </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the FE index for a given finite element degree. If not in hp- mode, this function always returns index 0. If an index is not found in hp-mode, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. </p>

</div>
</div>
<a id="abaae471fd6ff7a2cecaac81736a60771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaae471fd6ff7a2cecaac81736a60771">&#9670;&nbsp;</a></span>get_dof_indices_on_cell_batch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::get_dof_indices_on_cell_batch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locall_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_constraints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the vector <code>locall_indices</code> with locally owned degrees of freedom stored on the cell block <code>cell</code>. If <code>with_constraints</code> is <code>true</code>, then the returned vector will contain indices required to resolve constraints. The image below illustrates the output of this function for cell blocks zero and one with zero Dirichlet boundary conditions at the bottom of the domain. Note that due to the presence of constraints, the DoFs returned by this function for the case <code>with_constraints = true</code> are not a simple union of per cell DoFs on the cell block <code>cell</code>. </p><div class="image">
<img src="dofinfo_get_dof_indices.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>The returned indices may contain duplicates. The unique set can be obtain using <code>std::sort()</code> followed by <code>std::unique()</code> and <code>std::vector::erase()</code>. </dd></dl>

</div>
</div>
<a id="aae4d1ade3752808df2f15882eef27e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4d1ade3752808df2f15882eef27e6d">&#9670;&nbsp;</a></span>read_dof_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::read_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lexicographic_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ConstraintValues.html">ConstraintValues</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_at_boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This internal method takes the local indices on a cell and fills them into this class. It resolves the constraints and distributes the results. Ghost indices, i.e., indices that are located on another processor, get a temporary number by this function, and will later be assigned the correct index after all the ghost indices have been collected by the call to <code>assign_ghosts</code>. </p>

</div>
</div>
<a id="a9cf7609137d338d9dba9f71b955ef5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7609137d338d9dba9f71b955ef5be">&#9670;&nbsp;</a></span>assign_ghosts() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::assign_ghosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method assigns the correct indices to ghost indices from the temporary numbering employed by the <code>read_dof_indices</code> function. The numbers are localized with respect to the MPI process, and ghosts start at the end of the locally owned range. This way, we get direct access to all vector entries. </p>

</div>
</div>
<a id="a065a9af6526fabb0f734401bd4d9f761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065a9af6526fabb0f734401bd4d9f761">&#9670;&nbsp;</a></span>reorder_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::reorder_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method reorders the way cells are gone through based on a given renumbering of the cells. It also takes <code>vectorization_length</code> cells together and interprets them as one cell only, as is needed for vectorization. </p>

</div>
</div>
<a id="a3f9c294edfcbc88ce9917f71cb53e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9c294edfcbc88ce9917f71cb53e722">&#9670;&nbsp;</a></span>compute_cell_index_compression() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_cell_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>irregular_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the cell indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

</div>
</div>
<a id="a2440d06b3b672c6f027b2e2b5bc726e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2440d06b3b672c6f027b2e2b5bc726e4">&#9670;&nbsp;</a></span>compute_face_index_compression() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_face_index_compression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds possible compression for the face indices that we can apply for increased efficiency. Run at the end of reorder_cells. </p>

</div>
</div>
<a id="ae1e4e70a1c48646db1723d8874ec13dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e4e70a1c48646db1723d8874ec13dd">&#9670;&nbsp;</a></span>make_connectivity_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::make_connectivity_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the connectivity of the currently stored indices in terms of connections between the individual cells and fills the structure into a sparsity pattern. </p>

</div>
</div>
<a id="aa9e9b2d975825f1f7d311fd014a4ba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e9b2d975825f1f7d311fd014a4ba43">&#9670;&nbsp;</a></span>compute_tight_partitioners() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_tight_partitioners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">ShapeInfo</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_owned_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_lanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ghosted_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>fill_cell_centric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_vector_data_exchanger_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case face integrals are enabled, find out whether certain loops over the unknowns only access a subset of all the ghost dofs we keep in the main partitioner. </p>

</div>
</div>
<a id="a551317c655f02a56ad38888adaafaff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551317c655f02a56ad38888adaafaff0">&#9670;&nbsp;</a></span>compute_shared_memory_contiguous_indices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_shared_memory_contiguous_indices </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_indices_contiguous_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>cell_indices_contiguous_sm</code> containing the local index of cells of macro faces (inner/outer) and macro faces compute dof_indices_contiguous_sm. </p>

</div>
</div>
<a id="a5745c4934cc344a4b466f493b37f7449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5745c4934cc344a4b466f493b37f7449">&#9670;&nbsp;</a></span>compute_dof_renumbering() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_dof_renumbering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a renumbering of the degrees of freedom to improve the data access patterns for this class that can be utilized by the categories in the IndexStorageVariants enum. For example, the index ordering can be improved for typical DG elements by interleaving the degrees of freedom from batches of cells, which avoids the explicit data transposition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>. Currently, these more advanced features are not implemented, so there is only limited value of this function. </p>

</div>
</div>
<a id="a1a7106b8b9e9c0cb68b2368c83c79e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7106b8b9e9c0cb68b2368c83c79e50">&#9670;&nbsp;</a></span>compute_vector_zero_access_pattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::compute_vector_zero_access_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>task_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">FaceToCellTopology</a>&lt; length &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the array that defines how to zero selected ranges in the result vector within the cell loop, filling the two member variables <code>vector_zero_range_list_index</code> and <code>vector_zero_range_list</code>. The intent of this pattern is to zero the vector entries in close temporal proximity to the first access and thus keeping the vector entries in cache. </p>

</div>
</div>
<a id="a853239498bd0538bfa4a8d4e9fae80be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853239498bd0538bfa4a8d4e9fae80be">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t internal::MatrixFreeFunctions::DoFInfo::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption in bytes of this class. </p>

</div>
</div>
<a id="a65280e0f83efa154c59689ec66f2a7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65280e0f83efa154c59689ec66f2a7cb">&#9670;&nbsp;</a></span>print_memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>size_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

</div>
</div>
<a id="a0e06543035320ffb26149ddf0d2893a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e06543035320ffb26149ddf0d2893a9">&#9670;&nbsp;</a></span>print() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void internal::MatrixFreeFunctions::DoFInfo::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_pool_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a representation of the indices in the class to the given output stream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac67ec41e4ebafdbe56ea2c4d4be6137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67ec41e4ebafdbe56ea2c4d4be6137c">&#9670;&nbsp;</a></span>chunk_size_zero_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::chunk_size_zero_vector = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This value is used to define subranges in the vectors which we can zero inside the <a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">MatrixFree::loop()</a> call. The goal is to only clear a part of the vector at a time to keep the values that are zeroed in caches, saving one global vector access for the case where this is applied rather than <code>vector = 0.;</code>. We set the granularity to 64</p>
<ul>
<li>that is a number sufficiently large to minimize loop peel overhead within the work (and compatible with vectorization lengths of up to 16) and small enough to not waste on the size of the individual chunks. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00113">113</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a953d425f250ef41a844c3ab5c6e51026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953d425f250ef41a844c3ab5c6e51026">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::dimension</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the dimension of the underlying <a class="el" href="classDoFHandler.html">DoFHandler</a>. Since the indices are not templated, this is the variable that makes the dimension accessible in the (rare) cases it is needed inside this class. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00477">477</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a58a63e0b4346f8c4e0a2092bf8272320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a63e0b4346f8c4e0a2092bf8272320">&#9670;&nbsp;</a></span>vectorization_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::vectorization_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For efficiency reasons, always keep a fixed number of cells with similar properties together. This variable controls the number of cells batched together. As opposed to the other classes which are templated on the number type, this class as a pure index container is not templated, so we need to keep the information otherwise contained in VectorizedArrayType::size(). </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00488">488</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a4073bb3418c65afe7155d5b4ba4ab45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4073bb3418c65afe7155d5b4ba4ab45d">&#9670;&nbsp;</a></span>index_storage_variants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39">IndexStorageVariants</a> &gt;, 3 &gt; internal::MatrixFreeFunctions::DoFInfo::index_storage_variants</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the index storage variant of all cell and face batches. The three arrays given here address the types for the faces decorated as interior (0), the faces decorated with as exterior (1), and the cells (2) according to CellOrFaceAccess. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00497">497</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="ac6589b329695ab39d6495decb13bc69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6589b329695ab39d6495decb13bc69c">&#9670;&nbsp;</a></span>row_starts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::row_starts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the rowstart indices of the compressed row storage in the <code>dof_indices</code> and <code>constraint_indicator</code> fields. These two fields are always accessed together, so it is simpler to keep just one variable for them. This also obviates keeping two rowstart vectors in sync. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00507">507</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a3c418afc10d6b55f0c5dab42d7a2970b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c418afc10d6b55f0c5dab42d7a2970b">&#9670;&nbsp;</a></span>dof_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::dof_indices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the indices of the degrees of freedom for each cell. These indices are computed in MPI-local index space, i.e., each processor stores the locally owned indices as numbers between <code>0</code> and <code>n_locally_owned_dofs-1</code> and ghost indices in the range <code>n_locally_owned_dofs</code> to <code>n_locally_owned_dofs+n_ghost_dofs</code>. The translation between this MPI-local index space and the global numbering of degrees of freedom is stored in the <code>vector_partitioner</code> data structure. This array also includes the indirect contributions from constraints, which are described by the <code>constraint_indicator</code> field. Because of variable lengths of rows, this would be a vector of a vector. However, we use one contiguous memory region and store the rowstart in the variable <code>row_starts</code>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00526">526</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a4e4727218fdfd29d4efa2811030e8a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4727218fdfd29d4efa2811030e8a8c">&#9670;&nbsp;</a></span>constraint_indicator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned short, unsigned short &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::constraint_indicator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This variable describes the position of constraints in terms of the local numbering of degrees of freedom on a cell. The first number stores the distance from one constrained degree of freedom to the next. This allows to identify the position of constrained DoFs as we loop through the local degrees of freedom of the cell when reading from or writing to a vector. The second number stores the index of the constraint weights, stored in the variable constraint_pool_data. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00539">539</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="ad7a215a095cd438b24a28ebb22896b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a215a095cd438b24a28ebb22896b8d">&#9670;&nbsp;</a></span>dof_indices_interleaved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::dof_indices_interleaved</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reordered index storage for <code><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a5fc70ff0369f56d734047c9507af8623">IndexStorageVariants::interleaved</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00545">545</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a145dceaf9fda9a1ad64d93fb2b31811f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145dceaf9fda9a1ad64d93fb2b31811f">&#9670;&nbsp;</a></span>dof_indices_contiguous</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;, 3 &gt; internal::MatrixFreeFunctions::DoFInfo::dof_indices_contiguous</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed index storage for faster access than through <code>dof_indices</code> used according to the description in IndexStorageVariants. The three arrays given here address the types for the faces decorated as interior (0), the faces decorated with as exterior (1), and the cells (2) according to CellOrFaceAccess. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00556">556</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a93322f37f2d9cf9bc29ea81701ad3df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93322f37f2d9cf9bc29ea81701ad3df7">&#9670;&nbsp;</a></span>dof_indices_contiguous_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;, 3 &gt; internal::MatrixFreeFunctions::DoFInfo::dof_indices_contiguous_sm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above but for shared-memory usage. The first value of the pair is identifying the owning process and the second the index within that locally-owned data of that process. </p><dl class="section note"><dt>Note</dt><dd>This data structure is only set up if all entries in index_storage_variants[2] are <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a6369c97edd8ea0d2cd7c028b20ee8f39a23cf8d09a7805358cf05c7a6e01a7623">IndexStorageVariants::contiguous</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00567">567</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="afe167e1aa9037e41bf1501fc20178908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe167e1aa9037e41bf1501fc20178908">&#9670;&nbsp;</a></span>dof_indices_interleave_strides</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;, 3 &gt; internal::MatrixFreeFunctions::DoFInfo::dof_indices_interleave_strides</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed index storage for faster access than through <code>dof_indices</code> used according to the description in IndexStorageVariants. The three arrays given here address the types for the faces decorated as minus (0), the faces decorated with as plus (1), and the cells (2). </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00577">577</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a09302f9fcf4fbf31532ecb07d536cc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09302f9fcf4fbf31532ecb07d536cc99">&#9670;&nbsp;</a></span>n_vectorization_lanes_filled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; unsigned char &gt;, 3 &gt; internal::MatrixFreeFunctions::DoFInfo::n_vectorization_lanes_filled</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caches the number of indices filled when vectorizing. This information can implicitly deduced from the row_starts data fields, but this field allows for faster access. The three arrays given here address the types for the faces decorated as interior (0), the faces decorated with as exterior (1), and the cells (2) according to CellOrFaceAccess. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00588">588</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a5468cac6872750f4d3ea1aefd46770cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5468cac6872750f4d3ea1aefd46770cc">&#9670;&nbsp;</a></span>vector_partitioner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; internal::MatrixFreeFunctions::DoFInfo::vector_partitioner</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This stores the parallel partitioning that can be used to set up vectors. The partitioner includes the description of the local range in the vector, and also includes how the ghosts look like. This enables initialization of vectors based on the <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> field. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00597">597</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a59de4fd7794f93abfcc57c415838f7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59de4fd7794f93abfcc57c415838f7ac">&#9670;&nbsp;</a></span>vector_exchanger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1VectorDataExchange_1_1Base.html">internal::MatrixFreeFunctions::VectorDataExchange::Base</a> &gt; internal::MatrixFreeFunctions::DoFInfo::vector_exchanger</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> exchanger compatible with vector_partitioner. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00605">605</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="ae450dfe53f306bd830d82dc795335c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae450dfe53f306bd830d82dc795335c03">&#9670;&nbsp;</a></span>vector_exchanger_face_variants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::shared_ptr&lt; const <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1VectorDataExchange_1_1Base.html">internal::MatrixFreeFunctions::VectorDataExchange::Base</a> &gt;, 5 &gt; internal::MatrixFreeFunctions::DoFInfo::vector_exchanger_face_variants</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> exchanger compatible with partitioners that select a subset of ghost indices to the full vector partitioner stored in <code>vector_partitioner</code>. These partitioners are used in specialized loops that only import parts of the ghosted region for reducing the amount of communication. There are five variants of the partitioner initialized:</p>
<ul>
<li>one that queries only the cell values,</li>
<li>one that additionally describes the indices for evaluating the function values on relevant faces,</li>
<li>one that describes the indices for evaluation both the function values and the gradients on relevant faces adjacent to the locally owned cells,</li>
<li>one that additionally describes the indices for evaluating the function values on all faces, and</li>
<li>one that describes the indices for evaluation both the function values and the gradients on all faces adjacent to the locally owned cells. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00700">700</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a5ea7ac3279565124aa25b359e400b3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea7ac3279565124aa25b359e400b3c8">&#9670;&nbsp;</a></span>constrained_dofs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::constrained_dofs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This stores a (sorted) list of all locally owned degrees of freedom that are constrained. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00707">707</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a42555b435b16773abac60c68117ce925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42555b435b16773abac60c68117ce925">&#9670;&nbsp;</a></span>row_starts_plain_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::row_starts_plain_indices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the rowstart indices of the compressed row storage in the <code>plain_dof_indices</code> fields. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00714">714</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a880996b14e5afcc2b33b2a5f944f4d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880996b14e5afcc2b33b2a5f944f4d1d">&#9670;&nbsp;</a></span>plain_dof_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::plain_dof_indices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the indices of the degrees of freedom for each cell. This array does not include the indirect contributions from constraints, which are included in <code>dof_indices</code>. Because of variable lengths of rows, this would be a vector of a vector. However, we use one contiguous memory region and store the rowstart in the variable <code>row_starts_plain_indices</code>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00725">725</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a36a52e6cac05be6d4c9782f3375beef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a52e6cac05be6d4c9782f3375beef0">&#9670;&nbsp;</a></span>global_base_element_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::global_base_element_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the offset in terms of the number of base elements over all <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">DoFInfo</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00732">732</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a2e3fc38a5be0b3d0d05c02abe2e7754b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3fc38a5be0b3d0d05c02abe2e7754b">&#9670;&nbsp;</a></span>n_base_elements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::n_base_elements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the number of base elements in the <a class="el" href="classDoFHandler.html">DoFHandler</a> where the indices have been read from. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00739">739</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a5c85910ea8813c205df9400a53f48f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c85910ea8813c205df9400a53f48f48">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::n_components</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the number of components of each base element in the finite element where the indices have been read from. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00746">746</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a795ecfd661ab94ba6cefebc543681413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795ecfd661ab94ba6cefebc543681413">&#9670;&nbsp;</a></span>start_components</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::start_components</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The ith entry of this vector stores the component number of the given base element. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00753">753</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a4ea0dffcb4b43065166129a4b12d3322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea0dffcb4b43065166129a4b12d3322">&#9670;&nbsp;</a></span>component_to_base_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::component_to_base_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given component in an <a class="el" href="classFESystem.html">FESystem</a>, this variable tells which base element the index belongs to. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00760">760</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="aba47d7560960ed13c26957c64995e019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba47d7560960ed13c26957c64995e019">&#9670;&nbsp;</a></span>component_dof_indices_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::component_dof_indices_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a vector-valued element, this gives the constant offset in the number of degrees of freedom starting at the given component, as the degrees are numbered by degrees of freedom. This data structure does not take possible constraints and thus, shorter or longer lists, into account. This information is encoded in the row_starts variables directly. The outer vector goes through the various FE indices in the hp-case, similarly to the <code>dofs_per_cell</code> variable. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00773">773</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a14ff71f7f72b26d8fdaa768d35742cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ff71f7f72b26d8fdaa768d35742cff">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::dofs_per_cell</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the number of degrees of freedom per cell. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00779">779</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="acba75235fe8bf8397468f9657aaf0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba75235fe8bf8397468f9657aaf0197">&#9670;&nbsp;</a></span>dofs_per_face</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::dofs_per_face</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the number of degrees of freedom per face. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00785">785</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a746e2ed60aaa2dcbee14187853382211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746e2ed60aaa2dcbee14187853382211">&#9670;&nbsp;</a></span>store_plain_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> internal::MatrixFreeFunctions::DoFInfo::store_plain_indices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs on whether plain indices are cached. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00791">791</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a76079b289a37b0afd41145824ac6d66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76079b289a37b0afd41145824ac6d66d">&#9670;&nbsp;</a></span>cell_active_fe_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::cell_active_fe_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the index of the active finite element in the hp-case. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00797">797</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a389b69afee93e6b4ec02e36ed0e25f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b69afee93e6b4ec02e36ed0e25f6b">&#9670;&nbsp;</a></span>max_fe_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> internal::MatrixFreeFunctions::DoFInfo::max_fe_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the maximum degree of different finite elements for the hp- case. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00804">804</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a02c307b5046f01a1f94aed6187f79bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c307b5046f01a1f94aed6187f79bbb">&#9670;&nbsp;</a></span>fe_index_conversion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::fe_index_conversion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To each of the slots in an hp-adaptive case, the inner vector stores the corresponding element degree. This is used by the constructor of <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a> to identify the correct data slot in the hp-case. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00812">812</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a23dec49473e137815191717f4ffc75e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dec49473e137815191717f4ffc75e9">&#9670;&nbsp;</a></span>ghost_dofs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; internal::MatrixFreeFunctions::DoFInfo::ghost_dofs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temporarily stores the numbers of ghosts during setup. Cleared when calling <code>assign_ghosts</code>. Then, all information is collected by the partitioner. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00820">820</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a462c86eb6d5935fa2fa8eef84792248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462c86eb6d5935fa2fa8eef84792248d">&#9670;&nbsp;</a></span>vector_zero_range_list_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::vector_zero_range_list_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an integer to each partition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> that indicates whether to clear certain parts in the result vector if the user requested it with the respective argument in the <a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">MatrixFree::loop</a>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00828">828</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a583b90a9e2f2cd2ebcd27da53df1e67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583b90a9e2f2cd2ebcd27da53df1e67d">&#9670;&nbsp;</a></span>vector_zero_range_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::vector_zero_range_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the actual ranges in the vector to be cleared. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00834">834</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="ac9585d41f72cbd51903fa1a4f5792e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9585d41f72cbd51903fa1a4f5792e1b">&#9670;&nbsp;</a></span>cell_loop_pre_list_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::cell_loop_pre_list_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an integer to each partition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> that indicates when to schedule operations that will be done before any access to vector entries. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00842">842</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a1c94facf5601340ba6d16b96372bd1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c94facf5601340ba6d16b96372bd1ea">&#9670;&nbsp;</a></span>cell_loop_pre_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::cell_loop_pre_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the actual ranges of the operation before any access to vector entries. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00849">849</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="ad05306ef04310ec8d8ef1d7abae75fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05306ef04310ec8d8ef1d7abae75fbb">&#9670;&nbsp;</a></span>cell_loop_post_list_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; internal::MatrixFreeFunctions::DoFInfo::cell_loop_post_list_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an integer to each partition in <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">TaskInfo</a> that indicates when to schedule operations that will be done after all access to vector entries. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00857">857</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<a id="a4cf914a8a12d3e7c84b085007f0da74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf914a8a12d3e7c84b085007f0da74c">&#9670;&nbsp;</a></span>cell_loop_post_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; internal::MatrixFreeFunctions::DoFInfo::cell_loop_post_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the actual ranges of the operation after all access to vector entries. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_2dof__info_8h_source.html#l00864">864</a> of file <a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="matrix__free_2dof__info_8h_source.html">dof_info.h</a></li>
<li>source/matrix_free/<a class="el" href="dof__info_8cc_source.html">dof_info.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
