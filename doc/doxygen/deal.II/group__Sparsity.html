<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__Sparsity.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Sparsity patterns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Sparsity patterns<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Almost all finite element formulations lead to matrices that are "sparse", i.e., for which the number of nonzero elements per row is (i) relatively small compared to the overall size of the matrix, and (ii) bounded by a fixed number that does not grow if the mesh is refined. For such cases, it is more efficient to not store <em>all</em> elements of the matrix, but only those that are actually (or may be) nonzero. This requires storing, for each row, the column indices of the nonzero entries (we call this the "sparsity
  pattern") as well as the actual values of these nonzero entries. (In practice, it sometimes happens that some of the nonzero values are, in fact, zero. Sparsity patterns and sparse matrices only intend to provision space for entries that <em>may</em> be nonzero, and do so at a time when we don't know yet what values these entries will ultimately have; they may have a zero value if a coefficient or cell happens to have particular values.)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Sparsity patterns:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Exceptions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html">Exceptions and assertions</a></td></tr>
<tr class="memdesc:group__Exceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module contains classes that are used in the exception mechanism of deal.II. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTrilinosWrappers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceChunkSparsityPatternIterators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceChunkSparsityPatternIterators.html">ChunkSparsityPatternIterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDynamicSparsityPatternIterators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynamicSparsityPatternIterators.html">DynamicSparsityPatternIterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinternals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternals.html">internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinternals_1_1SparsityPatternTools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternals_1_1SparsityPatternTools.html">internals::SparsityPatternTools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSparsityPatternIterators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityPatternIterators.html">SparsityPatternIterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSparsityTools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html">SparsityTools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase&lt; SparsityPatternType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">ChunkSparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">ChunkSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">DynamicSparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">DynamicSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDynamicSparsityPattern_1_1Line.html">DynamicSparsityPattern::Line</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html">SparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparsityPattern.html">SparsityPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4d8af14de1e21c26eaeb48fd31846bdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4d8af14de1e21c26eaeb48fd31846bdc">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga4d8af14de1e21c26eaeb48fd31846bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79094ea32b3807c12b049b1c7c34bff7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga79094ea32b3807c12b049b1c7c34bff7">ChunkSparsityPatternIterators::Accessor::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga79094ea32b3807c12b049b1c7c34bff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5a691b2c5146bc4f8216239c5fe511"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga6e5a691b2c5146bc4f8216239c5fe511">ChunkSparsityPatternIterators::Iterator::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga6e5a691b2c5146bc4f8216239c5fe511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43fe54b08913d30ae5dcb81fc72107bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga43fe54b08913d30ae5dcb81fc72107bb">ChunkSparsityPattern::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga43fe54b08913d30ae5dcb81fc72107bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa72ff0b1fe466759e60bd34f89eb03ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa72ff0b1fe466759e60bd34f89eb03ac">ChunkSparsityPattern::const_iterator</a> = <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">ChunkSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:gaa72ff0b1fe466759e60bd34f89eb03ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e66cf5c0ef12063c3f5d5b0404bc4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga10e66cf5c0ef12063c3f5d5b0404bc4e">ChunkSparsityPattern::iterator</a> = <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">ChunkSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ga10e66cf5c0ef12063c3f5d5b0404bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfbeb2cf093e039975a1e99924b96690"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">DynamicSparsityPatternIterators::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:gadfbeb2cf093e039975a1e99924b96690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7249323016034cf1e20072c0b58907"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga2d7249323016034cf1e20072c0b58907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ab16f163487d426b3ecb653a0ad927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga18ab16f163487d426b3ecb653a0ad927">DynamicSparsityPattern::iterator</a> = <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">DynamicSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ga18ab16f163487d426b3ecb653a0ad927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab428801ce75a718d7b668d429eb7c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7ab428801ce75a718d7b668d429eb7c6">DynamicSparsityPattern::const_iterator</a> = <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">DynamicSparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ga7ab428801ce75a718d7b668d429eb7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e241eb348f5c446ddf05a08826eb31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">internals::SparsityPatternTools::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga12e241eb348f5c446ddf05a08826eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f04b492c7622ec4bd071ccdce18d396"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8f04b492c7622ec4bd071ccdce18d396">SparsityPatternIterators::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga8f04b492c7622ec4bd071ccdce18d396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7806ed33918ff4d52d022b9a1872a457"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7806ed33918ff4d52d022b9a1872a457">SparsityPatternIterators::Accessor::size_type</a> = <a class="el" href="group__Sparsity.html#ga8f04b492c7622ec4bd071ccdce18d396">SparsityPatternIterators::size_type</a></td></tr>
<tr class="separator:ga7806ed33918ff4d52d022b9a1872a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec97555e6eefafcc8a01ca7c6d013b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga5ec97555e6eefafcc8a01ca7c6d013b3">SparsityPatternIterators::Iterator::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga5ec97555e6eefafcc8a01ca7c6d013b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4e9b21ca516c5a2ca10869cfa44ca1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gadb4e9b21ca516c5a2ca10869cfa44ca1">SparsityPatternIterators::Iterator::container_pointer_type</a> = <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *</td></tr>
<tr class="separator:gadb4e9b21ca516c5a2ca10869cfa44ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c7b2070bea3afe6064dffdf5b1d664"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga39c7b2070bea3afe6064dffdf5b1d664">SparsityPatternBase::size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:ga39c7b2070bea3afe6064dffdf5b1d664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c554fe82e2f517f5e0759c3de987b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac1c554fe82e2f517f5e0759c3de987b4">SparsityPatternBase::const_iterator</a> = <a class="el" href="classSparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:gac1c554fe82e2f517f5e0759c3de987b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32de0a562f86156d7ecebb09a85c832a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga32de0a562f86156d7ecebb09a85c832a">SparsityPatternBase::iterator</a> = <a class="el" href="classSparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ga32de0a562f86156d7ecebb09a85c832a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2b13bf5274de30270934de0d644b320b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2b13bf5274de30270934de0d644b320b">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::BlockSparsityPatternBase</a> ()</td></tr>
<tr class="separator:ga2b13bf5274de30270934de0d644b320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa864194283fc0aca362f1a5ce86d0c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa864194283fc0aca362f1a5ce86d0c4d">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::BlockSparsityPatternBase</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html#ga124486ee59f893c19806a6a9d9c826af">n_block_rows</a>, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> n_block_columns)</td></tr>
<tr class="separator:gaa864194283fc0aca362f1a5ce86d0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ca421a06a9655285a84fecd65a64e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac2ca421a06a9655285a84fecd65a64e1">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::BlockSparsityPatternBase</a> (const <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> &amp;bsp)</td></tr>
<tr class="separator:gac2ca421a06a9655285a84fecd65a64e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1632ef532fb5aa23c30722c114ff3b12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1632ef532fb5aa23c30722c114ff3b12">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::~BlockSparsityPatternBase</a> () override</td></tr>
<tr class="separator:ga1632ef532fb5aa23c30722c114ff3b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1189ecd2022bb6671c9094dec725ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8d1189ecd2022bb6671c9094dec725ed">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::reinit</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html#ga124486ee59f893c19806a6a9d9c826af">n_block_rows</a>, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> n_block_columns)</td></tr>
<tr class="separator:ga8d1189ecd2022bb6671c9094dec725ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e28ccf99906536785540b80659517c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac5e28ccf99906536785540b80659517c">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::operator=</a> (const <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> &amp;)</td></tr>
<tr class="separator:gac5e28ccf99906536785540b80659517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a91aa1f9a52b5c51a89204eb29bcdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga01a91aa1f9a52b5c51a89204eb29bcdc">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::collect_sizes</a> ()</td></tr>
<tr class="separator:ga01a91aa1f9a52b5c51a89204eb29bcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68ecb039e13c35a501ee85e9fbbe403"><td class="memItemLeft" align="right" valign="top">SparsityPatternType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa68ecb039e13c35a501ee85e9fbbe403">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::block</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> row, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> column)</td></tr>
<tr class="separator:gaa68ecb039e13c35a501ee85e9fbbe403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fdbc69c1375c8cef87bc3bffc62c2a"><td class="memItemLeft" align="right" valign="top">const SparsityPatternType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga07fdbc69c1375c8cef87bc3bffc62c2a">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::block</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> row, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> column) const</td></tr>
<tr class="separator:ga07fdbc69c1375c8cef87bc3bffc62c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023d59afdfd3d7f9431318b3d4e7d459"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga023d59afdfd3d7f9431318b3d4e7d459">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::get_row_indices</a> () const</td></tr>
<tr class="separator:ga023d59afdfd3d7f9431318b3d4e7d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655859e290e4f5be905e961c3d6c732f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga655859e290e4f5be905e961c3d6c732f">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::get_column_indices</a> () const</td></tr>
<tr class="separator:ga655859e290e4f5be905e961c3d6c732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3bac2c0873208543e60684ce9cbd0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab3bac2c0873208543e60684ce9cbd0b0">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::compress</a> ()</td></tr>
<tr class="separator:gab3bac2c0873208543e60684ce9cbd0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124486ee59f893c19806a6a9d9c826af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga124486ee59f893c19806a6a9d9c826af">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::n_block_rows</a> () const</td></tr>
<tr class="separator:ga124486ee59f893c19806a6a9d9c826af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf36cec371f08b68e8b59bca61aefadc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf36cec371f08b68e8b59bca61aefadc6">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::n_block_cols</a> () const</td></tr>
<tr class="separator:gaf36cec371f08b68e8b59bca61aefadc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fce89a2849bfc67e60e715a11f9010d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga9fce89a2849bfc67e60e715a11f9010d">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::empty</a> () const</td></tr>
<tr class="separator:ga9fce89a2849bfc67e60e715a11f9010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf073215d48531dd728f98de936ccd8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf073215d48531dd728f98de936ccd8f1">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::max_entries_per_row</a> () const</td></tr>
<tr class="separator:gaf073215d48531dd728f98de936ccd8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5840454fd8907c708ff54632c463df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac5840454fd8907c708ff54632c463df5">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::add</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> i, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> j)</td></tr>
<tr class="separator:gac5840454fd8907c708ff54632c463df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a29824eed344d90cca6266d373476a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga53a29824eed344d90cca6266d373476a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga53a29824eed344d90cca6266d373476a">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::add_entries</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> row, ForwardIterator begin, ForwardIterator end, const <a class="el" href="classbool.html">bool</a> indices_are_sorted=false)</td></tr>
<tr class="separator:ga53a29824eed344d90cca6266d373476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45ebc113196659d1718adb3294e8e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad45ebc113196659d1718adb3294e8e8e">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::n_rows</a> () const</td></tr>
<tr class="separator:gad45ebc113196659d1718adb3294e8e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b35d986e4fbdbc9fbad75bab80be99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga58b35d986e4fbdbc9fbad75bab80be99">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::n_cols</a> () const</td></tr>
<tr class="separator:ga58b35d986e4fbdbc9fbad75bab80be99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b4f55f68b82aedcd14c414f3f01c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae4b4f55f68b82aedcd14c414f3f01c4c">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::exists</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> i, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> j) const</td></tr>
<tr class="separator:gae4b4f55f68b82aedcd14c414f3f01c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fc654b5be725eddf4df39759f6c58"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gabd9fc654b5be725eddf4df39759f6c58">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::row_length</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> row) const</td></tr>
<tr class="separator:gabd9fc654b5be725eddf4df39759f6c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808c9315f0805ad671b11423c2c62ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga808c9315f0805ad671b11423c2c62ad7">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ga808c9315f0805ad671b11423c2c62ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606b03bd1779c9694298065c93f2c675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga606b03bd1779c9694298065c93f2c675">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga606b03bd1779c9694298065c93f2c675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01cdbc59d0850dce65ddeb99b6ab5b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga01cdbc59d0850dce65ddeb99b6ab5b7e">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga01cdbc59d0850dce65ddeb99b6ab5b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6314b53f6dcfd263f85ef44666beb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7e6314b53f6dcfd263f85ef44666beb1">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::print_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga7e6314b53f6dcfd263f85ef44666beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3407a956c25fecbf04972d10cfc04fa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3407a956c25fecbf04972d10cfc04fa2">ChunkSparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *matrix, const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a> <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a21d97e0d4349771a8c290d4270e9dc3a">row</a>)</td></tr>
<tr class="separator:ga3407a956c25fecbf04972d10cfc04fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f71203ace1a31ef361626308140fdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga81f71203ace1a31ef361626308140fdc">ChunkSparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *matrix)</td></tr>
<tr class="separator:ga81f71203ace1a31ef361626308140fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d97e0d4349771a8c290d4270e9dc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga21d97e0d4349771a8c290d4270e9dc3a">ChunkSparsityPatternIterators::Accessor::row</a> () const</td></tr>
<tr class="separator:ga21d97e0d4349771a8c290d4270e9dc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451d13df4ce666f1d266e437a09d6c49"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga451d13df4ce666f1d266e437a09d6c49">ChunkSparsityPatternIterators::Accessor::reduced_index</a> () const</td></tr>
<tr class="separator:ga451d13df4ce666f1d266e437a09d6c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade15915efb3e43d8a9c8ad4d03a9a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaade15915efb3e43d8a9c8ad4d03a9a96">ChunkSparsityPatternIterators::Accessor::column</a> () const</td></tr>
<tr class="separator:gaade15915efb3e43d8a9c8ad4d03a9a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cd10e6fdfdfe859260f47107617c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga28cd10e6fdfdfe859260f47107617c81">ChunkSparsityPatternIterators::Accessor::is_valid_entry</a> () const</td></tr>
<tr class="separator:ga28cd10e6fdfdfe859260f47107617c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99975f68918e179273c47b11c6d0e5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga99975f68918e179273c47b11c6d0e5f7">ChunkSparsityPatternIterators::Accessor::operator==</a> (const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:ga99975f68918e179273c47b11c6d0e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e14732ee20344711d5ebd21fc80dbfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4e14732ee20344711d5ebd21fc80dbfa">ChunkSparsityPatternIterators::Accessor::operator&lt;</a> (const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:ga4e14732ee20344711d5ebd21fc80dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e967d6d0efc7e686eea475e2dff796a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga6e967d6d0efc7e686eea475e2dff796a">ChunkSparsityPatternIterators::Accessor::advance</a> ()</td></tr>
<tr class="separator:ga6e967d6d0efc7e686eea475e2dff796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653df8fcec158df8eaad041e727f78bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga653df8fcec158df8eaad041e727f78bc">ChunkSparsityPatternIterators::Iterator::Iterator</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *sp, const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html#a6e5a691b2c5146bc4f8216239c5fe511">size_type</a> row)</td></tr>
<tr class="separator:ga653df8fcec158df8eaad041e727f78bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a410833a31fa4732eabca7554a8220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga47a410833a31fa4732eabca7554a8220">ChunkSparsityPatternIterators::Iterator::operator++</a> ()</td></tr>
<tr class="separator:ga47a410833a31fa4732eabca7554a8220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cdd5092478ed3a7907ae742bfb477e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1cdd5092478ed3a7907ae742bfb477e8">ChunkSparsityPatternIterators::Iterator::operator++</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:ga1cdd5092478ed3a7907ae742bfb477e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6239128933b7185e91aeee0ef838c2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4f6239128933b7185e91aeee0ef838c2">ChunkSparsityPatternIterators::Iterator::operator*</a> () const</td></tr>
<tr class="separator:ga4f6239128933b7185e91aeee0ef838c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a34317fe9e7616f7ab6fa5897710939"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4a34317fe9e7616f7ab6fa5897710939">ChunkSparsityPatternIterators::Iterator::operator-&gt;</a> () const</td></tr>
<tr class="separator:ga4a34317fe9e7616f7ab6fa5897710939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441026b5608d33dd665b9fa03eda643e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga441026b5608d33dd665b9fa03eda643e">ChunkSparsityPatternIterators::Iterator::operator==</a> (const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:ga441026b5608d33dd665b9fa03eda643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18987092c4bba051567ced11527d05ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga18987092c4bba051567ced11527d05ca">ChunkSparsityPatternIterators::Iterator::operator!=</a> (const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:ga18987092c4bba051567ced11527d05ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8747567d51d9986056eb46db8d0ffcda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8747567d51d9986056eb46db8d0ffcda">ChunkSparsityPatternIterators::Iterator::operator&lt;</a> (const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:ga8747567d51d9986056eb46db8d0ffcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aba5f931783751744b78c6c4491b6c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8aba5f931783751744b78c6c4491b6c4">ChunkSparsityPattern::ChunkSparsityPattern</a> ()</td></tr>
<tr class="separator:ga8aba5f931783751744b78c6c4491b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4366453eb7970006d822cffbcabfc915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4366453eb7970006d822cffbcabfc915">ChunkSparsityPattern::ChunkSparsityPattern</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;)</td></tr>
<tr class="separator:ga4366453eb7970006d822cffbcabfc915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1f2f7493e6ffc756f8df3354c11e6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3d1f2f7493e6ffc756f8df3354c11e6b">ChunkSparsityPattern::ChunkSparsityPattern</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> max_chunks_per_row, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga3d1f2f7493e6ffc756f8df3354c11e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c2110491f4e184604948d8dcdfed9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga30c2110491f4e184604948d8dcdfed9f">ChunkSparsityPattern::ChunkSparsityPattern</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga30c2110491f4e184604948d8dcdfed9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc11bcc047bdd1670f49888726a2022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8dc11bcc047bdd1670f49888726a2022">ChunkSparsityPattern::ChunkSparsityPattern</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> max_per_row, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga8dc11bcc047bdd1670f49888726a2022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52645c05d93ba4ee7292119b0970c0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab52645c05d93ba4ee7292119b0970c0e">ChunkSparsityPattern::ChunkSparsityPattern</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:gab52645c05d93ba4ee7292119b0970c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c55eba8e52282441347427952d2af32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2c55eba8e52282441347427952d2af32">ChunkSparsityPattern::~ChunkSparsityPattern</a> () override=default</td></tr>
<tr class="separator:ga2c55eba8e52282441347427952d2af32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b42b2ce2078609ca0fe84626279077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga82b42b2ce2078609ca0fe84626279077">ChunkSparsityPattern::operator=</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;)</td></tr>
<tr class="separator:ga82b42b2ce2078609ca0fe84626279077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ace2dee00fd1fb57398d0a9e73af0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga6ace2dee00fd1fb57398d0a9e73af0fc">ChunkSparsityPattern::reinit</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> max_per_row, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga6ace2dee00fd1fb57398d0a9e73af0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b6f833f943400c70e1c94a9a966913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga81b6f833f943400c70e1c94a9a966913">ChunkSparsityPattern::reinit</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga81b6f833f943400c70e1c94a9a966913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c369603403f9249f07a35f7a7a8a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf1c369603403f9249f07a35f7a7a8a49">ChunkSparsityPattern::reinit</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:gaf1c369603403f9249f07a35f7a7a8a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545474926fb71c36f09d317e1f4ff830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga545474926fb71c36f09d317e1f4ff830">ChunkSparsityPattern::compress</a> ()</td></tr>
<tr class="separator:ga545474926fb71c36f09d317e1f4ff830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c912a28714c3d40a12c1a1cf9fff63"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gae9c912a28714c3d40a12c1a1cf9fff63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae9c912a28714c3d40a12c1a1cf9fff63">ChunkSparsityPattern::copy_from</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="classChunkSparsityPattern.html#ab29764d5ecb67c135d727658347d26c1">n_cols</a>, const ForwardIterator <a class="el" href="classChunkSparsityPattern.html#acf768e801f5f0e7e311da883488c5cfe">begin</a>, const ForwardIterator <a class="el" href="classChunkSparsityPattern.html#a581bcf26417ad8584cc0f1c0a32f14b6">end</a>, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:gae9c912a28714c3d40a12c1a1cf9fff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3bc592eb05b5a0d05e519b1aa1b329"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga2f3bc592eb05b5a0d05e519b1aa1b329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2f3bc592eb05b5a0d05e519b1aa1b329">ChunkSparsityPattern::copy_from</a> (const SparsityPatternType &amp;dsp, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:ga2f3bc592eb05b5a0d05e519b1aa1b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcca15e528bef78783c5aba2c2ce285"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:gaafcca15e528bef78783c5aba2c2ce285"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaafcca15e528bef78783c5aba2c2ce285">ChunkSparsityPattern::copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>)</td></tr>
<tr class="separator:gaafcca15e528bef78783c5aba2c2ce285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06eff2d40b9840b74b46c87606e0ce5e"><td class="memTemplParams" colspan="2">template&lt;typename Sparsity &gt; </td></tr>
<tr class="memitem:ga06eff2d40b9840b74b46c87606e0ce5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga06eff2d40b9840b74b46c87606e0ce5e">ChunkSparsityPattern::create_from</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> m, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> n, const Sparsity &amp;sparsity_pattern_for_chunks, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> <a class="el" href="group__Exceptions.html#ga808ad6482b774622b302ac5b1a1b68dd">chunk_size</a>, const <a class="el" href="classbool.html">bool</a> optimize_diagonal=true)</td></tr>
<tr class="separator:ga06eff2d40b9840b74b46c87606e0ce5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf119433c708bfce06ca2f106ac25e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaddf119433c708bfce06ca2f106ac25e1">ChunkSparsityPattern::empty</a> () const</td></tr>
<tr class="separator:gaddf119433c708bfce06ca2f106ac25e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30aa3167d5f7b9f8cdc3954aa0aaefb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae30aa3167d5f7b9f8cdc3954aa0aaefb">ChunkSparsityPattern::get_chunk_size</a> () const</td></tr>
<tr class="separator:gae30aa3167d5f7b9f8cdc3954aa0aaefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265ec1a8cc78a1ac3d512528e93eadfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga265ec1a8cc78a1ac3d512528e93eadfe">ChunkSparsityPattern::max_entries_per_row</a> () const</td></tr>
<tr class="separator:ga265ec1a8cc78a1ac3d512528e93eadfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b49e5060932cbee4e438699da65581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga07b49e5060932cbee4e438699da65581">ChunkSparsityPattern::add</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> i, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> j)</td></tr>
<tr class="separator:ga07b49e5060932cbee4e438699da65581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c30e3ae9bd087342b58b777ccd77bb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1c30e3ae9bd087342b58b777ccd77bb7">ChunkSparsityPattern::symmetrize</a> ()</td></tr>
<tr class="separator:ga1c30e3ae9bd087342b58b777ccd77bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60af18b0bd7b73f1f5e752b0d30802a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf60af18b0bd7b73f1f5e752b0d30802a">ChunkSparsityPattern::n_rows</a> () const</td></tr>
<tr class="separator:gaf60af18b0bd7b73f1f5e752b0d30802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29764d5ecb67c135d727658347d26c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab29764d5ecb67c135d727658347d26c1">ChunkSparsityPattern::n_cols</a> () const</td></tr>
<tr class="separator:gab29764d5ecb67c135d727658347d26c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c884dbfd69d3f4e406404beabb83c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga53c884dbfd69d3f4e406404beabb83c5">ChunkSparsityPattern::exists</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> i, const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> j) const</td></tr>
<tr class="separator:ga53c884dbfd69d3f4e406404beabb83c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84756c959244c4309bf94d83e45854b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga84756c959244c4309bf94d83e45854b9">ChunkSparsityPattern::row_length</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> row) const</td></tr>
<tr class="separator:ga84756c959244c4309bf94d83e45854b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef521b07f1e6e04cfc8185ad3bcd4be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaef521b07f1e6e04cfc8185ad3bcd4be4">ChunkSparsityPattern::bandwidth</a> () const</td></tr>
<tr class="separator:gaef521b07f1e6e04cfc8185ad3bcd4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c061d1117a85dff6f19b93886052d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga71c061d1117a85dff6f19b93886052d6">ChunkSparsityPattern::n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ga71c061d1117a85dff6f19b93886052d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9996952cc5704f6cdb8a62a7d4674d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga9996952cc5704f6cdb8a62a7d4674d7a">ChunkSparsityPattern::is_compressed</a> () const</td></tr>
<tr class="separator:ga9996952cc5704f6cdb8a62a7d4674d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1589f40972b0d32ed2b0b02280f64a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1589f40972b0d32ed2b0b02280f64a84">ChunkSparsityPattern::stores_only_added_elements</a> () const</td></tr>
<tr class="separator:ga1589f40972b0d32ed2b0b02280f64a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf768e801f5f0e7e311da883488c5cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gacf768e801f5f0e7e311da883488c5cfe">ChunkSparsityPattern::begin</a> () const</td></tr>
<tr class="separator:gacf768e801f5f0e7e311da883488c5cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga581bcf26417ad8584cc0f1c0a32f14b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga581bcf26417ad8584cc0f1c0a32f14b6">ChunkSparsityPattern::end</a> () const</td></tr>
<tr class="separator:ga581bcf26417ad8584cc0f1c0a32f14b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ae99d025ff8745246f02cc22a07e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf7ae99d025ff8745246f02cc22a07e45">ChunkSparsityPattern::begin</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> r) const</td></tr>
<tr class="separator:gaf7ae99d025ff8745246f02cc22a07e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671eee281d96be62cd67667213ac3f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga671eee281d96be62cd67667213ac3f93">ChunkSparsityPattern::end</a> (const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> r) const</td></tr>
<tr class="separator:ga671eee281d96be62cd67667213ac3f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c28e60ee4f52000a532cafa9c1cf4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0c28e60ee4f52000a532cafa9c1cf4b4">ChunkSparsityPattern::block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga0c28e60ee4f52000a532cafa9c1cf4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7656c89a8fb3081628cfe067e18e9cf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7656c89a8fb3081628cfe067e18e9cf7">ChunkSparsityPattern::block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga7656c89a8fb3081628cfe067e18e9cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fc2c515b962a61ac853569268f3f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad4fc2c515b962a61ac853569268f3f34">ChunkSparsityPattern::print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gad4fc2c515b962a61ac853569268f3f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc7c0e88fea614a08c84ac793159cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga6cc7c0e88fea614a08c84ac793159cb7">ChunkSparsityPattern::print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga6cc7c0e88fea614a08c84ac793159cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec280990051f39f9a2e72fc9904f298"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3ec280990051f39f9a2e72fc9904f298">ChunkSparsityPattern::memory_consumption</a> () const</td></tr>
<tr class="separator:ga3ec280990051f39f9a2e72fc9904f298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189c8ede77d4ec29676b3639ba522682"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga189c8ede77d4ec29676b3639ba522682">DynamicSparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *<a class="el" href="group__Sparsity.html#ga20831f347c1aa6d8fddbff4327ecd698">sparsity_pattern</a>, const <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html#ga56f4bfb7510a9b2f8f03eb8397c4f3c5">row</a>, const unsigned <a class="el" href="classint.html">int</a> index_within_row)</td></tr>
<tr class="separator:ga189c8ede77d4ec29676b3639ba522682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473e1cb731c7116964874b024cfeb901"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga473e1cb731c7116964874b024cfeb901">DynamicSparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *<a class="el" href="group__Sparsity.html#ga20831f347c1aa6d8fddbff4327ecd698">sparsity_pattern</a>)</td></tr>
<tr class="separator:ga473e1cb731c7116964874b024cfeb901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1c2f70e7ef3cb88c827df12b03ac44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4b1c2f70e7ef3cb88c827df12b03ac44">DynamicSparsityPatternIterators::Accessor::Accessor</a> ()</td></tr>
<tr class="separator:ga4b1c2f70e7ef3cb88c827df12b03ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f4bfb7510a9b2f8f03eb8397c4f3c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga56f4bfb7510a9b2f8f03eb8397c4f3c5">DynamicSparsityPatternIterators::Accessor::row</a> () const</td></tr>
<tr class="separator:ga56f4bfb7510a9b2f8f03eb8397c4f3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbbd85a753f8e0b194f80f31086d1f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4fbbd85a753f8e0b194f80f31086d1f4">DynamicSparsityPatternIterators::Accessor::index</a> () const</td></tr>
<tr class="separator:ga4fbbd85a753f8e0b194f80f31086d1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486d654e7b0d96637dff1827a0e2f35c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga486d654e7b0d96637dff1827a0e2f35c">DynamicSparsityPatternIterators::Accessor::column</a> () const</td></tr>
<tr class="separator:ga486d654e7b0d96637dff1827a0e2f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff81ba53abae5238413608b966ad779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gacff81ba53abae5238413608b966ad779">DynamicSparsityPatternIterators::Accessor::operator==</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:gacff81ba53abae5238413608b966ad779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98f276b887f267a1c7a6473b8458ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad98f276b887f267a1c7a6473b8458ca3">DynamicSparsityPatternIterators::Accessor::operator&lt;</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:gad98f276b887f267a1c7a6473b8458ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb2bc2c08288d1d6547eff29f2c659b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3eb2bc2c08288d1d6547eff29f2c659b">DynamicSparsityPatternIterators::Accessor::DeclExceptionMsg</a> (DummyAccessor, &quot;The instance of this class was initialized&quot; &quot; without <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> object, which&quot; &quot; means that it is a dummy accessor that can&quot; &quot; not do any operations.&quot;)</td></tr>
<tr class="separator:ga3eb2bc2c08288d1d6547eff29f2c659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123bb3c168fb1d5cdbf3fb95de4f48e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga123bb3c168fb1d5cdbf3fb95de4f48e4">DynamicSparsityPatternIterators::Accessor::advance</a> ()</td></tr>
<tr class="separator:ga123bb3c168fb1d5cdbf3fb95de4f48e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3158717e4bf78ee0fbd06e20629d00aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3158717e4bf78ee0fbd06e20629d00aa">DynamicSparsityPatternIterators::Iterator::Iterator</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *sp, const <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> row, const unsigned <a class="el" href="classint.html">int</a> index_within_row)</td></tr>
<tr class="separator:ga3158717e4bf78ee0fbd06e20629d00aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f09dc9ac73c9b3ac9442f448b82e7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac2f09dc9ac73c9b3ac9442f448b82e7f">DynamicSparsityPatternIterators::Iterator::Iterator</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *sp)</td></tr>
<tr class="separator:gac2f09dc9ac73c9b3ac9442f448b82e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5b3f18a9e780fb5e5ac3b8d0fa37e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gacd5b3f18a9e780fb5e5ac3b8d0fa37e3">DynamicSparsityPatternIterators::Iterator::Iterator</a> ()=default</td></tr>
<tr class="separator:gacd5b3f18a9e780fb5e5ac3b8d0fa37e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce23d97ee9eaa9adbf1ed4b174b0558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2ce23d97ee9eaa9adbf1ed4b174b0558">DynamicSparsityPatternIterators::Iterator::operator++</a> ()</td></tr>
<tr class="separator:ga2ce23d97ee9eaa9adbf1ed4b174b0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf200063a10ce2a0ff765e469b6aa058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gadf200063a10ce2a0ff765e469b6aa058">DynamicSparsityPatternIterators::Iterator::operator++</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:gadf200063a10ce2a0ff765e469b6aa058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b06be42a5d1d707e08cf51e22020dd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0b06be42a5d1d707e08cf51e22020dd1">DynamicSparsityPatternIterators::Iterator::operator*</a> () const</td></tr>
<tr class="separator:ga0b06be42a5d1d707e08cf51e22020dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bd6a9a0670870fe2ae6678e5845f9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae6bd6a9a0670870fe2ae6678e5845f9b">DynamicSparsityPatternIterators::Iterator::operator-&gt;</a> () const</td></tr>
<tr class="separator:gae6bd6a9a0670870fe2ae6678e5845f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651684066daa03b5f41ea05bcf360c8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga651684066daa03b5f41ea05bcf360c8e">DynamicSparsityPatternIterators::Iterator::operator==</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:ga651684066daa03b5f41ea05bcf360c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c7056a4913626d3df4ab02e0576b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga69c7056a4913626d3df4ab02e0576b40">DynamicSparsityPatternIterators::Iterator::operator!=</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:ga69c7056a4913626d3df4ab02e0576b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad289f97cba5e2d0ae6bedf129273bc5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad289f97cba5e2d0ae6bedf129273bc5e">DynamicSparsityPatternIterators::Iterator::operator&lt;</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;) const</td></tr>
<tr class="separator:gad289f97cba5e2d0ae6bedf129273bc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac2806ce6f426d7c2675f10212cb0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gadac2806ce6f426d7c2675f10212cb0c8">DynamicSparsityPatternIterators::Iterator::operator-</a> (const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;p) const</td></tr>
<tr class="separator:gadac2806ce6f426d7c2675f10212cb0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd181aef17e12fd56c8ca94ace05c9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8fd181aef17e12fd56c8ca94ace05c9e">DynamicSparsityPattern::DynamicSparsityPattern</a> ()</td></tr>
<tr class="separator:ga8fd181aef17e12fd56c8ca94ace05c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3622db24bcdf4c186eb5e0947ca89b6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3622db24bcdf4c186eb5e0947ca89b6f">DynamicSparsityPattern::DynamicSparsityPattern</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;)</td></tr>
<tr class="separator:ga3622db24bcdf4c186eb5e0947ca89b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976942bef275029caa4e62060690b7b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga976942bef275029caa4e62060690b7b4">DynamicSparsityPattern::DynamicSparsityPattern</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> m, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> n, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="group__Sparsity.html#ga2672023c3863f02a81d46fb9ea5b51b1">rowset</a>=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:ga976942bef275029caa4e62060690b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a268919f3f0ae9ddcc590b27eacb0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa6a268919f3f0ae9ddcc590b27eacb0a">DynamicSparsityPattern::DynamicSparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;indexset)</td></tr>
<tr class="separator:gaa6a268919f3f0ae9ddcc590b27eacb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939cc20e664903852dc34cfaa449ae14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga939cc20e664903852dc34cfaa449ae14">DynamicSparsityPattern::DynamicSparsityPattern</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> n)</td></tr>
<tr class="separator:ga939cc20e664903852dc34cfaa449ae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d9c95f86a949c8cbf6f46188fa803a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga57d9c95f86a949c8cbf6f46188fa803a">DynamicSparsityPattern::operator=</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;)</td></tr>
<tr class="separator:ga57d9c95f86a949c8cbf6f46188fa803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32f9f3ebad084d001349cd3ddb4074e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa32f9f3ebad084d001349cd3ddb4074e">DynamicSparsityPattern::reinit</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> m, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> n, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="group__Sparsity.html#ga2672023c3863f02a81d46fb9ea5b51b1">rowset</a>=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:gaa32f9f3ebad084d001349cd3ddb4074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ceb670be125dd2b8447e553374aa252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4ceb670be125dd2b8447e553374aa252">DynamicSparsityPattern::compress</a> ()</td></tr>
<tr class="separator:ga4ceb670be125dd2b8447e553374aa252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f777cdee3d8ed4b602d8102fe54911b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0f777cdee3d8ed4b602d8102fe54911b">DynamicSparsityPattern::empty</a> () const</td></tr>
<tr class="separator:ga0f777cdee3d8ed4b602d8102fe54911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfa1d39829c829f354af3b88cc9dd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaadfa1d39829c829f354af3b88cc9dd38">DynamicSparsityPattern::max_entries_per_row</a> () const</td></tr>
<tr class="separator:gaadfa1d39829c829f354af3b88cc9dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b1dc183fb130d188ee13a5c8ba9324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae8b1dc183fb130d188ee13a5c8ba9324">DynamicSparsityPattern::add</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> i, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> j)</td></tr>
<tr class="separator:gae8b1dc183fb130d188ee13a5c8ba9324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7b36840fa8fac8773c81e2d09bdafa"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga0f7b36840fa8fac8773c81e2d09bdafa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0f7b36840fa8fac8773c81e2d09bdafa">DynamicSparsityPattern::add_entries</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> row, ForwardIterator <a class="el" href="group__Sparsity.html#gaa7a69176e6bbca3e64805b0cd500db86">begin</a>, ForwardIterator <a class="el" href="group__Sparsity.html#ga54d7671ac9700b39572c3f2b318c9b9d">end</a>, const <a class="el" href="classbool.html">bool</a> indices_are_unique_and_sorted=false)</td></tr>
<tr class="separator:ga0f7b36840fa8fac8773c81e2d09bdafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f38772a4e0af734e01d4ad76bc17fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad6f38772a4e0af734e01d4ad76bc17fe">DynamicSparsityPattern::exists</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> i, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> j) const</td></tr>
<tr class="separator:gad6f38772a4e0af734e01d4ad76bc17fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23264e12d22d17767a7ef6b2bc47b9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga23264e12d22d17767a7ef6b2bc47b9a5">DynamicSparsityPattern::get_view</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="group__Sparsity.html#ga28b93db96b47f13a47950dad08a07ad0">rows</a>) const</td></tr>
<tr class="separator:ga23264e12d22d17767a7ef6b2bc47b9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb405a76dd681c216e8a371f12182e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gafb405a76dd681c216e8a371f12182e6e">DynamicSparsityPattern::symmetrize</a> ()</td></tr>
<tr class="separator:gafb405a76dd681c216e8a371f12182e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53eb9934e07a5de146cca99c2e65aee5"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternTypeLeft , typename SparsityPatternTypeRight &gt; </td></tr>
<tr class="memitem:ga53eb9934e07a5de146cca99c2e65aee5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga53eb9934e07a5de146cca99c2e65aee5">DynamicSparsityPattern::compute_mmult_pattern</a> (const SparsityPatternTypeLeft &amp;left, const SparsityPatternTypeRight &amp;right)</td></tr>
<tr class="separator:ga53eb9934e07a5de146cca99c2e65aee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44214be81221ccbe43bcf8e4548446e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternTypeLeft , typename SparsityPatternTypeRight &gt; </td></tr>
<tr class="memitem:gae44214be81221ccbe43bcf8e4548446e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae44214be81221ccbe43bcf8e4548446e">DynamicSparsityPattern::compute_Tmmult_pattern</a> (const SparsityPatternTypeLeft &amp;left, const SparsityPatternTypeRight &amp;right)</td></tr>
<tr class="separator:gae44214be81221ccbe43bcf8e4548446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02bf60f01c54494e09faef83cdce9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa02bf60f01c54494e09faef83cdce9a7">DynamicSparsityPattern::print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gaa02bf60f01c54494e09faef83cdce9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab90227179d3edcab862e8f104abbf243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab90227179d3edcab862e8f104abbf243">DynamicSparsityPattern::print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gab90227179d3edcab862e8f104abbf243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9941c7c73bfcec315af714e69f496159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga9941c7c73bfcec315af714e69f496159">DynamicSparsityPattern::n_rows</a> () const</td></tr>
<tr class="separator:ga9941c7c73bfcec315af714e69f496159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2b7c3a0e4fadc81c5805e604c50a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2d2b7c3a0e4fadc81c5805e604c50a09">DynamicSparsityPattern::n_cols</a> () const</td></tr>
<tr class="separator:ga2d2b7c3a0e4fadc81c5805e604c50a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e4f0b03970f1d820c1f8141c9f03168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7e4f0b03970f1d820c1f8141c9f03168">DynamicSparsityPattern::row_length</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> row) const</td></tr>
<tr class="separator:ga7e4f0b03970f1d820c1f8141c9f03168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab834dc1c62542c96b86dac74e75ef72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaab834dc1c62542c96b86dac74e75ef72">DynamicSparsityPattern::clear_row</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> row)</td></tr>
<tr class="separator:gaab834dc1c62542c96b86dac74e75ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f2226da6bfc7e7eea16cd3f3a0dd40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga87f2226da6bfc7e7eea16cd3f3a0dd40">DynamicSparsityPattern::column_number</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> row, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> index) const</td></tr>
<tr class="separator:ga87f2226da6bfc7e7eea16cd3f3a0dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86730419f3877f72842fa7c92346244d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga86730419f3877f72842fa7c92346244d">DynamicSparsityPattern::column_index</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> row, const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> col) const</td></tr>
<tr class="separator:ga86730419f3877f72842fa7c92346244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fd9b6fb152a12a57b37e5ca281b2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa0fd9b6fb152a12a57b37e5ca281b2f7">DynamicSparsityPattern::Line::add</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> col_num)</td></tr>
<tr class="separator:gaa0fd9b6fb152a12a57b37e5ca281b2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8838b3082af8e3a8e22e447a88641f5a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga8838b3082af8e3a8e22e447a88641f5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga8838b3082af8e3a8e22e447a88641f5a">DynamicSparsityPattern::Line::add_entries</a> (ForwardIterator <a class="el" href="group__Sparsity.html#gaa7a69176e6bbca3e64805b0cd500db86">begin</a>, ForwardIterator <a class="el" href="group__Sparsity.html#ga54d7671ac9700b39572c3f2b318c9b9d">end</a>, const <a class="el" href="classbool.html">bool</a> indices_are_sorted)</td></tr>
<tr class="separator:ga8838b3082af8e3a8e22e447a88641f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da4a1fea8a2ce185ca7a263d9621571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4da4a1fea8a2ce185ca7a263d9621571">DynamicSparsityPattern::Line::memory_consumption</a> () const</td></tr>
<tr class="separator:ga4da4a1fea8a2ce185ca7a263d9621571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f01a62b8aec73da7afb24236e706ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga5f01a62b8aec73da7afb24236e706ab7">internals::SparsityPatternTools::get_column_index_from_iterator</a> (const <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a> i)</td></tr>
<tr class="separator:ga5f01a62b8aec73da7afb24236e706ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781bf1039826e234a8a659c63b75be64"><td class="memTemplParams" colspan="2">template&lt;typename value &gt; </td></tr>
<tr class="memitem:ga781bf1039826e234a8a659c63b75be64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga781bf1039826e234a8a659c63b75be64">internals::SparsityPatternTools::get_column_index_from_iterator</a> (const std::pair&lt; <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>, value &gt; &amp;i)</td></tr>
<tr class="separator:ga781bf1039826e234a8a659c63b75be64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac123fc873fff5629d265fd7731867d43"><td class="memTemplParams" colspan="2">template&lt;typename value &gt; </td></tr>
<tr class="memitem:gac123fc873fff5629d265fd7731867d43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac123fc873fff5629d265fd7731867d43">internals::SparsityPatternTools::get_column_index_from_iterator</a> (const std::pair&lt; const <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>, value &gt; &amp;i)</td></tr>
<tr class="separator:gac123fc873fff5629d265fd7731867d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ae1c2d42607e4a4531ff8da66b9869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae2ae1c2d42607e4a4531ff8da66b9869">SparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *matrix, const std::size_t <a class="el" href="group__Sparsity.html#gaefe597a5a4c58ecdff28a4d4c75f5aa6">linear_index</a>)</td></tr>
<tr class="separator:gae2ae1c2d42607e4a4531ff8da66b9869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea2dc74a02b3dd3375ff1904ce254f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gadea2dc74a02b3dd3375ff1904ce254f3">SparsityPatternIterators::Accessor::Accessor</a> (const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *matrix)</td></tr>
<tr class="separator:gadea2dc74a02b3dd3375ff1904ce254f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41c5085f9d57d795a61ffb7e36fb784"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf41c5085f9d57d795a61ffb7e36fb784">SparsityPatternIterators::Accessor::Accessor</a> ()</td></tr>
<tr class="separator:gaf41c5085f9d57d795a61ffb7e36fb784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67096e8bc60d364e9450260dab9d4397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga67096e8bc60d364e9450260dab9d4397">SparsityPatternIterators::Accessor::row</a> () const</td></tr>
<tr class="separator:ga67096e8bc60d364e9450260dab9d4397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838f049ae1f234066b9b3366f3c4f5bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga838f049ae1f234066b9b3366f3c4f5bb">SparsityPatternIterators::Accessor::index</a> () const</td></tr>
<tr class="separator:ga838f049ae1f234066b9b3366f3c4f5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6358815e9f89a7706975c9fdc3890aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga6358815e9f89a7706975c9fdc3890aa4">SparsityPatternIterators::Accessor::global_index</a> () const</td></tr>
<tr class="separator:ga6358815e9f89a7706975c9fdc3890aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf486a00971aad248b16d5e847e1848b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf486a00971aad248b16d5e847e1848b5">SparsityPatternIterators::Accessor::column</a> () const</td></tr>
<tr class="separator:gaf486a00971aad248b16d5e847e1848b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05107e125b6d82daf62e612fa289e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf05107e125b6d82daf62e612fa289e73">SparsityPatternIterators::Accessor::is_valid_entry</a> () const</td></tr>
<tr class="separator:gaf05107e125b6d82daf62e612fa289e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e3645cf34ff78939ff8ffd6731fcdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga63e3645cf34ff78939ff8ffd6731fcdb">SparsityPatternIterators::Accessor::operator==</a> (const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:ga63e3645cf34ff78939ff8ffd6731fcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9185b4c659826331a16fafeff343bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gad9185b4c659826331a16fafeff343bc7">SparsityPatternIterators::Accessor::operator&lt;</a> (const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;) const</td></tr>
<tr class="separator:gad9185b4c659826331a16fafeff343bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dceec81473ac3a17beaaf59d29e12ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga9dceec81473ac3a17beaaf59d29e12ff">SparsityPatternIterators::Accessor::DeclExceptionMsg</a> (DummyAccessor, &quot;The instance of this class was initialized&quot; &quot; without <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object, which&quot; &quot; means that it is a dummy accessor that can&quot; &quot; not do any operations.&quot;)</td></tr>
<tr class="separator:ga9dceec81473ac3a17beaaf59d29e12ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0d7a91819f5077c4b25abb0ef74a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gafe0d7a91819f5077c4b25abb0ef74a76">SparsityPatternIterators::Accessor::advance</a> ()</td></tr>
<tr class="separator:gafe0d7a91819f5077c4b25abb0ef74a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212447d9b662791324a410240f920f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga212447d9b662791324a410240f920f29">SparsityPatternIterators::Iterator::Iterator</a> (const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *sp, const std::size_t linear_index)</td></tr>
<tr class="separator:ga212447d9b662791324a410240f920f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8f413087919c54a805c022128c19c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gacd8f413087919c54a805c022128c19c7">SparsityPatternIterators::Iterator::Iterator</a> (const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;<a class="el" href="classLinearIndexIterator.html#ab8716737b68aa4ea167f39a186023fec">accessor</a>)</td></tr>
<tr class="separator:gacd8f413087919c54a805c022128c19c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5ea1fc99de62b1367c495337477e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2c5ea1fc99de62b1367c495337477e9e">BlockDynamicSparsityPattern::column_number</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> row, const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ga2c5ea1fc99de62b1367c495337477e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaddfdea0c37c5c468e7a76dc47840ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaaddfdea0c37c5c468e7a76dc47840ff9">BlockSparsityPattern::reinit</a> (const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html#ga124486ee59f893c19806a6a9d9c826af">n_block_rows</a>, const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> n_block_columns)</td></tr>
<tr class="separator:gaaddfdea0c37c5c468e7a76dc47840ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae6efac28d03eb104562e88a809790883"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae6efac28d03eb104562e88a809790883">BlockSparsityPatternBase&lt; SparsityPatternType &gt;::invalid_entry</a> = SparsityPattern::invalid_entry</td></tr>
<tr class="separator:gae6efac28d03eb104562e88a809790883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bee1bf95816c5bc5d1fa863709b6adb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3bee1bf95816c5bc5d1fa863709b6adb">ChunkSparsityPatternIterators::Accessor::sparsity_pattern</a></td></tr>
<tr class="separator:ga3bee1bf95816c5bc5d1fa863709b6adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e28f6cf9346acf73d41b09429914454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html">SparsityPatternIterators::Accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0e28f6cf9346acf73d41b09429914454">ChunkSparsityPatternIterators::Accessor::reduced_accessor</a></td></tr>
<tr class="separator:ga0e28f6cf9346acf73d41b09429914454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e4d85ce7b010b45534e077b3ec3f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf6e4d85ce7b010b45534e077b3ec3f39">ChunkSparsityPatternIterators::Accessor::chunk_row</a></td></tr>
<tr class="separator:gaf6e4d85ce7b010b45534e077b3ec3f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eacf46d3f30fd32806f255171a3389c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1eacf46d3f30fd32806f255171a3389c">ChunkSparsityPatternIterators::Accessor::chunk_col</a></td></tr>
<tr class="separator:ga1eacf46d3f30fd32806f255171a3389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084938eb3e5871f67ecc0ef712ecb365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga084938eb3e5871f67ecc0ef712ecb365">ChunkSparsityPatternIterators::Iterator::accessor</a></td></tr>
<tr class="separator:ga084938eb3e5871f67ecc0ef712ecb365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07435d9948f56fdfcd2da48d321a733b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga07435d9948f56fdfcd2da48d321a733b">ChunkSparsityPattern::invalid_entry</a> = SparsityPattern::invalid_entry</td></tr>
<tr class="separator:ga07435d9948f56fdfcd2da48d321a733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20831f347c1aa6d8fddbff4327ecd698"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga20831f347c1aa6d8fddbff4327ecd698">DynamicSparsityPatternIterators::Accessor::sparsity_pattern</a></td></tr>
<tr class="separator:ga20831f347c1aa6d8fddbff4327ecd698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808262f5f634c1141cb412a55d9c1fcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga808262f5f634c1141cb412a55d9c1fcd">DynamicSparsityPatternIterators::Accessor::current_row</a></td></tr>
<tr class="separator:ga808262f5f634c1141cb412a55d9c1fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0527eb1e9116064b33a3bd570bb63d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gabb0527eb1e9116064b33a3bd570bb63d">DynamicSparsityPatternIterators::Accessor::current_entry</a></td></tr>
<tr class="separator:gabb0527eb1e9116064b33a3bd570bb63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55be108e835041773cef6b09de5c3d9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga55be108e835041773cef6b09de5c3d9c">DynamicSparsityPatternIterators::Accessor::end_of_row</a></td></tr>
<tr class="separator:ga55be108e835041773cef6b09de5c3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b11c7e62ae37df8940661610d63b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga69b11c7e62ae37df8940661610d63b8f">DynamicSparsityPatternIterators::Iterator::accessor</a></td></tr>
<tr class="separator:ga69b11c7e62ae37df8940661610d63b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335542a5ba7533469cd9d0f0d4696a9d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga335542a5ba7533469cd9d0f0d4696a9d">DynamicSparsityPattern::Line::entries</a></td></tr>
<tr class="separator:ga335542a5ba7533469cd9d0f0d4696a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda55d958060e7650c62037bc15bcad2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaeda55d958060e7650c62037bc15bcad2">SparsityPatternIterators::Accessor::container</a></td></tr>
<tr class="separator:gaeda55d958060e7650c62037bc15bcad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe597a5a4c58ecdff28a4d4c75f5aa6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaefe597a5a4c58ecdff28a4d4c75f5aa6">SparsityPatternIterators::Accessor::linear_index</a></td></tr>
<tr class="separator:gaefe597a5a4c58ecdff28a4d4c75f5aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827dd2a6a48aa827edc8eda109fc27c8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga827dd2a6a48aa827edc8eda109fc27c8">SparsityPatternBase::invalid_entry</a> = <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a></td></tr>
<tr class="separator:ga827dd2a6a48aa827edc8eda109fc27c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gab98ab372c63eaaf5e78f53002b678126"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab98ab372c63eaaf5e78f53002b678126">ChunkSparsityPatternIterators::Accessor::Iterator</a></td></tr>
<tr class="separator:gab98ab372c63eaaf5e78f53002b678126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98ab372c63eaaf5e78f53002b678126"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab98ab372c63eaaf5e78f53002b678126">DynamicSparsityPatternIterators::Accessor::Iterator</a></td></tr>
<tr class="separator:gab98ab372c63eaaf5e78f53002b678126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58b69743a1fc8209af1427247bad7b4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae58b69743a1fc8209af1427247bad7b4">SparsityPatternIterators::Accessor::LinearIndexIterator&lt; Iterator, Accessor &gt;</a></td></tr>
<tr class="separator:gae58b69743a1fc8209af1427247bad7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8cb66f1f83ca02d1cbe16924ddfb76"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga4b8cb66f1f83ca02d1cbe16924ddfb76">SparsityPatternIterators::Accessor::ChunkSparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:ga4b8cb66f1f83ca02d1cbe16924ddfb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Iterators</h2></td></tr>
<tr class="memitem:ga864232a7239785d7a8c201c81914305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga864232a7239785d7a8c201c81914305e">DynamicSparsityPattern::have_entries</a></td></tr>
<tr class="separator:ga864232a7239785d7a8c201c81914305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b93db96b47f13a47950dad08a07ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga28b93db96b47f13a47950dad08a07ad0">DynamicSparsityPattern::rows</a></td></tr>
<tr class="separator:ga28b93db96b47f13a47950dad08a07ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26fed625d6b7127c1face8133e71413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac26fed625d6b7127c1face8133e71413">DynamicSparsityPattern::cols</a></td></tr>
<tr class="separator:gac26fed625d6b7127c1face8133e71413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2672023c3863f02a81d46fb9ea5b51b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2672023c3863f02a81d46fb9ea5b51b1">DynamicSparsityPattern::rowset</a></td></tr>
<tr class="separator:ga2672023c3863f02a81d46fb9ea5b51b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ef582c284525e8b73895670d1ec986"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structDynamicSparsityPattern_1_1Line.html">Line</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga27ef582c284525e8b73895670d1ec986">DynamicSparsityPattern::lines</a></td></tr>
<tr class="separator:ga27ef582c284525e8b73895670d1ec986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f948b4c2f3b204e9fd3576ddad5bc76"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0f948b4c2f3b204e9fd3576ddad5bc76">DynamicSparsityPattern::DynamicSparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:ga0f948b4c2f3b204e9fd3576ddad5bc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a69176e6bbca3e64805b0cd500db86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa7a69176e6bbca3e64805b0cd500db86">DynamicSparsityPattern::begin</a> () const</td></tr>
<tr class="separator:gaa7a69176e6bbca3e64805b0cd500db86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d7671ac9700b39572c3f2b318c9b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga54d7671ac9700b39572c3f2b318c9b9d">DynamicSparsityPattern::end</a> () const</td></tr>
<tr class="separator:ga54d7671ac9700b39572c3f2b318c9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16befb1de3d170854dd467fc4e698bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga16befb1de3d170854dd467fc4e698bd2">DynamicSparsityPattern::begin</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> r) const</td></tr>
<tr class="separator:ga16befb1de3d170854dd467fc4e698bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3b08da02adb46dfde2d7ec4d9f9468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3f3b08da02adb46dfde2d7ec4d9f9468">DynamicSparsityPattern::end</a> (const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> r) const</td></tr>
<tr class="separator:ga3f3b08da02adb46dfde2d7ec4d9f9468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb39f4db9cca46254d724dc74df08ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaeb39f4db9cca46254d724dc74df08ec7">DynamicSparsityPattern::bandwidth</a> () const</td></tr>
<tr class="separator:gaeb39f4db9cca46254d724dc74df08ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62dcab5a89ebb242a4e3390e389cfc8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga62dcab5a89ebb242a4e3390e389cfc8c">DynamicSparsityPattern::n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ga62dcab5a89ebb242a4e3390e389cfc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c0fbf383a8d4b72cd6387a281dd5b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae6c0fbf383a8d4b72cd6387a281dd5b5">DynamicSparsityPattern::row_index_set</a> () const</td></tr>
<tr class="separator:gae6c0fbf383a8d4b72cd6387a281dd5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1066e0de41ad0c51826d5f7ac498a67c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1066e0de41ad0c51826d5f7ac498a67c">DynamicSparsityPattern::nonempty_cols</a> () const</td></tr>
<tr class="separator:ga1066e0de41ad0c51826d5f7ac498a67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea20a2ef7e88478514c264dbee9ba192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaea20a2ef7e88478514c264dbee9ba192">DynamicSparsityPattern::nonempty_rows</a> () const</td></tr>
<tr class="separator:gaea20a2ef7e88478514c264dbee9ba192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e5e23766ade844803fc897e81af39d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga87e5e23766ade844803fc897e81af39d">DynamicSparsityPattern::stores_only_added_elements</a> ()</td></tr>
<tr class="separator:ga87e5e23766ade844803fc897e81af39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4038aec0cfdcc324296c249aca9987f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf4038aec0cfdcc324296c249aca9987f">DynamicSparsityPattern::memory_consumption</a> () const</td></tr>
<tr class="separator:gaf4038aec0cfdcc324296c249aca9987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Iterators</h2></td></tr>
<tr class="memitem:gac9fd724a24c574100d582ad33722884f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gac9fd724a24c574100d582ad33722884f">SparsityPatternBase::begin</a> () const</td></tr>
<tr class="separator:gac9fd724a24c574100d582ad33722884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga688dd4995902ab99fa419d12484ae548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga688dd4995902ab99fa419d12484ae548">SparsityPatternBase::end</a> () const</td></tr>
<tr class="separator:ga688dd4995902ab99fa419d12484ae548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7121b88b0435b93497f8ab6ea7ee5c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7121b88b0435b93497f8ab6ea7ee5c0b">SparsityPatternBase::begin</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> r) const</td></tr>
<tr class="separator:ga7121b88b0435b93497f8ab6ea7ee5c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae647faa02955ab0a43333d16297c6750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gae647faa02955ab0a43333d16297c6750">SparsityPatternBase::end</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> r) const</td></tr>
<tr class="separator:gae647faa02955ab0a43333d16297c6750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Querying information</h2></td></tr>
<tr class="memitem:ga19e09b29ddae80a77a184bd081111fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga19e09b29ddae80a77a184bd081111fb5">SparsityPatternBase::operator==</a> (const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> &amp;) const</td></tr>
<tr class="separator:ga19e09b29ddae80a77a184bd081111fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea2ecbf49c88fcb9bf6dc35d3d45b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga5ea2ecbf49c88fcb9bf6dc35d3d45b4d">SparsityPatternBase::empty</a> () const</td></tr>
<tr class="separator:ga5ea2ecbf49c88fcb9bf6dc35d3d45b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653ae26e6c6ec67639c6f36144f583dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga653ae26e6c6ec67639c6f36144f583dd">SparsityPatternBase::exists</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> i, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> j) const</td></tr>
<tr class="separator:ga653ae26e6c6ec67639c6f36144f583dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe38c6ef54df0033741e2d29f41f71ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gafe38c6ef54df0033741e2d29f41f71ad">SparsityPatternBase::max_entries_per_row</a> () const</td></tr>
<tr class="separator:gafe38c6ef54df0033741e2d29f41f71ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc1c584a2e274ea0a885fc28a0fc3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1dc1c584a2e274ea0a885fc28a0fc3bc">SparsityPatternBase::bandwidth</a> () const</td></tr>
<tr class="separator:ga1dc1c584a2e274ea0a885fc28a0fc3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0707927053081fd6c46dac186e63c543"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga0707927053081fd6c46dac186e63c543">SparsityPatternBase::n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ga0707927053081fd6c46dac186e63c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d6d95e0b21b597b06b094c70de2f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga84d6d95e0b21b597b06b094c70de2f2e">SparsityPatternBase::is_compressed</a> () const</td></tr>
<tr class="separator:ga84d6d95e0b21b597b06b094c70de2f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f9eaaf6d72dcda84b91155918284cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga54f9eaaf6d72dcda84b91155918284cb">SparsityPatternBase::n_rows</a> () const</td></tr>
<tr class="separator:ga54f9eaaf6d72dcda84b91155918284cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14c01672d8104140704a98b9f18fcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf14c01672d8104140704a98b9f18fcfb">SparsityPatternBase::n_cols</a> () const</td></tr>
<tr class="separator:gaf14c01672d8104140704a98b9f18fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5144f4bb094460afd2c258f1e295bbc5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga5144f4bb094460afd2c258f1e295bbc5">SparsityPatternBase::row_length</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> row) const</td></tr>
<tr class="separator:ga5144f4bb094460afd2c258f1e295bbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0941b7048d52742bcb3ad11e46c7e57"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gab0941b7048d52742bcb3ad11e46c7e57">SparsityPatternBase::memory_consumption</a> () const</td></tr>
<tr class="separator:gab0941b7048d52742bcb3ad11e46c7e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessing entries</h2></td></tr>
<tr class="memitem:ga693eb9b754cb846967c84d648c737b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga693eb9b754cb846967c84d648c737b29">SparsityPatternBase::column_number</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> row, const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ga693eb9b754cb846967c84d648c737b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3bb2176471a4524ab88cc5cd6c7f30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga1c3bb2176471a4524ab88cc5cd6c7f30">SparsityPatternBase::row_position</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> i, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> j) const</td></tr>
<tr class="separator:ga1c3bb2176471a4524ab88cc5cd6c7f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0d069f88fdde21c5983efb725ac355"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>, <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3f0d069f88fdde21c5983efb725ac355">SparsityPatternBase::matrix_position</a> (const std::size_t global_index) const</td></tr>
<tr class="separator:ga3f0d069f88fdde21c5983efb725ac355"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Input/Output</h2></td></tr>
<tr class="memitem:ga5d941ca61962e3f9fffc3979731a79d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5d941ca61962e3f9fffc3979731a79d2">SparsityPatternBase::print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga5d941ca61962e3f9fffc3979731a79d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f59a68863a1e770ba275894a7170e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7f59a68863a1e770ba275894a7170e70">SparsityPatternBase::print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga7f59a68863a1e770ba275894a7170e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226ebb78284e9c60ddda8e3ae6779d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga226ebb78284e9c60ddda8e3ae6779d60">SparsityPatternBase::print_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga226ebb78284e9c60ddda8e3ae6779d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0635b1e8213ec4c51a9651dee34b3a5d"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga0635b1e8213ec4c51a9651dee34b3a5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0635b1e8213ec4c51a9651dee34b3a5d">SparsityPatternBase::save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:ga0635b1e8213ec4c51a9651dee34b3a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2c1125d76dde276bd6f504b1ec7f07"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga9d2c1125d76dde276bd6f504b1ec7f07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9d2c1125d76dde276bd6f504b1ec7f07">SparsityPatternBase::load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga9d2c1125d76dde276bd6f504b1ec7f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c76cfef0d63da0eaa6f63ff12cd1c3"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga01c76cfef0d63da0eaa6f63ff12cd1c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga01c76cfef0d63da0eaa6f63ff12cd1c3">SparsityPatternBase::serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga01c76cfef0d63da0eaa6f63ff12cd1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Construction and Initialization</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc3415fb5cf2f747bd9b1b420ea553af5"></a>Constructors, destructor, functions initializing, copying and filling an object. </p>
</td></tr>
<tr class="memitem:gabd231cc10a5192d97adf3547ee781b1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gabd231cc10a5192d97adf3547ee781b1f">SparsityPatternBase::SparsityPatternBase</a> ()</td></tr>
<tr class="separator:gabd231cc10a5192d97adf3547ee781b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c7e199d66bb83b69d52d126a536f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaa7c7e199d66bb83b69d52d126a536f06">SparsityPatternBase::~SparsityPatternBase</a> () override=default</td></tr>
<tr class="separator:gaa7c7e199d66bb83b69d52d126a536f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b74407cb9f120f1c568209452e1b443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga3b74407cb9f120f1c568209452e1b443">SparsityPatternBase::reinit</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> m, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> n, const unsigned <a class="el" href="classint.html">int</a> max_per_row)</td></tr>
<tr class="separator:ga3b74407cb9f120f1c568209452e1b443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64a59aef077cd122909bc3d510b00c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#gaf64a59aef077cd122909bc3d510b00c8">SparsityPatternBase::reinit</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> m, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> n, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;row_lengths)</td></tr>
<tr class="separator:gaf64a59aef077cd122909bc3d510b00c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7422bfd9cc2855cf992d156569f056ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga7422bfd9cc2855cf992d156569f056ae">SparsityPatternBase::reinit</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> m, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> n, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;row_lengths)=0</td></tr>
<tr class="separator:ga7422bfd9cc2855cf992d156569f056ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c1ebb8fbefcdce0a313e7be27ad34d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga16c1ebb8fbefcdce0a313e7be27ad34d">SparsityPatternBase::symmetrize</a> ()</td></tr>
<tr class="separator:ga16c1ebb8fbefcdce0a313e7be27ad34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b55cadc7817ef973735f3caa02b8502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Sparsity.html#ga2b55cadc7817ef973735f3caa02b8502">SparsityPatternBase::add</a> (const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> i, const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> j)</td></tr>
<tr class="separator:ga2b55cadc7817ef973735f3caa02b8502"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Almost all finite element formulations lead to matrices that are "sparse", i.e., for which the number of nonzero elements per row is (i) relatively small compared to the overall size of the matrix, and (ii) bounded by a fixed number that does not grow if the mesh is refined. For such cases, it is more efficient to not store <em>all</em> elements of the matrix, but only those that are actually (or may be) nonzero. This requires storing, for each row, the column indices of the nonzero entries (we call this the "sparsity
  pattern") as well as the actual values of these nonzero entries. (In practice, it sometimes happens that some of the nonzero values are, in fact, zero. Sparsity patterns and sparse matrices only intend to provision space for entries that <em>may</em> be nonzero, and do so at a time when we don't know yet what values these entries will ultimately have; they may have a zero value if a coefficient or cell happens to have particular values.) </p>
<p>lead to matrices that are "sparse", i.e., for which the number of nonzero elements per row is (i) relatively small compared to the overall size of the matrix, and (ii) bounded by a fixed number that does not grow if the mesh is refined. For such cases, it is more efficient to not store <em>all</em> elements of the matrix, but only those that are actually (or may be) nonzero. This requires storing, for each row, the column indices of the nonzero entries (we call this the "sparsity pattern") as well as the actual values of these nonzero entries. (In practice, it sometimes happens that some of the nonzero values are, in fact, zero. Sparsity patterns and sparse matrices only intend to provision space for entries that <em>may</em> be nonzero, and do so at a time when we don't know yet what values these entries will ultimately have; they may have a zero value if a coefficient or cell happens to have particular values.) In deal.II, sparsity patterns are typically separated from the actual sparse matrices (with the exception of the <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a> class and some classes from interfaces to external libraries such as PETSc). The reason is that one often has several matrices that share the same sparsity pattern; examples include the stiffness and mass matrices necessary for time stepping schemes, or the left and right hand side matrix of generalized eigenvalue problems. It would therefore be wasteful if each of them had to store their sparsity pattern separately. Consequently, deal.II has sparsity pattern classes that matrix classes build on. There are two main groups of sparsity pattern classes, as discussed below:</p>
<p>In deal.II, sparsity patterns are typically separated from the actual sparse matrices (with the exception of the <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a> class and some classes from interfaces to external libraries such as PETSc). The reason is that one often has several matrices that share the same sparsity pattern; examples include the stiffness and mass matrices necessary for time stepping schemes, or the left and right hand side matrix of generalized eigenvalue problems. It would therefore be wasteful if each of them had to store their sparsity pattern separately.</p>
<p>Consequently, deal.II has sparsity pattern classes that matrix classes build on. There are two main groups of sparsity pattern classes, as discussed below:</p>
<h4>"Static" sparsity patterns</h4>
<p>The main sparse matrix class in deal.II, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, only stores a value for each matrix entry, but not where these entries are located. For this, it relies on the information it gets from a sparsity pattern object associated with this matrix. This sparsity pattern object must be of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a>.</p>
<p>Because matrices are large objects and because it is comparatively expensive to change them, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> objects are built in two phases: first, in a "dynamic" phase, one allocates positions where one expects matrices built on it to have nonzero entries; in a second "static" phase, the representation of these nonzero locations is "compressed" into the usual Compressed Sparse Row (CSR) format. After this, no new nonzero locations may be added. Only after compression can a sparsity pattern be associated to a matrix, since the latter requires the efficient compressed data format of the former. Building a sparsity pattern during the dynamic phase often happens with the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function. Although this may appear a restriction, it is typically not a significant problem to first build a sparsity pattern and then to write into the matrix only in the previously allocated locations, since in finite element codes it is normally quite clear which elements of a matrix can possibly be nonzero and which are definitely zero.</p>
<p>The advantage of this two-phase generation of a sparsity pattern is that when it is actually used with a matrix, a very efficient format is available. In particular, the locations of entries are stored in a linear array that allows for rapid access friendly to modern CPU types with deep hierarchies of caches. Consequently, the static <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class is the only one on which deal.II's main <a class="el" href="classSparseMatrix.html">SparseMatrix</a> class can work.</p>
<p>The main drawback of static sparsity patterns is that their efficient construction requires a reasonably good guess how many entries each of the rows may maximally have. During the actual construction, for example in the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function, only at most as many entries can be allocated as previously stated. This is a problem because it is often difficult to estimate the maximal number of entries per row. Consequently, a common strategy is to first build and intermediate sparsity pattern that uses a less efficient storage scheme during construction of the sparsity pattern and later copy it directly into the static, compressed form. Most tutorial programs do this, starting at <a class="el" href="step_2.html">step-2</a> (see also, for example the <a class="el" href="step_11.html">step-11</a>, <a class="el" href="step_18.html">step-18</a>, and <a class="el" href="step_27.html">step-27</a> tutorial programs).</p>
<h4>"Dynamic" or "compressed" sparsity patterns</h4>
<p>As explained above, it is often complicated to obtain good estimates for the maximal number of entries in each row of a sparsity pattern. Consequently, any attempts to allocate a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> with bad estimates requires huge amounts of memory, almost all of which will not be used and be de-allocated upon compression.</p>
<p>To avoid this, deal.II contains a "dynamic" or "compressed" sparsity pattern called <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that only allocates as much memory as necessary to hold the currently added entries. While this saves much memory compared to the worst-case behavior mentioned above, it requires the use of less efficient storage schemes for insertion of elements, and the frequent allocation of memory often also takes significant compute time. The tradeoff to avoid excessive memory allocation cannot be avoided, however.</p>
<p>The class is typically used in the following way </p><pre class="fragment">* DynamicSparsityPattern dsp (dof_handler.n_dofs());
* DoFTools::make_sparsity_pattern (dof_handler,
*                                  dsp);
* constraints.condense (dsp);
*
* SparsityPattern final_sparsity_pattern;
* final_sparsity_pattern.copy_from (dsp);
* </pre><p>The intermediate, compressed sparsity pattern is directly copied into the "compressed" form of the final static pattern.</p>
<h4>Dynamic block sparsity patterns</h4>
<p>The class <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> implements an array of dynamic sparsity patterns for constructing block matrices. See the documentation and <a class="el" href="step_22.html">step-22</a> for more information.</p>
<h4>"Static" sparsity patterns</h4>
<p>The main sparse matrix class in deal.II, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, only stores a value for each matrix entry, but not where these entries are located. For this, it relies on the information it gets from a sparsity pattern object associated with this matrix. This sparsity pattern object must be of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a>. Because matrices are large objects and because it is comparatively expensive to change them, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> objects are built in two phases: first, in a "dynamic" phase, one allocates positions where one expects matrices built on it to have nonzero entries; in a second "static" phase, the representation of these nonzero locations is "compressed" into the usual Compressed Sparse Row (CSR) format. After this, no new nonzero locations may be added. Only after compression can a sparsity pattern be associated to a matrix, since the latter requires the efficient compressed data format of the former. Building a sparsity pattern during the dynamic phase often happens with the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function. Although this may appear a restriction, it is typically not a significant problem to first build a sparsity pattern and then to write into the matrix only in the previously allocated locations, since in finite element codes it is normally quite clear which elements of a matrix can possibly be nonzero and which are definitely zero. The advantage of this two-phase generation of a sparsity pattern is that when it is actually used with a matrix, a very efficient format is available. In particular, the locations of entries are stored in a linear array that allows for rapid access friendly to modern CPU types with deep hierarchies of caches. Consequently, the static <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class is the only one on which deal.II's main <a class="el" href="classSparseMatrix.html">SparseMatrix</a> class can work. The main drawback of static sparsity patterns is that their efficient construction requires a reasonably good guess how many entries each of the rows may maximally have. During the actual construction, for example in the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function, only at most as many entries can be allocated as previously stated. This is a problem because it is often difficult to estimate the maximal number of entries per row. Consequently, a common strategy is to first build and intermediate sparsity pattern that uses a less efficient storage scheme during construction of the sparsity pattern and later copy it directly into the static, compressed form. Most tutorial programs do this, starting at <a class="el" href="step_2.html">step-2</a> (see also, for example the <a class="el" href="step_11.html">step-11</a> , <a class="el" href="step_18.html">step-18</a> , and <a class="el" href="step_27.html">step-27</a> tutorial programs).</p>
<h4>"Dynamic" or "compressed" sparsity patterns</h4>
<p>As explained above, it is often complicated to obtain good estimates for the maximal number of entries in each row of a sparsity pattern. Consequently, any attempts to allocate a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> with bad estimates requires huge amounts of memory, almost all of which will not be used and be de-allocated upon compression. To avoid this, deal.II contains a "dynamic" or "compressed" sparsity pattern called <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that only allocates as much memory as necessary to hold the currently added entries. While this saves much memory compared to the worst-case behavior mentioned above, it requires the use of less efficient storage schemes for insertion of elements, and the frequent allocation of memory often also takes significant compute time. The tradeoff to avoid excessive memory allocation cannot be avoided, however. The class is typically used in the following way</p>
<pre class="fragment">* DynamicSparsityPattern dsp (dof_handler.n_dofs());
* DoFTools::make_sparsity_pattern (dof_handler,
*                                dsp);
* constraints.condense (dsp);
*
* SparsityPattern final_sparsity_pattern;
* final_sparsity_pattern.copy_from (dsp);
* </pre><p>The intermediate, compressed sparsity pattern is directly copied into the "compressed" form of the final static pattern. </p><h4>Dynamic block sparsity patterns</h4>
<p>The class <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> implements an array of dynamic sparsity patterns for constructing block matrices. See the documentation and <a class="el" href="step_22.html">step-22</a> for more information.</p>
<p><br  />
 </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4d8af14de1e21c26eaeb48fd31846bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8af14de1e21c26eaeb48fd31846bdc">&#9670;&nbsp;</a></span>size_type <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::<a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2block__sparsity__pattern_8h_source.html#l00084">84</a> of file <a class="el" href="origin_2lac_2block__sparsity__pattern_8h_source.html">block_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga79094ea32b3807c12b049b1c7c34bff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79094ea32b3807c12b049b1c7c34bff7">&#9670;&nbsp;</a></span>size_type <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">ChunkSparsityPatternIterators::Accessor::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html#l00068">68</a> of file <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga6e5a691b2c5146bc4f8216239c5fe511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e5a691b2c5146bc4f8216239c5fe511">&#9670;&nbsp;</a></span>size_type <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html#a6e5a691b2c5146bc4f8216239c5fe511">ChunkSparsityPatternIterators::Iterator::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html#l00172">172</a> of file <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga43fe54b08913d30ae5dcb81fc72107bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43fe54b08913d30ae5dcb81fc72107bb">&#9670;&nbsp;</a></span>size_type <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">ChunkSparsityPattern::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html#l00248">248</a> of file <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gaa72ff0b1fe466759e60bd34f89eb03ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa72ff0b1fe466759e60bd34f89eb03ac">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparsityPattern.html#aa72ff0b1fe466759e60bd34f89eb03ac">ChunkSparsityPattern::const_iterator</a> =  <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">ChunkSparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef an iterator class that allows to walk over all nonzero elements of a sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html#l00253">253</a> of file <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga10e66cf5c0ef12063c3f5d5b0404bc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e66cf5c0ef12063c3f5d5b0404bc4e">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">ChunkSparsityPattern::iterator</a> =  <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">ChunkSparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef an iterator class that allows to walk over all nonzero elements of a sparsity pattern.</p>
<p>Since the iterator does not allow to modify the sparsity pattern, this type is the same as that for <code>const_iterator</code>. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html#l00262">262</a> of file <a class="el" href="origin_2lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gadfbeb2cf093e039975a1e99924b96690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfbeb2cf093e039975a1e99924b96690">&#9670;&nbsp;</a></span>size_type <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">DynamicSparsityPatternIterators::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00059">59</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga2d7249323016034cf1e20072c0b58907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d7249323016034cf1e20072c0b58907">&#9670;&nbsp;</a></span>size_type <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html#l00324">324</a> of file <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga18ab16f163487d426b3ecb653a0ad927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ab16f163487d426b3ecb653a0ad927">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">DynamicSparsityPattern::iterator</a> =  <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">DynamicSparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef an for iterator class that allows to walk over all nonzero elements of a sparsity pattern.</p>
<p>Since the iterator does not allow to modify the sparsity pattern, this type is the same as that for <code>const_iterator</code>. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html#l00333">333</a> of file <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga7ab428801ce75a718d7b668d429eb7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab428801ce75a718d7b668d429eb7c6">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynamicSparsityPattern.html#a7ab428801ce75a718d7b668d429eb7c6">DynamicSparsityPattern::const_iterator</a> =  <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">DynamicSparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for an iterator class that allows to walk over all nonzero elements of a sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html#l00339">339</a> of file <a class="el" href="origin_2lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga12e241eb348f5c446ddf05a08826eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e241eb348f5c446ddf05a08826eb31">&#9670;&nbsp;</a></span>size_type <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">internals::SparsityPatternTools::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00078">78</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga8f04b492c7622ec4bd071ccdce18d396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f04b492c7622ec4bd071ccdce18d396">&#9670;&nbsp;</a></span>size_type <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="group__Sparsity.html#ga8f04b492c7622ec4bd071ccdce18d396">SparsityPatternIterators::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00127">127</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga7806ed33918ff4d52d022b9a1872a457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7806ed33918ff4d52d022b9a1872a457">&#9670;&nbsp;</a></span>size_type <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">SparsityPatternIterators::Accessor::size_type</a> =  <a class="el" href="group__Sparsity.html#ga8f04b492c7622ec4bd071ccdce18d396">SparsityPatternIterators::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size type of <a class="el" href="classSparsityPattern.html">SparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00137">137</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga5ec97555e6eefafcc8a01ca7c6d013b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec97555e6eefafcc8a01ca7c6d013b3">&#9670;&nbsp;</a></span>size_type <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternIterators_1_1Iterator.html#a5ec97555e6eefafcc8a01ca7c6d013b3">SparsityPatternIterators::Iterator::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size type. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00284">284</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gadb4e9b21ca516c5a2ca10869cfa44ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb4e9b21ca516c5a2ca10869cfa44ca1">&#9670;&nbsp;</a></span>container_pointer_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternIterators_1_1Iterator.html#adb4e9b21ca516c5a2ca10869cfa44ca1">SparsityPatternIterators::Iterator::container_pointer_type</a> =  <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the stored pointer. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00289">289</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga39c7b2070bea3afe6064dffdf5b1d664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c7b2070bea3afe6064dffdf5b1d664">&#9670;&nbsp;</a></span>size_type <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">SparsityPatternBase::size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00330">330</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gac1c554fe82e2f517f5e0759c3de987b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c554fe82e2f517f5e0759c3de987b4">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternBase.html#ac1c554fe82e2f517f5e0759c3de987b4">SparsityPatternBase::const_iterator</a> =  <a class="el" href="classSparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef an iterator class that allows to walk over all nonzero elements of a sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00336">336</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga32de0a562f86156d7ecebb09a85c832a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32de0a562f86156d7ecebb09a85c832a">&#9670;&nbsp;</a></span>iterator <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">SparsityPatternBase::iterator</a> =  <a class="el" href="classSparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef an iterator class that allows to walk over all nonzero elements of a sparsity pattern.</p>
<p>Since the iterator does not allow to modify the sparsity pattern, this type is the same as that for <code>const_iterator</code>. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html#l00345">345</a> of file <a class="el" href="origin_2lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2b13bf5274de30270934de0d644b320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b13bf5274de30270934de0d644b320b">&#9670;&nbsp;</a></span>BlockSparsityPatternBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::<a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the matrix empty, that is with no memory allocated. This is useful if you want such objects as member variables in other classes. You can make the structure usable by calling the <a class="el" href="classBlockSparsityPatternBase.html#af19ed94a019224dd27ff879caf7a4188">reinit()</a> function. </p>

</div>
</div>
<a id="gaa864194283fc0aca362f1a5ce86d0c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa864194283fc0aca362f1a5ce86d0c4d">&#9670;&nbsp;</a></span>BlockSparsityPatternBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::<a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the matrix with the given number of block rows and columns. The blocks themselves are still empty, and you have to call <a class="el" href="classBlockSparsityPatternBase.html#a8ceb6f5ecdf6b02da18dab401a01cfee">collect_sizes()</a> after you assign them sizes. </p>

</div>
</div>
<a id="gac2ca421a06a9655285a84fecd65a64e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2ca421a06a9655285a84fecd65a64e1">&#9670;&nbsp;</a></span>BlockSparsityPatternBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::<a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt; &amp;&#160;</td>
          <td class="paramname"><em>bsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is only allowed to be called if the sparsity pattern to be copied is empty, i.e. there are no block allocated at present. This is for the same reason as for the <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, see there for the details. </p>

</div>
</div>
<a id="ga1632ef532fb5aa23c30722c114ff3b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1632ef532fb5aa23c30722c114ff3b12">&#9670;&nbsp;</a></span>~BlockSparsityPatternBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::~<a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="ga8d1189ecd2022bb6671c9094dec725ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d1189ecd2022bb6671c9094dec725ed">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize the matrix, by setting the number of block rows and columns. This deletes all blocks and replaces them with uninitialized ones, i.e. ones for which also the sizes are not yet set. You have to do that by calling the <a class="el" href="classBlockSparsityPatternBase.html#af19ed94a019224dd27ff879caf7a4188">reinit()</a> functions of the blocks themselves. Do not forget to call <a class="el" href="classBlockSparsityPatternBase.html#a8ceb6f5ecdf6b02da18dab401a01cfee">collect_sizes()</a> after that on this object.</p>
<p>The reason that you have to set sizes of the blocks yourself is that the sizes may be varying, the maximum number of elements per row may be varying, etc. It is simpler not to reproduce the interface of the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class here but rather let the user call whatever function they desire. </p>

</div>
</div>
<a id="gac5e28ccf99906536785540b80659517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e28ccf99906536785540b80659517c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&amp; <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. For this the same holds as for the copy constructor: it is declared, defined and fine to be called, but the latter only for empty objects. </p>

</div>
</div>
<a id="ga01a91aa1f9a52b5c51a89204eb29bcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01a91aa1f9a52b5c51a89204eb29bcdc">&#9670;&nbsp;</a></span>collect_sizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function collects the sizes of the sub-objects and stores them in internal arrays, in order to be able to relay global indices into the matrix to indices into the subobjects. You <em>must</em> call this function each time after you have changed the size of the sub-objects. </p>

</div>
</div>
<a id="gaa68ecb039e13c35a501ee85e9fbbe403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa68ecb039e13c35a501ee85e9fbbe403">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternType&amp; <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. </p>

</div>
</div>
<a id="ga07fdbc69c1375c8cef87bc3bffc62c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07fdbc69c1375c8cef87bc3bffc62c2a">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const SparsityPatternType&amp; <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. Version for constant objects. </p>

</div>
</div>
<a id="ga023d59afdfd3d7f9431318b3d4e7d459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023d59afdfd3d7f9431318b3d4e7d459">&#9670;&nbsp;</a></span>get_row_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::get_row_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Grant access to the object describing the distribution of row indices to the individual blocks. </p>

</div>
</div>
<a id="ga655859e290e4f5be905e961c3d6c732f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga655859e290e4f5be905e961c3d6c732f">&#9670;&nbsp;</a></span>get_column_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::get_column_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Grant access to the object describing the distribution of column indices to the individual blocks. </p>

</div>
</div>
<a id="gab3bac2c0873208543e60684ce9cbd0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3bac2c0873208543e60684ce9cbd0b0">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function compresses the sparsity structures that this object represents. It simply calls <code>compress</code> for all sub-objects. </p>

</div>
</div>
<a id="ga124486ee59f893c19806a6a9d9c826af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga124486ee59f893c19806a6a9d9c826af">&#9670;&nbsp;</a></span>n_block_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::n_block_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a column. </p>

</div>
</div>
<a id="gaf36cec371f08b68e8b59bca61aefadc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf36cec371f08b68e8b59bca61aefadc6">&#9670;&nbsp;</a></span>n_block_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::n_block_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a row. </p>

</div>
</div>
<a id="ga9fce89a2849bfc67e60e715a11f9010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fce89a2849bfc67e60e715a11f9010d">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as that both dimensions are zero. This function is just the concatenation of the respective call to all sub- matrices. </p>

</div>
</div>
<a id="gaf073215d48531dd728f98de936ccd8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf073215d48531dd728f98de936ccd8f1">&#9670;&nbsp;</a></span>max_entries_per_row() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of entries per row. It returns the maximal number of entries per row accumulated over all blocks in a row, and the maximum over all rows. </p>

</div>
</div>
<a id="gac5840454fd8907c708ff54632c463df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5840454fd8907c708ff54632c463df5">&#9670;&nbsp;</a></span>add() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a nonzero entry to the matrix. This function may only be called for non-compressed sparsity patterns.</p>
<p>If the entry already exists, nothing bad happens.</p>
<p>This function simply finds out to which block <code>(i,j)</code> belongs and then relays to that block. </p>

</div>
</div>
<a id="ga53a29824eed344d90cca6266d373476a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53a29824eed344d90cca6266d373476a">&#9670;&nbsp;</a></span>add_entries() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add several nonzero entries to the specified matrix row. This function may only be called for non-compressed sparsity patterns.</p>
<p>If some of the entries already exist, nothing bad happens.</p>
<p>This function simply finds out to which blocks <code>(row,col)</code> for <code>col</code> in the iterator range belong and then relays to those blocks. </p>

</div>
</div>
<a id="gad45ebc113196659d1718adb3294e8e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad45ebc113196659d1718adb3294e8e8e">&#9670;&nbsp;</a></span>n_rows() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of rows of this matrix, which equals the dimension of the image space. It is the sum of rows of the (block-)rows of sub-matrices. </p>

</div>
</div>
<a id="ga58b35d986e4fbdbc9fbad75bab80be99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b35d986e4fbdbc9fbad75bab80be99">&#9670;&nbsp;</a></span>n_cols() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of columns of this matrix, which equals the dimension of the range space. It is the sum of columns of the (block-)columns of sub- matrices. </p>

</div>
</div>
<a id="gae4b4f55f68b82aedcd14c414f3f01c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b4f55f68b82aedcd14c414f3f01c4c">&#9670;&nbsp;</a></span>exists() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a value at a certain position may be non-zero. </p>

</div>
</div>
<a id="gabd9fc654b5be725eddf4df39759f6c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9fc654b5be725eddf4df39759f6c58">&#9670;&nbsp;</a></span>row_length() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row, added up over all the blocks that form this row. </p>

</div>
</div>
<a id="ga808c9315f0805ad671b11423c2c62ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808c9315f0805ad671b11423c2c62ad7">&#9670;&nbsp;</a></span>n_nonzero_elements() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway.</p>
<p>This function may only be called if the matrix struct is compressed. It does not make too much sense otherwise anyway.</p>
<p>In the present context, it is the sum of the values as returned by the sub-objects. </p>

</div>
</div>
<a id="ga606b03bd1779c9694298065c93f2c675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606b03bd1779c9694298065c93f2c675">&#9670;&nbsp;</a></span>print() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix. The output consists of one line per row of the format <code>[i,j1,j2,j3,...]</code>. <em>i</em> is the row number and <em>jn</em> are the allocated columns in this row. </p>

</div>
</div>
<a id="ga01cdbc59d0850dce65ddeb99b6ab5b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01cdbc59d0850dce65ddeb99b6ab5b7e">&#9670;&nbsp;</a></span>print_gnuplot() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. This is the same functionality implemented for usual sparsity patterns, see <a class="el" href="group__Exceptions.html#ga7f59a68863a1e770ba275894a7170e70">SparsityPatternBase::print_gnuplot()</a>. </p>

</div>
</div>
<a id="ga7e6314b53f6dcfd263f85ef44666beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e6314b53f6dcfd263f85ef44666beb1">&#9670;&nbsp;</a></span>print_svg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::print_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in <code>svg</code> format. This is the same functionality implemented for usual sparsity patterns, see <a class="el" href="group__Exceptions.html#ga226ebb78284e9c60ddda8e3ae6779d60">SparsityPatternBase::print_svg()</a>. </p>

</div>
</div>
<a id="ga3407a956c25fecbf04972d10cfc04fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3407a956c25fecbf04972d10cfc04fa2">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="ga81f71203ace1a31ef361626308140fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81f71203ace1a31ef361626308140fdc">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Construct the end accessor for the given sparsity pattern. </p>

</div>
</div>
<a id="ga21d97e0d4349771a8c290d4270e9dc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d97e0d4349771a8c290d4270e9dc3a">&#9670;&nbsp;</a></span>row() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a> ChunkSparsityPatternIterators::Accessor::row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row number of the element represented by this object. This function can only be called for entries for which <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a28cd10e6fdfdfe859260f47107617c81">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="ga451d13df4ce666f1d266e437a09d6c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451d13df4ce666f1d266e437a09d6c49">&#9670;&nbsp;</a></span>reduced_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ChunkSparsityPatternIterators::Accessor::reduced_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global index from the reduced sparsity pattern. </p>

</div>
</div>
<a id="gaade15915efb3e43d8a9c8ad4d03a9a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaade15915efb3e43d8a9c8ad4d03a9a96">&#9670;&nbsp;</a></span>column() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a> ChunkSparsityPatternIterators::Accessor::column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column number of the element represented by this object. This function can only be called for entries for which <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a28cd10e6fdfdfe859260f47107617c81">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="ga28cd10e6fdfdfe859260f47107617c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28cd10e6fdfdfe859260f47107617c81">&#9670;&nbsp;</a></span>is_valid_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Accessor::is_valid_entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the sparsity pattern entry pointed to by this iterator is valid or not. Note that after compressing the sparsity pattern, all entries are valid. However, before compression, the sparsity pattern allocated some memory to be used while still adding new nonzero entries; if you create iterators in this phase of the sparsity pattern's lifetime, you will iterate over elements that are not valid. If this is so, then this function will return false. </p>

</div>
</div>
<a id="ga99975f68918e179273c47b11c6d0e5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99975f68918e179273c47b11c6d0e5f7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Accessor::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison. True, if both iterators point to the same matrix position. </p>

</div>
</div>
<a id="ga4e14732ee20344711d5ebd21fc80dbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e14732ee20344711d5ebd21fc80dbfa">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Accessor::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller.</p>
<p>This function is only valid if both iterators point into the same sparsity pattern. </p>

</div>
</div>
<a id="ga6e967d6d0efc7e686eea475e2dff796a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e967d6d0efc7e686eea475e2dff796a">&#9670;&nbsp;</a></span>advance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPatternIterators::Accessor::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the accessor to the next nonzero entry in the matrix. </p>

</div>
</div>
<a id="ga653df8fcec158df8eaad041e727f78bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga653df8fcec158df8eaad041e727f78bc">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html#a6e5a691b2c5146bc4f8216239c5fe511">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create an iterator into the sparsity pattern <code>sp</code> for the given row and the index within it. </p>

</div>
</div>
<a id="ga47a410833a31fa4732eabca7554a8220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a410833a31fa4732eabca7554a8220">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a>&amp; ChunkSparsityPatternIterators::Iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefix increment. </p>

</div>
</div>
<a id="ga1cdd5092478ed3a7907ae742bfb477e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cdd5092478ed3a7907ae742bfb477e8">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> ChunkSparsityPatternIterators::Iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postfix increment. </p>

</div>
</div>
<a id="ga4f6239128933b7185e91aeee0ef838c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f6239128933b7185e91aeee0ef838c2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a>&amp; ChunkSparsityPatternIterators::Iterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereferencing operator. </p>

</div>
</div>
<a id="ga4a34317fe9e7616f7ab6fa5897710939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a34317fe9e7616f7ab6fa5897710939">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a>* ChunkSparsityPatternIterators::Iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereferencing operator. </p>

</div>
</div>
<a id="ga441026b5608d33dd665b9fa03eda643e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga441026b5608d33dd665b9fa03eda643e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison. True, if both iterators point to the same matrix position. </p>

</div>
</div>
<a id="ga18987092c4bba051567ced11527d05ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18987092c4bba051567ced11527d05ca">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse of <code>==</code>. </p>

</div>
</div>
<a id="ga8747567d51d9986056eb46db8d0ffcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8747567d51d9986056eb46db8d0ffcda">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPatternIterators::Iterator::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller.</p>
<p>This function is only valid if both iterators point into the same matrix. </p>

</div>
</div>
<a id="ga8aba5f931783751744b78c6c4491b6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aba5f931783751744b78c6c4491b6c4">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the matrix empty, that is with no memory allocated. This is useful if you want such objects as member variables in other classes. You can make the structure usable by calling the <a class="el" href="classChunkSparsityPattern.html#a6ace2dee00fd1fb57398d0a9e73af0fc">reinit()</a> function. </p>

</div>
</div>
<a id="ga4366453eb7970006d822cffbcabfc915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4366453eb7970006d822cffbcabfc915">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is only allowed to be called if the matrix structure to be copied is empty. This is so in order to prevent involuntary copies of objects for temporaries, which can use large amounts of computing time. However, copy constructors are needed if one wants to place a <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> in a container, e.g., to write such statements like <code>v.push_back (<a class="el" href="classChunkSparsityPattern.html#a8aba5f931783751744b78c6c4491b6c4">ChunkSparsityPattern()</a>);</code>, with <code>v</code> a vector of <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> objects.</p>
<p>Usually, it is sufficient to use the explicit keyword to disallow unwanted temporaries, but this does not work for <code>std::vector</code>. Since copying a structure like this is not useful anyway because multiple matrices can use the same sparsity structure, copies are only allowed for empty objects, as described above. </p>

</div>
</div>
<a id="ga3d1f2f7493e6ffc756f8df3354c11e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1f2f7493e6ffc756f8df3354c11e6b">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>max_chunks_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a rectangular matrix.</p>
<ul>
<li>m number of rows </li>
<li>n number of columns </li>
<li>max_per_row maximum number of nonzero entries per row </li>
</ul>

</div>
</div>
<a id="ga30c2110491f4e184604948d8dcdfed9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30c2110491f4e184604948d8dcdfed9f">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a rectangular matrix.</p>
<ul>
<li>m number of rows </li>
<li>n number of columns </li>
<li>row_lengths possible number of nonzero entries for each row. This vector must have one entry for each row. </li>
</ul>

</div>
</div>
<a id="ga8dc11bcc047bdd1670f49888726a2022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc11bcc047bdd1670f49888726a2022">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>max_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a quadratic matrix of dimension <code>n</code> with at most <code>max_per_row</code> nonzero entries per row.</p>
<p>This constructor automatically enables optimized storage of diagonal elements. To avoid this, use the constructor taking row and column numbers separately. </p>

</div>
</div>
<a id="gab52645c05d93ba4ee7292119b0970c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52645c05d93ba4ee7292119b0970c0e">&#9670;&nbsp;</a></span>ChunkSparsityPattern() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a quadratic matrix.</p>
<ul>
<li>m number of rows and columns </li>
<li>row_lengths possible number of nonzero entries for each row. This vector must have one entry for each row. </li>
</ul>

</div>
</div>
<a id="ga2c55eba8e52282441347427952d2af32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c55eba8e52282441347427952d2af32">&#9670;&nbsp;</a></span>~ChunkSparsityPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSparsityPattern::~ChunkSparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="ga82b42b2ce2078609ca0fe84626279077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82b42b2ce2078609ca0fe84626279077">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>&amp; ChunkSparsityPattern::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. For this the same holds as for the copy constructor: it is declared, defined and fine to be called, but the latter only for empty objects. </p>

</div>
</div>
<a id="ga6ace2dee00fd1fb57398d0a9e73af0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ace2dee00fd1fb57398d0a9e73af0fc">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>max_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate memory and set up data structures for a new matrix with <code>m </code>rows and <code>n</code> columns, with at most <code>max_per_row</code> nonzero entries per row.</p>
<p>This function simply maps its operations to the other <code>reinit</code> function. </p>

</div>
</div>
<a id="ga81b6f833f943400c70e1c94a9a966913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b6f833f943400c70e1c94a9a966913">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate memory for a matrix of size <code>m x n</code>. The number of entries for each row is taken from the array <code>row_lengths</code> which has to give this number of each row <code>i=1...m</code>.</p>
<p>If <code>m*n==0</code> all memory is freed, resulting in a total reinitialization of the object. If it is nonzero, new memory is only allocated if the new size extends the old one. This is done to save time and to avoid fragmentation of the heap.</p>
<p>If the number of rows equals the number of columns then diagonal elements are stored first in each row to allow optimized access in relaxation methods of <a class="el" href="classSparseMatrix.html">SparseMatrix</a>. </p>

</div>
</div>
<a id="gaf1c369603403f9249f07a35f7a7a8a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c369603403f9249f07a35f7a7a8a49">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with an <a class="el" href="classArrayView.html">ArrayView</a> argument instead. </p>

</div>
</div>
<a id="ga545474926fb71c36f09d317e1f4ff830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545474926fb71c36f09d317e1f4ff830">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function compresses the sparsity structure that this object represents. It does so by eliminating unused entries and sorting the remaining ones to allow faster access by usage of binary search algorithms. A special sorting scheme is used for the diagonal entry of quadratic matrices, which is always the first entry of each row.</p>
<p>The memory which is no more needed is released.</p>
<p><a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects require the <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> objects they are initialized with to be compressed, to reduce memory requirements. </p>

</div>
</div>
<a id="gae9c912a28714c3d40a12c1a1cf9fff63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c912a28714c3d40a12c1a1cf9fff63">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used as a replacement for <a class="el" href="classChunkSparsityPattern.html#a6ace2dee00fd1fb57398d0a9e73af0fc">reinit()</a>, subsequent calls to <a class="el" href="classChunkSparsityPattern.html#a07b49e5060932cbee4e438699da65581">add()</a> and a final call to close() if you know exactly in advance the entries that will form the matrix sparsity pattern.</p>
<p>The first two parameters determine the size of the matrix. For the two last ones, note that a sparse matrix can be described by a sequence of rows, each of which is represented by a sequence of pairs of column indices and values. In the present context, the <a class="el" href="classChunkSparsityPattern.html#acf768e801f5f0e7e311da883488c5cfe">begin()</a> and <a class="el" href="classChunkSparsityPattern.html#a581bcf26417ad8584cc0f1c0a32f14b6">end()</a> parameters designate iterators (of forward iterator type) into a container, one representing one row. The distance between <a class="el" href="classChunkSparsityPattern.html#acf768e801f5f0e7e311da883488c5cfe">begin()</a> and <a class="el" href="classChunkSparsityPattern.html#a581bcf26417ad8584cc0f1c0a32f14b6">end()</a> should therefore be equal to <a class="el" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows()</a>. These iterators may be iterators of <code>std::vector</code>, <code>std::list</code>, pointers into a C-style array, or any other iterator satisfying the requirements of a forward iterator. The objects pointed to by these iterators (i.e. what we get after applying <code>operator*</code> or <code>operator-&gt;</code> to one of these iterators) must be a container itself that provides functions <code>begin</code> and <code>end</code> designating a range of iterators that describe the contents of one line. Dereferencing these inner iterators must either yield a pair of an integer as column index and a value of arbitrary type (such a type would be used if we wanted to describe a sparse matrix with one such object), or simply an integer (if we only wanted to describe a sparsity pattern). The function is able to determine itself whether an integer or a pair is what we get after dereferencing the inner iterators, through some template magic.</p>
<p>While the order of the outer iterators denotes the different rows of the matrix, the order of the inner iterator denoting the columns does not matter, as they are sorted internal to this function anyway.</p>
<p>Since that all sounds very complicated, consider the following example code, which may be used to fill a sparsity pattern: </p><div class="fragment"><div class="line">std::vector&lt;std::vector&lt;size_type&gt; &gt; column_indices (<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> row=0; row&lt;<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>; ++row)</div>
<div class="line">        <span class="comment">// generate necessary columns in this row</span></div>
<div class="line">  fill_row (column_indices[row]);</div>
<div class="line"> </div>
<div class="line">sparsity.copy_from (<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>, <a class="code" href="classChunkSparsityPattern.html#ab29764d5ecb67c135d727658347d26c1">n_cols</a>,</div>
<div class="line">                    column_indices.begin(),</div>
<div class="line">                    column_indices.end());</div>
</div><!-- fragment --><p>Note that this example works since the iterators dereferenced yield containers with functions <code>begin</code> and <code>end</code> (namely <code>std::vector</code>s), and the inner iterators dereferenced yield integers as column indices. Note that we could have replaced each of the two <code>std::vector</code> occurrences by <code>std::list</code>, and the inner one by <code>std::set</code> as well.</p>
<p>Another example would be as follows, where we initialize a whole matrix, not only a sparsity pattern: </p><div class="fragment"><div class="line">std::vector&lt;std::map&lt;size_type,double&gt; &gt; entries (<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> row=0; row&lt;<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>; ++row)</div>
<div class="line">        <span class="comment">// generate necessary pairs of columns</span></div>
<div class="line">        <span class="comment">// and corresponding values in this row</span></div>
<div class="line">  fill_row (entries[row]);</div>
<div class="line"> </div>
<div class="line">sparsity.copy_from (<a class="code" href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">n_rows</a>, <a class="code" href="classChunkSparsityPattern.html#ab29764d5ecb67c135d727658347d26c1">n_cols</a>,</div>
<div class="line">                    column_indices.begin(),</div>
<div class="line">                    column_indices.end());</div>
<div class="line"><a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638afb9cf45d5916e2dce29dbefbeb3c6a1a">matrix</a>.reinit (sparsity);</div>
<div class="line"><a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638afb9cf45d5916e2dce29dbefbeb3c6a1a">matrix</a>.copy_from (column_indices.begin(),</div>
<div class="line">                  column_indices.end());</div>
</div><!-- fragment --><p>This example works because dereferencing iterators of the inner type yields a pair of integers and a value, the first of which we take as column index. As previously, the outer <code>std::vector</code> could be replaced by <code>std::list</code>, and the inner <code>std::map&lt;size_type,double&gt;</code> could be replaced by <code>std::vector&lt;std::pair&lt;size_type,double&gt; &gt;</code>, or a list or set of such pairs, as they all return iterators that point to such pairs. </p>

</div>
</div>
<a id="ga2f3bc592eb05b5a0d05e519b1aa1b329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f3bc592eb05b5a0d05e519b1aa1b329">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from an object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. Previous content of this object is lost, and the sparsity pattern is in compressed mode afterwards. </p>

</div>
</div>
<a id="gaafcca15e528bef78783c5aba2c2ce285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcca15e528bef78783c5aba2c2ce285">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a full matrix and use its nonzero entries to generate a sparse matrix entry pattern for this object.</p>
<p>Previous content of this object is lost, and the sparsity pattern is in compressed mode afterwards. </p>

</div>
</div>
<a id="ga06eff2d40b9840b74b46c87606e0ce5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06eff2d40b9840b74b46c87606e0ce5e">&#9670;&nbsp;</a></span>create_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sparsity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::create_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sparsity &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern_for_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>optimize_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the sparsity pattern of the chunk sparsity pattern to be given by <code>chunk_size*chunksize</code> blocks of the sparsity pattern for chunks specified. Note that the final number of rows <code>m</code> of the sparsity pattern will be approximately <code>sparsity_pattern_for_chunks.n_rows() * chunk_size</code> (modulo padding elements in the last chunk) and similarly for the number of columns <code>n</code>.</p>
<p>This is a special initialization option in case you can tell the position of the chunk already from the beginning without generating the sparsity pattern using <code>make_sparsity_pattern</code> calls. This bypasses the search for chunks but of course needs to be handled with care in order to give a correct sparsity pattern.</p>
<p>Previous content of this object is lost, and the sparsity pattern is in compressed mode afterwards. </p>

</div>
</div>
<a id="gaddf119433c708bfce06ca2f106ac25e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf119433c708bfce06ca2f106ac25e1">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPattern::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as that both dimensions are zero. </p>

</div>
</div>
<a id="gae30aa3167d5f7b9f8cdc3954aa0aaefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30aa3167d5f7b9f8cdc3954aa0aaefb">&#9670;&nbsp;</a></span>get_chunk_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::get_chunk_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the chunk size given as argument when constructing this object. </p>

</div>
</div>
<a id="ga265ec1a8cc78a1ac3d512528e93eadfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265ec1a8cc78a1ac3d512528e93eadfe">&#9670;&nbsp;</a></span>max_entries_per_row() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of entries per row. Before compression, this equals the number given to the constructor, while after compression, it equals the maximum number of entries actually allocated by the user. </p>

</div>
</div>
<a id="ga07b49e5060932cbee4e438699da65581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b49e5060932cbee4e438699da65581">&#9670;&nbsp;</a></span>add() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a nonzero entry to the matrix. This function may only be called for non-compressed sparsity patterns.</p>
<p>If the entry already exists, nothing bad happens. </p>

</div>
</div>
<a id="ga1c30e3ae9bd087342b58b777ccd77bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c30e3ae9bd087342b58b777ccd77bb7">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the sparsity pattern symmetric by adding the sparsity pattern of the transpose object.</p>
<p>This function throws an exception if the sparsity pattern does not represent a quadratic matrix. </p>

</div>
</div>
<a id="gaf60af18b0bd7b73f1f5e752b0d30802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60af18b0bd7b73f1f5e752b0d30802a">&#9670;&nbsp;</a></span>n_rows() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of rows of this matrix, which equals the dimension of the image space. </p>

</div>
</div>
<a id="gab29764d5ecb67c135d727658347d26c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab29764d5ecb67c135d727658347d26c1">&#9670;&nbsp;</a></span>n_cols() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of columns of this matrix, which equals the dimension of the range space. </p>

</div>
</div>
<a id="ga53c884dbfd69d3f4e406404beabb83c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c884dbfd69d3f4e406404beabb83c5">&#9670;&nbsp;</a></span>exists() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPattern::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a value at a certain position may be non-zero. </p>

</div>
</div>
<a id="ga84756c959244c4309bf94d83e45854b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84756c959244c4309bf94d83e45854b9">&#9670;&nbsp;</a></span>row_length() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

</div>
</div>
<a id="gaef521b07f1e6e04cfc8185ad3bcd4be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef521b07f1e6e04cfc8185ad3bcd4be4">&#9670;&nbsp;</a></span>bandwidth() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of \(|i-j|\) for which the index pair \((i,j)\) represents a nonzero entry of the matrix. Consequently, the maximum bandwidth a \(n\times m\) matrix can have is \(\max\{n-1,m-1\}\). </p>

</div>
</div>
<a id="ga71c061d1117a85dff6f19b93886052d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71c061d1117a85dff6f19b93886052d6">&#9670;&nbsp;</a></span>n_nonzero_elements() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway.</p>
<p>This function may only be called if the matrix struct is compressed. It does not make too much sense otherwise anyway. </p>

</div>
</div>
<a id="ga9996952cc5704f6cdb8a62a7d4674d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9996952cc5704f6cdb8a62a7d4674d7a">&#9670;&nbsp;</a></span>is_compressed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPattern::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the structure is compressed or not. </p>

</div>
</div>
<a id="ga1589f40972b0d32ed2b0b02280f64a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1589f40972b0d32ed2b0b02280f64a84">&#9670;&nbsp;</a></span>stores_only_added_elements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ChunkSparsityPattern::stores_only_added_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this object stores only those entries that have been added explicitly, or if the sparsity pattern contains elements that have been added through other means (implicitly) while building it. For the current class, the result is true if and only if it is square because it then unconditionally stores the diagonal entries whether they have been added explicitly or not.</p>
<p>This function mainly serves the purpose of describing the current class in cases where several kinds of sparsity patterns can be passed as template arguments. </p>

</div>
</div>
<a id="gacf768e801f5f0e7e311da883488c5cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf768e801f5f0e7e311da883488c5cfe">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a> ChunkSparsityPattern::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of the matrix. The resulting iterator can be used to walk over all nonzero entries of the sparsity pattern. </p>

</div>
</div>
<a id="ga581bcf26417ad8584cc0f1c0a32f14b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga581bcf26417ad8584cc0f1c0a32f14b6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a> ChunkSparsityPattern::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="gaf7ae99d025ff8745246f02cc22a07e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7ae99d025ff8745246f02cc22a07e45">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a> ChunkSparsityPattern::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferenceable in that case. </p>

</div>
</div>
<a id="ga671eee281d96be62cd67667213ac3f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671eee281d96be62cd67667213ac3f93">&#9670;&nbsp;</a></span>end() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPattern.html#a10e66cf5c0ef12063c3f5d5b0404bc4e">iterator</a> ChunkSparsityPattern::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="ga0c28e60ee4f52000a532cafa9c1cf4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c28e60ee4f52000a532cafa9c1cf4b4">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system of number format.</p>
<p>The purpose of this function is that you can swap out matrices and sparsity pattern if you are short of memory, want to communicate between different programs, or allow objects to be persistent across different runs of the program. </p>

</div>
</div>
<a id="ga7656c89a8fb3081628cfe067e18e9cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7656c89a8fb3081628cfe067e18e9cf7">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data that has previously been written by <a class="el" href="classChunkSparsityPattern.html#a0c28e60ee4f52000a532cafa9c1cf4b4">block_write()</a> from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted except for a few numbers up front.</p>
<p>The object is resized on this operation, and all previous contents are lost.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="gad4fc2c515b962a61ac853569268f3f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fc2c515b962a61ac853569268f3f34">&#9670;&nbsp;</a></span>print() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix. The output consists of one line per row of the format <code>[i,j1,j2,j3,...]</code>. <em>i</em> is the row number and <em>jn</em> are the allocated columns in this row. </p>

</div>
</div>
<a id="ga6cc7c0e88fea614a08c84ac793159cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc7c0e88fea614a08c84ac793159cb7">&#9670;&nbsp;</a></span>print_gnuplot() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSparsityPattern::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. The format consists of pairs <code>i j</code> of nonzero elements, each representing one entry of this matrix, one per line of the output file. Indices are counted from zero on, as usual. Since sparsity patterns are printed in the same way as matrices are displayed, we print the negative of the column index, which means that the <code>(0,0)</code> element is in the top left rather than in the bottom left corner.</p>
<p>Print the sparsity pattern in gnuplot by setting the data style to dots or points and use the <code>plot</code> command. </p>

</div>
</div>
<a id="ga3ec280990051f39f9a2e72fc9904f298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec280990051f39f9a2e72fc9904f298">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ChunkSparsityPattern::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. See <a class="el" href="namespaceMemoryConsumption.html">MemoryConsumption</a>. </p>

</div>
</div>
<a id="ga189c8ede77d4ec29676b3639ba522682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga189c8ede77d4ec29676b3639ba522682">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index_within_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="ga473e1cb731c7116964874b024cfeb901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga473e1cb731c7116964874b024cfeb901">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Construct the end accessor for the given sparsity pattern. </p>

</div>
</div>
<a id="ga4b1c2f70e7ef3cb88c827df12b03ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b1c2f70e7ef3cb88c827df12b03ac44">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor creating a dummy accessor. This constructor is here only to be able to store accessors in STL containers such as <code>std::vector</code>. </p>

</div>
</div>
<a id="ga56f4bfb7510a9b2f8f03eb8397c4f3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56f4bfb7510a9b2f8f03eb8397c4f3c5">&#9670;&nbsp;</a></span>row() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> DynamicSparsityPatternIterators::Accessor::row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row number of the element represented by this object. </p>

</div>
</div>
<a id="ga4fbbd85a753f8e0b194f80f31086d1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fbbd85a753f8e0b194f80f31086d1f4">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> DynamicSparsityPatternIterators::Accessor::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index within the current row of the element represented by this object. </p>

</div>
</div>
<a id="ga486d654e7b0d96637dff1827a0e2f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga486d654e7b0d96637dff1827a0e2f35c">&#9670;&nbsp;</a></span>column() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> DynamicSparsityPatternIterators::Accessor::column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column number of the element represented by this object. </p>

</div>
</div>
<a id="gacff81ba53abae5238413608b966ad779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff81ba53abae5238413608b966ad779">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPatternIterators::Accessor::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison. True, if both iterators point to the same matrix position. </p>

</div>
</div>
<a id="gad98f276b887f267a1c7a6473b8458ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98f276b887f267a1c7a6473b8458ca3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPatternIterators::Accessor::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller.</p>
<p>This function is only valid if both iterators point into the same sparsity pattern. </p>

</div>
</div>
<a id="ga3eb2bc2c08288d1d6547eff29f2c659b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb2bc2c08288d1d6547eff29f2c659b">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Accessor::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">DummyAccessor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The instance of this class was initialized&quot; &quot; without <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">which&quot; &quot; means that it is a dummy accessor that can&quot; &quot; not do any operations.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga123bb3c168fb1d5cdbf3fb95de4f48e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123bb3c168fb1d5cdbf3fb95de4f48e4">&#9670;&nbsp;</a></span>advance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPatternIterators::Accessor::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the accessor to the next nonzero entry in the matrix. </p>

</div>
</div>
<a id="ga3158717e4bf78ee0fbd06e20629d00aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3158717e4bf78ee0fbd06e20629d00aa">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index_within_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create an iterator into the sparsity pattern <code>sp</code> for the given global index (i.e., the index of the given element counting from the zeroth row). </p>

</div>
</div>
<a id="gac2f09dc9ac73c9b3ac9442f448b82e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2f09dc9ac73c9b3ac9442f448b82e7f">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create an invalid (end) iterator into the sparsity pattern <code>sp</code>. </p>

</div>
</div>
<a id="gacd5b3f18a9e780fb5e5ac3b8d0fa37e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5b3f18a9e780fb5e5ac3b8d0fa37e3">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor creating an invalid iterator. This constructor is here only to be able to store iterators in STL containers such as <code>std::vector</code>. </p>

</div>
</div>
<a id="ga2ce23d97ee9eaa9adbf1ed4b174b0558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce23d97ee9eaa9adbf1ed4b174b0558">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a>&amp; DynamicSparsityPatternIterators::Iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefix increment. </p>

</div>
</div>
<a id="gadf200063a10ce2a0ff765e469b6aa058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf200063a10ce2a0ff765e469b6aa058">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> DynamicSparsityPatternIterators::Iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postfix increment. </p>

</div>
</div>
<a id="ga0b06be42a5d1d707e08cf51e22020dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b06be42a5d1d707e08cf51e22020dd1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a>&amp; DynamicSparsityPatternIterators::Iterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereferencing operator. </p>

</div>
</div>
<a id="gae6bd6a9a0670870fe2ae6678e5845f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6bd6a9a0670870fe2ae6678e5845f9b">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a>* DynamicSparsityPatternIterators::Iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereferencing operator. </p>

</div>
</div>
<a id="ga651684066daa03b5f41ea05bcf360c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651684066daa03b5f41ea05bcf360c8e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPatternIterators::Iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison. True, if both iterators point to the same matrix position. </p>

</div>
</div>
<a id="ga69c7056a4913626d3df4ab02e0576b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c7056a4913626d3df4ab02e0576b40">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPatternIterators::Iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse of <code>==</code>. </p>

</div>
</div>
<a id="gad289f97cba5e2d0ae6bedf129273bc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad289f97cba5e2d0ae6bedf129273bc5e">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPatternIterators::Iterator::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller.</p>
<p>This function is only valid if both iterators point into the same matrix. </p>

</div>
</div>
<a id="gadac2806ce6f426d7c2675f10212cb0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadac2806ce6f426d7c2675f10212cb0c8">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> DynamicSparsityPatternIterators::Iterator::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the distance between the current iterator and the argument. The distance is given by how many times one has to apply operator++ to the current iterator to get the argument (for a positive return value), or operator-- (for a negative return value). </p>

</div>
</div>
<a id="ga8fd181aef17e12fd56c8ca94ace05c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd181aef17e12fd56c8ca94ace05c9e">&#9670;&nbsp;</a></span>DynamicSparsityPattern() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPattern::DynamicSparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize as an empty object. This is useful if you want such objects as member variables in other classes. You can make the structure usable by calling the <a class="el" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit()</a> function. </p>

</div>
</div>
<a id="ga3622db24bcdf4c186eb5e0947ca89b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3622db24bcdf4c186eb5e0947ca89b6f">&#9670;&nbsp;</a></span>DynamicSparsityPattern() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPattern::DynamicSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is only allowed to be called if the sparsity structure to be copied is empty. This is so in order to prevent involuntary copies of objects for temporaries, which can use large amounts of computing time. However, copy constructors are needed if you want to place a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> in a container, e.g. to write such statements like <code>v.push_back (<a class="el" href="classDynamicSparsityPattern.html#a8fd181aef17e12fd56c8ca94ace05c9e">DynamicSparsityPattern()</a>);</code>, with <code>v</code> a vector of <code><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></code> objects. </p>

</div>
</div>
<a id="ga976942bef275029caa4e62060690b7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga976942bef275029caa4e62060690b7b4">&#9670;&nbsp;</a></span>DynamicSparsityPattern() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPattern::DynamicSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>rowset</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a rectangular sparsity pattern with <code>m</code> rows and <code>n</code> columns. The <code>rowset</code> restricts the storage to elements in rows of this set. Adding elements outside of this set has no effect. The default argument keeps all entries. </p>

</div>
</div>
<a id="gaa6a268919f3f0ae9ddcc590b27eacb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a268919f3f0ae9ddcc590b27eacb0a">&#9670;&nbsp;</a></span>DynamicSparsityPattern() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPattern::DynamicSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>indexset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a square <a class="el" href="classSparsityPattern.html">SparsityPattern</a> using the given index set. The total size is given by the size of <code>indexset</code> and only rows corresponding to indices in <code>indexset</code> are stored on the current processor. </p>

</div>
</div>
<a id="ga939cc20e664903852dc34cfaa449ae14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939cc20e664903852dc34cfaa449ae14">&#9670;&nbsp;</a></span>DynamicSparsityPattern() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicSparsityPattern::DynamicSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a square pattern of dimension <code>n</code>. </p>

</div>
</div>
<a id="ga57d9c95f86a949c8cbf6f46188fa803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d9c95f86a949c8cbf6f46188fa803a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>&amp; DynamicSparsityPattern::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. For this the same holds as for the copy constructor: it is declared, defined and fine to be called, but the latter only for empty objects. </p>

</div>
</div>
<a id="gaa32f9f3ebad084d001349cd3ddb4074e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32f9f3ebad084d001349cd3ddb4074e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>rowset</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate memory and set up data structures for a new sparsity pattern with <code>m</code> rows and <code>n</code> columns. The <code>rowset</code> restricts the storage to elements in rows of this set. Adding elements outside of this set has no effect. The default argument keeps all entries. </p>

</div>
</div>
<a id="ga4ceb670be125dd2b8447e553374aa252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ceb670be125dd2b8447e553374aa252">&#9670;&nbsp;</a></span>compress() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this object is kept compressed at all times anyway, this function does nothing, but is declared to make the interface of this class as much alike as that of the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. </p>

</div>
</div>
<a id="ga0f777cdee3d8ed4b602d8102fe54911b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f777cdee3d8ed4b602d8102fe54911b">&#9670;&nbsp;</a></span>empty() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPattern::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as that both dimensions are zero. </p>

</div>
</div>
<a id="gaadfa1d39829c829f354af3b88cc9dd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfa1d39829c829f354af3b88cc9dd38">&#9670;&nbsp;</a></span>max_entries_per_row() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of entries per row. Note that this number may change as entries are added. </p>

</div>
</div>
<a id="gae8b1dc183fb130d188ee13a5c8ba9324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b1dc183fb130d188ee13a5c8ba9324">&#9670;&nbsp;</a></span>add() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a nonzero entry. If the entry already exists, this call does nothing. </p>

</div>
</div>
<a id="ga0f7b36840fa8fac8773c81e2d09bdafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7b36840fa8fac8773c81e2d09bdafa">&#9670;&nbsp;</a></span>add_entries() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>indices_are_unique_and_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add several nonzero entries to the specified row. Already existing entries are ignored. </p>

</div>
</div>
<a id="gad6f38772a4e0af734e01d4ad76bc17fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f38772a4e0af734e01d4ad76bc17fe">&#9670;&nbsp;</a></span>exists() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPattern::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a value at a certain position may be non-zero. </p>

</div>
</div>
<a id="ga23264e12d22d17767a7ef6b2bc47b9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23264e12d22d17767a7ef6b2bc47b9a5">&#9670;&nbsp;</a></span>get_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> DynamicSparsityPattern::get_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a view of this sparsity pattern. That is, for all rows in <code>rows</code> extract non-empty columns. The resulting sparsity pattern will have number of rows equal <code>rows.n_elements()</code>. </p>

</div>
</div>
<a id="gafb405a76dd681c216e8a371f12182e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb405a76dd681c216e8a371f12182e6e">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the sparsity pattern symmetric by adding the sparsity pattern of the transpose object.</p>
<p>This function throws an exception if the sparsity pattern does not represent a square matrix. </p>

</div>
</div>
<a id="ga53eb9934e07a5de146cca99c2e65aee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53eb9934e07a5de146cca99c2e65aee5">&#9670;&nbsp;</a></span>compute_mmult_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternTypeLeft , typename SparsityPatternTypeRight &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::compute_mmult_pattern </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternTypeLeft &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternTypeRight &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct and store in this object the sparsity pattern corresponding to the product of <code>left</code> and <code>right</code> sparsity pattern. </p>

</div>
</div>
<a id="gae44214be81221ccbe43bcf8e4548446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44214be81221ccbe43bcf8e4548446e">&#9670;&nbsp;</a></span>compute_Tmmult_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternTypeLeft , typename SparsityPatternTypeRight &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::compute_Tmmult_pattern </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternTypeLeft &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternTypeRight &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct and store in this object the sparsity pattern corresponding to the product of transposed <code>left</code> and non-transpose <code>right</code> sparsity pattern. </p>

</div>
</div>
<a id="gaa02bf60f01c54494e09faef83cdce9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa02bf60f01c54494e09faef83cdce9a7">&#9670;&nbsp;</a></span>print() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity pattern. The output consists of one line per row of the format <code>[i,j1,j2,j3,...]</code>. <em>i</em> is the row number and <em>jn</em> are the allocated columns in this row. </p>

</div>
</div>
<a id="gab90227179d3edcab862e8f104abbf243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab90227179d3edcab862e8f104abbf243">&#9670;&nbsp;</a></span>print_gnuplot() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity pattern in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. The format consists of pairs <code>i j</code> of nonzero elements, each representing one entry, one per line of the output file. Indices are counted from zero on, as usual. Since sparsity patterns are printed in the same way as matrices are displayed, we print the negative of the column index, which means that the <code>(0,0)</code> element is in the top left rather than in the bottom left corner.</p>
<p>Print the sparsity pattern in gnuplot by setting the data style to dots or points and use the <code>plot</code> command. </p>

</div>
</div>
<a id="ga9941c7c73bfcec315af714e69f496159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9941c7c73bfcec315af714e69f496159">&#9670;&nbsp;</a></span>n_rows() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows, which equals the dimension of the image space. </p>

</div>
</div>
<a id="ga2d2b7c3a0e4fadc81c5805e604c50a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2b7c3a0e4fadc81c5805e604c50a09">&#9670;&nbsp;</a></span>n_cols() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns, which equals the dimension of the range space. </p>

</div>
</div>
<a id="ga7e4f0b03970f1d820c1f8141c9f03168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e4f0b03970f1d820c1f8141c9f03168">&#9670;&nbsp;</a></span>row_length() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. This function can only be called if the given row is a member of the index set of rows that we want to store. </p>

</div>
</div>
<a id="gaab834dc1c62542c96b86dac74e75ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab834dc1c62542c96b86dac74e75ef72">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all entries stored in a specific row. </p>

</div>
</div>
<a id="ga87f2226da6bfc7e7eea16cd3f3a0dd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87f2226da6bfc7e7eea16cd3f3a0dd40">&#9670;&nbsp;</a></span>column_number() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::column_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to column number field. Return the column number of the <code>indexth</code> entry in <code>row</code>. </p>

</div>
</div>
<a id="ga86730419f3877f72842fa7c92346244d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86730419f3877f72842fa7c92346244d">&#9670;&nbsp;</a></span>column_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::column_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return index of column <code>col</code> in row <code>row</code>. If the column does not exist in this sparsity pattern, the returned value will be '<a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a>'. </p>

</div>
</div>
<a id="gaa7a69176e6bbca3e64805b0cd500db86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a69176e6bbca3e64805b0cd500db86">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a> DynamicSparsityPattern::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of the matrix. The resulting iterator can be used to walk over all nonzero entries of the sparsity pattern.</p>
<p>Note the discussion in the general documentation of this class about the order in which elements are accessed.</p>
<dl class="section note"><dt>Note</dt><dd>If the sparsity pattern has been initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> that denotes which rows to store, then iterators will simply skip over rows that are not stored. In other words, they will look like empty rows, but no exception will be generated when iterating over such rows. </dd></dl>

</div>
</div>
<a id="ga54d7671ac9700b39572c3f2b318c9b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54d7671ac9700b39572c3f2b318c9b9d">&#9670;&nbsp;</a></span>end() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a> DynamicSparsityPattern::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="ga16befb1de3d170854dd467fc4e698bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16befb1de3d170854dd467fc4e698bd2">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a> DynamicSparsityPattern::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferenceable in that case.</p>
<p>Note also the discussion in the general documentation of this class about the order in which elements are accessed.</p>
<dl class="section note"><dt>Note</dt><dd>If the sparsity pattern has been initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> that denotes which rows to store, then iterators will simply skip over rows that are not stored. In other words, they will look like empty rows, but no exception will be generated when iterating over such rows. </dd></dl>

</div>
</div>
<a id="ga3f3b08da02adb46dfde2d7ec4d9f9468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3b08da02adb46dfde2d7ec4d9f9468">&#9670;&nbsp;</a></span>end() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a18ab16f163487d426b3ecb653a0ad927">iterator</a> DynamicSparsityPattern::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="gaeb39f4db9cca46254d724dc74df08ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb39f4db9cca46254d724dc74df08ec7">&#9670;&nbsp;</a></span>bandwidth() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of \(|i-j|\) for which the index pair \((i,j)\) represents a nonzero entry of the matrix. </p>

</div>
</div>
<a id="ga62dcab5a89ebb242a4e3390e389cfc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62dcab5a89ebb242a4e3390e389cfc8c">&#9670;&nbsp;</a></span>n_nonzero_elements() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements allocated through this sparsity pattern. </p>

</div>
</div>
<a id="gae6c0fbf383a8d4b72cd6387a281dd5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c0fbf383a8d4b72cd6387a281dd5b5">&#9670;&nbsp;</a></span>row_index_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; DynamicSparsityPattern::row_index_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classIndexSet.html">IndexSet</a> that sets which rows are active on the current processor. It corresponds to the <a class="el" href="classIndexSet.html">IndexSet</a> given to this class in the constructor or in the reinit function. </p>

</div>
</div>
<a id="ga1066e0de41ad0c51826d5f7ac498a67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1066e0de41ad0c51826d5f7ac498a67c">&#9670;&nbsp;</a></span>nonempty_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DynamicSparsityPattern::nonempty_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classIndexSet.html">IndexSet</a> that contains entries for all columns in which at least one element exists in this sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>In a parallel context, this only considers the locally stored rows. </dd></dl>

</div>
</div>
<a id="gaea20a2ef7e88478514c264dbee9ba192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea20a2ef7e88478514c264dbee9ba192">&#9670;&nbsp;</a></span>nonempty_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DynamicSparsityPattern::nonempty_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classIndexSet.html">IndexSet</a> that contains entries for all rows in which at least one element exists in this sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>In a parallel context, this only considers the locally stored rows. </dd></dl>

</div>
</div>
<a id="ga87e5e23766ade844803fc897e81af39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e5e23766ade844803fc897e81af39d">&#9670;&nbsp;</a></span>stores_only_added_elements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> DynamicSparsityPattern::stores_only_added_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return whether this object stores only those entries that have been added explicitly, or if the sparsity pattern contains elements that have been added through other means (implicitly) while building it. For the current class, the result is always true.</p>
<p>This function mainly serves the purpose of describing the current class in cases where several kinds of sparsity patterns can be passed as template arguments. </p>

</div>
</div>
<a id="gaf4038aec0cfdcc324296c249aca9987f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4038aec0cfdcc324296c249aca9987f">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="gaa0fd9b6fb152a12a57b37e5ca281b2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0fd9b6fb152a12a57b37e5ca281b2f7">&#9670;&nbsp;</a></span>add() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::Line::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a>&#160;</td>
          <td class="paramname"><em>col_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given column number to this line. </p>

</div>
</div>
<a id="ga8838b3082af8e3a8e22e447a88641f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8838b3082af8e3a8e22e447a88641f5a">&#9670;&nbsp;</a></span>add_entries() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynamicSparsityPattern::Line::add_entries </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>indices_are_sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the columns specified by the iterator range to this line. </p>

</div>
</div>
<a id="ga4da4a1fea8a2ce185ca7a263d9621571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da4a1fea8a2ce185ca7a263d9621571">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::Line::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>estimates memory consumption. </p>

</div>
</div>
<a id="ga5f01a62b8aec73da7afb24236e706ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f01a62b8aec73da7afb24236e706ab7">&#9670;&nbsp;</a></span>get_column_index_from_iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a> internals::SparsityPatternTools::get_column_index_from_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to get the column index from a dereferenced iterator in the copy_from() function, if the inner iterator type points to plain unsigned integers. </p>

</div>
</div>
<a id="ga781bf1039826e234a8a659c63b75be64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga781bf1039826e234a8a659c63b75be64">&#9670;&nbsp;</a></span>get_column_index_from_iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a> internals::SparsityPatternTools::get_column_index_from_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>, value &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to get the column index from a dereferenced iterator in the copy_from() function, if the inner iterator type points to pairs of unsigned integers and some other value. </p>

</div>
</div>
<a id="gac123fc873fff5629d265fd7731867d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac123fc873fff5629d265fd7731867d43">&#9670;&nbsp;</a></span>get_column_index_from_iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a> internals::SparsityPatternTools::get_column_index_from_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const <a class="el" href="group__Sparsity.html#ga12e241eb348f5c446ddf05a08826eb31">size_type</a>, value &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Likewise, but sometimes needed for certain types of containers that make the first element of the pair constant (such as <code>std::map</code>). </p>

</div>
</div>
<a id="gae2ae1c2d42607e4a4531ff8da66b9869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ae1c2d42607e4a4531ff8da66b9869">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>linear_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="gadea2dc74a02b3dd3375ff1904ce254f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea2dc74a02b3dd3375ff1904ce254f3">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Construct the end accessor for the given sparsity pattern. </p>

</div>
</div>
<a id="gaf41c5085f9d57d795a61ffb7e36fb784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf41c5085f9d57d795a61ffb7e36fb784">&#9670;&nbsp;</a></span>Accessor() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Accessor::Accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor creating a dummy accessor. This constructor is here only to be able to store accessors in STL containers such as <code>std::vector</code>. </p>

</div>
</div>
<a id="ga67096e8bc60d364e9450260dab9d4397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67096e8bc60d364e9450260dab9d4397">&#9670;&nbsp;</a></span>row() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a> SparsityPatternIterators::Accessor::row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row number of the element represented by this object. This function can only be called for entries for which <a class="el" href="classSparsityPatternIterators_1_1Accessor.html#af05107e125b6d82daf62e612fa289e73">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="ga838f049ae1f234066b9b3366f3c4f5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga838f049ae1f234066b9b3366f3c4f5bb">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a> SparsityPatternIterators::Accessor::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index within the current row of the element represented by this object. This function can only be called for entries for which <a class="el" href="classSparsityPatternIterators_1_1Accessor.html#af05107e125b6d82daf62e612fa289e73">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="ga6358815e9f89a7706975c9fdc3890aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6358815e9f89a7706975c9fdc3890aa4">&#9670;&nbsp;</a></span>global_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a> SparsityPatternIterators::Accessor::global_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the how-many'th entry within the entire sparsity pattern the current iterator points to. While the order of entries in a sparsity pattern is generally not important, this function allows indexing entries of the sparsity pattern using a linear index.</p>
<p>This function can only be called for entries for which <a class="el" href="classSparsityPatternIterators_1_1Accessor.html#af05107e125b6d82daf62e612fa289e73">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="gaf486a00971aad248b16d5e847e1848b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf486a00971aad248b16d5e847e1848b5">&#9670;&nbsp;</a></span>column() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html#a7806ed33918ff4d52d022b9a1872a457">size_type</a> SparsityPatternIterators::Accessor::column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column number of the element represented by this object. This function can only be called for entries for which <a class="el" href="classSparsityPatternIterators_1_1Accessor.html#af05107e125b6d82daf62e612fa289e73">is_valid_entry()</a> is true. </p>

</div>
</div>
<a id="gaf05107e125b6d82daf62e612fa289e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05107e125b6d82daf62e612fa289e73">&#9670;&nbsp;</a></span>is_valid_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternIterators::Accessor::is_valid_entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the sparsity pattern entry pointed to by this iterator is valid or not. Note that after compressing the sparsity pattern, all entries are valid. However, before compression, the sparsity pattern allocated some memory to be used while still adding new nonzero entries; if you create iterators in this phase of the sparsity pattern's lifetime, you will iterate over elements that are not valid. If this is so, then this function will return false. </p>

</div>
</div>
<a id="ga63e3645cf34ff78939ff8ffd6731fcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e3645cf34ff78939ff8ffd6731fcdb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternIterators::Accessor::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison. True, if both iterators point to the same matrix position. </p>

</div>
</div>
<a id="gad9185b4c659826331a16fafeff343bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9185b4c659826331a16fafeff343bc7">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternIterators::Accessor::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Result is true if either the first row number is smaller or if the row numbers are equal and the first index is smaller.</p>
<p>This function is only valid if both iterators point into the same sparsity pattern. </p>

</div>
</div>
<a id="ga9dceec81473ac3a17beaaf59d29e12ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dceec81473ac3a17beaaf59d29e12ff">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Accessor::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">DummyAccessor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The instance of this class was initialized&quot; &quot; without <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">which&quot; &quot; means that it is a dummy accessor that can&quot; &quot; not do any operations.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafe0d7a91819f5077c4b25abb0ef74a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0d7a91819f5077c4b25abb0ef74a76">&#9670;&nbsp;</a></span>advance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternIterators::Accessor::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the accessor to the next nonzero entry in the matrix. </p>

</div>
</div>
<a id="ga212447d9b662791324a410240f920f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212447d9b662791324a410240f920f29">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>linear_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create an iterator into the sparsity pattern <code>sp</code> for the given global index (i.e., the index of the given element counting from the zeroth row). </p>

</div>
</div>
<a id="gacd8f413087919c54a805c022128c19c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8f413087919c54a805c022128c19c7">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternIterators::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create an iterator into the sparsity pattern <code>sp</code> for a given accessor. </p>

</div>
</div>
<a id="gabd231cc10a5192d97adf3547ee781b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd231cc10a5192d97adf3547ee781b1f">&#9670;&nbsp;</a></span>SparsityPatternBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternBase::SparsityPatternBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the matrix empty, that is with no memory allocated. This is useful if you want such objects as member variables in other classes. You can make the structure usable by calling the <a class="el" href="classSparsityPatternBase.html#a3b74407cb9f120f1c568209452e1b443">reinit()</a> function. </p>

</div>
</div>
<a id="gaa7c7e199d66bb83b69d52d126a536f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c7e199d66bb83b69d52d126a536f06">&#9670;&nbsp;</a></span>~SparsityPatternBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPatternBase::~SparsityPatternBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="ga3b74407cb9f120f1c568209452e1b443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b74407cb9f120f1c568209452e1b443">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate memory and set up data structures for a new matrix with <code>m</code> rows and <code>n</code> columns, with at most <code>max_per_row</code> nonzero entries per row.</p>
<p>This function simply maps its operations to the other <a class="el" href="classSparsityPatternBase.html#a3b74407cb9f120f1c568209452e1b443">reinit()</a> function. </p>

</div>
</div>
<a id="gaf64a59aef077cd122909bc3d510b00c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf64a59aef077cd122909bc3d510b00c8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate memory for a matrix of size <code>m</code> times <code>n</code>. The number of entries for each row is taken from the array <code>row_lengths</code> which has to give this number of each row \(i=1\ldots m\).</p>
<p>If <code>m*n==0</code> all memory is freed, resulting in a total reinitialization of the object. If it is nonzero, new memory is only allocated if the new size extends the old one. This is done to save time and to avoid fragmentation of the heap. </p>

</div>
</div>
<a id="ga7422bfd9cc2855cf992d156569f056ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7422bfd9cc2855cf992d156569f056ae">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SparsityPatternBase::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but with an <a class="el" href="classArrayView.html">ArrayView</a> argument instead.</p>
<p>The derived classes are responsible for implementation of this function. </p>

<p>Implemented in <a class="el" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">SparsityPattern</a>, <a class="el" href="classSparsityPattern.html#a26ec3baef7689cb2d7935c0df68cdda4">SparsityPattern</a>, and <a class="el" href="group__Exceptions.html#ga26ec3baef7689cb2d7935c0df68cdda4">SparsityPattern</a>.</p>

</div>
</div>
<a id="ga16c1ebb8fbefcdce0a313e7be27ad34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c1ebb8fbefcdce0a313e7be27ad34d">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the sparsity pattern symmetric by adding the sparsity pattern of the transpose object.</p>
<p>This function throws an exception if the sparsity pattern does not represent a quadratic matrix. </p>

</div>
</div>
<a id="ga2b55cadc7817ef973735f3caa02b8502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b55cadc7817ef973735f3caa02b8502">&#9670;&nbsp;</a></span>add() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a nonzero entry to the matrix. This function may only be called for non-compressed sparsity patterns.</p>
<p>If the entry already exists, nothing bad happens. </p>

</div>
</div>
<a id="gac9fd724a24c574100d582ad33722884f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9fd724a24c574100d582ad33722884f">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a> SparsityPatternBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of the matrix. The resulting iterator can be used to walk over all nonzero entries of the sparsity pattern.</p>
<p>The order in which elements are accessed depends on the storage scheme implemented by derived classes. </p>

</div>
</div>
<a id="ga688dd4995902ab99fa419d12484ae548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga688dd4995902ab99fa419d12484ae548">&#9670;&nbsp;</a></span>end() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a> SparsityPatternBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="ga7121b88b0435b93497f8ab6ea7ee5c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7121b88b0435b93497f8ab6ea7ee5c0b">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a> SparsityPatternBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferenceable in that case.</p>
<p>The order in which elements are accessed depends on the storage scheme implemented by derived classes. </p>

</div>
</div>
<a id="gae647faa02955ab0a43333d16297c6750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae647faa02955ab0a43333d16297c6750">&#9670;&nbsp;</a></span>end() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a32de0a562f86156d7ecebb09a85c832a">iterator</a> SparsityPatternBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="ga19e09b29ddae80a77a184bd081111fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e09b29ddae80a77a184bd081111fb5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternBase::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality of two SparsityPatterns. </p>

</div>
</div>
<a id="ga5ea2ecbf49c88fcb9bf6dc35d3d45b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea2ecbf49c88fcb9bf6dc35d3d45b4d">&#9670;&nbsp;</a></span>empty() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternBase::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as that both dimensions are zero. </p>

</div>
</div>
<a id="ga653ae26e6c6ec67639c6f36144f583dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga653ae26e6c6ec67639c6f36144f583dd">&#9670;&nbsp;</a></span>exists() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternBase::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a value at a certain position may be non-zero. </p>

</div>
</div>
<a id="gafe38c6ef54df0033741e2d29f41f71ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe38c6ef54df0033741e2d29f41f71ad">&#9670;&nbsp;</a></span>max_entries_per_row() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of entries per row. Before compression, this equals the number given to the constructor, while after compression, it equals the maximum number of entries actually allocated by the user. </p>

</div>
</div>
<a id="ga1dc1c584a2e274ea0a885fc28a0fc3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dc1c584a2e274ea0a885fc28a0fc3bc">&#9670;&nbsp;</a></span>bandwidth() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of \(|i-j|\) for which the index pair \((i,j)\) represents a nonzero entry of the matrix. Consequently, the maximum bandwidth a \(n\times m\) matrix can have is \(\max\{n-1,m-1\}\), a diagonal matrix has bandwidth 0, and there are at most \(2*q+1\) entries per row if the bandwidth is \(q\). The returned quantity is sometimes called "half
bandwidth" in the literature. </p>

</div>
</div>
<a id="ga0707927053081fd6c46dac186e63c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0707927053081fd6c46dac186e63c543">&#9670;&nbsp;</a></span>n_nonzero_elements() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SparsityPatternBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway.</p>
<p>This function may only be called if the matrix struct is compressed. It does not make too much sense otherwise anyway. </p>

</div>
</div>
<a id="ga84d6d95e0b21b597b06b094c70de2f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d6d95e0b21b597b06b094c70de2f2e">&#9670;&nbsp;</a></span>is_compressed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPatternBase::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the structure is compressed or not. </p>

</div>
</div>
<a id="ga54f9eaaf6d72dcda84b91155918284cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f9eaaf6d72dcda84b91155918284cb">&#9670;&nbsp;</a></span>n_rows() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of rows of this matrix, which equals the dimension of the image space. </p>

</div>
</div>
<a id="gaf14c01672d8104140704a98b9f18fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14c01672d8104140704a98b9f18fcfb">&#9670;&nbsp;</a></span>n_cols() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of columns of this matrix, which equals the dimension of the range space. </p>

</div>
</div>
<a id="ga5144f4bb094460afd2c258f1e295bbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5144f4bb094460afd2c258f1e295bbc5">&#9670;&nbsp;</a></span>row_length() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> SparsityPatternBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

</div>
</div>
<a id="gab0941b7048d52742bcb3ad11e46c7e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0941b7048d52742bcb3ad11e46c7e57">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SparsityPatternBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. See <a class="el" href="namespaceMemoryConsumption.html">MemoryConsumption</a>. </p>

</div>
</div>
<a id="ga693eb9b754cb846967c84d648c737b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693eb9b754cb846967c84d648c737b29">&#9670;&nbsp;</a></span>column_number() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::column_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to column number field. Return the column number of the <code>index</code>th entry in <code>row</code>. Note that if diagonal elements are optimized, the first element in each row is the diagonal element, i.e. <code>column_number(row,0)==row</code>.</p>
<p>If the sparsity pattern is already compressed, then (except for the diagonal element), the entries are sorted by columns, i.e. <code>column_number(row,i)</code> <code>&lt;</code> <code>column_number(row,i+1)</code>. </p>

</div>
</div>
<a id="ga1c3bb2176471a4524ab88cc5cd6c7f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3bb2176471a4524ab88cc5cd6c7f30">&#9670;&nbsp;</a></span>row_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a> SparsityPatternBase::row_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The index of a global matrix entry in its row.</p>
<p>This function is analogous to operator(), but it computes the index not with respect to the total field, but only with respect to the row <code>j</code>. </p>

</div>
</div>
<a id="ga3f0d069f88fdde21c5983efb725ac355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0d069f88fdde21c5983efb725ac355">&#9670;&nbsp;</a></span>matrix_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>, <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">size_type</a>&gt; SparsityPatternBase::matrix_position </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the inverse operation to operator()(): given a global index, find out row and column of the matrix entry to which it belongs. The returned value is the pair composed of row and column index.</p>
<p>This function may only be called if the sparsity pattern is closed. The global index must then be between zero and <a class="el" href="classSparsityPatternBase.html#a0707927053081fd6c46dac186e63c543">n_nonzero_elements()</a>.</p>
<p>If <code>N</code> is the number of rows of this matrix, then the complexity of this function is <em>log(N)</em>. </p>

</div>
</div>
<a id="ga5d941ca61962e3f9fffc3979731a79d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d941ca61962e3f9fffc3979731a79d2">&#9670;&nbsp;</a></span>print() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix. The output consists of one line per row of the format <code>[i,j1,j2,j3,...]</code>. <em>i</em> is the row number and <em>jn</em> are the allocated columns in this row. </p>

</div>
</div>
<a id="ga7f59a68863a1e770ba275894a7170e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f59a68863a1e770ba275894a7170e70">&#9670;&nbsp;</a></span>print_gnuplot() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. The format consists of pairs <code>i j</code> of nonzero elements, each representing one entry of this matrix, one per line of the output file. Indices are counted from zero on, as usual. Since sparsity patterns are printed in the same way as matrices are displayed, we print the negative of the column index, which means that the <code>(0,0)</code> element is in the top left rather than in the bottom left corner.</p>
<p>Print the sparsity pattern in gnuplot by setting the data style to dots or points and use the <code>plot</code> command. </p>

</div>
</div>
<a id="ga226ebb78284e9c60ddda8e3ae6779d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga226ebb78284e9c60ddda8e3ae6779d60">&#9670;&nbsp;</a></span>print_svg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::print_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the sparsity of the matrix in a .svg file which can be opened in a web browser. The .svg file contains squares which correspond to the entries in the matrix. An entry in the matrix which contains a non-zero value corresponds with a red square while a zero-valued entry in the matrix correspond with a white square. </p>

</div>
</div>
<a id="ga0635b1e8213ec4c51a9651dee34b3a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0635b1e8213ec4c51a9651dee34b3a5d">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga9d2c1125d76dde276bd6f504b1ec7f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2c1125d76dde276bd6f504b1ec7f07">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga01c76cfef0d63da0eaa6f63ff12cd1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c76cfef0d63da0eaa6f63ff12cd1c3">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPatternBase::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga2c5ea1fc99de62b1367c495337477e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c5ea1fc99de62b1367c495337477e9e">&#9670;&nbsp;</a></span>column_number() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">BlockDynamicSparsityPattern::size_type</a> BlockDynamicSparsityPattern::column_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to column number field. Return the column number of the <code>index</code> th entry in row <code>row</code>. </p>

<p class="definition">Definition at line <a class="el" href="lac_2block__sparsity__pattern_8h_source.html#l00991">991</a> of file <a class="el" href="lac_2block__sparsity__pattern_8h_source.html">block_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gaaddfdea0c37c5c468e7a76dc47840ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaddfdea0c37c5c468e7a76dc47840ff9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BlockSparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forwarding to <a class="el" href="classBlockSparsityPatternBase.html#af19ed94a019224dd27ff879caf7a4188">BlockSparsityPatternBase::reinit()</a>. </p>

<p class="definition">Definition at line <a class="el" href="lac_2block__sparsity__pattern_8h_source.html#l01020">1020</a> of file <a class="el" href="lac_2block__sparsity__pattern_8h_source.html">block_sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae6efac28d03eb104562e88a809790883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6efac28d03eb104562e88a809790883">&#9670;&nbsp;</a></span>invalid_entry <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classBlockSparsityPatternBase.html#a4d8af14de1e21c26eaeb48fd31846bdc">size_type</a> <a class="el" href="classBlockSparsityPatternBase.html">BlockSparsityPatternBase</a>&lt; SparsityPatternType &gt;::invalid_entry = SparsityPattern::invalid_entry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define a value which is used to indicate that a certain value in the <code>colnums</code> array is unused, i.e. does not represent a certain column number index. This value is only an alias to the respective value of the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. </p>

<p class="definition">Definition at line <a class="el" href="lac_2block__sparsity__pattern_8h_source.html#l00089">89</a> of file <a class="el" href="lac_2block__sparsity__pattern_8h_source.html">block_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga3bee1bf95816c5bc5d1fa863709b6adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bee1bf95816c5bc5d1fa863709b6adb">&#9670;&nbsp;</a></span>sparsity_pattern <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> * ChunkSparsityPatternIterators::Accessor::sparsity_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The sparsity pattern we operate on accessed. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00145">145</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga0e28f6cf9346acf73d41b09429914454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e28f6cf9346acf73d41b09429914454">&#9670;&nbsp;</a></span>reduced_accessor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPatternIterators_1_1Accessor.html">SparsityPatternIterators::Accessor</a> ChunkSparsityPatternIterators::Accessor::reduced_accessor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The accessor of the (reduced) sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00151">151</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gaf6e4d85ce7b010b45534e077b3ec3f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e4d85ce7b010b45534e077b3ec3f39">&#9670;&nbsp;</a></span>chunk_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a> ChunkSparsityPatternIterators::Accessor::chunk_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current chunk row number. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00157">157</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga1eacf46d3f30fd32806f255171a3389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eacf46d3f30fd32806f255171a3389c">&#9670;&nbsp;</a></span>chunk_col</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html#a79094ea32b3807c12b049b1c7c34bff7">size_type</a> ChunkSparsityPatternIterators::Accessor::chunk_col</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current chunk col number. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00163">163</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga084938eb3e5871f67ecc0ef712ecb365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084938eb3e5871f67ecc0ef712ecb365">&#9670;&nbsp;</a></span>accessor <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">Accessor</a> ChunkSparsityPatternIterators::Iterator::accessor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store an object of the accessor class. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00253">253</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga07435d9948f56fdfcd2da48d321a733b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07435d9948f56fdfcd2da48d321a733b">&#9670;&nbsp;</a></span>invalid_entry <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">size_type</a> ChunkSparsityPattern::invalid_entry = SparsityPattern::invalid_entry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define a value which is used to indicate that a certain value in the colnums array is unused, i.e. does not represent a certain column number index. Indices with this invalid value are used to insert new entries to the sparsity pattern using the <a class="el" href="classChunkSparsityPattern.html#a07b49e5060932cbee4e438699da65581">add()</a> member function, and are removed when calling <a class="el" href="classChunkSparsityPattern.html#a545474926fb71c36f09d317e1f4ff830">compress()</a>. You should not assume that the variable declared here has a certain value. The initialization is given here only to enable the compiler to perform some optimizations, but the actual value of the variable may change over time. </p>

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00301">301</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga20831f347c1aa6d8fddbff4327ecd698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20831f347c1aa6d8fddbff4327ecd698">&#9670;&nbsp;</a></span>sparsity_pattern <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> * DynamicSparsityPatternIterators::Accessor::sparsity_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The sparsity pattern we operate on accessed. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00143">143</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga808262f5f634c1141cb412a55d9c1fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808262f5f634c1141cb412a55d9c1fcd">&#9670;&nbsp;</a></span>current_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> DynamicSparsityPatternIterators::Accessor::current_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The row we currently point into. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00149">149</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gabb0527eb1e9116064b33a3bd570bb63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb0527eb1e9116064b33a3bd570bb63d">&#9670;&nbsp;</a></span>current_entry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> &gt;::const_iterator DynamicSparsityPatternIterators::Accessor::current_entry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the element within the current row that we currently point to. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00156">156</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga55be108e835041773cef6b09de5c3d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55be108e835041773cef6b09de5c3d9c">&#9670;&nbsp;</a></span>end_of_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__Sparsity.html#gadfbeb2cf093e039975a1e99924b96690">size_type</a> &gt;::const_iterator DynamicSparsityPatternIterators::Accessor::end_of_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the end of the current row. We store this to make comparison against the end of line iterator cheaper as it otherwise needs to do the <a class="el" href="classIndexSet.html">IndexSet</a> translation from row index to the index within the 'lines' array of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00165">165</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga69b11c7e62ae37df8940661610d63b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b11c7e62ae37df8940661610d63b8f">&#9670;&nbsp;</a></span>accessor <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">Accessor</a> DynamicSparsityPatternIterators::Iterator::accessor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store an object of the accessor class. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00296">296</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga864232a7239785d7a8c201c81914305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864232a7239785d7a8c201c81914305e">&#9670;&nbsp;</a></span>have_entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> DynamicSparsityPattern::have_entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that stores whether any entries have been added so far. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00720">720</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga28b93db96b47f13a47950dad08a07ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b93db96b47f13a47950dad08a07ad0">&#9670;&nbsp;</a></span>rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows that this sparsity structure shall represent. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00726">726</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gac26fed625d6b7127c1face8133e71413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26fed625d6b7127c1face8133e71413">&#9670;&nbsp;</a></span>cols</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> DynamicSparsityPattern::cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns that this sparsity structure shall represent. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00732">732</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga2672023c3863f02a81d46fb9ea5b51b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2672023c3863f02a81d46fb9ea5b51b1">&#9670;&nbsp;</a></span>rowset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DynamicSparsityPattern::rowset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set that contains the valid rows. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00739">739</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga335542a5ba7533469cd9d0f0d4696a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga335542a5ba7533469cd9d0f0d4696a9d">&#9670;&nbsp;</a></span>entries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">size_type</a> &gt; DynamicSparsityPattern::Line::entries</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Storage for the column indices of this row. This array is always kept sorted. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00757">757</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga27ef582c284525e8b73895670d1ec986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ef582c284525e8b73895670d1ec986">&#9670;&nbsp;</a></span>lines</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structDynamicSparsityPattern_1_1Line.html">Line</a> &gt; DynamicSparsityPattern::lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual data: store for each row the set of nonzero entries. </p>

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00789">789</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gaeda55d958060e7650c62037bc15bcad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeda55d958060e7650c62037bc15bcad2">&#9670;&nbsp;</a></span>container</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPatternBase.html">SparsityPatternBase</a> * SparsityPatternIterators::Accessor::container</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The sparsity pattern we operate on accessed. </p>

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00245">245</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gaefe597a5a4c58ecdff28a4d4c75f5aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefe597a5a4c58ecdff28a4d4c75f5aa6">&#9670;&nbsp;</a></span>linear_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SparsityPatternIterators::Accessor::linear_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index in global sparsity pattern. This index represents the location the iterator/accessor points to within the array of the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class that stores the column numbers. It is also the index within the values array of a sparse matrix that stores the corresponding value of this site. </p>

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00255">255</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga827dd2a6a48aa827edc8eda109fc27c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827dd2a6a48aa827edc8eda109fc27c8">&#9670;&nbsp;</a></span>invalid_entry <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPatternBase.html#a39c7b2070bea3afe6064dffdf5b1d664">SparsityPatternBase::size_type</a> SparsityPatternBase::invalid_entry = <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define a value which is used to indicate that a certain value in the <a class="el" href="group__Exceptions.html#ga053dc7218e68bd1689dc1e40c5f0aacf">colnums</a> array is unused, i.e. does not represent a certain column number index. Indices with this invalid value are used to insert new entries to the sparsity pattern using the <a class="el" href="classSparsityPatternBase.html#a2b55cadc7817ef973735f3caa02b8502">add()</a> member function, and are removed when calling <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a>. You should not assume that the variable declared here has a certain value. The initialization is given here only to enable the compiler to perform some optimizations, but the actual value of the variable may change over time. </p>

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00379">379</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="gab98ab372c63eaaf5e78f53002b678126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98ab372c63eaaf5e78f53002b678126">&#9670;&nbsp;</a></span>Iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Iterator.html">Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html#l00173">173</a> of file <a class="el" href="lac_2chunk__sparsity__pattern_8h_source.html">chunk_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gab98ab372c63eaaf5e78f53002b678126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98ab372c63eaaf5e78f53002b678126">&#9670;&nbsp;</a></span>Iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPatternIterators_1_1Iterator.html">Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00175">175</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga0f948b4c2f3b204e9fd3576ddad5bc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f948b4c2f3b204e9fd3576ddad5bc76">&#9670;&nbsp;</a></span>DynamicSparsityPatternIterators::Accessor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynamicSparsityPatternIterators_1_1Accessor.html">DynamicSparsityPatternIterators::Accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html#l00792">792</a> of file <a class="el" href="lac_2dynamic__sparsity__pattern_8h_source.html">dynamic_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="gae58b69743a1fc8209af1427247bad7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58b69743a1fc8209af1427247bad7b4">&#9670;&nbsp;</a></span>LinearIndexIterator&lt; Iterator, Accessor &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearIndexIterator.html">LinearIndexIterator</a>&lt; <a class="el" href="classSparsityPatternIterators_1_1Iterator.html">Iterator</a>, <a class="el" href="classSparsityPatternIterators_1_1Accessor.html">Accessor</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00265">265</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ga4b8cb66f1f83ca02d1cbe16924ddfb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8cb66f1f83ca02d1cbe16924ddfb76">&#9670;&nbsp;</a></span>ChunkSparsityPatternIterators::Accessor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparsityPatternIterators_1_1Accessor.html">ChunkSparsityPatternIterators::Accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2sparsity__pattern_8h_source.html#l00268">268</a> of file <a class="el" href="lac_2sparsity__pattern_8h_source.html">sparsity_pattern.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassChunkSparsityPattern_html_a43fe54b08913d30ae5dcb81fc72107bb"><div class="ttname"><a href="classChunkSparsityPattern.html#a43fe54b08913d30ae5dcb81fc72107bb">ChunkSparsityPattern::size_type</a></div><div class="ttdeci">types::global_dof_index size_type</div><div class="ttdef"><b>Definition:</b> <a href="lac_2chunk__sparsity__pattern_8h_source.html#l00273">chunk_sparsity_pattern.h:273</a></div></div>
<div class="ttc" id="aclassChunkSparsityPattern_html_ab29764d5ecb67c135d727658347d26c1"><div class="ttname"><a href="classChunkSparsityPattern.html#ab29764d5ecb67c135d727658347d26c1">ChunkSparsityPattern::n_cols</a></div><div class="ttdeci">size_type n_cols() const</div></div>
<div class="ttc" id="aclassChunkSparsityPattern_html_af60af18b0bd7b73f1f5e752b0d30802a"><div class="ttname"><a href="classChunkSparsityPattern.html#af60af18b0bd7b73f1f5e752b0d30802a">ChunkSparsityPattern::n_rows</a></div><div class="ttdeci">size_type n_rows() const</div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638afb9cf45d5916e2dce29dbefbeb3c6a1a"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638afb9cf45d5916e2dce29dbefbeb3c6a1a">LAPACKSupport::matrix</a></div><div class="ttdeci">@ matrix</div><div class="ttdoc">Contents is actually a matrix.</div><div class="ttdef"><b>Definition:</b> <a href="lac_2lapack__support_8h_source.html#l00063">lapack_support.h:63</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
