<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__dofs.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Degrees of Freedom This module groups classes and namespaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Degrees of Freedom This module groups classes and namespaces</div>  </div>
</div><!--header-->
<div class="contents">

<p>that have to do with handling degrees of freedom. The central class of this group is the <a class="el" href="classDoFHandler.html">DoFHandler</a> class: it is built on top of a triangulation and a finite element class and allocated degrees of freedom on each cell of the triangulation as required for the finite element space described by the finite element object. There are other variants of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class such as <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> that do similar things for more special cases. <a class="el" href="classDoFHandler.html">DoFHandler</a> objects are used together with objects of type <a class="el" href="classFiniteElement.html">FiniteElement</a> (or <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> in the case of <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>) to enumerate all the degrees of freedom that exist in a triangulation for this particular finite element. As such, the combination of mesh, finite element, and DoF handler object can be thought of as providing a <em>basis</em> of the finite element space: the mesh provides the locations at which basis functions are defined; the finite element describes what kinds of basis functions exist; and the DoF handler object provides an enumeration of the basis, i.e., it is provides a concrete structure of the space so that we can describe functions in this finite dimensional space by vectors of coefficients. DoFHandlers extend <a class="el" href="classTriangulation.html">Triangulation</a> objects (and the other classes in the <a class="el" href="group__grid.html">Grids and Triangulations This module groups functions and</a> module) in that they, too, offer iterators that run over all cells, faces, or other geometric objects that make up a triangulation. These iterators are derived from the triangulation iterators and therefore offer the same functionality, but they also offer additional functions. For example, they allow to query the indices of the degrees of freedom associated with the present cell. Note that <a class="el" href="classDoFHandler.html">DoFHandler</a> classes are <em>not derived</em> from <a class="el" href="classTriangulation.html">Triangulation</a>, though they use <a class="el" href="classTriangulation.html">Triangulation</a> objects; the reason is that there can be more than one <a class="el" href="classDoFHandler.html">DoFHandler</a> object that works on the same <a class="el" href="classTriangulation.html">Triangulation</a> object. In addition to the DoF handler classes, this module holds a number of auxiliary classes not commonly used in application programs, as well as three classes that are not directly associated with the data structures of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class. The first of these is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class that stores and treats the constraints associated with hanging nodes. Secondly, the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace offers functions that can reorder degrees of freedom; among its functions are ones that sort degrees of freedom in downstream direction, for example, and ones that sort degrees of freedom in such a way that the bandwidth of associated matrices is minimized. Finally, the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace offers a variety of algorithms around handling degrees of freedom. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library:  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Degrees of Freedom This module groups classes and namespaces:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html">Constraints on degrees of freedom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinternal_1_1DoFHandlerImplementation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1DoFHandlerImplementation.html">internal::DoFHandlerImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDoFRenumbering"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDoFTools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html">DoFTools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockInfo.html">BlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class collecting the different <a class="el" href="classBlockIndices.html">BlockIndices</a> involved in global, multilevel and local computations. Once a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been initialized with an <a class="el" href="classFESystem.html">FESystem</a>, a data object of type <a class="el" href="classBlockInfo.html" title="A small class collecting the different BlockIndices involved in global, multilevel and local computat...">BlockInfo</a> (accessed by <a class="el" href="classDoFHandler.html#a76c71bc8d38639321ff571661de296dd">DoFHandler::block_info()</a> ) is filled, which reflects the block structure of the degrees of freedom. <a class="el" href="classBlockInfo.html" title="A small class collecting the different BlockIndices involved in global, multilevel and local computat...">BlockInfo</a> consists of several <a class="el" href="classBlockIndices.html">BlockIndices</a> objects. The member <a class="el" href="classBlockInfo.html#ab9c42d6e2e1fb8bfc0f55ecd938b2f2b">global()</a> reflects the block structure of the system on the active cell level, usually referred to as the global system. As soon as <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a> has been called, the function <a class="el" href="classBlockIndices.html#a51b1014b407737cfdd91df0b33793dd7">BlockIndices::block_size()</a> in <a class="el" href="classBlockInfo.html#ab9c42d6e2e1fb8bfc0f55ecd938b2f2b">global()</a> will return the correct sizes of each block. After <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">DoFRenumbering::block_wise()</a>, <a class="el" href="classBlockIndices.html#ae025d42ea6c023d11bce1723670a1d5a">BlockIndices::block_start()</a> will return the start index for each of the blocks. When a <a class="el" href="classDoFHandler.html">DoFHandler</a> with levels is used, the same structure is automatically generated for each level. The level blocks can be accessed through <a class="el" href="classBlockInfo.html#a9b200f57e2db76116691e6d523aa8989">level()</a>. Finally, there are <a class="el" href="classBlockInfo.html#acb3a36ef4badb3fa8607b2b85b2489de">local()</a> <a class="el" href="classBlockIndices.html">BlockIndices</a>, which describe the block structure on a single cell. This is used for instance by <a class="el" href="classMeshWorker_1_1Assembler_1_1MatrixLocalBlocksToGlobalBlocks.html">MeshWorker::Assembler::MatrixLocalBlocksToGlobalBlocks</a>. The local indices are not filled automatically, since they change the behavior of the <a class="el" href="namespaceMeshWorker_1_1Assembler.html">MeshWorker::Assembler</a> classes relying on <a class="el" href="classBlockInfo.html" title="A small class collecting the different BlockIndices involved in global, multilevel and local computat...">BlockInfo</a>. They must be initialized by hand through <a class="el" href="classBlockInfo.html#af32417e3a55a6eca6230e0e024cf8cbb" title="Initialize block structure on cells and compute renumbering between cell dofs and block cell dofs.">initialize_local()</a>.  <a href="classBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1DoFAccessorImplementation_1_1Inheritance.html">internal::DoFAccessorImplementation::Inheritance&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html">DoFAccessor&lt; structdim, dim, spacedim, level_dof_access &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFHandler.html">DoFHandler&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1DoFHandlerImplementation_1_1DoFObjects.html">internal::DoFHandlerImplementation::DoFObjects&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html">AffineConstraints&lt; number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga768cd565b5c25f1ac235586e36ac94d6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ga768cd565b5c25f1ac235586e36ac94d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> = ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt;</td></tr>
<tr class="separator:ga768cd565b5c25f1ac235586e36ac94d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>that have to do with handling degrees of freedom. The central class of this group is the <a class="el" href="classDoFHandler.html">DoFHandler</a> class: it is built on top of a triangulation and a finite element class and allocated degrees of freedom on each cell of the triangulation as required for the finite element space described by the finite element object. There are other variants of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class such as <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> that do similar things for more special cases. <a class="el" href="classDoFHandler.html">DoFHandler</a> objects are used together with objects of type <a class="el" href="classFiniteElement.html">FiniteElement</a> (or <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> in the case of <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>) to enumerate all the degrees of freedom that exist in a triangulation for this particular finite element. As such, the combination of mesh, finite element, and DoF handler object can be thought of as providing a <em>basis</em> of the finite element space: the mesh provides the locations at which basis functions are defined; the finite element describes what kinds of basis functions exist; and the DoF handler object provides an enumeration of the basis, i.e., it is provides a concrete structure of the space so that we can describe functions in this finite dimensional space by vectors of coefficients. DoFHandlers extend <a class="el" href="classTriangulation.html">Triangulation</a> objects (and the other classes in the <a class="el" href="group__grid.html">Grids and Triangulations This module groups functions and</a> module) in that they, too, offer iterators that run over all cells, faces, or other geometric objects that make up a triangulation. These iterators are derived from the triangulation iterators and therefore offer the same functionality, but they also offer additional functions. For example, they allow to query the indices of the degrees of freedom associated with the present cell. Note that <a class="el" href="classDoFHandler.html">DoFHandler</a> classes are <em>not derived</em> from <a class="el" href="classTriangulation.html">Triangulation</a>, though they use <a class="el" href="classTriangulation.html">Triangulation</a> objects; the reason is that there can be more than one <a class="el" href="classDoFHandler.html">DoFHandler</a> object that works on the same <a class="el" href="classTriangulation.html">Triangulation</a> object. In addition to the DoF handler classes, this module holds a number of auxiliary classes not commonly used in application programs, as well as three classes that are not directly associated with the data structures of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class. The first of these is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class that stores and treats the constraints associated with hanging nodes. Secondly, the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace offers functions that can reorder degrees of freedom; among its functions are ones that sort degrees of freedom in downstream direction, for example, and ones that sort degrees of freedom in such a way that the bandwidth of associated matrices is minimized. Finally, the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace offers a variety of algorithms around handling degrees of freedom. In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </p>
<p>This module groups classes and namespaces that have to do with handling degrees of freedom. The central class of this group is the <a class="el" href="classDoFHandler.html">DoFHandler</a> class: it is built on top of a triangulation and a finite element class and allocated degrees of freedom on each cell of the triangulation as required for the finite element space described by the finite element object. There are other variants of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class such as <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> that do similar things for more special cases.</p>
<div class="dotgraph">
<div class="caption">
digraph G { graph[rankdir="TB",bgcolor="transparent"];</div>
</div>
<p><a class="el" href="classDoFHandler.html">DoFHandler</a> objects are used together with objects of type <a class="el" href="classFiniteElement.html">FiniteElement</a> (or <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> in the case of <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>) to enumerate all the degrees of freedom that exist in a triangulation for this particular finite element. As such, the combination of mesh, finite element, and DoF handler object can be thought of as providing a <em>basis</em> of the finite element space: the mesh provides the locations at which basis functions are defined; the finite element describes what kinds of basis functions exist; and the DoF handler object provides an enumeration of the basis, i.e., it is provides a concrete structure of the space so that we can describe functions in this finite dimensional space by vectors of coefficients.</p>
<p>DoFHandlers extend <a class="el" href="classTriangulation.html">Triangulation</a> objects (and the other classes in the <a class="el" href="group__grid.html">Grids and Triangulations This module groups functions and</a> module) in that they, too, offer iterators that run over all cells, faces, or other geometric objects that make up a triangulation. These iterators are derived from the triangulation iterators and therefore offer the same functionality, but they also offer additional functions. For example, they allow to query the indices of the degrees of freedom associated with the present cell. Note that <a class="el" href="classDoFHandler.html">DoFHandler</a> classes are <em>not derived</em> from <a class="el" href="classTriangulation.html">Triangulation</a>, though they use <a class="el" href="classTriangulation.html">Triangulation</a> objects; the reason is that there can be more than one <a class="el" href="classDoFHandler.html">DoFHandler</a> object that works on the same <a class="el" href="classTriangulation.html">Triangulation</a> object.</p>
<p>In addition to the DoF handler classes, this module holds a number of auxiliary classes not commonly used in application programs, as well as three classes that are not directly associated with the data structures of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class. The first of these is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class that stores and treats the constraints associated with hanging nodes. Secondly, the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace offers functions that can reorder degrees of freedom; among its functions are ones that sort degrees of freedom in downstream direction, for example, and ones that sort degrees of freedom in such a way that the bandwidth of associated matrices is minimized. Finally, the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace offers a variety of algorithms around handling degrees of freedom.</p>
<p>In the grand scheme of things, the pieces of this module interact with a variety of other parts of the library: </p><div class="dotgraph">
</div>
 <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga768cd565b5c25f1ac235586e36ac94d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768cd565b5c25f1ac235586e36ac94d6">&#9670;&nbsp;</a></span>DoFHandler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> = typedef ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt;<a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>Upon mesh refinement, child cells inherit the active FE index of the parent.</li>
<li>When coarsening cells, the (now active) parent cell will be assigned an active FE index that is determined from its (no longer active) children, following the <a class="el" href="namespaceFiniteElementDomination.html">FiniteElementDomination</a> logic: Out of the set of elements previously assigned to the former children, we choose the one dominated by all children for the parent cell. If none was found, we pick the most dominant element in the whole collection that is dominated by all former children. See <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> for further information on this topic. <dl class="section note"><dt>Note</dt><dd>Finite elements need to be assigned to each cell by either calling set_fe() or <a class="el" href="step-2_8cc.html#a3a9f87477d0e161e173c8a8d7ddbff33">distribute_dofs()</a> first to make this functionality available. <h3>Active FE indices and parallel meshes</h3>
</dd></dl>
When this class is used with either a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, you can only set active FE indices on cells that are locally owned, using a call such as <code>cell-&gt;set_active_fe_index(...)</code> . On the other hand, setting the active FE index on ghost or artificial cells is not allowed. Ghost cells do acquire the information what element is active on them, however: whenever you call hp::DoFHandler::distribute_dofs(), all processors that participate in the parallel mesh exchange information in such a way that the active FE index on ghost cells equals the active FE index that was set on that processor that owned that particular ghost cell. Consequently, one can <em>query</em> the <code>active_fe_index</code> on ghost cells, just not set it by hand. On artificial cells, no information is available about the <code>active_fe_index</code> used there. That's because we don't even know whether these cells exist at all, and even if they did, the current processor does not know anything specific about them. See <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary entry on artificial cells</a> for more information. During refinement and coarsening, information about the <code>active_fe_index</code> of each cell will be automatically transferred. However, using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with an <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> requires additional attention during serialization, since no information on active FE indices will be automatically transferred. This has to be done manually using the prepare_for_serialization_of_active_fe_indices() and deserialize_active_fe_indices() functions. The former has to be called before <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a> is invoked, and the latter needs to be run after <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation::load()</a>. If further data will be attached to the triangulation via the <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a>, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>, or <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> classes, all corresponding preparation and deserialization function calls need to happen in the same order. Consult the documentation of <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> for more information. @ :: capable of hp-adaptation now.</li>
</ul>
<p>Manage the distribution and numbering of the degrees of freedom for hp- FEM algorithms. This class satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> requirements.</p>
<p>The purpose of this class is to allow for an enumeration of degrees of freedom in the same way as the <a class="el" href="classDoFHandler.html">DoFHandler</a> class, but it allows to use a different finite element on every cell. To this end, one assigns an <code>active_fe_index</code> to every cell that indicates which element within a collection of finite elements (represented by an object of type <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>) is the one that lives on this cell. The class then enumerates the degree of freedom associated with these finite elements on each cell of a triangulation and, if possible, identifies degrees of freedom at the interfaces of cells if they match. If neighboring cells have degrees of freedom along the common interface that do not immediate match (for example, if you have \(Q_2\) and \(Q_3\) elements meeting at a common face), then one needs to compute constraints to ensure that the resulting finite element space on the mesh remains conforming.</p>
<p>The whole process of working with objects of this type is explained in <a class="el" href="step_27.html">step-27</a>. Many of the algorithms this class implements are described in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>.</p>
<h3>Active FE indices and their behavior under mesh refinement</h3>
<p>The typical workflow for using this class is to create a mesh, assign an active FE index to every active cell, calls hp::DoFHandler::distribute_dofs(), and then assemble a linear system and solve a problem on this finite element space. However, one can skip assigning active FE indices upon mesh refinement in certain circumstances. In particular, the following rules apply:</p><ul>
<li>Upon mesh refinement, child cells inherit the active FE index of the parent.</li>
<li>When coarsening cells, the (now active) parent cell will be assigned an active FE index that is determined from its (no longer active) children, following the <a class="el" href="namespaceFiniteElementDomination.html">FiniteElementDomination</a> logic: Out of the set of elements previously assigned to the former children, we choose the one dominated by all children for the parent cell. If none was found, we pick the most dominant element in the whole collection that is dominated by all former children. See <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> for further information on this topic.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Finite elements need to be assigned to each cell by either calling set_fe() or <a class="el" href="step-2_8cc.html#a3a9f87477d0e161e173c8a8d7ddbff33">distribute_dofs()</a> first to make this functionality available.</dd></dl>
<h3>Active FE indices and parallel meshes</h3>
<p>When this class is used with either a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, you can only set active FE indices on cells that are locally owned, using a call such as <code>cell-&gt;set_active_fe_index(...)</code>. On the other hand, setting the active FE index on ghost or artificial cells is not allowed.</p>
<p>Ghost cells do acquire the information what element is active on them, however: whenever you call hp::DoFHandler::distribute_dofs(), all processors that participate in the parallel mesh exchange information in such a way that the active FE index on ghost cells equals the active FE index that was set on that processor that owned that particular ghost cell. Consequently, one can <em>query</em> the <code>active_fe_index</code> on ghost cells, just not set it by hand.</p>
<p>On artificial cells, no information is available about the <code>active_fe_index</code> used there. That's because we don't even know whether these cells exist at all, and even if they did, the current processor does not know anything specific about them. See <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary entry on artificial cells</a> for more information.</p>
<p>During refinement and coarsening, information about the <code>active_fe_index</code> of each cell will be automatically transferred.</p>
<p>However, using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with an <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> requires additional attention during serialization, since no information on active FE indices will be automatically transferred. This has to be done manually using the prepare_for_serialization_of_active_fe_indices() and deserialize_active_fe_indices() functions. The former has to be called before <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a> is invoked, and the latter needs to be run after <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation::load()</a>. If further data will be attached to the triangulation via the <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a>, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>, or <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> classes, all corresponding preparation and deserialization function calls need to happen in the same order. Consult the documentation of <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> for more information.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000139">Deprecated:</a></b></dt><dd>The basic <a class="el" href="classDoFHandler.html">DoFHandler</a> is capable of hp-adaptation now. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hp_2dof__handler_8h_source.html#l00066">66</a> of file <a class="el" href="hp_2dof__handler_8h_source.html">dof_handler.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
