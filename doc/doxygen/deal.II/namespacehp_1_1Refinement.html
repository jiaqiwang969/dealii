<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespacehp_1_1Refinement.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: hp::Refinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehp.html">hp</a></li><li class="navelem"><a class="el" href="namespacehp_1_1Refinement.html">Refinement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">hp::Refinement Namespace Reference<div class="ingroups"><a class="el" href="group__hp.html">hp-finite element support Classes and functions that have to</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a> = <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number &amp;)&gt;</td></tr>
<tr class="separator:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>We supply adaptive methods to align computational resources with the complexity of the numerical solution. Error estimates are an appropriate means of determining where adjustments need to be made. However with hp-adaptivity, we have two ways to realize these adjustments: For irregular solutions, h-adaptive methods which dynamically assign cell sizes tend to reduce the approximation error, while for smooth solutions p-adaptive methods are better suited in which function spaces will be selected dynamically. This namespace collects tools to decide which type of adaptive methods to apply. </p><h3>Usage</h3>
<p>To successfully apply hp-adaptive methods, we recommend the following workflow: </p><ol>
<li>
A suitable error estimate is the basis for any kind of adaptive method. Similar to pure grid refinement, we will determine error estimates in the usual way (i.e. <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>) and mark cells for refinement or coarsening (i.e. <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>). Calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> at this stage will perform pure grid refinement as expected. </li>
<li>
Once all refinement and coarsening flags have been distributed on the mesh, we may determine if those qualify for p-adaptive methods. Corresponding functions will set <code>future_fe_indices</code> on top of the refinement and coarsening flags if they fulfil a certain criterion. In case of refinement, the superordinate element of the underlying <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> will be assigned as the future finite element. Correspondingly, the subordinate element will be selected for coarsening. <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> will now supply both h- and p-adaptive methods independently. </li>
<li>
Right now, there may be cells scheduled for both h- and p-adaptation. If we do not want to impose both methods at once, we need to decide which one to pick for each cell individually and unambiguously. Since grid refinement will be imposed by default and we only determine qualification for p-adaptivity on top, we will always decide in favour of p-adaptive methods. Calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> will now perform either h- or p-adaptive methods uniquely on each cell. </li>
<li>
Up to this point, each cell knows its destiny in terms of adaptivity. We can now move on to prepare all data structures to be transferred across mesh changes. Previously set refinement and coarsening flags as well as <code>future_fe_indices</code> will be used to update the data accordingly. </li>
</ol>
<p>As an example, a realisation of pure p-adaptive methods would look like the following: </p><div class="fragment"><div class="line"><span class="comment">// step 1: flag cells for refinement or coarsening</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">  hp_dof_handler,</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> (<a class="code" href="namespaceParticles_1_1Generators.html#aa1cd861e3aaf1770ddcddd956cdae5e4">quadrature_points</a>),</div>
<div class="line">  <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim, Number&gt;</a>&gt;(),</div>
<div class="line">  <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">  estimated_error_per_cell);</div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                estimated_error_per_cell,</div>
<div class="line">                                                top_fraction,</div>
<div class="line">                                                bottom_fraction);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 2: set future finite element indices on flagged cells</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7fc52cae14b805ecd78d329dbdd03986">hp::Refinement::full_p_adaptivity</a>(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 3: decide whether h- or p-adaptive methods will be supplied</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7dcdcc921a66bb023b4d1ed7c648137c">hp::Refinement::force_p_over_h</a>(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 4: prepare solutions to be transferred</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">triangulation.execute_coarsening_and_refinement();</div>
</div><!-- fragment --><p>We supply adaptive methods to align computational resources with the complexity of the numerical solution. Error estimates are an appropriate means of determining where adjustments need to be made.</p>
<p>However with hp-adaptivity, we have two ways to realize these adjustments: For irregular solutions, h-adaptive methods which dynamically assign cell sizes tend to reduce the approximation error, while for smooth solutions p-adaptive methods are better suited in which function spaces will be selected dynamically. This namespace collects tools to decide which type of adaptive methods to apply.</p>
<h3>Usage</h3>
<p>To successfully apply hp-adaptive methods, we recommend the following workflow: </p><ol>
<li>
<p class="startli">A suitable error estimate is the basis for any kind of adaptive method. Similar to pure grid refinement, we will determine error estimates in the usual way (i.e. <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>) and mark cells for refinement or coarsening (i.e. <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>).</p>
<p class="interli">Calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> at this stage will perform pure grid refinement as expected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Once all refinement and coarsening flags have been distributed on the mesh, we may determine if those qualify for p-adaptive methods. Corresponding functions will set <code>future_fe_indices</code> on top of the refinement and coarsening flags if they fulfil a certain criterion.</p>
<p class="interli">In case of refinement, the superordinate element of the underlying <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> will be assigned as the future finite element. Correspondingly, the subordinate element will be selected for coarsening.</p>
<p class="interli"><a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> will now supply both h- and p-adaptive methods independently.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Right now, there may be cells scheduled for both h- and p-adaptation. If we do not want to impose both methods at once, we need to decide which one to pick for each cell individually and unambiguously. Since grid refinement will be imposed by default and we only determine qualification for p-adaptivity on top, we will always decide in favour of p-adaptive methods.</p>
<p class="interli">Calling <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> will now perform either h- or p-adaptive methods uniquely on each cell.</p>
<p class="endli"></p>
</li>
<li>
Up to this point, each cell knows its destiny in terms of adaptivity. We can now move on to prepare all data structures to be transferred across mesh changes. Previously set refinement and coarsening flags as well as <code>future_fe_indices</code> will be used to update the data accordingly. </li>
</ol>
<p>As an example, a realisation of pure p-adaptive methods would look like the following: </p><div class="fragment"><div class="line"><span class="comment">// step 1: flag cells for refinement or coarsening</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">    hp_dof_handler,</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> (<a class="code" href="namespaceParticles_1_1Generators.html#aa1cd861e3aaf1770ddcddd956cdae5e4">quadrature_points</a>),</div>
<div class="line">    <a class="code" href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">std::map</a>&lt;<a class="code" href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim, Number&gt;</a> *&gt;(),</div>
<div class="line">    <a class="code" href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a>,</div>
<div class="line">    estimated_error_per_cell);</div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">                                                  estimated_error_per_cell,</div>
<div class="line">                                                  top_fraction,</div>
<div class="line">                                                  bottom_fraction);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 2: set future finite element indices on flagged cells</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7fc52cae14b805ecd78d329dbdd03986">hp::Refinement::full_p_adaptivity</a>(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 3: decide whether h- or p-adaptive methods will be supplied</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7dcdcc921a66bb023b4d1ed7c648137c">hp::Refinement::force_p_over_h</a>(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step 4: prepare solutions to be transferred</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">triangulation.execute_coarsening_and_refinement();</div>
</div><!-- fragment --> </div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad0ca178ceaa3fbd70627d23d2adabeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ca178ceaa3fbd70627d23d2adabeeb">&#9670;&nbsp;</a></span>ComparisonFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">hp::Refinement::ComparisonFunction</a> = typedef <a class="el" href="kinsol__0_8txt.html#a8d00284f252cd8059a1f0db88a9bda7b">std::function</a>&lt;<a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>(<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number &amp;, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias that defines the characteristics of a function that can be used as a comparison criterion for deciding whether to perform h- or p-adaptation. Such functions take two numbers as arguments: The first one corresponds to the provided criterion, while the other one conforms to the reference. The result of the comparison will be returned as a boolean. </p>

<p class="definition">Definition at line <a class="el" href="hp_2refinement_8h_source.html#l00087">87</a> of file <a class="el" href="hp_2refinement_8h_source.html">refinement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7fc52cae14b805ecd78d329dbdd03986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc52cae14b805ecd78d329dbdd03986">&#9670;&nbsp;</a></span>full_p_adaptivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::full_p_adaptivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each cell flagged for h-refinement will also be flagged for p-refinement. The same applies to coarsening. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function.</dd></dl>
<p>Setting p-adaptivity flags </p>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00047">47</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a4b763dabdf5f7740a73b0dcc6d3f721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b763dabdf5f7740a73b0dcc6d3f721d">&#9670;&nbsp;</a></span>p_adaptivity_from_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells that have been specifically flagged for p-adaptation via the parameter <code>p_flags</code>. Future finite elements will only be assigned if cells have been flagged for refinement and coarsening beforehand. Each entry of the parameter <code>p_flags</code> needs to correspond to an active cell. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00067">67</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a95de4d68d350f8ea7555441c299d0ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95de4d68d350f8ea7555441c299d0ea5">&#9670;&nbsp;</a></span>p_adaptivity_from_absolute_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_absolute_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>p_refine_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Number&#160;</td>
          <td class="paramname"><em>p_coarsen_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;Number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;Number&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells whose criteria meet a certain absolute threshold. For p-refinement and p-coarsening, two separate thresholds need to provided via parameters <code>p_refine_threshold</code> and <code>p_coarsen_threshold</code>. We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding threshold. Let us be more specific on the default case: We consider a cell for p-refinement if it is flagged for refinement and its criterion is larger than or equal to the corresponding threshold. The same applies for p-coarsening, but the cell's criterion must be lower than or equal to the threshold. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies. Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00111">111</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a54156dbe64e8eda42b2e964c9b1c0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54156dbe64e8eda42b2e964c9b1c0963">&#9670;&nbsp;</a></span>p_adaptivity_from_relative_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_relative_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>p_refine_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>p_coarsen_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;Number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;Number&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells whose criteria meet a certain threshold relative to the overall range of criterion values. The threshold will be determined for refined and coarsened cells separately based on the currently set refinement markers. For each class of cells, we determine the maximal and minimal values of all criteria and determine the threshold by linear interpolation between these limits. Parameters <code>p_refine_fraction</code> and <code>p_refine_coarsen</code> are used as interpolation factors, where <code>0</code> corresponds to the minimal and <code>1</code> to the maximal value. By default, mean values are considered as thresholds. We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding threshold. Let us be more specific on the default case: We consider a cell for p-refinement if it is flagged for refinement and its criterion is larger than or equal to the corresponding threshold. The same applies for p-coarsening, but the cell's criterion must be lower than or equal to the threshold. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies. Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\) . </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function.</dd></dl>
<p>Adapt which finite element to use on cells whose criteria meet a certain threshold relative to the overall range of criterion values.</p>
<p>The threshold will be determined for refined and coarsened cells separately based on the currently set refinement markers. For each class of cells, we determine the maximal and minimal values of all criteria and determine the threshold by linear interpolation between these limits. Parameters <code>p_refine_fraction</code> and <code>p_refine_coarsen</code> are used as interpolation factors, where <code>0</code> corresponds to the minimal and <code>1</code> to the maximal value. By default, mean values are considered as thresholds.</p>
<p>We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding threshold. Let us be more specific on the default case: We consider a cell for p-refinement if it is flagged for refinement and its criterion is larger than or equal to the corresponding threshold. The same applies for p-coarsening, but the cell's criterion must be lower than or equal to the threshold. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies.</p>
<p>Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00150">150</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a6066e056301dd2b9f6c31191c47c7b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6066e056301dd2b9f6c31191c47c7b16">&#9670;&nbsp;</a></span>p_adaptivity_fixed_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_fixed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>p_refine_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>p_coarsen_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;Number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;Number&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on a given fraction of cells. Out of all cells flagged for a certain type of adaptation, be it refinement or coarsening, we will determine a fixed number of cells among this subset that will be flagged for the corresponding p-adaptive variant. For each of both refinement and coarsening subsets, we will determine a threshold based on the provided parameter <code>criteria</code> containing indicators for every active cell. In the default case for refinement, all cells with an indicator larger than or equal to the corresponding threshold will be considered for p-refinement, while for coarsening all cells with an indicator less than or equal to the matching threshold are taken into account. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies. For refinement, the threshold will be associated with the cell that has the <code>p_refine_fraction</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> largest indicator, while it is the cell with the <code>p_refine_coarsen</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> lowest indicator for coarsening. Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\) . </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function.</dd></dl>
<p>Adapt which finite element to use on a given fraction of cells.</p>
<p>Out of all cells flagged for a certain type of adaptation, be it refinement or coarsening, we will determine a fixed number of cells among this subset that will be flagged for the corresponding p-adaptive variant.</p>
<p>For each of both refinement and coarsening subsets, we will determine a threshold based on the provided parameter <code>criteria</code> containing indicators for every active cell. In the default case for refinement, all cells with an indicator larger than or equal to the corresponding threshold will be considered for p-refinement, while for coarsening all cells with an indicator less than or equal to the matching threshold are taken into account. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies.</p>
<p>For refinement, the threshold will be associated with the cell that has the <code>p_refine_fraction</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> largest indicator, while it is the cell with the <code>p_refine_coarsen</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> lowest indicator for coarsening.</p>
<p>Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00247">247</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="aff154ed2b5f28b7eeaf81494d6071b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff154ed2b5f28b7eeaf81494d6071b59">&#9670;&nbsp;</a></span>p_adaptivity_from_regularity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_regularity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>sobolev_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells based on the regularity of the (unknown) analytical solution. With an approximation of the local Sobolev regularity index \(k_K\) , we may assess to which finite element space our local solution on cell \(K\) belongs. Since the regularity index is only an estimate, we won't use it to assign the finite element space directly, but rather consider it as an indicator for adaptation. If a cell is flagged for refinement, we will perform p-refinement once it satisfies \(k_K &gt; p_{K,\text{super}}\) , where \(p_{K,\text{super}}\) is the polynomial degree of the finite element superordinate to the currently active element on cell \(K\) . In case of coarsening, the criterion \(k_K &lt; p_{K,\text{sub}}\) has to be met, with \(p_{K,\text{sub}}\) the degree of the subordinate element. Each entry of the parameter <code>sobolev_indices</code> needs to correspond to an active cell. For more theoretical details see <b>[ainsworth1998hp]</b> . </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function.</dd></dl>
<p>Adapt which finite element to use on cells based on the regularity of the (unknown) analytical solution.</p>
<p>With an approximation of the local Sobolev regularity index \(k_K\), we may assess to which finite element space our local solution on cell \(K\) belongs. Since the regularity index is only an estimate, we won't use it to assign the finite element space directly, but rather consider it as an indicator for adaptation. If a cell is flagged for refinement, we will perform p-refinement once it satisfies \(k_K &gt; p_{K,\text{super}}\), where \(p_{K,\text{super}}\) is the polynomial degree of the finite element superordinate to the currently active element on cell \(K\). In case of coarsening, the criterion \(k_K &lt; p_{K,\text{sub}}\) has to be met, with \(p_{K,\text{sub}}\) the degree of the subordinate element.</p>
<p>Each entry of the parameter <code>sobolev_indices</code> needs to correspond to an active cell.</p>
<p>For more theoretical details see <b>[ainsworth1998hp]</b> .</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00448">448</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a1ca8f3c6d6ef49918329fc7d45d9f7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca8f3c6d6ef49918329fc7d45d9f7db">&#9670;&nbsp;</a></span>p_adaptivity_from_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::<a class="el" href="rtree__0_8txt.html#af516d631e8e6045677c29110e2696833">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on each cell based on how its criterion relates to a reference. We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding reference. Other than functions <a class="el" href="namespacehp_1_1Refinement.html#a95de4d68d350f8ea7555441c299d0ea5">p_adaptivity_from_absolute_threshold()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">p_adaptivity_from_relative_threshold()</a>, compare function objects have to be provided explicitly via the parameters <code>compare_refine</code> and <code>compare_coarsen</code>. Each entry of the parameters <code>criteria</code> and <code>references</code> needs to correspond to an active cell. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00506">506</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a9c96d6a85b38f120b5d7cf68126cded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c96d6a85b38f120b5d7cf68126cded9">&#9670;&nbsp;</a></span>predict_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::predict_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>gamma_p</em> = <code><a class="el" href="solver__cg__0_8txt.html#a557c71e94a2542d697ca3426b8843cd4">std::sqrt</a>(0.4)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>gamma_h</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>gamma_n</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predict how the current <code>error_indicators</code> will adapt after refinement and coarsening were to happen on the provided <code>dof_handler</code>, and write its results to <code>predicted_errors</code>. Each entry of <code>error_indicators</code> and <code>predicted_errors</code> corresponds to an active cell on the underlying <a class="el" href="classTriangulation.html">Triangulation</a>, thus each container has to be of size <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>. The errors are interpreted to be measured in the energy norm; this assumption enters the rate of convergence that is used in the prediction. The \(l_2\) -norm of the output argument <code>predicted_errors</code> corresponds to the predicted global error after adaptation. For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>. For h-adaptation, we expect the local error \(\eta_K\) on cell \(K\) to be proportional to \((h_K)^{p_K}\) in the energy norm, where \(h_K\) denotes the cell diameter and \(p_K\) the polynomial degree of the currently assigned finite element on cell \(K\) . During h-coarsening, the finite elements on siblings may be different, and their parent cell will be assigned to their least dominating finite element that belongs to its most general child. Thus, we will always interpolate on an enclosing finite element space. Additionally assuming that the finite elements on the cells to be coarsened are sufficient to represent the solution correctly (e.g. at least quadratic basis functions for a quadratic solution), we are confident to say that the error will not change by sole interpolation on the larger finite element space. For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>. The assumption of exponential convergence is only valid if both h- and p-adaptive methods are combined in a sense that they are both utilitzed throughout a mesh, but do not have to be applied both on a cell simultaneously. The prediction algorithm is formulated as follows with control parameters <code>gamma_p</code>, <code>gamma_h</code> and <code>gamma_n</code> that may be used to influence prediction for each adaptation type individually. The results for each individual cell are stored in the <code>predicted_errors</code> output argument. </p><table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{h} \, 0.5^{p_{K,\text{future}}} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, (\gamma_\text{h} \, 0.5^{p_{K,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td></tr>
</table>
<p>On basis of the refinement history, we use the predicted error estimates to decide how cells will be adapted in the next adaptation step. Comparing the predicted error from the previous adaptation step to the error estimates of the current step allows us to justify whether our previous choice of adaptation was justified, and lets us decide how to adapt in the next one. We thus have to transfer the predicted error from the old to the adapted mesh. When transferring the predicted error to the adapted mesh, make sure to configure your <a class="el" href="classCellDataTransfer.html">CellDataTransfer</a> object with <a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a069487de103023e142d174c1bb6712fa">AdaptationStrategies::Refinement::l2_norm()</a> as a refinement strategy and <a class="el" href="namespaceAdaptationStrategies_1_1Coarsening.html#ac3b7ed64dc5873912710963c3e879563">AdaptationStrategies::Coarsening::l2_norm()</a> as a coarsening strategy. This ensures that the \(l_2\) -norm of the predict errors is preserved on both meshes. In this context, we assume that the local error on a cell to be h-refined will be divided equally on all of its \(n_{K_c}\) children, whereas local errors on siblings will be summed up on the parent cell in case of h-coarsening. This assumption is often not satisfied in practice: For example, if a cell is at a corner singularity, then the one child cell that ends up closest to the singularity will inherit the majority of the remaining error</p>
<ul>
<li>but this function can not know where the singularity will be, and consequently assumes equal distribution. Incorporating the transfer from the old to the adapted mesh, the complete error prediction algorithm reads as follows: <table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\left( \eta_{K_c,\text{pred}} \right)^2 = n_{K_c}^{-1} \left( \eta_{K_p} \, \gamma_\text{h} \, 0.5^{p_{K_c,\text{future}}} \, \gamma_\text{p}^{(p_{K_c,\text{future}} - p_{K_p})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\left( \eta_{K_p,\text{pred}} \right)^2 = \sum\limits_{K_c} \left( \eta_{K_c} \, (\gamma_\text{h} \, 0.5^{p_{K_p,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K_p,\text{future}} - p_{K_c})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td></tr>
</table>
With these predicted error estimates, we are capable of adapting the finite element on cells based on their refinement history or rather the predicted change of their error estimates. If a cell is flagged for adaptation, we want to perform p-adaptation once the associated error indicators \(\eta_{K}\) on cell \(K\) satisfy \(\eta_{K} &lt; \eta_{K,\text{pred}}\) , where the subscript \(\text{pred}\) denotes the predicted error. This corresponds to our assumption of smoothness being correct, else h-adaptation is applied. We achieve this with the function <a class="el" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference()</a> and a function object <code>std::less&lt;Number&gt;()</code> for both comparator parameters. Also with an alternative strategy, we can determine the fractions of cells to be h- and p-adapted among all cells to be adapted. For this, use <a class="el" href="namespacehp_1_1Refinement.html#a6066e056301dd2b9f6c31191c47c7b16">hp::Refinement::p_adaptivity_fixed_number()</a> with criteria \((\eta_{K,\text{pred}} - \eta_{K})\) . For the very first adaptation step in either case, the user needs to decide whether h- or p-adaptation is supposed to happen. An h-step will be applied with \(\eta_{K,\text{pred}} = 0\) , whereas \(\eta_{K,\text{pred}} = \infty\) ensures a p-step. The latter may be realized with <code>std::numeric_limits::infinity()</code>. The following code snippet demonstrates how to impose hp-adaptivity based on refinement history in an application: <div class="fragment"><div class="line"><span class="comment">// [initialisation...]</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">predicted_error_per_cell[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] = std::numeric_limits&lt;float&gt;::infinity();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [during each refinement step...]</span></div>
<div class="line"><span class="comment">// set h-adaptivity flags</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a>(...);</div>
<div class="line">GridRefinemet::refine_and_coarsen_fixed_{<a class="code" href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a>|fraction}(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set p-adaptivity flags</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference</a>(</div>
<div class="line">hp_dof_handler,</div>
<div class="line">estimated_error_per_cell,</div>
<div class="line">predicted_error_per_cell,</div>
<div class="line">std::less&lt;float&gt;(),</div>
<div class="line">std::less&lt;float&gt;());</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html">hp::Refinement</a>::{choose|force}_p_over_h(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// predict error for the subsequent adaptation</span></div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(</div>
<div class="line">hp_dof_handler,</div>
<div class="line">estimated_error_per_cell,</div>
<div class="line">predicted_error_per_cell);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// perform adaptation</span></div>
<div class="line"><a class="code" href="classCellDataTransfer.html">CellDataTransfer&lt;dim, spacedim, Vector&lt;float&gt;</a>&gt; cell_data_transfer(</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line"><span class="keyword">false</span>,</div>
<div class="line">&amp;AdaptationStrategies::Refinement::l2_norm&lt;dim, spacedim, float&gt;,</div>
<div class="line">&amp;AdaptationStrategies::Coarsening::l2_norm&lt;dim, spacedim, float&gt;);</div>
<div class="line">cell_data_transfer.prepare_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> transferred_errors(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">cell_data_transfer.unpack(predicted_error_per_cell, transferred_errors);</div>
<div class="line">predicted_error_per_cell = std::move(transferred_errors);</div>
</div><!-- fragment --> For more theoretical details see <b>[melenk2001hp]</b> , where the default parameters for this function come from as well, i.e. \(\gamma_\text{p}^2 = 0.4\) , \(\gamma_\text{h}^2 = 4\) , \(\gamma_\text{n}^2 = 1\) . If you are working with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, you need to pay special attention. Here, p4est determines the details of grid refinement, and consequently, it yields more reliable and trustworthy results when we determine the predicted errors during the adaptation process. We can do exactly this by attaching this function to the signal <a class="el" href="structTriangulation_1_1Signals.html#a3e5f60e6ee760066d7b2516eeb4f9d20">Triangulation::Signals::post_p4est_refinement</a>, which is triggered after p4est got refined, but before data is prepared for transfer. <a class="el" href="namespacehp_1_1Refinement.html">Refinement</a> and coarsening flags of the <a class="el" href="classTriangulation.html">Triangulation</a> object need to be matched with the already refined p4est oracle using internal::parallel::distributed::TemporarilyMatchRefineFlags. Thus, a construct like the following is necessary to correctly predict errors in parallel distributed applications. <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_errors;</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.signals.post_p4est_refinement.connect([&amp;]() {</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classparallel_1_1distributed_1_1TemporarilyMatchRefineFlags.html">parallel::distributed::TemporarilyMatchRefineFlags&lt;dim&gt;</a></div>
<div class="line">  refine_modifier(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line">predicted_errors.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(dof_handler,</div>
<div class="line">                              error_indicators,</div>
<div class="line">                              predicted_errors);</div>
<div class="line">});</div>
</div><!-- fragment --> The container <code>predicted_errors</code> then needs to follow the usual <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a> workflow. <dl class="section note"><dt>Note</dt><dd>We want to predict the error by how adaptation will actually happen. Thus, this function needs to be called after <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a>.</dd></dl>
Predict how the current <code>error_indicators</code> will adapt after refinement and coarsening were to happen on the provided <code>dof_handler</code>, and write its results to <code>predicted_errors</code>. Each entry of <code>error_indicators</code> and <code>predicted_errors</code> corresponds to an active cell on the underlying <a class="el" href="classTriangulation.html">Triangulation</a>, thus each container has to be of size <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>. The errors are interpreted to be measured in the energy norm; this assumption enters the rate of convergence that is used in the prediction. The \(l_2\)-norm of the output argument <code>predicted_errors</code> corresponds to the predicted global error after adaptation.</li>
</ul>
<p>For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>.</p>
<p>For h-adaptation, we expect the local error \(\eta_K\) on cell \(K\) to be proportional to \((h_K)^{p_K}\) in the energy norm, where \(h_K\) denotes the cell diameter and \(p_K\) the polynomial degree of the currently assigned finite element on cell \(K\).</p>
<p>During h-coarsening, the finite elements on siblings may be different, and their parent cell will be assigned to their least dominating finite element that belongs to its most general child. Thus, we will always interpolate on an enclosing finite element space. Additionally assuming that the finite elements on the cells to be coarsened are sufficient to represent the solution correctly (e.g. at least quadratic basis functions for a quadratic solution), we are confident to say that the error will not change by sole interpolation on the larger finite element space.</p>
<p>For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>. The assumption of exponential convergence is only valid if both h- and p-adaptive methods are combined in a sense that they are both utilitzed throughout a mesh, but do not have to be applied both on a cell simultaneously.</p>
<p>The prediction algorithm is formulated as follows with control parameters <code>gamma_p</code>, <code>gamma_h</code> and <code>gamma_n</code> that may be used to influence prediction for each adaptation type individually. The results for each individual cell are stored in the <code>predicted_errors</code> output argument. </p><table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{h} \, 0.5^{p_{K,\text{future}}} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, (\gamma_\text{h} \, 0.5^{p_{K,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td></tr>
</table>
<p>On basis of the refinement history, we use the predicted error estimates to decide how cells will be adapted in the next adaptation step. Comparing the predicted error from the previous adaptation step to the error estimates of the current step allows us to justify whether our previous choice of adaptation was justified, and lets us decide how to adapt in the next one.</p>
<p>We thus have to transfer the predicted error from the old to the adapted mesh. When transferring the predicted error to the adapted mesh, make sure to configure your <a class="el" href="classCellDataTransfer.html">CellDataTransfer</a> object with <a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a069487de103023e142d174c1bb6712fa">AdaptationStrategies::Refinement::l2_norm()</a> as a refinement strategy and <a class="el" href="namespaceAdaptationStrategies_1_1Coarsening.html#ac3b7ed64dc5873912710963c3e879563">AdaptationStrategies::Coarsening::l2_norm()</a> as a coarsening strategy. This ensures that the \(l_2\)-norm of the predict errors is preserved on both meshes.</p>
<p>In this context, we assume that the local error on a cell to be h-refined will be divided equally on all of its \(n_{K_c}\) children, whereas local errors on siblings will be summed up on the parent cell in case of h-coarsening. This assumption is often not satisfied in practice: For example, if a cell is at a corner singularity, then the one child cell that ends up closest to the singularity will inherit the majority of the remaining error &ndash; but this function can not know where the singularity will be, and consequently assumes equal distribution.</p>
<p>Incorporating the transfer from the old to the adapted mesh, the complete error prediction algorithm reads as follows: </p><table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\left( \eta_{K_c,\text{pred}} \right)^2 = n_{K_c}^{-1} \left( \eta_{K_p} \, \gamma_\text{h} \, 0.5^{p_{K_c,\text{future}}} \, \gamma_\text{p}^{(p_{K_c,\text{future}} - p_{K_p})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\left( \eta_{K_p,\text{pred}} \right)^2 = \sum\limits_{K_c} \left( \eta_{K_c} \, (\gamma_\text{h} \, 0.5^{p_{K_p,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K_p,\text{future}} - p_{K_c})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td></tr>
</table>
<p>With these predicted error estimates, we are capable of adapting the finite element on cells based on their refinement history or rather the predicted change of their error estimates.</p>
<p>If a cell is flagged for adaptation, we want to perform p-adaptation once the associated error indicators \(\eta_{K}\) on cell \(K\) satisfy \(\eta_{K} &lt; \eta_{K,\text{pred}}\), where the subscript \(\text{pred}\) denotes the predicted error. This corresponds to our assumption of smoothness being correct, else h-adaptation is applied. We achieve this with the function <a class="el" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference()</a> and a function object <code>std::less&lt;Number&gt;()</code> for both comparator parameters.</p>
<p>Also with an alternative strategy, we can determine the fractions of cells to be h- and p-adapted among all cells to be adapted. For this, use <a class="el" href="namespacehp_1_1Refinement.html#a6066e056301dd2b9f6c31191c47c7b16">hp::Refinement::p_adaptivity_fixed_number()</a> with criteria \((\eta_{K,\text{pred}} - \eta_{K})\).</p>
<p>For the very first adaptation step in either case, the user needs to decide whether h- or p-adaptation is supposed to happen. An h-step will be applied with \(\eta_{K,\text{pred}} = 0\), whereas \(\eta_{K,\text{pred}} = \infty\) ensures a p-step. The latter may be realized with <code>std::numeric_limits::infinity()</code>.</p>
<p>The following code snippet demonstrates how to impose hp-adaptivity based on refinement history in an application: </p><div class="fragment"><div class="line"><span class="comment">// [initialisation...]</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  predicted_error_per_cell[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] = std::numeric_limits&lt;float&gt;::infinity();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [during each refinement step...]</span></div>
<div class="line"><span class="comment">// set h-adaptivity flags</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a>(...);</div>
<div class="line">GridRefinemet::refine_and_coarsen_fixed_{<a class="code" href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a>|fraction}(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set p-adaptivity flags</span></div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference</a>(</div>
<div class="line">  hp_dof_handler,</div>
<div class="line">  estimated_error_per_cell,</div>
<div class="line">  predicted_error_per_cell,</div>
<div class="line">  std::less&lt;float&gt;(),</div>
<div class="line">  std::less&lt;float&gt;());</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html">hp::Refinement</a>::{choose|force}_p_over_h(hp_dof_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// predict error for the subsequent adaptation</span></div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(</div>
<div class="line">  hp_dof_handler,</div>
<div class="line">  estimated_error_per_cell,</div>
<div class="line">  predicted_error_per_cell);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// perform adaptation</span></div>
<div class="line"><a class="code" href="classCellDataTransfer.html">CellDataTransfer&lt;dim, spacedim, Vector&lt;float&gt;</a>&gt; cell_data_transfer(</div>
<div class="line">  <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">  <span class="keyword">false</span>,</div>
<div class="line">  &amp;AdaptationStrategies::Refinement::l2_norm&lt;dim, spacedim, float&gt;,</div>
<div class="line">  &amp;AdaptationStrategies::Coarsening::l2_norm&lt;dim, spacedim, float&gt;);</div>
<div class="line">cell_data_transfer.prepare_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> transferred_errors(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">cell_data_transfer.unpack(predicted_error_per_cell, transferred_errors);</div>
<div class="line">predicted_error_per_cell = std::move(transferred_errors);</div>
</div><!-- fragment --><p>For more theoretical details see <b>[melenk2001hp]</b> , where the default parameters for this function come from as well, i.e. \(\gamma_\text{p}^2 = 0.4\), \(\gamma_\text{h}^2 = 4\), \(\gamma_\text{n}^2 = 1\).</p>
<p>If you are working with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, you need to pay special attention. Here, p4est determines the details of grid refinement, and consequently, it yields more reliable and trustworthy results when we determine the predicted errors during the adaptation process. We can do exactly this by attaching this function to the signal <a class="el" href="structTriangulation_1_1Signals.html#a3e5f60e6ee760066d7b2516eeb4f9d20">Triangulation::Signals::post_p4est_refinement</a>, which is triggered after p4est got refined, but before data is prepared for transfer. <a class="el" href="namespacehp_1_1Refinement.html">Refinement</a> and coarsening flags of the <a class="el" href="classTriangulation.html">Triangulation</a> object need to be matched with the already refined p4est oracle using internal::parallel::distributed::TemporarilyMatchRefineFlags. Thus, a construct like the following is necessary to correctly predict errors in parallel distributed applications. </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_errors;</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.signals.post_p4est_refinement.connect([&amp;]() {</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classparallel_1_1distributed_1_1TemporarilyMatchRefineFlags.html">parallel::distributed::TemporarilyMatchRefineFlags&lt;dim&gt;</a></div>
<div class="line">    refine_modifier(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>);</div>
<div class="line">  predicted_errors.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells());</div>
<div class="line">  <a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(dof_handler,</div>
<div class="line">                                error_indicators,</div>
<div class="line">                                predicted_errors);</div>
<div class="line">});</div>
</div><!-- fragment --><p> The container <code>predicted_errors</code> then needs to follow the usual <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a> workflow.</p>
<dl class="section note"><dt>Note</dt><dd>We want to predict the error by how adaptation will actually happen. Thus, this function needs to be called after <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a>.</dd></dl>
<p>Error prediction </p>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00549">549</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a7dcdcc921a66bb023b4d1ed7c648137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdcc921a66bb023b4d1ed7c648137c">&#9670;&nbsp;</a></span>force_p_over_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::force_p_over_h </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose p-adaptivity over h-adaptivity in any case. Removes all refine and coarsen flags on cells that have a <code>future_fe_index</code> assigned. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function.</dd></dl>
<p>Decide between h- and p-adaptivity </p>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00668">668</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a4890d9eae896d749b103c8eec9c2029d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4890d9eae896d749b103c8eec9c2029d">&#9670;&nbsp;</a></span>choose_p_over_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::choose_p_over_h </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose p-adaptivity over h-adaptivity whenever it is invoked on all related cells. In case of refinement, information about finite elements will be inherited. Thus we will prefer p-refinement over h-refinement whenever desired, i.e. clear the refine flag and supply a corresponding <code>future_fe_index</code>. However for coarsening, we follow a different approach. Flagging a cell for h-coarsening does not ultimately mean that it will be coarsened. Only if a cell and all of its siblings are flagged, they will be merged into their parent cell. If we consider p-coarsening on top, we must decide for all siblings together how they will be coarsened. We distinguish between three different cases: </p><ol>
<li>
Not all siblings flagged for coarsening: p-coarsening. <br  />
 We keep the <code>future_fe_indices</code> and clear the coarsen flags on all siblings. </li>
<li>
All siblings flagged for coarsening, but not all for p-adaptation: h-coarsening. <br  />
 We keep the coarsen flags and clear all <code>future_fe_indices</code> on all siblings. </li>
<li>
All siblings flagged for coarsening and p-adaptation: p-coarsening. <br  />
 We keep the <code>future_fe_indices</code> and clear the coarsen flags on all siblings. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> will clean up all h-coarsening flags if they are not shared among all siblings. In the hp-case, we need to bring forward this decision: If the cell will not be coarsened, but qualifies for p-adaptivity, we have to set all flags accordingly. So this function anticipates the decision that <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> would have made later on. </dd>
<dd>
<a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00690">690</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
<a id="a33d9d552f696d578da30dc9a83048670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9d552f696d578da30dc9a83048670">&#9670;&nbsp;</a></span>limit_p_level_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> hp::Refinement::limit_p_level_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; <a class="el" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>, <a class="el" href="fe__simplex__p__bubbles__0_8txt.html#a5cf3dab3f4c82260e6fb738524f8fbe2">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>max_difference</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>contains_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit p-level differences between neighboring cells. Essentially does to future FE indices what <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> does to refinement flags. In detail, this function limits the level difference of neighboring cells and thus smoothes the overall function space. Future FE indices will be raised (and never lowered) so that the level difference to neighboring cells is never larger than <code>max_difference</code>. Multiple FE hierarchies might have been registered via <a class="el" href="classhp_1_1FECollection.html#a8ae7823f04f51f2daaf0b770a151b1b1">hp::FECollection::set_hierarchy()</a>. This function operates on only one hierarchy, namely the one that contains the FE index <code>contains_fe_index</code>. Cells with future FE indices that are not part of the corresponding hierarchy will be ignored. The function can optionally be called before performing adaptation with <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>. It is not necessary to call this function, nor will it be automatically invoked in any part of the library (contrary to its <a class="el" href="classTriangulation.html">Triangulation</a> counterpart). On cells that will be h-coarsened, we enforce the difference criterion as if it is already a parent cell. That means, we set the level of all siblings to the highest one among them. In that case, all sibling cells need to have the h-coarsenening flags set terminally via <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement()</a> beforehand. Otherwise an assertion will be triggered. Returns whether any future FE indices have been changed by this function.</p>
<p>Optimize p-level distribution </p>

<p class="definition">Definition at line <a class="el" href="refinement_8cc_source.html#l00804">804</a> of file <a class="el" href="refinement_8cc_source.html">refinement.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="anewton__0_8txt_html_af4dc1cb00f59a52e48df46a4c205a8e6"><div class="ttname"><a href="newton__0_8txt.html#af4dc1cb00f59a52e48df46a4c205a8e6">number</a></div><div class="ttdeci">*Operator class performing Newton s iteration with standard step size control and adaptive matrix generation This class performs a Newton iteration up to convergence determined by control If after an update the norm of the residual has become larger then step size control is activated and the update is subsequently divided by two until the residual actually becomes depending on the tends to be this method applies an adaptive reassembling strategy Only if the reduction factor for the residual is more than receiving the applications computing the residual and solving the linear respectively **Declare the parameters applicable to Newton s method **Read the parameters in the ParameterHandler **Initialize the pointer data_out for debugging **The actual Newton iteration The initial value is in&lt; tt &gt; which also contains the result after convergence Values in&lt; tt &gt; in&lt;/tt &gt; are not used by but will be handed down to the objects **Set the maximal residual reduction allowed without triggering assembling in the next step Return the previous value **Control object for the Newton iteration **The indicating that the matrix must be assembled anew upon start **A flag used to decide how many stepsize iteration should be made Default is the original value of Enter zero here to turn off stepsize control *Controlled by&lt; tt &gt; Stepsize iterations&lt;/tt &gt; in parameter file **Threshold for re assembling matrix If the quotient of two consecutive residuals is smaller than this the system matrix is not assembled in this step *This parameter should be adjusted to the residual gain of the inner solver The default values is resulting in reassembling in every Newton step **Print update and updated solution after each step into file&lt; tt &gt; Newton_NNN&lt;/tt &gt; **Write debug output to[2.x.3] the higher the number</div><div class="ttdef"><b>Definition:</b> <a href="newton__0_8txt_source.html#l00034">newton_0.txt:34</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="aclassCellDataTransfer_html"><div class="ttname"><a href="classCellDataTransfer.html">CellDataTransfer</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2cell__data__transfer_8h_source.html#l00108">cell_data_transfer.h:108</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a7dcdcc921a66bb023b4d1ed7c648137c"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a7dcdcc921a66bb023b4d1ed7c648137c">hp::Refinement::force_p_over_h</a></div><div class="ttdeci">void force_p_over_h(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00668">refinement.cc:668</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_ac2b339f054fd752a401e197097db8cfe"><div class="ttname"><a href="distributed__0_8txt.html#ac2b339f054fd752a401e197097db8cfe">solution</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire or solution</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="anamespaceParticles_1_1Generators_html_aa1cd861e3aaf1770ddcddd956cdae5e4"><div class="ttname"><a href="namespaceParticles_1_1Generators.html#aa1cd861e3aaf1770ddcddd956cdae5e4">Particles::Generators::quadrature_points</a></div><div class="ttdeci">void quadrature_points(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Quadrature&lt; dim &gt; &amp;quadrature, const std::vector&lt; std::vector&lt; BoundingBox&lt; spacedim &gt;&gt;&gt; &amp;global_bounding_boxes, ParticleHandler&lt; dim, spacedim &gt; &amp;particle_handler, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()), const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;properties={})</div><div class="ttdef"><b>Definition:</b> <a href="generators_8cc_source.html#l00451">generators.cc:451</a></div></div>
<div class="ttc" id="aclassVector_html_ac4a4dbef7dd65ef8ad35ae56b57d7c05"><div class="ttname"><a href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">Vector::reinit</a></div><div class="ttdeci">virtual void reinit(const size_type N, const bool omit_zeroing_entries=false)</div></div>
<div class="ttc" id="anamespacetypes_html_aaf4eb6ec214fa642dfd956f11a9cd2d7"><div class="ttname"><a href="namespacetypes.html#aaf4eb6ec214fa642dfd956f11a9cd2d7">types::boundary_id</a></div><div class="ttdeci">unsigned int boundary_id</div><div class="ttdef"><b>Definition:</b> <a href="base_2types_8h_source.html#l00117">types.h:117</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a9c96d6a85b38f120b5d7cf68126cded9"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a></div><div class="ttdeci">void predict_error(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const Vector&lt; Number &gt; &amp;error_indicators, Vector&lt; Number &gt; &amp;predicted_errors, const double gamma_p=std::sqrt(0.4), const double gamma_h=2., const double gamma_n=1.)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00549">refinement.cc:549</a></div></div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="amapping__fe__0_8txt_html_a0af9c36aca1d2fa34a8615b4521ad4de"><div class="ttname"><a href="mapping__fe__0_8txt.html#a0af9c36aca1d2fa34a8615b4521ad4de">map</a></div><div class="ttdeci">where is the first fundamental form of the map</div><div class="ttdef"><b>Definition:</b> <a href="mapping__fe__0_8txt_source.html#l00084">mapping_fe_0.txt:84</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a1ca8f3c6d6ef49918329fc7d45d9f7db"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference</a></div><div class="ttdeci">void p_adaptivity_from_reference(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const Vector&lt; Number &gt; &amp;criteria, const Vector&lt; Number &gt; &amp;references, const ComparisonFunction&lt; typename identity&lt; Number &gt;::type &gt; &amp;compare_refine, const ComparisonFunction&lt; typename identity&lt; Number &gt;::type &gt; &amp;compare_coarsen)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00506">refinement.cc:506</a></div></div>
<div class="ttc" id="anamespaceGridRefinement_html_ae90dc87c4db158b8d01f6d564ac614e5"><div class="ttname"><a href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max(), const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00390">grid_refinement.cc:390</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html"><div class="ttname"><a href="namespacehp_1_1Refinement.html">hp::Refinement</a></div><div class="ttdef"><b>Definition:</b> <a href="hp_2refinement_8h_source.html#l00074">refinement.h:74</a></div></div>
<div class="ttc" id="anamespacehp_1_1Refinement_html_a7fc52cae14b805ecd78d329dbdd03986"><div class="ttname"><a href="namespacehp_1_1Refinement.html#a7fc52cae14b805ecd78d329dbdd03986">hp::Refinement::full_p_adaptivity</a></div><div class="ttdeci">void full_p_adaptivity(const ::DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler)</div><div class="ttdef"><b>Definition:</b> <a href="refinement_8cc_source.html#l00047">refinement.cc:47</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function_8h_source.html#l00140">function.h:140</a></div></div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1TemporarilyMatchRefineFlags_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1TemporarilyMatchRefineFlags.html">parallel::distributed::TemporarilyMatchRefineFlags</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2tria_8h_source.html#l01017">tria.h:1017</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; float &gt;</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
