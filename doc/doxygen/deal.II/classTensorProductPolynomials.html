<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTensorProductPolynomials.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TensorProductPolynomials&lt; dim, PolynomialType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTensorProductPolynomials-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TensorProductPolynomials&lt; dim, PolynomialType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2tensor__product__polynomials_8h_source.html">deal.II/base/tensor_product_polynomials.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TensorProductPolynomials&lt; dim, PolynomialType &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplParams" colspan="2">template&lt;class Pol &gt; </td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ad84eaac16a38d48f9eb163590d895fd2">TensorProductPolynomials</a> (const std::vector&lt; Pol &gt; &amp;pols)</td></tr>
<tr class="separator:ad84eaac16a38d48f9eb163590d895fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075c0549687e1f65687e73b07e6b7a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a075c0549687e1f65687e73b07e6b7a35">output_indices</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a075c0549687e1f65687e73b07e6b7a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a8db386caf8f98a7c8b2850b1dab5aa00">set_numbering</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumber)</td></tr>
<tr class="separator:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a2179c77d357b24c7b09a87c1a73c2c85">get_numbering</a> () const</td></tr>
<tr class="separator:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160753ef67378b6dca667015efa338b1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a160753ef67378b6dca667015efa338b1">get_numbering_inverse</a> () const</td></tr>
<tr class="separator:a160753ef67378b6dca667015efa338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;unit_point, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;grad_grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;third_derivatives, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;fourth_derivatives) const override</td></tr>
<tr class="separator:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplParams" colspan="2">template&lt;int order&gt; </td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a20b4938f22468df56790687b5fe8389c">compute_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a20b4938f22468df56790687b5fe8389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a7f38a12b70f4692561cf9b62ba67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a356a7f38a12b70f4692561cf9b62ba67">compute_1st_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a356a7f38a12b70f4692561cf9b62ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ab92d8b51ede2f37b9af2b80a4691404f">compute_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a334e6b9b143e22fa64ef5d73bfe0fa4b">compute_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4cf2c9f38d15c08f3a849021f5e474f1">compute_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac821e3766c21b0fe5e32d7d9a55ac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a3ac821e3766c21b0fe5e32d7d9a55ac3">compute_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a3ac821e3766c21b0fe5e32d7d9a55ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93aa873ad6d4a83ba1e3ab2a43ca7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#aa93aa873ad6d4a83ba1e3ab2a43ca7a2">compute_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:aa93aa873ad6d4a83ba1e3ab2a43ca7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21a282efdbd50cb314d71ca4f7051a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#aae21a282efdbd50cb314d71ca4f7051a">name</a> () const override</td></tr>
<tr class="separator:aae21a282efdbd50cb314d71ca4f7051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec967d04a42f728b9c0f32efadf4f47"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a3ec967d04a42f728b9c0f32efadf4f47">clone</a> () const override</td></tr>
<tr class="separator:a3ec967d04a42f728b9c0f32efadf4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d0a5bf5b373b508703f802b8ecc2ef"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a15d0a5bf5b373b508703f802b8ecc2ef">memory_consumption</a> () const override</td></tr>
<tr class="separator:a15d0a5bf5b373b508703f802b8ecc2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb9561ec86f66d96925d68d65056e14"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PolynomialType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a5fb9561ec86f66d96925d68d65056e14">get_underlying_polynomials</a> () const</td></tr>
<tr class="separator:a5fb9561ec86f66d96925d68d65056e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplParams" colspan="2">template&lt;class Pol &gt; </td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ad84eaac16a38d48f9eb163590d895fd2">TensorProductPolynomials</a> (const std::vector&lt; Pol &gt; &amp;pols)</td></tr>
<tr class="separator:ad84eaac16a38d48f9eb163590d895fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075c0549687e1f65687e73b07e6b7a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a075c0549687e1f65687e73b07e6b7a35">output_indices</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a075c0549687e1f65687e73b07e6b7a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a8db386caf8f98a7c8b2850b1dab5aa00">set_numbering</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumber)</td></tr>
<tr class="separator:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a2179c77d357b24c7b09a87c1a73c2c85">get_numbering</a> () const</td></tr>
<tr class="separator:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160753ef67378b6dca667015efa338b1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a160753ef67378b6dca667015efa338b1">get_numbering_inverse</a> () const</td></tr>
<tr class="separator:a160753ef67378b6dca667015efa338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;unit_point, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;grad_grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;third_derivatives, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;fourth_derivatives) const override</td></tr>
<tr class="separator:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplParams" colspan="2">template&lt;int order&gt; </td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a20b4938f22468df56790687b5fe8389c">compute_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a20b4938f22468df56790687b5fe8389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a7f38a12b70f4692561cf9b62ba67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a356a7f38a12b70f4692561cf9b62ba67">compute_1st_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a356a7f38a12b70f4692561cf9b62ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ab92d8b51ede2f37b9af2b80a4691404f">compute_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a334e6b9b143e22fa64ef5d73bfe0fa4b">compute_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4cf2c9f38d15c08f3a849021f5e474f1">compute_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc9f190c744a25c59b8f824277c333b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a0cc9f190c744a25c59b8f824277c333b">compute_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a0cc9f190c744a25c59b8f824277c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c3a06f64a6c606da65aeb6878114fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a39c3a06f64a6c606da65aeb6878114fa">compute_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a39c3a06f64a6c606da65aeb6878114fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21a282efdbd50cb314d71ca4f7051a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#aae21a282efdbd50cb314d71ca4f7051a">name</a> () const override</td></tr>
<tr class="separator:aae21a282efdbd50cb314d71ca4f7051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda00ed5c7fabf38c73f9d3f81a45c9a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#acda00ed5c7fabf38c73f9d3f81a45c9a">clone</a> () const override</td></tr>
<tr class="separator:acda00ed5c7fabf38c73f9d3f81a45c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795944fd345cbe8d4e01c01fc9e92f39"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a795944fd345cbe8d4e01c01fc9e92f39">memory_consumption</a> () const override</td></tr>
<tr class="separator:a795944fd345cbe8d4e01c01fc9e92f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11819bc0196042fc5ed1b9549422851"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PolynomialType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ae11819bc0196042fc5ed1b9549422851">get_underlying_polynomials</a> () const</td></tr>
<tr class="separator:ae11819bc0196042fc5ed1b9549422851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplParams" colspan="2">template&lt;class Pol &gt; </td></tr>
<tr class="memitem:ad84eaac16a38d48f9eb163590d895fd2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ad84eaac16a38d48f9eb163590d895fd2">TensorProductPolynomials</a> (const std::vector&lt; Pol &gt; &amp;pols)</td></tr>
<tr class="separator:ad84eaac16a38d48f9eb163590d895fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075c0549687e1f65687e73b07e6b7a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a075c0549687e1f65687e73b07e6b7a35">output_indices</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a075c0549687e1f65687e73b07e6b7a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a8db386caf8f98a7c8b2850b1dab5aa00">set_numbering</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumber)</td></tr>
<tr class="separator:a8db386caf8f98a7c8b2850b1dab5aa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a2179c77d357b24c7b09a87c1a73c2c85">get_numbering</a> () const</td></tr>
<tr class="separator:a2179c77d357b24c7b09a87c1a73c2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160753ef67378b6dca667015efa338b1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a160753ef67378b6dca667015efa338b1">get_numbering_inverse</a> () const</td></tr>
<tr class="separator:a160753ef67378b6dca667015efa338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;unit_point, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;grad_grads, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;third_derivatives, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;fourth_derivatives) const override</td></tr>
<tr class="separator:a06c5ffbc3623ee5bba80b400ca67c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a12469a186dd9c223c6ac7f8b72d1458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplParams" colspan="2">template&lt;int order&gt; </td></tr>
<tr class="memitem:a20b4938f22468df56790687b5fe8389c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a20b4938f22468df56790687b5fe8389c">compute_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a20b4938f22468df56790687b5fe8389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a7f38a12b70f4692561cf9b62ba67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a356a7f38a12b70f4692561cf9b62ba67">compute_1st_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a356a7f38a12b70f4692561cf9b62ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ab92d8b51ede2f37b9af2b80a4691404f">compute_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ab92d8b51ede2f37b9af2b80a4691404f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a334e6b9b143e22fa64ef5d73bfe0fa4b">compute_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a334e6b9b143e22fa64ef5d73bfe0fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4cf2c9f38d15c08f3a849021f5e474f1">compute_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a4cf2c9f38d15c08f3a849021f5e474f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc9f190c744a25c59b8f824277c333b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a0cc9f190c744a25c59b8f824277c333b">compute_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a0cc9f190c744a25c59b8f824277c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c3a06f64a6c606da65aeb6878114fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a39c3a06f64a6c606da65aeb6878114fa">compute_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a39c3a06f64a6c606da65aeb6878114fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21a282efdbd50cb314d71ca4f7051a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#aae21a282efdbd50cb314d71ca4f7051a">name</a> () const override</td></tr>
<tr class="separator:aae21a282efdbd50cb314d71ca4f7051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda00ed5c7fabf38c73f9d3f81a45c9a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#acda00ed5c7fabf38c73f9d3f81a45c9a">clone</a> () const override</td></tr>
<tr class="separator:acda00ed5c7fabf38c73f9d3f81a45c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795944fd345cbe8d4e01c01fc9e92f39"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a795944fd345cbe8d4e01c01fc9e92f39">memory_consumption</a> () const override</td></tr>
<tr class="separator:a795944fd345cbe8d4e01c01fc9e92f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11819bc0196042fc5ed1b9549422851"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PolynomialType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ae11819bc0196042fc5ed1b9549422851">get_underlying_polynomials</a> () const</td></tr>
<tr class="separator:ae11819bc0196042fc5ed1b9549422851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0d082a8891da5ca7b7f899b4b191ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a7f0d082a8891da5ca7b7f899b4b191ca">output_indices</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:a7f0d082a8891da5ca7b7f899b4b191ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51bcd9a62db6b4a68a060442275a967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ad51bcd9a62db6b4a68a060442275a967">set_numbering</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)</td></tr>
<tr class="separator:ad51bcd9a62db6b4a68a060442275a967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f28a449d55860f145076fe7e4a70f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a5f28a449d55860f145076fe7e4a70f39">compute_value</a> (const unsigned <a class="el" href="classint.html">int</a>, const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;) const</td></tr>
<tr class="separator:a5f28a449d55860f145076fe7e4a70f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4639b3c22c7014e4a7350f71facdf12a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4639b3c22c7014e4a7350f71facdf12a">compute_grad</a> (const unsigned <a class="el" href="classint.html">int</a>, const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;) const</td></tr>
<tr class="separator:a4639b3c22c7014e4a7350f71facdf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2238eef68605f7953460f8a49419980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ab2238eef68605f7953460f8a49419980">compute_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a>, const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;) const</td></tr>
<tr class="separator:ab2238eef68605f7953460f8a49419980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106478d2b4c888b56a32f0c12a294cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a5106478d2b4c888b56a32f0c12a294cd">evaluate</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 0 &gt;&gt; &amp;, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 0 &gt;&gt; &amp;, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, 0 &gt;&gt; &amp;, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, 0 &gt;&gt; &amp;) const</td></tr>
<tr class="separator:a5106478d2b4c888b56a32f0c12a294cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4a31514cf94b170f48daa0c052e6670f"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4a31514cf94b170f48daa0c052e6670f">dimension</a> = dim</td></tr>
<tr class="separator:a4a31514cf94b170f48daa0c052e6670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a0c5f45fc9847ec3466636578ad9c5b3e">compute_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;indices) const</td></tr>
<tr class="separator:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a0c5f45fc9847ec3466636578ad9c5b3e">compute_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;indices) const</td></tr>
<tr class="separator:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a0c5f45fc9847ec3466636578ad9c5b3e">compute_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;indices) const</td></tr>
<tr class="separator:a0c5f45fc9847ec3466636578ad9c5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab237ea935bbea2a48f0733d78cebd5eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#ab237ea935bbea2a48f0733d78cebd5eb">compute_index</a> (const unsigned <a class="el" href="classint.html">int</a>, std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 0 &gt; &amp;) const</td></tr>
<tr class="separator:ab237ea935bbea2a48f0733d78cebd5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9708cd033eaaadc177af496e9de3837a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PolynomialType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a9708cd033eaaadc177af496e9de3837a">polynomials</a></td></tr>
<tr class="separator:a9708cd033eaaadc177af496e9de3837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4393595258041aad27379fb14be02c5b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a4393595258041aad27379fb14be02c5b">index_map</a></td></tr>
<tr class="separator:a4393595258041aad27379fb14be02c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1c9bd03a8216fb3a67b2ac3421c611"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#abc1c9bd03a8216fb3a67b2ac3421c611">index_map_inverse</a></td></tr>
<tr class="separator:abc1c9bd03a8216fb3a67b2ac3421c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9eabe2340a93dbb84404b06858dcc047"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#a9eabe2340a93dbb84404b06858dcc047">TensorProductPolynomialsBubbles&lt; dim &gt;</a></td></tr>
<tr class="separator:a9eabe2340a93dbb84404b06858dcc047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7560ba6d45833e3c99dc1ee7833ec35"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductPolynomials.html#aa7560ba6d45833e3c99dc1ee7833ec35">TensorProductPolynomialsConst&lt; dim &gt;</a></td></tr>
<tr class="separator:aa7560ba6d45833e3c99dc1ee7833ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename PolynomialType = Polynomials::Polynomial&lt;double&gt;&gt;<br />
class TensorProductPolynomials&lt; dim, PolynomialType &gt;</h3>

<p><a class="el" href="classTensor.html">Tensor</a> product of given polynomials. Given a vector of <em>n</em> one-dimensional polynomials <em>P<sub>1</sub></em> to <em>P<sub>n</sub></em>, this class generates <em>n<sup>dim</sup></em> polynomials of the form <em>Q<sub>ijk</sub>(x,y,z) = P<sub>i</sub>(x)P<sub>j</sub>(y)P<sub>k</sub>(z)</em>. If the base polynomials are mutually orthogonal on the interval [-1,1] or [0,1], then the tensor product polynomials are orthogonal on [-1,1]<sup>dim</sup> or [0,1]<sup>dim</sup>, respectively. Indexing is as follows: the order of dim-dimensional polynomials is x-coordinates running fastest, then y-coordinate, etc. The first few polynomials are thus <em>P<sub>1</sub>(x)P<sub>1</sub>(y), P<sub>2</sub>(x)P<sub>1</sub>(y), P<sub>3</sub>(x)P<sub>1</sub>(y), ..., P<sub>1</sub>(x)P<sub>2</sub>(y), P<sub>2</sub>(x)P<sub>2</sub>(y), P<sub>3</sub>(x)P<sub>2</sub>(y), ...</em> and likewise in 3d. The <a class="el" href="classTensorProductPolynomials.html#a075c0549687e1f65687e73b07e6b7a35">output_indices()</a> function prints the ordering of the dim-dimensional polynomials, i.e. for each polynomial in the polynomial space it gives the indices i,j,k of the one-dimensional polynomials in x,y and z direction. The ordering of the dim-dimensional polynomials can be changed by using the <a class="el" href="classTensorProductPolynomials.html#a8db386caf8f98a7c8b2850b1dab5aa00">set_numbering()</a> function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolynomialType</td><td>A class that satisfies the required interface for computing tensor products. Typical choices for this template argument are <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a> and <a class="el" href="classPolynomials_1_1PiecewisePolynomial.html">Polynomials::PiecewisePolynomial</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00074">74</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad84eaac16a38d48f9eb163590d895fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84eaac16a38d48f9eb163590d895fd2">&#9670;&nbsp;</a></span>TensorProductPolynomials() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Pol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::<a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pol &gt; &amp;&#160;</td>
          <td class="paramname"><em>pols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. <code>pols</code> is a vector of objects that should be derived or otherwise convertible to one-dimensional polynomial objects of type <code>PolynomialType</code> (template argument of class). It will be copied element by element into a protected member variable. </p>

</div>
</div>
<a id="ad84eaac16a38d48f9eb163590d895fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84eaac16a38d48f9eb163590d895fd2">&#9670;&nbsp;</a></span>TensorProductPolynomials() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Pol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::<a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pol &gt; &amp;&#160;</td>
          <td class="paramname"><em>pols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. <code>pols</code> is a vector of objects that should be derived or otherwise convertible to one-dimensional polynomial objects of type <code>PolynomialType</code> (template argument of class). It will be copied element by element into a protected member variable. </p>

</div>
</div>
<a id="ad84eaac16a38d48f9eb163590d895fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84eaac16a38d48f9eb163590d895fd2">&#9670;&nbsp;</a></span>TensorProductPolynomials() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Pol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::<a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pol &gt; &amp;&#160;</td>
          <td class="paramname"><em>pols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. <code>pols</code> is a vector of objects that should be derived or otherwise convertible to one-dimensional polynomial objects of type <code>PolynomialType</code> (template argument of class). It will be copied element by element into a protected member variable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a075c0549687e1f65687e73b07e6b7a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075c0549687e1f65687e73b07e6b7a35">&#9670;&nbsp;</a></span>output_indices() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::output_indices </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the list of the indices to <code>out</code>. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00114">114</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a8db386caf8f98a7c8b2850b1dab5aa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db386caf8f98a7c8b2850b1dab5aa00">&#9670;&nbsp;</a></span>set_numbering() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::set_numbering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ordering of the polynomials. Requires <code>renumber.size()==n()</code>. Stores a copy of <code>renumber</code>. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00143">143</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a2179c77d357b24c7b09a87c1a73c2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2179c77d357b24c7b09a87c1a73c2c85">&#9670;&nbsp;</a></span>get_numbering() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the renumber vector. </p>

</div>
</div>
<a id="a160753ef67378b6dca667015efa338b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160753ef67378b6dca667015efa338b1">&#9670;&nbsp;</a></span>get_numbering_inverse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering_inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the inverse renumber vector. </p>

</div>
</div>
<a id="a06c5ffbc3623ee5bba80b400ca67c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c5ffbc3623ee5bba80b400ca67c965">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fourth_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value and the first and second derivatives of each tensor product polynomial at <code>unit_point</code>. The size of the vectors must either be equal 0 or equal n(). In the first case, the function will not compute these values. If you need values or derivatives of all tensor product polynomials then use this function, rather than using any of the <a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value()</a>, <a class="el" href="classTensorProductPolynomials.html#a3ac821e3766c21b0fe5e32d7d9a55ac3">compute_grad()</a> or <a class="el" href="classTensorProductPolynomials.html#aa93aa873ad6d4a83ba1e3ab2a43ca7a2">compute_grad_grad()</a> functions, see below, in a loop over all tensor product polynomials. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00310">310</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a12469a186dd9c223c6ac7f8b72d1458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12469a186dd9c223c6ac7f8b72d1458b">&#9670;&nbsp;</a></span>compute_value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each point value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function with <code>values.size()==</code>n() to get the point values of all tensor polynomials all at once and in a much more efficient way. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00169">169</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a20b4938f22468df56790687b5fe8389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b4938f22468df56790687b5fe8389c">&#9670;&nbsp;</a></span>compute_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;order, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the <code>order</code>th derivative of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with the size of the appropriate parameter set to n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>The derivative order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356a7f38a12b70f4692561cf9b62ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a7f38a12b70f4692561cf9b62ba67">&#9670;&nbsp;</a></span>compute_1st_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_1st_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the first derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="ab92d8b51ede2f37b9af2b80a4691404f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92d8b51ede2f37b9af2b80a4691404f">&#9670;&nbsp;</a></span>compute_2nd_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the second derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a334e6b9b143e22fa64ef5d73bfe0fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334e6b9b143e22fa64ef5d73bfe0fa4b">&#9670;&nbsp;</a></span>compute_3rd_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the third derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a4cf2c9f38d15c08f3a849021f5e474f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf2c9f38d15c08f3a849021f5e474f1">&#9670;&nbsp;</a></span>compute_4th_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the fourth derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a3ac821e3766c21b0fe5e32d7d9a55ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac821e3766c21b0fe5e32d7d9a55ac3">&#9670;&nbsp;</a></span>compute_grad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the grad of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00203">203</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="aa93aa873ad6d4a83ba1e3ab2a43ca7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93aa873ad6d4a83ba1e3ab2a43ca7a2">&#9670;&nbsp;</a></span>compute_grad_grad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second derivative (grad_grad) of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grad_grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00254">254</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="aae21a282efdbd50cb314d71ca4f7051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21a282efdbd50cb314d71ca4f7051a">&#9670;&nbsp;</a></span>name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the name of the space, which is <code><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a></code>. </p>

</div>
</div>
<a id="a3ec967d04a42f728b9c0f32efadf4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec967d04a42f728b9c0f32efadf4f47">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt; dim &gt; &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::clone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>A sort of virtual copy constructor, this function returns a copy of the polynomial space object. Derived classes need to override the function here in this base class and return an object of the same type as the derived class. Some places in the library, for example the constructors of <a class="el" href="classFE__Poly.html">FE_Poly</a>, need to make copies of polynomial spaces without knowing their exact type. They do so through this function. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00489">489</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a15d0a5bf5b373b508703f802b8ecc2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d0a5bf5b373b508703f802b8ecc2ef">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate (in bytes) for the memory consumption of this object. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00498">498</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a5fb9561ec86f66d96925d68d65056e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb9561ec86f66d96925d68d65056e14">&#9670;&nbsp;</a></span>get_underlying_polynomials() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PolynomialType &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_underlying_polynomials</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a copy of the underlying one-dimensional polynomials given to the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00509">509</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a0c5f45fc9847ec3466636578ad9c5b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5f45fc9847ec3466636578ad9c5b3e">&#9670;&nbsp;</a></span>compute_index() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each tensor product polynomial <em>i</em> is a product of one-dimensional polynomials in each space direction. Compute the indices of these one- dimensional polynomials for each space direction, given the index <em>i</em>. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00086">86</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a075c0549687e1f65687e73b07e6b7a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075c0549687e1f65687e73b07e6b7a35">&#9670;&nbsp;</a></span>output_indices() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::output_indices </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the list of the indices to <code>out</code>. </p>

</div>
</div>
<a id="a8db386caf8f98a7c8b2850b1dab5aa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db386caf8f98a7c8b2850b1dab5aa00">&#9670;&nbsp;</a></span>set_numbering() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::set_numbering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ordering of the polynomials. Requires <code>renumber.size()==n()</code>. Stores a copy of <code>renumber</code>. </p>

</div>
</div>
<a id="a2179c77d357b24c7b09a87c1a73c2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2179c77d357b24c7b09a87c1a73c2c85">&#9670;&nbsp;</a></span>get_numbering() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the renumber vector. </p>

</div>
</div>
<a id="a160753ef67378b6dca667015efa338b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160753ef67378b6dca667015efa338b1">&#9670;&nbsp;</a></span>get_numbering_inverse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering_inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the inverse renumber vector. </p>

</div>
</div>
<a id="a06c5ffbc3623ee5bba80b400ca67c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c5ffbc3623ee5bba80b400ca67c965">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fourth_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value and the first and second derivatives of each tensor product polynomial at <code>unit_point</code>.</p>
<p>The size of the vectors must either be equal 0 or equal n(). In the first case, the function will not compute these values.</p>
<p>If you need values or derivatives of all tensor product polynomials then use this function, rather than using any of the <a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value()</a>, <a class="el" href="classTensorProductPolynomials.html#a3ac821e3766c21b0fe5e32d7d9a55ac3">compute_grad()</a> or <a class="el" href="classTensorProductPolynomials.html#aa93aa873ad6d4a83ba1e3ab2a43ca7a2">compute_grad_grad()</a> functions, see below, in a loop over all tensor product polynomials. </p>

</div>
</div>
<a id="a12469a186dd9c223c6ac7f8b72d1458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12469a186dd9c223c6ac7f8b72d1458b">&#9670;&nbsp;</a></span>compute_value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering.</p>
<p>Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each point value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function with <code>values.size()==</code>n() to get the point values of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="a20b4938f22468df56790687b5fe8389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b4938f22468df56790687b5fe8389c">&#9670;&nbsp;</a></span>compute_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;order, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the <code>order</code>th derivative of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering.</p>
<p>Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with the size of the appropriate parameter set to n() to get the point value of all tensor polynomials all at once and in a much more efficient way.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>The derivative order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356a7f38a12b70f4692561cf9b62ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a7f38a12b70f4692561cf9b62ba67">&#9670;&nbsp;</a></span>compute_1st_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_1st_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the first derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="ab92d8b51ede2f37b9af2b80a4691404f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92d8b51ede2f37b9af2b80a4691404f">&#9670;&nbsp;</a></span>compute_2nd_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the second derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a334e6b9b143e22fa64ef5d73bfe0fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334e6b9b143e22fa64ef5d73bfe0fa4b">&#9670;&nbsp;</a></span>compute_3rd_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the third derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a4cf2c9f38d15c08f3a849021f5e474f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf2c9f38d15c08f3a849021f5e474f1">&#9670;&nbsp;</a></span>compute_4th_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the fourth derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a0cc9f190c744a25c59b8f824277c333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc9f190c744a25c59b8f824277c333b">&#9670;&nbsp;</a></span>compute_grad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the grad of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering.</p>
<p>Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="a39c3a06f64a6c606da65aeb6878114fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c3a06f64a6c606da65aeb6878114fa">&#9670;&nbsp;</a></span>compute_grad_grad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second derivative (grad_grad) of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering.</p>
<p>Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grad_grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="aae21a282efdbd50cb314d71ca4f7051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21a282efdbd50cb314d71ca4f7051a">&#9670;&nbsp;</a></span>name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the name of the space, which is <code><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a></code>. </p>

</div>
</div>
<a id="acda00ed5c7fabf38c73f9d3f81a45c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda00ed5c7fabf38c73f9d3f81a45c9a">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt;dim&gt; &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>A sort of virtual copy constructor, this function returns a copy of the polynomial space object. Derived classes need to override the function here in this base class and return an object of the same type as the derived class. Some places in the library, for example the constructors of <a class="el" href="classFE__Poly.html">FE_Poly</a>, need to make copies of polynomial spaces without knowing their exact type. They do so through this function. </p>

</div>
</div>
<a id="a795944fd345cbe8d4e01c01fc9e92f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795944fd345cbe8d4e01c01fc9e92f39">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate (in bytes) for the memory consumption of this object. </p>

</div>
</div>
<a id="ae11819bc0196042fc5ed1b9549422851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11819bc0196042fc5ed1b9549422851">&#9670;&nbsp;</a></span>get_underlying_polynomials() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PolynomialType&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_underlying_polynomials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a copy of the underlying one-dimensional polynomials given to the constructor of this class. </p>

</div>
</div>
<a id="a0c5f45fc9847ec3466636578ad9c5b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5f45fc9847ec3466636578ad9c5b3e">&#9670;&nbsp;</a></span>compute_index() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each tensor product polynomial <em>i</em> is a product of one-dimensional polynomials in each space direction. Compute the indices of these one- dimensional polynomials for each space direction, given the index <em>i</em>. </p>

</div>
</div>
<a id="a075c0549687e1f65687e73b07e6b7a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075c0549687e1f65687e73b07e6b7a35">&#9670;&nbsp;</a></span>output_indices() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::output_indices </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the list of the indices to <code>out</code>. </p>

</div>
</div>
<a id="a8db386caf8f98a7c8b2850b1dab5aa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db386caf8f98a7c8b2850b1dab5aa00">&#9670;&nbsp;</a></span>set_numbering() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::set_numbering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ordering of the polynomials. Requires <code>renumber.size()==n()</code>. Stores a copy of <code>renumber</code>. </p>

</div>
</div>
<a id="a2179c77d357b24c7b09a87c1a73c2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2179c77d357b24c7b09a87c1a73c2c85">&#9670;&nbsp;</a></span>get_numbering() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the renumber vector. </p>

</div>
</div>
<a id="a160753ef67378b6dca667015efa338b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160753ef67378b6dca667015efa338b1">&#9670;&nbsp;</a></span>get_numbering_inverse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_numbering_inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give read access to the inverse renumber vector. </p>

</div>
</div>
<a id="a06c5ffbc3623ee5bba80b400ca67c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c5ffbc3623ee5bba80b400ca67c965">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_grads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fourth_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value and the first and second derivatives of each tensor product polynomial at <code>unit_point</code>. The size of the vectors must either be equal 0 or equal n(). In the first case, the function will not compute these values. If you need values or derivatives of all tensor product polynomials then use this function, rather than using any of the <a class="el" href="classTensorProductPolynomials.html#a12469a186dd9c223c6ac7f8b72d1458b">compute_value()</a>, <a class="el" href="classTensorProductPolynomials.html#a3ac821e3766c21b0fe5e32d7d9a55ac3">compute_grad()</a> or <a class="el" href="classTensorProductPolynomials.html#aa93aa873ad6d4a83ba1e3ab2a43ca7a2">compute_grad_grad()</a> functions, see below, in a loop over all tensor product polynomials. </p>

</div>
</div>
<a id="a12469a186dd9c223c6ac7f8b72d1458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12469a186dd9c223c6ac7f8b72d1458b">&#9670;&nbsp;</a></span>compute_value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each point value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function with <code>values.size()==</code>n() to get the point values of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="a20b4938f22468df56790687b5fe8389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b4938f22468df56790687b5fe8389c">&#9670;&nbsp;</a></span>compute_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;order, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the <code>order</code>th derivative of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with the size of the appropriate parameter set to n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>The derivative order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356a7f38a12b70f4692561cf9b62ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a7f38a12b70f4692561cf9b62ba67">&#9670;&nbsp;</a></span>compute_1st_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_1st_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the first derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="ab92d8b51ede2f37b9af2b80a4691404f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92d8b51ede2f37b9af2b80a4691404f">&#9670;&nbsp;</a></span>compute_2nd_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the second derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a334e6b9b143e22fa64ef5d73bfe0fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334e6b9b143e22fa64ef5d73bfe0fa4b">&#9670;&nbsp;</a></span>compute_3rd_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the third derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a4cf2c9f38d15c08f3a849021f5e474f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf2c9f38d15c08f3a849021f5e474f1">&#9670;&nbsp;</a></span>compute_4th_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Compute the fourth derivative of the <code>i</code>th polynomial at unit point <code>p</code>. Consider using <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> instead. </p>

</div>
</div>
<a id="a0cc9f190c744a25c59b8f824277c333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc9f190c744a25c59b8f824277c333b">&#9670;&nbsp;</a></span>compute_grad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the grad of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="a39c3a06f64a6c606da65aeb6878114fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c3a06f64a6c606da65aeb6878114fa">&#9670;&nbsp;</a></span>compute_grad_grad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second derivative (grad_grad) of the <code>i</code>th tensor product polynomial at <code>unit_point</code>. Here <code>i</code> is given in tensor product numbering. Note, that using this function within a loop over all tensor product polynomials is not efficient, because then each derivative value of the underlying (one-dimensional) polynomials is (unnecessarily) computed several times. Instead use the <a class="el" href="classTensorProductPolynomials.html#a06c5ffbc3623ee5bba80b400ca67c965">evaluate()</a> function, see above, with <code>grad_grads.size()==</code>n() to get the point value of all tensor polynomials all at once and in a much more efficient way. </p>

</div>
</div>
<a id="aae21a282efdbd50cb314d71ca4f7051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21a282efdbd50cb314d71ca4f7051a">&#9670;&nbsp;</a></span>name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the name of the space, which is <code><a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a></code>. </p>

</div>
</div>
<a id="acda00ed5c7fabf38c73f9d3f81a45c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda00ed5c7fabf38c73f9d3f81a45c9a">&#9670;&nbsp;</a></span>clone() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classScalarPolynomialsBase.html">ScalarPolynomialsBase</a>&lt;dim&gt; &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>A sort of virtual copy constructor, this function returns a copy of the polynomial space object. Derived classes need to override the function here in this base class and return an object of the same type as the derived class. Some places in the library, for example the constructors of <a class="el" href="classFE__Poly.html">FE_Poly</a>, need to make copies of polynomial spaces without knowing their exact type. They do so through this function. </p>

</div>
</div>
<a id="a795944fd345cbe8d4e01c01fc9e92f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795944fd345cbe8d4e01c01fc9e92f39">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate (in bytes) for the memory consumption of this object. </p>

</div>
</div>
<a id="ae11819bc0196042fc5ed1b9549422851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11819bc0196042fc5ed1b9549422851">&#9670;&nbsp;</a></span>get_underlying_polynomials() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PolynomialType&gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::get_underlying_polynomials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a copy of the underlying one-dimensional polynomials given to the constructor of this class. </p>

</div>
</div>
<a id="a0c5f45fc9847ec3466636578ad9c5b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5f45fc9847ec3466636578ad9c5b3e">&#9670;&nbsp;</a></span>compute_index() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::compute_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each tensor product polynomial <em>i</em> is a product of one-dimensional polynomials in each space direction. Compute the indices of these one- dimensional polynomials for each space direction, given the index <em>i</em>. </p>

</div>
</div>
<a id="ab237ea935bbea2a48f0733d78cebd5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab237ea935bbea2a48f0733d78cebd5eb">&#9670;&nbsp;</a></span>compute_index() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::compute_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00102">102</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a7f0d082a8891da5ca7b7f899b4b191ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0d082a8891da5ca7b7f899b4b191ca">&#9670;&nbsp;</a></span>output_indices() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::output_indices </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00132">132</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="ad51bcd9a62db6b4a68a060442275a967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51bcd9a62db6b4a68a060442275a967">&#9670;&nbsp;</a></span>set_numbering() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::set_numbering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00158">158</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a5f28a449d55860f145076fe7e4a70f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f28a449d55860f145076fe7e4a70f39">&#9670;&nbsp;</a></span>compute_value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::compute_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00189">189</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a4639b3c22c7014e4a7350f71facdf12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4639b3c22c7014e4a7350f71facdf12a">&#9670;&nbsp;</a></span>compute_grad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 0 &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::compute_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00240">240</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="ab2238eef68605f7953460f8a49419980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2238eef68605f7953460f8a49419980">&#9670;&nbsp;</a></span>compute_grad_grad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, 0 &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::compute_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00299">299</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<a id="a5106478d2b4c888b56a32f0c12a294cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106478d2b4c888b56a32f0c12a294cd">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; 0, <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__polynomials_8cc_source.html#l00473">473</a> of file <a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9eabe2340a93dbb84404b06858dcc047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eabe2340a93dbb84404b06858dcc047">&#9670;&nbsp;</a></span>TensorProductPolynomialsBubbles&lt; dim &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTensorProductPolynomialsBubbles.html">TensorProductPolynomialsBubbles</a>&lt; dim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classTensorProductPolynomialsBubbles.html">TensorProductPolynomialsBubbles</a> has a <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a> class so we declare it as a friend class. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00297">297</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<a id="aa7560ba6d45833e3c99dc1ee7833ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7560ba6d45833e3c99dc1ee7833ec35">&#9670;&nbsp;</a></span>TensorProductPolynomialsConst&lt; dim &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTensorProductPolynomialsConst.html">TensorProductPolynomialsConst</a>&lt; dim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classTensorProductPolynomialsConst.html">TensorProductPolynomialsConst</a> has a <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a> class so we declare it as a friend class. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00304">304</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a31514cf94b170f48daa0c052e6670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a31514cf94b170f48daa0c052e6670f">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the dimension of this object, for checking and automatic setting of dimension in other classes. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00082">82</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<a id="a9708cd033eaaadc177af496e9de3837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9708cd033eaaadc177af496e9de3837a">&#9670;&nbsp;</a></span>polynomials</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PolynomialType &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::polynomials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy of the vector <code>pols</code> of polynomials given to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00267">267</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<a id="a4393595258041aad27379fb14be02c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4393595258041aad27379fb14be02c5b">&#9670;&nbsp;</a></span>index_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::index_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index map for reordering the polynomials. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00273">273</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<a id="abc1c9bd03a8216fb3a67b2ac3421c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1c9bd03a8216fb3a67b2ac3421c611">&#9670;&nbsp;</a></span>index_map_inverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename PolynomialType  = Polynomials::Polynomial&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classTensorProductPolynomials.html">TensorProductPolynomials</a>&lt; dim, PolynomialType &gt;::index_map_inverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index map for reordering the polynomials. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__product__polynomials_8h_source.html#l00279">279</a> of file <a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="base_2tensor__product__polynomials_8h_source.html">tensor_product_polynomials.h</a></li>
<li>source/base/<a class="el" href="tensor__product__polynomials_8cc_source.html">tensor_product_polynomials.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
