<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMatrixBlockVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixBlockVector&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMatrixBlockVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatrixBlockVector&lt; MatrixType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a> &raquo; <a class="el" href="group__vector__valued.html">Handling vector valued problems</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lac_2matrix__block_8h_source.html">deal.II/lac/matrix_block.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MatrixBlockVector&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedf908e34d3f375ad163c48091c309"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> = <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt; MatrixType &gt;</td></tr>
<tr class="separator:a1bedf908e34d3f375ad163c48091c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> = std::shared_ptr&lt; <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &gt;</td></tr>
<tr class="separator:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedf908e34d3f375ad163c48091c309"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> = <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt; MatrixType &gt;</td></tr>
<tr class="separator:a1bedf908e34d3f375ad163c48091c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> = std::shared_ptr&lt; <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &gt;</td></tr>
<tr class="separator:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> = <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td></tr>
<tr class="separator:abc34d1d1d06923b4da6d1c3720ba65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedf908e34d3f375ad163c48091c309"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> = <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt; MatrixType &gt;</td></tr>
<tr class="separator:a1bedf908e34d3f375ad163c48091c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> = std::shared_ptr&lt; <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &gt;</td></tr>
<tr class="separator:a075a14d6bd7dfe189f0326cf3d49e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21fee8e09b8695d535611a9d0173d31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a21fee8e09b8695d535611a9d0173d31e">add</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> row, <a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> column, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="separator:a21fee8e09b8695d535611a9d0173d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#acb09b1abe7daf175b361d20be0dbb2dc">reinit</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73d1296e8d3301cf9ba905865d731a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab73d1296e8d3301cf9ba905865d731a7">clear</a> (<a class="el" href="classbool.html">bool</a> really_clean=false)</td></tr>
<tr class="separator:ab73d1296e8d3301cf9ba905865d731a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab7e0ef2ade03e5cc43f1ab17c93e803a">memory_consumption</a> () const</td></tr>
<tr class="separator:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ae06e50a1fd91deb8592b37973510"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#aa35ae06e50a1fd91deb8592b37973510">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i) const</td></tr>
<tr class="separator:aa35ae06e50a1fd91deb8592b37973510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e3643b2a97ef357641f0e5705fabc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a13e3643b2a97ef357641f0e5705fabc5">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:a13e3643b2a97ef357641f0e5705fabc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6439447897ca2c7d2dca52a2edadb5b"><td class="memItemLeft" align="right" valign="top">MatrixType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ae6439447897ca2c7d2dca52a2edadb5b">matrix</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:ae6439447897ca2c7d2dca52a2edadb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fee8e09b8695d535611a9d0173d31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a21fee8e09b8695d535611a9d0173d31e">add</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> row, <a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> column, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="separator:a21fee8e09b8695d535611a9d0173d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#acb09b1abe7daf175b361d20be0dbb2dc">reinit</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73d1296e8d3301cf9ba905865d731a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab73d1296e8d3301cf9ba905865d731a7">clear</a> (<a class="el" href="classbool.html">bool</a> really_clean=false)</td></tr>
<tr class="separator:ab73d1296e8d3301cf9ba905865d731a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab7e0ef2ade03e5cc43f1ab17c93e803a">memory_consumption</a> () const</td></tr>
<tr class="separator:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aedf0dd78dfa9b9ff58686a7677877"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#aa2aedf0dd78dfa9b9ff58686a7677877">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i) const</td></tr>
<tr class="separator:aa2aedf0dd78dfa9b9ff58686a7677877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdc9329ecd767bdd6bae627c33b269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a9cdc9329ecd767bdd6bae627c33b269c">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:a9cdc9329ecd767bdd6bae627c33b269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1391307cf117db29148005dc632b9"><td class="memItemLeft" align="right" valign="top">MatrixType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ac3b1391307cf117db29148005dc632b9">matrix</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:ac3b1391307cf117db29148005dc632b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fee8e09b8695d535611a9d0173d31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a21fee8e09b8695d535611a9d0173d31e">add</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> row, <a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> column, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="separator:a21fee8e09b8695d535611a9d0173d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#acb09b1abe7daf175b361d20be0dbb2dc">reinit</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:acb09b1abe7daf175b361d20be0dbb2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73d1296e8d3301cf9ba905865d731a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab73d1296e8d3301cf9ba905865d731a7">clear</a> (<a class="el" href="classbool.html">bool</a> really_clean=false)</td></tr>
<tr class="separator:ab73d1296e8d3301cf9ba905865d731a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ab7e0ef2ade03e5cc43f1ab17c93e803a">memory_consumption</a> () const</td></tr>
<tr class="separator:ab7e0ef2ade03e5cc43f1ab17c93e803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aedf0dd78dfa9b9ff58686a7677877"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#aa2aedf0dd78dfa9b9ff58686a7677877">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i) const</td></tr>
<tr class="separator:aa2aedf0dd78dfa9b9ff58686a7677877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdc9329ecd767bdd6bae627c33b269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a9cdc9329ecd767bdd6bae627c33b269c">block</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:a9cdc9329ecd767bdd6bae627c33b269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1391307cf117db29148005dc632b9"><td class="memItemLeft" align="right" valign="top">MatrixType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#ac3b1391307cf117db29148005dc632b9">matrix</a> (<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> i)</td></tr>
<tr class="separator:ac3b1391307cf117db29148005dc632b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c3060ecb24b17b4fbb19c297a5186"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a027c3060ecb24b17b4fbb19c297a5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c3060ecb24b17b4fbb19c297a5186"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a027c3060ecb24b17b4fbb19c297a5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c3060ecb24b17b4fbb19c297a5186"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a027c3060ecb24b17b4fbb19c297a5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114aae577fb1ab8addf8d2484171cc3a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a114aae577fb1ab8addf8d2484171cc3a">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a114aae577fb1ab8addf8d2484171cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classMatrixBlockVector.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5962a83bb87b825d2148a8d62459863f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">size</a> () const</td></tr>
<tr class="memdesc:a5962a83bb87b825d2148a8d62459863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stored data objects.  <a href="classAnyData.html#a5962a83bb87b825d2148a8d62459863f">More...</a><br /></td></tr>
<tr class="separator:a5962a83bb87b825d2148a8d62459863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5949f684f8ce7ccce9d45e65af32580c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a> (type <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a>, const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a5949f684f8ce7ccce9d45e65af32580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new data object.  <a href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">More...</a><br /></td></tr>
<tr class="separator:a5949f684f8ce7ccce9d45e65af32580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">merge</a> (const <a class="el" href="classAnyData.html">AnyData</a> &amp;other)</td></tr>
<tr class="memdesc:a8153b8b6e7595586dd950fc9dc83a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object.  <a href="classAnyData.html#a8153b8b6e7595586dd950fc9dc83a05b">More...</a><br /></td></tr>
<tr class="separator:a8153b8b6e7595586dd950fc9dc83a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>)</td></tr>
<tr class="memdesc:a2ea02bd1c7339366b8e14e9ecf500958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">More...</a><br /></td></tr>
<tr class="separator:a2ea02bd1c7339366b8e14e9ecf500958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af9a25a405fc920c687c6074730736721"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af9a25a405fc920c687c6074730736721">entry</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:af9a25a405fc920c687c6074730736721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#af9a25a405fc920c687c6074730736721">More...</a><br /></td></tr>
<tr class="separator:af9a25a405fc920c687c6074730736721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a62409810c0af9c206e79fa483931534c"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a62409810c0af9c206e79fa483931534c">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a62409810c0af9c206e79fa483931534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">entry</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a42a7c0e418b39cf201e0d9754e8b9058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to stored data object by index.  <a href="classAnyData.html#a42a7c0e418b39cf201e0d9754e8b9058">More...</a><br /></td></tr>
<tr class="separator:a42a7c0e418b39cf201e0d9754e8b9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ab1796f27e02bd47e6cda73761701fd26"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:ab1796f27e02bd47e6cda73761701fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.  <a href="classAnyData.html#ab1796f27e02bd47e6cda73761701fd26">More...</a><br /></td></tr>
<tr class="separator:ab1796f27e02bd47e6cda73761701fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a2fc077dc12f8405a262749a9622deeff"><td class="memTemplItemLeft" align="right" valign="top">const type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a2fc077dc12f8405a262749a9622deeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access.  <a href="classAnyData.html#a2fc077dc12f8405a262749a9622deeff">More...</a><br /></td></tr>
<tr class="separator:a2fc077dc12f8405a262749a9622deeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43273f02653f364163ede364d2f29d97"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a43273f02653f364163ede364d2f29d97"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a43273f02653f364163ede364d2f29d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident.  <a href="classAnyData.html#a43273f02653f364163ede364d2f29d97">More...</a><br /></td></tr>
<tr class="separator:a43273f02653f364163ede364d2f29d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ffef0112889ff54d74020fd60892d9"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ac8ffef0112889ff54d74020fd60892d9"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ac8ffef0112889ff54d74020fd60892d9">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:ac8ffef0112889ff54d74020fd60892d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#ac8ffef0112889ff54d74020fd60892d9">More...</a><br /></td></tr>
<tr class="separator:ac8ffef0112889ff54d74020fd60892d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data.  <a href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">More...</a><br /></td></tr>
<tr class="separator:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">More...</a><br /></td></tr>
<tr class="separator:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident.  <a href="classAnyData.html#a8da271ab2d9e4f8b9f9a2fc554b6423a">More...</a><br /></td></tr>
<tr class="separator:a8da271ab2d9e4f8b9f9a2fc554b6423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object.  <a href="classAnyData.html#af0b46ccd9afa63924bf5df7d9a3f3543">More...</a><br /></td></tr>
<tr class="separator:af0b46ccd9afa63924bf5df7d9a3f3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82d2937c524aa75857180b88fca34b1"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ac82d2937c524aa75857180b88fca34b1"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#ac82d2937c524aa75857180b88fca34b1">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:ac82d2937c524aa75857180b88fca34b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5f3e927f4a549ad50dfba9881cb5e1b9">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a5f3e927f4a549ad50dfba9881cb5e1b9">More...</a><br /></td></tr>
<tr class="separator:a5f3e927f4a549ad50dfba9881cb5e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5dbb69e8c6746bacdfbf052adeb0a14f">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a8be2d338e4468cc7c880bef7b96145cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">More...</a><br /></td></tr>
<tr class="separator:a8be2d338e4468cc7c880bef7b96145cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a5dbb69e8c6746bacdfbf052adeb0a14f">try_read_ptr</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="separator:a5dbb69e8c6746bacdfbf052adeb0a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a8be2d338e4468cc7c880bef7b96145cf"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">try_read_ptr</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a8be2d338e4468cc7c880bef7b96145cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access to pointer object without exception.  <a href="classAnyData.html#a8be2d338e4468cc7c880bef7b96145cf">More...</a><br /></td></tr>
<tr class="separator:a8be2d338e4468cc7c880bef7b96145cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2e0522f7e4f244395d3f25981a75f"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a21b2e0522f7e4f244395d3f25981a75f"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a21b2e0522f7e4f244395d3f25981a75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned.  <a href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f">More...</a><br /></td></tr>
<tr class="separator:a21b2e0522f7e4f244395d3f25981a75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#afdff7cb5c4ad6acb67becbb0c0ef44ea">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#afdff7cb5c4ad6acb67becbb0c0ef44ea">More...</a><br /></td></tr>
<tr class="separator:afdff7cb5c4ad6acb67becbb0c0ef44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:aebe567605387d6b3001a0152bec9c6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions.  <a href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">More...</a><br /></td></tr>
<tr class="separator:aebe567605387d6b3001a0152bec9c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a6a0d816391ae9e016fbd2b9c39bae732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">More...</a><br /></td></tr>
<tr class="separator:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aebe567605387d6b3001a0152bec9c6dd"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">try_read</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:aebe567605387d6b3001a0152bec9c6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned.  <a href="classAnyData.html#aebe567605387d6b3001a0152bec9c6dd">More...</a><br /></td></tr>
<tr class="separator:aebe567605387d6b3001a0152bec9c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memTemplItemLeft" align="right" valign="top">const type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">try_read</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a6a0d816391ae9e016fbd2b9c39bae732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated read only access without exception.  <a href="classAnyData.html#a6a0d816391ae9e016fbd2b9c39bae732">More...</a><br /></td></tr>
<tr class="separator:a6a0d816391ae9e016fbd2b9c39bae732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c3060ecb24b17b4fbb19c297a5186"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a027c3060ecb24b17b4fbb19c297a5186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of object at index.  <a href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">More...</a><br /></td></tr>
<tr class="separator:a027c3060ecb24b17b4fbb19c297a5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99410c676515b34476e57583bf990d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a4f99410c676515b34476e57583bf990d">find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a4f99410c676515b34476e57583bf990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found.  <a href="classAnyData.html#a4f99410c676515b34476e57583bf990d">More...</a><br /></td></tr>
<tr class="separator:a4f99410c676515b34476e57583bf990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">try_find</a> (const std::string &amp;<a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a>) const</td></tr>
<tr class="memdesc:a35dfae6b2fbc85f4f5c56de11387e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found.  <a href="classAnyData.html#a35dfae6b2fbc85f4f5c56de11387e299">More...</a><br /></td></tr>
<tr class="separator:a35dfae6b2fbc85f4f5c56de11387e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">is_type</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if object is of a certain type.  <a href="classAnyData.html#a74ae97dd162a3a5bf15aeeae252adc1d">More...</a><br /></td></tr>
<tr class="separator:a74ae97dd162a3a5bf15aeeae252adc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">list</a> (StreamType &amp;os) const</td></tr>
<tr class="memdesc:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents to a stream.  <a href="classAnyData.html#a641e47622afaabf7f6fc58dd9eafb3d3">More...</a><br /></td></tr>
<tr class="separator:a641e47622afaabf7f6fc58dd9eafb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca2472f512372a3dd791ed954bab75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">DeclException1</a> (<a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>, std::string,&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;)</td></tr>
<tr class="memdesc:a85ca2472f512372a3dd791ed954bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">More...</a><br /></td></tr>
<tr class="separator:a85ca2472f512372a3dd791ed954bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca2472f512372a3dd791ed954bab75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">DeclException1</a> (<a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>, std::string,&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;)</td></tr>
<tr class="memdesc:a85ca2472f512372a3dd791ed954bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="classAnyData.html#a85ca2472f512372a3dd791ed954bab75">More...</a><br /></td></tr>
<tr class="separator:a85ca2472f512372a3dd791ed954bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">DeclException2</a> (<a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>, std::string, std::string,&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;)</td></tr>
<tr class="memdesc:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">More...</a><br /></td></tr>
<tr class="separator:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aa2275d6bf2fbc5379573bd24d7211a61">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">DeclException2</a> (<a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>, std::string, std::string,&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;)</td></tr>
<tr class="memdesc:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="classAnyData.html#a61ed0e0c2cee64500104f14edb7bb4ea">More...</a><br /></td></tr>
<tr class="separator:a61ed0e0c2cee64500104f14edb7bb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aa2275d6bf2fbc5379573bd24d7211a61">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:aa2275d6bf2fbc5379573bd24d7211a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a> (std::string arg1)</td></tr>
<tr class="memdesc:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object.  <a href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">More...</a><br /></td></tr>
<tr class="separator:gada4f4f3fcf8d68947c725ee6c2fddaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04d4dd43302af21cbd506c1910adeff"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="memdesc:gad04d4dd43302af21cbd506c1910adeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested type and the stored type are different.  <a href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">More...</a><br /></td></tr>
<tr class="separator:gad04d4dd43302af21cbd506c1910adeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1bf38524189d47d6569cbd99f279dc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b1bf38524189d47d6569cbd99f279dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aabd758e5edb9aa0b8f61162095d2eea5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::any &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#aabd758e5edb9aa0b8f61162095d2eea5">data</a></td></tr>
<tr class="memdesc:aabd758e5edb9aa0b8f61162095d2eea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stored data.  <a href="classAnyData.html#aabd758e5edb9aa0b8f61162095d2eea5">More...</a><br /></td></tr>
<tr class="separator:aabd758e5edb9aa0b8f61162095d2eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ec93276969816ae67877ee760aa416"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnyData.html#a83ec93276969816ae67877ee760aa416">names</a></td></tr>
<tr class="memdesc:a83ec93276969816ae67877ee760aa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names of the stored data.  <a href="classAnyData.html#a83ec93276969816ae67877ee760aa416">More...</a><br /></td></tr>
<tr class="separator:a83ec93276969816ae67877ee760aa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MatrixType&gt;<br />
class MatrixBlockVector&lt; MatrixType &gt;</h3>

<p>A vector of <a class="el" href="classMatrixBlock.html">MatrixBlock</a>, which is implemented using shared pointers, in order to allow for copying and rearranging. Each matrix block can be identified by name. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00366">366</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abc34d1d1d06923b4da6d1c3720ba65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc34d1d1d06923b4da6d1c3720ba65be">&#9670;&nbsp;</a></span>size_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00373">373</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a1bedf908e34d3f375ad163c48091c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bedf908e34d3f375ad163c48091c309">&#9670;&nbsp;</a></span>value_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> =  <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt;MatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of object stored. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00379">379</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a075a14d6bd7dfe189f0326cf3d49e0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a14d6bd7dfe189f0326cf3d49e0fd">&#9670;&nbsp;</a></span>ptr_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> =  std::shared_ptr&lt;<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pointer type used for storing the objects. We use a shard pointer, such that they get deleted automatically when not used anymore. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00386">386</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="abc34d1d1d06923b4da6d1c3720ba65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc34d1d1d06923b4da6d1c3720ba65be">&#9670;&nbsp;</a></span>size_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2matrix__block_8h_source.html#l00358">358</a> of file <a class="el" href="origin_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a1bedf908e34d3f375ad163c48091c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bedf908e34d3f375ad163c48091c309">&#9670;&nbsp;</a></span>value_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> =  <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt;MatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of object stored. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2matrix__block_8h_source.html#l00363">363</a> of file <a class="el" href="origin_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a075a14d6bd7dfe189f0326cf3d49e0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a14d6bd7dfe189f0326cf3d49e0fd">&#9670;&nbsp;</a></span>ptr_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> =  std::shared_ptr&lt;<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pointer type used for storing the objects. We use a shard pointer, such that they get deleted automatically when not used anymore. </p>

<p class="definition">Definition at line <a class="el" href="origin_2lac_2matrix__block_8h_source.html#l00369">369</a> of file <a class="el" href="origin_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="abc34d1d1d06923b4da6d1c3720ba65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc34d1d1d06923b4da6d1c3720ba65be">&#9670;&nbsp;</a></span>size_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a> =  <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="translator_2lac_2matrix__block_8h_source.html#l00373">373</a> of file <a class="el" href="translator_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a1bedf908e34d3f375ad163c48091c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bedf908e34d3f375ad163c48091c309">&#9670;&nbsp;</a></span>value_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a> =  <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt;MatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of object stored. </p>

<p class="definition">Definition at line <a class="el" href="translator_2lac_2matrix__block_8h_source.html#l00379">379</a> of file <a class="el" href="translator_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a075a14d6bd7dfe189f0326cf3d49e0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a14d6bd7dfe189f0326cf3d49e0fd">&#9670;&nbsp;</a></span>ptr_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::<a class="el" href="classMatrixBlockVector.html#a075a14d6bd7dfe189f0326cf3d49e0fd">ptr_type</a> =  std::shared_ptr&lt;<a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pointer type used for storing the objects. We use a shard pointer, such that they get deleted automatically when not used anymore. </p>

<p class="definition">Definition at line <a class="el" href="translator_2lac_2matrix__block_8h_source.html#l00386">386</a> of file <a class="el" href="translator_2lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a21fee8e09b8695d535611a9d0173d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fee8e09b8695d535611a9d0173d31e">&#9670;&nbsp;</a></span>add() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new matrix block at the position <code>(row,column)</code> in the block system. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00884">884</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="acb09b1abe7daf175b361d20be0dbb2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09b1abe7daf175b361d20be0dbb2dc">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For matrices using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, this function reinitializes each matrix in the vector with the correct pattern from the block system. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00895">895</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="ab73d1296e8d3301cf9ba905865d731a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73d1296e8d3301cf9ba905865d731a7">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>really_clean</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the object. Since often only clearing of the individual matrices is desired, but not removing the blocks themselves, there is an optional argument. If the argument is missing or <code>false</code>, all matrices will be empty, but the size of this object and the block positions will not change. If <code>really_clean</code> is <code>true</code>, then the object will contain no blocks at the end. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00906">906</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="ab7e0ef2ade03e5cc43f1ab17c93e803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e0ef2ade03e5cc43f1ab17c93e803a">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The memory used by this object. </p>

</div>
</div>
<a id="aa35ae06e50a1fd91deb8592b37973510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35ae06e50a1fd91deb8592b37973510">&#9670;&nbsp;</a></span>block() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt; MatrixType &gt; &amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access a constant reference to the block at position <em>i</em>. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00923">923</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a13e3643b2a97ef357641f0e5705fabc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e3643b2a97ef357641f0e5705fabc5">&#9670;&nbsp;</a></span>block() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixBlock.html">MatrixBlock</a>&lt; MatrixType &gt; &amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access a reference to the block at position <em>i</em>. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00931">931</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="ae6439447897ca2c7d2dca52a2edadb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6439447897ca2c7d2dca52a2edadb5b">&#9670;&nbsp;</a></span>matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType &amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the matrix at position <em>i</em> for read and write access. </p>

<p class="definition">Definition at line <a class="el" href="lac_2matrix__block_8h_source.html#l00939">939</a> of file <a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a>.</p>

</div>
</div>
<a id="a21fee8e09b8695d535611a9d0173d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fee8e09b8695d535611a9d0173d31e">&#9670;&nbsp;</a></span>add() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new matrix block at the position <code>(row,column)</code> in the block system. </p>

</div>
</div>
<a id="acb09b1abe7daf175b361d20be0dbb2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09b1abe7daf175b361d20be0dbb2dc">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For matrices using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, this function reinitializes each matrix in the vector with the correct pattern from the block system. </p>

</div>
</div>
<a id="ab73d1296e8d3301cf9ba905865d731a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73d1296e8d3301cf9ba905865d731a7">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>really_clean</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the object.</p>
<p>Since often only clearing of the individual matrices is desired, but not removing the blocks themselves, there is an optional argument. If the argument is missing or <code>false</code>, all matrices will be empty, but the size of this object and the block positions will not change. If <code>really_clean</code> is <code>true</code>, then the object will contain no blocks at the end. </p>

</div>
</div>
<a id="ab7e0ef2ade03e5cc43f1ab17c93e803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e0ef2ade03e5cc43f1ab17c93e803a">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The memory used by this object. </p>

</div>
</div>
<a id="aa2aedf0dd78dfa9b9ff58686a7677877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aedf0dd78dfa9b9ff58686a7677877">&#9670;&nbsp;</a></span>block() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a constant reference to the block at position <em>i</em>. </p>

</div>
</div>
<a id="a9cdc9329ecd767bdd6bae627c33b269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdc9329ecd767bdd6bae627c33b269c">&#9670;&nbsp;</a></span>block() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a reference to the block at position <em>i</em>. </p>

</div>
</div>
<a id="ac3b1391307cf117db29148005dc632b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b1391307cf117db29148005dc632b9">&#9670;&nbsp;</a></span>matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the matrix at position <em>i</em> for read and write access. </p>

</div>
</div>
<a id="a21fee8e09b8695d535611a9d0173d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fee8e09b8695d535611a9d0173d31e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new matrix block at the position <code>(row,column)</code> in the block system. </p>

</div>
</div>
<a id="acb09b1abe7daf175b361d20be0dbb2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09b1abe7daf175b361d20be0dbb2dc">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For matrices using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, this function reinitializes each matrix in the vector with the correct pattern from the block system. </p>

</div>
</div>
<a id="ab73d1296e8d3301cf9ba905865d731a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73d1296e8d3301cf9ba905865d731a7">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>really_clean</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the object. Since often only clearing of the individual matrices is desired, but not removing the blocks themselves, there is an optional argument. If the argument is missing or <code>false</code>, all matrices will be empty, but the size of this object and the block positions will not change. If <code>really_clean</code> is <code>true</code>, then the object will contain no blocks at the end. </p>

</div>
</div>
<a id="ab7e0ef2ade03e5cc43f1ab17c93e803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e0ef2ade03e5cc43f1ab17c93e803a">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The memory used by this object. </p>

</div>
</div>
<a id="aa2aedf0dd78dfa9b9ff58686a7677877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aedf0dd78dfa9b9ff58686a7677877">&#9670;&nbsp;</a></span>block() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a constant reference to the block at position <em>i</em>. </p>

</div>
</div>
<a id="a9cdc9329ecd767bdd6bae627c33b269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdc9329ecd767bdd6bae627c33b269c">&#9670;&nbsp;</a></span>block() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixBlockVector.html#a1bedf908e34d3f375ad163c48091c309">value_type</a>&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a reference to the block at position <em>i</em>. </p>

</div>
</div>
<a id="ac3b1391307cf117db29148005dc632b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b1391307cf117db29148005dc632b9">&#9670;&nbsp;</a></span>matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType&amp; <a class="el" href="classMatrixBlockVector.html">MatrixBlockVector</a>&lt; MatrixType &gt;::matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixBlockVector.html#abc34d1d1d06923b4da6d1c3720ba65be">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the matrix at position <em>i</em> for read and write access. </p>

</div>
</div>
<a id="a027c3060ecb24b17b4fbb19c297a5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c3060ecb24b17b4fbb19c297a5186">&#9670;&nbsp;</a></span>name() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AnyData::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>import functions from private base class </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00315">315</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00227">227</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a027c3060ecb24b17b4fbb19c297a5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c3060ecb24b17b4fbb19c297a5186">&#9670;&nbsp;</a></span>name() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AnyData::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>import functions from private base class </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00315">315</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00227">227</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a027c3060ecb24b17b4fbb19c297a5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c3060ecb24b17b4fbb19c297a5186">&#9670;&nbsp;</a></span>name() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AnyData::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>import functions from private base class </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00315">315</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a114aae577fb1ab8addf8d2484171cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114aae577fb1ab8addf8d2484171cc3a">&#9670;&nbsp;</a></span>name() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; AnyData::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>import functions from private base class </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00227">227</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

</div>
</div>
<a id="a5962a83bb87b825d2148a8d62459863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962a83bb87b825d2148a8d62459863f">&#9670;&nbsp;</a></span>size() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stored data objects. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00227">227</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5949f684f8ce7ccce9d45e65af32580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949f684f8ce7ccce9d45e65af32580c">&#9670;&nbsp;</a></span>add() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::add </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new data object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00436">436</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00445">445</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

</div>
</div>
<a id="a8153b8b6e7595586dd950fc9dc83a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153b8b6e7595586dd950fc9dc83a05b">&#9670;&nbsp;</a></span>merge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAnyData.html">AnyData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the data of another <a class="el" href="classAnyData.html">AnyData</a> to the end of this object. </p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00355">355</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00366">366</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00236">236</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00248">248</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to stored data object by name. </p>
<p>Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. </p>
<p>Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

</div>
</div>
<a id="a2ea02bd1c7339366b8e14e9ecf500958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea02bd1c7339366b8e14e9ecf500958">&#9670;&nbsp;</a></span>entry() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="af9a25a405fc920c687c6074730736721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a25a405fc920c687c6074730736721">&#9670;&nbsp;</a></span>entry() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by name. Find the object with given name, try to convert it to <code>type</code> and return it. This function throws an exception if either the name does not exist or if the conversion fails. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>

</div>
</div>
<a id="a62409810c0af9c206e79fa483931534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62409810c0af9c206e79fa483931534c">&#9670;&nbsp;</a></span>entry() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to stored data object by index. </p>

</div>
</div>
<a id="a42a7c0e418b39cf201e0d9754e8b9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a7c0e418b39cf201e0d9754e8b9058">&#9670;&nbsp;</a></span>entry() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to stored data object by index. </p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00378">378</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00262">262</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name. </p>
<p>For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

</div>
</div>
<a id="ab1796f27e02bd47e6cda73761701fd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1796f27e02bd47e6cda73761701fd26">&#9670;&nbsp;</a></span>read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name. For a constant object, this function equals <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958" title="Access to stored data object by name. Find the object with given name, try to convert it to type and ...">entry()</a>. For a non-const object, it forces read only access to the data. In particular, it throws an exception if the object is not found or cannot be converted to type. If such an exception is not desired, use <a class="el" href="classAnyData.html#a21b2e0522f7e4f244395d3f25981a75f" title="Dedicated read only access by name without exceptions. This function tries to find the name in the li...">try_read()</a> instead. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function for stored objects which are pointers. Use <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a> instead! </dd></dl>

</div>
</div>
<a id="a2fc077dc12f8405a262749a9622deeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc077dc12f8405a262749a9622deeff">&#9670;&nbsp;</a></span>read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type AnyData::read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access. </p>

</div>
</div>
<a id="a43273f02653f364163ede364d2f29d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43273f02653f364163ede364d2f29d97">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00389">389</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="ac8ffef0112889ff54d74020fd60892d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ffef0112889ff54d74020fd60892d9">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00276">276</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a8da271ab2d9e4f8b9f9a2fc554b6423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da271ab2d9e4f8b9f9a2fc554b6423a">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. </p>
<p>If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

</div>
</div>
<a id="af0b46ccd9afa63924bf5df7d9a3f3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b46ccd9afa63924bf5df7d9a3f3543">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

</div>
</div>
<a id="a8da271ab2d9e4f8b9f9a2fc554b6423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da271ab2d9e4f8b9f9a2fc554b6423a">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name for pointer data. If the stored data object is a pointer to a constant object, the logic of access becomes fairly complicated. Namely, the standard read function may fail, depending on whether it was a const pointer or a regular pointer. This function fixes the logic and ascertains that the object does not become mutable by accident. </p>

</div>
</div>
<a id="af0b46ccd9afa63924bf5df7d9a3f3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b46ccd9afa63924bf5df7d9a3f3543">&#9670;&nbsp;</a></span>read_ptr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object. </p>

</div>
</div>
<a id="ac82d2937c524aa75857180b88fca34b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82d2937c524aa75857180b88fca34b1">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00403">403</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5f3e927f4a549ad50dfba9881cb5e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3e927f4a549ad50dfba9881cb5e1b9">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00290">290</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a5dbb69e8c6746bacdfbf052adeb0a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbb69e8c6746bacdfbf052adeb0a14f">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

</div>
</div>
<a id="a8be2d338e4468cc7c880bef7b96145cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be2d338e4468cc7c880bef7b96145cf">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

</div>
</div>
<a id="a5dbb69e8c6746bacdfbf052adeb0a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbb69e8c6746bacdfbf052adeb0a14f">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the same action as <a class="el" href="classAnyData.html#a43273f02653f364163ede364d2f29d97" title="Dedicated read only access by name for pointer data. If the stored data object is a pointer to a cons...">read_ptr()</a>, but do not throw an exception if the pointer does not exist. Return a null pointer instead. </p>

</div>
</div>
<a id="a8be2d338e4468cc7c880bef7b96145cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be2d338e4468cc7c880bef7b96145cf">&#9670;&nbsp;</a></span>try_read_ptr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read_ptr </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access to pointer object without exception. </p>

</div>
</div>
<a id="a21b2e0522f7e4f244395d3f25981a75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b2e0522f7e4f244395d3f25981a75f">&#9670;&nbsp;</a></span>try_read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00418">418</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="afdff7cb5c4ad6acb67becbb0c0ef44ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdff7cb5c4ad6acb67becbb0c0ef44ea">&#9670;&nbsp;</a></span>try_read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type * AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00304">304</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="aebe567605387d6b3001a0152bec9c6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe567605387d6b3001a0152bec9c6dd">&#9670;&nbsp;</a></span>try_read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. </p>
<p>This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

</div>
</div>
<a id="a6a0d816391ae9e016fbd2b9c39bae732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d816391ae9e016fbd2b9c39bae732">&#9670;&nbsp;</a></span>try_read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

</div>
</div>
<a id="aebe567605387d6b3001a0152bec9c6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe567605387d6b3001a0152bec9c6dd">&#9670;&nbsp;</a></span>try_read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access by name without exceptions. This function tries to find the name in the list and return a pointer to the associated object. If either the name is not found or the object cannot be converted to the return type, a null pointer is returned. </p>

</div>
</div>
<a id="a6a0d816391ae9e016fbd2b9c39bae732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d816391ae9e016fbd2b9c39bae732">&#9670;&nbsp;</a></span>try_read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type* AnyData::try_read </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dedicated read only access without exception. </p>

</div>
</div>
<a id="a027c3060ecb24b17b4fbb19c297a5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c3060ecb24b17b4fbb19c297a5186">&#9670;&nbsp;</a></span>name() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AnyData::name </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of object at index. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00315">315</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00336">336</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find index of a named object. </p>
<p>Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

</div>
</div>
<a id="a4f99410c676515b34476e57583bf990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f99410c676515b34476e57583bf990d">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find index of a named object Try to find the object and return its index in the list. Throw an exception if the object has not been found. </p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00323">323</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find index of a named object. </p>
<p>Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

</div>
</div>
<a id="a35dfae6b2fbc85f4f5c56de11387e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dfae6b2fbc85f4f5c56de11387e299">&#9670;&nbsp;</a></span>try_find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> AnyData::try_find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find index of a named object Try to find the object and return its index in the list. returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if the name was not found. </p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00347">347</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

</div>
</div>
<a id="a74ae97dd162a3a5bf15aeeae252adc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ae97dd162a3a5bf15aeeae252adc1d">&#9670;&nbsp;</a></span>is_type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AnyData::is_type </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if object is of a certain type. </p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00457">457</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

</div>
</div>
<a id="a641e47622afaabf7f6fc58dd9eafb3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e47622afaabf7f6fc58dd9eafb3d3">&#9670;&nbsp;</a></span>list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AnyData::list </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the contents to a stream. </p>

</div>
</div>
<a id="a85ca2472f512372a3dd791ed954bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca2472f512372a3dd791ed954bab75">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object. </p>

</div>
</div>
<a id="a85ca2472f512372a3dd791ed954bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca2472f512372a3dd791ed954bab75">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gada4f4f3fcf8d68947c725ee6c2fddaf3">ExcNameNotFound</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;No <a class="el" href="classAnyData.html#a2ea02bd1c7339366b8e14e9ecf500958">entry</a> with the <a class="el" href="classAnyData.html#a027c3060ecb24b17b4fbb19c297a5186">name</a> &quot;&lt;&lt; arg1&lt;&lt; &quot; exists.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An entry with this name does not exist in the <a class="el" href="classAnyData.html">AnyData</a> object. </p>

</div>
</div>
<a id="a61ed0e0c2cee64500104f14edb7bb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed0e0c2cee64500104f14edb7bb4ea">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The requested type and the stored type are different. </p>

</div>
</div>
<a id="aa2275d6bf2fbc5379573bd24d7211a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2275d6bf2fbc5379573bd24d7211a61">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception indicating that a function expected a vector to have a certain name, but we store a different name in that position. </p>

</div>
</div>
<a id="a61ed0e0c2cee64500104f14edb7bb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed0e0c2cee64500104f14edb7bb4ea">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gad04d4dd43302af21cbd506c1910adeff">ExcTypeMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The requested type &quot;&lt;&lt; arg1&lt;&lt; &quot; and the stored type &quot;&lt;&lt; arg2&lt;&lt; &quot; must coincide.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The requested type and the stored type are different. </p>

</div>
</div>
<a id="aa2275d6bf2fbc5379573bd24d7211a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2275d6bf2fbc5379573bd24d7211a61">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyData::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#ga8b1bf38524189d47d6569cbd99f279dc">ExcNameMismatch</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Name at position &quot;&lt;&lt; arg1&lt;&lt; &quot; is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception indicating that a function expected a vector to have a certain name, but we store a different name in that position. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aabd758e5edb9aa0b8f61162095d2eea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd758e5edb9aa0b8f61162095d2eea5">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::any &gt; AnyData::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The stored data. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00221">221</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<a id="a83ec93276969816ae67877ee760aa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ec93276969816ae67877ee760aa416">&#9670;&nbsp;</a></span>names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; AnyData::names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The names of the stored data. </p>

<p class="definition">Definition at line <a class="el" href="algorithms_2any__data_8h_source.html#l00223">223</a> of file <a class="el" href="algorithms_2any__data_8h_source.html">any_data.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="lac_2matrix__block_8h_source.html">matrix_block.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
