include/deal.II-translator/numerics/vector_tools_point_gradient_0.txt
[0.x.0]*
    [2.x.0] 函数的评估和错误  
* [0.x.1]*
   评估由给定DoFHandler和节点向量在给定点定义的可能是矢量值的有限元函数，并通过最后一个参数返回该函数的（矢量）梯度。    这是一个使用单元格边界的Q1映射来调用其他point_gradient()函数的包装函数。    这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评估点相匹配的点，然后在那里评估形状函数。你可能不想用这个函数来评估[1.x.0]点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估[1.x.1]，你可能想看看[2.x.1]函数。   
* [2.x.2] 如果发现点所在的单元格不是本地拥有的，就会抛出一个[2.x.3]类型的异常。   
* [2.x.4] 这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.2]*
   与上述hp的情况相同。   
* [2.x.5] 如果找到的点所在的单元格不是本地拥有的，会抛出一个[2.x.6]类型的异常。   
* [2.x.7] 这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。    因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.3]*
   评估由给定DoFHandler和节点向量在给定点定义的标量有限元函数，并返回这个函数的梯度。    与另一个同名的函数相比，这是一个使用Q1映射的单元格的包装函数。    这个函数不是特别便宜。这是因为它首先需要找到一个给定的点在哪个单元格中，然后在参考单元格上找到与给定的评估点相匹配的点，然后评估那里的形状函数。你可能不想用这个函数来评估[1.x.2]点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估[1.x.3]，你可能想看一下[2.x.8]函数。   
* [2.x.9] 如果发现点所在的单元格不是本地拥有的，就会抛出一个[2.x.10]类型的异常。   
* [2.x.11] 这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.4]*
   与上述hp的情况相同。   
* [2.x.12] 如果找到的点所在的单元格不是本地拥有的，会抛出一个[2.x.13]类型的异常。   
* [2.x.14] 这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.5]*
   评估由给定DoFHandler和节点向量在给定点定义的可能是矢量值的有限元函数，并通过最后一个参数返回这个函数的梯度。    与另一个同名的函数相比，这个函数使用一个任意的映射进行评估。    这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评价点相匹配的点，然后在那里评价形状函数。你可能不想用这个函数来评估[1.x.4]点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估[1.x.5]，你可能想看一下[2.x.15]函数。   
* [2.x.16] 如果发现点所在的单元格不是本地拥有的，就会抛出一个[2.x.17]类型的异常。   
* [2.x.18] 这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.6]*
   与上述hp的情况相同。   
* [2.x.19] 如果找到的点所在的单元格不是本地拥有的，会抛出一个[2.x.20]类型的异常。   
* [2.x.21] 这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.7]*
   评估由给定DoFHandler和节点向量在给定点定义的标量有限元函数，并返回这个函数的梯度。    与另一个同名的函数相比，这个函数使用一个任意的映射进行评估。    这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评价点相匹配的点，然后在那里评价形状函数。你可能不想用这个函数来评估[1.x.6]点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估[1.x.7]，你可能想看一下[2.x.22]函数。   
* [2.x.23] 如果发现点所在的单元格不是本地拥有的，就会抛出一个[2.x.24]类型的异常。   
* [2.x.25] 这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.8]*
   与上述hp的情况相同。   
* [2.x.26] 如果找到的点所在的单元格不是本地拥有的，会抛出一个[2.x.27]类型的异常。   
* [2.x.28] 这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。    因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 
* [0.x.9]

