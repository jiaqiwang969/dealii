include/deal.II-translator/numerics/cell_data_transfer_0.txt
[0.x.0]*
 在细化和/或粗化三角测量时，传输与每个活动单元相关的数据（如误差指标）。
* 因此，这个类对于单元相关的信息，就像SolutionTransfer对于定义在三角剖分上的自由度值一样。
* 必须提供一个非分布式的容器（如Vector或[2.x.0]），它以活动单元被遍历的相同顺序持有单元的数据。换句话说，每个条目都对应于具有相同索引[2.x.1]的单元，容器的大小必须是[2.x.2] 。
* [1.x.0]
* 下面的代码片断演示了如何在细化/粗化注册三角的过程中传输单元的相关数据。
* 

* 
* [1.x.1]
* 
* 当使用[2.x.3]时，我们需要确保在细化发生之前，我们的本地向量中有全局数据。我们可以通过以下方式实现这一点。
* 

* 
* [1.x.2]
* 
* 对于并行分布的情况，有一个指定的类[2.x.4]。在使用[2.x.5]时，请参考这个特定的类。
* 

* 
* [2.x.6] 参见SolutionTransfer的文档，以了解传输的匹配代码片段。
* 

* 
* [2.x.7] 

* 
* [0.x.1]*
   一个别名，定义了所提供的容器模板的数据类型。 
* [0.x.2]*
   构造函数。     [2.x.8] triangulation 所有操作都将发生在这个三角形上。当这个构造函数被调用时，有关的细化还没有发生。   [2.x.9] refinement_strategy %函数，决定如何将数据从其父单元存储到细化单元上。   [2.x.10] coarsening_strategy %函数决定在子单元上存储哪些数据，其子单元将被粗化为。 
* [0.x.3]*
   为粗化和细化当前对象做准备。    存储相关三角形上所有活动单元的active_cell_indices，并将它们归属于持久化、细化或粗化的单元。 
* [0.x.4]*
   将上一个网格的信息转移到更新的网格中。    由[2.x.11]提供的前一个网格的数据将被转移到更新的网格，并存储在[2.x.12][2.x.13]必须提供足够的空间来容纳转移的数据，即必须是`triangulation.n_active_cells()`的大小。 
* [0.x.5]*
   指向要处理的三角结构的指针。 
* [0.x.6]*
   决定数据如何从其父单元存储到细化单元的函数。 
* [0.x.7]*
   决定如何处理来自子单元的数据以存储在父单元上的函数。 
* [0.x.8]*
   容器，用于临时存储持续存在的单元格的迭代器和活动单元格索引。 
* [0.x.9]*
   用于临时存储将被精炼的单元格的迭代器和活动单元格索引的容器。 
* [0.x.10]*
   容器用于临时存储粗化后将保留的父单元格的迭代器以及相应子单元格的活动单元格索引。 
* [0.x.11]*
   初始三角形上尚未被细化的活动单元的数量。    它将在prepare_for_coarsening_and_refinement()中设置，并在细化发生后用于验证用户输入（仅在调试模式）。 
* [0.x.12]

