include/deal.II-translator/numerics/error_estimator.templates_0.txt
[0.x.0]*
   误差估计器的几个函数在每个线程中需要一次的所有小型临时数据对象都聚集在这个结构中。  建立这个结构的原因主要是我们有一些对单元或面进行操作的函数，需要一些小的临时数据对象。由于这些函数可能会并行运行，我们不能让这些对象成为包围类的成员变量。另一方面，在这些函数中的每一个局部声明它们将需要在我们每次访问下一个单元格或面时重新分配，我们发现如果经常发生这种情况，即使是在单线程的情况下（在我们的测量中为10-20%）也会花费大量的时间；然而，最重要的是，内存分配需要在多线程模式下进行同步。虽然这是由C++库完成的，不需要手工编码，但它还是严重损害了有效地并行运行该类函数的能力，因为它们经常被这些同步点阻断，使一切都慢了两到三倍。    因此，每个线程都有一个这个类的实例来工作，不需要自己分配内存，也不需要与其他线程同步。    数组的大小被初始化为hp情况下所需的最大条目数。在各个单元的循环中，我们会根据需要调整数组的大小。因为对于[2.x.0]来说，调整大小到一个较小的尺寸并不意味着内存分配，所以这很快速。 
* [0.x.1]*
     要使用的有限元。   
* [0.x.2]*
     用于面的正交公式。   
* [0.x.3]*
     FEFaceValues对象，用于对当前和可能的邻近单元的面进行积分。   
* [0.x.4]*
     一个向量用于存储每个求解向量的正交点的法向量跳动（即一个临时值）。    这个向量不是在使用它的函数内部分配的，而是全局分配的，因为内存分配很慢，特别是在有多个线程的情况下，同步化会使事情变得更慢。   
* [0.x.5]*
     一个单元上的有限元函数梯度的向量 让psi成为<tt>a grad u_h</tt>的简称，其中第三个索引是有限元的分量，第二个索引是正交点的编号。第一个索引表示解向量的索引。   
* [0.x.6]*
     邻近单元的相同向量    
* [0.x.7]*
     一个面上的有限元函数的法向量    
* [0.x.8]*
     对立面的法向量。   
* [0.x.9]*
     跳跃中的系数值所需的两个数组，如果它们被给出的话。   
* [0.x.10]*
     用于雅各布行列式和四分仪点的权重的乘积的数组。   
* [0.x.11]*
     我们要关注的子域ID。   
* [0.x.12]*
     我们要关注的材料ID。   
* [0.x.13]*
     还有一些对[2.x.1]函数的输入数据的引用。   
* [0.x.14]*
     构造函数。   
* [0.x.15]*
     调整数组的大小，使其适合与给定的有限元索引相关的正交点数量的hp-集合。   
* [0.x.16]*
   将单个ParallelData对象的local_face_integrals地图中的数据复制到一个全局的此类地图中。这是一个WorkStream流水线的复制器阶段。 
* [0.x.17]*
   实际上是根据ParallelData中评估的梯度来进行计算。 
* [0.x.18]*
   一个用于缩放边界处面的积分的因子。用于Neumann BC。 
* [0.x.19]*
   一个用于缩放常规面的积分的因子。 
* [0.x.20]*
   对不规则面的积分进行缩放的系数。 
* [0.x.21]*
   一个用于汇总每个单元中不同面的所有贡献的系数。 
* [0.x.22]*
   实际上是在一个没有悬挂节点的面（它是规则的）上进行计算，也就是说，要么在另一边有涅槃（面在边界），要么另一边的细化水平与这一边的细化水平相同，然后把这两种情况的积分一起处理。 
* [0.x.23]*
   和上面的函数一样，只是积分是在[2.x.3]的[2.x.2]面上，其中各自的邻居被细化，所以积分会更复杂一些。 
* [0.x.24]*
   计算单个单元的面的误差。    这个函数只在二维或三维中需要。 一维的误差估计器是单独实现的。 
* [0.x.25]

