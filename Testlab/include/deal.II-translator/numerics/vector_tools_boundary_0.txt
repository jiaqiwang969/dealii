include/deal.II-translator/numerics/vector_tools_boundary_0.txt
[0.x.0]*
    [2.x.0] 内插和投影  
* [0.x.1]*
   计算对应于施加Dirichlet边界条件的解决方案的约束。 这个函数通过在边界周围插值，创建一个受迪里希特边界条件约束的自由度地图，以及要分配给它们的相应数值。对于边界上的每个自由度，如果它的索引已经存在于[2.x.1]中，那么它的边界值将被覆盖，否则将在[2.x.2]中插入一个具有适当索引和边界值的新条目。 参数[2.x.3]提供了一个由该函数处理的边界指标列表和相应的边界值函数。  该图的键对应于面的编号[2.x.4]。   [2.x.5]是这个键的非法值，因为它是为内部面保留的。关于如何用非空地图使用这个参数的例子，请看[2.x.6]的教程程序。    最后一个参数[2.x.7]中的标志表示有限元空间的哪些部分应被插值。如果保留默认值（即一个空数组），所有组件都被插值。如果它与默认值不同，则假定条目数等于边界函数和有限元中的分量数，给定边界函数中的那些分量将被用于在分量掩码中设置的相应标志。另见 [2.x.8] 。  举个例子，假设你正在求解2d中的斯托克斯方程，变量为[2.x.9]，你只想插值速度的边界值，那么分量掩码应该对应于[2.x.10] 。   
* [2.x.11] 无论是否指定了分量掩码，[2.x.12]中函数的分量数必须与[2.x.13]使用的有限元的分量数一致。 ] 换句话说，对于上面的例子，你需要提供一个有3个分量（两个速度和压力）的Function对象，尽管你只对其中的前两个感兴趣。 interpolate_boundary_values()然后会调用这个函数，在每个插值点获得3个值的向量，但只取前两个，舍弃第三个。换句话说，你可以自由地在[2.x.14]返回的向量的第三个分量中返回你喜欢的东西，但Function对象必须说明它有3个分量。    如果使用的有限元的形状函数在一个以上的分量中是非零的（用deal.II的话说：它们是非原始的），那么这些分量目前不能用于内插边界值。  因此，与这些非正则形状函数的分量相对应的分量掩码中的元素必须是 [2.x.15] 更多信息请参见该命名空间的一般文档。   
* [2.x.16] 当求解带有边界条件的偏微分方程[2.x.17]（或边界的部分*）时，那么这个边界条件一般不能用[2.x.18]形式的有限元准确满足。这是因为函数[2.x.19]一般不是多项式，而[2.x.20]在位于边界的网格的每个面上都是*项多项式。换句话说，一般来说，不可能施加*这样的边界条件；然而，可以*做的是施加[1.x.0]，其中[2.x.21]是一个函数，在位于边界的有限元空间的每个节点上等于[2.x.22]，并且在两者之间是片断多项式。换句话说，[2.x.23]是一个内插算子*，[2.x.24]是内插的边界值
* 
*--因此而得名。使用[2.x.25]而不是[2.x.26]作为边界值会带来一个额外的误差（与使用正交引入一个额外的误差相比，能够准确计算弱形式的积分）。在大多数情况下，这个额外的误差与有限元方法中的其他误差项相同，尽管在测量[2.x.27]准则中的误差时有一些微妙的差别。关于一些细节，请参见 [2.x.28] 。   
* [2.x.29] 使用内插法的一个替代方法，[1.x.1]是使用边界值[2.x.30]对边界上的有限元空间的投影*：[1.x.2] 投影可以使用project_boundary_values()函数。使用投影可能有一些理论上的优势（参见[2.x.31]），但有一个实际的缺点，即计算投影比计算插值要昂贵得多，因为后者可以一次完成一个面，而投影则需要解决整个边界上的问题。另一方面，插值只适用于 "节点式 "有限元空间（如FE_Q，但不包括FE_Q_Hierarchical），而投影则始终适用。 
* [0.x.2]*
   像之前的函数一样，但采取一个映射集合，以配合具有hp能力的DoFHandler对象。 
* [0.x.3]*
   和上面的函数一样，但只取一对边界指标和相应的边界函数。同样的评论适用于前面的函数，特别是关于组件掩码的使用和函数对象的要求大小。     [2.x.32] [2.x.33] "关于边界指标的词汇条目"  
* [0.x.4]*
   像之前的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 
* [0.x.5]*
   调用另一个interpolate_boundary_values()函数，见上文，使用<tt>mapping=MappingQGeneric [2.x.34] 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。     [2.x.35] [2.x.36] "关于边界指标的词汇条目"  
* [0.x.6]*
   调用另一个interpolate_boundary_values()函数，见上文，<tt>mapping=MappingQGeneric [2.x.37] 与前一个函数的评论相同，特别是关于使用分量掩码和函数对象的要求大小。 
* [0.x.7]*
   将由于Dirichlet边界条件引起的（代数）约束插入AffineConstraints [2.x.38] 这个函数识别受Dirichlet边界条件约束的自由度，将它们添加到[2.x.39]中受约束的DoF列表中，并将各自的不均匀性设置为围绕边界插值的值。如果这个例程遇到一个已经被约束的DoF（例如被悬挂的节点约束，见下文，或任何其他类型的约束，例如来自周期性边界条件的约束），约束的旧设置（条目被约束的DoF，不均匀性）被保留，不会发生什么。   
* [2.x.40] 当在一个AffineConstraints对象中结合具有悬挂节点约束和边界条件的自适应细化网格时，悬挂节点约束应该总是首先被设置，然后是边界条件，因为边界条件不会在已经被约束的自由度的第二次操作中被设置。这可以确保离散化保持所需的一致性。参见[2.x.41]模块中关于冲突约束的讨论。    这个函数与上面的函数基本等同，只是它将其结果放入AffineConstraint对象中，而不是[2.x.42] 更多评论见上面的函数。   
* [2.x.43]   
* [0.x.8]*
   和前面的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 
* [0.x.9]*
   与上述函数相同，但只取一对边界指标和相应的边界函数。同样的评论适用于前面的函数，特别是关于组件掩码的使用和函数对象的要求大小。   
* [2.x.44] [2.x.45] [2.x.46] "关于边界指标的词汇条目"  
* [0.x.10]*
   像之前的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 
* [0.x.11]*
   调用另一个interpolate_boundary_values()函数，见上文，使用<tt>mapping=MappingQGeneric [2.x.47] 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。   
* [2.x.48] [2.x.49] [2.x.50] "关于边界指标的词汇条目"  
* [0.x.12]*
   调用另一个interpolate_boundary_values()函数，见上文，<tt>mapping=MappingQGeneric [2.x.51] 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。   
* [2.x.52]   
* [0.x.13]*
   投射一个函数或一组函数到域的边界。  换句话说，计算以下问题的解决方案：找到[2.x.53]（其中[2.x.54]是由该函数的DoFHandler参数所代表的有限元空间），以便  
* [1.x.3]
* 其中[2.x.55], [2.x.56], [2.x.57]是指数集，[2.x.58]是该函数的函数图参数[2.x.59]所代表的相应边界函数，积分用正交法求值。这个问题在内部有一个非唯一的解决方案，但对于边界部分的自由度，[2.x.60]，它是定义良好的，我们对其进行积分。[2.x.61]的值，即这个函数沿边界的自由度的节点值，就是这个函数所计算的。    如果这个函数与[2.x.62]符合的有限元空间一起使用，则会计算出一个不同的问题的解决方案，即。找到[2.x.63]，以便  
* [1.x.4]
*其中[2.x.64]是一个外向法向量。    如果与[2.x.65]符合的元素一起使用，这个函数会抛出一个异常，所以应该使用project_boundary_values_curl_conforming_l2()来代替。     [2.x.66] 映射 将用于沿边界整合所需的转换的映射。   [2.x.67] dof 描述有限元空间和自由度编号的DoFHandler。   [2.x.68] boundary_functions 从边界指标到函数指针的映射，这些函数描述了边界上标有该边界指标的那些部分的期望值（见[2.x.69] "边界指标"）。  投影只发生在边界的那些部分，这些部分的指标在这个地图中被代表。   [2.x.70] q 用于计算质量矩阵和投影的右手边所需的积分的面正交。   [2.x.71] boundary_values 这个函数的结果。它是一个包含边界上所有自由度指数的地图（如[2.x.72]中的边界部分所涵盖的，以及该自由度的计算dof值。对于边界上的每个自由度，如果它的索引已经存在于[2.x.73]中，那么它的边界值将被覆盖，否则将在[2.x.74]中插入一个具有适当索引和边界值的新条目。 ] component_mapping 有时，将一个矢量值函数投射到有限元空间的一部分是很方便的（例如，将一个[2.x.76]分量的函数投射到斯托克斯问题的[2.x.77]分量DoFHandler的速度分量）。为了允许这一点，这个参数允许分量被重新映射。如果矢量不是空的，它必须为[2.x.78]中使用的有限元的每个矢量分量有一个条目，这个条目是[2.x.79]中的分量编号，应该用于[2.x.80]中的这个分量。 默认情况下，不应用重新映射。   
* [2.x.81] 使用投影*而不是边界值的插值*，在实践中没有什么区别。也就是说，计算投影的计算成本要高得多，因为它需要解决一个耦合边界上所有未知数的问题，而内插法则是一次只计算一个面。另一方面，插值只适用于 "节点型 "有限元空间（如FE_Q，但不包括FE_Q_Hierarchical），而投影则始终适用。(关于一些更多的理论考虑，见上面第一个interpolate_boundary_values()函数的文档)。 
* [0.x.14]*
   调用project_boundary_values()函数，见上文，<tt>mapping=MappingQGeneric [2.x.82] 。  
* [0.x.15]*
   和上面一样，但有hp-capabilities。 
* [0.x.16]*
   调用project_boundary_values()函数，见上文，使用<tt>mapping=MappingQGeneric [2.x.83] 。  
* [0.x.17]*
   将一个函数投影到域的边界，使用给定的面的正交公式。该函数识别受Dirichlet边界条件约束的自由度，将其添加到[2.x.84]中的受约束自由度列表中，并将各自的不均匀性设置为投影操作产生的值。如果这个例程遇到一个已经被约束的DoF（例如被悬挂的节点约束，见下文，或任何其他类型的约束，例如来自周期性边界条件的约束），约束的旧设置（条目被约束的DoF，不均匀性）被保留，不会发生什么。   
* [2.x.85] 当在一个AffineConstraints对象中结合具有悬挂节点约束和边界条件的自适应细化网格时，悬挂节点约束应该总是首先被设置，然后是边界条件，因为边界条件不会在已经被约束的自由度的第二次操作中被设置。这可以确保离散化保持所需的一致性。参见[2.x.86]模块中关于冲突约束的讨论。    如果[2.x.87]为空，则假定[2.x.88]的分量数与[2.x.89]所使用的有限元的分量数一致。 在1d中，投影等于插值。因此，interpolate_boundary_values被调用。     [2.x.90] [2.x.91] 如果[2.x.92]和[2.x.93]中的组件不重合，这个向量允许它们被重新映射。如果这个向量不是空的，它必须有一个条目代表[2.x.94]中的每个组件。这个条目是[2.x.95]中的分量编号，应该用于[2.x.96]中的这个分量。 默认情况下，不应用重映射。   
* [2.x.97]   
* [0.x.18]*
   调用project_boundary_values()函数，见上文，使用<tt>mapping=MappingQGeneric [2.x.98] 。    
* [2.x.99]   
* [0.x.19]*
   这个函数是project_boundary_values_curl_conforming函数的一个更新版本。其目的是修复在使用前一个函数时与非矩形几何体（即具有非矩形面的元素）一起使用的一个问题。所用的L2投影方法取自PD Ledger, K Morgan and O Hassan的论文 "Electromagnetic Scattering simulation using an H (curl) conforming hp-finite element method in three dimensions" ( Int. J. Num. Meth. Fluids, Volume 53, Issue 8, pages 1267-1296) 。    该函数将计算对应于[2.x.100]形式的Dirichlet边界条件的约束，即[2.x.101]和[2.x.102]的切向分量应相吻合。    [1.x.5] 为了计算约束条件，我们使用基于上述论文的投影方法。在二维中，对于基于边缘的形状函数，无论有限元的顺序如何，这都是在单一阶段完成的。在三维中，这是在两个阶段完成的，首先是边，然后是面。    对于每个单元，每个边[2.x.103]通过解决线性系统[2.x.104]进行投影，其中[2.x.105]是边上自由度的约束向量，[2.x.106][2.x.107]是[2.x.108]形状函数，[2.x.110]是切线向量。    一旦所有的边缘约束，[2.x.111]被计算出来，我们可以用类似的方式计算面的约束，同时考虑到边缘的残差。    对于单元格上的每个面，[2.x.112]，我们解决线性系统[2.x.113]，其中[2.x.114]是面的自由度约束矢量，[2.x.115][2.x.116]和[2.x.117]，是边缘残差。    然后在解决方案[2.x.118]和[2.x.119]中给出所产生的约束。    如果AffineConstraints [2.x.120]中包含数值或其他约束，那么如果要使用的边界部分的节点已经在约束列表中，那么新的约束将被添加或覆盖旧的约束。这可以通过使用不均匀约束来处理。请注意，当结合自适应网格和这种约束时，应该首先设置Dirichlet条件，然后通过悬挂节点约束完成，以确保离散化保持一致。参见 [2.x.121] 模块中关于冲突约束的讨论。    [1.x.6] 该函数明确用于FE_Nedelec元素，或包含FE_Nedelec元素的FESystem元素。如果在调用该函数时使用任何其他有限元，则会产生一个异常。用户在使用此函数时必须保证FESystem元素的正确设置，因为在这种情况下不可能进行检查。    这个函数的第二个参数表示有限元的第一个矢量分量，对应于你希望约束的矢量函数。例如，如果我们正在求解三维麦克斯韦方程，并且有分量[2.x.122]，我们想要边界条件[2.x.123]，那么[2.x.124]第一_向量_分量将是3。在这个例子中，[2.x.125]必须返回6个分量，前3个对应于[2.x.126]，后3个对应于[2.x.127] 。隐含地假定矢量正好有[2.x.128]个分量，这些分量的排序方式与我们通常对坐标方向的排序方式相同，即[2.x.129] -，[2.x.130] -，最后是[2.x.131] -分量。    参数[2.x.132]对应于面的编号[2.x.133]边界_id。 [2.x.134]是一个非法值，因为它是为内部面保留的。    最后一个参数被表示为计算边界点的法向量[2.x.135]。     
* [2.x.136] [2.x.137] [2.x.138] "关于边界指标的词汇条目"  
* [0.x.20]*
   project_boundary_values_curl_conforming_l2（上文）的hp-namespace版本。   
* [2.x.139]   
* [0.x.21]*
   计算对应于[2.x.140]形式的边界条件的约束，即解[2.x.141]和给定[2.x.142]的法线分量应重合。函数[2.x.143]由[2.x.144]给出，所得到的约束被添加到[2.x.145]约束中，用于具有边界指标的面[2.x.146] 这个函数是明确写给FE_RaviartThomas元素使用的。因此，如果它与其他有限元一起被调用，就会抛出一个异常。    如果AffineConstraints对象[2.x.147]之前包含数值或其他约束，那么如果要使用的边界部分的一个节点已经在约束列表中，那么就会添加新的约束或覆盖旧的约束。这可以通过使用不均匀约束来处理。请注意，当结合自适应网格和这种约束时，应该首先设置Dirichlet条件，然后通过悬挂节点约束完成，以确保离散化保持一致。参见 [2.x.148] 模块中关于冲突约束的讨论。    参数[2.x.149]表示有限元中的第一个矢量分量，对应于你要约束的矢量函数[2.x.150]。隐含地假定矢量正好有[2.x.151]个分量，这些分量的排序方式与我们通常对坐标方向的排序方式相同，即[2.x.152] -，[2.x.153] -，最后是[2.x.154] -分量。    参数[2.x.155]对应的是应用边界条件的面的[2.x.156]。   [2.x.157]是一个非法值，因为它被保留给内部面。[2.x.158]用于计算边界点的法向量[2.x.159]。    [1.x.7] 为了计算约束条件，我们在位于边界的每个面上使用Brezzi, Fortin (Mixed and Hybrid Finite Element Methods, Springer, 1991)中提出的插值运算。   
* [2.x.160] [2.x.161] [2.x.162] "关于边界指标的词汇条目"  
* [0.x.22]*
   与上述hp-namespace的情况相同。   
* [2.x.163] [2.x.164] [2.x.165] "关于边界指标的词汇表条目"  
* [0.x.23]

