include/deal.II-translator/numerics/data_out_rotation_0.txt
[0.x.0]*
     一个派生类，用于DataOutFaces类中。这是一个用于WorkStream类的文档中讨论的AdditionalData那种数据结构的类。   
* [0.x.1]*
 这个类在全域的计算中生成输出，这些计算是利用域和解的旋转对称性完成的。特别是，如果一个三维问题的计算是围绕[2.x.0]旋转对称的（即在[2.x.1]中完成的，那么这个类可以用来生成原始[2.x.2]空间中的输出。为了做到这一点，它从计算网格中的每个单元生成一个空间中的单元，其尺寸比DoFHandler对象的尺寸大。这样的输出将由六面体组成，形成一个围绕Z轴旋转对称的对象。由于大多数图形程序不能表示环状结构，角度（旋转）变量也被离散成有限数量的区间；这些区间的数量必须交给[2.x.3]函数。然而，需要注意的是，虽然这个函数生成了整个领域的漂亮图片，但它经常产生[2.x.4]非常[2.x.5]大的输出文件。
* 

* [1.x.0]
* 这个类的接口是从DataOut类复制过来的。此外，它们共享共同的父类DataOut_DoFData()。关于接口的讨论以及如何通过从这个类派生出更多的类来扩展它，请参见这两个类的参考文献。
* 

* [1.x.1]
* 传递给这个类的DoFHandler对象所使用的三角测量中的一个坐标被当作径向变量，然后输出将是一个圆或一个环域。用户有责任保证径向坐标只达到非负值。
* 

* [1.x.2]
* 我们认为计算（由附加到该类的DoFHandler对象表示）发生在[2.x.6]中，其中[2.x.7]是径向变量，[2.x.8]表示围绕解决方案对称的旋转轴。输出是在[2.x.9]空间，其中径向依赖被转换到[2.x.10]平面。目前，不可能交换模拟所在平面的第一个和第二个变量的含义，即生成模拟的输出，其中第一个变量表示对称轴，第二个表示径向变量。在第一次为你的应用程序编程时，你必须考虑到这一点。
* 用户有责任确保径向变量只达到非负值。
* 

* 
* [2.x.11] 

* 
* [0.x.2]*
   补丁的尺寸参数。 
* [0.x.3]*
   对所考虑的dof处理程序类的迭代器类型的类型定义。 
* [0.x.4]*
   这是该类的核心功能，因为它建立了由基类的低级函数编写的补丁列表。从本质上讲，补丁是三角形和DoFHandler对象的每个单元上的数据的一些中间表示，然后可以用来以某种可视化程序可读的格式编写文件。    你可以在这个类的一般文档中找到关于这个函数的使用概述。在这个类的基类DataOut_DoFData的文档中也提供了一个例子。     [2.x.12] n_patches_per_circle 表示角度（旋转）变量将被细分为多少个间隔。     [2.x.13] n_subdivisions 参见[2.x.14]对该参数的详细描述。 
* [0.x.5]*
   返回我们想要输出的第一个单元格。默认实现返回第一个[2.x.15]"活动单元"，但你可能想在派生类中返回其他单元。 
* [0.x.6]*
   返回[2.x.16]之后我们想要输出的下一个单元格。如果没有更多的单元格，应返回<tt>dofs->end()</tt>。    默认实现返回下一个活动单元，但你可能想在派生类中返回其他单元。请注意，默认实现假设给定的[2.x.17]是活动的，只要[2.x.18]也被用于默认实现，就可以保证。只重载这两个函数中的一个可能不是个好主意。 
* [0.x.7]*
   异常情况  
* [0.x.8]*
   建立与第一个参数中给出的单元格相对应的所有补丁。在WorkStream中使用第二个参数作为并行调用的抓取空间，并将结果放到最后一个参数中。 
* [0.x.9]*
    [2.x.19] 使用没有DoFHandlerType模板的[2.x.20]代替。 
* [0.x.10]

