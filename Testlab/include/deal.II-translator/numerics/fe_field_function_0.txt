include/deal.II-translator/numerics/fe_field_function_0.txt
[0.x.0]*
   这是一个针对给定的dof处理程序和给定的解决方案向量的插值函数。这个函数可以被评估的点必须是在dof处理程序的域内，但除了这一点，没有给出其他要求。这个函数相当慢，因为它需要为你想评估有限元函数的点（或点组）构造一个正交对象。为了做到这一点，它需要找出这些点的位置。    如果你事先知道你的点位于哪个单元，你可以在要求函数的值或梯度之前调用set_active_cell()来加快事情的进展。如果你不这样做，而你的点不在当前存储的单元格中，那么就会调用函数[2.x.0]来找出点的位置。  你可以指定一个可选的映射，以便在网格中寻找点时使用。如果你不这样做，这个函数就会使用一个Q1的映射。    一旦 FEFieldFunction 知道了点的位置，它就会为这些点创建一个正交公式，然后用给定的正交点调用 [2.x.1] 或 [2.x.2] 。    如果你只需要正交点，而不需要有限元函数的值（你可能想要这个用于邻接插值），你也可以单独使用函数compute_point_locations()。    下面是使用这个函数的一个例子。   
* [1.x.0]
* 上面的代码片断将工作，假设第二个三角形完全包含在第一个三角形中。    FEFieldFunction被设计成一种简单的方式来获取你在不同的、可能不匹配的网格中的计算结果。在这个类中没有假定点的位置的知识，这使得它的工作完全依赖于[2.x.3]工具。然而，该类可以通过使用[2.x.4]的方法，对将要计算的点的位置进行 "有根据的猜测"，所以如果你有一个聪明的方法来告诉你的点在哪里，你可以让这个类知道，从而节省大量的计算时间。      [1.x.1]当使用这个类与并行分布式三角测量对象并在一个特定的点上评估解决方案时，不是每个处理器都会拥有评估解决方案的单元。相反，可能发现这个点的单元实际上是一个幽灵或人工单元（见[2.x.5]和[2.x.6]）。  解决方案可以在幽灵单元上进行评估，但对于人工单元，我们无法访问那里的解决方案，在这样的点上评估解决方案的函数将触发一个[2.x.7]类型的异常。 为了处理这种情况，你将希望使用如下代码，例如，在原点评估解决方案时（这里使用一个平行的TrilinosWrappers向量来保存解决方案）。 
* [1.x.2]
*     
* [2.x.8]   
* [0.x.1]*
     构建一个向量函数。一个智能指针被存储到dof处理程序中，所以你必须确保它在这个对象的整个生命周期内是有意义的。这个函数的组件数量等于有限元对象的组件数量。如果指定了一个映射，这就是用来找出点的位置。否则就使用标准的Q1映射。   
* [0.x.2]*
     设置当前单元。如果你事先知道你的点在哪里，你可以通过调用这个函数告诉这个对象。这将使事情变得更快一些。   
* [0.x.3]*
     在给定的点上获得一个矢量值。使用单点的效率很低。如果你一次需要多于一个，请使用vector_value_list()函数。出于效率的考虑，如果所有的点都位于同一个单元格上，那就更好了。这并不是强制性的，但是它确实能加快事情的进展。       
* [2.x.9] 当在[2.x.10]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.11] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.4]*
     返回函数在给定点的值。除非只有一个分量（即该函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。使用单点的效率很低。如果你一次需要多于一个，请使用vector_value_list()函数。出于效率的考虑，如果所有的点都位于同一个单元格上，那就更好了。这并不是强制性的，但是它确实能加快事情的进展。       
* [2.x.12] 当在一个[2.x.13]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.14] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.5]*
     将[2.x.15]设置为[2.x.16]处的函数指定分量的点值 假设[2.x.17]已经有了合适的大小，即与点阵的大小相同。如果所有的点都位于同一个单元格上，这就相当有效。如果不是这样的话，事情可能会变得有点慢。       
* [2.x.18] 当在一个[2.x.19]上使用这个函数时，你可能会在试图评估位于一个人造单元上的点的解决方案时得到一个异常（见[2.x.20] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.6]*
     将[2.x.21]设置为[2.x.22]处的函数的点值 假设[2.x.23]已经有了合适的大小，即与点阵列的大小相同。如果所有的点都位于同一个单元格上，这就相当有效。如果不是这样的话，事情可能会变得有点慢。       
* [2.x.24] 当在一个[2.x.25]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.26] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.7]*
     返回函数在给定点的所有分量的梯度。 使用单点的效率很低。如果你一次需要多于一个，请使用vector_value_list()函数。出于效率的考虑，如果所有的点都位于同一个单元格上，那就更好了。这并不是强制性的，但是它确实能加快事情的进展。       
* [2.x.27] 当在一个[2.x.28]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.29]）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.8]*
     返回函数的指定分量在给定点的梯度。使用单点的效率很低。如果你一次需要多于一个，请使用vector_value_list()函数。出于效率的考虑，如果所有的点都位于同一个单元格上，那就更好了。这并不是强制性的，但是它确实能加快事情的进展。       
* [2.x.30] 当在一个[2.x.31]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.32]）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.9]*
     返回所有给定点的函数的所有分量的梯度。如果所有的点都在同一个单元格上，这就相当有效。如果不是这种情况，事情可能会变得有点慢。       
* [2.x.33] 当在[2.x.34]上使用这个函数时，当你试图在一个位于人工单元上的点上求解时，你可能会得到一个异常（见[2.x.35] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.10]*
     返回函数的指定分量在所有给定点的梯度。 如果所有的点都在同一个单元格上，这就相当有效。如果不是这种情况，事情可能会慢一点。       
* [2.x.36] 当在[2.x.37]上使用这个函数时，当你试图在一个位于人工单元上的点上求解时可能会得到一个异常（见[2.x.38]）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.11]*
     计算点<tt>p</tt>处给定分量的拉普拉斯。       
* [2.x.39] 当在一个[2.x.40]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.41] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.12]*
     计算点<tt>p</tt>上所有分量的拉普拉斯，并将其存储在<tt>values</tt>中。       
* [2.x.42]当在一个[2.x.43]上使用这个函数时，当你试图在一个位于人工单元上的点上评估解决方案时，你可能会得到一个异常（见[2.x.44] ）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.13]*
     计算一组点上的一个分量的拉普拉斯（Laplacian）。       
* [2.x.45]当在一个[2.x.46]上使用这个函数时，当你试图在一个位于人工单元上的点上求解时，可能会得到一个异常（见[2.x.47]）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.14]*
     计算一组点上的所有分量的拉普拉斯系数。       
* [2.x.48]当在一个[2.x.49]上使用这个函数时，当你试图在一个位于人工单元上的点上求解时，可能会得到一个异常（见[2.x.50]）。    更多信息请参见该类的一般文档中的章节。   
* [0.x.15]*
     给出一组位于域中的点（或者，在并行三角计算的情况下，位于域的局部拥有的部分或当前处理器的幽灵单元上），将这些点分类到至少有一个点所在的每个单元的桶中。        这个函数填充了三个输出向量。 [2.x.51] [2.x.52] 和 [2.x.53] 第一个是包含这些点的单元格的列表，第二个是与第一个列表的每个单元格相匹配的正交点的列表，第三个包含给定的正交点的索引，即[2.x.54] 最后是第四个单元格的第五个正交点。         [2.x.55] 这个函数返回共同包含给定[2.x.56]点的单元格的数量。这也等同于输出数组的长度。        这个函数简单地调用了[2.x.57]：使用原始函数避免了在每次函数调用时计算一个新的Cache。   
* [0.x.16]*
     持有本地cell_hint的类型定义。   
* [0.x.17]*
     指向dof处理程序的指针。   
* [0.x.18]*
     对实际数据向量的引用。   
* [0.x.19]*
     一个对正在使用的映射的引用。   
* [0.x.20]*
     缓存对象    
* [0.x.21]*
     最新的单元格提示。   
* [0.x.22]*
     给定一个单元格，如果它确实位于该单元格内，则返回该单元格内给定点的参考坐标。否则返回一个未初始化的[2.x.58]对象。   
* [0.x.23]*
      [2.x.59] 使用没有DoFHandlerType模板的[2.x.60]代替。   
* [0.x.24]

