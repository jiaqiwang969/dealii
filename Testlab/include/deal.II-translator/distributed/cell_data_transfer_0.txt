include/deal.II-translator/distributed/cell_data_transfer_0.txt
[0.x.0]*
     在细化和/或粗化分布式三角测量时，传输与每个活动单元相关的数据（如错误指示器）并处理必要的通信。        因此，该类对单元相关信息的作用就像[2.x.0]对定义在[2.x.1]上的自由度值的作用一样。该类被设计用来操作任何一种可序列化的数据类型。必须提供一个非分布式的容器（如Vector或[2.x.2]），它以活动单元被遍历的相同顺序来保存单元的数据。换句话说，每个条目都对应于具有相同索引[2.x.3]的单元，容器的大小必须是[2.x.4] [1.x.0] 下面的代码片段演示了如何在细化/粗化注册三角的过程中传输单元相关数据。       
* [1.x.1]
* [1.x.2] 这个类可以用来序列化和随后反序列化一个带有附加数据的分布式网格到不同的文件。        对于序列化，下面的代码片段不仅保存了三角图本身，而且还保存了附加的单元数据。   
* [1.x.3]
* 之后，在反序列化过程中，三角图和数据都可以按以下方式恢复。   
* [1.x.4]
*         
* [2.x.5] 如果你通过[2.x.6]和[2.x.7]接口使用一个以上的对象来传输数据，目的是为了序列化，对相应的prepare_for_serialization()和deserialize()函数的调用需要分别以相同的顺序发生。依靠这个接口的类，例如[2.x.8] [2.x.9]和[2.x.10] 。        
* [2.x.11] 参见[2.x.12]的文档，了解传输和序列化的匹配代码片段。       
* [2.x.13]     
* [0.x.1]*
       一个别名，定义了所提供的容器模板的数据类型。     
* [0.x.2]*
       构造函数。             [2.x.14] triangulation 所有的操作都将发生在这个三角形上。当这个构造函数被调用时，有关的细化还没有发生。       [2.x.15] transfer_variable_size_data 指定你的VectorType容器是否存储有不同大小的值。不同数量的数据可能会被打包到每个单元格中，例如，如果VectorType容器的底层ValueType是一个容器本身。       [2.x.16] refinement_strategy %函数决定数据将如何从其父单元格存储在精炼单元格上。       [2.x.17] coarsening_strategy %函数决定在一个单元格上存储哪些数据，其子单元格将被粗化为。     
* [0.x.3]*
       为粗化和细化的当前对象做准备。            它在底层三角形上注册了[2.x.18]的数据传输。       [2.x.19]包括要插值到新的（细化和/或粗化的）网格上的数据。关于如何使用这个功能的更多信息，请参见这个类的文档。            这个函数对指定的容器只能调用一次，直到数据传输完成。如果要通过这个类传输多个向量，请使用下面这个函数。     
* [0.x.4]*
       与上面的函数相同，只是针对一个向量的列表。     
* [0.x.5]*
       准备对给定的向量进行序列化。            序列化是由[2.x.20]完成的，关于如何使用这一功能的更多信息，请参见该类的文档。            这个函数对指定的容器只能调用一次，直到数据传输完成。如果多个向量应通过这个类来传输，请使用下面的函数。     
* [0.x.6]*
       与上面的函数相同，只是针对一个向量的列表。     
* [0.x.7]*
       在网格被细化或粗化到当前的单元格集合之前，解压之前存储在这个对象中的信息。     
* [0.x.8]*
       与上面的函数相同，只是针对一个向量列表。     
* [0.x.9]*
       执行存储信息的反序列化。      这需要在调用[2.x.21]后进行。      
* [0.x.10]*
       和上面的函数一样，只是针对一个向量的列表。     
* [0.x.11]*
       指向要处理的三角结构的指针。     
* [0.x.12]*
       指定要传输的数据的大小是否因单元格而异。     
* [0.x.13]*
       决定数据如何从其父单元存储到细化单元的函数。     
* [0.x.14]*
       决定如何处理来自子单元的数据以存储在父单元上的函数。     
* [0.x.15]*
       一个向量，存储所有我们应该从旧网格复制到新网格的向量的指针。     
* [0.x.16]*
       triangulation分配给这个对象的句柄，我们可以用它来访问我们的内存偏移和我们的打包函数。     
* [0.x.17]*
       将pack_callback()函数注册给triangulation并存储返回的句柄。     
* [0.x.18]*
       一个回调函数，用于将当前网格上的数据打包成对象，以后可以在细化、粗化和重新划分后取回。     
* [0.x.19]*
       一个回调函数，用来解开当前网格上的数据，这些数据在细化、粗化和重新划分之前，已经被打包在网格上了。     
* [0.x.20]

