include/deal.II-translator/distributed/shared_tria_0.txt
[0.x.0]*
     这个类提供了一个并行的三角形，每个处理器都知道全局网格的每个单元（与[2.x.0]类不同），但在用MPI运行时，单元被自动分割，这样每个处理器就 "拥有 "一个单元子集。这个类的使用在 [2.x.1] 中得到了证明。        与[2.x.2]和[2.x.3]类不同，这意味着整个网格被存储在每个处理器上。虽然这显然是一个内存瓶颈，将这个类的使用限制在几十个或几百个MPI进程中，但网格的划分可以用来划分参与处理器之间的工作，如装配或后处理，它也可以用来划分哪个处理器存储矩阵和向量的哪一部分。因此，使用这个类通常是比更多的[2.x.4]类更温和的代码并行化介绍，在后者中，处理器只知道他们自己的那部分网格，但对其他处理器拥有的单元却一无所知，除了他们自己那部分域周围的单层幽灵单元之外。        作为在每个处理器上存储整个网格的结果，活动单元需要在所有处理器上被标记为细化或粗化，如果你想调整它们，无论它们被归类为本地所有、幽灵或人工。        在计算时间和内存的考虑决定了程序需要并行运行，但在算法上需要每个处理器都知道整个网格的情况下，该类也很有用。一个例子是，一个应用程序必须同时拥有体积和表面网格，然后都可以独立分区，但很难确保本地拥有的表面网格单元集与本地拥有的体积网格单元集相邻，反之亦然。在这种情况下，知道两个网格的[1.x.0]可以确保耦合项的装配可以实现，而不需要实施过于复杂的方案来在处理器之间传递相邻单元的信息。        单元在处理器之间的划分是根据一些不同的可能性在内部完成的。通过向该类的构造函数传递适当的标志（见[2.x.5]枚举），可以选择不同的网格划分方式，包括由应用决定的方式，而不是由希望最小化处理器所拥有的子域之间的接口长度（如METIS和Zoltan包所做的，两者都是划分的选项）。DoFHandler类知道如何以适合于分区网格的方式列举自由度。       
* [2.x.6]     
* [0.x.1]*
       分布式三角计算的配置标志要在构造函数中设置。设置可以用位法OR来组合。            构造函数要求[2.x.7]、[2.x.8]和[2.x.9]中正好有一个被设置。如果[2.x.10]被选中，它将使用[2.x.11]（如果可用），然后是[2.x.12]（如果可用），最后是[2.x.13] 。     
* [0.x.2]*
         根据配置deal.II时发现的启用的依赖关系，选择分区器。 特别是，如果发现了Trilinos软件包Zoltan，那么就使用[2.x.14]策略。如果没有找到Zoltan，但找到了METIS包，那么就使用partition_metis策略。如果这两个都没有找到，那么就使用partition_zorder分区策略。       
* [0.x.3]*
         使用METIS分区器对活动单元进行分区。       
* [0.x.4]*
         用p4est库中使用的相同方案划分活动单元。                术语 "Z-order "起源于这样一个事实，即单元格使用空间填充曲线进行排序，该曲线在2d内按照左下、右下、左上、右上的顺序连接单元格的四个子单元（即用一条看起来像反向 "Z "的曲线），并在三角结构的所有层面上递归进行。这也是GeometryInfo类枚举孩子的顺序。"Z-order "有时也被称为 "Morton ordering"，见https://en.wikipedia.org/wiki/Z-order_curve 。                 [2.x.15] [2.x.16] "Z顺序词汇表条目"。       
* [0.x.5]*
         使用Zoltan来划分活动单元。       
* [0.x.6]*
         使用一个自定义的、用户定义的函数来划分单元格。这可以通过在三角图首次创建时将post_refinement信号连接到三角图，并通过信号传递用户定义的函数来实现 [2.x.17] 。        下面是一个例子。       
* [1.x.1]
* 一个使用lambda函数的等效代码看起来是这样的。       
* [1.x.2]
*                 
* [2.x.18] 如果你打算使用几何多网格的自定义分区，除了活动单元外，你必须手动分区水平单元。       
* [0.x.7]*
         这个标志需要被设置以使用几何多网格功能。这个选项需要额外的计算和通信。                注意：这个标志应该总是和活动单元划分方法的标志一起设置。       
* [0.x.8]*
       构造器。            标志[2.x.19]可以用来启用人工细胞。如果启用，这个类的行为与[2.x.20]和[2.x.21]类似，即会有本地拥有的细胞、单层的幽灵细胞和人工细胞。然而，我们不应该忘记，与那些平行三角形相比，所有的细胞都是在所有的过程中重复的，在大多数情况下，导致人工细胞明显增多。            如果人工细胞被禁用，所有非本地拥有的细胞都被视为幽灵细胞。这可能会导致非常昂贵的幽灵值更新步骤。虽然在人工单元的情况下，幽灵值更新只导致与直接进程邻居的点对点通信，但如果没有人工单元，这些就会退化为每个进程与其他每个进程的通信（"全对全 "通信）。如果这样的幽灵值更新是你代码中的瓶颈，你可能想考虑启用人工单元。     
* [0.x.9]*
       销毁器。     
* [0.x.10]*
       如果支持多级层次结构并且已经构建完成，则返回。     
* [0.x.11]*
       根据设置的细化和粗化标志，对网格进行粗化和细化。            这一步等同于[2.x.22]类，在最后增加调用[2.x.23]。     
* [0.x.12]*
       创建一个三角剖面。            这个函数也是根据提供给构造函数的MPI通信器来划分三角形的。     
* [0.x.13]*
        [2.x.24] [2.x.25].             
* [2.x.26] 还没有实现。     
* [0.x.14]*
       将[2.x.27]复制到这个三角形中。            这个函数也是根据提供给构造器的MPI通信器来划分三角结构。           
* [2.x.28]这个函数不能与[2.x.29]一起使用，因为它只存储它拥有的那些单元，在它本地拥有的单元周围的一层幽灵单元，以及一些人造单元。     
* [0.x.15]*
       为了序列化的目的，从一个流中读取此对象的数据。扔掉之前的内容。            这个函数首先做与[2.x.30]相同的工作，然后根据提供给构造函数的MPI通信器来划分三角形。     
* [0.x.16]*
       返回一个长度为[2.x.31]的向量，其中每个元素都存储了这个单元的所有者的子域ID。向量的元素显然与本地拥有的和幽灵单元的子域id相同，但对于那些不在其子域_id字段中存储单元所有者是谁的人工单元也是正确的。     
* [0.x.17]*
       返回一个长度为[2.x.32]的向量，其中每个元素都存储了这个单元的所有者的水平子域id。该向量的元素显然与本地拥有的和幽灵单元的水平子域ID相同，但对于那些不在其水平子域_id字段中存储单元的所有者的人工单元也是正确的。     
* [0.x.18]*
       返回allow_artificial_cells ，即如果允许人工细胞，则为true。     
* [0.x.19]*
       设置      
* [0.x.20]*
       一个决定是否允许人造细胞的标志。     
* [0.x.21]*
       这个函数调用[2.x.33]()，如果在类的构造函数中要求，就会标记人工细胞。     
* [0.x.22]*
       一个包含子域ID的向量，这些子域是通过使用zorder、METIS或用户定义的分区方案获得的细胞。      在allow_artificial_cells为false的情况下，这个向量与存储在三角形类的cell->subdomain_id()的ID一致。当allow_artificial_cells为true时，属于人工的单元将有cell->subdomain_id() == [2.x.34] 原始分区信息被存储，以允许使用半人工的单元的顺序DoF分布和分区函数。     
* [0.x.23]*
       一个包含通过划分每个级别获得的单元的级别子域ID的向量。            原始的分区信息被存储起来，以允许使用半人工单元的顺序DoF分布和分区函数。     
* [0.x.24]*
     如果我们没有用MPI库实际配置deal.II，编译器为并行共享三角计算选择的假类。这个类的存在使得我们可以在整个库中引用[2.x.35]对象，即使它被禁用。        由于这个类的构造函数被删除，实际上不能创建这样的对象，因为考虑到MPI不可用，这将是毫无意义的。   
* [0.x.25]*
       构造器。已删除，以确保不能构造这种类型的对象（也可参见类的文档）。     
* [0.x.26]*
       如果支持多级层次结构并已构建，则返回。     
* [0.x.27]*
       一个假函数，用于返回空向量。     
* [0.x.28]*
       一个假函数，用于返回空向量。     
* [0.x.29]*
       一个假函数，它总是返回真。     
* [0.x.30]*
       一个假的向量。     
* [0.x.31]*
       一个假的向量。     
* [0.x.32]*
       这个类临时修改了所有活动单元的子域ID，使其成为各自的 "真实 "所有者。            这种修改只发生在[2.x.36]对象的人工单元上，并且在这个类的实例化过程中持续存在。            TemporarilyRestoreSubdomainIds类应该只用于临时的只读目的。例如，每当你的实现需要将人工单元暂时作为本地相关的单元来访问其道夫指数时。            这个类只有在允许人工单元的情况下才有效果。如果没有人工单元，当前的子域ID已经对应于真正的子域ID。关于人工单元的更多信息，请参见[2.x.37]"词汇表"。     
* [0.x.33]*
         构造函数。                如果提供的Triangulation是[2.x.38]类型，则存储所有活动单元的子域ID，用它们的真实子域ID等价物替换。       
* [0.x.34]*
         解构器。                将[2.x.39]上所有活动单元的子域ID返回到它们之前的状态。       
* [0.x.35]*
         修改后的[2.x.40]。        
* [0.x.36]*
         一个向量，在[2.x.41]上的所有活动单元被修改之前，临时存储它们的子域ID。        
* [0.x.37]

