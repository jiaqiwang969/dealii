include/deal.II-translator/distributed/solution_transfer_0.txt
[0.x.0]*
     在细化和/或粗化分布式网格的同时，通过内插法转移离散的FE函数（如解决方案矢量），并处理必要的通信。       
* [2.x.0] 需要注意的是，如果你同时使用一个以上的SolutionTransfer对象，那么对prepare_*()和interpolate()/deserialize()的调用需要以相同的顺序进行。        [1.x.0] 在并行计算中，PETSc或Trilinos矢量可能包含幽灵元素，也可能不包含。对于用prepare_for_coarsening_and_refinement()或prepare_for_serialization()读入信息，你需要提供有重影元素的向量，这样就可以读到所有本地活动元素。另一方面，有重影的向量通常是不可写的，所以对于调用interpolate()或deserialize()，你需要提供没有重影元素的分布式向量。更确切地说，在插值过程中，当前的算法会写进所有局部活动的自由度。        [1.x.1] 这里VectorType是你喜欢的向量类型，例如[2.x.1] [2.x.2] 或相应的块向量。   
* [1.x.2]
* 由于网格是分布式的，需要注意的是，旧的解决方案（）必须被复制到一个也能提供对本地相关DoF值的访问（这些值在插值过程中需要）。   
* [1.x.3]
* 与PETSc和Trilinos矢量不同，[2.x.3]允许写进重影元素。    对于一个重影向量，插值步骤可以通过以下方式完成    
* [1.x.4]
* [1.x.5] 这个类可以用来序列化和随后反序列化一个带有求解向量的分布式网格到一个文件。如果你使用一个以上的DoFHandler，从而使用一个以上的SolutionTransfer对象，它们需要按照相同的顺序进行序列化和反序列化。        如果向量有本地相关的DoF，序列化工作如下。   
* [1.x.6]
* 对于反序列化，向量需要是一个分布式向量（没有鬼魂元素）。   
* [1.x.7]
* [1.x.8] 由于具有hp-capabilities的DoFHandler对象上的数据与许多不同的FiniteElement对象相关联，每个单元的数据都必须用其相应的`future_fe_index`来处理。此外，如果涉及到细化，数据将以其`future_fe_index`打包在父单元上，随后以相同的索引在子单元上解包。    如果单元被粗化为一个，数据将被打包在子单元上，以其共同子空间中最不占优势的有限元，并在父单元上以这个特定的有限元进行解包（更多信息请参考[2.x.4] ）。        在细化过程中转移解决方案的工作方式与非hp情况下完全相同。然而，当考虑序列化时，我们还必须在一个额外的步骤中存储活动FE指数。下面提供了一个代码片段，演示了使用[2.x.5]类与具有hp-capabilities的DoFHandler对象进行序列化。这里VectorType是你喜欢的向量类型，例如[2.x.6] [2.x.7]或相应的块向量。        如果向量有本地相关的DoF，序列化工作如下。   
* [1.x.9]
* 对于反序列化，向量需要是一个分布式向量（没有鬼魂元素）。   
* [1.x.10]
* [1.x.11] 从本质上讲，这个类实现了与[2.x.8]相同的步骤（尽管实现完全是独立的）。因此，这个类会发生与[2.x.9]相同的挂起节点和粗化的问题，见那里的扩展讨论。       
* [2.x.10]     
* [0.x.1]*
       构造函数。             [2.x.11] dof 所有操作都将发生在它上面的DoFHandler。        在这个构造函数被调用的时候，DoFHandler仍然指向有关细化发生之前的三角结构。     
* [0.x.2]*
       解构器。     
* [0.x.3]*
       为粗化和细化的当前对象做准备。它存储每个单元的dof指数，并在每个将被粗化的单元中存储[2.x.12]中向量的dof值。 [2.x.13]包括所有将被内插到新的（细化和/或粗化的）网格上的向量。     
* [0.x.4]*
       与前面的函数相同，但只对一个离散函数进行内插。     
* [0.x.5]*
       在细化或粗化网格之前，将先前存储在此对象中的数据插值到当前的单元格组中。对提供给prepare_for_coarsening_and_refinement()的每个向量进行插值，并将结果写入给定的向量集中。     
* [0.x.6]*
       与前一个函数相同。它只对一个函数进行插值。它假定向量有正确的大小（即<tt>in.size()==n_dofs_old</tt>, <tt>out.size()==n_dofs_refined</tt>）。            不允许多次调用此函数。通过使用<tt>interpolate (all_in, all_out)</tt>，可以在一个步骤中执行多个函数的插值。     
* [0.x.7]*
       准备对给定的矢量进行序列化。序列化由[2.x.14]完成，给定的向量需要本地活动DoF的所有信息（必须是重影的）。更多信息请参见该类的文档。     
* [0.x.8]*
       和上面的函数一样，只是针对一个向量的列表。     
* [0.x.9]*
       执行给定向量的反序列化。这需要在调用[2.x.15]后进行，给定的向量必须是一个完全分布的向量，没有重影元素。更多信息请参见该类的文档。     
* [0.x.10]*
       和上面的函数一样，只是针对一个向量列表。     
* [0.x.11]*
       指向自由度处理程序的指针，用于工作。     
* [0.x.12]*
       一个存储指向所有我们应该从旧网格复制到新网格的向量的指针。     
* [0.x.13]*
       Triangulation分配给这个对象的句柄，我们可以用它来访问我们的内存偏移和我们的打包函数。     
* [0.x.14]*
       一个回调函数，用于将当前网格上的数据打包成对象，以后可以在细化、粗化和重新划分后进行检索。     
* [0.x.15]*
       一个回调函数，用来解开当前网格上的数据，这些数据在细化、粗化和重新划分之前，已经被打包在网格上了。     
* [0.x.16]*
       将pack_callback()函数注册到已经分配给DoFHandler类成员的[2.x.16]，并存储返回的句柄。     
* [0.x.17]*
        [2.x.17] 使用没有DoFHandlerType模板的[2.x.18]代替。     
* [0.x.18]

