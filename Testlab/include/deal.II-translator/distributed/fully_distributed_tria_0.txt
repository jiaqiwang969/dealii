include/deal.II-translator/distributed/fully_distributed_tria_0.txt
[0.x.0]*
   一个用于全分布式三角测量的命名空间。   
* [2.x.0]   
* [0.x.1]*
     一个具有分布式粗网格的分布式三角测量。        [2.x.1]的动机源于以下关于复杂几何体和/或由外部网格生成器创建的给定网格的观察。我们认为复杂的几何体是指只能用不可忽略的粗单元数量（>10,000）来进行网格划分的几何体。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - 从内存的角度来看，在每个进程上存储粗网格信息过于昂贵（如[2.x.2]所做的那样 通常，一个进程只需要全局三角图的一小部分，即粗网格的一小部分，这样，粗网格的分区确实是必要的。每个进程上存储的单元由[2.x.3]"本地拥有的单元 "和[2.x.4]"幽灵单元 "组成。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 活动细胞的分布
* 
* - 在最精细的层面上
* 
* - 通过简单地划分空间填充曲线在所有进程中的分布，对于源自大的粗网格的三角形来说，可能不会导致最佳结果：例如，属于同一进程的分区可能是不连续的，导致通信量增加（在一个节点内部和外部）。基于图的分区算法可能是[2.x.5]所使用的空间填充曲线的一个合理的替代方案。为了能够构建一个完全分区的三角形，分配粗网格并给出关于分区的灵活性，需要以下成分。
* 

* 
* 

* 
 

 
 

 
 

 
* 
* - 一个本地相关的粗网格三角图（顶点、单元格定义；包括一层幽灵单元格
 

 
 

 
 

 
 

 
 

 
* 
* - 本地相关的粗网格三角图到全球粗网格三角图的映射
 

* 
* 

* 
 

 
 

 
 

 
* 
* - 关于哪个单元应该被细化的信息，以及关于每个单元的子域_id、水平_子域_id、流形_id和边界_id的信息。        上面列出的成分被捆绑在结构[2.x.6]中，用户必须填写这个数据结构
* 
* - 在一个预处理步骤中
* 
* - 在实际创建三角测量之前。创建[2.x.7]的预定义函数可以在命名空间[2.x.8]中找到。一旦[2.x.9] `construction_data`被构建，就可以通过调用`tria.create_triangulation(construction_data);`来创建三角形`。       
* [2.x.10] 这个三角图支持。1D/2D/3D，悬挂节点，几何多网格，以及周期性。       
* [2.x.11] 你可以用create_triangulation()创建一个具有悬空节点和多网格层次的三角形。然而，一旦它被创建，就不能再被改变，也就是说，你不能在之后进行粗化或细化。       
* [2.x.12] 目前只有简单的周期性条件（即没有偏移量和旋转矩阵
* 
* - 也可参见[2.x.13]的文档。   
* [0.x.2]*
       构造函数。             [2.x.14] mpi_communicator 用于三角测量的MPI通信器。     
* [0.x.3]*
       解构器。     
* [0.x.4]*
        [2.x.15] [2.x.16] [2.x.16].             
* [2.x.17] 这是用于代替[2.x.18]的函数，用于处理.II的一些其他三角计算。     
* [0.x.5]*
      
* [2.x.19] 这个函数没有为这个类实现，并抛出一个断言。相反，使用其他create_triangulation()函数来创建三角形。     
* [0.x.6]*
       实现与基类中相同的函数。             [2.x.20] other_tria 要复制的三角图。它可以是一个序列三角形，也可以是一个 [2.x.21] 两者都可以已经被完善。           
* [2.x.22] 这个函数使用用set_partitioner()注册的分区器。     
* [0.x.7]*
       注册一个分区器，在copy_triangulation方法中使用。             [2.x.23] partitioner 一个分区函数，它的输入参数是对要分区的三角形的引用和要创建的分区的数量。                         该函数需要为给定三角形的每个活动单元设置子域ID，其值在零（包括）和函数的第二个参数（排他）之间。       [2.x.24] 设置 参见设置枚举器的描述。           
* [2.x.25]默认情况下，[2.x.26]被用作分区器，不设置多网格层次上的数据结构。     
* [0.x.8]*
       根据设置的细化和粗化标志，粗化和细化网格。           
* [2.x.27]还没有实现。     
* [0.x.9]*
       覆盖基类中prepare_coarsening_and_refinement的实现。           
* [2.x.28] 还没有实现。     
* [0.x.10]*
       如果三角形有悬空节点，返回true。           
* [2.x.29] 还没有实现。     
* [0.x.11]*
       返回本地内存消耗的字节数。     
* [0.x.12]*
       将三角图保存到给定的文件中。这个文件需要在一个共享的网络文件系统上，从计算中的所有节点都可以到达。参见SolutionTransfer类，了解如何将解决方案向量存储到这个文件中。其他基于单元的数据可以用register_data_attach()来保存。     
* [0.x.13]*
       将用save()保存的三角剖面加载回来。在调用这个函数之前，网格必须是空的。            你需要用与保存时相同数量的MPI进程来加载，因此自动分区功能被禁用。            用register_data_attach()保存的基于单元的数据可以在调用load()后用notify_ready_to_unpack()读入。     
* [0.x.14]*
       遍历所有属于本地的活动单元，并在私有成员向量local_cell_relations中记录它们将如何变化。            由于该类目前不支持自适应网格细化，所有的单元将被标记为CellStatus CELL_PERSIST。      这些关系目前只用于序列化。            存储的向量的大小将等于本地拥有的活动单元的数量，并将按照这些单元的出现率排序。     
* [0.x.15]*
       存储设置。     
* [0.x.16]*
       copy_triangulation()中使用的分区器。     
* [0.x.17]*
       成对的粗略单元ID及其索引的排序列表。     
* [0.x.18]*
       每个粗放单元的粗放单元ID的列表（存储在cell->index()）。     
* [0.x.19]*
       表示函数create_triangulation()被调用为内部使用的布尔值。     
* [0.x.20]*
       表示函数prepare_coarsening_and_refinement()被调用用于内部使用的布尔值。     
* [0.x.21]

