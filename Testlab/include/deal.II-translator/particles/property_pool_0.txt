include/deal.II-translator/particles/property_pool_0.txt
[0.x.0]*
   用于粒子的索引的类型。虽然在顺序计算中，40亿个32位无符号整数的索引已经足够了，但使用数百个进程的并行计算会溢出这个数字，我们需要一个更大的索引空间。我们在这里利用了控制自由度指数的同一个构建变量，因为自由度的数量和粒子的数量通常在同一个数量级上。    数据类型总是表示无符号整数类型。 
* [0.x.1]*
   一个标识符，表示与[2.x.0]相关的MPI类型。  
* [0.x.2]*
   用于粒子的索引的类型。虽然在顺序计算中，40亿个32位无符号整数的索引已经足够了，但使用数百个进程的并行计算会溢出这个数字，我们需要一个更大的索引空间。我们在这里利用了控制自由度指数的同一个构建变量，因为自由度的数量和粒子的数量通常在同一个数量级上。    数据类型总是表示无符号整数类型。 
* [0.x.3]*
   一个标识符，表示与[2.x.1]相关的MPI类型。  
* [0.x.4]*
   这个类管理着一个内存空间，与ParticleHandler相关的所有粒子都在其中存储它们的属性。它还存储粒子的位置和参考位置。    这个类的基本原理是，因为通常每个粒子都存储相同数量的属性，并且因为算法通常会遍历所有的粒子，对所有粒子的属性进行相同的操作，所以让用于属性的内存由一个中央管理器来处理会更有效率。  这样，粒子就不会存储一个指向它们存储属性的内存区域的指针，而是一个 "句柄"，然后PropertyPool类将其转化为指向具体内存的指针。    综上所述，目前的实现只提供了这种接口，但仍然对粒子所要求的每一组属性使用简单的新建/删除分配。此外，目前的实现假设每个粒子的属性数量相同，但当然PropertyType可以包含一个指向动态分配的内存的指针，每个粒子的大小不同（这个内存不会被这个类所管理）。 
* [0.x.5]*
     返回给粒子的句柄的类型定义，该句柄唯一地标识了为该粒子保留的内存槽。   
* [0.x.6]*
     为句柄定义一个默认（无效）值。   
* [0.x.7]*
     构造器。存储每个保留槽的属性数量。   
* [0.x.8]*
     解构器。这个函数确保之前使用allocate_properties_array()分配的所有内存也已经通过deallocate_properties_array()返回。   
* [0.x.9]*
     清除这个类所分配的动态内存。这个函数确保之前使用allocate_properties_array()分配的所有内存也已经通过deallocate_properties_array()返回。   
* [0.x.10]*
     返回一个新的句柄，允许粒子存储诸如属性和位置等信息。这也是在这个PropertyPool变量中分配内存。   
* [0.x.11]*
     返回一个通过register_particle()获得的句柄，并将分配给存储粒子数据的内存标记为空闲，以便重新使用。   
* [0.x.12]*
     返回由给定的`handle'标识的粒子的位置。   
* [0.x.13]*
     设置由给定的`handle'标识的粒子的位置。   
* [0.x.14]*
     返回由给定的 "handle "标识的粒子的参考位置。   
* [0.x.15]*
     设置由给定的 "handle "标识的粒子的参考位置。   
* [0.x.16]*
     返回由给定的`handle'标识的这个粒子的ID号。   
* [0.x.17]*
     设置由给定的 "handle "标识的这个粒子的ID号。   
* [0.x.18]*
     返回一个ArrayView给定句柄所对应的属性 [2.x.2]     
* [0.x.19]*
     预留储存[2.x.3]粒子的属性所需的动态内存。   
* [0.x.20]*
     返回池中每个槽位存储的属性数量。   
* [0.x.21]*
     每个粒子保留的属性数量。   
* [0.x.22]*
     一个存储粒子位置的向量。它的索引方式与`reference_locations`和`properties`数组相同，也就是通过句柄。   
* [0.x.23]*
     一个存储粒子参考位置的向量。它的索引方式与`locations`和`properties`数组相同，即通过句柄。   
* [0.x.24]*
     一个存储粒子的唯一标识符的向量。它的索引方式与`位置`和`属性`数组的索引方式相同，即通过句柄。   
* [0.x.25]*
     当前分配的属性（无论是分配给粒子的还是可分配的）。它的索引方式与`locations`和`reference_locations`数组相同，通过句柄。   
* [0.x.26]*
     由allocate_properties_array()创建并由deallocate_properties_array()销毁的句柄的集合。由于内存仍然被分配，这些句柄可以被重新用于新的粒子以避免内存分配。   
* [0.x.27]

