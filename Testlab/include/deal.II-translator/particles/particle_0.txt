include/deal.II-translator/particles/particle_0.txt
[0.x.0]*
 一个命名空间，包含所有与粒子实现相关的类，特别是基本的粒子类。

* 
* [0.x.1]*
     电池级别/索引对的内部别名。   
* [0.x.2]*
   一个代表领域中的粒子的类，该领域由某种三角形网格组成。这个类所存储的数据是粒子在整体空间中的位置，粒子在它当前所在的单元的参考坐标系中的位置，一个在所有粒子中唯一的ID号，以及一个数量可变的 "属性"。    附在该类每个对象上的 "属性 "由一个PropertyPool对象存储。这些属性被存储为一个 "双 "变量数组，可以通过ArrayView对象访问。例如，如果人们想给每个粒子配备一个 "温度 "和 "化学成分 "属性，这些属性会随着粒子的移动而移动（例如，可能会根据一些微分方程在不同的时间步长上发生变化），那么人们会在PropertyPool对象中给每个粒子分配两个属性。    然而，在实践中，人们经常希望将属性与粒子联系起来，而不是像上面的情况那样只是独立的数字。一个例子是，如果人们想要跟踪一个粒子所受到的应力或应变
* 
*--一个张量值的量。在这些情况下，人们会将[1.x.0]这些标量属性作为[1.x.1]。换句话说，我们首先会告诉PropertyPool为每个粒子分配尽可能多的属性，就像我们想要追踪的张量中的成分一样，然后编写小的转换函数，将get_properties()函数返回的标量属性的ArrayView转换为适当类型的张量。然后，这可以在每个时间步骤中被评估和演化。第二个转换函数将从张量转换回ArrayView对象，通过set_properties()函数将更新的数据存储回粒子中。    当然，在有些情况下，人们关心的属性不是实数（或者在计算机中是浮点），而是分类的。例如，人们可能想把一些粒子标记为 "红色"、"蓝色 "或 "绿色"。然后，该属性可能被表示为一个整数，或作为 "enum "的一个元素。在这些情况下，人们需要想出一种方法来[1.x.2]这些分类字段的浮点数字。例如，我们可以将 "红色 "映射到浮点数1.0，"蓝色 "映射到2.0，"绿色 "映射到3.0。那么，在这两种表示法之间进行转换的转换函数应该也不是很难写。   
* [2.x.0]   
* [0.x.3]*
     粒子的空构造函数，在原点创建一个粒子。   
* [0.x.4]*
     粒子的构造函数。这个函数在指定的位置创建一个具有指定ID的粒子。注意，没有对重复的粒子ID进行检查，所以用户必须确保在所有进程中ID是唯一的。数据被存储在一个全局的PropertyPool对象中（对应于全局的 "堆"），但以后可以通过调用set_property_pool()转移到另一个属性池。         [2.x.1] location 粒子的初始位置。     [2.x.2] reference_location 粒子在参考单元的坐标系中的初始位置。     [2.x.3] id 粒子的全球唯一ID号。   
* [0.x.5]*
     粒子的复制构造器。这个函数创建一个与输入参数的状态完全相同的粒子。复制的数据存储在一个全局的PropertyPool对象中（对应于全局的 "堆"），但以后可以通过调用set_property_pool()转移到另一个属性池。   
* [0.x.6]*
     粒子的构造函数。这个函数从一个数据矢量创建一个粒子。数据被存储在一个全局PropertyPool对象中（对应于全局 "堆"），但以后可以通过调用set_property_pool()转移到另一个属性池中。这个构造函数通常在通过调用write_data()函数对粒子进行序列化之后被调用。         [2.x.4] begin_data 一个指向内存位置的指针，可以从中读取完全描述一个粒子的信息。然后这个类从这个内存位置反序列化它的数据，并将指针推进到已经读过的数据之外，以初始化粒子信息。         [2.x.5] property_pool 一个可选的指向属性池的指针，用于管理这个粒子所使用的属性数据。如果没有提供这个参数，那么就会使用一个全局属性池；另一方面，如果提供了一个非空的指针，那么这个构造函数就会假设[2.x.6]包含了由[2.x.7]分配的相同长度和类型的序列化数据。 如果这里提供的数据指针对应于有属性的粒子的数据，那么这个函数只有在提供一个属性池作为第二个参数，能够存储每个粒子正确数量的属性时才会成功。   
* [0.x.7]*
     粒子的移动构造函数，通过窃取现有粒子的状态来创建一个粒子。   
* [0.x.8]*
     复制赋值运算符。   
* [0.x.9]*
     移动赋值运算符。   
* [0.x.10]*
     销毁器。如果属性句柄是有效的，则将其释放，从而为其他粒子释放内存空间。注意：内存是由属性池管理的，属性池负责对内存的处理。   
* [0.x.11]*
     将粒子数据写入一个数据阵列。这个数组应该足够大，可以容纳这些数据，无效指针应该指向数组的第一个条目，这些数据应该被写入该数组。这个函数是用来序列化所有的粒子属性，然后通过调用适当的构造函数来反序列化这些属性 Particle(void&data, PropertyPoolproperty_pool = nullptr); [2.x.8] [in] data 要写进粒子数据的内存位置。         [2.x.9] 指向已写入数据的阵列后的下一个字节的指针。   
* [0.x.12]*
     通过使用一个数据数组来更新与粒子相关的所有数据：ID、位置、参考位置，如果有的话，还有属性。这个数组应该足够大，以容纳这些数据，而且空指针应该指向数组的第一个条目，这些数据应该被写入这个数组中。这个函数是用来反序列化粒子数据的，不需要建立一个新的粒子类。这在ParticleHandler中被用来更新幽灵粒子，而不需要取消分配和重新分配内存。         [2.x.10] data 一个指向内存位置的指针，可以从中读取完全描述一个粒子的信息。然后这个类从这个内存位置去序列化它的数据。         [2.x.11]一个指向从该阵列中读取数据后的下一个字节的指针。   
* [0.x.13]*
     设置这个粒子的位置。注意，这并不检查这是否是模拟域中的有效位置。         [2.x.12] [in] new_location 这个粒子的新位置。       
* [2.x.13] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元以及幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.14]"具有幽灵元素的向量 "或[2.x.15]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.14]*
     获取这个粒子的位置。         [2.x.16] 这个粒子的位置。   
* [0.x.15]*
     设置此粒子的参考位置。         [2.x.17] [in] new_reference_location 这个粒子的新参考位置。       
* [2.x.18] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.19]"具有幽灵元素的向量 "或[2.x.20]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.16]*
     返回这个粒子在其当前单元中的参考位置。   
* [0.x.17]*
     返回这个粒子的ID号。粒子的ID是一个即使在并行计算中也是全局唯一的属性，如果它从当前处理器拥有的单元移动到另一个处理器拥有的单元，或者它所在的单元的所有权被转移到另一个处理器，那么它的ID将与粒子的其他属性一起被转移。   
* [0.x.18]*
     设置这个粒子的ID号。粒子的ID旨在成为一个全局唯一的属性，即使在并行计算中也是如此，如果它从当前处理器拥有的单元移动到另一个处理器拥有的单元，或者它所在的单元的所有权被转移到另一个处理器，那么它的ID将与粒子的其他属性一起转移。因此，在设置粒子的ID时，需要注意确保粒子具有全球唯一的ID。(ParticleHandler本身并不检查如此设置的粒子ID在并行设置中是否是全局唯一的，因为这将是一个非常昂贵的操作。)          [2.x.21] new_id 这个粒子的新ID号。       
* [2.x.22] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.23]"具有幽灵元素的向量 "或[2.x.24]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作 "const "对象，不应该被修改，即使这些对象允许修改属性的调用。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.19]*
     告诉粒子在哪里存储它的属性（即使它并不拥有属性）。通常情况下，每个粒子只做一次，但是由于粒子不知道属性，我们希望在构造时不做。这个函数的另一个用途是在粒子转移到一个新进程之后。        如果一个粒子已经在一个属性池中存储了属性，那么它们的值就会被保存下来，之前的属性池中的内存会被释放，而这个粒子的属性副本将被分配到新的属性池中。   
* [0.x.20]*
     返回这个粒子是否有一个有效的属性池和一个有效的属性句柄。   
* [0.x.21]*
     设置此粒子的属性。         [2.x.25] [in] new_properties 一个包含此粒子的新属性的ArrayView。       
* [2.x.26] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.27]"具有幽灵元素的向量 "或[2.x.28]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.22]*
     获得对这个粒子的属性的写入权限。如果粒子还没有属性，但可以访问PropertyPool对象，它将分配属性以允许写入它们。如果它没有属性，也不能访问一个PropertyPool，这个函数将抛出一个异常。         [2.x.29] 这个粒子的属性的ArrayView。   
* [0.x.23]*
     获取对该粒子的属性的读取权限。如果粒子没有属性，这个函数会抛出一个异常。         [2.x.30] 此粒子的属性的ArrayView。   
* [0.x.24]*
     返回这个粒子在所有数据被序列化的情况下所占的字节数（即这个类的write_data函数所写入的字节数）。   
* [0.x.25]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写到一个流中，以便进行序列化。   
* [0.x.26]*
     为了序列化的目的，使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从流中读取此对象的数据。    请注意，为了正确地存储属性，在读取时必须知道这个粒子的属性库，即在调用这个函数之前，必须调用set_property_pool()。   
* [0.x.27]*
     释放属性池的内存    
* [0.x.28]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从一个流中写入和读取此对象的数据，以便进行序列化。   
* [0.x.29]*
     一个全局属性池，当一个粒子没有与属于例如ParticleHandler的属性池相关联时使用。   
* [0.x.30]*
     一个指向属性池的指针。从句柄到实际内存位置的转换是必要的。   
* [0.x.31]*
     一个指向所有粒子属性的句柄    
* [0.x.32]*
       确保我们可以构建一个[2.x.31]对象的RTree。     
* [0.x.33]*
          [2.x.32]期望一个可索引对象的常量引用。对于一个[2.x.33]对象，这是它的引用位置。       
* [0.x.34]

