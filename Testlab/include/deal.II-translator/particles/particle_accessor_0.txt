include/deal.II-translator/particles/particle_accessor_0.txt
[0.x.0]*
   ParticleIterator使用的访问器类，用于访问粒子数据。 
* [0.x.1]*
      [2.x.0] [2.x.1].     
* [0.x.2]*
      [2.x.2] [2.x.3].     
* [0.x.3]*
     设置这个粒子的位置。注意，这并不检查这是否是模拟域中的有效位置。         [2.x.4] [in] new_location 这个粒子的新位置。       
* [2.x.5] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元以及幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.6]"具有幽灵元素的向量 "或[2.x.7]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.4]*
     获取这个粒子的位置。         [2.x.8] 这个粒子的位置。   
* [0.x.5]*
     设置此粒子的参考位置。         [2.x.9] [in] new_reference_location 这个粒子的新参考位置。       
* [2.x.10] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.11]"具有幽灵元素的向量 "或[2.x.12]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.6]*
     返回这个粒子在其当前单元中的参考位置。   
* [0.x.7]*
     返回这个粒子的ID号。   
* [0.x.8]*
     告诉粒子在哪里存储它的属性（即使它不拥有属性）。通常情况下，每个粒子只做一次，但是由于粒子生成器不知道属性，我们希望在构造时不做。这个函数的另一个用途是在粒子转移到一个新进程之后。   
* [0.x.9]*
     返回这个粒子是否有一个有效的属性库和一个有效的属性句柄。   
* [0.x.10]*
     设置此粒子的属性。         [2.x.13] [in] new_properties 一个包含此粒子的新属性的向量。       
* [2.x.14] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.15]"具有幽灵元素的向量 "或[2.x.16]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.11]*
     设置这个粒子的属性。         [2.x.17] [in] new_properties 一个ArrayView，指向包含此粒子的新属性的内存位置。       
* [2.x.18] 在并行程序中，ParticleHandler类将粒子存储在本地拥有的单元上，以及在幽灵单元上。后者上的粒子是其他处理器上拥有的粒子的副本*，因此应该以与[2.x.19]"具有幽灵元素的向量 "或[2.x.20]"幽灵单元 "中的幽灵条目相同的方式处理。在这两种情况下，应该把鬼魂元素或单元格当作`const`对象，即使这些对象允许修改属性的调用，也不应该被修改。相反，属性应该只在实际拥有*粒子的处理器上被修改。   
* [0.x.12]*
     获得对这个粒子的属性的写访问权。         [2.x.21] 这个粒子的属性的ArrayView。   
* [0.x.13]*
     获取对该粒子的属性的读取权限。         [2.x.22] 此粒子的属性的ArrayView。   
* [0.x.14]*
     返回这个粒子在所有数据被序列化的情况下所占的字节数（即这个类的write_data函数所写入的字节数）。   
* [0.x.15]*
     获取当前粒子周围的单元格的迭代器。    由于粒子是以三角形的结构组织的，但是三角形本身并不存储在粒子中，所以这个操作需要对三角形的引用。   
* [0.x.16]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)对该类的内容进行序列化。   
* [0.x.17]*
     将ParticleAccessor推进到下一个粒子。   
* [0.x.18]*
     将ParticleAccessor移动到前一个粒子。   
* [0.x.19]*
     不等式运算符。   
* [0.x.20]*
     等价运算符。   
* [0.x.21]*
     构建一个无效的访问器。这样的对象是不能使用的。   
* [0.x.22]*
     从对地图的引用和对地图的迭代器构造一个访问器。这个构造函数是`private`的，所以它只能被朋友类访问。   
* [0.x.23]*
     一个指向存储粒子的容器的指针。很明显，如果容器发生变化，这个访问器就会失效。   
* [0.x.24]*
     一个进入粒子容器的迭代器。很明显，如果容器发生变化，这个访问器就会失效。   
* [0.x.25]*
       确保我们可以从[2.x.23]对象中构建一个RTree。     
* [0.x.26]*
          [2.x.24]期望一个可索引对象的常量引用。对于一个[2.x.25]对象，这是它的引用位置。       
* [0.x.27]

