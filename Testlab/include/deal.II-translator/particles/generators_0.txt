include/deal.II-translator/particles/generators_0.txt
[0.x.0]*
   一个命名空间，包含所有与粒子生成有关的类。 
* [0.x.1]*
     一个在指定的[2.x.0]的每个单元中生成粒子的函数 被添加到[2.x.1]对象中的粒子总数是[2.x.2]的本地拥有的单元数乘以[2.x.3]中的位置数 一个可选的[2.x.4]参数可用于从[2.x.5]映射到真实的粒子位置。         [2.x.6] triangulation 与[2.x.7]相关的三角形。 [2.x.8] particle_reference_locations 单元格中的一个位置矢量。    粒子将在每个单元格中的这些位置生成。         [2.x.9] particle_handler 粒子处理程序，它将负责生成的粒子的所有权。         [2.x.10] mapping 一个可选的映射对象，用于将单元格中的参考位置映射到三角形的真实单元。如果没有提供映射，则假定有MappingQ1。   
* [0.x.2]*
     一个在单元格[2.x.11]中的随机位置生成一个粒子的函数，其索引为[2.x.12]。该函数希望有一个随机数发生器，以避免为每个粒子生成和销毁一个发生器的昂贵费用，并且可以选择考虑到单元格的映射。在该函数中实现的算法在 [2.x.13] 中有描述。简而言之，该算法在[2.x.14]的边界框内生成随机位置，然后反转映射以检查生成的粒子是否在细胞本身内。这确保了该算法即使对于非线性映射和扭曲的单元格也能产生统计学上的随机位置。然而，如果界线盒和单元格体积之间的比率变得非常大的话
* 
* - 即细胞变得强烈变形，例如一个铅笔形状的细胞位于域的对角线上
* 
* - 那么该算法可能会变得非常低效。    因此，在抛出错误信息之前，它只尝试找到一个固定次数的单元格位置。         [2.x.15] cell 生成粒子的单元。         [2.x.16] id 将被分配给新粒子的粒子索引。         [2.x.17] random_number_generator 将用于创建粒子的随机数发生器。         [2.x.18] mapping 一个可选的映射对象，用于将单元格中的参考位置映射到真实单元格。如果没有提供映射，则假定有MappingQ1。   
* [0.x.3]*
     一个根据所提供的概率密度函数[2.x.19]在域中随机生成粒子密度的函数，添加到[2.x.20]对象中的粒子总数为[2.x.21] 一个可选的[2.x.22]参数可用于从[2.x.23]映射到真实粒子位置。    该函数可以通过计算每个单元的概率密度函数的积分并相应地创建粒子来确定每个单元的粒子数（如果选项[2.x.24]设置为false），或者它可以根据概率密度函数和单元大小随机选择单元（如果选项[2.x.25]设置为true）。在这两种情况下，细胞内单个粒子的位置都是随机计算的。        该函数中实现的算法在 [2.x.26] 中有描述。         [2.x.27] triangulation 与 [2.x.28] [2.x.29] probability_density_function 与非负值有关的函数，决定在这个位置生成粒子的概率密度。该函数不需要被归一化。         [2.x.30] random_cell_selection 一个bool，决定如何计算每个单元的粒子数（见上面的描述）。         [2.x.31] n_particles_to_create 这个函数将创建的粒子的数量。         [2.x.32] particle_handler（粒子处理程序） 将对生成的粒子拥有所有权的粒子处理程序。         [2.x.33] mapping 一个可选的映射对象，用于将单元格中的参考位置映射到三角形的实际单元。如果没有提供映射，则假定是MappingQ1。         [2.x.34] random_number_seed 一个可选的种子，决定随机数发生器的初始状态。使用相同的数字来获得可重复的粒子分布，或者使用一个变化的数字（例如基于系统时间）来为每次对该函数的调用产生不同的粒子分布。   
* [0.x.4]*
     一个在DoFHandler的支持点位置生成粒子的函数，可能是基于与用于构建ParticleHandler的三角图不同的三角图。    被添加到[2.x.35]对象中的粒子总数是被传递的DoFHandler中位于三角形内且其组件位于ComponentMask内的dofs数量。    这个函数使用insert_global_particles，因此可能会引起相当大的mpi通信开销。        这个函数在 [2.x.36] 中使用。         [2.x.37] dof_handler 一个DOF处理程序，可能存在于另一个三角形上，用于确定粒子的位置。         [2.x.38] global_bounding_boxes 一个包含所有处理器的所有边界盒的向量。这个向量可以通过首先使用[2.x.39]来建立，然后使用[2.x.40]来收集所有的边界框。 [2.x.41] particle_handler 粒子处理程序，将负责生成的粒子的所有权。生成的粒子将被附加到当前由粒子处理程序拥有的粒子上。         [2.x.42] mapping 一个可选的映射对象，用于映射DOF位置。如果没有提供映射，则假定是MappingQ1。         [2.x.43] components 决定使用哪个支持点的dof_handler的子集来生成粒子的组件掩码。         [2.x.44] properties 每个要插入的粒子的可选属性向量。   
* [0.x.5]*
     一个在Triangulation的正交点位置生成粒子的函数。这个三角图可以不同于用于构造ParticleHandler的三角图。    被添加到[2.x.45]对象中的粒子总数是单元格的数量乘以粒子参考位置的数量，这些参考位置通常是用正交点构建的。    这个函数使用insert_global_particles，因此可能引起相当大的mpi通信开销。         [2.x.46] triangulation 可能是不匹配的三角形，用于将粒子插入域中。         [2.x.47] 正交法 一个正交法，其参考位置用于在单元中插入粒子。         [2.x.48] global_bounding_boxes 一个包含所有处理器的所有边界盒的向量。这个向量可以通过首先使用[2.x.49]来建立，并使用[2.x.50]来收集所有的边界框。 [2.x.51] particle_handler 粒子处理程序，它将负责生成的粒子的所有权。         [2.x.52] mapping 一个可选的映射对象，用于映射正交位置。如果没有提供映射，则假定有MappingQ1。         [2.x.53] properties 一个可选的矢量，用于插入每个粒子的属性矢量。   
* [0.x.6]

