include/deal.II-translator/meshworker/simple_0.txt
[0.x.0] 包含[2.x.0][2.x.1][2.x.2]和[2.x.3]类的页眉。

 
* [0.x.1]*
     组装残差，没有块状结构。        这个汇编器类的数据结构是每个单元上的一个简单向量，条目从零到[2.x.4]，以及一个简单的全局向量，条目编号从零到[2.x.5]，不需要BlockInfo，全局向量可以是任何类型的向量，通过<tt>operator() (unsigned int)</tt>有元素访问。       
* [2.x.6]     
* [0.x.2]*
       用一个AnyData对象初始化，该对象保存着组装的结果。            组装目前写入<tt>results</tt>的第一个向量中。     
* [0.x.3]*
       初始化约束。     
* [0.x.4]*
       初始化以后用于装配的DoFInfo对象中的本地数据。            如果[2.x.7]对象指的是一个单元格，如果[2.x.8]，则指的是一个内部或边界面。     
* [0.x.5]*
       将局部残差组合成全局残差。            数值被添加到之前的内容中。如果约束被激活，则使用[2.x.9]。     
* [0.x.6]*
       将两个局部残差组合成全局残差。     
* [0.x.7]*
       由assemble()填充的全局残差向量。     
* [0.x.8]*
       一个指向包含约束的对象的指针。     
* [0.x.9]*
     将本地矩阵组装成一个单一的全局矩阵或与同一DoFHandler相关的几个全局矩阵。如果这些全局矩阵有块状结构，则不使用该结构，而是使用全局自由度的编号。        在用一个SparseMatrix对象（或另一个提供相同功能的矩阵[2.x.10]或一个这样的向量）初始化后，这个类可以在[2.x.11]中使用，将单元和面的矩阵组合成全局矩阵。        如果在初始化过程中提供了一个AffineConstraints，这个矩阵将被用来[2.x.12]准确地说）将局部矩阵输入到全局稀疏矩阵。        汇编器可以处理两种不同类型的局部数据。首先，默认情况下，明显的选择是取一个单一的局部矩阵，其尺寸等于单元的自由度数。    或者，可以在DoFInfo中初始化一个局部块结构。    在这之后，本地数据将被排列成一个由n乘n的FullMatrix块组成的数组（n是DoFInfo中DoFHandler使用的FES系统中的块数），这些块在DoFInfo中以列索引最快的方式排序。如果矩阵被初始化为几个矩阵的向量，并且使用了本地块结构，那么LocalResults中的前n<sup>2</sup>个矩阵将被用于该向量中的第一个矩阵，第二组n<sup>2</sup>个矩阵，以此类推。       
* [2.x.13]     
* [0.x.10]*
       构造函数，初始化#阈值，它限制了可以进入矩阵的小数字。     
* [0.x.11]*
       存储结果矩阵，以便以后进行组装。     
* [0.x.12]*
       存储几个结果矩阵供以后组装。     
* [0.x.13]*
       初始化约束。在用一个有效的AffineConstraints对象调用此函数后，函数[2.x.14]将被assemble()用来将单元和面矩阵分配到一个全局稀疏矩阵中。     
* [0.x.14]*
       初始化以后用于装配的DoFInfo对象中的局部数据。            如果[2.x.15]对象指的是一个单元格，如果[2.x.16]，则指的是一个内部或边界面。     
* [0.x.15]*
       将与单个单元相关的局部矩阵组装成全局矩阵。     
* [0.x.16]*
       将[2.x.17]和[2.x.18]对象中与一个内部面相关的所有局部矩阵组装到全局矩阵中。     
* [0.x.17]*
       正在组装的全局矩阵的向量。     
* [0.x.18]*
       将被输入全局矩阵的最小正数。所有更小的绝对值将被视为零，不会被装配。     
* [0.x.19]*
       将单个矩阵[2.x.19]装配到向量#matrix中[2.x.20]处的元素。     
* [0.x.20]*
       一个指向包含约束的对象的指针。     
* [0.x.21]*
     将局部矩阵组装成水平矩阵，而不使用块结构。         [2.x.21] 用局部细化和连续元素组装水平矩阵所需的矩阵结构缺失。       
* [2.x.22]     
* [0.x.22]*
       构造函数，初始化#threshold，它限制了可以输入矩阵的小数字。     
* [0.x.23]*
       存储结果矩阵，以便以后进行组装。     
* [0.x.24]*
       初始化多级约束。     
* [0.x.25]*
       初始化矩阵#flux_up和#flux_down，用于不连续Galerkin方法的局部细化。     
* [0.x.26]*
       初始化矩阵#interface_in和#interface_out，用于连续Galerkin方法的局部细化。     
* [0.x.27]*
       初始化DoFInfo对象中的局部数据，以后用于装配。            如果[2.x.23]对象指的是一个单元，否则指的是一个内部或边界面。     
* [0.x.28]*
       将矩阵[2.x.25]组装成全局矩阵。     
* [0.x.29]*
       将[2.x.26]和[2.x.27]对象中的两个局部矩阵组装成全局矩阵。     
* [0.x.30]*
       将单个矩阵组装成全局矩阵。     
* [0.x.31]*
       将一个单一的矩阵组装成一个全局矩阵。     
* [0.x.32]*
       将一个单一的矩阵组合成一个全局矩阵。     
* [0.x.33]*
       将一个单一的矩阵组合成一个全局矩阵。     
* [0.x.34]*
       将一个单一的矩阵组合成一个全局矩阵。     
* [0.x.35]*
       将一个单一的矩阵组合成一个全局矩阵。     
* [0.x.36]*
       正在装配的全局矩阵。     
* [0.x.37]*
       用于细化边缘的面通量项的矩阵，将粗的耦合到细的。     
* [0.x.38]*
       用于细化边缘的面通量项的矩阵，将细化与粗化相耦合。     
* [0.x.39]*
       用于整个细化边缘的连续元素的面贡献的矩阵，耦合粗到细。     
* [0.x.40]*
       用于整个细化边缘的连续元素的面贡献的矩阵，将细化与粗化相耦合。     
* [0.x.41]*
       一个指向包含约束的对象的指针。     
* [0.x.42]*
       将被输入全局矩阵的最小正数。所有更小的绝对值将被视为零，不会被集合。     
* [0.x.43]*
     一次性组装一个简单的矩阵和一个简单的右手边。我们使用MatrixSimple和ResidualSimple的组合来实现这一点。单元和面操作者应该在LocalResults中填充矩阵和向量对象，这个类将把它们组装成矩阵和向量对象。       
* [2.x.28]     
* [0.x.44]*
       构造函数在MatrixSimple中设置阈值。     
* [0.x.45]*
       存储两个对象的数据被组装成。     
* [0.x.46]*
       初始化约束。在用一个有效的AffineConstraints对象调用此函数后，函数[2.x.29]将被assemble()用来将单元和面矩阵分配到一个全局稀疏矩阵中。     
* [0.x.47]*
       初始化以后用于装配的DoFInfo对象中的局部数据。            如果[2.x.30]对象指的是一个单元，否则指的是一个内部或边界面。     
* [0.x.48]*
       将矩阵[2.x.32]组装成全局矩阵。     
* [0.x.49]*
       将[2.x.33]和[2.x.34]对象中的两个局部矩阵组装成全局矩阵。     
* [0.x.50]*
       将单个矩阵[2.x.35]装配到向量#matrix中[2.x.36]处的元素中。     
* [0.x.51]

