include/deal.II-translator/meshworker/dof_info_0.txt
[0.x.0]*
   一个包含网格对象的几何和自由度信息的类。    这些对象中的信息通常会被某个Assembler类所使用。这也是基于网格的矩阵（通常被称为无矩阵方法）中需要的信息。    除了存储在该类中的自由度信息外，它还为在LocalResults中操作的工作对象提供本地计算空间。这个基类将在每个单元上自动被重新初始化，但初始设置由用户决定，应该在调用这个类的initialize()时完成。    该类在两种不同的模式下运行，与Assembler命名空间文档中讨论的数据模型相对应。    本地数据模型的选择由向量[2.x.0]触发，而向量通常由[2.x.1]填充。如果使用了这个函数，或者向量已经从零长度改变，那么存储在这个对象中的本地dof指数将自动重新编号以反映本地块结构。这意味着，[2.x.2]中的第一个条目将指的是系统的第一个块，然后是第二个块，依此类推。    BlockInfo对象是作为一个指针来存储的。因此，如果块结构发生变化，例如因为网格细化，DoFInfo类将自动使用新的结构。   
* [2.x.3]   
* [0.x.1]*
     当前单元上的当前面的编号。        如果[2.x.5]对象被初始化为一个单元格，那么这个数字就是[2.x.4]。   
* [0.x.2]*
     当前面上的子面的编号 如果[2.x.7]对象没有被初始化为子面，这个编号是[2.x.6]。   
* [0.x.3]*
     当前单元的DoF指数    
* [0.x.4]*
     当前单元上的DoF指数，按本地块组织。这个向量的大小是零，除非使用局部块。   
* [0.x.5]*
     设置#block_info指针的构造函数。   
* [0.x.6]*
     构造函数让#block_info指针为空，但设置#aux_local_indices。   
* [0.x.7]*
     设置当前单元格并填充[2.x.8]。    
* [0.x.8]*
     如果#单元格发生变化，设置当前面和填充[2.x.9]。   
* [0.x.9]*
     设置当前的子面，如果#单元格发生变化，则填充[2.x.10]。   
* [0.x.10]*
     切换到同一单元格的新面。不改变[2.x.11]，不重置LocalResults中的数据。   
* [0.x.11]*
     切换到同一单元的一个新的子面。不改变[2.x.12]，不重置LocalResults中的数据。   
* [0.x.12]*
     该结构指的是具有水平数据的单元，而不是活动数据。   
* [0.x.13]*
     标准构造函数，不设置任何区块索引。不推荐使用这个构造函数，但DoFInfoBox中的数组需要它。   
* [0.x.14]*
     如果#block_info没有被设置，则创建一个辅助的本地BlockIndices对象。它只包含每个单元的自由度大小的单一块。   
* [0.x.15]*
   一个捆绑单元上使用的[2.x.13]对象的类。     [2.x.14] 目前，我们为单元存储一个对象，为每个面存储两个对象。我们可以将所有与单元格本身有关的面的数据收集在一个对象中，这样可以节省一点内存和一些操作，但会牺牲一些清洁度。   
* [2.x.15]   
* [0.x.16]*
     构造函数将种子复制到所有其他对象中。   
* [0.x.17]*
     复制构造函数，取#cell并将其作为其他构造函数中的种子。   
* [0.x.18]*
     复制赋值运算符，以另一个对象为种子。   
* [0.x.19]*
     重置所有的可用标志。   
* [0.x.20]*
     在所有DOFINFO对象被适当填充后，使用ASSEMBLER对象将它们组装成全局数据。参见[2.x.16]中的可用类。   
* [0.x.21]*
     单元的数据。   
* [0.x.22]*
     里面的面的数据。   
* [0.x.23]*
     来自外部的面的数据。   
* [0.x.24]*
     一组标志，表明内部面的数据是否可用。   
* [0.x.25]*
     一组标志，表明外部面的数据是否可用。   
* [0.x.26]*
     一个标志，指定当前对象是否已被设置为有效单元。   
* [0.x.27]

