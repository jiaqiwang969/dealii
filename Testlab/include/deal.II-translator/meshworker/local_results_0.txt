include/deal.II-translator/meshworker/local_results_0.txt
[0.x.0]*
 一个用于网格循环的函数和类的集合，它是每个有限元程序中无处不在的部分。
* 这个命名空间的主力是loop()函数，它实现了对所有网格单元的完全通用循环。由于对loop()的调用由于其通用性而容易出错，对于许多应用来说，最好从[2.x.0]派生出一个类，并使用不太通用的 integration_loop()。
* loop()依赖于作为参数交给它的某些对象。这些对象有两种类型，[2.x.1]对象，如 DoFInfo 和 IntegrationInfo，以及 LocalWorker 和 IntegrationWorker 等工作对象。
* 工作者对象通常做两个不同的工作：首先，他们计算一个单元或面对全局操作的本地贡献。其次，它们将这个局部贡献集合到全局结果中，无论是函数、形式还是双线性形式。第一项工作是针对被解决的问题的，而第二项工作是通用的，只取决于数据结构。因此，工人组装成全局数据的基类在命名空间Assembler中提供。
* [1.x.0]
* 函数loop()和cell_action()需要一些参数，这些参数是模板参数。让我们在这里列出这些类的最低要求并描述它们的属性。
* [1.x.1]
* 任何具有<tt>operator++()</tt>并指向TriaAccessor或派生类的对象。
* [1.x.2]
* 关于一个实现的例子，请参考类模板DoFInfo。为了与cell_action()和loop()协同工作，DOFINFO需要遵循以下接口。

* 
* [1.x.3]
* 
* 这三个私有函数是由DoFInfoBox调用的，其他地方应该不需要。很明显，它们可以被公开，然后末尾的friend声明可能会被遗漏。
* 此外，你将需要至少一个公共构造函数。此外，DOFINFO还相当无用：需要与INTEGRATIONINFO和ASSEMBLER接口的函数。
* DOFINFO对象被聚集在一个DoFInfoBox中。在这些对象中，我们存储了对每个单元及其面的局部操作的结果。一旦所有这些信息都被收集起来，一个ASSEMBLER被用来将其组装成全局数据。
* [1.x.4]
* 这种类型在IntegrationInfoBox中得到了体现。它在INFO对象中收集单元格和面的动作的输入数据（见下文）。它为loop()和cell_action()提供以下接口。
* 

* 
* [1.x.5]
* 
* 这个类的主要目的是收集五个INFO对象，它们包含了每个单元或面所使用的临时数据。对这些对象的要求列在下面。在这里，我们只注意到需要有这5个对象的名字在上面列出。
* 两个函数模板是在cell_action()中调用的回调函数。第一个是在工作面之前调用的，第二个是在工作面之后调用的。
* [1.x.6]
* 关于这些对象的例子，请参见IntegrationInfo。它们包含了每个单元或面所需的临时数据，以计算出结果。MeshWorker只使用接口
* 

 
* [1.x.7]
* 
* [1.x.8]
* 由于loop()是相当普遍的，所以有一个专门的integration_loop()，它是一个具有简化接口的loop()的包装器。
* integration_loop()函数循环从IntegrationInfoBox对象中获取大部分需要传递给loop()的信息。它的用途在[2.x.2]中作了解释，但简而言之，它需要在单元格、内部或边界面上做局部积分的函数，它还需要一个对象（称为 "装配器"）将这些局部贡献复制到全局矩阵和右手对象中。
* 在我们能够运行积分循环之前，我们必须在我们的IntegrationWorker和assembler对象中初始化几个数据结构。例如，我们必须决定正交规则，或者我们可能需要比默认更新标志更多的东西。
* 

* 
* [2.x.3] 

* 
* [2.x.4] 

 
* [0.x.1]*
   提供剪贴簿的类，以填充局部整合的结果。根据网格工作者循环所执行的任务，局部结果可以是不同的类型。它们可以是标量，也可以是等于积分中使用的自由度数的向量，或者是同样大小的方阵。所有这些都有一个共同点，那就是它们是在一个单元或面上进行局部积分的结果。哪种对象是一个操作的结果，是由使用它们的汇编器决定的。也是装配者决定[1.x.9]每种对象的产生（例如，一个装配者可以同时创建质量和刚度矩阵的局部贡献），以及将局部结果的数组设置为所需的大小。    该类的接口允许通过以下函数访问所有这些信息。     [2.x.5] [2.x.6] 标量：n_values()返回该类对象存储的标量数量，通过value()函数访问它们。     [2.x.7] 向量：n_vectors()返回该类对象存储的向量数量（每个向量的长度等于该单元上发生积分的自由度数量）。  向量是由vector()函数访问的。     [2.x.8] 矩阵：n_matrices()返回存储的矩阵数量，每个矩阵的维数等于每个单元的自由度数。矩阵由matrix()访问，第二个参数是<tt>false</tt>。这些矩阵在同一个单元中耦合自由度。对于跨面的通量，还有一组同样大小的矩阵，这些矩阵的维度与两个单元的自由度有关。这些矩阵可以通过matrix()访问，使用第二个参数<tt>true</tt>。   [2.x.9] 本地矩阵由[2.x.10]对象的reinit()初始化，然后由Assembler类组装成全局系统。   
* [2.x.11]   
* [0.x.2]*
     当前对象所存储的标量值的数量。        这个数字被[2.x.12]设置为非零值。    
* [0.x.3]*
     当前对象所存储的向量的数量。        这个数字被[2.x.13]和[2.x.14]设置为非零值。    
* [0.x.4]*
     当前对象存储的矩阵数量。   
* [0.x.5]*
     quadrature_values()中正交点的数量。   
* [0.x.6]*
     quadrature_values()中每个正交点的值的数量。   
* [0.x.7]*
     对该类存储的第i个标量的读写访问。   
* [0.x.8]*
     对该类存储的第`i`个标量的读取访问。   
* [0.x.9]*
     对该类所存储的第i个向量的读写访问。   
* [0.x.10]*
     对该类存储的第`i`个向量的读写权限    
* [0.x.11]*
     对该类存储的第`i`个矩阵的读写访问。        关于第二个参数的解释，请看当前类本身的文档。   
* [0.x.12]*
     读取该类所存储的第`i`个矩阵的访问权限。        关于第二个参数的解释，请看当前类本身的文档。   
* [0.x.13]*
     访问正交点数据的向量#quadrature_data，其组织方式是每个点都有一个向量，每个分量都包含一个条目。   
* [0.x.14]*
     访问正交点[1.x.10]的第[1.x.11]个值。   
* [0.x.15]*
     读取正交点[1.x.13]的[1.x.12]的值。   
* [0.x.16]*
     用标量值初始化向量。       
* [2.x.15]这个函数通常只由汇编程序调用。   
* [0.x.17]*
     用向量值初始化向量。       
* [2.x.16] 这个函数通常只由汇编器调用。   
* [0.x.18]*
     分配[2.x.17]本地矩阵。此外，将它们的块行和列坐标设置为零。矩阵本身的大小由reinit()来调整。       
* [2.x.18] 这个函数通常只由汇编器调用。   
* [0.x.19]*
     为[2.x.19]中的每个全局矩阵分配一个本地矩阵，另外，设置它们的块行和列坐标。矩阵本身的大小由reinit()来调整。       
* [2.x.20]这个函数通常只由汇编器调用。   
* [0.x.20]*
     为[2.x.21]矩阵中的每个全局级对象分配一个本地矩阵。另外，设置它们的块行和块列坐标。矩阵本身的大小由reinit()来调整。       
* [2.x.22]这个函数通常只由汇编器调用。   
* [0.x.21]*
     将正交值初始化为<tt>nv</tt>值在<tt>np</tt>正交点。   
* [0.x.22]*
     为新单元重新初始化矩阵。不调整存储在此对象中的任何数据向量的大小，但调整#R中的向量以及#M1和#M2中的矩阵的大小为hp，并将它们设置为零。   
* [0.x.23]*
     这个对象所使用的内存。   
* [0.x.24]*
     本地的数字，在一个单元或一个面上计算。   
* [0.x.25]*
     本地向量。这个字段是公开的，所以本地积分器可以写到它。   
* [0.x.26]*
     耦合单元本身或面的第一个单元的自由度的局部矩阵。   
* [0.x.27]*
     耦合单元上的测试函数和其他单元上的试验函数的局部矩阵。        只在内部面使用。   
* [0.x.28]*
     用于写入补丁数据的正交点的值。   
* [0.x.29]

