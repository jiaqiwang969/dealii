include/deal.II-translator/meshworker/integration_info_0.txt
[0.x.0]*
   用于交给本地集成函数的对象的类。    这个类的对象包含一个或多个类型为FEValues、FEFaceValues或FESubfaceValues的对象，用于局部整合。它们被存储在一个指向基类FEValuesBase的数组中。模板参数VectorType允许在全局系统中使用不同的数据类型。    此外，这个函数包含了存储在#global_data中的正交点的有限元函数值的空间。这些向量在每个单元或面都会自动初始化。为了避免初始化未使用的向量，你可以使用initialize_selector()来按名称选择你真正想要使用的向量。    [1.x.0] 该类支持两种局部集成模型，对应于Assembler命名空间的文档中的数据模型。一种是由使用FESystem建议的标准模型。也就是说，这个类中有一个FEValuesBase对象，包含了整个系统的所有形状函数，并且拥有和系统一样多的组件。使用这个模型需要对所有的系统形状函数进行循环。它要求识别每个形状函数的系统组件，并选择正确的双线性形式，通常在[2.x.0]或[2.x.1]语句中。    第二个集成模型为系统的每个基元建立一个FEValuesBase对象。每个单元上的自由度按块重新编号，这样它们就代表了与全局系统相同的块结构。然后，执行集成的对象可以单独处理每个块，这大大改善了代码的可重复使用性。   
* [2.x.2] 正如DoFInfo中描述的那样，在这个类中使用initialize()之前，通过调用[2.x.3]来触发对本地块模型的使用。   
* [2.x.4]   
* [0.x.1]*
     构造函数。   
* [0.x.2]*
     复制构造函数，创建一个克隆，供[2.x.5]使用。    
* [0.x.3]*
     建立所有的内部结构，特别是FEValuesBase对象，并为数据向量分配空间。         [2.x.6] el是DoFHandler的有限元素。         [2.x.7] mapping是用于映射网格单元的Mapping对象。         [2.x.8] quadrature是在FEVALUES对象的构造器中使用的正交公式。         [2.x.9] flags是在FEVALUES对象的构造函数中使用的UpdateFlags。         [2.x.10] local_block_info是PDE系统的一个可选参数。如果它提供了合理的数据，那么单元格上的自由度将被重新排序以反映系统的块结构。   
* [0.x.4]*
     初始化数据向量并缓存选择器。   
* [0.x.5]*
     删除由initialize()创建的数据。   
* [0.x.6]*
     返回一个对用于初始化此对象的FiniteElement的引用。   
* [0.x.7]*
     如果对单个元素使用initialize()，这就是正在使用的访问函数（没有BlockInfo参数）。如果应用于一个元素的向量，它会抛出一个异常。   
* [0.x.8]*
     如果对一组元素使用了initialize()（有一个有效的BlockInfo对象），必须使用这个访问函数。   
* [0.x.9]*
     包含正交点中的有限元函数值的向量。        每个选定的有限元函数有一个向量，每个分量有一个向量，包含每个正交点的值的向量。   
* [0.x.10]*
     包含有限元函数在正交点的导数的向量。        每个选定的有限元函数有一个向量，每个分量包含一个向量，包含每个正交点的值的向量。   
* [0.x.11]*
     包含有限元函数在正交点的二阶导数的向量。        每个选定的有限元函数有一个向量，每个分量包含一个向量，包含每个正交点的值的向量。   
* [0.x.12]*
     重新初始化内部数据结构，以便在一个单元上使用。   
* [0.x.13]*
     使用#global_data中的有限元函数，填充向量#values、#gradients和#hessians。   
* [0.x.14]*
     用于计算正交点的函数值的全局数据向量。   
* [0.x.15]*
     这个对象所使用的内存。   
* [0.x.16]*
     用于初始化的（系统）元素的指针。   
* [0.x.17]*
     使用#global_data中的有限元函数，并根据选择器的值填充向量#values、#gradients和#hessians。   
* [0.x.18]*
     缓存系统元素的组件数量。   
* [0.x.19]*
   持有用于整合单元格和面的划痕数据的对象。  IntegrationInfoBox有三个主要用途。     [2.x.11] [2.x.12] 它提供了[2.x.13]所需的接口，即两个函数post_cell()和post_faces()，以及数据成员#cell、#boundary、#face、#subface和#neighbor。     [2.x.14] 它包含了初始化 IntegrationInfo 数据成员中的 FEValues 和 FEFaceValues 对象所需的所有信息。     [2.x.15] 它存储了关于有限元向量的信息，以及它们的数据是否应该被用来计算正交点的函数值或导数。     [2.x.16] 它对正交规则和更新标志进行有根据的猜测，因此在默认参数足够的情况下，需要编写最少的代码。   [2.x.17] 为了允许足够的通用性，必须采取几个步骤来使用这个类。    首先，你应该考虑你是否需要AnyData对象中任何向量的值。如果是的话，将VectorSelector对象#cell_selector、#boundary_selector和#face_selector的名称和要提取的数据类型（值、梯度、Hessian）填入。    之后，你将需要考虑FEValues对象的UpdateFlags。一个好的开始是initialize_update_flags()，它查看之前填写的选择器，并添加所有需要的标志以获得选择。  其他的标志可以用add_update_flags()来设置。    最后，我们需要选择正交公式。在最简单的情况下，你可能对默认设置感到满意，即[1.x.1]-点高斯公式。如果只使用形状函数的导数（#update_values没有设置），[1.x.2]等于FiniteElement中的最高多项式度数，如果#update_values设置了，[1.x.3]是比这个度数高一个。 如果你选择使用其他大小的高斯公式，请使用initialize_gauss_quadrature()的适当值。否则，你可以直接填写#cell_quadrature、#boundary_quadrature和#face_quadrature这些变量。    为了节省时间，你可以将基类的boundary_fluxes和internal_fluxes变量设置为false，从而告诉[2.x.18]不要在这些面上循环。    这里的所有信息都是用来正确设置IntegrationInfo对象的，通常是在一个IntegrationInfoBox中。   
* [2.x.19]   
* [0.x.20]*
     单元的[2.x.20]对象的类型。   
* [0.x.21]*
     默认构造函数。   
* [0.x.22]*
     初始化包含的IntegrationInfo对象。        在这样做之前，添加必要的更新标志以产生所需的数据，同时将未初始化的正交规则设置为高斯公式，该公式精确地整合多项式双线性形式。   
* [0.x.23]*
     初始化包含的IntegrationInfo对象。        在这样做之前，添加必要的更新标志以产生所需的数据，同时将未初始化的正交规则设置为高斯公式，该公式完全集成多项式双线性形式。   
* [0.x.24]*
     初始化包含的IntegrationInfo对象。        在这样做之前，添加必要的更新标志以产生所需的数据，同时将未初始化的正交规则设置为高斯公式，该公式完全集成多项式双线性形式。   
* [0.x.25]*
      [2.x.21] FEValues设置    
* [0.x.26]*
     在initialize()之前调用这个函数，以便根据选择的数据猜测需要的更新标志。        在计算面通量时，我们通常可以使用原始单元的几何图形（积分权重和法向量），从而可以避免在邻近单元上更新这些值。将<tt>neighbor_geometry</tt>设置为true，以便将这些值也初始化。   
* [0.x.27]*
     增加FEValues UpdateFlags，以便在所有对象（单元格、边界面和所有内部面）上进行整合。   
* [0.x.28]*
     添加FEValues UpdateFlags用于单元格的整合。   
* [0.x.29]*
     添加FEValues UpdateFlags用于边界面的积分。   
* [0.x.30]*
     添加FEValues UpdateFlags用于内部面的积分。   
* [0.x.31]*
     在本程序中已经设置的更新标志的基础上，增加额外的更新标志。    四个布尔标志表示是否应该为单元、边界、单元本身或相邻单元的元素间面，或它们的任何组合设置额外的标志。   
* [0.x.32]*
     为每个正交规则分配n点高斯正交值。这里，0点的大小意味着不应该对这些网格实体进行循环。        如果参数<tt>force</tt>为真，那么所有的正交集都被填入新的正交规则。如果它是假的，那么只有空的规则被改变。   
* [0.x.33]*
     这个对象所使用的内存。   
* [0.x.34]*
     用于边界单元集成的更新标志集。        默认为#update_JxW_values。   
* [0.x.35]*
     用于边界面集成的更新标志集。        默认为#update_JxW_values和#update_normal_vectors。   
* [0.x.36]*
     用于内部面集成的更新标志集。        默认为#update_JxW_values和#update_normal_vectors。   
* [0.x.37]*
     用于内部面集成的更新标志集。        默认为#update_default，因为正交权重取自其他单元。   
* [0.x.38]*
     在单元格上使用的正交规则。   
* [0.x.39]*
     用于边界面的正交规则。   
* [0.x.40]*
     用于内部面的正交规则。   
* [0.x.41]*
      [2.x.22] 数据向量    
* [0.x.42]*
     初始化VectorSelector对象#cell_selector、#boundary_selector和#face_selector，以节省计算工作。如果没有使用选择器，那么[2.x.23]中所有命名的向量的值都将在所有正交点中计算。        这个函数还将把UpdateFlags添加到存储在这个类中的标志中。   
* [0.x.43]*
     从[2.x.24]中选择应该在单元格上的正交点计算的向量。   
* [0.x.44]*
     从[2.x.25]中选择应该在边界面上的正交点计算的向量。   
* [0.x.45]*
     从[2.x.26]中选择应该在内部面的正交点上计算的向量。   
* [0.x.46]*
      [2.x.27] [2.x.28]的接口。    
* [0.x.47]*
     一个回调函数，它在所有单元格的循环中被调用，在对一个单元格的操作被执行后，在面的处理之前。        为了使这个函数产生这种效果，至少loop()的参数<tt>boundary_worker</tt>或<tt>face_worker</tt>应该是非零的。此外，<tt>cells_first</tt>应该为真。如果<tt>cells_first</tt>是假的，那么在对一个单元格采取任何行动之前就会调用这个函数。        在这个类中是空函数，但在其他类中可以用loop()代替。        参见loop()和cell_action()以了解该函数的更多使用细节。   
* [0.x.48]*
     一个回调函数，它在所有单元格的循环中被调用，在对一个单元格的面进行操作后，在处理该单元格本身之前（假设<tt>cells_first</tt>为假）。        为了使这个函数有合理的效果，至少loop()的参数<tt>boundary_worker</tt>或<tt>face_worker</tt>应该是非零的。此外，<tt>cells_first</tt>应该是假的。        而且在这个类中是空函数，但在其他类中可以用loop()代替。        参见loop()和cell_action()以了解该函数的详细使用方法。   
* [0.x.49]*
     一个单元格的[2.x.29]对象。   
* [0.x.50]*
     边界面的[2.x.30]对象。   
* [0.x.51]*
     从第一个单元看到的[2.x.31]对象为一个规则的内部面。   
* [0.x.52]*
     从第一个单元看到的内部面的[2.x.32]对象的精炼面。   
* [0.x.53]*
     从另一个单元看到的内部面的[2.x.33]对象。   
* [0.x.54]

