include/deal.II-translator/meshworker/mesh_loop_0.txt
[0.x.0]*
     一个帮助类，为底层单元格迭代器类型提供类型定义。   
* [0.x.1]*
       用于单元格迭代器类型的类型定义。     
* [0.x.2]*
     一个辅助类，为底层单元格迭代器类型提供类型定义。        这个特殊化是针对IteratorRange的，它可以有TriaActiveIterator或FilteredIterator作为其基础类型。   
* [0.x.3]*
       单元迭代器类型的类型定义。     
* [0.x.4]*
     一个帮助类，为底层单元格迭代器类型提供类型定义。        这个特殊化是针对FilteredIterator的，它可以有一个TriaActiveIterator作为它的基础类型，或者可以与另一个FilteredIterator嵌套作为迭代的类型。   
* [0.x.5]*
       单元格迭代器类型的定义。     
* [0.x.6]*
   这个别名为Mesh_loop()中使用的单元格工作者的函数类型引入了一个友好而简短的名称。 
* [0.x.7]*
   这个别名为Mesh_loop()中使用的单元格工作者的函数类型引入了一个友好而简短的名字。 
* [0.x.8]*
   这个别名为Mesh_loop()中使用的边界工作者的函数类型引入了一个友好而简短的名字。 
* [0.x.9]*
   这个别名为Mesh_loop()中使用的面片工作者的函数类型引入了一个友好而简短的名称。 
* [0.x.10]*
   这个函数扩展了WorkStream的概念，可以在网格（单元和/或面）上工作，并处理自适应细化面的工作和并行计算的复杂逻辑（例如，对面的工作到幽灵邻居）。  [2.x.0]可用于简化对单元（例如装配）、边界（诺伊曼型边界条件）或内部面（例如在非连续加尔金方法中）的操作。该函数在许多教程中使用，包括[2.x.1], [2.x.2], 和[2.x.3]，仅举几例。    对于均匀细化的网格，使用[2.x.4]和[2.x.5]会比较容易，[2.x.5]也会在面上循环，并根据当前和相邻单元的情况来处理面的组合条件。所有进行这些循环的用户代码都需要手动插入逻辑，为当前单元的每个面确定相邻的单元，以及相邻单元上与当前面相对应的面的索引。    如果启用了局部细化，并且当前或相邻单元有悬挂的节点，这就更复杂了。在这种情况下，还需要确定当前或邻近面的相应子面。    这个方法将该逻辑外部化（独立于用户代码），并将面的装配条款（内部面、边界面或平行计算中不同子域ID之间的面）与单元上的装配分开，允许用户指定两个额外的工作者（一个[2.x.6]一个[2.x.7]和一个[2.x.8]，根据传递的特定AssembleFlags[2.x.10]在每个[2.x.9]中自动调用。2.x.11]被传递给单元格标识符、ScratchData对象和CopyData对象，遵循与[2.x.12]相同的原则。 在内部，该函数除了传递给[2.x.13]之外，还传递了一个[2.x.14]参数，用于识别应该被执行集成的面。而[2.x.15]则需要在单元格和相邻单元格上明确识别当前面，因此它被调用时有六个参数（每个单元格有三个参数：实际单元格、面的索引和子面_索引。如果不需要子面集成，那么除了通常的ScratchData和CopyData对象外，子面_索引为[2.x.16]。    如果传递了标志[2.x.17]，那么默认的行为是先在面上循环并在那里做功，然后再计算单元上的实际功。如果指定了标志[2.x.19]，那么每个内部面只被访问一次，[2.x.20]被假定为一次集成所有面的条款（并在不连续Galerkin设置中增加面的两边贡献）。    当AssembleFlags只包含[2.x.22]时，该方法等同于[2.x.21]方法，可以作为该方法的替代品使用。    两个数据类型ScratchData和CopyData需要有一个工作拷贝构造函数。ScratchData只在worker函数中使用，而CopyData是由worker传递给copyer的对象。每次这个函数访问一个新的单元时，CopyData对象就会被重置为提供给这个函数的值（在这里它就会调用单元和面对工作者）。换句话说，在一个单元格上调用`copier`和在下一个单元格上调用`cell_worker`/`face_worker`/`boundary_worker`函数之间，没有任何状态的延续，用户代码不需要在单元格整合的开始或拷贝操作的结束时重置拷贝对象。在 "face_worker "或 "boundary_worker "内部重置 "copier "的状态构成一个bug，并可能导致一些意外的结果。下面的例子显示了什么是不允许的，因为复印机有可能在一个单元上的许多面之间共享。 
* [1.x.0]
* queue_length参数表示在任何给定时间内可以活用的项目的数量。每个项目由输入流的chunk_size元素组成，这些元素将被worker和copyer函数在同一个线程上一个接一个地处理。    如果你的数据对象很大，或者它们的构造函数很昂贵，记住ScratchData对象的queue_length副本和CopyData对象的`queue_length*chunk_size`副本是有帮助的。   
* [2.x.23] 这里的Doxygen文档中显示的函数参数类型和默认值（空工作者函数）与实际类型相比略有简化。   
* [2.x.24] 关于模板类型的要求以及[2.x.25]和[2.x.26]的含义的更多信息可以在WorkStream命名空间及其成员的文档中找到。   
* [2.x.27]   
* [0.x.11]*
   与上面的函数相同，但适用于迭代器范围（因此也适用于过滤的迭代器）。    在串行情况下，该函数的一个使用实例是这样给出的  
* [1.x.1]
* 该函数在并行分布式情况下的使用示例，其中复制器只在本地拥有的单元上调用，由以下内容给出  
* [1.x.2]
*     
* [2.x.28]   
* [0.x.12]*
   这是Mesh_loop()函数的一个变体，可用于作为类成员函数的worker和copier函数。    作为[2.x.29]传递的参数必须可以转换为与[2.x.30]开始相同的类型，但本身不一定是同一类型。这允许编写类似<code>mesh_loop(dof_handler.begin_active(), dof_handler.end(), ...)</code>的代码，其中第一个是[2.x.31]类型，而第二个是[2.x.32]类型。 [2.x.33]参数表示在任何特定时间可以活着的项目数量。每个项目由输入流的[2.x.34]个元素组成，这些元素将由工作者和复制者函数在同一线程上一个接一个地处理。   
* [2.x.35] 如果你的数据对象很大，或者它们的构造函数很昂贵，记住<tt>queue_length</tt>拷贝的<tt>ScratchData</tt>对象和<tt>queue_length*chunk_size</tt>拷贝的<tt>CopyData</tt>对象是很有用的。    该函数的一个使用例子是这样给出的  
* [1.x.3]
     
* [2.x.36]   
* [0.x.13]*
   和上面的函数一样，但是对于迭代器的范围（以及，因此，过滤的迭代器）。    在串行情况下，该函数的一个使用实例是这样给出的  
* [1.x.4]
* 该函数在并行分布式情况下的使用示例，其中复制器只在本地拥有的单元上调用，由以下内容给出  
* [1.x.5]
*     
* [2.x.37]   
* [0.x.14]

