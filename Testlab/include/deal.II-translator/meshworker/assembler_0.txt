include/deal.II-translator/meshworker/assembler_0.txt
[0.x.0]*
   含有对象的命名空间，可用于将单元格和面的计算数据组装成全局对象。这可以达到从收集单元和面的贡献的总误差估计到组装矩阵和多级矩阵的目的。    [1.x.0] 从这个命名空间中选择的类决定了哪种数据模型被使用。  对于局部和全局对象，我们可以选择两种模型。    1.x.1] 这是由FESystem类建立的结构。在全球范围内，这意味着，数据被集合到一个残差向量和一个矩阵中。这些对象可能是块状向量和块状矩阵，但组装的过程忽略了这个事实。    同样地，只有一个单元向量和单元矩阵，分别由FES系统的所有自由度来索引。  在建立单元矩阵时，有必要区分系统的不同组成部分，并为每对单元选择正确的运算符。    [1.x.2]在这里，所有的块都是单独处理的（尽管在其他地方使用FESystem是为了其方便）。例如，没有组装区块矩阵，而是一个区块的列表，以后可以通过BlockMatrixArray来组合。在本地，这意味着，一个系统的每个矩阵块都是单独生成的，并被组装成相应的全局块。    如果全局系统中每个块的矩阵数量不同，这种方法是有利的。例如，Oseen问题的块状预处理需要3个压力矩阵，但只有一个发散和一个速度的平流-扩散算子。    此外，这种方法能够从每个方程和耦合算子的构建块中构建一个方程系统。    然而，由于必须为每个基本元素创建一个单独的FEValues对象，所以先验地不太清楚哪种数据模型更有效。   
* [2.x.0]   
* [0.x.1]*
     将局部残差组装成全局残差。        全局残差被期望为一个FEVectors对象。本地残差是块向量。        根据BlockInfo对象是否用[2.x.1]初始化，在本地使用全面或块数据模型。        在块模型中，本地向量的每个块都对应于系统的单个块对这个单元的限制（见[2.x.2]）。    因此，这个局部块的大小是FES系统中相应基元的自由度数。         [2.x.3] 综合模型目前没有实现。       
* [2.x.4]     
* [0.x.2]*
       将BlockInfo和矩阵指针复制到本地变量中。     
* [0.x.3]*
       初始化约束。     
* [0.x.4]*
       初始化以后用于装配的DoFInfo对象中的局部数据。            如果[2.x.6]，[2.x.5]对象指的是一个单元，否则指的是一个内部或边界面。     
* [0.x.5]*
       将局部残差组装成全局残差。     
* [0.x.6]*
       将两个局部残差集合到全局残差中。     
* [0.x.7]*
       将一个局部残差装配到全局中。     
* [0.x.8]*
       全局向量，以AnyData容器的指针形式存储。     
* [0.x.9]*
       一个指向包含块结构的对象的指针。     
* [0.x.10]*
       一个指向包含约束的对象的指针。     
* [0.x.11]*
     一个帮助类，将本地矩阵组装成全局矩阵。        全局矩阵应该是MatrixBlock对象的一个向量，每个对象都包含一个矩阵对象，其函数对应于[2.x.7]，以及该矩阵在一个块系统中代表的块行和块列的信息。        本地矩阵被期望为一个类似的MatrixBlock对象的向量，但包含一个FullMatrix。        与ResidualLocalBlocksToGlobalBlocks一样，BlockInfo对象的初始化决定了是使用综合数据模型还是块模型。        在综合模型中，每个LocalMatrixBlocks的坐标（0,0）和尺寸等于FES系统的自由度数。        在综合模型中，每个块都有自己的块坐标，其大小取决于相关的 [2.x.8] 这些块可以单独生成，并将由这个对象组装成正确的矩阵块。       
* [2.x.9]     
* [0.x.12]*
       构造函数，初始化#阈值，它限制了可以输入矩阵的小数字。     
* [0.x.13]*
       将BlockInfo和矩阵指针复制到局部变量中，并初始化单元矩阵向量。     
* [0.x.14]*
       初始化约束。     
* [0.x.15]*
       初始化以后用于装配的DoFInfo对象中的局部数据。            如果[2.x.10]对象指的是一个单元格，如果[2.x.11]，则指的是一个内部或边界面。     
* [0.x.16]*
       将局部矩阵组装成全局矩阵。     
* [0.x.17]*
       将所有局部矩阵集合到全局矩阵中。     
* [0.x.18]*
       将单个局部矩阵组合成全局矩阵。     
* [0.x.19]*
       全局矩阵，以指针向量的形式存储。     
* [0.x.20]*
       一个指向包含块结构的对象的指针。     
* [0.x.21]*
       一个指向包含约束的对象的指针。     
* [0.x.22]*
       将被输入全局矩阵的最小的正数。所有更小的绝对值将被视为零，不会被集合。     
* [0.x.23]*
     一个帮助类，将局部矩阵组装成全局多级矩阵。这个类是MatrixLocalBlocksToGlobalBlocks的多级等价物，该类的文档在很大程度上适用于此。        全局矩阵被期望为指向MatrixBlock对象的一个向量，每个对象都包含一个MGLevelObject，其中的矩阵具有对应于[2.x.12]的函数，以及该矩阵在块系统中代表的块行和块列的信息。        本地矩阵是一个类似MatrixBlock对象的向量，但包含一个FullMatrix。        如果发生局部细化，多重网格方法需要更多的矩阵，两个用于连续元素，另外两个如果在界面上计算数值通量。第二组矩阵可以通过initialize_edge_flux()添加。一旦加入，所有参与矩阵的贡献将从单元和面的矩阵中自动集合起来。       
* [2.x.13]     
* [0.x.24]*
       构造函数，初始化#threshold，它限制了可以输入矩阵的小数字。     
* [0.x.25]*
       将BlockInfo和矩阵指针复制到本地变量，并初始化单元格矩阵向量。     
* [0.x.26]*
       初始化多级约束。     
* [0.x.27]*
       局部细化网格上的多网格方法需要额外的矩阵。      对于不连续的Galerkin方法，这些是跨越细化边缘的两个通量矩阵，由该方法设置。     
* [0.x.28]*
       局部细化网格上的多栅方法需要额外的矩阵。      对于不连续的Galerkin方法，这些是跨越细化边缘的两个通量矩阵，由该方法设置。     
* [0.x.29]*
       初始化以后用于装配的DoFInfo对象中的局部数据。            如果[2.x.15]，[2.x.14]对象指的是一个单元，否则指的是一个内部或边界面。     
* [0.x.30]*
       将局部矩阵组装成全局矩阵。     
* [0.x.31]*
       将所有局部矩阵集合到全局矩阵中。     
* [0.x.32]*
       将单个局部矩阵组合成全局矩阵。     
* [0.x.33]*
       将一个单一的局部矩阵组合成一个全局矩阵。     
* [0.x.34]*
       将一个单一的本地矩阵组合成一个全局矩阵。     
* [0.x.35]*
       将一个单一的本地矩阵组合成一个全局矩阵。     
* [0.x.36]*
       将一个单一的本地矩阵组合成一个全局矩阵。     
* [0.x.37]*
       将一个单一的本地矩阵组合成一个全局矩阵。     
* [0.x.38]*
       水平矩阵，存储为一个指向性的向量。     
* [0.x.39]*
       细化边缘的细化水平和粗化水平之间的通量矩阵。     
* [0.x.40]*
       细化边缘的粗级和细级之间的通量矩阵。     
* [0.x.41]*
       细化边缘处精细级和粗化级之间的界面矩阵。     
* [0.x.42]*
       细化边缘处的粗级和细级之间的界面矩阵。     
* [0.x.43]*
       一个指向包含块结构的对象的指针。     
* [0.x.44]*
       一个指向包含约束条件的对象的指针。     
* [0.x.45]*
       将被输入全局矩阵的最小的正数。所有更小的绝对值将被视为零，不会被集合。     
* [0.x.46]

