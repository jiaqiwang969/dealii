include/deal.II-translator/meshworker/loop_0.txt
[0.x.0]*
   找出一个迭代器是否支持非活动单元。 
* [0.x.1]*
   用于控制MeshWorker循环执行的参数集合。 
* [0.x.2]*
     构造函数。   
* [0.x.3]*
     在本进程拥有的单元格上进行循环。默认为[2.x.0] 。   
* [0.x.4]*
     在不属于本进程的单元格上进行循环。默认为[2.x.1] 。   
* [0.x.5]*
     描述何时对一个面进行装配的枚举：例如，见[2.x.2]，以了解在特定情况下如何解释这个枚举的值的例子。   
* [0.x.6]*
       不要在一个面上进行装配。     
* [0.x.7]*
       在一个面上进行装配。     
* [0.x.8]*
       在两个面上进行装配。     
* [0.x.9]*
     控制在一个本地拥有的单元和一个幽灵单元之间的面的循环。
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 
* - 绝不。不要装配这些面孔。
* 

* 
 

 
 

 
 

 
 

 
 
* - 一个。只有一个进程将组装这些面（从较细的一面或MPI等级较低的进程）。
 

 
* 

* 
 

 
 

 
 

 
 
* - 两者都是。两个进程都将装配这些面。注意，这些面永远不会在一个进程中从两边装配。        默认是 [2.x.3] 。   
* [0.x.10]*
     控制在两个本地拥有的单元之间的面的循环。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 
* - 绝不。不要组装脸部条款。
* 

* 
* 

 
 

 
 

 
 

 
 
* - 一。组装一次（总是从较细的一面来）。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 都是。将每个面组装两次（对悬挂的节点不实施！）。        默认是 [2.x.4] 。   
* [0.x.11]*
     一个标志，决定单元格积分应该在面的积分之前或之后进行。默认值是[2.x.5] 。   
* [0.x.12]*
   loop()调用的函数，用于对单元格和其面进行所需的操作。<tt>cell_worker</tt>, <tt>boundary_worker</tt> 和 <tt>face_worker</tt> 这三个函数是交给loop()的。在那里，我们只对所有的单元格进行循环，而在这里，我们只做一个单元格，如果有必要的话，还要做它的面、内部和边界。    返回时，DoFInfoBox中的DoFInfo对象被填充了单元格和每个面所计算的数据。因此，在执行这个函数后，我们就可以调用[2.x.6]将局部数据分配到全局数据中。     2.x.7] cell是我们工作的单元 [2.x.8] dof_info是输入局部结果的对象。预计它已经被设置为正确的数据类型。   [2.x.9] info是包含仅用于内部处理的额外数据的对象。   [2.x.10] cell_worker定义了对每个单元的本地操作。   [2.x.11] boundary_worker定义了对边界面的局部操作 [2.x.12] face_worker定义了对内部面的局部操作。   [2.x.13] loop_control控制结构，指定应该执行什么动作。   
* [2.x.14]   
* [0.x.13]*
   本命名空间的主要工作功能。它是对一个迭代器范围内所有单元格的循环，其中对每个单元格调用cell_action()。  循环会自动处理单边细化的内部面。这个循环中的大部分工作是在cell_action()中完成的，它也接收这个函数的大部分参数。更多细节请参见那里的文档。    如果你不希望在单元格、内部或边界面发生任何事情，只需将Null指针传递给其中一个函数参数。   
* [2.x.15]   
* [0.x.14]*
   如果专门用于积分，使用LocalIntegrator中的虚拟函数，简化了loop()的接口。   
* [2.x.16]   
* [0.x.15]

