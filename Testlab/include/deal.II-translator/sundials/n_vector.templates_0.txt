include/deal.II-translator/sundials/n_vector.templates_0.txt
[0.x.0]*
     一个内部类，用于存储一个向量的指针，并在必要时管理内存。这个类的对象被用作SUNDIALS N_Vector模块中的`内容'字段。此外，这个类有一个标志，用来存储存储的向量是否应该被视为常量。当对该类的非常量对象调用get()时，会检查该标志，如果该向量实际上是常量，则会抛出一个异常。因此，我们保留了一种 "运行时常态正确性"，尽管由于SUNDIALS N_Vector不支持常态，所以静态常态正确性已经丧失。   
* [0.x.1]*
       用现有的[2.x.0][2.x.1]向量创建一个非所有权的内容 要包裹在这个对象中的基础向量。     
* [0.x.2]*
       用一个现有的const创建一个非所有权的内容 [2.x.2] 如果使用这个构造函数，只允许通过get()const方法访问。       [2.x.3] vector 在这个对象中要包裹的基础向量。     
* [0.x.3]*
       分配一个新的（非const）向量，包裹在一个新的内容对象中。当这个对象被销毁时，这个向量将被自动取消分配。           
* [2.x.4]这个构造函数是为SUNDIALS的N_VClone()调用准备的。     
* [0.x.4]*
       对存储向量的非const访问。只有在使用了不同于NVectorContent(const VectorTypevector)的构造函数时才允许。       [2.x.5]       
* [0.x.5]*
       对存储向量的常量访问。总是允许的。     
* [0.x.6]*
       如果调用NVectorContent()，可能用于分配存储的向量内存。     
* [0.x.7]*
       实际存储的向量内容。     
* [0.x.8]*
       存储的指针是否被视为常数的标志。如果在构造函数中传递的指针确实是常数，那么它将被抛开，但这个标志将被设置为真。然后，对指针的访问必须检查这个标志是否被正确设置。     
* [0.x.9]*
     帮助创建一个具有所有操作和给定[2.x.6] [2.x.7] 内容的向量，以附加到N_Vector。     [2.x.8] 一个新的N_Vector    
* [0.x.10]*
     帮助创建一个具有所有操作但没有内容的空向量。     [2.x.9] 一个新的N_Vector    
* [0.x.11]*
     SUNDIALS N_Vector文档指定的所有操作的集合。这些函数被附加到通用的N_Vector结构中。   
* [0.x.12]*
       Sundials喜欢一个void*，但我们想在内部使用上述函数的安全类型。     
* [0.x.13]

