include/deal.II-translator/sundials/n_vector_0.txt
[0.x.0]*
     创建一个给定的NVectorView [2.x.0] 这个调用的目的是用来作为        
* [1.x.0]
* 产生的对象`view`必须被保留在周围，只要任何其他对象将使用内部查看的N_Vector。         [2.x.1] VectorType 被观察的向量的类型。这个参数可以自动推导，并将尊重一个潜在的const-qualifier。     [2.x.2] 矢量 要查看的矢量。     [2.x.3] [2.x.4] 的NVectorView [2.x.5] NVectorView    
* [0.x.1]*
     检索连接到N_Vector的底层向量 [2.x.6] 只有当底层向量不是常量时，这个调用才会成功。在这种情况下，请使用unwrap_nvector_const()。       
* [2.x.7] 用户必须确保在调用此函数时询问正确的VectorType，并且没有类型安全检查。         [2.x.8] VectorType 存储在[2.x.9]中的向量的类型 [2.x.10] v 要解包的向量 [2.x.11] 存储在[2.x.12]中的向量     
* [0.x.2]*
     检索连接到N_Vector [2.x.13] 的底层向量，作为一个常数指针。       
* [2.x.14] 用户必须确保在调用此函数时询问正确的VectorType，并且没有类型安全检查。         [2.x.15] VectorType 存储在[2.x.16]中的向量的类型 [2.x.17] v 要解包的向量 [2.x.18] 存储在[2.x.19]中的向量     
* [0.x.3]*
     一个指向向量的视图，只要需要N_Vector就可以使用。        这个类的对象最好是通过make_nvector_view()创建，因为        
* [1.x.1]
* 产生的N_Vector是实际矢量的视图，而不是拥有内存。另外，不能对生成的N_Vector调用N_VDestroy()，因为这将导致在析构器中出现双倍删除。       
* [2.x.20] SUNDIALS永远不会在它自己没有创建的向量上调用N_VDestroy()，因此上述约束没有限制用户。         [2.x.21] VectorType 储存在[2.x.22]的向量的类型。    
* [0.x.4]*
       默认构造函数。            该对象实际上没有查看任何东西，需要用operator=(NVectorView &&)来分配。     
* [0.x.5]*
       构造函数。创建[2.x.23]的视图。      
* [0.x.6]*
       移动赋值。     
* [0.x.7]*
       移动构造器。     
* [0.x.8]*
       明确删除复制的ctor。这个类只有移动。     
* [0.x.9]*
       明确删除复制赋值。这个类是只允许移动的。     
* [0.x.10]*
       解构器。           
* [2.x.24] 这将不会破坏被查看的向量。     
* [0.x.11]*
       隐式转换为N_Vector。这个操作符使NVectorView看起来像一个实际的N_Vector，它可以直接作为许多SUNDIALS函数的参数使用。     
* [0.x.12]*
       访问这个对象所查看的N_Vector。     
* [0.x.13]*
       实际指向该类所查看的向量的指针。     
* [0.x.14]

