include/deal.II-translator/sundials/ida_0.txt
[0.x.0]*
   SUNDIALS隐式微分代数（IDA）求解器的接口。    IDA类是SUNDIALS隐式微分代数求解器的一个封装器，它是一个通用的微分代数方程（DAE）系统的求解器。    用户必须提供以下内容的实现 [2.x.0] 。
* 

* 
* 

* 
* 

 
 

 
 
* - reinit_vector;
 

 
 

 
 

 
 

 
 
* - 残留物。
 

 
* 

 
 

 
 

 
 
* - setup_jacobian;
* 

* 
* 

* 
 

 
 

 
* 
* - solve_jacobian_system/solve_with_jacobian; 函数`solve_jacobian_system`应该在SUNDIALS < 4.0.0中实现。对于后来的版本，你应该使用`solve_with_jacobian`来利用更好的非线性算法。    也可以选择提供以下函数。默认情况下，它们什么都不做，或者不需要。如果你在调用构造函数时需要一个未实现的函数，将抛出一个断言。
* 

* 
* 

* 
* 

 
 

 
* 
* - solver_should_restart;
 

* 
* 

 
 

 
 

 
 
* - 差异化的成分。
 

* 
* 

* 
 

 
 

 
* 
* - get_local_tolerances; 要输出步骤，请将一个函数连接到信号上
 

* 
* 

* 
* 

 
 

 
* 
* - output_step; 引自SUNDIALS文档。      考虑一个一般形式的微分代数方程组 [1.x.0] ，其中 [2.x.1] 是 [2.x.2] 中的向量， [2.x.3] 通常是时间（但也可以是一个参数量），以及 [2.x.4] 。  这样的问题是用牛顿迭代和直线搜索全局策略来解决的。IDA中使用的积分方法是变阶、变系数的BDF（后向微分公式），为固定导程系数。方法的阶数从1到5，阶数为[2.x.5]的BDF由多步公式[1.x.1]给出，其中[2.x.6]和[2.x.7]分别是[2.x.8]和[2.x.9]的计算近似值，步长为[2.x.10] 。系数[2.x.11]由阶数[2.x.12]和步长的历史唯一地决定。将BDF方法应用于DAE系统的结果是在每个时间步长上需要解决一个非线性代数系统。    [1.x.2] 牛顿方法导致了一个形式为[1.x.3]的线性系统，其中[2.x.13]是[2.x.14]对[2.x.15]的第1次近似，[2.x.16]是系统雅各布[1.x.4]和[2.x.17]的近似。值得一提的是，每当步长或方法阶数改变时，标量[2.x.18]就会改变。    为了提供一个简单的例子，考虑下面的谐波振荡器问题： [1.x.5] 我们用一阶奥德来写它。 [1.x.6] 即[2.x.19] 其中[1.x.7] 和[2.x.20] , [2.x.21] 。    精确解是 [2.x.22] , [2.x.23] , [2.x.24] 。    要集合的雅各布系数如下。  [2.x.25] .     这可以通过以下代码片段实现。 
* [1.x.8]
*   
* [0.x.1]*
     可以传递给IDA类的额外参数。   
* [0.x.2]*
       IDA是一个微分代数求解器。因此，它对一阶导数也需要初始条件。如果你没有提供一致的初始条件，（即F(y_dot(0), y(0), 0)=0的条件），你可以要求SUNDIALS为你计算初始条件，在`initial_time`（`ic_type`）和复位后（`reset_type`）指定初始条件的InitialConditionCorrection。     
* [0.x.3]*
         不要试图使初始条件一致。       
* [0.x.4]*
         计算y的代数分量和y_dot的微分分量，给定y的微分分量。该选项要求用户在函数get_differential_components中指定微分和代数分量。       
* [0.x.5]*
         计算y的所有分量，给定y_dot。       
* [0.x.6]*
       IDA的初始化参数。            全局参数。             [2.x.26] initial_time 初始时间 [2.x.27] final_time 最终时间 [2.x.28] initial_step_size 初始步长 [2.x.29] output_period 每次输出的时间间隔 运行参数。             [2.x.30] minimum_step_size 最小步长 [2.x.31] maximum_order 最大BDF阶数 [2.x.32] maximum_non_linear_iterations 最大非线性迭代次数 [2.x.33] ls_norm_factor 从积分器容限到线性求解器容限迭代的转换系数 错误参数。             [2.x.34] absolute_tolerance 绝对误差公差 [2.x.35] relative_tolerance 相对误差公差 [2.x.36] ignore_algebraic_terms_for_errors 忽略误差计算的代数项。             [2.x.37] ic_type 初始条件修正类型 [2.x.38] reset_type 重启后的初始条件修正类型 [2.x.39] maximum_non_linear_iterations_ic 初始条件Newton最大迭代次数      
* [0.x.7]*
       将所有AdditionalData()参数添加到给定的ParameterHandler对象中。当参数从文件中被解析出来时，内部参数会自动更新。            声明了以下参数。           
* [1.x.9]
* 这些参数与你在构建时可以传递的选项是一一对应的。            你在构建时传递的选项在ParameterHandler对象`prm`中被设置为默认值。之后你可以通过使用`prm`解析参数文件来修改它们。每当`prm`的内容被更新时，参数的值就会被更新。            请确保这个类的寿命比`prm`长。如果你破坏了这个类，然后用`prm`解析一个参数文件，将会发生未定义的行为。     
* [0.x.8]*
       DAE的初始时间。     
* [0.x.9]*
       最终时间。     
* [0.x.10]*
       初始步骤大小。     
* [0.x.11]*
       最小步长。     
* [0.x.12]*
       自适应时间步进的绝对误差容限。     
* [0.x.13]*
       自适应时间步进的相对误差容限。     
* [0.x.14]*
       BDF的最大顺序。     
* [0.x.15]*
       每个输出之间的时间周期。     
* [0.x.16]*
       忽略错误的代数项。     
* [0.x.17]*
       对初始条件的修正类型。            如果你没有提供一致的初始条件，（即[2.x.40]的条件），你可以在构造时使用`ic_type`参数，要求SUNDIALS为你计算初始条件。            请注意，原则上你可以使用这个功能来解决稳态问题，将y_dot设置为零，并要求计算出满足[2.x.42]的[2.x.41]，然而IDA内部使用的非线性求解器可能对有几百万个未知数的复杂问题不够强大。     
* [0.x.18]*
       解算器重启后使用的初始条件修正类型。            如果你在重启后没有一致的初始条件，（即F(y_dot(t_restart), y(t_restart), t_restart) = 0的条件），你可以要求SUNDIALS在构造时使用`reset_type`参数为你计算新的初始条件。     
* [0.x.19]*
       IC计算中牛顿法的最大迭代次数。     
* [0.x.20]*
       在时间推进过程中，牛顿方法的最大迭代次数。     
* [0.x.21]*
       从积分器公差转换到线性求解器公差时使用的系数。     
* [0.x.22]*
     构造器。通过传递一个设定所有求解器参数的AdditionalData()对象，可以对SUNDIALS IDA求解器进行微调。        IDA是一个微分代数求解器。因此，它对一阶导数也需要初始条件。如果你没有提供一致的初始条件，（即F(y_dot(0), y(0), 0)=0的条件），你可以在构造时使用`ic_type`参数要求SUNDIALS为你计算初始条件。        你有三个选择
* 

* 
* 

* 
 

 
 

 
 

 
* 
* - 无：不要试图使初始条件一致。
* 

* 
 

 
 

 
 

 
 

 
* 
* - use_y_diff: 计算y的代数成分和y_dot的微分成分，给定y的微分成分。这个选项要求用户在函数get_differential_components中指定微分和代数成分。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - use_y_dot: 计算y的所有分量，给定y_dot。        默认情况下，该类假设所有分量都是微分，并且你想解决一个标准的颂歌。在这种情况下，初始分量类型被设置为`use_y_diff'，因此在时间t=`初始时间'的`y_dot'是通过解决变量`y_dot'的非线性问题[2.x.43]计算的。        请注意，牛顿求解器被用于这一计算。牛顿求解器的参数可以通过作用于`ic_alpha`和`ic_max_iter`进行调整。        如果你在某个时候重置求解器，你可能想在重置后为初始条件选择一个不同的计算。比如说，你完善了一个网格，在将解转移到新的网格后，初始条件不再一致了。那么你可以选择如何使其一致，使用与`reset_type`中初始条件相同的三个选项。        在串行情况下，MPI通信器被简单地忽略了。         [2.x.44] data IDA配置数据 [2.x.45] mpi_comm MPI通信器    
* [0.x.23]*
     解构器。   
* [0.x.24]*
     对微分代数方程进行积分。该函数返回最终的计算步骤数。   
* [0.x.25]*
     清理内部内存，以干净的对象开始。这个函数在模拟开始时和用户对solver_should_restart()的调用返回true时被调用。        默认情况下，solver_should_restart()返回false。如果用户需要实现例如空间的局部适应性，可以给solver_should_restart()指定一个不同的函数，执行所有的网格变化，将解和解点转移到新的网格，并返回true。        在reset()过程中，y和yp都会被检查是否一致，根据指定的ic_type（如果t==initial_time）或reset_type（如果t>initial_time），yp、y或两者都被修改以获得一致的初始数据集。         [2.x.46] t 新的起始时间 [2.x.47] h 新的（暂定）起始时间步骤 [2.x.48] y 新的（暂定）初始解 [2.x.49] yp 新的（暂定）初始解_dot    
* [0.x.26]*
     重新设置向量，使其具有正确的大小和MPI通信器等。   
* [0.x.27]*
     计算残差。返回 [2.x.50] 。        这个函数应该返回。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 0: 成功
 

 
* 

* 
* 

 
 

 
 

 
* 
* - >0: 可恢复的错误（如果发生这种情况，将调用IDAReinit，然后再次尝试最后一个函数
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - <0: 无法恢复的错误，计算将被中止，并抛出一个断言。   
* [0.x.28]*
     计算雅各布系数。IDA在任何需要更新雅各布的时候都会调用这个函数。用户应该计算Jacobian（或者更新所有允许应用Jacobian的变量）。IDA在调用solve_jacobian_system()（适用于SUNDIALS < 4.0.0）或solve_with_jacobian()（适用于SUNDIALS >= 4.0.0）之前，会调用该函数一次。        雅各邦[2.x.51]应该是[1.x.10]的一个（可能是不精确的）计算，如果用户使用基于矩阵的雅各邦计算，那么在这里应该调用一个装配例程来装配雅各邦系统的矩阵和预处理程序。    随后调用（可能不止一次）solve_jacobian_system()或solve_with_jacobian()可以假设这个函数至少被调用过一次。        请注意，这个接口没有假设用户在这个函数中应该做什么。IDA只假设在调用setup_jacobian()后，有可能调用solve_jacobian_system()或solve_with_jacobian()来获得系统的解 [2.x.52] 。        这个函数应该返回。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 0: 成功
 

 
* 

* 
* 

 
 

 
 

 
* 
* - >0: 可恢复的错误（如果发生这种情况，将调用IDAReinit，然后再次尝试最后一个函数
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - <0: 无法恢复的错误，计算将被中止，并抛出一个断言。   
* [0.x.29]*
     解决Jacobian线性系统。这个函数将在setup_jacobian()被调用至少一次之后被IDA调用（可能是多次）。IDA试图尽最大努力调用setup_jacobian()最少的次数。如果不更新雅各布式就能实现收敛，那么IDA就不会再次调用setup_jacobian()。相反，如果IDA内部收敛测试失败，那么IDA会用更新的向量和系数再次调用setup_jacobian()，这样连续调用solve_jacobian_systems()会导致牛顿过程中更好的收敛。        雅可比[2.x.54]应该是系统雅可比[1.x.11]的（近似值）。对该函数的调用应该在`dst`中存储[2.x.55]应用于`src`的结果，即`J*dst = src`。用户有责任在这个函数中设置适当的求解器和预处理器。        这个函数应该返回。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 0: 成功
 

 
* 

* 
* 

 
 

 
 

 
* 
* - >0: 可恢复的错误（如果发生这种情况，将调用IDAReinit，然后再次尝试最后一个函数
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - <0: 无法恢复的错误，计算将被中止，并抛出一个断言。         [2.x.56] 从SUNDIALS 4.1开始，SUNDIALS提供了指定分辨率的公差的可能性。从公差的一部分只提供`rhs`，`dst`需要返回。   
* [0.x.30]*
     解决雅各布线性系统，直到指定的公差。这个函数将在setup_jacobian()被调用至少一次之后被IDA调用（可能是多次）。IDA试图尽最大努力调用setup_jacobian()的最少次数。如果不更新雅各布式就能实现收敛，那么IDA就不会再次调用setup_jacobian()。相反，如果IDA内部收敛测试失败，那么IDA会用更新的向量和系数再次调用setup_jacobian()，这样连续调用solve_with_jacobian()会导致牛顿过程中更好的收敛。        雅各邦[2.x.57]应该是系统雅各邦[1.x.12]的（近似值），函数的参数是。         [2.x.58] rhs 要解决的系统右侧。     [2.x.59] dst [2.x.60] 的解。     [2.x.61] tolerance 解决线性方程组的公差。        对该函数的调用应该在`dst`中存储[2.x.62]应用于`src`的结果，即线性系统`J*dst = src`的解。    用户有责任在这个函数中或在`setup_jacobian()`函数中设置适当的求解器和预处理器。例如，后者是[2.x.63]程序所做的。所有昂贵的操作都发生在`setup_jacobian()`中，因为该函数被调用的频率远低于当前函数）。)         这个函数应该返回。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 0: 成功
 

 
* 

* 
* 

 
 

 
 

 
* 
* - >0: 可恢复的错误（如果发生这种情况，将调用IDAReinit，然后再次尝试最后一个函数）。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - <0: 无法恢复的错误，计算将被中止，并抛出一个断言。   
* [0.x.31]*
     处理解决方案。这个函数由IDA在固定的时间步数上调用，每隔`output_period`秒，它被传递给解决方案的多项式插值及其时间导数，使用当前的BDF顺序和（内部存储的）先前计算的解决方案步数计算。        请注意，IDA内部计算的时间步长很可能比`output_period`步长大得多，因此通过简单地执行所有中间插值，连续多次调用这个函数。这个函数被调用的次数和实际计算的时间步数之间没有关系。   
* [0.x.32]*
     评估求解器是否应该被重新启动（例如因为自由度的数量发生了变化）。        这个函数应该执行所有在`sol`和`sol_dot`中需要的操作，以确保得到的向量是一致的，并且最终大小正确。        例如，我们可以决定在时间t有必要进行局部细化。这个函数应该返回true，并改变sol和sol_dot的尺寸以反映新的尺寸。由于IDA不知道新的维度，所以内部重置是必要的。        默认实现只是返回 "false"，也就是说，在演化过程中不进行重启。   
* [0.x.33]*
     返回一个包含微分成分的索引集。    这个函数的实现是可选的。默认是返回一个完整的索引集。如果你的方程也是代数的（即它包含代数约束，或拉格朗日乘数），你应该覆盖这个函数，以便只返回系统的微分成分。        当并行运行时，每个进程都会独立地调用这个函数，同步将在初始化设置结束时发生，以沟通哪些组件是本地的。确保你只返回本地拥有的（或本地相关的）组件，以减少进程间的通信。   
* [0.x.34]*
     返回一个向量，其成分是IDA用来计算向量法线的权重。这个函数的实现是可选的。如果用户没有提供实现，则假设权重为所有的1。   
* [0.x.35]*
     处理IDA的异常。   
* [0.x.36]*
     当一个具有给定名称的函数没有实现时，抛出一个异常。   
* [0.x.37]*
     这个函数在构造时被执行，以设置上面的[2.x.64]，如果它们没有被实现，则触发一个断言。   
* [0.x.38]*
     IDA配置数据。   
* [0.x.39]*
     IDA内存对象。   
* [0.x.40]*
     MPI通信器。SUNDIALS解算器可以愉快地并行运行。注意，如果库的编译没有MPI支持，MPI_Comm被别名为int。   
* [0.x.41]*
     向量的内存池。   
* [0.x.42]

