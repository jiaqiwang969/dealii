include/deal.II-translator/hp/dof_handler_0.txt
[0.x.0]*
   管理hp- FEM算法的自由度的分布和编号。这个类满足了[2.x.0]"MeshType概念 "的要求。    这个类的目的是允许以与::DoFHandler类相同的方式枚举自由度，但它允许在每个单元上使用不同的有限元。为此，我们给每个单元分配一个[2.x.1]，表示在有限元集合中的哪个元素（由[2.x.2]类型的对象表示）是住在这个单元上的。然后，该类列举了三角形的每个单元上与这些有限元相关的自由度，如果可能的话，还可以识别单元界面上的自由度，如果它们匹配的话。如果相邻的单元沿共同界面的自由度不立即匹配（例如，如果你有[2.x.3]和[2.x.4]元素在一个共同的面相遇），那么就需要计算约束，以确保网格上产生的有限元空间保持一致。    整个处理这种类型的对象的过程在 [2.x.5] 中有解释。这个类实现的许多算法在 [2.x.6] "hp-paper "中描述。      [1.x.0] 使用该类的典型工作流程是创建一个网格，给每个活动单元分配一个活动FE索引，调用[2.x.7]，然后在这个有限元空间上装配一个线性系统并解决问题。然而，在某些情况下，我们可以在网格细化时跳过分配活动FE指数。特别是，以下规则适用。
* 

* 
* 

* 
* 

 
* 
* - 网格细化时，子单元会继承父单元的活动FE索引。
 

 
 

 
 

 
* 
* - 当粗化单元时，（现在活动的）父单元将被分配一个活动的FE索引，该索引由其（不再活动的）子单元决定，遵循FiniteElementDomination逻辑。在以前分配给前子女的元素集合中，我们选择一个由所有子女支配的元素作为父单元。如果没有找到，我们就在整个集合中挑选一个被所有以前的孩子支配的最主要的元素。关于这个主题的进一步信息，请参见[2.x.8]。   
* [2.x.9] 有限元素需要先通过调用set_fe()或distribution_dofs()来分配给每个单元格，以使这个功能可用。      [1.x.1] 当这个类与[2.x.10]或[2.x.11]一起使用时，你只能在本地拥有的单元上设置活动FE指数，使用诸如[2.x.12]的调用。  另一方面，不允许在幽灵或人工单元上设置活动FE指数。    然而，幽灵单元确实获得了什么元素在其上处于活动状态的信息：每当你调用[2.x.13]时，所有参与并行网格的处理器都会以这样的方式交换信息，幽灵单元上的活动FE指数等于在拥有该特定幽灵单元的处理器上设置的活动FE指数。  因此，人们可以[1.x.2]幽灵单元上的[2.x.14]，只是不能用手去设置。    在人工单元上，没有关于那里使用的[2.x.15]的信息可用。这是因为我们甚至不知道这些细胞是否存在，即使存在，当前的处理器也不知道关于它们的任何具体信息。  更多信息见[2.x.16]"人工细胞的词汇表条目"。    在细化和粗化过程中，关于每个单元的[2.x.17]的信息将被自动转移。    然而，使用[2.x.18]和[2.x.19]需要在序列化过程中额外注意，因为活动FE指数的信息不会被自动转移。这必须使用prepare_for_serialization_of_active_fe_indices()和deserialize_active_fe_indices()函数手动完成。前者必须在调用[2.x.20]之前调用，后者需要在[2.x.21]之后运行。 如果进一步的数据将通过[2.x.22][2.x.23]或[2.x.24]类附加到三角形上，所有相应的准备和反序列化函数调用需要以相同的顺序发生。更多信息请参考[2.x.25]的文档。     
* [2.x.26] [2.x.27] 基本的[2.x.28]现在能够进行hp-adaptation。 
* [0.x.1]

