include/deal.II-translator/hp/mapping_collection_0.txt
[0.x.0]*
   这个类实现了映射对象的集合，与[2.x.0]实现有限元类集合的方式相同。    它实现了doxygen文档中描述的[2.x.1]模块中的概念。    尽管建议为hp-computation中使用的每个有限元种类提供一个适当的映射，但MappingCollection类实现了一个来自单一映射的转换构造器。 因此，可以只为[2.x.2]类提供一个映射，而不是[2.x.3]类。这是为了方便用户，因为许多简单的几何形状不需要沿边界提供不同的映射来达到最佳收敛率。 因此，提供一个单一的映射对象通常就足够了。参见[2.x.4]类中关于为给定单元选择映射的规则。   
* [2.x.5]   
* [0.x.1]*
     默认构造函数。导致一个空的集合，以后可以用push_back()来填充。   
* [0.x.2]*
     转换构造函数。这个构造函数从一个单一的映射中创建一个MappingCollection。如果需要的话，可以用push_back()添加更多的映射，尽管用同样的方式添加所有的映射可能会更清楚。   
* [0.x.3]*
     复制构造函数。   
* [0.x.4]*
     构造函数。这个构造函数从传递给构造函数的一个或多个映射对象创建一个MappingCollection。为了使这个调用有效，所有的参数都需要是从Mapping<dim,spacedim>类派生的类型。   
* [0.x.5]*
     向MappingCollection添加一个新的映射。一般来说，你会希望对映射使用与你使用的[2.x.6]对象的元素相同的顺序。然而，与[2.x.7]函数讨论的相同的考虑因素也适用于当前的环境。        这个类创建了一个给定映射对象的副本，也就是说，你可以做像<tt>push_back(MappingQ<dim>(3));</tt>的事情。这个内部拷贝后来在整个集合被销毁时被这个对象销毁。   
* [0.x.6]*
   库中的许多地方默认使用（bi-,tri-）线性映射，除非用户明确提供不同的映射来使用。在这些情况下，被调用的函数必须创建一个[2.x.8]映射对象，即一个MappingQGeneric(1)类型的对象。这是很昂贵的。在受影响的函数中创建这样的对象作为静态对象也是很昂贵的，因为静态对象在程序的整个生命周期中都不会被销毁，尽管它们只需要在代码第一次运行某个特定函数时创建一次。    为了避免在整个库的这些上下文中创建（静态或动态）[2.x.9]映射对象，这个类定义了一个具有单一[2.x.10]映射对象的静态映射集合。然后这个集合可以在所有需要这种集合的地方使用。 
* [0.x.7]*
     公开可用的静态[2.x.11] 映射集合对象。   
* [0.x.8]

