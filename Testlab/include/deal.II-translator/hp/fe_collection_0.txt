include/deal.II-translator/hp/fe_collection_0.txt
[0.x.0]*
   该类作为DoFHandler中使用的有限元对象的集合。    它实现了doxygen文档中描述的[2.x.0]模块中的概念。    除了提供对集合元素的访问外，该类还提供对每个顶点、线等的最大自由度的访问，以便在使用与三角形单元相关的有限元时，在最坏的情况下分配尽可能多的内存。    这个类还没有实现在一维情况下的使用（<tt>spacedim != dim </tt>）。   
* [2.x.1]   
* [0.x.1]*
     在hp-finite element程序中考虑p-adaptivity时，需要建立一个有限元的层次结构，以确定细化的后续有限元和粗化的前期有限元。        在这个结构中，我们提供了一个层次结构，默认情况下强加在所有FECollection对象上。   
* [0.x.2]*
       返回[2.x.3]中[2.x.2]的后续索引 一旦到达[2.x.4]的最后一个元素，在层次结构中就没有更高层次的元素，因此我们返回最后的值。     
* [0.x.3]*
       返回[2.x.6]中[2.x.5]之前的索引 一旦到达[2.x.7]的第一个元素，在层次结构中就没有较低层次的元素，因此我们返回第一个值。     
* [0.x.4]*
     默认构造函数。导致一个空的集合，以后可以用push_back()来填充。建立一个有限元的层次结构，与它们在集合中的索引相对应。   
* [0.x.5]*
     转换构造函数。这个构造函数从一个单一的有限元创建一个FECollection。如果需要，可以用push_back()添加更多的有限元对象，尽管用同样的方式添加所有的映射可能会更清楚。   
* [0.x.6]*
     构造函数。这个构造函数从传递给构造函数的一个或多个有限元对象创建一个FECollection。为了使这个调用有效，所有的参数都需要是派生自FiniteElement<dim,spacedim>类的类型。   
* [0.x.7]*
     构造函数。和上面一样，但是对于任何数量的元素。元素的指针以向量形式传递给这个构造函数。如上所述，参数所指向的有限元对象除了在内部创建副本外，实际上并不使用。因此，你可以在调用这个构造函数后立即再次删除这些指针。   
* [0.x.8]*
     拷贝构造函数。   
* [0.x.9]*
     移动构造函数。       
* [2.x.8]标准数据类型的实现可能会随着不同的库而改变，所以它们的移动成员可能会或不会被标记为非抛出。    我们需要根据其成员变量显式地设置noexcept指定器，以便仍然获得性能优势（并满足clang-tidy）。   
* [0.x.10]*
     移动赋值运算符。   
* [0.x.11]*
     等价比较运算符。所有存储的FiniteElement对象都按顺序进行比较。   
* [0.x.12]*
     非等价比较运算符。所有存储的FiniteElement对象按顺序进行比较。   
* [0.x.13]*
     添加一个有限元素。这个函数生成一个给定元素的副本，即你可以做类似<tt>push_back(FE_Q<dim>(1));</tt>的事情。    这个内部拷贝后来在整个集合被销毁时被这个对象销毁。        当一个新的元素被添加时，它需要拥有与已经在集合中的所有其他元素相同数量的向量成分。   
* [0.x.14]*
     返回这个集合中的有限元素的向量分量的数量。 这个数字对于集合中的所有元素必须是相同的。        这个函数调用[2.x.9]更多信息见[2.x.10]"术语表"。   
* [0.x.15]*
     返回这个集合中的有限元素的向量块的数量。虽然这个类保证了存储在其中的所有元素都有相同数量的向量分量，但是对于每个元素所组成的块数却没有这样的保证（一个元素的块数可能少于向量分量，更多信息见[2.x.11] "术语表"）。例如，你可能有一个FECollection对象，它存储了一份带有[2.x.12] FE_Q对象的FESystem和一份FE_RaviartThomas元素的副本。两者都有[2.x.13]向量成分，但前者有[2.x.14]块，后者只有一个。因此，如果所有元素的块数不一样，这个函数将抛出一个断言。如果它们相同，该函数返回的结果是[2.x.15] 。    
* [0.x.16]*
     返回[2.x.16]在这个集合的所有元素上返回的值的最大值。   
* [0.x.17]*
     返回此集合所有元素中每个顶点的最大自由度数。   
* [0.x.18]*
     返回这个集合的所有元素中每条线的最大自由度数。   
* [0.x.19]*
     返回这个集合中所有元素的每个四边形的最大自由度数。   
* [0.x.20]*
     返回这个集合中所有元素中每个六度的最大自由度数。   
* [0.x.21]*
     返回这个集合的所有元素中每个面的最大自由度数。   
* [0.x.22]*
     返回这个集合的所有元素中每个单元的最大自由度数。   
* [0.x.23]*
     返回这个集合中的所有元素是否以新的方式实现了悬挂节点约束，这必须用于使元素 "hp-compatible"。如果不是这样，该函数返回false，这意味着FECollection中至少有一个元素不支持新的面孔接口约束。另一方面，如果这个方法确实返回true，这并不意味着hp-方法会起作用。        这种行为与以下事实有关，即提供新式悬挂节点约束的FiniteElement类可能仍然没有为所有可能的情况提供这些约束。如果FE_Q和FE_RaviartThomas元素包含在FECollection中，并且都正确实现了get_face_interpolation_matrix方法，这个方法将返回true。    但是get_face_interpolation_matrix可能仍然无法找到这两个元素之间的插值矩阵。   
* [0.x.24]*
     返回这个FECollection中支配所有与所提供的索引集相关的元素的有限元素的索引 [2.x.17] 你可以在其各自的类文档或其继承的成员函数的实现中找到关于有限元素的支配行为的信息 [2.x.18] 考虑到一个有限元素可能支配也可能不支配它自己（例如FE_Nothing元素）。        例如，如果一个FEC集合由`{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}`元素组成，我们要寻找支配这个集合中间元素的有限元素（即[2.x.19]为`{1,2}`），那么答案是`{FE_Q(1),FE_Q(2)`，因此这个函数将返回它们在FEC集合中的索引，即`{0,1}`。        [2.x.20]参数描述了被调查的子空间的码率，并指定它受此比较。更多信息见[2.x.21]。   
* [0.x.25]*
     返回此FECollection中被与所提供的指数集相关的所有元素支配的有限元的指数 [2.x.22] 你可以在其各自的类文件或其继承的成员函数的实现中找到关于有限元的支配行为的信息 [2.x.23] 考虑到一个有限元可能支配也可能不支配自己（例如，FE_Nothing元素）。        例如，如果一个FEC集合由`{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}`元素组成，我们要寻找被这个集合的中间元素支配的有限元素（即。 [2.x.24]是`{1,2}`，那么答案是`{FE_Q(3),FE_Q(4)`，因此这个函数将返回它们在FEC集合中的索引，即`{2,3}`。        [2.x.25]参数描述了被调查的子空间的码率，并指定它受此比较。更多信息见[2.x.26]。   
* [0.x.26]*
     返回所提供的指数集[2.x.27]中的一个有限元素的指数，该元素支配着这个非常集合中的所有其他元素。        你可以在其各自的类文件中或在其继承的成员函数的实现中找到关于有限元的支配行为的信息 [2.x.28] 考虑到一个有限元可能支配也可能不支配自己（例如FE_Nothing元素）。        如果这个集合正好由一个元素组成，我们认为它是支配性的，并返回其相应的索引。此外，如果函数根本无法找到一个有限元素，则返回[2.x.29] 例如，如果一个FEC集合由`{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}`元素组成，我们要在这个集合的中间元素中寻找主导的有限元素（即。 [2.x.30]是`{1,2}`），那么答案是FE_Q(2)，因此这个函数将返回它在FEC集合中的索引，即`1`。        当然，有可能存在不止一个元素支配着所有被选中的元素。例如，如果集合由`{FE_Q(1),FE_Q(1),FE_Q(2),FE_Q(2)}`组成，并且`fes`涵盖所有的索引，那么可以返回0或1。 在这种情况下，该函数要么返回 "0"，要么返回 "1"，因为两者之间不存在平局。        [2.x.31]参数描述了被调查的子空间的二维度，并指定它要接受这种比较。更多信息见[2.x.32]。   
* [0.x.27]*
     返回所提供的指数集[2.x.33]中的一个有限元素的指数，该元素被这个非常集合的所有其他元素所支配。        你可以在其各自的类文件中或其继承成员函数的实现中找到关于有限元的支配行为的信息 [2.x.34] 考虑到一个有限元可能支配自己，也可能不支配自己（例如FE_Nothing元素）。        如果这个集合正好由一个元素组成，我们认为它是被支配的，并返回其相应的索引。此外，如果函数根本无法找到有限元，则返回[2.x.35] 例如，如果一个FEC集合由`{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}`元素组成，我们在这个集合的中间元素中寻找支配的有限元（即。 [2.x.36]是`{1,2}`），那么答案是FE_Q(3)，因此这个函数将返回它在FEC集合中的索引，即`2`。        当然，有可能存在不止一个元素被所有选定的元素所支配。例如，如果集合由`{FE_Q(1),FE_Q(1),FE_Q(2),FE_Q(2)}`组成，并且`fes`覆盖了所有的索引，那么可以返回2或3。 在这种情况下，该函数要么返回`2`，要么返回`3`，因为两者之间没有平局。        [2.x.37]参数描述了被调查的子空间的维度，并指定它要接受这种比较。更多信息见[2.x.38]。   
* [0.x.28]*
     返回所提供的指数集[2.x.39]中的一个有限元素的指数，该元素支配着这个非常集合中的所有其他元素。如果我们没有成功，我们就在整个集合上扩大搜索范围，挑选最不占优势的，也就是描述最大的有限元空间的元素，所提供的集合[2.x.40]的所有有限元都是其中的一部分。        你可以在其各自的类文件中或其继承的成员函数的实现中找到关于有限元的支配行为的信息[2.x.41] 考虑到一个有限元可以支配也可以不支配自己（例如FE_Nothing元素）。        如果这个集合正好由一个元素组成，我们认为它是被支配的，并返回其相应的索引。此外，如果函数根本无法找到一个有限元，则返回[2.x.42] [2.x.43]参数描述了所研究的子空间的二维度，并指定它受此比较。更多信息见[2.x.44]。   
* [0.x.29]*
     返回所提供的指数集[2.x.45]中的一个有限元素的指数，该元素被这个非常集的所有其他元素所支配。如果我们没有成功，我们就在整个集合上扩展搜索，挑选出最被支配的，也就是描述最小的有限元空间的元素，该空间包括所提供集合的所有有限元[2.x.46]你可以在其各自的类文档中或其继承成员函数的实现中找到关于有限元支配行为的信息[2.x.47]考虑到一个有限元可能支配也可能不支配自己（例如，FE_Nothing元素）。        如果这个集合正好由一个元素组成，我们就认为它是支配性的，并返回其相应的索引。此外，如果该函数根本无法找到一个有限元素，则返回[2.x.48] [2.x.49]参数描述了被调查的子空间的二维度，并指定其受此比较。更多信息见[2.x.50]。   
* [0.x.30]*
     确定有限元层次的集合函数，即一个函数[2.x.51]返回给定的有限元后的索引，一个函数[2.x.52]返回前一个。        这两个函数都需要一个[2.x.53]来传递有限元索引，在其基础上找到并返回新的索引。       
* [2.x.54] 传递和返回的索引都必须在这个集合的索引范围内有效，即在[0, size()]内。   
* [0.x.31]*
     设置与集合中每个有限元的索引相对应的默认层次结构。        这个默认层次是通过函数[2.x.55]和[2.x.56]建立的。    
* [0.x.32]*
     返回一个对应于注册层次结构的FE指数序列，以升序排列，即FE指数从低到高排序。        用set_hierarchy()注册的一个自定义层次结构可以有多个FE指数序列。该函数将返回包含用户提供的索引[2.x.57]的序列，该索引可以位于序列内的任何位置。通过set_default_hierarchy()设置的默认层次结构，对应于升序的FE指数，只包含一个序列。        例如，这个函数可以用来验证你所提供的层次结构是否涵盖了所有的元素，并符合所需的顺序。        如果返回的容器的大小等于这个对象的元素数，则只存在一个FE指数序列，即[2.x.58] 。    
* [0.x.33]*
     %函数返回层次结构中给定的[2.x.59]之后的有限元的索引。        默认情况下，将返回[2.x.60]之后的索引。如果[2.x.61]已经对应于最后一个索引，将返回最后一个索引。    可以通过成员函数set_hierachy()提供一个自定义的层次结构。   
* [0.x.34]*
     %函数返回层次结构中给定[2.x.62]之前的有限元的索引。        默认情况下，将返回[2.x.63]之前的索引。如果[2.x.64]已经对应于第一个索引，第一个索引将被返回。    可以通过成员函数set_hierachy()提供一个自定义的层次结构。   
* [0.x.35]*
     返回一个分量掩码，其元素数量与此对象的向量分量相同，并且其中正好有一个分量是真实的，与给定的参数相对应。       
* [2.x.65] 这个函数等同于[2.x.66]，参数相同。它验证了它是否从存储在这个FECollection中的每一个元素中得到了相同的结果。如果不是这样的话，它会抛出一个异常。         [2.x.67] 标量 一个代表该有限元的单一标量矢量分量的对象。     [2.x.68] 一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。   
* [0.x.36]*
     返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的[2.x.69]分量为真。       
* [2.x.70]这个函数等同于[2.x.71]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。         [2.x.72] 矢量 一个表示该有限元的微弱矢量成分的对象。     [2.x.73] 一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。   
* [0.x.37]*
     返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的[2.x.74]分量为真。       
* [2.x.75]这个函数等同于[2.x.76]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。         [2.x.77] sym_tensor 一个表示该有限元的dim*(dim+1)/2组件的对象，这些组件共同被解释为形成一个对称张量。     [2.x.78]一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。   
* [0.x.38]*
     给定一个块掩码（见[2.x.79] "本词汇表条目"），产生一个分量掩码（见[2.x.80] "本词汇表条目"），代表与输入参数中选择的块对应的分量。这本质上是一个从BlockMask到ComponentMask的转换操作。       
* [2.x.81] 这个函数等同于[2.x.82]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。         [2.x.83] block_mask 选择有限元单个块的掩码 [2.x.84] 选择那些与输入参数的选定块对应的组件的掩码。   
* [0.x.39]*
     返回一个块掩码，其元素数与此对象的块数相同，并且其中正好有一个与给定参数相对应的成分是真的。更多信息请参见 [2.x.85] "术语表"。       
* [2.x.86] 这个函数只有在参数所引用的标量包含一个完整的块时才会成功。换句话说，例如，如果你传递了一个单一[2.x.87]速度的提取器，并且这个对象代表一个FE_RaviartThomas对象，那么你选择的单一标量对象是一个更大的块的一部分，因此没有代表它的块屏蔽。然后该函数将产生一个异常。       
* [2.x.88] 这个函数相当于[2.x.89]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样的话，它会抛出一个异常。         [2.x.90] 标量 一个代表该有限元的单个标量向量分量的对象。     [2.x.91] 一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。   
* [0.x.40]*
     返回一个分量掩码，其元素数与此对象的向量分量相同，并且其中对应于给定参数的[2.x.92]分量为真。更多信息见[2.x.93] "术语表"。       
* [2.x.94] 这个函数等同于[2.x.95]，参数相同。它验证是否从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样的话，它会抛出一个异常。       
* [2.x.96] 同样的注意事项适用于上述函数的版本。    作为参数传递的提取器对象必须使其对应于完整的块，而不是分割这个元素的块。         [2.x.97] vector 一个表示该有限元的dim向量分量的对象。     [2.x.98] 一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。   
* [0.x.41]*
     返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的[2.x.99]分量为真。更多信息见[2.x.100] "术语表"。       
* [2.x.101] 同样的注意事项适用于上述函数的版本。    作为参数传递的提取器对象必须使其对应于完整的块，而不是分割此元素的块。       
* [2.x.102] 这个函数等同于[2.x.103]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。         [2.x.104] sym_tensor 一个代表该有限元的dim*(dim+1)/2组件的对象，这些组件共同被解释为形成一个对称张量。     [2.x.105] 一个分量掩码，在所有分量中都是假的，除了与参数相对应的那些。   
* [0.x.42]*
     给定一个分量掩码（见[2.x.106] "本词汇表条目"），产生一个块掩码（见[2.x.107] "本词汇表条目"），代表与输入参数中选择的分量对应的块。这本质上是一个从ComponentMask到BlockMask的转换操作。       
* [2.x.108] 这个函数只有在参数所引用的组件包含完整的块时才会成功。换句话说，例如，如果你传递了一个单一[2.x.109]速度的组件掩码，而这个对象代表一个FE_RaviartThomas对象，那么你选择的单一组件是一个更大的块的一部分，因此，没有代表它的块掩码。然后该函数将产生一个异常。       
* [2.x.110] 这个函数相当于[2.x.111]，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。         [2.x.112]component_mask 选择有限元个别组件的掩码 [2.x.113]选择那些与输入参数的选定块对应的掩码。   
* [0.x.43]*
      [2.x.114] 异常情况 [2.x.115]     
* [0.x.44]*
     异常情况        
* [2.x.116]     
* [0.x.45]*
      [2.x.117]     
* [0.x.46]*
     %函数返回层次结构中给定元素之后的有限元素的索引。   
* [0.x.47]*
     返回在层次结构中给定的有限元之前的有限元的索引的函数。   
* [0.x.48]

