include/deal.II-translator/A-tutorial/step-75_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16 ][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32]
* [2.x.4] 
* [1.x.33]
 

* 
* [2.x.5] 作为这个程序的先决条件，你需要安装p4estlibrary和Trilinos库。在[1.x.34]文件中描述了deal.IItogether与这些附加库的安装。
* 

* 
* [1.x.35][1.x.36][1.x.37] 。
* 

* 在有限元背景下，更多的自由度通常会产生更精确的解决方案，但也需要更多的计算工作。
* 在以前的整个教程中，我们找到了通过将网格分辨率与解的复杂性进行局部调整来有效分布自由度的方法（自适应网格细化，[2.x.6] ）。如果我们不仅调整网格，而且还局部调整每个单元上的相关无限元素的多项式程度，这种方法就特别有效（hp-adaptation, [2.x.7] ）。
* 此外，分配更多的进程来同时运行你的程序，有助于在更短的时间内解决计算的工作量。根据你的机器的硬件架构，你的程序必须为所有进程都能访问相同的内存（共享内存，[2.x.8]），或者进程被托管在几个独立的节点上（分布式内存，[2.x.9]）的情况做好准备。
* 在高性能计算领域，内存访问被证明是当前超级计算机的瓶颈。我们可以通过MatrixFree方法（[2.x.10]）在飞行中计算矩阵向量乘积的效果来避免完全存储矩阵。它们可用于几何多网格方法（[2.x.11]），也可用于多项式多网格方法，以极大地加快方程组的求解速度。
* 本教程结合所有这些特点，以最先进的方式介绍了如何解决一个简单的拉普拉斯问题：在具有分布式内存的机器上利用hp-adaptation和无矩阵混合多栅方法。
* 

* [1.x.38][1.x.39] 。
* 

* 对于有限元的并行应用，我们将网格划分为子域（又称域分解），并将其分配给进程。正如在[2.x.12]中所展示的，这种划分发生在deal.II的活动单元上。在那里，每个单元都有相同的有限元和相同的自由度分配，以及大约相同的工作负荷。为了平衡所有进程的工作量，我们必须平衡所有参与进程中的单元数量。
* 有了hp自适应方法，情况就不一样了：有限元类型可能因单元而异，因此自由度的数量也不同。匹配单元的数量并不能产生平衡的工作量。在无矩阵的情况下，工作量可以假定为与每个过程的自由度数量成正比，因为在最好的情况下，只有源向量和目的向量需要被加载。
* 我们可以通过给每个单元分配权重来平衡工作量，这些权重与自由度的数量成正比，并在所有进程之间平衡所有权重的总和。给每个单元分配单独的权重可以用我们以后要用的[2.x.13]类来实现。
* 

*[1.x.40][1.x.41]。
* 

* 使用hp-adaptive方法，我们不仅要决定哪些单元要细化或粗化，而且还要选择如何做：要么调整网格分辨率，要么调整有限元的多项式程度。
* 我们将再次根据当前解决方案的（后验）计算误差估计值来决定哪些单元需要调整，例如，使用KellyErrorEstimator。我们将同样决定如何适应（事后）计算的平滑度估计：大的多项式度数在解决方案的平滑部分效果最好，而细的网格分辨率在不规则部分是有利的。在[2.x.14]中，我们提出了基于傅里叶系数的衰减来计算光滑度估计值。让我们利用这个机会，提出另一种遵循同样思路的方法，但采用Legendre系数。
* 我们将简要介绍这种新技术的思路，但为了简单起见，将其描述限于一维。假设[2.x.15]是一个定义在单元[2.x.16]上的有限元函数[1.x.42]，其中每个[2.x.17]是一个形状函数。我们可以在Legendre多项式[2.x.19]的基础上等效地表示[2.x.18]为[1.x.43]。我们的目标是在有限元系数[2.x.20]和Legendre系数[2.x.21]之间获得一个映射。我们将通过把问题写成[2.x.22]对[2.x.23]在Legendre基础上的投影来实现这一目标。每个系数[2.x.24]都可以通过[1.x.44]计算。根据结构，Legendre多项式在[2.x.25]的内积下是正交的。此外，我们假设它们已经被归一化，所以它们的内积可以写成[1.x.45]，其中[2.x.27]是Kronecker delta，[2.x.28]是[2.x.29]到[2.x.30]的映射的Jacobian，（在本教程中）假设它是常数（即，该映射必须是仿射）。
* 因此，结合所有这些假设，在Legendre基础上表达[2.x.31]的投影矩阵只是[2.x.32] 。
* 
*也就是说，[2.x.33]乘以身份矩阵。让[2.x.34]成为从[2.x.35]到其参考单元[2.x.36]的映射。因此，投影系统中右侧的条目为：[1.x.46]回顾[2.x.37]的形状函数表示，我们可以将其写成[2.x.38]，其中[2.x.39 ]是具有条目[1.x.47]的基数变化矩阵，因此[2.x.40]的值可以写成[2.x.41]独立于[2.x.42]的[2.x.43]，在转换为参考坐标后，将[2.x.44]前置因数。因此，把这一切放在一起，投影问题可以写成[1.x.48]，可以简单地改写成[1.x.49]。
* 在这一点上，我们需要强调的是，大多数有限元应用都使用非结构化的网格，对于这些网格的映射几乎总是非线性的。换句话说：[2.x.45]在整个单元中是常数的假设对于一般的网格来说是不正确的。因此，对[2.x.46]的正确计算不仅要求我们为每一个单元计算相应的变换矩阵[2.x.47]，而且还要求我们在单元[2.x.48]上定义一组类似Legendre的正交函数，该单元可能有一个任意的和非常复杂的几何形状。尤其是第二部分，计算成本非常高。目前FESeries变换类的实现是依靠有一个恒定的Jacobian所带来的简化来提高性能，因此只对仿射映射产生正确的结果。除此之外，这种情况对本教程来说并不构成问题，因为我们只使用方形的单元。
* Eibner和Melenk[2.x.49]认为，当且仅当Legendre系数的绝对值随指数增加而呈指数衰减时，一个函数是解析的，即可以用幂级数表示[2.x.50]：[1.x.50]衰减率[2.x.51]可以解释为衡量该函数的平稳性。我们可以把它理解为对转换系数进行线性回归拟合的斜率：[1.x.51] 。
* 我们将对每个单元进行这种拟合[2.x.52]，以获得有限元近似的平滑度的局部估计。衰减率[2.x.53]将作为hp适应的决策指标。对于具有多项式程度[2.x.55]的单元[2.x.54]上的有限元，计算[2.x.56]的系数被证明是估计平滑度的合理选择。你可以在[2.x.57]中找到一个更详细的、与维度无关的描述。
* 以上所有内容已经在[2.x.58]类和[2.x.59]命名空间中实现。有了误差估计和平滑度指标，我们就剩下对单元格进行实际细化和粗化的标记。来自[2.x.60]和[2.x.61]命名空间的一些函数将在后面帮助我们完成这些工作。
* 

* [1.x.52][1.x.53] 。
* 

* 有限元矩阵通常是非常稀疏的。此外，hp-adaptive方法对应于每行非零项数量变化很大的矩阵。一些最先进的预处理程序，如[2.x.62]中使用的代数多重网格（AMG），在这些情况下表现不佳。
* 因此，我们将依靠一个无矩阵的混合多网格预处理器。[2.x.63]已经证明了几何多网格方法与MatrixFree框架结合时的优越性。在hp-adaptive FEM上的应用需要一些额外的工作，因为一个单元的子女可能有不同的多项式度数。作为补救措施，我们首先对线性元素进行p松弛（类似于Mitchell[2.x.64]），然后以常规方式进行h松弛。在最粗的层次上，我们应用代数多网格解算器。p-multigrid、h-multigrid和AMG的结合使得该求解器成为一个混合多网格求解器。
* 我们将通过使用MGTransferGlobalCoarsening，在现有的全局粗化基础设施的帮助下，创建一个具有上述特殊要求的自定义混合多网格预处理器。
* 

*[1.x.54][1.x.55]
* 

* 对于椭圆方程来说，每个再入角通常会调用asingularity [2.x.65] 。我们可以利用这种情况对我们的hp决策算法进行测试：在所有需要调整的单元上，我们倾向于在奇点附近采用精细的网格，而在其他地方则采用高的多项式程度。
* 作为在这些条件下要解决的最简单的椭圆问题，我们选择了L型域中的拉普拉斯方程，其重角在坐标系的原点。
* 为了能够确定实际误差，我们制造了一个有已知解的边界值问题。在上述领域中，拉普拉斯方程的解是，在极坐标中，[2.x.66] : [1.x.56] 。
* 另见[2.x.67]或[2.x.68] 。解决方案看起来如下。
* [2.x.69] 
* 

 
* [1.x.160][1.x.161][1.x.162] 。
* 

* [1.x.163][1.x.164]。
* 

* deal.II库提供了多种策略来决定对单元的适应类型：要么调整网格分辨率，要么改变多项式程度。我们在本教程中只介绍了[1.x.165]策略，而[2.x.70]则展示了相同想法的[1.x.166]等价物。
* 关于这些策略的概述，请参见[2.x.71]中的 "扩展的可能性 "一节，或相应的文档中的详细描述。
* 在那里，提到了另一个到目前为止还没有在任何教程中展示过的策略：基于[1.x.167]的策略。这个方法在并行分布式应用中的使用比其他方法更棘手，所以我们将强调与之相伴的挑战。我们需要有关细化标志的最终状态的信息，并且我们需要在细化的网格之间转移解决方案。对于前者，我们需要将[2.x.72]函数附加到[2.x.73]信号上，使其被称为[1.x.168]的[2.x.74]函数。在这个阶段，所有的精炼标志和未来的FE指数都被最终设定，并且可以对错误进行可靠的预测。预测的误差需要借助于[2.x.75]在精炼网格之间进行转移。
* 试着在本教程中实施这些策略之一，并观察结果的微妙变化。你会注意到，所有的策略都能识别出重心角附近的奇异点，并在这些区域进行[2.x.76]精化，而在体域中则倾向于[2.x.77]精化。这些策略的详细比较见[2.x.78]。
* 

* [1.x.169][1.x.170] 。
* 

* 本教程只关注无矩阵策略。然而，所有的hp-adaptivealgorithms在并行分布式环境中也可以使用基于矩阵的方法。
* 要创建一个系统矩阵，你可以使用[2.x.79]函数，或者使用类似于[2.x.81]的[2.x.80]函数，然后你可以像往常一样将系统矩阵传递给求解器。
* 你可以对基于矩阵和无矩阵实现的结果进行计时，量化加速，并说服自己哪种变量更快。
* 

*[1.x.171][1.x.172]
* 

* 为了简单起见，我们将自己限制在单一类型的粗网格求解器（带AMG的CG）、平滑器（带point Jacobi预处理的Chebyshev平滑器），以及多网格算法中的几何粗化方案（globalcoarsening）。请自由尝试其他方法，研究它们的性能和稳健性。
* 

* [1.x.173][1.x.174] [2.x.82] 
* [0.x.1]

