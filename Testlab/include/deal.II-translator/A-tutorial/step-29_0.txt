include/deal.II-translator/A-tutorial/step-29_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
* [2.x.2]
* [1.x.23]
* [1.x.24] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考[1.x.25]中的说明如何做到这一点。
*

*[1.x.26][1.x.27][1.x.28]



* 一个经常出现的问题是如何用交易解决涉及复值函数的问题。对于许多问题，与其直接使用复值有限元，不如将复值函数分成实部和虚部，并使用单独的标量有限元场来离散其中的每一个。基本上，这相当于把一个单一的复值方程看成是两个实值方程的系统。这个简短的例子演示了如何在deal.II中通过使用[2.x.3]对象来堆叠两个代表实部和虚部的有限元场来实现。(相反的方法，保持所有的复值，在另一个教程程序中演示：见[2.x.4]。)当分成实部和虚部时，这里涉及的方程属于矢量值问题的范畴。关于这一主题的顶层概述可以在[2.x.5]模块中找到。
* 除了这个讨论之外，我们还讨论了ParameterHandler类，它提供了一种方便的方法，可以在运行时从配置文件中读取参数，而不需要重新编译程序代码。
*

*[1.x.29][1.x.30]


* 本程序的最初目的是模拟由一个具有可变几何形状的换能器透镜产生的超声波的聚焦特性。最近在医学成像方面的应用不仅使用超声波进行成像，而且还激发材料中的某些局部效应，如光学特性的变化，然后可以用其他成像技术进行测量。这些方法的一个重要因素是能够将超声波的强度集中在材料的一个特定部分，最好是一个点，以便能够检查材料在该特定位置的特性。
* 为了得出这个问题的模型，我们认为超声波是由波浪方程支配的压力波：[1.x.31]其中[2.x.6]是波速（为简单起见，我们假设它是常数），[2.x.7] 。边界[2.x.8]分为两部分[2.x.9]和[2.x.10]，其中[2.x.11]代表换能器透镜，[2.x.12]是吸收边界（也就是说，我们要在[2.x.13]上选择边界条件，使其模仿大域的方式）。在[2.x.14]上，换能器产生一个恒定频率[2.x.15]和恒定振幅（我们在这里选择为1）的波：[1.x.32] 。
* 如果没有其他（内部或边界）源，并且由于唯一的源具有频率[2.x.16]，那么该解决方案允许一个形式为[2.x.17]的变量分离。复值函数[2.x.18]描述了频率外波的振幅和相位（相对于源）的空间依赖性[2.x.19]，其中振幅是我们感兴趣的量。通过将这种形式的解决方案插入波浪方程，我们看到，对于[2.x.20]，我们有[1.x.33]
*
* 为了在[2.x.21]上找到合适的条件来模拟一个吸收边界，考虑一个频率为[2.x.23]的波在[2.x.24]方向上行驶。为了使[2.x.25]能够解决波浪方程，[2.x.26]必须成立。假设这个波在[2.x.27]中以直角撞击边界，即[2.x.28]，[2.x.29]表示[2.x.30]在[2.x.31]的外单位法线。然后在[2.x.32]，这个波满足方程[1.x.34]。因此，通过强制执行边界条件[1.x.35]，以直角撞击边界[2.x.33]的波将被完全吸收。另一方面，那些没有以直角撞击边界的波场部分并不满足这个条件，将其作为边界条件来执行将产生部分反射，也就是说，只有部分波会通过边界，就像它不在这里一样，而剩下的那部分波将被反射回域中。
* 如果我们愿意接受这一点作为吸收边界的充分近似，我们最终得出以下问题[2.x.34]：[1.x.36] 。
* 这是一个亥姆霍兹方程（类似于[2.x.35]中的方程，但这次有''坏符号''），[2.x.36]上有迪里希特数据，[2.x.37]上有混合边界条件。由于[2.x.38]上的条件，我们不能只是单独处理[2.x.39]的实部和虚部方程。然而，我们可以把[2.x.40]的PDE看作是[2.x.41]的实部和虚部的两个PDE系统，[2.x.42]的边界条件代表系统中两个部分之间的耦合项。这是按以下思路进行的。让[2.x.43]，然后在[2.x.44]和[2.x.45]方面，我们有以下系统：[1.x.37]
*
* 对于测试函数[2.x.46]与[2.x.47]，经过通常的乘法，在[2.x.48]上的积分和应用分项积分，我们得到弱表述[1.x.38] 。
*
* 我们选择有限元空间[2.x.49]和[2.x.50]，基数为[2.x.51]，并寻找近似解[1.x.39]插入变分形式，得到方程组[1.x.40]，用矩阵符号表示：[1.x.41](不要被这里的右手边为零所迷惑，那是因为我们还没有包括Dirichlet边界数据。)由于非对角线块的交替符号，我们已经可以看到这个系统是非对称的，事实上它甚至是不确定的。当然，没有必要选择空间[2.x.52]和[2.x.53]是相同的。然而，我们希望解的实部和虚部具有类似的性质，因此在实施过程中确实会采取[2.x.54]，并且对这两个空间使用相同的基函数[2.x.55]。之所以使用不同的符号，只是为了让我们区分[2.x.56]和[2.x.57]的形状函数，因为这种区分在实施中起着重要作用。
*

*[1.x.42][1.x.43] 。


* 在计算中，我们将考虑波在单位方阵中的传播，超声由换能器透镜产生，透镜的形状像圆的一个部分，中心在[2.x.58]，半径略大于[2.x.59]；这种形状应该导致声波在圆中心的聚焦。改变[2.x.60]会改变透镜的 "焦点"，影响[2.x.61]强度的空间分布，我们主要关心的是[2.x.62]的聚焦程度。
* 在下面的程序中，我们将使用实部和虚部分离的公式来实现复值亥姆霍兹方程。我们还将讨论如何生成一个看起来像正方形的域，并带有模拟换能器的轻微隆起（在[2.x.63]函数中），以及如何生成图形输出，不仅包含解分量[2.x.64]和[2.x.65]，还包括直接在输出文件中的量级[2.x.66]（在[2.x.67]中）。最后，我们使用ParameterHandler类来轻松读取参数，如焦距[2.x.68]、波速[2.x.69]、频率[2.x.70]，以及在运行时从输入文件中读取其他一些参数，而不是在源代码中固定这些参数，每次我们想改变参数时，都必须重新编译。
*

* [1.x.44] [1.x.45]。
* [1.x.46] [1.x.47]。
*

*
* 以下头文件之前都已经讨论过了。
*


*


* [1.x.48]
*
* 这个头文件包含ParameterHandler类的必要声明，我们将用它来从配置文件中读取我们的参数。
*


* [1.x.49]
*
* 对于线性系统的求解，我们将使用UMFPACK提供的稀疏LU分解（参见SparseDirectUMFPACK类），为此需要以下头文件。  请注意，为了编译这个教程程序，deal.II-library需要建立UMFPACK支持，这个支持在默认情况下是启用的。
*


* [1.x.50]
*
* FESystem类允许我们将几个FE-对象堆叠成一个复合的、矢量值的有限元场。该类的必要声明在这个头文件中提供。
*


* [1.x.51]
*
* 最后，包括声明Timer类的头文件，我们将用它来确定我们程序的每个操作需要多少时间。
*


* [1.x.52]
*
* 作为这个程序开始的最后一步，我们把这个程序中的所有东西都放到它的命名空间中，在它的命名空间中，让所有在deal.II命名空间中的东西都是全局可用的，不需要在所有东西前加上[2.x.71]。
*


* [1.x.53]
*
* [1.x.54] [1.x.55]。


*
* 首先我们为代表Dirichlet边界值的函数定义一个类。这在以前已经做过很多次了，因此不需要过多解释。   
* 因为有两个值[2.x.72]和[2.x.73]需要在边界规定，我们必须告诉基类，这是一个有两个分量的向量值函数，[2.x.74]函数和它的表弟[2.x.75]必须返回有两个条目的向量。在我们的例子中，这个函数非常简单，它只是对实部[2.x.76]返回1，对虚部[2.x.77]返回0，而不管它在哪个点被评估。
*


* [1.x.56]
*
* [1.x.57] [1.x.58]。


*
* 下一个类负责准备ParameterHandler对象并从输入文件中读取参数。  它包括一个声明所有必要参数的函数[2.x.78]和一个从外部调用的[2.x.79]函数，以启动参数读取过程。
*


* [1.x.59]
*
* 构造函数存储了一个传递给它的ParameterHandler对象的引用。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* [2.x.80]函数声明了我们的ParameterHandler对象能够从输入文件中读取的所有参数，以及它们的类型、范围条件和它们出现在哪个小节。我们将用一对大括号包住所有进入一个部分的条目，以迫使编辑器将它们缩进一级，从而使阅读哪些条目共同构成一个部分变得更简单。
*


* [1.x.63]
*
* 网格和几何的参数包括应用于初始粗网格的全局细化步数和换能器镜头的焦距[2.x.81]。对于细化步数，我们允许在[2.x.82]范围内取整数，其中[2.x.83]对象的第二个参数被省略，表示半开区间。  对于焦距，任何大于零的数字都可以接受。
*


* [1.x.64]
*
* 下一小节专门讨论方程中出现的物理参数，即频率 [2.x.84] 和波速 [2.x.85] 。同样，两者都需要位于半开区间[2.x.86]内，通过调用[2.x.87]类，仅以左端点为参数来表示。
*


* [1.x.65]
*
* 最后但并非最不重要的是，我们希望能够通过配置文件中的条目来改变输出的一些属性，如文件名和格式，这就是最后一小节的目的。
*


* [1.x.66]
*
* 因为不同的输出格式可能需要不同的参数来生成输出（例如，postscript输出需要视角角度、线宽、颜色等），如果我们必须为库中支持的每一种可能的输出格式手工声明所有这些参数，那将是非常麻烦的。相反，每种输出格式都有一个[2.x.88]函数，它在自己的小节中声明了该格式的所有特定参数。下面调用[2.x.89]为所有可用的输出格式执行[2.x.90]，这样就为每种格式创建了一个自己的小节，并为该特定输出格式声明了参数。(上面[2.x.91]的调用中，模板参数的实际值在这里并不重要：该函数做了同样的工作，与维度无关，但碰巧是在一个依赖模板参数的类中。)  要想知道哪种输出格式有哪些参数，你可以查阅DataOutBase类的文档，或者干脆在没有参数文件的情况下运行这个程序。然后，它将创建一个文件，将所有声明的参数设置为默认值，这可以方便地作为一个起点，将参数设置为你想要的值。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这是在ParameterReader类中的主函数。  它从外部被调用，首先声明所有的参数，然后从输入文件中读取参数，文件名由调用者提供。在对这个函数的调用完成后，可以使用[2.x.92]对象来检索从文件中读入的参数值。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 正如介绍中提到的，我们真正追求的数量是超声波强度的空间分布，它对应于 [2.x.93] 。现在我们可以只满足于在输出中拥有[2.x.94]和[2.x.95]，并使用合适的可视化或后处理工具从我们计算的解决方案中得出[2.x.96]。然而，也有一种方法可以输出从deal.II的解决方案中得出的数据，我们在这里要利用这个机制。
*

*
* 到目前为止，我们一直使用[2.x.97]函数将包含输出数据的向量添加到一个DataOut对象中。  这个函数有一个特殊的版本，除了数据向量之外，还有一个额外的参数类型为DataPostprocessor。当这个函数用于输出时，在每个要生成输出数据的点上，指定的DataPostprocessor对象的[2.x.98]或[2.x.99]函数被调用，从数据向量代表的有限元函数的值、梯度和二阶导数计算输出量（在面相关数据的情况下，法向量也可用）。因此，这使我们可以输出任何可以从解的值及其导数中局部得出的数量。  当然，超声强度[2.x.100]就是这样一个量，其计算甚至不涉及[2.x.101]或[2.x.102]的任何导数。
*

*
* 在实践中，DataPostprocessor类只提供了一个接口，我们需要从它派生出我们自己的类，以便实现接口所指定的功能。在最一般的情况下，我们必须实现几个成员函数，但如果输出量是一个单一的标量，那么其中一些模板代码可以由一个更专业的类，即DataPostprocessorScalar来处理，我们可以从该类中派生出来。这就是[2.x.103]类的作用。
*


* [1.x.73]
*
* 在构造函数中，我们需要用两个参数调用基类的构造函数。第一个参数表示这个类计算的单一标量在输出文件中应该用什么名字来表示。在我们的例子中，后处理程序有[2.x.104]作为输出，所以我们使用 "Intensity"。   
* 第二个参数是一组标志，表明后处理程序需要哪些数据来计算输出量。  这可以是update_values、update_gradients和update_hessians（如果是脸部数据，也可以是update_normal_vector）的任何一个子集，这些都在UpdateFlags中记录。  当然，导数的计算需要额外的资源，所以这里只应该给出真正需要的数据的标志，就像我们使用FEValues对象时一样。在我们的例子中，只有[2.x.105]和[2.x.106]的函数值需要用来计算[2.x.107]，所以我们用update_values标志就可以了。
*


* [1.x.74]
*
* 实际的后处理发生在下面这个函数中。它的输入是一个存储函数值的对象（这里是向量值），代表给[2.x.108]的数据向量在我们产生输出的所有评估点的评估值，以及一些代表导数的张量对象（这里我们不使用，因为[2.x.109]只是从[2.x.110]和[2.x.111]计算出来的）。派生量在[2.x.112]向量中返回。请记住，这个函数只能使用由 [2.x.113] 指定的各自更新标志的数据。例如，我们可能不会在这里使用导数，因为我们对 [2.x.114] 的实现要求只提供函数值。
*


* [1.x.75]

* 计算本身是很简单的。我们遍历输出向量中的每个条目，并从[2.x.116]和[2.x.117]的相应值中计算出[2.x.115] 。我们通过创建一个复数[2.x.118]，然后对结果调用[2.x.119]来实现。(我们可能会想调用[2.x.120]，但是在一个历史的怪圈中，C++委员会决定[2.x.121]应该返回绝对值的[1.x.76]。
*
* - 因此不符合数学家对称为 "规范 "的东西的属性要求）。)
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 最后这里是这个程序的主类。  它的成员函数与之前的例子非常相似，特别是[2.x.122]，成员变量的列表也没有任何重大的惊喜。传递给构造函数的ParameterHandler对象被存储为一个引用，以便于从该类的所有函数中访问参数。  由于我们正在使用矢量值的有限元，我们使用的FE对象是FESystem类型的。
*


* [1.x.80]
*
* 构造函数接收ParameterHandler对象并将其存储在一个引用中。它还初始化了DoF-Handler和有限元系统，该系统由两份标量Q1场组成，一份用于[2.x.123]，一份用于[2.x.124] 。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 这里我们为我们的领域设置网格。  正如论述中所提到的，这个几何体只是一个单位正方形（2D），其边界部分代表换能器透镜，由一个圆的扇形代替。
*


* [1.x.84]
*
* 首先我们产生一些日志输出，并启动一个计时器，这样我们就可以计算出这个函数完成后的执行时间。
*


* [1.x.85]
*
* 然后我们从ParameterHandler对象中查询换能器镜头的焦距和网格细化步数的值。
*


* [1.x.86]
*
* 接下来，为换能器镜头的位置和焦点定义了两个点，即圆的中心，其线段将形成边界的换能器部分。注意，这是程序中唯一一个在二维和三维中略有不同的地方。尽管本教程只涉及二维情况，但要使这个程序在三维中发挥作用，必要的补充是非常少的，因此我们选择包括它们。
*


* [1.x.87]
*
* 作为初始粗网格，我们采用一个简单的单位方格，每个方向上有5个细分。分区的数量是这样选择的：我们想指定为换能器边界的线段[2.x.125]是由一个面来跨越的。然后，我们通过所有的单元格来找到换能器所在的面，事实上，这只是X轴上从0.4到0.6的一条边。这是我们希望根据圆环形边界进行细化的地方，所以我们用不同的流形指标来标记这个边缘。由于我们将在换能器上设置迪里希特边界条件，我们也要改变其边界指标。
*


* [1.x.88]
*
* 对于换能器镜头的圆形部分，使用了一个SphericalManifold对象（当然，在2D中只是代表一个圆），中心的计算方法如上。
*


* [1.x.89]
*
* 现在，全局细化被执行。换能器位置附近的单元格将根据换能器透镜的圆弧形边界自动细化。
*


* [1.x.90]
*
* 最后，我们再生成一些日志输出。我们停止定时器，并查询从函数开始到现在所经过的CPU秒数。
*


* [1.x.91]
*
* [1.x.92] [1.x.93].
* 系统矩阵、稀疏模式和向量的初始化与前面的例子相同，因此不需要进一步注释。和前面的函数一样，我们也输出我们在这里所做的运行时间。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 和以前一样，这个函数负责组装系统矩阵和右手边的向量。
*


* [1.x.97]
*
* 首先，我们从ParameterHandler对象中查询波速和频率，并将它们存储在本地变量中，因为它们将在本函数中频繁使用。
*


*


* [1.x.98]
*
* 像往常一样，计算积分时使用普通的高斯正交规则。由于我们的双线性形式涉及到[2.x.126]上的边界积分，我们还需要一个正交法则来计算面的积分，这些面是[2.x.127]维的。
*


* [1.x.99]
*
* FEValues对象将为我们评估形状函数。  对于涉及到[2.x.128]上的积分的双线性形式的部分，我们需要形状函数的值和梯度，当然还有正交加权。  对于涉及边界积分的条款，只需要形状函数值和正交权重。
*


* [1.x.100]
*
* 像往常一样，系统矩阵是逐个单元组装的，我们需要一个矩阵来存储本地单元的贡献，以及一个索引向量来将单元的贡献转移到全局系统矩阵中的适当位置，然后。
*


* [1.x.101]
*
* 在每个单元，我们首先需要重置本地贡献矩阵，并请求FEValues对象计算当前单元的形状函数。
*


* [1.x.102]
*
* 在这一点上，重要的是要记住，我们所处理的是一个有两个分量的有限元系统。由于我们构造这个FESystem的方式，即作为两个标量有限元场的笛卡尔乘积，每个形状函数只有一个非零分量（用deal.II的行话来说，它们是[2.x.129] GlossPrimitive "原始"）。  因此，每个形状函数可以被看作是介绍中的[2.x.130] 's或[2.x.131] 's之一，同样，相应的自由度也可以归属于[2.x.132] 或[2.x.133] 。然而，当我们遍历当前单元上的所有自由度时，它们并不以任何特定的顺序出现，因此我们无法立即决定索引为[2.x.134]和[2.x.135]的自由度是属于我们解决方案的实部还是虚部。  另一方面，如果你看一下介绍中的系统矩阵的形式，这个区别是至关重要的，因为它将决定当前一对DoF的贡献将归入系统矩阵的哪个块，因此我们需要从给定的两个形状函数中计算哪个量。  幸运的是，FESystem对象可以为我们提供这些信息，即它有一个函数[2.x.136]，为每个局部的DoF索引返回一对整数，其中第一个整数表示该DoF属于系统的哪个组成部分。这对整数中的第二个整数表示该DoF在标量基有限元域中的索引，但这一信息在这里并不相关。如果你想知道更多关于这个函数和原始向量值元素背后的基本方案，可以看看[2.x.137]或[2.x.138]模块，那里对这些主题有深入的解释。
*


* [1.x.103]

* 如果DoF[2.x.139]和[2.x.140]都属于同一个组件，即它们的形状函数都是[2.x.141]'s或都是[2.x.142]'s，贡献将最终出现在我们系统矩阵的一个对角线块中，由于相应的条目是由同一个公式计算的，我们不必理会它们是否真的是[2.x.143]或[2.x.144]形状函数。我们可以简单地通过遍历所有正交点并将其贡献相加来计算条目，其中形状函数的值和梯度由我们的FEValues对象提供。
*


*


* [1.x.104]
*
* 你可能认为我们在向FEValues对象请求形状函数值或梯度时，必须指定我们想评估的形状函数的哪个分量。然而，由于形状函数是原始的，它们只有一个非零分量，而FEValues类足够聪明，它知道我们肯定对这一个非零分量感兴趣。
*


* [1.x.105]
*
* 我们还必须增加由于边界项的贡献。为此，我们对当前单元格的所有面进行循环，首先看它是否在边界上，其次看它是否有与[2.x.145]相关的正确边界指标，即我们有吸收边界条件的那部分边界。
*


* [1.x.106]
*
* 这些面肯定会对系统矩阵的非对角线块作出贡献，所以我们要求FEFaceValues对象为我们提供这个面上的形状函数值。
*


* [1.x.107]
*
* 接下来，我们循环浏览当前单元的所有DoF，找到属于不同组件且都支持当前face_no的一对。
*


* [1.x.108]
*
* 检查形状函数是否在一个面上有支持并不是严格必要的：如果我们不检查它，我们会简单地把本地单元矩阵的项加起来，这些项碰巧是零，因为至少有一个形状函数碰巧是零。然而，我们可以通过添加上面的检查来节省这项工作。
*

*
* 在任何一种情况下，这些DoF都会对系统矩阵的非对角线块的边界积分做出贡献。为了计算积分，我们在面的所有正交点上进行循环，并将贡献量与面正交规则所提供的正交权重相加。  与对角线块上的条目不同，这里的形状函数哪一个是[2.x.146]，哪一个是[2.x.147]，确实很重要，因为这将决定该条目的符号。  我们通过一个简单的条件语句来说明这一点，以确定正确的符号。由于我们已经检查了DoF[2.x.148]和[2.x.149]属于不同的组件，这里只需测试其中一个属于哪个组件即可。
*


* [1.x.109]
*
* 现在我们已经完成了这个单元，必须把它的贡献从局部系统矩阵转移到全局系统矩阵。为此，我们首先得到这个单元斗室的全局指数列表......
*


* [1.x.110]
*
* ......然后把这些条目一个一个地加到系统矩阵中。
*


* [1.x.111]
*
* 唯一剩下的是[2.x.150]上的迪里希特边界值，其特征是边界指标1。迪里希特值是由我们上面定义的[2.x.151]类提供的。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 正如介绍中已经提到的，系统矩阵既不是对称的，也不是确定的，因此，如何提出一个迭代求解器和预处理器来很好地处理这个矩阵并不是很明显。  我们选择了另一种方式，用UMFPACK提供的稀疏LU分解来解决线性系统。这通常是二维问题的一个很好的首选，即使对于大量的DoF也能很好地工作。  SparseDirectUMFPACK类提供了UMFPACK的deal.II接口，它非常容易使用，使我们只需3行代码就能解决我们的线性系统。
*

*
* 再次注意，为了编译这个例子程序，你需要有支持UMFPACK的deal.II库。
*


* [1.x.115]
*
* 解决线性系统的代码很短：首先，我们分配一个正确类型的对象。下面的[2.x.152]调用提供了我们想要反转的矩阵给SparseDirectUMFPACK对象，并同时启动了LU分解。因此，这也是这个程序中大部分计算工作发生的地方。
*


* [1.x.116]
*
* 分解之后，我们可以把[2.x.153]当作代表我们系统矩阵的逆矩阵来使用，所以要计算出解决方案，我们只需要与右边的向量相乘。
*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
* 在这里，我们以参数文件中指定的格式输出我们的解[2.x.154]和[2.x.155]以及派生量[2.x.156]。从[2.x.158]和[2.x.159]导出[2.x.157]的大部分工作已经在[2.x.160]类的实现中完成，因此输出程序相当简单，与前面教程中的内容非常相似。
*


* [1.x.120]
*
* 定义我们[2.x.161]类的对象和一个DataOut对象。
*


* [1.x.121]
*
* 接下来我们从ParameterHandler查询输出相关的参数。[2.x.162] 调用充当了 [2.x.164] 中 [2.x.163] 调用的对应部分。它从ParameterHandler收集所有与输出格式相关的参数，并相应地设置DataOut对象的相应属性。
*


* [1.x.122]
*
* 现在我们从ParameterHandler提供的基本名称和DataOut类提供的后缀组合成文件名（默认后缀被设置为正确的类型，与.prm文件中通过parse_parameters()设置的类型相匹配）。
*


* [1.x.123]
*
*解向量[2.x.165]和[2.x.166]以常规方式添加到DataOut对象中。
*


* [1.x.124]
*
* 对于强度，我们只是再次调用[2.x.167]，但这次用我们的[2.x.168]对象作为第二个参数，这实际上是将[2.x.169]加入到输出数据中。
*


* [1.x.125]

* 最后的步骤和以前一样。请注意，现在实际的输出格式是由输入文件中的内容决定的，也就是说，人们可以改变输出格式而不必重新编译这个程序。
*


* [1.x.126]
*
* [1.x.127] [1.x.128]。


*
* 这里我们只是一个接一个地执行我们的函数。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 最后是该程序的[2.x.170]功能。它的结构与其他几乎所有的教程程序相同。唯一的例外是，我们定义了ParameterHandler和[2.x.171]对象，并让后者从一个叫做[2.x.172]的文本文件中读入参数值。读取的值将被交给UltrasoundProblem类的一个实例。
*


* [1.x.132]
* [1.x.133][1.x.134][1.x.135] 。


* 当前程序从一个名为[2.x.173]的输入文件中读取其运行时参数，该文件看起来像这样。
* [1.x.136]
*
* 可以看出，我们设置了[2.x.174]，这相当于换能器镜头的焦点在[2.x.175]，[2.x.176]。粗略的网格被细化了5次，结果是160x160个单元，输出结果以vtu格式书写。参数读取器可以理解更多与输出生成有关的参数，但是我们在这里不需要这些参数，因此坚持使用它们的默认值。
* 下面是在调试模式下程序的控制台输出。
* [1.x.137]
*
* (当然，如果你在本地运行该程序，执行时间会有所不同。) 事实上，大部分时间都花在组装系统矩阵和生成输出上，这是因为在调试模式下有许多断言需要检查。在发布模式下，程序的这些部分运行得更快，而求解线性系统的速度却很难加快。
* [1.x.138]
*
* 该程序的图形输出看起来如下。
*

* [2.x.177]
* 前两张图片显示了[2.x.178]的实部和虚部，而最后一张显示了强度[2.x.179]。我们可以清楚地看到，强度集中在透镜的焦点周围（0.5，0.3），焦点在[2.x.180]方向相当尖锐，但在[2.x.181]方向却比较模糊，这是聚焦透镜的几何形状、有限光圈和问题的波浪性质所造成的。
* 因为丰富多彩的图形总是很有趣，而且为了进一步强调聚焦效果，这里还有一组图像，强调强度在[2.x.182]-方向上的实际聚焦效果。
* [2.x.183]
*

* 最后，程序的结构使我们很容易确定程序的哪些部分可以随着网格的细化而很好地扩展，哪些部分不可以。下面是5、6、7次全局细化的运行时间。
* [1.x.139]
*
* 每次我们对网格进行一次细化，所以每一步的单元和自由度的数量大约是四倍。可以看出，生成网格、设置自由度、组装线性系统和生成输出的比例相当接近于线性，而求解线性系统的操作，自由度的数量每增加4倍，就需要增加8倍的时间，也就是说，是[2.x.184] 。这可以解释为（使用最优排序）有限元矩阵的带宽是[2.x.185]，而使用LU分解解决带状线性系统的努力是[2.x.186]。这也解释了为什么程序在三维中也能运行（在改变了[2.x.187]对象的维度后），但扩展性很差，在完成对具有可观分辨率的网格上的线性系统的求解前需要极大的耐心，尽管程序的其他部分扩展性很好。
*


* [1.x.140][1.x.141][1.x.142] 。


* 这个程序的一个明显的可能的扩展是在3D&mdash中运行；毕竟，我们周围的世界是三维的，超声束在三维介质中传播。你可以通过简单地改变[2.x.188]中主类的模板参数并运行它来尝试。但这不会让你走得很远：如果你按照参数文件中的设置做5个全局细化步骤，当然不会。你的内存会耗尽，因为网格（包括[2.x.189]单元），特别是稀疏直接求解器会占用太多的内存。然而，如果你有一点时间，你可以用3个全局细化步骤进行求解：在2011年初，直接求解大约需要半个小时。然而，你会注意到，这个解法是完全错误的：网格大小根本不足以准确地解决解法的波浪，你可以从解法的图中看到这一点。因此，在这种情况下，如果你不想在这个问题上扔一个更大的（可能是%并行的）机器，那么自适应性是必不可少的。
*

* [1.x.143][1.x.144] [2.x.190]。
* [0.x.1]

