include/deal.II-translator/A-tutorial/step-5_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16]
*[1.x.17][1.x.18][1.x.19] 。


* [2.x.2]
* 这个例子没有展示革命性的新东西，但它展示了比以前的例子更多的小改进，也有许多通常可以在有限元程序中找到的小东西。其中包括。[2.x.3] [2.x.4] 在连续细化的网格上进行计算。至少在数学科学中，在一个层次的网格上计算解是很常见的，以获得对解的精度的感觉；如果你在一个网格上只有一个解，你通常无法猜测解的精度。此外，deal.II被设计用来支持自适应算法，其中在连续细化的网格上的迭代求解是算法的核心。尽管在这个例子中没有使用自适应网格，但这里为它们奠定了基础。   [2.x.5] 在实际应用中，领域经常被自动网格生成器细分为三角形。为了使用它们，从文件中读取粗大的网格是很重要的。在这个例子中，我们将读取一个UCD（非结构化单元数据）格式的粗网格。当这个程序在2000年左右首次编写时，UCD格式是AVS资源管理器所使用的格式
*
*--这个程序在当时被合理地广泛使用，但现在已经不再重要了。(尽管如此，该文件格式仍然存在，并且仍然被一些程序所理解)。   [2.x.6] 有限元程序通常使用大量的计算时间，所以有时需要进行一些优化。我们将展示其中的一些。   [2.x.7] 另一方面，有限元程序往往是相当复杂的，所以调试是一个重要方面。我们通过使用断言来支持安全编程，断言在调试模式下检查参数和%内部状态的有效性，但在优化模式下被移除。( [2.x.8] [2.x.9] 关于数学方面，我们展示了如何支持椭圆算子的可变系数，以及如何对线性方程组使用预处理迭代求解器。[2.x.10]
* 这里要解决的方程如下。
* [1.x.20]
* 如果[2.x.11]是一个恒定系数，这将是简单的Poissone方程。但是，如果它确实是空间变量，那就是一个更复杂的方程（通常被称为 "扩展泊松方程"）。根据变量[2.x.12]指的是什么，它模拟了各种具有广泛适用性的情况。
*
* 如果[2.x.13]是电动势，那么[2.x.14]是介质中的电流，系数[2.x.15]是介质在任何给定点的导电性。在这种情况下，方程的右侧将是电源密度，通常为零或由局部的、类似德尔塔的函数组成）。
*
* - 如果[2.x.16]是薄膜的垂直挠度，那么[2.x.17]将是对局部刚度的测量。这就是让我们能够解释下面结果部分所显示的图像的解释。
* 由于拉普拉斯/泊松方程出现在如此多的背景下，除了上面列出的两种解释外，还有许多其他解释。
* 当组装这个方程的线性系统时，我们需要弱形式，这里的弱形式如下。
* [1.x.21]
* 在[2.x.18]函数中的实现是直接从这里开始的。
*

* [1.x.22] [1.x.23]。
* [1.x.24][1.x.25] 。


*
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
*


* [1.x.26]

* 这个是新的。我们想从磁盘上读取一个三角图，做这个的类在以下文件中声明。
*


* [1.x.27]
*
* 我们将使用一个圆形域，而描述其边界的对象来自这个文件。
*


* [1.x.28]
*
* 这是C++ ...
*


* [1.x.29]

* 最后，这在以前的教程程序中已经讨论过了。
*


* [1.x.30]
*
* [1.x.31] [1.x.32]。


*
* 主类主要和前面的例子一样。最明显的变化是删除了函数[2.x.19]，因为现在创建网格是在[2.x.20]函数中完成的，其余的功能都在[2.x.21]中。除此以外，一切都和以前一样。
*


* [1.x.33]
*
* [1.x.34] [1.x.35]。


*
* 在[2.x.22]中，我们展示了如何使用非恒定边界值和右手边。  在这个例子中，我们想在椭圆算子中使用一个可变系数来代替。由于我们有一个只取决于空间中的点的函数，我们可以做得更简单一点，使用一个普通的函数，而不是继承自Function。
*

*
* 这是对单点的系数函数的实现。我们让它在与原点的距离小于0.5的情况下返回20，否则返回1。
*


* [1.x.36]
*
* [1.x.37] [1.x.38]。



* [1.x.39] [1.x.40]。


*
* 这个函数和以前一样。
*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 这是前面例子中的函数[2.x.23]，减去了生成网格的部分。其他的东西都没有变化。
*


* [1.x.44]
*
* [1.x.45] [1.x.46]。


*
* 和前面的例子一样，这个函数在功能上没有太大的变化，但是仍然有一些优化，我们将展示这些优化。对此，需要注意的是，如果使用高效的求解器（如预设条件的CG方法），组装矩阵和右手边会花费相当长的时间，你应该考虑在某些地方使用一到两个优化方法。
*

*
* 该函数的前几部分与之前完全没有变化。
*


* [1.x.47]
*
* 接下来是对所有单元的典型循环，计算局部贡献，然后将它们转移到全局矩阵和向量中。与[2.x.24]相比，这部分的唯一变化是我们将使用上面定义的[2.x.25]函数来计算每个正交点的系数值。
*


* [1.x.48]
*
* 有了这样建立的矩阵，我们再次使用零边界值。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。


*
*求解过程看起来又和前面的例子差不多。然而，我们现在将使用一个预设条件的共轭梯度算法。做出这种改变并不难。事实上，我们唯一需要改变的是，我们需要一个作为预处理程序的对象。我们将使用SSOR（对称连续过度放松），放松系数为1.2。为此，[2.x.26]类有一个函数可以做一个SSOR步骤，我们需要把这个函数的地址和它应该作用的矩阵（也就是要反转的矩阵）以及松弛因子打包成一个对象。[2.x.27]类为我们做到了这一点。([2.x.28]类需要一个模板参数，表示它应该处理的矩阵类型。默认值是[2.x.29]，这正是我们在这里需要的，所以我们只需坚持使用默认值，不在角括号中指定任何东西)。
*

*
* 请注意，对于目前的情况，SSOR的表现其实并不比其他大多数预处理程序好多少（尽管比没有预处理好）。在下一个教程程序[2.x.30]的结果部分对不同的预处理程序进行了简要的比较。
*

*
* 有了这个，剩下的函数就很简单了：我们现在使用我们声明的预设条件器，而不是之前创建的[2.x.31]对象，CG求解器将为我们完成剩下的工作。
*


* [1.x.52]
*
* [1.x.53] [1.x.54]。


*
* 将输出写入文件的方法与上一个教程中的方法基本相同。唯一不同的是，我们现在需要为每个细化周期构建一个不同的文件名。
*

*
* 该函数以VTU格式写入输出，这是VTK格式的一个变种，因为它压缩了数据，所以需要更少的磁盘空间。当然，如果你希望使用一个不懂VTK或VTU的可视化程序，DataOut类还支持许多其他格式。
*


* [1.x.55]
*
* [1.x.56] [1.x.57]。


*
* 这个程序中倒数第二件事是[2.x.32]函数的定义。与之前的程序不同，我们将在一个网格序列上进行计算，在每次迭代后都会进行全局细化。因此，该函数由6个周期的循环组成。在每个循环中，我们首先打印循环编号，然后决定如何处理网格。如果这不是第一个周期，我们就简单地对现有的网格进行一次全局精炼。然而，在运行这些循环之前，我们必须先生成一个网格。
*

*
* 在之前的例子中，我们已经使用了[2.x.33]类中的一些函数。这里我们想从一个存储有单元格的文件中读取网格，这个文件可能来自其他人，也可能是一个网格生成工具的产物。
*

*
* 为了从文件中读取网格，我们生成一个数据类型为GridIn的对象，并将三角测量与之相关联（也就是说，当我们要求它读取文件时，我们告诉它要填充我们的三角测量对象）。然后我们打开相应的文件，用文件中的数据初始化三角剖分。
*


* [1.x.58]

* 我们现在想读取该文件。但是，输入文件只针对二维三角测量，而这个函数是一个任意维度的模板。由于这只是一个演示程序，我们不会为不同的维度使用不同的输入文件，而是在不在二维的情况下迅速杀死整个程序。当然，由于下面的主函数假定我们是在二维空间工作，我们可以跳过这个检查，在这个版本的程序中，没有任何不良影响。   
* 事实证明，90%以上的编程错误是无效的函数参数，如无效的数组大小等，所以我们在整个deal.II中大量使用断言来捕捉这种错误。为此，[2.x.34]宏是一个很好的选择，因为它确保作为第一个参数的条件是有效的，如果不是，就抛出一个异常（它的第二个参数），通常会终止程序，并给出错误发生的位置和原因的信息。关于[2.x.35]宏的具体作用，可以在[2.x.36]"异常文档模块 "中找到更详细的讨论）。这通常会大大减少发现编程错误的时间，我们发现断言是快速编程的宝贵手段。   
* 另一方面，所有这些检查（目前库中有超过10,000个），如果你想做大型计算，应该不会使程序太慢。为此，[2.x.37]宏只在调试模式下使用，如果在优化模式下则扩展为零。因此，当你在小问题上测试你的程序并进行调试时，断言会告诉你问题出在哪里。一旦你的程序稳定了，你可以关闭调试，程序将在没有断言的情况下以最大速度运行你的实际计算。更准确地说：通过在优化模式下编译你的程序，关闭库中的所有检查（这些检查可以防止你用错误的参数调用函数，从数组中走出来，等等），通常可以使程序的运行速度提高四倍左右。即使优化后的程序性能更高，我们仍然建议在调试模式下开发，因为它允许库自动发现许多常见的编程错误。对于那些想尝试的人来说。从调试模式切换到优化模式的方法是用<code>make release</code>命令重新编译你的程序。现在[2.x.38]程序的输出应该向你表明，该程序现在是以优化模式编译的，以后也会被链接到已经为优化模式编译的库。为了切换回调试模式，只需用 [2.x.39] 命令重新编译。
*


* [1.x.59]
*
* ExcInternalError是一个全局定义的异常，每当有什么可怕的事情发生时，它就会被抛出。通常，人们希望使用更具体的异常，特别是在这种情况下，如果[2.x.40]不等于2，人们当然会尝试做其他事情，例如使用库函数创建一个网格。终止程序通常不是一个好主意，断言实际上只应该用于不应该发生的特殊情况，但由于程序员、用户或其他人的愚蠢而可能发生。上面的情况并不是对Assert的巧妙使用，但还是那句话：这是一个教程，也许值得展示什么是不应该做的，毕竟。
*

*
* 因此，如果我们通过了断言，我们就知道dim==2，现在我们可以真正地读取网格。它的格式是UCD（非结构化单元数据）（尽管惯例是使用UCD文件的后缀[2.x.41]）。
*


* [1.x.60]
*
* 如果你想使用其他的输入格式，你必须使用其他[2.x.42]函数之一。参见[2.x.43]类的文档以了解目前支持哪些输入格式）。
*

*
* 文件中的网格描述了一个圆。因此，我们必须使用一个流形对象，告诉三角计算在细化网格时将边界上的新点放在哪里。与[2.x.44]不同的是，由于GridIn不知道域有一个圆形的边界（与[2.x.45]不同，我们必须在创建三角剖分后明确地将流形附加到边界上，以便在细化网格时得到正确的结果。
*


* [1.x.61]
*
* 现在我们有了一个确定的网格，我们写一些输出，做所有我们在前面的例子中已经看到的事情。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。


*
* 主函数看起来和前面的例子中的函数差不多，所以我们不会对它作进一步评论。
*


* [1.x.65]
* [1.x.66][1.x.67] 。


*
* 以下是控制台的输出。
* [1.x.68]
*
*

*
*在每个周期中，单元格的数量翻了两番，CGiterations的数量大约翻了一番。另外，在每个周期中，程序以VTU格式写出一个输出图形文件。它们被描述为以下内容。
* [2.x.46]


*
* 由于系数的变化（曲率的减少与系数的增加是相同的），溶液的顶部区域被压扁了。溶液的梯度沿着界面是不连续的，尽管在上面的图片中并没有很清楚地看到这一点。我们将在下一个例子中更详细地研究这个问题。
* 图片还显示，在非常粗的网格上，这个程序计算出的解实际上是非常错误的（其幅度是错误的）。这是因为没有一种数值方法能够保证在粗大的网格上的解是特别准确的。
*
* - 但我们知道解[1.x.69]是精确的解，事实上你可以看到从一个网格到下一个网格的解似乎在最后不再有太大的变化。
*

* [1.x.70][1.x.71] [2.x.47] 。
* [0.x.1]

