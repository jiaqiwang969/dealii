include/deal.II-translator/A-tutorial/step-10_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5]
* [1.x.6][1.x.7][1.x.8] 。
 

* 
* 这是一个相当短的例子，只显示了使用高阶映射的一些方面。我们所说的[2.x.2]映射[2.x.3]是指单元格（即单元线、正方形或立方体）与现实空间中的单元格之间的转换。在前面所有的例子中，我们都隐含地使用了线性或d-线性映射；你根本不会注意到这一点，因为如果你不做任何特别的事情，这就是发生的情况。然而，如果你的域有弯曲的边界，在有些情况下，边界的片状线性逼近(即由直线段构成)是不够的，你希望你的计算域也是使用弯曲边界的真实域的逼近。如果边界近似使用逐片二次抛物线来近似真实边界，那么我们说这是二次或[2.x.4]近似。如果我们使用立方体多项式的片断图形，那么这就是[2.x.5]的近似，以此类推。
* 

* 
* 对于某些微分方程，已知边界的分片线性逼近，即[2.x.6]映射，如果精确域的边界是弯曲的，则是不充分的。例如，使用[2.x.7]元素的双谐波方程，或具有弯曲反射边界的域上的气体动力学的Eulerequations。在这些情况下，有必要使用高阶映射来计算积分。如果我们不使用这样的高阶映射，边界的逼近顺序将主导整个数值方案的收敛顺序，而不考虑域内部离散化的收敛顺序。
* 

* 
* 我们没有用这些更复杂的例子来证明高阶映射的使用，而只是做了一个简单的计算：用两种不同的方法计算[2.x.8]的值。
* 

* 
* 第一种方法是使用一个具有单位半径的圆的三角形近似，并在其上积分一个单位大小的常数函数（[2.x.9]）。当然，如果领域是精确的单位圆，那么面积将是[2.x.10]，但由于我们只使用了分片多项式段的近似，我们所积分的面积值并不完全是[2.x.11]。然而，众所周知，当我们细化三角形时，[2.x.12]的映射会以[2.x.13]的阶数逼近边界，其中[2.x.14]是网格大小。我们将检查不同映射下圆的计算面积值及其向[2.x.15]网格细化的收敛性。我们还将发现一个收敛行为，这个行为一开始是令人惊讶的，但有一个很好的解释。
* 

* 
* 第二种方法的工作原理与此类似，但这次不使用三角形单位圆的面积，而是使用其周长。 [2.x.16]是周长的一半，因为我们选择半径等于1。
* 

* 
* [2.x.17] 本教程实质上展示了如何为积分选择一个特定的映射，通过将一个特定的几何体附加到三角测量中（例如在[2.x.18]中已经做过），然后将一个映射参数传递给FEValues类，该类在deal.II中用于所有积分。我们选择的几何体是一个圆，deal.II已经有一个可以使用的类（SphericalManifold）。如果你想定义你自己的几何体，例如，因为它很复杂，而且不能用deal.II中已有的类来描述，你将需要阅读 [2.x.19] 。
* 

* [1.x.9] [1.x.10] 。
* 以下第一个include文件现在可能已经众所周知，不需要进一步解释。
* 

* 
* [1.x.11]
* 
* 这个包含文件是新的。即使我们在本教程中不求解PDE，我们也要使用FE_Nothing类提供的自由度为零的假有限元。
* 

* 
* [1.x.12]
* 
* 下面的头文件也是新的：在其中，我们声明了MappingQ类，我们将用它来处理任意阶的多项式映射。
 

* 
* [1.x.13]
* 
* 这又是C++。
* 

* 
* [1.x.14]
* 
* 最后一步和以前的程序一样。
* 

* 
* [1.x.15]
* 
* 现在，由于我们要计算[2.x.20]的值，我们必须与一些东西进行比较。这些是[2.x.21]的前几个数字，我们事先定义好，以便以后使用。由于我们想计算两个数字的差值，而这两个数字是相当精确的，计算出的[2.x.22]的近似值的精度在一个双变量可以容纳的数字范围内，所以我们宁可将参考值声明为[2.x.23]，并给它增加一些数字。
* 

* 
* [1.x.16]
* 
* 然后，第一个任务将是生成一些输出。由于这个程序非常小，我们在其中没有采用面向对象的技术，也没有声明类（当然，我们使用了库的面向对象的功能）。相反，我们只是将功能打包成独立的函数。我们使这些函数成为空间维数的模板，以符合使用deal.II时的通常做法，尽管我们只对两个空间维数使用这些函数，当试图对任何其他空间维数使用时，会出现异常。  
* 这些函数中的第一个只是生成一个圆（超球）的三角形，并输出[2.x.24]的不同值的单元格的映射。然后，我们细化一次网格，再做一次。
* 

* 
* [1.x.17]
* 
* 所以首先生成一个圆的粗略三角形，并将一个合适的边界描述关联到它。默认情况下，[2.x.26]将SphericalManifold附加到边界上（内部使用FlatManifold），所以我们只需调用该函数就可以继续。
* 

* 
* [1.x.18]
 
* 然后在当前网格上交替生成[2.x.27]、[2.x.28]和[2.x.29]映射的输出，以及（在循环体的末端）对网格进行一次全局细化。
* 

* 
* [1.x.19]
* 
* 为此，首先设置一个描述映射的对象。这是用MappingQ类来完成的，该类在构造函数中采用了它应使用的多项式程度作为参数。
* 

* 
* [1.x.20]
 
* 顺便提一下，对于一个片状线性映射，你可以给MappingQ的构造函数一个[2.x.30]的值，但也有一个MappingQ1类可以达到同样的效果。历史上，它以比MappingQ更简单的方式做了很多事情，但今天只是后者的一个包装。然而，如果你没有明确指定另一个映射，它仍然是库中许多地方隐含使用的类。
* 

* 
*  
* 为了真正用这个映射写出现在的网格，我们设置了一个对象，我们将用它来输出。我们将生成Gnuplot输出，它由一组描述映射的三角图的线条组成。默认情况下，三角剖分的每个面只画一条线，但由于我们想明确地看到映射的效果，所以我们想更详细地了解这些面。这可以通过传递给输出对象一个包含一些标志的结构来实现。在目前的情况下，由于Gnuplot只能画直线，我们在面孔上输出了一些额外的点，这样每个面孔就由30条小线来画，而不是只有一条。这足以让我们看到一条弯曲的线，而不是一组直线的印象。
* 

* 
* [1.x.21]
 
* 最后，生成一个文件名和一个输出的文件。
* 

* 
* [1.x.22]
* 
* 然后写出三角图到这个文件。该函数的最后一个参数是一个指向映射对象的指针。这个参数有一个默认值，如果没有给出值，就会取一个简单的MappingQ1对象，我们在上面简单介绍过。这样就会在输出中产生一个真实边界的片状线性近似。
* 

* 
* [1.x.23]
* 
* 在循环的最后，对网格进行全局细化。
* 

* 
* [1.x.24]
* 
* 现在我们进行代码的主要部分，对[2.x.31]进行逼近。圆的面积当然是由[2.x.32]给出的，所以有一个半径为1的圆，面积代表的只是搜索到的数字。面积的数值计算是通过在整个计算域中积分值为1的常数函数来进行的，即通过计算面积[2.x.33]，其中总和扩展到三角形中所有活动单元上的所有正交点，[2.x.34]是正交点的权重[2.x.35]。每个单元上的积分都是通过数字正交来逼近的，因此我们唯一需要的额外成分是建立一个FEValues对象，提供每个单元的相应`JxW`值。注意`JxW`是指[1.x.25]的缩写；因为在数值正交中，两个因子总是出现在相同的地方，所以我们只提供合并的数量，而不是两个单独的数量）。我们注意到，在这里我们不会在其最初的目的中使用FEValues对象，即用于计算特定正交点上的特定有限元的基函数值。相反，我们只用它来获得正交点上的`JxW'，而不考虑我们将给FEValues对象的构造器的（假）有限元。给予FEValues对象的实际有限元根本不使用，所以我们可以给任何。
* 

* 
* [1.x.26]
* 
* 对于所有单元上的数字正交，我们采用了一个足够高的正交规则。我们选择8阶的QGauss（4点），以确保数字正交引起的误差比由于边界近似的阶数，即所采用的映射的阶数所引起的阶数（最大6）更高。请注意，积分，雅各布行列式，不是一个多项式函数（相反，它是一个有理函数），所以我们不使用高斯正交来获得积分的精确值，就像在有限元计算中经常做的那样，而是可以使用任何类似阶数的正交公式来代替。
* 

* 
* [1.x.27]
* 
* 现在开始在多项式映射度=1...4的基础上进行循环。
* 

* 
* [1.x.28]
* 
* 首先生成三角形，边界和映射对象，正如已经看到的那样。
* 

* 
* [1.x.29]
* 
* 我们现在创建一个有限元。与其他的例子程序不同，我们实际上不需要用形状函数做任何计算；我们只需要FEValues对象的`JxW`值。因此，我们使用特殊的有限元类FE_Nothing，它的每个单元的自由度正好为零（顾名思义，每个单元的局部基础为空集）。FE_Nothing的一个比较典型的用法见[2.x.36] 。
* 

* 
* [1.x.30]
* 
* 同样的，我们需要创建一个DoFHandler对象。我们实际上并没有使用它，但是它将为我们提供 "active_cell_iterators"，这是重新初始化三角形的每个单元上的FEValues对象所需要的。
* 

* 
* [1.x.31]
* 
* 现在我们设置FEValues对象，给构造函数提供Mapping、假有限元和正交对象，以及要求只在正交点提供`JxW`值的更新标志。这告诉FEValues对象在调用[2.x.37]函数时不需要计算其他数量，从而节省计算时间。        
* 与以前的例子程序相比，FEValues对象的构造最重要的区别是，我们传递了一个映射对象作为第一个参数，它将用于计算从单元到实数单元的映射。在以前的例子中，这个参数被省略了，结果是隐含地使用了MappingQ1类型的对象。
* 

* 
* [1.x.32]
* 
* 我们使用一个ConvergenceTable类的对象来存储所有重要的数据，如[2.x.38]的近似值和与[2.x.39]的真实值相比的误差。我们还将使用ConvergenceTable类提供的函数来计算[2.x.40]的近似值的收敛率。
* 

* 
* [1.x.33]
* 
* 现在我们在三角形的几个细化步骤上循环。
* 

* 
* [1.x.34]
* 
* 在这个循环中，我们首先将当前三角形的活动单元的数量添加到表格中。这个函数会自动创建一个上标为 "cells "的表格列，如果这个列之前没有被创建的话。
* 

* 
* [1.x.35]
* 
* 然后我们为假的有限元分配自由度。严格地说，在我们的特殊情况下，我们不需要这个函数调用，但我们调用它是为了使DoFHandler高兴
* 
* - 否则它将在下面的[2.x.41]函数中抛出一个断言。
* 

* 
* [1.x.36]
* 
* 我们将变量面积定义为`长双`，就像我们之前对`pi`变量所做的那样。
* 

* 
* [1.x.37]
* 
* 现在我们循环所有的单元格，重新初始化每个单元格的FEValues对象，并将该单元格的所有`JxW`值加到`面积'中......
* 

* 
* [1.x.38]
* 
* ...并将得到的面积值和误差存储在表中。我们需要静态转换为双数，因为没有实现add_value(string, long double)函数。请注意，这也涉及到第二个调用，因为[2.x.43]命名空间中的[2.x.42]函数在其参数类型上是重载的，所以存在一个获取并返回[2.x.44]的版本，而全局命名空间中只有一个这样的函数被声明（获取并返回一个双数）。
* 

* 
* [1.x.39]
* 
* 我们想计算 "错误 "列的收敛率。因此我们需要在调用`evaluate_all_convergence_rates`之前，将其他列从收敛率评估中省略。
* 

* 
* [1.x.40]
* 
* 最后我们为一些数量的输出设置精度和科学模式...
* 

* 
* [1.x.41]
* 
* ...并将整个表格写到[2.x.45]。
 

* 
* [1.x.42]
* 
* 下面，第二个函数也是计算[2.x.46]的近似值，但这次是通过域的周长[2.x.47]而不是面积。这个函数只是前一个函数的一个变化。因此，我们主要给出不同之处的文件。
* 

* 
* [1.x.43]
* 
* 我们采取同样的正交顺序，但这次是`dim-1`维正交，因为我们将在（边界）线上而不是在单元上积分。
* 

* 
* [1.x.44]
* 
* 我们对所有的度进行循环，创建三角形、边界、映射、假有限元和DoFHandler对象，如前所述。
* 

* 
* [1.x.45]
 
* 然后我们创建一个FEFaceValues对象，而不是前面函数中的FEValues对象。同样，我们传递一个映射作为第一个参数。
* 

* 
* [1.x.46]
* 
* 现在我们对所有单元和每个单元的所有面进行计算。只有边界面上的`JxW`值的贡献被添加到长双变量`周长`中。
* 

* 
* [1.x.47]
* 
* 我们用单元格迭代器和面的编号重新启动FEFaceValues对象。
* 

* 
* [1.x.48]
* 
* 然后将评估后的数值存储在表格中...
* 

* 
* [1.x.49]
* 
* ...然后像我们在前一个函数中那样结束这个函数。
 

* 
* [1.x.50]
* 
* 下面的主函数只是按照上述函数的出现顺序来调用它们。除此以外，它看起来就像以前的教程程序的主函数。
* 

* 
* [1.x.51]
* [1.x.52][1.x.53] 。
* 

* 
* 该程序执行了两项任务，第一项是生成映射域的可视化，第二项是通过所述的两种方法计算π。让我们先看一下生成的图形。它们是以Gnuplot格式生成的，可以通过以下命令查看
* [1.x.54]
* 或者使用其他的文件名。第二行确保生成的输出的长宽比实际上是1:1，也就是说，在你的屏幕上，圆形被画成一个圆，而不是椭圆。第三行关闭了图形中的按键，因为这只会打印出现在并不重要的信息（文件名）。同样地，第四行和第五行关闭了刻度线。然后生成具有特定线宽（"lw"，这里设置为4）和线型（"lt"，这里选择线应该用RGB颜色 "黑色 "绘制）的图。
* 下表显示了[2.x.48]、[2.x.49]和[2.x.50]映射的三角计算域，原始粗网格（左）和一次均匀细化网格（右）。
* [2.x.51] 
* 这些图片显示了高阶映射的明显优势：它们在相当粗的网格上也能相当好地接近真实边界。为了进一步证明这一点，这里是使用[2.x.52]和[2.x.53]映射的粗网格的右上角四分之一圆的一部分，其中红色虚线标志着实际圆。
* [2.x.54] 
* 很明显，二次映射很好地逼近了边界，而对于三次映射来说，对于粗网格来说，逼近的域和真实的域之间的差别已经很难看出来了。你还可以看到，映射只在三角形的外部边界上有所改变。在内部，所有的线仍然是由线性函数表示的，这导致只在边界的单元上进行额外的计算。因此，高阶映射通常不会比低阶映射明显地慢，因为额外的计算只在所有单元格的一小部分上执行。
* 

* 
* 该程序的第二个目的是计算出准确的pi值。这是程序的这一部分的输出。
* [1.x.55]
 
* 

* 
* 从输出中可以直接观察到，在所有情况下，数值都会迅速收敛到[2.x.55]的真实值。请注意，对于[2.x.56]的映射，我们已经进入了四舍五入误差的状态，收敛率趋于平稳，这已经是相当大的进步了。然而，也请注意，对于[2.x.57]映射，即使在最细的网格上，精度也比[2.x.58]映射的粗略网格上要差得多!
* 

* 
* 输出的最后一列显示了收敛顺序，以网格宽度[2.x.59]为单位。在介绍中，我们曾说过，[2.x.60]映射的收敛顺序应该是[2.x.61]。然而，在所示的例子中，顺序是[2.x.62] ! 这个最初令人惊讶的事实可以用[2.x.63]映射的特性来解释。在[1.x.56]阶，它使用的支持点是基于[1.x.57]+1点Gauss-Lobatto正交规则，以这样的方式选择支持点，使正交规则在2[1.x.58]阶收敛。尽管这些点在这里只用于插值[1.x.59]阶多项式，但我们在对积分进行数值计算时得到了一个超级收敛效应，从而得到了观察到的高收敛阶数。这一效应在以下出版物中也有详细讨论。A. Bonito, A. Demlow, and J. Owen: "对拉普拉斯-贝特拉米算子的特征值和特征函数的有限元近似的先验误差估计"，已提交，2018年）。)
* 

* [1.x.60][1.x.61][2.x.64] 
* [0.x.1]

