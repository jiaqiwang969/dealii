include/deal.II-translator/A-tutorial/step-43_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22 ][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43]
* [2.x.2] 
* [1.x.44]
* 

* [1.x.45][1.x.46][1.x.47] 。
 

* 多孔介质中的多相流模拟是一个普遍存在的问题，我们以前在 [2.x.3] 和 [2.x.4] 中已经以某种形式解决了这个问题。然而，正如在那里很容易看到的，它面临着两个主要困难：数值精度和效率。第一个困难在固定解算器[2.x.5]中很容易看到：使用最低阶的Raviart-Thomas元素不能期望产生高度精确的解。我们需要更精确的方法。第二个原因从时间依赖性[2.x.6]中可以看出：该程序慢得令人发指，没有希望在合理的时间范围内得到三维的高度精确解。
* 在这个程序中，为了克服这两个问题，有五个方面我们正在努力改进，以建立一个高性能的模拟器。
* [2.x.7] [2.x.8] 高阶空间离散 [2.x.9] 自适应网格细化 [2.x.10] 自适应时间步进 [2.x.11] 运算器分离 [2.x.12] 高效求解器和预处理 [2.x.13] 
* 本程序的大部分灵感来自于[2.x.14]，但这里讨论的几个技术是原创的。
* 

*[1.x.48][1.x.49]
* 

* 我们考虑的是两相不混杂、不可压缩的流体的流动。毛细管和重力效应被忽略，而粘性效应被假定为主导因素。这种流动的治理方程与[2.x.15]中使用的方程相同，为
* [1.x.50]
* 其中[2.x.16]是第二（润湿）相的饱和度（体积分数在0和1之间），[2.x.17]是压力，[2.x.18]是渗透性张量，[2.x.19]是总流动性，[2.x.20]是孔隙率，[2.x.21]是润湿相的分流量，[2.x.22]是源项，[2.x.23]是总速度。总流动性、润湿相的分流量和总速度分别由以下公式给出
* [1.x.51]
* 其中，下标[2.x.24]分别代表湿润相和非湿润相。
* 为方便起见，饱和度方程中的孔隙度[2.x.25]可视为时间变量的缩放系数，被设定为1。根据相对渗透率[2.x.26]和[2.x.27]对饱和度的依赖性的常用规定，我们使用
* [1.x.52]
* 
* 上面的多孔介质方程由饱和度的初始条件和压力的边界条件组成。由于饱和度和压力梯度唯一地决定了速度，因此不需要速度的边界条件。由于流动方程不包含时间导数，因此不需要速度和压力变量的初始条件。流动场将边界分为流入或流出部分。具体来说，[1.x.53]，我们通过对流入边界的饱和度变量施加边界值来得到一个完整的模型[2.x.28] 。
* 

*[1.x.54][1.x.55] 。
* 

* 正如在[2.x.29]中所看到的，一旦我们知道了流动变量，解决速度和压力的流动方程是程序中花费时间远大于饱和度变量的（显式）更新步骤的部分。另一方面，压力和速度对饱和度的依赖性很弱，因此可以考虑每隔几步只求解压力和速度，而每步更新饱和度。如果我们能找到一个关于何时需要更新流量变量的标准，我们就把这种分割称为 "自适应运算器分割 "方案。
* 在这里，我们使用以下后验标准来决定何时重新计算压力和速度变量（详细推导和描述可参见[Chueh, Djilali和Bangerth 2011]）。
* [1.x.56]
* 其中括号内的上标表示定义任何数量的饱和时间步数，[2.x.30]代表我们实际计算压力和速度的最后一步。如果[2.x.31]超过某个阈值，我们就重新计算流量变量；否则，我们就在时间步骤[2.x.32]中停止计算，只将饱和变量向前移动一个时间步骤。
* 简言之，该算法允许我们执行若干长度为[2.x.33]的饱和时间步长，直到上述准则告诉我们要重新计算速度和压力变量，从而导致一个长度为[1.x.57]的宏观时间步长。 ]，我们已经证实，对于下面讨论的饱和方程的有限元和时间步长方案的选择是稳定的（[2.x.34]表示单元格[2.x.35]的直径）。结果是一个方案，微观和宏观时间步长都不一致，两者都是自适应选择。
*[1.x.59][1.x.60]。
* 使用这种时间离散化，我们可以从IMPES方法中得到以下每个时间步长的方程组（见[2.x.36]）。
* [1.x.61]
* 
* 

* 利用[2.x.37]这一事实，时间离散饱和方程变为
* [1.x.62]
 
* [1.x.63][1.x.64] 。
* 

* 通过将定义总速度的方程[2.x.38]和用源项表示其发散的方程分别与测试函数[2.x.39]和[2.x.40]相乘，然后根据需要进行分项积分，问题的弱式为。找出[2.x.41]，以便对所有测试函数[2.x.42]而言，持有[1.x.65] 。
* 这里，[2.x.43]代表[2.x.44]的单位外向法向量，压力[2.x.45]可以在边界的开放部分[2.x.46]弱化规定，而在那些规定了速度的部分（例如具有[2.x.47]的不透水边界），该术语完全消失，因为[2.x.48] 。
* 我们使用连续有限元来离散化速度和压力方程。具体来说，我们使用混合有限元来确保同时对矢量变量（如流体速度）和标量变量（如压力）进行高阶逼近。对于鞍点问题，已经确定所谓的Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件[Brezzi 1991, Chen 2005]需要得到满足以确保压力-速度系统的稳定性。在本工作中，通过使用比压力高一阶的速度元素来满足这些稳定性条件，即[2.x.49]和[2.x.50]，其中[2.x.51]，[2.x.52]是空间维度，[2.x.53]表示每个变量的张量积拉格朗多项式的空间[2.x.54]。
* [1.x.66][1.x.67] 。
* 为饱和方程选择的[2.x.55]元素不能导致没有上卷或其他类型的稳定化的稳定微分，并且在数值解中会出现虚假的震荡。添加一个人工扩散项是消除这些振荡的一种方法[Chen 2005]。另一方面，添加过多的扩散项会在解中涂抹出尖锐的锋芒，并且会有网格定位的困难[Chen 2005]。为了避免这些影响，我们使用了由[Guermond and Pasquetti 2008]提出并在[Chueh, Djilali, Bangerth 2011]和[Kronbichler, Heister and Bangerth, 2011]以及[2.x.56]中验证的人工扩散项。
* 这种方法修改了饱和方程的（离散）弱形式，将其改为
* [1.x.68]
* 其中[2.x.57]是人工扩散参数，[2.x.58]是在域的边界上适当选择的数值通量（我们为此选择明显的全上风通量）。
* 按照[Guermond and Pasquetti 2008]（以及[Chueh, Djilali and Bangerth 2011]中的详细说明），我们将参数作为一个片断常数函数，设置在每个单元[2.x.59]上，直径为[1.x.69]，其中[2.x.61]是一个稳定指数，[2.x.62]是一个无尺寸的用户定义的稳定常数。按照[Guermond and Pasquetti 2008]以及[2.x.63]中的实现，速度和饱和全局正常化常数[2.x.64]以及残差[2.x.65]分别由[1.x.70 ]和[1.x.71]，其中[2.x.66]是用户定义的第二个无维常数，[2.x.67]是域的直径，[2.x.68]是整个计算域中呈现的饱和度值的范围[2.x.69] 。
* 这种稳定方案与更简单的方案相比有很多优势，如有限体积（或不连续Galerkin）方法或流线型上风Petrov Galerkin（SUPG）离散。特别是，人工扩散项主要作用于不连续点附近，因为在饱和度平稳的地方，残差很小。因此，它提供了一个更高的精度。另一方面，它是非线性的，因为[2.x.70]取决于饱和度[2.x.71] 。我们通过明确处理所有的非线性项来避免这一困难，这导致了在时间步长[2.x.72]的以下离散问题。
* [1.x.72]
* 其中[2.x.73]是由[2.x.74]和[2.x.75]线性外推到当前时间的速度[2.x.76]，如果[2.x.77]，而[2.x.78]是[2.x.79]，如果[2.x.80] .因此，该方程在[2.x.81]是线性的，所有需要的是用饱和空间的质量矩阵求解。
* 由于饱和度的Dirichlet边界条件只施加在流入边界上，所以上述方程左侧的第三项需要进一步拆分为两部分。
* [1.x.73]
* 其中[2.x.82]和[2.x.83]分别代表流入和流出的边界。我们使用上风公式选择数值，即[2.x.84]和[2.x.85]对应于从当前单元中获取的数值，而[2.x.86]和[2.x.87]的数值是从邻近边界[2.x.88]获取的数值。
* 

*[1.x.74][1.x.75]。
* 

* 自适应地选择网格以解决尖锐饱和前沿问题是我们算法中实现效率的一个基本要素。在这里，我们使用[Chueh, Djilali and Bangerth 2011]中使用的相同的冲击型细化方法来选择那些应该被细化或粗化的单元。三角形的每个单元[2.x.89]的细化指标由[1.x.76]计算，其中[2.x.90]是在单元[2.x.92]的中心[2.x.91]评估的离散饱和变量的梯度。这种方法类似于在可压缩流动问题中经常使用的方法，其中密度梯度被用来表示细化。也就是说，正如我们将在[1.x.77]末尾讨论的那样，这并不是一个非常有用的标准，因为它基本上在任何地方都导致了细化。我们在这里只是为了说明问题而展示它。
* 

*[1.x.78][1.x.79]
* 

* 按照上面讨论的治理方程的离散化，我们得到一个时间步长[2.x.93]的线性方程组，其形式如下：[1.x.80]其中各个矩阵和向量的定义如下，使用形状函数[2.x.94]表示速度，[2.x.95]表示压力和饱和度。
* [1.x.81]
*和[2.x.96]，如稳定运输方程的定义中给出的。
* 如果我们把矩阵的左上角[2.x.97]板块视为一个板块，则上述线性系统是块状三角形形式的。因此，我们可以首先求解速度和压力（除非我们决定用[2.x.98]代替速度），然后再求解饱和度变量。其中第一个步骤要求我们求解[1.x.82]，我们对这个线性系统采用广义最小残差（GMRES）方法[Saad和Schultz1986]。速度-压力系统的理想预处理程序是
* [1.x.83]
* 其中[2.x.99]是该系统的Schur补码[Zhang 2005]。这个预处理程序是最佳的，因为
* [1.x.84]
* 可以证明，GMRES在两次迭代中收敛。
* 然而，我们当然不能指望使用速度质量矩阵和Schur补码的精确求逆。因此，我们遵循[Silvester and Wathen 1994]最初为斯托克斯系统提出的方法。将其适用于当前的方程组，可以得到预设条件器
* [1.x.85]
* 其中，斜线表示精确反矩阵的近似值。特别是，由于[2.x.100]是一个稀疏的对称和正定矩阵，我们为[2.x.101]选择了这个矩阵的一个稀疏的不完全Cholesky分解的应用[Golub和Van Loan 1996]。我们注意到，对应于非混合形式的多介质流算子的Schur补，[2.x.102]和[2.x.103] 应该是实际Schur补矩阵[2.x.104] 的一个良好近似。由于这两个矩阵又都是对称和正定的，我们使用[2.x.105]的不完全Cholesky分解来表示[2.x.106]。需要注意的是，[2.x.107]需要用迪里希特边界条件建立，以确保其可逆性。
* 一旦有了速度[2.x.108]，我们就可以把[2.x.109]和[2.x.110]组合起来，用以下方法解决饱和问题
* [1.x.86]
* 其中质量矩阵[2.x.111]用共轭梯度法求解，再次使用不完整的Cholesky分解作为预处理。
* [1.x.87][1.x.88] 。
* 

* 
* [2.x.112] 这里讨论的实现使用并扩展了本库的[2.x.113]、[2.x.114]和[2.x.115]教程程序的部分内容。特别是，如果你想了解它是如何工作的，请参考[2.x.116]关于数学问题的讨论，以及[2.x.117]，大部分的实现都是来自于此。我们不会讨论已经在[2.x.118]中讨论过的实现的各个方面。
* 我们展示了一些两相流方程的数值结果，这些方程通过适当的初始和边界条件与两种不同的渗透率模型的选择进行了增强。在所考虑的问题中，没有内源项（ [2.x.119] ）。如上所述，定量的数值结果在[Chueh, Djilali and Bangerth 2011]中提出。
* 为了简单起见，我们选择了[2.x.120]，尽管所有的方法（以及我们的实现）在一般的非结构化网格上都应该同样工作。
* 初始条件只需要饱和变量，我们选择[2.x.121]，即多孔介质最初由非湿润（80%）和湿润（20%）的混合相填充。这与[2.x.122]中的初始条件不同，我们采用了[2.x.123]，但由于复杂的数学原因，在那里有一个很长的注释提到，目前使用基于熵的人工扩散项的方法在这个初始条件下不能收敛到黏度解，除非对方法进行额外的修改。因此，我们为目前的方案选择了这个修改过的版本。
* 此外，我们在边界上规定了一个线性压力：[1.x.89]压力和饱和度唯一地决定了一个速度，而速度决定了一个边界段是流入还是流出的边界。在边界的流入部分，[2.x.124]，我们规定
* [1.x.90]
* 换句话说，领域被来自左边的湿润相淹没。对于边界的流出部分，不需要饱和的边界条件。
* 所有用于二维/三维案例的数值和物理参数都列在下表中。
* [2.x.125] 
* 

* [1.x.91][1.x.92] 。
* 

* 
* [2.x.126] [2.x.127] CC Chueh, N Djilali and W Bangerth. [2.x.128] 三维异质多孔介质中两相流的h-适应性算子分割方法。[2.x.129] SIAM Journal on Scientific Computing, vol. 35 (2013), pp.
* [2.x.130] M. Kronbichler, T. Heister, and W. Bangerth [2.x.131] High Accuracy Mantle Convection Simulation through Modern NumericalMethods. [2.x.132] Geophysics Journal International, vol. 191 (2012), pp.
* [2.x.133] F Brezzi and M Fortin. [2.x.134] [1.x.93]. [2.x.135] Springer-Verlag, 1991.
* [2.x.136] Z Chen. [2.x.137] [1.x.94]. [2.x.138] Springer, 2005.
* [2.x.139] JL Guermond和R Pasquetti. [2.x.140] 基于熵的非线性黏度，用于守恒定律的傅里叶近似。[2.x.141] [1.x.95], 346(13-14): 801-806, 2008.
* [2.x.142] CC Chueh, M Secanell, W Bangerth, and N Djilali. [2.x.143] 异质多孔介质中瞬态两相流的多级自适应模拟。[2.x.144] [1.x.96], 39:1585-1596, 2010.
* [2.x.145] Y Saad和MH Schultz。[2.x.146] Gmres: 用于解决非对称线性系统的广义最小残差算法。[2.x.147] [1.x.97], 7(3):856-869, 1986.
* [2.x.148] F Zhang. [2.x.149] [1.x.98]. [2.x.150] Springer, 2005.
* [2.x.151] D Silvester and A Wathen. [2.x.152] 稳定的斯托克斯系统的快速迭代求解第二部分：使用一般块状先决条件。[2.x.153] [1.x.99], 31(5):1352-1367, 1994.
* [2.x.154] GH Golub和CF van Loan. [2.x.155] [1.x.100]. [2.x.156] 第三版，约翰霍普金斯大学，1996年。
* [2.x.157] SE Buckley和MC Leverett。[2.x.158] 沙子中流体位移的机制。[2.x.159] [1.x.101], 146:107-116, 1942.
* [2.x.160] 
 

* [1.x.102] [1.x.103].
* [1.x.104] [1.x.105].
 

* 
* 像往常一样，第一步是包括一些deal.II和C++头文件的功能。
* 

* 
* 列表中包括一些提供向量、矩阵和预处理类的头文件，这些头文件实现了各自Trilinos类的接口；关于这些的一些更多信息可以在 [2.x.161] 中找到。
* 

* 
* [1.x.106]
 
* 在这个顶层设计的最后，我们为当前的项目打开一个命名空间，下面的所有材料都将进入这个命名空间，然后将所有deal.II的名字导入这个命名空间。
* 

* 
* [1.x.107]
* 
* [1.x.108] [1.x.109]
 

* 
* 下面的部分直接取自[2.x.162]，所以没有必要重复那里的描述。
* 

* 
* [1.x.110]
* 
* [1.x.111] [1.x.112]。
 

* 
* 在本教程中，我们仍然使用以前在[2.x.163]中使用的两个渗透率模型，所以我们再次避免对它们进行详细的评论。
* 

* 
* [1.x.113]
* 
* [1.x.114] [1.x.115]。
 

* 
* 所有物理量的实现，如总流动性[2.x.164]和水的部分流量[2.x.165]都来自[2.x.166]，所以我们也没有对它们做任何评论。与[2.x.167]相比，我们增加了检查，以确保传递给这些函数的饱和度实际上是在物理上的有效范围内。此外，鉴于润湿相以速度[2.x.168]移动，很明显[2.x.169]必须大于或等于零，所以我们也断言，以确保我们为得到导数的公式而进行的计算是合理的。
* 

* 
* [1.x.116]
* 
* [1.x.117] [1.x.118]
 

* 
* 在这第一部分中，我们定义了一些我们在构建线性求解器和预处理器时需要的类。这一部分与 [2.x.170] 中使用的基本相同。唯一不同的是，原来的变量名称stokes_matrix被另一个名称darcy_matrix取代，以配合我们的问题。
* 

* 
* [1.x.119]
* 
* [1.x.120] [1.x.121].
 

* 
* 定义了解决随时间变化的平流主导的两相流问题（或Buckley-Leverett问题[Buckley 1942]）的顶层逻辑的类，主要是基于教程程序[2.x.171]和[2.x.172]，特别是[2.x.173]，其中我们使用的一般结构与这里基本相同。正如在[2.x.174]中，在下面的实现中需要注意的关键例程是[2.x.175]函数。  
* 与[2.x.176]的主要区别是，由于考虑了自适应算子拆分，我们需要多几个成员变量来保存最近两次计算的Darcy（速度/压力）解，以及当前的解（直接计算，或从前两次计算中推导出来），我们需要记住最近两次计算Darcy解的时间。我们还需要一个辅助函数来计算出我们是否真的需要重新计算达西解。  
* 与[2.x.177]不同，这一步多用了一个AffineConstraints对象，叫做 darcy_preconditioner_constraints。这个约束对象仅用于为Darcy预处理程序组装矩阵，包括悬挂节点约束以及压力变量的Dirichlet边界值约束。我们需要这个，因为我们正在为压力建立一个拉普拉斯矩阵，作为舒尔补数的近似值），如果应用边界条件，这个矩阵是正定的。  
* 这样在这个类中声明的成员函数和变量的集合与[2.x.178]中的相当相似。
* 

* 
* [1.x.122]
* 
* 我们接下来会有一些辅助函数，在整个程序中的不同地方都会用到。
* 

* 
* [1.x.123]
* 
* 接下来是成员变量，其中大部分与[2.x.179]中的变量相似，但与速度/压力系统的宏观时间步长有关的变量除外。
* 

* 
* [1.x.124]
 
* 在最后，我们声明一个变量，表示材料模型。与[2.x.180]相比，我们在这里把它作为一个成员变量，因为我们想在不同的地方使用它，所以有一个声明这样一个变量的中心位置，将使我们更容易用另一个类来替换一个类（例如用[2.x.182]替换[2.x.181]）。
* 

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127]。
 

* 
* 这个类的构造函数是对 [2.x.183] 和 [2.x.184] 中构造函数的扩展。我们需要添加涉及饱和度的各种变量。正如介绍中所讨论的，我们将再次使用[2.x.185]（Taylor-Hood）元素来表示Darcy系统，这是一个满足Ladyzhenskaya-Babuska-Brezzi（LBB）条件的元素组合[Brezzi and Fortin 1991, Chen 2005]，以及[2.x.186]元素表示饱和度。然而，通过使用存储Darcy和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度以及在其上使用的所有正交公式的下游。此外，我们还初始化了与算子分割有关的时间步进变量，以及矩阵装配和预处理的选项。
* 

* 
* [1.x.128]
* 
* [1.x.129] [1.x.130] * [1.x.130].
 

* 
* 这个函数设置了我们这里的DoFHandler对象（一个用于Darcy部分，一个用于饱和部分），以及将本程序中线性代数所需的各种对象设置为合适的尺寸。其基本操作与[2.x.187]所做的类似。  
* 函数的主体首先列举了达西和饱和系统的所有自由度。对于Darcy部分，自由度被排序，以确保速度优先于压力DoF，这样我们就可以将Darcy矩阵划分为一个[2.x.188]矩阵。  
* 然后，我们需要将悬挂节点约束和迪里切特边界值约束纳入darcy_preconditioner_constraints。 边界条件约束只设置在压力分量上，因为对应于非混合形式的多孔介质流算子的Schur补码预处理[2.x.189] ，只作用于压力变量。因此，我们使用一个过滤掉速度分量的组件_掩码，这样就可以只对压力自由度进行缩减。  
* 做完这些后，我们计算各块中的自由度数量。然后，这些信息被用来创建达西和饱和系统矩阵的稀疏模式，以及用于建立达西预处理的预处理矩阵。如同在[2.x.190]中，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。因此，对于这一点，我们遵循与[2.x.191]相同的方式，对于成员函数的其他部分，我们不必再重复描述。
* 

* 
* [1.x.131]
* 
* [1.x.132] [1.x.133].
 

* 
* 接下来的几个函数是专门用来设置我们在这个程序中必须处理的各种系统和预处理矩阵及右手边的。
* 

* 
* [1.x.134] [1.x.135].
* 

* 
* 这个函数组装了我们用于预处理达西系统的矩阵。我们需要的是速度分量上由[2.x.192]加权的矢量质量矩阵和压力分量上由[2.x.193]加权的质量矩阵。我们首先生成一个适当阶数的正交对象，即FEValues对象，可以给出正交点的数值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量phi_u和grad_phi_p将保存基函数的值，以便更快地建立局部矩阵，正如在 [2.x.194] 中已经做的。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。  
* 本地矩阵的建立相当简单。只有一个由[2.x.195]加权的项（关于速度）和一个由[2.x.196]加权的拉普拉斯矩阵需要生成，所以局部矩阵的创建基本上在两行完成。由于该文件顶部的材料模型函数只提供了渗透率和迁移率的倒数，我们必须根据给定的值手工计算[2.x.197]和[2.x.198]，每个正交点一次。  
* 一旦本地矩阵准备好了（在每个正交点上循环计算本地矩阵的行和列），我们就可以得到本地的DoF指数，并将本地信息写入全局矩阵中。我们通过直接应用约束条件（即darcy_preconditioner_constraints）来做到这一点，该约束条件负责处理悬挂节点和零Dirichlet边界条件约束。这样做，我们就不必事后再做，以后也不必使用[2.x.199]和[2.x.200]这两个需要修改矩阵和向量项的函数，因此对于我们不能立即访问单个内存位置的特里诺斯类来说，很难编写。
* 

* 
* [1.x.136]
* 
* [1.x.137] [1.x.138].
 

* 
* 在调用上述函数组装预处理矩阵后，该函数生成将用于舒尔补块预处理的内部预处理器。前置条件需要在每个饱和时间步长时重新生成，因为它们取决于随时间变化的饱和度[2.x.201]。  
*在这里，我们设置了速度-速度矩阵[2.x.202]和Schur补码[2.x.203]的预处理器。正如介绍中所解释的，我们将使用一个基于矢量矩阵[2.x.204]的IC预处理器和另一个基于标量拉普拉斯矩阵[2.x.205]的IC预处理器（其频谱上接近达西矩阵的Schur补集）。通常，[2.x.206]类可以被看作是一个很好的黑箱预处理程序，不需要对矩阵结构和/或背后的算子有任何特殊的了解。
* 

* 
* [1.x.139]
* 
* [1.x.140] [1.x.141].
 

* 
* 这是为达西系统组装线性系统的函数。  
* 关于执行的技术细节，其程序与 [2.x.207] 和 [2.x.208] 中的程序相似。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。  
* 有一件事需要评论：由于我们有一个单独的有限元和DoFHandler来处理饱和问题，我们需要生成第二个FEValues对象来正确评估饱和解。要实现这一点并不复杂：只需使用饱和结构，并为基函数值设置一个更新标志，我们需要对饱和解进行评估。这里唯一需要记住的是，两个FEValues对象使用相同的正交公式，以确保我们在两个对象的正交点上循环时得到匹配的信息。  
* 申报过程中，对数组的大小、本地矩阵的创建、右手边以及与全局系统相比的本地道夫指数的向量进行了一些简化。
* 

* 
* [1.x.142]
 
* 接下来我们需要一个向量，它将包含前一个时间层次的饱和解在正交点的值，以组装达西方程中的饱和依赖系数。    
* 我们接下来创建的向量集包含了基函数的评价以及它们的梯度，将用于创建矩阵。把这些放到自己的数组中，而不是每次都向FEValues对象索取这些信息，这是一种优化，可以加速装配过程，详情见[2.x.209]。    
* 最后两个声明是用来从整个FE系统中提取各个块（速度、压力、饱和度）的。
* 

* 
* [1.x.143]
* 
* 现在开始对问题中的所有单元进行循环。我们正在为这个装配例程处理两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，但是由于达西系统和饱和系统都使用相同的网格，我们可以假设这两个迭代器在两个DoFHandler对象的单元格上同步运行。    
* 循环中的第一条语句又是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并在正交点处得到旧解的值。 在这一点上，我们还必须在正交点上获得前一个时间步长的饱和函数的值。为此，我们可以使用[2.x.210]（之前已经在[2.x.211]、[2.x.212]和[2.x.213]中使用），这个函数接收一个解向量，并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。    
* 然后，我们就可以在单元上的正交点上进行循环，以进行积分。这方面的公式直接来自介绍中所讨论的内容。    
* 一旦完成，我们就开始在局部矩阵的行和列上进行循环，并向矩阵提供相关的产物。    
* 循环所有单元的最后一步是将本地贡献输入到全局矩阵和向量结构中，并在local_dof_indices中指定位置。同样，我们让AffineConstraints类将单元格矩阵元素插入到全局矩阵中，全局矩阵已经浓缩了悬挂节点的约束。
* 

* 
* [1.x.144]
* 
* [1.x.145] [1.x.146]
 

* 
* 这个函数是为了组装饱和传输方程的线性系统。如果有必要，它会调用另外两个成员函数：assemble_saturation_matrix()和assemble_saturation_rhs()。前一个函数然后组装饱和度矩阵，只需要偶尔改变。另一方面，后一个组装右手边的函数必须在每个饱和时间步骤中调用。
* 

* 
* [1.x.147]
* 
* [1.x.148] [1.x.149].
 

* 
* 这个函数很容易理解，因为它只是通过基函数phi_i_s和phi_j_s为饱和线性系统的左手边形成一个简单的质量矩阵。最后，像往常一样，我们通过在local_dof_indices中指定位置将局部贡献输入全局矩阵。这是通过让AffineConstraints类将单元矩阵元素插入全局矩阵来完成的，全局矩阵已经浓缩了悬挂节点约束。
* 

* 
* [1.x.150]
 
* [1.x.151] [1.x.152].
 

* 
* 这个函数是用来组装饱和传输方程的右边。在进行这项工作之前，我们必须为达西系统和饱和系统分别创建两个FEValues对象，此外，还要为这两个系统创建两个FEFaceValues对象，因为在饱和方程的弱形式中我们有一个边界积分项。对于饱和系统的FEFaceValues对象，我们还需要法向量，我们使用update_normal_vectors标志来申请。  
* 接下来，在对所有单元进行循环之前，我们必须计算一些参数（例如global_u_infty、global_S_variation和global_Omega_diameter），这是人工粘度[2.x.214]需要的。这与[2.x.215]中的做法基本相同，所以你可以在那里看到更多的信息。  
* 真正的工作开始于对所有饱和和Darcy单元的循环，以将局部贡献放入全局矢量。在这个循环中，为了简化实现，我们把一些工作分成两个辅助函数：assemble_saturation_rhs_cell_term和assemble_saturation_rhs_boundary_term。 我们注意到，我们在这两个函数中把细胞或边界贡献插入全局向量，而不是在本函数中。
* 

* 
* [1.x.153]
* 
* [1.x.154] [1.x.155].
 

* 
* 这个函数负责整合饱和度方程右边的单元项，然后将其组装成全局右边的矢量。鉴于介绍中的讨论，这些贡献的形式很清楚。唯一棘手的部分是获得人工黏度和计算它所需的一切。该函数的前半部分专门用于这项任务。  
* 该函数的最后部分是将局部贡献复制到全局向量中，其位置由local_dof_indices指定。
* 

* 
* [1.x.156]
* 
* [1.x.157] [1.x.158] * [1.x.158].
 

* 
* 下一个函数负责饱和方程右侧形式中的边界积分项。 对于这些，我们必须计算全局边界面上的上行通量，也就是说，我们只对全局边界的流入部分弱加迪里切特边界条件。如前所述，这在[2.x.216]中已经描述过了，所以我们不对其进行更多的描述。
* 

* 
* [1.x.159]
* 
* [1.x.160] [1.x.161]。
 

* 
* 该函数实现了算子分割算法，即在每个时间步长中，它要么重新计算达西系统的解，要么从以前的时间步长中推算出速度/压力，然后确定时间步长的大小，然后更新饱和变量。其实现主要遵循 [2.x.217] 中的类似代码。除了run()函数外，它是本程序中的核心函数。  
* 在函数的开始，我们询问是否要通过评估后验准则来解决压力-速度部分（见下面的函数）。如果有必要，我们将使用GMRES求解器与Schur补充块预处理来求解压力-速度部分，如介绍中所述。
* 

* 
* [1.x.162]
 
* 另一方面，如果我们已经决定不想计算当前时间步长的达西系统的解，那么我们需要简单地将前两个达西解外推到与我们计算速度/压力的时间相同。我们做一个简单的线性外推，即给定从上次计算达西解到现在的宏观时间步长[2.x.218]（由[2.x.219]给出），以及[2.x.220]上一个宏观时间步长（由[2.x.221]给出），然后我们得到[2.x.222]，其中[2.x.223]和[2.x.224]是最近两次计算的达西解。我们只需用两行代码就可以实现这个公式。    
* 请注意，这里的算法只有在我们至少有两个先前计算的达西解，我们可以从中推断出当前时间的情况下才会起作用，这一点通过要求重新计算前两个时间步骤的达西解来保证。
* 

* 
* [1.x.163]
* 
* 用这样计算出来的速度矢量，根据介绍中讨论的CFL标准计算出最佳时间步长......
* 

* 
* [1.x.164]
* 
* ...然后在我们处理时间步长的时候也要更新我们使用的宏观时间步长。具体而言，这涉及到 (i) 如果我们刚刚重新计算了达西解，那么之前的宏观时间步长现在是固定的，当前的宏观时间步长，到现在为止，只是当前（微观）时间步长。(ii) 如果我们没有重新计算达西解，那么当前的宏观时间步长刚刚增长了[2.x.225] 。
* 

* 
* [1.x.165]
* 
* 这个函数的最后一步是根据我们刚刚得到的速度场重新计算饱和解。这自然发生在每一个时间步骤中，我们不会跳过任何一个计算。在计算饱和度的最后，我们投射回允许的区间[2.x.226]，以确保我们的解保持物理状态。
* 

* 
* [1.x.166]
* 
* [1.x.167] [1.x.168].
 

* 
* 下一个函数是对网格进行细化和粗化。它的工作分三块进行。(i) 计算细化指标，方法是通过使用各自的时间步长（如果这是第一个时间步长，则取唯一的解决方案），从前两个时间步长中线性推断出的解决方案向量的梯度。(ii) 在梯度大于或小于某一阈值的单元中标记出细化和粗化的单元，保留网格细化的最小和最大水平。(iii) 将解决方案从旧网格转移到新网格。这些都不是特别困难。
* 

* 
* [1.x.169]
* 
* [1.x.170] [1.x.171]。
 

* 
* 这个函数生成了图形输出。它实质上是对 [2.x.227] 中的实现的一个复制。
* 

* 
* [1.x.172]
* 
* [1.x.173] [1.x.174].
 

* 
* [1.x.175] [1.x.176]。
* 

* 
* 这个函数实现了自适应算子拆分的后验准则。考虑到我们在上面实现其他函数的方式，并考虑到论文中得出的准则公式，这个函数是比较简单的。  
* 如果人们决定要采用原始的IMPES方法，即在每个时间步长中求解Darcy方程，那么可以通过将阈值[2.x.228]（默认为[2.x.229]）设置为零来实现，从而迫使该函数总是返回真。  
* 最后，请注意，该函数在前两个时间步骤中无条件地返回真，以确保我们在跳过达西系统的解时总是至少解了两次，从而允许我们从[2.x.230]中的最后两个解中推算出速度。
* 

* 
* [1.x.177]
* 
* [1.x.178] [1.x.179].
 

* 
* 下一个函数只是确保饱和度值始终保持在[2.x.231]的物理合理范围内。虽然连续方程保证了这一点，但离散方程并没有。然而，如果我们允许离散解逃脱这个范围，我们就会遇到麻烦，因为像[2.x.232]和[2.x.233]这样的项会产生不合理的结果（例如[2.x.234]为[2.x.235]，这将意味着润湿液相的流动方向为[1.x.180]的散流体速度））。因此，在每个时间步骤结束时，我们只需将饱和场投射回物理上合理的区域。
* 

* 
* [1.x.181]
* 
* [1.x.182] [1.x.183].   
* 另一个比较简单的辅助函数。计算总速度乘以分数流函数的导数的最大值，即计算 [2.x.236] 。这个项既用于时间步长的计算，也用于人工黏度中的熵留项的归一化。
* 

* 
* [1.x.184]
* 
* [1.x.185] [1.x.186] * [1.x.185]。  
* 为了计算稳定化项，我们需要知道饱和变量的范围。与[2.x.237]不同的是，这个范围很容易被区间[2.x.238]所约束，但我们可以通过在正交点的集合上循环，看看那里的值是什么，从而做得更好。如果可以的话，也就是说，如果周围至少有两个时间步长，我们甚至可以把这些值外推到下一个时间步长。  
* 和以前一样，这个函数是以最小的修改取自[2.x.239] 。
* 

* 
* [1.x.187]
* 
* [1.x.188] [1.x.189] 。  
* 最后一个工具函数是用来计算给定单元上的人工粘度的。如果你面前有它的公式，这并不特别复杂，看一下 [2.x.240] 中的实现。与该教程程序的主要区别是，这里的速度不是简单的[2.x.241]，而是[2.x.242]，一些公式需要做相应的调整。
* 

* 
* [1.x.190]
* 
* [1.x.191] [1.x.192]。
 

* 
* 除了[2.x.243]之外，这个函数是本程序的主要功能，因为它控制了迭代的时间，以及何时将解写入输出文件，何时进行网格细化。  
* 除了启动代码通过[2.x.244]标签循环回到函数的开头之外，一切都应该是相对简单的。无论如何，它模仿了 [2.x.245] 中的相应函数。
* 

* 
* [1.x.193]
* 
* [1.x.194] [1.x.195].
 

* 
* 主函数看起来与所有其他程序几乎相同。对于使用Trilinos的程序，需要初始化MPI子系统
* 
* - 即使是实际上没有并行运行的程序也是如此
* 
* - 在 [2.x.246] 中有解释。
* 

* 
* [1.x.196]
* 
* 这个程序只能以串行方式运行。否则，抛出一个异常。
* 

* 
* [1.x.197]
* [1.x.198][1.x.199] 。
 

* 
* 这个程序的输出与[2.x.247]的输出其实没有什么不同：毕竟它解决的是同一个问题。更重要的是量化的指标，如解决方案的准确性以及计算所需的时间。这些在本页顶部列出的两份出版物中都有详细记载，我们在此不再重复。
* 尽管如此，如果没有几张好的图片，任何教程程序都是不完整的，所以这里有一些3D运行的输出。
* [2.x.248] 
* 

* [1.x.200][1.x.201][1.x.202] 。
* 

* 人们对这个程序的主要反对意见是它仍然太慢了：在合理的细网格上进行三维计算简直是太昂贵了，不可能经常性地进行，也不可能有合理的快速周转。这与我们编写[2.x.249]时的情况类似，本程序也是从中得到很多启发的。解决办法也和当时的情况类似。我们需要以类似于从[2.x.251]中导出[2.x.250]的方式将程序并行化。事实上，[2.x.252]中使用的所有技术也可以转移到这个程序中，使程序立即在几十或几百个处理器上运行。
* 一个不同的方向是使该程序与许多其他有孔媒体应用更相关。具体来说，一个途径是进入多孔介质流动模拟器的主要用户，即石油工业。在那里，该领域的应用以多相流动为主（即超过我们这里的两相），以及它们之间可能发生的反应（或任何其他相的质量交换方式，如通过溶解和气泡从油相中流出的气体）。此外，气体的存在通常会导致流体的可压缩性效应。这些效应通常共同构成了广泛使用的 "黑油模型"。多相之间的真实反应在油藏模型中也起作用，因为考虑到油藏中石油的控制性燃烧以提高压力和温度。不过，这些问题要复杂得多，留待今后的项目处理。
* 最后，从数学的角度来看，我们得出了在某一时间步长重新计算速度/压力解的标准，假设我们想把当前时间步长得到的解与上次实际解决该系统时计算的解进行比较。然而，在程序中，每当我们没有重新计算解决方案时，我们不只是使用之前计算的解决方案，而是从之前两次解决该系统的过程中推断出来。因此，该标准被悲观地表述为：我们真正应该比较的是我们在当前时间步长中得到的解和外推的解。在这方面，重新阐述该定理是一个练习。
* 还有其他方法可以扩展这个程序的数学基础；例如，我们可以说，我们关心的不是速度，而实际上是饱和度。因此，人们可能会问，我们在这里用来决定是否需要计算[2.x.253]的标准是否合适；例如，人们可能会建议，决定一个错误的速度场是否（以及多少）事实上影响到饱和方程的解，也是很重要的。这自然会导致敏感性分析。
* 从算法的角度来看，我们在这里使用了工程中经常使用的细化标准，即通过观察解的梯度。然而，如果你检查解决方案，你会发现它几乎在所有地方都能迅速导致细化，甚至在明显不需要细化的区域：因此经常使用并不意味着它是一个有用的标准。另一方面，用一个不同的、更好的标准来取代这个标准应该不是很困难。例如，许多其他程序中使用的KellyErrorEstimator类肯定也适用于当前的问题。
* 

* [1.x.203][1.x.204] [2.x.254]。
* [0.x.1]

