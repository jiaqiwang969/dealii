include/deal.II-translator/A-tutorial/step-60_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]
* [2.x.2] 
* [1.x.22]
* [2.x.3] 
* 

* [1.x.23][1.x.24]。
* 

*[1.x.25][1.x.26]
 

* 
* 在本教程中，我们考虑两个域的情况，[2.x.4]在[2.x.5]中，[2.x.6]在[2.x.7]中，其中[2.x.8]被嵌入[2.x.9]中（[2.x.10]）。我们想解决[2.x.11]上的偏微分方程，对嵌入域*[2.x.12]上的问题的解决强制执行一些条件。
* 有两种有趣的情况。
* 
* - 嵌入域[2.x.13]的几何维度`dim`与域[2.x.14]相同（`spacedim`），即[2.x.15]的spacedim维度不为零，或
* 
* - 嵌入域[2.x.16]的内在维度`dim`小于[2.x.17]（`spacedim`），因此其间隔维度为零；例如，它是一条嵌入二维域的曲线，或嵌入三维域的面。
* 在这两种情况下，定义限制算子[2.x.18]为算子，给定[2.x.19]上的连续函数，返回其在[2.x.20]上的（连续）限制，即：。
* [1.x.27]
* 众所周知，当[2.x.25]的内在维度与[2.x.26]相同时，算子[2.x.21]可以扩展为[2.x.22]上的连续算子，将[2.x.23]中的函数映射到[2.x.24]中的函数。
* 当[2.x.28]的维数比[2.x.29]少一个时，同样的情况也适用于一个不太规则的范围空间（即[2.x.27]），并且[2.x.30]没有边界。在这第二种情况下，算子[2.x.31]也被称为轨迹*算子，它对于嵌入[2.x.33]的Lipschitz共维度一的曲线和曲面[2.x.32]有很好的定义（关于轨迹算子的进一步细节请阅读[1.x.28]）。
* 二维的情况要复杂一些，一般来说，当[2.x.36]的维度为零或一的时候，不可能构造一个连续的轨迹算子，甚至不可能从[2.x.34]到[2.x.35]，分别在二维和三维中构造。
* 在本教程中，我们对[2.x.37]的进一步细节不感兴趣：假设嵌入域的维数(`dim`)总是小于或等于嵌入域[2.x.39]的维数(`spacedim`)，我们认为扩展[2.x.38]是当然的。
* 我们要解决以下微分问题：给定[2.x.41]上的一个充分无规则函数[2.x.40]，求[2.x.42]的解。
* [1.x.29]
* 
* 这是一个约束问题，我们正在寻找一个谐波函数[2.x.43]，满足[2.x.44]上的同质边界条件，并在约束条件[2.x.45]下使用拉格朗日乘法器。
* 这个问题有一个物理解释：谐波函数，即满足拉普拉斯方程的函数，可以被认为是边界值被规定的膜的位移。目前的情况相当于找到一个膜的形状，不仅边界上的位移，而且[2.x.46]上的位移也是规定的。例如，如果[2.x.47]是二维空间中的一条封闭曲线，那么这将是一个肥皂膜的模型，它被沿[2.x.48]的一个线环和沿[2.x.49]的第二个线环所固定。在[2.x.50]是整个区域的情况下，你可以把它看作是在障碍物上伸展的膜，其中[2.x.51]是接触区域。如果接触面积不知道，我们有一个不同的问题
* 
* 称为 "障碍物问题"
* 
* --在[2.x.52]中进行建模）。)
* 作为第一个例子，我们研究[2.x.53]上的零迪里切特边界条件。如果我们在[2.x.54]上应用零Neumann边界条件或两者的混合，也适用同样的方程。
* 变分公式可以通过引入两个无限空间[2.x.55]和[2.x.56]来得到，分别用于解[2.x.57]和拉格朗日乘子[2.x.58]。
* 将第一个方程乘以[2.x.59]，第二个方程乘以[2.x.60]，可能时进行部分积分，并利用[2.x.61]的边界条件，我们得到以下变量问题。
* 给定[2.x.63]上的一个足够规则的函数[2.x.62]，找到[1.x.30]的解[2.x.64]。
* 
*其中[2.x.65]和[2.x.66]分别代表[2.x.67]在[2.x.68]和[2.x.69]中的标量积。
* 对变量公式的检查告诉我们，空间[2.x.70]可以被看作是[2.x.71]。空间[2.x.72]，在同维度为零的情况下，应取为[2.x.73]，而在同维度为一的情况下，应取为[2.x.74]。
* 因此，函数[2.x.75]应该在[2.x.76]（对于同维度零的情况）或[2.x.77]（对于同维度一的情况）中，这给我们留下了一个拉格朗日乘数[2.x.78]，即[2.x.80]或[2.x.81] 。
* 上述问题的离散化有两种选择。人们可以选择匹配离散化，即[2.x.82]的三角法与[2.x.83]的三角法相一致，或者可以选择以完全独立的方式离散化这两个域。
* 对于我们上面提出的简单问题，第一种选择显然更有意义：只需对[2.x.84]使用一个三角形计算，然后根据[2.x.85]施加某些约束。这种方法的一个例子是在[2.x.86]中研究的，其中解决方案必须保持在一个障碍物之上，这是在[2.x.87]上施加的约束。
* 为了解决更复杂的问题，例如领域[2.x.88]与时间有关的问题，第二种方法可能是更可行的解决方案。处理不对齐的网格本身就很复杂：为了说明如何做，我们研究一个简单的问题。
* 我们在这里描述的技术在文献中使用了许多名称：[1.x.31]、[1.x.32]、[1.x.33]和其他名称之一。其主要原理是，两个网格和两个有限元空间的离散化是完全独立的。这种技术对于模拟流固耦合问题特别有效，其中嵌入结构的配置是问题本身的一部分，人们要解决一个（可能是非线性）弹性问题来确定[2.x.89]的（与时间有关的）配置，以及[2.x.90]的（可能是非线性）流动问题，加上流体和固体之间界面上的耦合条件。
* 在这个教程程序中，我们把事情变得简单一些，我们假设嵌入域的配置是以两种可能的方式之一给出的。
* 
* -作为变形映射[2.x.91]，定义在[2.x.92]上的连续有限维空间上，对于任何点[2.x.93]，其坐标[2.x.94]在[2.x.95]中表示。
* 
* - 作为[2.x.97]的位移映射[2.x.96]，代表任何点[2.x.98]的位移矢量，以使[2.x.99]形成其实际配置[2.x.100] 。
* 我们定义了嵌入式参考域[2.x.101]`embedded_grid`：在这个三角形上，我们构建了一个有限维空间（`embedded_configuration_dh`），通过FE_Q对象的有限单元系统（`embedded_configuration_fe`）来描述变形或位移。这个有限维度空间仅用于插值用户提供的函数（`embedded_configuration_function`），代表[2.x.102]（如果参数`use_displacement`被设置为[2.x.103]）或[2.x.104]（如果参数`use_displacement`被设置为[2.x.105] ）。
* 拉格朗日乘数[2.x.106]和用户提供的函数[2.x.107]是通过另一个有限维空间`embedded_dh`和另一个有限元素`embedded_fe`定义的，使用相同的参考域。为了考虑到域的变形，MappingFEField或MappingQEulerian对象都用`embedded_configuration`向量初始化。
* 在嵌入空间中，使用FiniteElement `space_fe`在嵌入网格`space_grid`上构建了一个标准的有限维空间`space_dh`，几乎逐字逐句地遵循[2.x.108]中的方法。
* 我们分别用[1.x.34]和[1.x.35]表示空间[2.x.109]和[2.x.110]的离散化，其中[2.x.111]是`space_dh`的尺寸，[2.x.112]是`embedded_dh`的尺寸。
* 一旦所有的有限维空间都被定义，上述问题的变分公式就会给我们留下以下的有限维方程组。
* [1.x.36]
* 其中
* [1.x.37]
* 
* 虽然矩阵[2.x.113]是[2.x.114]上泊松问题的标准刚度矩阵，而向量[2.x.115]是[2.x.117]上带有强迫项[2.x.116]的有限元问题的标准右手向量（例如，见[2.x.118]），但矩阵[2.x.119]或其转置[2.x.120]是非标准的，因为它们在两个非匹配网格上耦合信息。
* 特别是，在计算[2.x.121]的一个条目时出现的积分，是在[2.x.122]上计算的。像通常的有限元一样，我们将这个积分分成来自用于解算[2.x.123]的三角形的所有单元的贡献，我们将[2.x.124]上的积分转换为其边界元素[2.x.125]上的积分，其中[2.x.126]是从[2.x.127]到[2.x.128]的映射，并且使用正交公式计算[2.x.129]上的积分。
* [1.x.38]
* 计算这个和是不容易的，因为我们必须评估[2.x.130]。一般来说，如果[2.x.131]和[2.x.132]没有对齐，那么[2.x.133]点相对于[2.x.134]是完全任意的，除非我们想出一个办法，在[2.x.136]上的一个任意点上插值[2.x.135]的所有基函数，否则我们无法计算出矩阵[2.x.137]的一个条目需要的积分。
* 为了评估[2.x.138]，需要采取以下步骤（如下图所示）。
 
* - 对于[2.x.140]中的给定单元[2.x.139]，计算实点[2.x.141]，其中[2.x.142]是用于对[2.x.143]进行积分的正交点之一。
* 
* - 找到[2.x.144]的单元，[2.x.145]位于其中。我们将称这个单元为[2.x.146]。
* 
* - 为了评估基函数，使用映射[2.x.147]的逆映射，将参考元素[2.x.148]转换为元素[2.x.149]：[2.x.150] 。
* [2.x.151] 
* 上面的三个步骤可以通过依次调用来计算。
* 
* - [2.x.152]，然后是
* 
* - [2.x.153] 我们然后
* 
* - 构建一个自定义的正交公式，包含参考单元格中的点，然后
* 
* - 构建一个FEValues对象，使用给定的正交公式，并以第一步中获得的单元格为初始化。
* 这就是deal.II函数[2.x.154]在评价一个任意点的有限元场（而不仅仅是一个单一的形状函数）时的做法；但在这种情况下，这将是低效的。
* 一个更好的解决方案是使用一个方便的包装器在一个点的集合上执行前三个步骤。 [2.x.155]如果人们确实对计算完整的耦合矩阵感兴趣，那么可以调用方法[2.x.156]，该方法以有效的方式执行上述步骤，重复使用所有可能的数据结构，并将昂贵的步骤集合起来。这就是我们在本教程后面要使用的函数。
* 我们通过迭代求解器来解决最终的鞍点问题，应用于舒尔补码[2.x.157]（其构造在[2.x.158]中有所描述），我们使用LinearOperator类构造[2.x.159]。
* 

*[1.x.39][1.x.40]
* 

* 我们在这里解决的问题与[2.x.160]相同，不同的是我们对一个嵌入域[2.x.161]施加一些约束。本教程是以独立于维度的方式编写的，在结果部分我们展示了如何改变`dim`和`spacedim`。
* 本教程是在`dim`等于1，`spacedim`等于2的情况下编译的。如果你想在嵌入维度`spacedim`等于3的情况下运行程序，你很可能想改变[2.x.162]的参考域，例如，你从文件中读到的东西，或者你后来变形为更有趣的东西的封闭球。
* 在默认情况下，[2.x.163]的同维度为1，本教程程序实现了虚构边界法。事实证明，同样的技术被用于变异沉浸有限元法，上面定义的耦合算子[2.x.164]在几乎所有的非匹配方法中都是一样的。
* 嵌入域被假定包括在[2.x.165]中，我们把它当作单元方[2.x.166]。虚域[2.x.167]的定义可以通过参数文件进行修改，可以给出从界线区间[2.x.168]到[2.x.169]中的一条曲线的映射。
* 如果该曲线是封闭的，那么结果将类似于在边界为[2.x.170]的网格上运行相同的问题。程序也可以在非封闭的[2.x.171]上运行，尽管在这些情况下，问题的数学表述更加困难，因为[2.x.172]本身就有一个边界，相对于域[2.x.173]来说是二维的。
* 

* [1.x.41][1.x.42] 。
* 

* [2.x.174] [2.x.175] Glowinski, R., T.-W. Pan, T.I. Hesla, and D.D. Joseph. 1999. "分布式拉格朗日乘数/虚构域方法用于颗粒物流动"。 International Journal of Multiphase Flow 25 (5). Pergamon: 755-94.
* [2.x.176] Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin. 2008. "论沉浸边界法的超弹性公式"。应用力学和工程中的计算机方法197（25-28）。
* [2.x.177] Heltai, L., and F. Costanzo. 2012. "浸没式有限元方法的变量实现"。应用力学和工程中的计算机方法》229-232。[2.x.178] 
* 

* [1.x.43] [1.x.44].
* [1.x.45] [1.x.46] 其中大部分已在其他地方介绍过，我们只对新的进行评论。
* 

* 
*  

* 
* [1.x.47]
* 
* 参数接受器类是本教程程序的第一个新颖之处：一般来说，参数文件是用来在运行时引导程序的执行。虽然即使是简单的方法也能节省编译时间，因为同一个可执行文件可以用不同的参数设置来运行，但要同时处理数百个参数，同时保持不同程序之间的兼容性会变得很困难。这就是ParameterAcceptor类证明有用的地方。
* 

* 
* 这个类用来定义一个公共接口，供那些想使用一个全局ParameterHandler来处理参数的类使用。该类提供了一个静态的ParameterHandler成员，即[2.x.179]，并实现了 "命令设计模式"（例如，见E. Gamma, R. Helm, R. Johnson, J. Vlissides, 设计模式。Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. https://goo.gl/FNYByc）。)
* 

* 
* ParameterAcceptor提供了一个全局订阅机制。每当一个从ParameterAcceptor派生出来的类的对象被构造出来，一个指向该派生类型的对象的指针就会被注册，同时在参数文件中也有一个部分条目。这种注册表在调用单一函数[2.x.180]时被遍历，该函数反过来确保所有存储在全局注册表中的类都声明它们将使用的参数，在声明了这些参数后，它读取`file.prm`的内容来解析实际参数。
* 

* 
* 如果你为你想在代码中使用的每个参数调用方法[2.x.181]，你就不需要做其他事情了。如果你使用一个已经存在的类，它提供了两个函数`declare_parameters`和`parse_parameters`，你仍然可以使用ParameterAcceptor，方法是将现有的类封装成ParameterAcceptorProxy类。
* 

* 
* 在这个例子中，我们将使用这两种策略，为deal.II类使用ParameterAcceptorProxy，并直接从ParameterAcceptor派生我们自己的参数类。
* 

* 
* [1.x.48]
* 
* 另一个新的包含文件是包含[2.x.182]类的文件。deal.II的结构和许多现代数值库一样，是按照有向无环图（DAG）组织的。DAG是一个具有拓扑顺序的有向图：每个节点在结构上代表一个对象，并通过一条（或多条）有向边与非根节点相连，从父节点到子节点。这种结构最重要的例子是Triangulation及其[2.x.183]结构。从Triangulation（主节点），我们可以访问每个单元（三角形的子节点）。从单元本身，我们可以访问该单元的所有顶点。在这个简单的例子中，DAG结构可以表示为三种节点类型（三角结构、单元格迭代器和顶点），由从三角结构到单元格迭代器，以及从单元格迭代器到顶点的定向边连接。这有几个优点，但它本质上造成了 "不对称"，使某些操作变得很快，而它们的逆向操作却很慢：寻找一个单元的顶点的计算成本很低，可以通过简单地遍历DAG来完成，而寻找所有共享一个顶点的单元则需要进行非难事的计算，除非添加一个新的DAG数据结构来表示逆向搜索。
* 

* 
* 由于逆向操作在有限元代码中通常是不需要的，所以在GridTools中实现了这些操作，而没有使用与三角形相关的额外数据结构，这将使它们的速度更快。例如，一个这样的数据结构是一个从三角形的顶点到所有共享这些顶点的单元的映射，这将减少回答前面问题所需的计算。
* 

* 
* 有些方法，例如[2.x.184]大量使用了这些非标准的操作。如果你需要多次调用这些方法，那么把这些数据结构储存在某个地方就变得很方便了。 [2.x.185]正是这样做的，它让你可以访问以前计算过的对象，或者在飞行中计算它们（然后将它们存储在类中供以后使用），并确保每当三角测量被更新时，相关的数据结构也被重新计算。
* 

* 
* [1.x.49]
 
* 在这个例子中，我们将使用一个参考域来描述一个嵌入的Triangulation，通过一个有限元矢量场进行变形。
* 

* 
* 接下来的两个包含文件包含了在这些情况下可以使用的两个类的定义。MappingQEulerian允许人们通过位移*场来描述一个域，基于FESystem[FE_Q(p)^spacedim] 有限元空间。第二种是比较通用的，允许你使用任意的矢量有限元空间，只要它们能提供一个连续的*域描述。
 对你的领域的描述。在这种情况下，描述是通过实际变形*场，而不是位移*场完成的。
* 

* 
* 哪一个被使用取决于用户想如何指定参考域，和/或实际配置。我们将提供这两个选项，并在本教程程序的结果部分做一些实验。
* 

* 
* [1.x.50]
* 
* 被解析的函数类是另一个新条目。它允许人们创建一个Function对象，从参数文件中的一个字符串开始，它被解析成一个对象，你可以在deal.II接受Function的任何地方使用（例如，用于插值、边界条件等）。
* 

* 
* [1.x.51]
* 
* 这是本教程程序的最后一个新条目。命名空间NonMatching包含了一些方法，这些方法在对非匹配网格或不与底层网格对齐的曲线进行计算时非常有用。
* 

* 
* 我们将在后面的 "setup_coupling "方法中详细讨论其用途。
* 

* 
* [1.x.52]
* 
* ［1.x.53］ ［1.x.54   
* 在DistributedLagrangeProblem中，我们需要两个参数来描述域[2.x.186]（`dim`）和域[2.x.187]（`spacedim`）的尺寸。  
* 这些参数将被用来初始化一个Triangulation<dim,spacedim>（用于[2.x.188]）和一个Triangulation<spacedim,spacedim>（用于[2.x.189] ）。  
* 与其他教程程序相比，一个新奇之处在于大量使用了 [2.x.190] 这些行为就像经典的指针，其优点是可以进行自动的内部管理：一旦unique_ptr超出范围，所包含的对象就会被自动销毁，即使它在一个容器内或者有一个异常。此外，它不允许有重复的指针，这可以防止所有权问题。我们这样做，是因为我们希望能够 i) 构建问题，ii) 读取参数，iii) 根据参数文件中指定的内容初始化所有对象。  
* 我们在派生于ParameterAcceptor的内部类`Parameters`中构建我们问题的参数。`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用，因此不可能从DistributedLagrangeProblem类本身修改参数。  
* 我们可以先初始化参数，然后将参数传递给DistributedLagrangeProblem，假设所有条目都设置为所需的值，但这有两个缺点。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
* 
* - 我们不应该对用户如何初始化一个不受我们直接控制的类做出假设。如果用户未能初始化该类，我们应该注意到并抛出一个异常。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
* 
* - 并非所有需要从参数文件中读取参数的对象在我们构造参数时都可以使用；对于复杂的程序，有多种物理现象，或者我们在一些外部类中重复使用现有的代码，往往是这种情况。我们通过将一些 "复杂 "的对象，如ParsedFunction对象，保留在`DistributedLagrangeProblem`内而不是`Parameters`内来模拟这一点。  
* 这里我们假设在构建时，构建我们问题的类还不能使用。解析参数文件是确保我们有所有的成分来建立我们的类，我们的设计是，如果解析失败，或者没有被执行，运行就会被中止。
* 

* 
*  

* 
* [1.x.55]
* 
* `Parameters`类派生于ParameterAcceptor。这使得我们可以在其构造函数中使用[2.x.191]方法。    
* 这个函数的成员都是非常量的，但是`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用：这确保参数不会从`DistributedLagrangeProblem`类中被修改。
* 

* 
* [1.x.56]
* 
* 现在描述的参数都可以用参数文件在外部设置：如果运行可执行文件时没有参数文件，程序将用这里定义的默认值创建一个 "parameters.prm "文件，然后中止，让用户有机会修改参数.prm文件。
* 

* 
* 嵌入网格的初始细化，对应于域[2.x.192] 。
* 

* 
* [1.x.57]
* 
* 嵌入网格[2.x.193]和嵌入网格[2.x.194]之间的互动是通过[2.x.195]的计算来处理的，这涉及到[2.x.196]的所有单元与[2.x.197]的部分重叠：对这些单元的更高细化可能会提高我们的计算质量。为此，我们定义了 "delta_refinement"：如果它大于零，那么我们将空间网格中包含嵌入网格顶点的每个单元及其相邻的单元标记出来，执行细化，并重复这个过程 "delta_refinement "次。
* 

* 
* [1.x.58]
* 
* 开始细化嵌入网格，对应于域[2.x.198] 。
* 

* 
* [1.x.59]
* 
* 边界id的列表，在这个列表中我们施加了同质的Dirichlet边界条件。在其余的边界id上（如果有的话），我们施加同质的诺伊曼边界条件。作为一个默认的问题，我们在[2.x.199]上设置了零迪里切特边界条件。
* 

* 
* [1.x.60]
 
* 嵌入空间的有限元素程度。 [2.x.200] 
* 

* 
* [1.x.61]
 
* 嵌入空间的有限元素程度。 [2.x.201] 
* 

* 
* [1.x.62]
* 
*用于描述嵌入域变形的空间的有限元程度
* 

* 
* [1.x.63]
* 
* 用于积分耦合的正交公式的阶数
* 

* 
* [1.x.64]
* 
* 如果设置为 "真"，则嵌入式配置函数被解释为位移函数
* 

* 
* [1.x.65]
* 
* 在输出中使用的粗略程度
* 

* 
* [1.x.66]
* 
* 一个标志，用于跟踪我们是否被初始化了
* 

* 
* [1.x.67]
* 
* DistributedLagrangeProblem的入口点
* 

 
* [1.x.68]
* 
* 包含实际参数的对象
* 

* 
* [1.x.69]
* 
* 下面的函数与其他所有的教程程序相似，不同的是，我们现在需要为两个不同系列的对象设置东西，即与embedding*网格有关的对象，以及与embedded*有关的对象。
* 

* 
*  

* 
* [1.x.70]
* 
* 我们这里唯一的非常规函数是`setup_coupling()`方法，用于生成耦合矩阵的稀疏模式 [2.x.202] 。
* 

* 
*  

* 
* [1.x.71]
 
* 首先我们收集所有与嵌入空间几何有关的对象
* 

* 
*  

* 
* [1.x.72]
* 
* 然后是与嵌入网格有关的，与拉格朗日乘数`lambda`有关的DoFHandler
* 

* 
*  

* 
* [1.x.73]
 
* 最后，所有需要形成*内嵌三角形的东西都是如此
* 

* 
* [1.x.74]
* 
* ParameterAcceptorProxy类是一个 "透明 "的包装器，它源自ParameterAcceptor和作为其模板参数传递的类型。在构造时，参数被分成两部分：第一个参数是转发给ParameterAcceptor类的[2.x.203]，并包含应该用于该类的部分名称，而所有其余的参数都被转发给模板类型的构造器，在这种情况下，转发给[2.x.204]构造器。    
* 这个类允许你结合ParameterAcceptor注册机制使用现有的类，只要这些类有`declare_parameters()`和`parse_parameters()`成员。    
* 这里就是这种情况，使得利用[2.x.205]类相当容易：不要求用户在代码中为RHS、边界函数等创建新的Function对象（就像在其他大多数教程中那样），这里我们允许用户使用deal.II接口到muParser（http://muparser.beltoforion.de），其中函数的规范不是在编译时完成，而是在运行时，使用一个字符串被解析成一个实际的Function对象。    
* 在这种情况下，`embedded_configuration_function`是一个向量值的Function，根据`parameters.use_displacement`的布尔值，可以被解释为adeformation*或adisplacement*。组件的数量在后面的构造中指定。
* 

* 
*  

* 
* [1.x.75]
 
* 我们做同样的事情来指定函数[2.x.206]的值，这就是我们希望我们的解在嵌入空间中的值。在这种情况下，该函数是一个标量函数。
* 

* 
* [1.x.76]
* 
* 与我们对[2.x.207]类所做的类似，我们对ReductionControl类重复同样的做法，允许我们为我们以后要使用的Schur补码迭代求解器指定所有可能的停止标准。
* 

* 
* [1.x.77]
* 
* 接下来我们收集所有我们需要的SparsityPattern, SparseMatrix和Vector对象
* 

* 
* [1.x.78]
* 
* TimerOutput类是用来提供一些关于我们程序性能的统计数据。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81] [1.x.81].   
* 在构造时，我们也要初始化ParameterAcceptor类，在解析参数文件时，我们希望我们的问题能使用节的名称。  
* 参数文件可以被组织成节/子节/等等：这样做的好处是，定义的对象在共享同一节/子节/等等时可以共享参数。ParameterAcceptor允许使用Unix约定的路径来指定部分名称。如果部分名称以斜线（"/"）开头，那么该部分将被解释为一个绝对路径*，ParameterAcceptor为路径中的每个目录输入一个小节，使用它遇到的最后一个名称作为当前类的登陆小节。  
* 例如，如果你用`ParameterAcceptor("/first/second/third/My Class")`构建你的类，参数将被组织如下。  
* [2.x.208]    
* 在内部，存储在ParameterAcceptor中的current path*现在被认为是"/first/second/third/"，也就是说，当你指定一个绝对路径时，ParameterAcceptor会将*当前的部分改为当前路径，即改为直到最后*"/"的部分名称的路径。  
* 你现在可以使用相对路径（例如，`ParameterAcceptor("My Other Class")`）而不是绝对路径（例如，`ParameterAcceptor("/first/second/third/My Other Class")`）构建从ParameterAcceptor派生的另一个类，获得。 [2.x.209]    
* 如果部分名称*以斜线结尾，那么后续的类将把它解释为全路径：例如，与上面类似，如果我们有两个类，一个用`ParameterAcceptor("/first/second/third/My Class/")`初始化，另一个用`ParameterAcceptor("My Other Class")`，那么得到的参数文件将看起来像。  
* [2.x.210]    
* 我们将利用这一点，使我们的`Parameters`成为所有后续构建的类的父*。由于大多数其他的类都是 "DistributedLagrangeProblem "的成员，这允许，例如，为两个不同的维度构造两个 "DistributedLagrangeProblem"，而不会在这两个问题的参数上有冲突。
* 

* 
* [1.x.85]
* 
* [2.x.211]函数做了几件事。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 在施工时向ParameterAcceptor输入指定的分段
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 调用[2.x.212]函数
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 调用你可能连接到[2.x.213]的任何信号 
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 离开了该小节     
* 反过来，[2.x.214]。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 在参数处理程序中为给定的变量声明一个条目。
 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 
* - 获取变量的当前值
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 将其转换为一个字符串，作为参数文件的默认值使用
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 在[2.x.215]中附加一个动作*，当文件被解析时，或当一个条目被设置时，它将更新传递给`add_parameter()`的变量的值，将其设置为输入文件中指定的内容（当然，在输入文件被解析并将文本表示转换为变量的类型之后）。
* 

* 
* [1.x.86]
* 
* 一旦参数文件被解析，那么参数就可以使用了。设置内部变量`initialized`为true。
* 

* 
* [1.x.87]
* 
* 构造函数是非常标准的，除了前面解释的`ParameterAcceptorProxy`对象之外。
* 

* 
* [1.x.88]
* 
* 这里是为使用ParameterAcceptorProxy构建的ParameterAcceptor类设置默认值的一种方法。    
* 在这种情况下，我们将嵌入式网格的默认变形设置为半径为[2.x.216]、中心为[2.x.217]的圆，我们将embedded_value_function的默认值设置为常数，并为SolverControl对象指定一些合理的值。    
* 嵌入[2.x.218]是最基本的：从[2.x.219]的定义可以看出，如果[2.x.220]，矩阵[2.x.221]的某些行将为零。这将是一个问题，因为舒尔补码法要求[2.x.222]具有全列秩。
* 

* 
* [1.x.89]
* 
* [1.x.90] [1.x.91]。  
* 函数[2.x.223]是用来设置有限元空间的。注意[2.x.224]是如何用来创建包裹在[2.x.225]对象内的对象的。
* 

* 
* [1.x.92]
* 
* 初始化[2.x.226]：构造三角形并将其包裹到[2.x.227]对象中
* 

* 
* [1.x.93]
* 
* 接下来，我们使用[2.x.228]实际创建三角形，最后一个参数被设置为true：这激活了着色（即为边界的不同部分分配不同的边界指标），我们用它来分配Dirichlet和Neumann条件。
* 

* 
* [1.x.94]
 
* 一旦我们构建了一个三角形，我们就根据参数文件中的规格对其进行全局细化，并用它构建一个[2.x.229]。
* 

* 
* [1.x.95]
* 
* 对嵌入式网格也是这样做的。由于嵌入式网格是变形的，我们首先需要设置变形映射。我们在下面几行中这样做。
* 

* 
* [1.x.96]
* 
* 一旦我们为变形定义了一个有限维度的空间，我们就对参数文件中定义的 "嵌入_配置_函数 "进行插值。
* 

* 
* [1.x.97]
* 
* 现在我们可以根据用户在参数文件中指定的内容来解释它：作为位移，在这种情况下，我们构建一个映射，将我们配置有限元空间的每个支撑点的位置在相应的配置矢量上按指定的量进行位移*，或者作为一个缺省位置。    
* 在第一种情况下，MappingQEulerian类提供其服务，而在第二种情况下，我们将使用MappingFEField类。它们实际上是非常相似的。MappingQEulerian只适用于FE_Q有限元空间系统，其中位移矢量被存储在FESystem的第一个`spacedim`分量中，并且在构造时作为参数给出的度数必须与第一个`spacedim`分量的度数相匹配。    
* MappingFEField类稍显一般，因为它允许你在构造近似时选择任意的FiniteElement类型。当然，根据你选择的FiniteElement的类型，一些选择可能（也可能没有）意义。MappingFEField实现了纯粹的等参量概念，例如，可以通过与FE_Bernstein有限元类结合，在deal.II中实现等参量分析代码。在这个例子中，我们将考虑到一个配置将是一个 "位移"，而另一个将是一个绝对的 "变形 "场，从而将两者互换使用。
* 

* 
*  

* 
* [1.x.98]
* 
* 在这个教程程序中，我们不仅对[2.x.230]进行全局细化，还允许根据[2.x.231]的位置进行局部细化，根据`parameters.delta_refinement`的值，我们用来决定应该对[2.x.232]进行多少轮局部细化，对应于[2.x.233]的位置。    
* 有了这个映射，现在就可以通过调用方法[2.x.234]来查询与`嵌入式_dh'相关的所有支持点的位置。     
* 这个方法有两个变体。一种是不*接受Mapping，另一种是接受Mapping。如果你使用第二种类型，就像我们在这种情况下所做的那样，支持点是通过指定的映射来计算的，它可以对它们进行相应操作。    
* 这正是`embedded_mapping`的作用。
* 

* 
* [1.x.99]
* 
* 一旦我们有了嵌入有限元空间的支持点，我们就想确定嵌入空间的哪些单元包含哪些支持点，以便有机会在必要的地方细化嵌入网格，也就是嵌入网格的位置。这可以手动完成，通过循环每个支持点，然后为嵌入空间的每个单元调用方法[2.x.235]，直到我们找到一个返回单位参考单元中的点，或者可以用更智能的方式完成。    
* [2.x.236]是一个可能的选择，它以更便宜的方式执行上述任务，首先确定嵌入三角的最接近目标点的顶点，然后只对那些共享找到的顶点的单元格调用[2.x.237]。    
* 事实上，在GridTools命名空间中，有一些算法利用[2.x.238]对象，可能还有KDTree对象来尽可能地加快这些操作。    
* 利用最大速度的最简单的方法是调用一个专门的方法，[2.x.239]在第一次点搜索时，会存储很多有用的信息和数据结构，然后在后续的点中重复使用所有这些信息。    
* [2.x.240]返回一个元组，其中第一个元素是一个包含输入点的单元格向量，在这里是support_points。对于细化来说，这是我们唯一需要的信息，而这正是现在所发生的。    
* 然而，当我们需要组装一个耦合矩阵时，我们还需要每个点的参考位置来评估嵌入空间的基础函数。由[2.x.241]返回的元组的其他元素允许你重建，对于每个点，什么单元包含它，以及什么是给定点的参考单元的位置。由于这些信息最好被分组到单元格中，那么这就是算法返回的内容：一个元组，包含所有单元格中至少有一个点的向量，以及所有参考点的列表和它们在原始向量中的相应索引。    
* 在下面的循环中，我们将忽略所有返回的对象，除了第一个，确定所有单元格至少包含一个嵌入空间的支持点。这允许一个简单的自适应细化策略：细化这些单元和它们的邻居。    
* 请注意，我们需要做一些理智的检查，在这个意义上，我们希望有一个嵌入网格，它在嵌入网格周围被很好地细化，但其中两个连续的支持点要么位于同一个单元，要么位于邻居嵌入单元。    
* 这只有在我们确保嵌入网格的最小单元尺寸仍然大于嵌入网格的最大单元尺寸时才有可能。由于用户可以修改细化水平，以及他们希望在嵌入网格周围进行的局部细化的数量，我们要确保所得到的网格满足我们的要求，如果不是这样，我们就以例外的方式放弃。
* 

* 
* [1.x.100]
* 
* 为了构造一个良好的耦合插值算子[2.x.242]，对嵌入域和被嵌入域之间的网格的相对尺寸有一些限制。耦合算子[2.x.243]和空间[2.x.244]和[2.x.245]必须满足一个inf-sup条件，以使问题有一个解决方案。事实证明，只要空间[2.x.247]和[2.x.248]之间相互兼容（例如，只要它们被选为引言中所述的空间），非匹配的[2.x.246]投影就满足这种inf-sup条件。    
* 然而，discrete* inf-sup条件也必须成立。这里没有出现复杂的情况，但事实证明，当非匹配网格的局部直径离得太远时，离散的inf-sup常数会恶化。特别是，事实证明，如果你选择了一个相对于嵌入网格更细*的嵌入网格，inf-sup常数的恶化程度要比你让嵌入网格更细的情况下要大得多。    
* 为了避免问题，在本教程中，如果用户选择的参数使嵌入网格的最大直径大于嵌入网格的最小直径，我们将抛出一个异常。    
* 这种选择保证了几乎每个嵌入网格的单元都不超过两个嵌入网格的单元，但也有一些罕见的例外，这些例外在产生的inf-sup方面可以忽略不计。
* 

* 
* [1.x.101]
* 
* [2.x.249]已经被完善，我们现在可以设置它的DoF了
 

* 
* [1.x.102]
 
* 我们现在设置[2.x.250]和[2.x.251]的DoF：因为它们基本上是独立的（除了[2.x.252]的网格在[2.x.253]周围更加精细），所以程序是标准的。
* 

* 
* [1.x.103]
 
* 根据定义，刚度矩阵只涉及[2.x.254]的DoFs。
* 

* 
* [1.x.104]
 
* 根据定义，我们要解决的系统的Rhs只涉及一个零向量和[2.x.255]，它只用[2.x.256]的DoF来计算。
* 

* 
* [1.x.105]
* 
* 创建耦合稀疏模式是一个复杂的操作，但是可以使用[2.x.257]轻松完成，它需要两个DoFHandler对象，耦合的正交点，一个DynamicSparsityPattern（然后需要复制到稀疏模式中，像往常一样），嵌入和嵌入三角形的分量掩码（我们留空）以及嵌入和嵌入三角形的映射关系。
* 

* 
* [1.x.106]
* 
* [1.x.107] [1.x.108]   
* 以下函数创建矩阵：如前所述，计算刚度矩阵和rhs是一个标准程序。
* 

* 
* [1.x.109]
* 
* 嵌入刚度矩阵 [2.x.258] ，以及右手 [2.x.259] 。
 

 
* [1.x.110]
* 
* 为了计算耦合矩阵，我们使用[2.x.260]工具，其工作原理与[2.x.261]类似。
* 

* 
* [1.x.111]
* 
* [1.x.112] [1.x.113]。  
* 所有的部分都已经组装好了：我们用舒尔补数法解决这个系统
* 

* 
* [1.x.114]
* 
* 从创建反刚度矩阵开始
* 

* 
* [1.x.115]
* 
* 初始化运算符，如介绍中所述
* 

* 
* [1.x.116]
* 
* 使用舒尔补数法
* 

* 
* [1.x.117]
* 
* 下面的函数只是在两个独立的文件上生成标准结果输出，每个网格一个。
* 

* 
* [1.x.118]
* 
* 这两个输出例程的唯一区别是，在第二种情况下，我们要输出当前配置的数据，而不是参考配置的数据。这可以通过将实际的embedded_mapping传递给[2.x.262]函数来实现。该映射将负责在实际变形的配置上输出结果。
* 

* 
*  

* 
* [1.x.119]
* 
* 与所有其他教程程序类似，`run()`函数只是按正确的顺序调用所有其他方法。没有什么特别需要注意的，只是在我们实际尝试运行我们的程序之前，我们检查是否完成了解析。
* 

* 
* [1.x.120]
* 
* 与其他教程程序中的情况不同，这里我们使用ParameterAcceptor风格的初始化，即首先构建所有对象，然后对静态方法[2.x.263]发出一次调用，以填充从ParameterAcceptor派生的类的所有参数。      
* 我们检查用户是否在程序启动时指定了一个参数文件名来使用。如果是，就尝试读取该参数文件，否则就尝试读取文件 "parameters.prm"。      
* 如果指定的参数文件（隐含的或明确的）不存在，[2.x.264]将为你创建一个，并退出程序。
* 

* 
*  

* 
* [1.x.121]
* [1.x.122][1.x.123] 。
* 

* 运行这个程序的目录中默认不包含参数文件。另一方面，这个程序想从一个叫做parameters.prm的文件中读取它的参数。
* 
* 因此，当你第一次执行它时，你会得到一个异常，即找不到这样的文件。
* [1.x.124]
* 
* 然而，正如错误信息已经指出的那样，触发该异常的代码也将生成一个参数.prm文件，该文件只包含该程序所关心的所有参数的默认值。通过检查参数文件，我们看到以下内容。
* [1.x.125]
* 
* 如果你现在运行这个程序，你会得到一个叫做`used_parameters.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行程序的参数。
* [1.x.126]
* 
* 首先创建`parameters.prm`文件(程序第一次运行)，然后创建`used_parameters.prm`(每隔一段时间运行程序)，其理由是你可能想让大多数参数保持其默认值，而只修改其中一小部分。
* 例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。
* [1.x.127]
* 
* 你会得到与下面测试案例1完全相同的结果。
* [1.x.128][1.x.129] 。
* 

* 对于默认问题，[2.x.265]在[2.x.266]上的值被设置为常数[2.x.267]：这就像在[2.x.268]上施加一个常数迪里切特边界条件，被视为[2.x.269]在[2.x.270]内的部分的边界。同样，在[2.x.271]上我们有零迪里切特边界条件。
* 

* [2.x.272] 
* 程序的输出将看起来像下面这样。
* [1.x.130]
* 
* 你可能会注意到，就CPU时间而言，组装耦合系统的成本是组装标准泊松系统的两倍，尽管矩阵更小。这是由于离散化的非匹配性质造成的。这是否可以接受，取决于应用。
* 如果问题被设置在三维环境中，并且浸入式网格与时间有关，那么在每一步重新创建网格要比使用我们这里介绍的技术要昂贵得多。此外，你也许可以在一个均匀细化的正方形或立方体网格上创建一个非常快速和优化的求解器，并在你想进行计算的领域嵌入这里的技术。这就要求你只拥有你的领域的表面代表（一个更便宜和更容易制作的网格）。
* 为了玩一玩，我们要把虚构的领域以及我们施加在它上面的边界条件复杂化一点。
* [1.x.131][1.x.132] 。
* 

* 如果我们使用下面的参数文件。
* [1.x.133]
* 
* 我们得到一个看起来 "花花绿绿 "的域，在这里我们施加一个线性边界条件 [2.x.273] 。这个测试表明，该方法在从其边界条件中恢复一个完全线性的函数方面实际上是相当准确的，即使网格没有对齐，我们也得到了一个相当好的结果。
* 用[2.x.275]替换[2.x.274]，即修改参数文件，以便我们有
* [1.x.134]
* 产生右边的马鞍。
* [2.x.276] 
* [1.x.135][1.x.136][1.x.137] 。
 

* [1.x.138][1.x.139] 。
 

* 虽然目前的教程程序是为 "spacedim "等于2而编写的，但为了使程序能够在不同的尺寸组合中运行，你只需要做一些小的改动。
* 如果你想在 "spacedim "等于3，"dim "等于2的情况下运行，你几乎肯定要做以下改变。
* 
* - 为嵌入式网格使用不同的参考域，也许是从文件中读取。不可能用一个正方形域的单一参数来构造一个光滑的封闭表面，因此你很可能想用一个拓扑学上等同于球体边界的参考域。
* 
* - 使用位移而不是变形来将[2.x.277]映射到[2.x.278]。
* [1.x.140][1.x.141]。
* 

* 我们已经在其他教程中看到（例如在[2.x.279]和[2.x.280]）如何从输入文件中读取网格。这个教程程序的一个很好的概括是允许用户从参数文件中选择要读取的网格，而不是在教程程序本身硬编码网格类型。
* [1.x.142][1.x.143] 。
* 

* 目前，我们没有关于Schur补数的预处理程序。这在二维问题上是可以的，几百次的迭代就可以把残差降到机器的精度，但是在三维问题上就不可行了。
* 在这里，好的预处理程序是什么并不明显。我们用舒尔补码解决的物理问题是将迪里切特数据[2.x.281]与拉格朗日乘数[2.x.282]的值联系起来。 [2.x.283]可以解释为法线梯度的跳跃*，需要强加在[2.x.284]和[2.x.285]之间，以获得Dirichlet数据[2.x.286]。
* 所以[2.x.287]是某种诺伊曼到迪里切特的地图，我们希望有一个迪里切特到诺伊曼地图的良好近似。一个可能性是使用[2.x.288]上的问题的边界元素近似，并构建一个与[2.x.289]相关的泊松问题的超星形算子的近似，这正是一个迪里切特到诺依曼的映射。
*[1.x.144][1.x.145]
* 

* 这里提出的简单代码可以作为更复杂问题的起点，要解决这些问题，需要在并行代码上运行，可能使用分布式网格（见[2.x.290]，[2.x.291]，以及[2.x.292]和[2.x.293]的文档）。
* 当并行使用非匹配网格时，会出现一个问题：为了计算矩阵[2.x.294]，一个进程需要关于真实空间同一区域的两个网格的信息，但是，当使用分布式网格时，这种信息可能无法获得，因为存储在特定处理器上的[2.x.295]三角测量的本地拥有部分可能与存储在同一处理器上的[2.x.296]三角测量的本地拥有部分不在同一位置上。
* 可以实施各种策略来解决这个问题。
* 
* - 分布两个网格，以便满足这个约束条件。
* 
* - 对不满足该约束的实空间部分使用通信。
* 
* - 对嵌入空间使用分布式三角法，对模拟配置使用共享三角法。
* 后一种策略显然是最容易实现的，因为本教程程序中使用的大多数函数在并行情况下也会不变地工作。当然，我们可以使用反转策略（即有一个分布式嵌入式三角函数和一个共享的嵌入三角函数）。
* 然而，这种策略很可能会更加昂贵，因为根据定义，嵌入网格要比嵌入网格大，而且分布两个网格中最大的网格更有意义，保持所有处理器之间共享的小石块。
* 

* [1.x.146][1.x.147][2.x.297] 
* [0.x.1]

