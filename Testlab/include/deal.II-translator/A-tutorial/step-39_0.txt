include/deal.II-translator/A-tutorial/step-39_0.txt
[0.x.0]*
 [2.x.0]
* 本教程取决于[2.x.1] b.
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9]
* [1.x.10]
* 在这个程序中，我们使用内部惩罚法和Nitsche的弱边界条件来解决Poisson方程。我们在局部细化的网格上使用多网格方法，这些网格是用一个bulkcriterion和一个基于单元和面的标准误差估计器生成的。所有的操作都是通过MeshWorker接口实现的。
* 与[2.x.2]一样，离散化依赖于有限元空间，其在网格单元内是多项式的[2.x.3]，但在单元之间没有连续性。由于这种函数在每个内部面[2.x.4]上有两个值，每边一个，我们定义均值和跳跃算子如下：让[1.x.11]<sub>1</sub>和[1.x.12]<sub>2</sub>为两个单元，并让函数的轨迹[1.x.13]和外层法向量[1.x.14][1.x.15] 被相应地标记为。然后，在这个面上，我们让[1.x.16]。
* 注意，如果这样的表达式包含一个法向量，平均运算符就会变成一个跳跃。对问题[1.x.17]的内部惩罚方法变成[1.x.18] 。
*
* 这里，[2.x.5]是惩罚参数，选择如下：对于单元格[1.x.20]的一个面[1.x.19]，计算值[1.x.21]，其中[1.x.22]是有限元函数的多项式程度，[2.x.6]和[2.x.7]表示相应对象的[2.x.8]和[2.x.9]维的豪斯多尔夫度。如果该面位于边界，则选择[2.x.10] .对于内部面，我们取该面的两个值的平均值。
* 在我们的有限元程序中，我们区分了三个不同的积分，分别对应于上面的单元格、内部面和边界面的总和。由于[2.x.11]为我们组织了和，我们只需要实现每个网格元素的积分。下面的MatrixIntegrator类有这三个函数用于公式的左边，RHSIntegrator类用于右边。
* 正如我们将在下面看到的，即使是误差估计也是相同结构的，因为它可以写成
* [1.x.23]
*
* 因此，下面用于组装矩阵、右手边和误差估计的函数表明，这些循环都是通用的，可以用同样的方式进行编程。
* 这个程序与[2.x.12] b有关，因为它使用MeshWorker和非连续Galerkin方法。在那里，我们解决的是一个平流问题，而这里是一个扩散问题。在这里，我们还使用了多网格预处理和一个理论上合理的误差估计器，见Karakashian和Pascal(2003)。Kanschat(2004)详细讨论了多层次方案。Hoppe, Kanschat和Warburton (2009)讨论了自适应迭代及其收敛性（对于三角形网格）。
*

* [1.x.24] [1.x.25]。
* 线性代数的包含文件。一个普通的SparseMatrix，它又将包括SparsityPattern和Vector类的必要文件。
*


* [1.x.26]
*
*包括用于设置网格的文件
*


* [1.x.27]
*
* FiniteElement类和DoFHandler的包含文件。
*


* [1.x.28]
*
* 使用MeshWorker框架的包含文件
*


* [1.x.29]
*
*与拉普拉斯相关的局部积分器的包含文件
*


* [1.x.30]
*
* 支持多棱镜方法
*


* [1.x.31]
*
* 最后，我们从库中取出我们的精确解，以及正交和附加工具。
*


* [1.x.32]
*
* deal.II库的所有类都在dealii命名空间中。为了节省打字，我们告诉编译器也要在那里搜索名字。
*


* [1.x.33]
*
* 这是我们用来设置边界值的函数，也是我们比较的精确解。
*


* [1.x.34]
*
* [1.x.35] [1.x.36]。


*
* MeshWorker将局部积分与单元格和面的循环分离开来。因此，我们必须编写局部积分类来生成矩阵、右手边和误差估计器。
*

*
* 所有这些类都有相同的三个函数，分别用于在单元格、边界面和内部面的积分。局部积分所需的所有信息都是由[2.x.13]提供的。请注意，这些函数的签名不能被改变，因为它是由[2.x.14]预期的。
*

*
* 定义局部积分器的第一类负责计算单元和面矩阵。它被用来组装全局矩阵以及水平矩阵。
*


* [1.x.37]
*
* 在每个单元上，我们对Dirichlet形式进行积分。我们使用LocalIntegrators中的现成积分库来避免自己编写这些循环。同样地，我们实现了Nitsche边界条件和单元间的内部惩罚通量。   
* 边界和通量项需要一个惩罚参数，这个参数应该根据单元的大小和多项式的度数来调整。在[2.x.15]中可以找到这个参数对常数系数的安全选择，我们在下面使用这个参数。
*


* [1.x.38]
*
* 内部面使用内部惩罚方法
*


* [1.x.39]
*
* 第二个局部积分器建立了右手边。在我们的例子中，右手边的函数是零，这样，这里只设置了弱形式的边界条件。
*


* [1.x.40]
*
* 第三个局部积分器负责对误差估计的贡献。这是由Karakashian和Pascal (2003)提出的标准能量估计器。
*


* [1.x.41]
*
* 单元贡献是离散解的拉普拉斯，因为右手边是零。
*


* [1.x.42]
*
* 在边界，我们简单地使用边界残差的加权形式，即有限元解和正确边界条件之间的差值的规范。
*


* [1.x.43]
*
* 最后，在内部面，估计器由解的跳跃和它的法向导数组成，适当加权。
*


* [1.x.44]
*
* 最后我们有一个误差的积分器。由于不连续Galerkin问题的能量准则不仅涉及到单元内部的梯度差，而且还涉及到跨面和边界的跳跃项，所以我们不能仅仅使用[2.x.16] 而是使用MeshWorker接口来计算误差。
*

*
* 有几种不同的方法来定义这个能量准则，但是所有的方法都是随着网格大小的变化而等价的（有些不是随着多项式程度的变化而等价）。这里，我们选择[1.x.45]。
*


*


* [1.x.46]

* 这里我们有单元格上的积分。目前MeshWorker中还没有一个很好的接口可以让我们访问正交点的正规函数的值。因此，我们必须在单元格积分器中为精确的函数值和梯度创建向量。之后，一切照旧，我们只需将差值的平方加起来。
*

*
* 除了计算能量准则的误差，我们还利用网格工作者的能力，在同一时间计算两个函数，并在同一循环中计算[1.x.47]的误差。很明显，这个函数没有任何跳跃项，只出现在单元格的积分中。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* 这个类做主要的工作，就像前面的例子一样。关于这里声明的函数的描述，请参考下面的实现。
*


* [1.x.51]
*
* 与离散化有关的成员对象在此。
*


* [1.x.52]

* 然后，我们有与全局离散系统有关的矩阵和向量。
*


* [1.x.53]
*
* 最后，我们有一组与多级预处理程序有关的稀疏模式和稀疏矩阵。  首先，我们有一个水平矩阵和它的稀疏性模式。
*


* [1.x.54]
*
* 当我们在局部细化的网格上进行局部平滑的多重网格时，需要额外的矩阵；见Kanschat（2004）。这里是这些边缘矩阵的稀疏性模式。我们只需要一个，因为上矩阵的模式是下矩阵的转置。实际上，我们并不太关心这些细节，因为MeshWorker正在填充这些矩阵。
*


* [1.x.55]
*
*细化边缘的通量矩阵，将细级自由度与粗级自由度耦合。
*


* [1.x.56]
*
*细化边缘的通量矩阵的转置，将粗级自由度耦合到细级。
*


* [1.x.57]
*
*构造函数简单地设置了粗略的网格和DoFHandler。FiniteElement作为一个参数被提供，以实现灵活性。
*


* [1.x.58]
*
* 在这个函数中，我们设置了线性系统的维度和全局矩阵以及水平矩阵的稀疏性模式。
*


* [1.x.59]

* 首先，我们使用有限元将自由度分布在网格上并对其进行编号。
*


* [1.x.60]

* 然后，我们已经知道代表有限元函数的向量的大小。
*


* [1.x.61]
*
* 接下来，我们为全局矩阵设置稀疏性模式。由于我们事先不知道行的大小，所以我们首先填充一个临时的DynamicSparsityPattern对象，一旦完成，就把它复制到常规的SparsityPattern中。
*


* [1.x.62]
*
* 全局系统已经设置好了，现在我们来处理关卡矩阵。我们调整所有矩阵对象的大小，以便每一级都有一个矩阵。
*


* [1.x.63]
*
* 在为水平矩阵调用<tt>clear()</tt>之后，更新稀疏模式非常重要，因为矩阵通过SmartPointer和Subscriptor机制锁定了稀疏模式。
*


* [1.x.64]
*
* 现在所有的对象都准备好了，每一层都有一个稀疏模式或矩阵。剩下的就是在每个层次上设置稀疏模式了。
*


* [1.x.65]
*
* 这些是与上面的全局矩阵大致相同的行，现在是针对每个级别。
*


* [1.x.66]
*
* 此外，我们需要初始化各级之间细化边缘的转移矩阵。它们被存储在指代两个索引中较细的索引处，因此在0层没有这样的对象。
*


* [1.x.67]
*
* 在这个函数中，我们组装全局系统矩阵，这里的全局是指我们解决的离散系统的矩阵，它覆盖了整个网格。
*


* [1.x.68]

* 首先，我们需要设置提供我们集成值的对象。这个对象包含所有需要的FEValues和FEFaceValues对象，并且自动维护它们，使它们总是指向当前的单元。为此，我们首先需要告诉它，在哪里计算，计算什么。由于我们没有做任何花哨的事情，我们可以依靠他们对正交规则的标准选择。     
* 由于他们的默认更新标志是最小的，我们额外添加我们需要的东西，即所有对象（单元、边界和内部面）上的形状函数的值和梯度。之后，我们准备初始化容器，它将创建所有必要的FEValuesBase对象进行整合。
*


* [1.x.69]

* 这是我们整合本地数据的对象。它由MatrixIntegrator中的局部整合例程填充，然后由汇编者用来将信息分配到全局矩阵中。
*


* [1.x.70]
*
* 此外，我们需要一个将局部矩阵组装成全局矩阵的对象。这些装配对象拥有目标对象结构的所有知识，在这种情况下是一个稀疏矩阵，可能的约束和网格结构。
*


* [1.x.71]
*
* 现在是我们自己编码的部分，局部积分器。这是唯一与问题有关的部分。
*


* [1.x.72]

* 现在，我们把所有东西都扔到[2.x.17]中，这里遍历网格的所有活动单元，计算单元和面的矩阵，并把它们集合到全局矩阵中。我们在这里使用变量<tt>dof_handler</tt>，以便使用全局自由度的编号。
*


* [1.x.73]
*
* 现在，我们对水平矩阵做同样的处理。不太令人惊讶的是，这个函数看起来像前一个函数的孪生兄弟。事实上，只有两个小的区别。
*


* [1.x.74]
*
* 很明显，汇编器需要被一个填充水平矩阵的汇编器所取代。请注意，它也会自动填充边缘矩阵。
*


* [1.x.75]
*
* 这里是与前一个函数的另一个区别：我们在所有的单元上运行，而不仅仅是活动单元。而且我们使用以[2.x.18]结尾的函数，因为我们需要每一层的自由度，而不是全局的编号。
*


* [1.x.76]
*
* 这里我们有另一个assemble函数的克隆。与组装系统矩阵的区别在于，我们在这里组装了一个向量。
*


* [1.x.77]
*
* 因为这个汇编器允许我们填充几个向量，所以接口要比上面复杂一些。向量的指针必须存储在一个AnyData对象中。虽然这在这里似乎造成了两行额外的代码，但实际上在更复杂的应用中它是很方便的。
*


* [1.x.78]
*
* 现在我们已经编码了建立离散线性系统的所有函数，现在是我们实际解决它的时候了。
*


* [1.x.79]
*
*选择的求解器是共轭梯度。
*


* [1.x.80]

* 现在我们正在设置多级预处理程序的组件。首先，我们需要在网格层之间进行转移。我们在这里使用的对象为这些转移生成了稀疏矩阵。
*


* [1.x.81]
*
* 然后，我们需要在最粗的层次上对矩阵进行精确求解。
*


* [1.x.82]
*
* 虽然转移和粗略的网格求解器几乎是通用的，但为平滑器提供了更多的灵活性。首先，我们选择Gauss-Seidel作为我们的平滑方法。
*


* [1.x.83]
*
* 在每个级别上做两个平滑的步骤。
*


* [1.x.84]
*
* 由于SOR方法不是对称的，但我们在下面使用共轭梯度迭代，这里有一个技巧，使多级预处理器成为对称算子，即使是对非对称平滑器。
*


* [1.x.85]
*
* 平滑器类可以选择实现变量V-cycle，我们在这里不需要。
*


* [1.x.86]
*
* 最后，我们必须将我们的矩阵包裹在一个具有所需乘法函数的对象中。
*


* [1.x.87]

* 现在，我们准备设置V型循环算子和多级预处理程序。
*


* [1.x.88]
*
* 我们不要忘记因为自适应细化而需要的边缘矩阵。
*


* [1.x.89]
*
* 在所有的准备工作完成后，将Multigrid对象包装成另一个对象，它可以作为一个普通的预处理程序使用。
*


* [1.x.90]

* 并用它来解决这个系统。
*


* [1.x.91]
*
* 另一个克隆的assemble函数。与之前的最大区别是，这里我们也有一个输入向量。
*


* [1.x.92]
*
* 估计器的结果存储在一个向量中，每个单元格有一个条目。由于deal.II中的单元格没有编号，我们必须建立自己的编号，以便使用这个向量。对于下面使用的汇编器来说，结果存储在向量的哪个分量中的信息是由每个单元的user_index变量传送的。我们需要在这里设置这个编号。     
* 另一方面，有人可能已经使用了用户索引。所以，让我们做个好公民，在篡改它们之前保存它们。
*


* [1.x.93]
*
*这和以前一样开始。
*


* [1.x.94]
*
* 但现在我们需要通知信息框我们要在正交点上评估的有限元函数。首先，我们用这个向量创建一个AnyData对象，这个向量就是我们刚刚计算的解。
*


* [1.x.95]
*
* 然后，我们告诉单元格的[2.x.19]，我们需要这个解决方案的第二导数（以计算拉普拉斯）。因此，选择函数值和第一导数的布尔参数是假的，只有选择第二导数的最后一个参数是真的。
*


* [1.x.96]
*
* 在内部和边界面，我们需要函数值和第一导数，但不需要第二导数。
*


* [1.x.97]
*
* 我们继续像以前一样，除了默认的更新标志已经被调整为我们上面要求的值和导数之外。
*


* [1.x.98]
*
* 汇编器在每个单元格中存储一个数字，否则这就与右手边的计算相同。
*


* [1.x.99]
*
* 就在我们返回错误估计的结果之前，我们恢复了旧的用户索引。
*


* [1.x.100]
*
* 这里我们将我们的有限元解与（已知的）精确解进行比较，并计算梯度和函数本身的平均二次方误差。这个函数是上面那个估计函数的克隆。
*

*
* 因为我们分别计算了能量和[1.x.101]-norm的误差，所以我们的块向量在这里需要两个块。
*


* [1.x.102]
*
* 创建图形输出。我们通过整理其各个组成部分的名称来产生文件名，包括我们用两个数字输出的细化周期。
*


* [1.x.103]
*
* 最后是自适应循环，或多或少和前面的例子一样。
*


* [1.x.104]
* [1.x.105][1.x.106] 。


* [1.x.107][1.x.108] 。
* 首先，该程序产生通常的日志文件，在这里存储在<tt>deallog</tt>。它的内容是（省略了中间的步骤
* [1.x.109]
*
* 例如，这个日志显示共轭梯度迭代步骤的数量恒定在大约15个。
* [1.x.110][1.x.111] 。
*

* [2.x.20] 使用perl脚本<tt>postprocess.pl</tt>，我们提取相关数据到<tt>output.dat</tt>中，可以用<tt>gnuplot</tt>绘制图形。例如，上面的图是用gnuplot脚本<tt>plot_errors.gpl</tt>通过以下方式制作的
* [1.x.112]
*
* 参考数据可以在<tt>output.reference.dat</tt>中找到。
*

* [1.x.113][1.x.114] [2.x.21] 。
* [0.x.1]

