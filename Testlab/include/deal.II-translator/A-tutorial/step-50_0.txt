include/deal.II-translator/A-tutorial/step-50_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
* [2.x.3]
* [1.x.28]
* [2.x.4]
* [2.x.5] 作为这个程序的先决条件，你需要同时安装p4est和PETScor Trilinos库。在[1.x.29]文件中描述了deal.II和这些附加库的安装情况。
*

*[1.x.30][1.x.31][1.x.32]


*
* 这个例子展示了deal.II中的多级函数在平行分布式网格上的应用，并给出了几何多栅和代数多栅方法的比较。考虑了两种几何多网格(GMG)的预处理方法：一种是类似于[2.x.7]中的基于矩阵的版本（但用于并行计算），另一种是[2.x.8]中讨论的无矩阵版本。我们的目标是找出哪种方法能够为大型并行计算提供最好的解算器。
* 本教程是基于 [2.x.9] 中的一个数值例子。请参阅该出版物，以了解交易.II中多网格实现的详细背景。我们将在下面的文字中总结一些结果。
* 代数多网格方法显然是最容易用deal.II实现的，因为诸如[2.x.10]和[2.x.11]这样的类本质上是黑布尔调节器，即使对于并行计算，也只需要几行就可以设置好。另一方面，几何多网格方法需要对整个代码库进行修改
*
* - 不是非常多，但必须知道自己在做什么。
* 本程序的结果将显示，代数和几何多网格方法的性能大致相当[1.x.33]，而无矩阵的几何多网格方法对于这里所考虑的问题来说要好得多。次要的结论是，当每个处理器的未知数小于20,000个时，基于矩阵的几何多网格方法确实不能很好地扩展。
*

*[1.x.34][1.x.35]


* 我们考虑变系数拉普拉斯的弱表述
* [1.x.36]
*在域[2.x.12]（二维为L形域，三维为Fichera角）上，如果[2.x.14]，则为[2.x.15]。换句话说，[2.x.16]是沿着域的边缘或面的小的，这些边缘或面跑到再入角，在下面的图中会看到。
* 边界条件在整个边界上是[2.x.17]，右手边是[2.x.18]。我们使用连续的[2.x.19]元素来表示离散的有限元空间[2.x.20]，并使用来自[2.x.22]的基于单元的后验误差估计器[2.x.21]。
* [1.x.37]
* 适应性地细化网格。(这是KellyErrorEstimator类中使用的Kellyerror估计器的一般化，KellyErrorEstimator类在大多数其他教程程序中驱动网格细化。)下图是2D的解决方案和细化的可视化： [2.x.23] 在3D中，解决方案看起来类似(见下文)。在左边你可以看到解决方案，在右边我们展示了靠近域中心的[2.x.24]的切片，显示了自适应细化的网格。[2.x.25]在二维和三维中，你都可以看到自适应细化拾取了角部奇点和粘度跳跃的内部奇点，而沿着分离两个粘度的线的界面（正确）没有被细化，因为它被充分解决了。
*

*[1.x.38][1.x.39]


* 如上所述，这个程序的目的是展示代数和几何多网格方法在这个问题上的应用，并且是在并行计算中的应用。使算法扩展到大型并行机器的一个重要组成部分是确保每个处理器都有相同的工作量要做。更确切地说，重要的是没有一小部分处理器比其他处理器有更多的工作，因为如果是这样的话，很大一部分处理器将闲置，等待一小部分处理器完成工作。相反，一小部分处理器拥有大量[1.x.40]的工作并不是一个问题，因为大多数处理器会继续生产，只有一小部分处理器在完成工作后会闲置。)
* 对于活跃的网格，我们使用[2.x.26]类，正如在[2.x.27]中所做的那样，它使用外部库[1.x.41]中的功能来分配活跃单元在处理器之间。对于多级层次结构中的非活动单元，deal.II实现了我们所说的 "第一子规则"，对于层次结构中的每个单元，我们递归地将一个单元的父级分配给第一个子单元的所有者。下面的图给出了这样一个分布的例子。左图表示使用空间填充曲线划分的二维网格样本的活动单元（这也是p4est用来划分单元的方法）；中图给出活动网格的树状表示；右图给出单元的多级层次。颜色和数字代表不同的处理器。树状图中的圆形节点是非活动单元，使用 "长子规则 "进行分配。
* [2.x.28]
* 在这个例子中，屏幕上的输出包括一个 "分区效率 "的数值，这个数值由[2.x.29]表示，用[2.x.30]来量化在多网格层次结构的每一层上没有完美工作平衡所产生的开销。这种不平衡在上面的例子中很明显：虽然[2.x.31]层在三个处理器的四个单元中尽可能的平衡，但粗略的[2.x.32]层只有一个处理器的工作，而[2.x.33]层只有两个处理器的工作，其中一个的工作是另一个的三倍。
* 对于定义[2.x.34]，需要注意的是，由于我们使用局部平滑来定义多网格层次（见[2.x.35]"多网格论文 "中对局部平滑的描述），一个单元的细化水平与该单元的多网格水平相对应。现在，让[2.x.36]为[2.x.37]层的单元数（包括活动和非活动单元），[2.x.38]为进程[2.x.39]所拥有的子集。我们还将用[2.x.40]表示处理器的总数。假设任何一个处理器的工作量与该处理器拥有的单元格数量成正比，每个处理器的最佳工作量为
* [1.x.42]
* 接下来，假设每一层的工作都是同步的（即在V型循环的每一层，在进入下一层之前，所有的处理器都必须完成工作），每一层的极限工作由以下公式给出
* [1.x.43]
*而总的并行复杂度
* [1.x.44]
* 然后我们将[2.x.41]定义为最佳分区与当前分区的并行复杂度的比率
* [1.x.45]
* 对于上面的例子分布，我们有
* [1.x.46]
*该值 [2.x.42] 1/mathbb{E}。[2.x.43] `mathbb{E}的价值[2.x.44] `mathbb{E}。\约1 [2.x.45] Mathematbb{E}。[2.x.46] 1/2.x.x.[2.x.47] 1/mathbb{E]。[2.x.48] W_\ell [2.x.49] W [2.x.50] r_0 = f-Au_0 [2.x.51] u_0 [2.x.52] u = u_0 + A^{-1}r_0 [2.x.53] u_0 [2.x.54] A^{-1}r_0 [2.x.55] u_0 [2.x.56] A [2.x.57] u_0 [2.x.58] f [2.x.59] u_0 [2.x.60] h^2 \| f + \epsilon \triangle u \|_K^2 [2.x.61] \sum_F h_F \| jump{\epsilon \nabla u \cdot n}.\|2.x.62] 矩阵{E}。[2.x.63] 0.371/0.161=2.3 [2.x.64] `mathbb{E}.[2.x.65] {cal O}(N\log N) [2.x.66] {cal O}(N) [2.x.67] 9\times 9 [2.x.68] 27\times 27 [2.x.69] L [2.x.70] 21\times 21 [2.x.71] 117\times 117$ in 3d.但是，如果粗网格由数百或数千个单元组成，这种方法将不再起作用，并可能开始主导每个V-cyle的整体运行时间。一个常见的方法是使用代数多网格预处理器解决粗网格问题；然而，这将需要组装粗矩阵（即使是无矩阵版本）作为AMG实现的输入。
*

*[1.x.134][1.x.135] [2.x.72]
* [0.x.1]

