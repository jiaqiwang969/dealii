include/deal.II-translator/A-tutorial/step-45_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6]
* [2.x.2] 
* [1.x.7][1.x.8][1.x.9][1.x.10]
 

* 在这个例子中，我们介绍了如何使用周期性边界条件indeal.II。周期性边界条件是代数约束，通常出现在一个大域的代表性区域的计算中，这些区域在一个或多个方向上重复。
* 一个例子是模拟光子晶体的电子结构，因为它们有一个类似格子的结构，因此，往往只需要在格子的一个盒子上进行实际计算就可以了。为了能够以这种方式进行，我们必须假设该模型可以周期性地扩展到其他盒子；这就要求解决方案具有周期性结构。
*[1.x.11][1.x.12][1.x.13]
* 

* 应用周期性边界条件的一般方法包括三个步骤（参见[2.x.3]"关于周期性边界条件的词汇"）。
* 
* - 创建一个网格
* 
* - 使用[2.x.4]确定边界不同部分的一对面，在这些面上的解应该是对称的。
* 
* - 使用[2.x.5]将周期性信息添加到网格中。
* 
* - 使用[2.x.6]添加周期性约束。
* 第二和第三步对于使用[2.x.7]类的平行网格是必要的，以确保位于域的对面但由周期性面连接的单元是幽灵层的一部分，如果其中一个单元被存储在本地处理器上的话。
* 第一步包括收集匹配的周期性面，并将它们存储在[2.x.10]的[2.x.9]中，这是通过函数[2.x.11]完成的，例如可以这样调用。
* [1.x.14]
* 
* 这个调用在容器dof_handler的所有面中循环进行，周期性边界的边界指标分别为[2.x.12]和[2.x.13]。(你可以在创建粗略的网格后手工指定这些边界指标，见[2.x.14] "边界指标"。另外，如果你指定了 "colorize "标志，你也可以让GridGenerator命名空间中的许多函数来做这件事；在这种情况下，这些函数会给边界的不同部分分配不同的边界指标，细节通常在这些函数的文档中详细说明）。)
* 具体来说，如果[2.x.15]是两个面[2.x.16]的顶点，那么上面的函数调用将匹配成对的面（和道夫），使得[2.x.17]和[2.x.18]之间的差异除了方向之外在每个分量上都消失，并将产生的对与相关数据存储在[2.x.19]中（关于匹配过程的详细信息见[2.x.20]。
* 例如，考虑彩色单元格[2.x.21]，其边界指示器0在左边，1在右边，2在下面，3在上面。见[2.x.22]的文件，了解这个关于如何分配边界指标的公约）。然后。
* [1.x.15]
* 将产生周期性约束，从而使[2.x.23]对所有[2.x.24]。
* 如果我们考虑由[2.x.25], [2.x.26], [2.x.27], [2.x.28]的凸壳给出的平行四边形，我们可以通过指定一个[2.x.30]来实现约束[2.x.29] 。
* [1.x.16]
*或
* [1.x.17]
*这里，同样，边界指标0和1的分配源于[2.x.31]的文件。
* 由此产生的[2.x.32]可以用在[2.x.33]中，用于用周期性约束填充AffineConstraintsobject。
* [1.x.18]
* 
* 除了这个高级接口外，还有一些[2.x.34]的变体可以结合这两个步骤（见[2.x.35]的变体）。
* 如果需要更多的灵活性，还有一个[2.x.36]的低层次接口。低级变体允许直接指定两个应被约束的面。
* [1.x.19]
* 这里，我们需要使用[2.x.37][2.x.38]和[2.x.39]来指定两个面的方向。 关于更详细的描述，请看[2.x.40]的文档。除了自我解释的[2.x.41]和[2.x.42]之外，其余参数与高级接口相同。
 

* [1.x.20][1.x.21][1.x.22] 。
* 

* 在下文中，我们将展示如何在一个更复杂的例子中使用上述函数。任务是对斯托克斯流的速度分量实施旋转的周期性约束。
* 在一个由[2.x.43]定义的四分之一圆上，我们要解决斯托克斯问题[1.x.23] 。
* 边界[2.x.44]定义为[2.x.45]。对于边界的其余部分，我们将使用周期性边界条件，即
* [1.x.24]
* 
* 网格将由[2.x.46]生成，它也记录了如果它的`colorize'参数设置为`true'，它如何给它的各个边界分配边界指标。
* 

* [1.x.25] [1.x.26]。
* 这个例子程序是对[2.x.47]的轻微修改，使用Trilinos并行运行，以演示在deal.II中使用周期性边界条件。因此我们不讨论大部分的源代码，只对处理周期性约束的部分进行评论。其余的请看[2.x.48]和底部的完整源代码。
* 

* 
* 为了实现周期性边界条件，只有两个函数需要修改。
 

 
* 
* - [2.x.49] : 要用周期性约束来填充AffineConstraints对象
* 

* 
* 
* - [2.x.50] : 为一个分布式三角形提供周期性信息。
* 

* 
* 程序的其余部分与[2.x.51]相同，所以让我们跳过这部分，只在下文中展示这两个函数。(不过，完整的程序可以在下面的 "普通程序 "部分找到)。
* 

* 
*  
*     
*  
* [1.x.27] [1.x.28]。
 

 
* [1.x.29]
* 
* 在我们能够规定周期性约束之前，我们需要确保位于域的对面但由周期性面连接的单元是幽灵层的一部分，如果其中一个单元存储在本地处理器上。在这一点上，我们需要考虑我们要如何规定周期性。左边边界上的面的顶点[2.x.52]应该与下边边界上的面的顶点[2.x.53]相匹配，由[2.x.54]给出，其中旋转矩阵[2.x.55]和偏移量[2.x.56]由以下公式给出

* 
* [1.x.30]
* 我们要把得到的信息保存到这里的数据结构是基于三角法的。
* 

* 
* [1.x.31]
* 
* 现在只要调用[2.x.57]就可以告诉三角法所需的周期性，特别容易。
* 

* 
* [1.x.32]
* 
* 在我们为网格提供了周期性约束的必要信息之后，我们现在就可以实际创建它们了。对于描述匹配，我们使用与之前相同的方法，也就是说，左边边界上的一个面的[2.x.58]应该与下面边界上的一个面的顶点[2.x.59]相匹配，这些顶点的旋转矩阵[2.x.61]和偏移量[2.x.62]是由以下公式给出的

* 
* [1.x.33]
* 这两个对象不仅描述了面应该如何匹配，而且还描述了解决方案应该从[2.x.63]转换到[2.x.64]的哪个意义上。
* 

* 
* [1.x.34]
* 
* 为了设置约束，我们首先将周期性信息存储在一个类型为[2.x.65] [2.x.66] </code>的辅助对象中。周期性边界的边界指标为2（x=0）和3（y=0）。所有其他的参数我们之前已经设置好了。在这种情况下，方向并不重要。由于[2.x.67]这正是我们想要的。
* 

* 
* [1.x.35]
* 
* 接下来，我们需要提供关于解的哪些矢量值分量应该被旋转的信息。由于我们在这里选择只约束速度，而且是从解向量的第一个分量开始的，所以我们只需插入一个0。
* 

* 
* [1.x.36]
* 
* 在周期性_vector中设置了所有的信息后，我们要做的就是告诉make_periodicity_constraints来创建所需的约束。
* 

* 
* [1.x.37]
* 
* 然后程序的其余部分又与[2.x.68]相同。我们现在省略它，但和以前一样，你可以在下面的 "普通程序 "部分找到这些部分。
* 

* 
* [1.x.38][1.x.39] 。
* 

* 创建的输出并不十分令人惊讶。我们只是看到，相对于左边界和下边界，解是周期性的。
* [2.x.69] 
* 如果没有周期性约束，我们最终会得到以下的解决方案。
* [2.x.70] 
* 

* [1.x.40][1.x.41] [2.x.71] 。
* [0.x.1]

