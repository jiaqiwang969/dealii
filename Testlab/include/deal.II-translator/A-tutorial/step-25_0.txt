include/deal.II-translator/A-tutorial/step-25_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13 ][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26]
*[1.x.27][1.x.28][1.x.29] 。
 

* 这个程序是由Ivan Christov在Texas A&amp;MUniversity的一个学生项目发展而来的。这个程序的大部分工作是由他完成的。
* 这个程序的目标是解决1、2或3空间维度的正弦戈登孤子方程。解决这个方程的动机是对二维和三维的解决方案的性质知之甚少，尽管一维的情况已经被广泛地研究。
* 正弦戈登方程的名称是对所谓的克莱因-戈登方程的双关语，克莱因-戈登方程是对质量为非零的粒子的薛定谔方程的相对论版本。这种相似性不仅仅是表面的，正弦-戈登方程已经被证明可以模拟一些统一的场现象，如亚原子粒子的相互作用（见，例如，Perring &amp; Skyrme in Nuclear %Physics [1.x.30 此外，从数学的角度来看，由于正弦戈登方程是 "完全不可积分的"，它是使用反散射变换等通常方法进行研究的候选者。因此，多年来，人们发现了许多有趣的静止波，甚至是静止的正弦戈登方程的解。在这些解中，粒子对应于局部特征。关于正弦戈登方程、反散射变换和其他寻找分析性索利通方程的方法的更多信息，读者应参考以下关于该主题的 "经典 "参考资料。G. L. Lamb的[1.x.32]（第5章，第2节）和G. B. Whitham的[1.x.33]（第17章，10-13节）。
* [2.x.2] 我们将在[2.x.3]中介绍量子力学的一个单独的非线性方程，即非线性Schr&ouml;dinger方程。
*[1.x.34][1.x.35]
* 我们希望解决的正弦戈登初始边界值问题（IBVP）由以下方程组成：[1.x.36]这是一个类似于[2.x.4]和[2.x.5]中讨论过的波浪方程的非线性方程。然而，应该注意的是，Dirichlet边界条件并不适合这个问题。尽管正弦-戈登方程的解是局部的，但只有在[2.x.6]处指定（迪里希特）边界条件才有意义，否则，要么不存在解，要么只存在微不足道的解[2.x.7]。
* 然而，上述方程的形式对于数值离散化来说并不理想。如果我们要直接准确地离散二阶时间导数，那么我们将需要一个最大的encil（即需要在内存中保存几个时间步骤），这可能会变得很昂贵。因此，与我们在[2.x.8]和[2.x.9]中的做法完全类似，我们将二阶（时间）正弦-戈登方程分割成两个一阶（时间）方程系统，我们称之为分割或速度公式。为此，通过设置[2.x.10]，很容易看到正弦戈登方程等效于[1.x.37] 。
*[1.x.38][1.x.39] 。
* 现在，我们可以使用[2.x.11]方法对分裂公式进行时间离散，该方法的模板只有两个时间步长。通过选择[2.x.12]，后者的离散化允许我们从一系列的方案中进行选择。特别是，如果我们选择[2.x.13]或[2.x.14]，我们可以分别得到一阶精确的阐释式隐式欧拉方法。另一个重要的选择是[2.x.15]，它给出了二阶精确的Crank-Nicolson方案。因此，上标[2.x.16]表示[2.x.17]时间步长的变量值，即[2.x.18]，其中[2.x.19]为（固定）时间步长。因此，时间分解的正弦-戈登方程的分割表述为[1.x.40] 。
* 我们可以通过一点代数来简化后者。从第一个方程中排除[2.x.20]并重新排列，我们得到[1.x.41] 。
* 在这一点上，我们似乎可以直接对方程进行空间离散。虽然这对第二个方程（在[2.x.21]中是线性的）来说是正确的，但这对所有的[2.x.22]来说是不可行的，因为上面的第一个方程是非线性的。因此，必须实现一个非线性求解器，然后将方程在空间中离散化并求解。
* 为此，我们可以使用牛顿方法。给定非线性方程[2.x.23]，我们产生对[2.x.24]的连续近似值如下：[1.x.42]迭代可以用旧的时间步长初始化，即[2.x.25]，最终它将产生对分裂公式中第一个方程的解（见上文）。对于这里所考虑的sine-Gordon方程的时间离散化，我们有[1.x.43]注意，虽然[2.x.26]是一个函数，[2.x.27]是一个算子。
*[1.x.44][1.x.45]。
* 事后看来，我们选择的解决方案和测试空间都是[2.x.28]。因此，乘以测试函数[2.x.29]并进行积分，我们得到每个时间步长的分裂公式（包括第一个方程的非线性求解器）的以下变分（或弱）公式：[1.x.46]注意，我们已经使用了部分积分和涉及拉普拉斯算子的所有项的零纽曼边界条件。此外，[2.x.30]和[2.x.31]如上定义，[2.x.32]表示通常[2.x.33]对域[2.x.34]的内积，即[2.x.35]。最后，请注意，第一个方程实际上是一个迭代程序的定义，所以它在每个时间步骤中被多次解决，直到满足一个停止标准。
* [1.x.47][1.x.48] 。
* 使用有限元方法，我们在空间中离散化变分公式。为此，让[2.x.36]成为一个具有节点基础[2.x.39]的有限元空间（[2.x.38]）。现在，我们可以在弱公式中展开所有函数(见上文)与节点基的关系。此后，我们将用大写字母表示一个函数的系数向量（在节点基中），用小写字母表示；例如，[2.x.40]，其中[2.x.41]和[2.x.42] 。因此，变量公式的有限维版本要求我们在每个时间步骤中解决以下矩阵方程：[1.x.49] 。
* 以上，矩阵[2.x.43]和向量[2.x.44]表示上面讨论的小工具的离散版本，即[1.x.50]再次注意，上面的第一个矩阵方程实际上是迭代程序的定义，所以它被多次解决，直到满足停止标准。此外，[2.x.45]是质量矩阵，即[2.x.46]，[2.x.47]是拉普拉斯矩阵，即[2.x.48]，[2.x.49]是定义我们的辅助速度变量的方程中的非线性项，即[2.x.50]，[2.x.51]是[2.x.52]的雅各布矩阵的非线性项，即[2.x.53] 。
* 对于第一个方程，我们可以用什么解法？让我们来看看我们要反转的矩阵：[1.x.51]对于一些[2.x.54]，取决于现在和以前的解决方案。首先，请注意，该矩阵是对称的。此外，如果时间步长[2.x.55]足够小，也就是说，如果[2.x.56]，那么矩阵也将是正无限的。在下面的程序中，情况总是这样的，所以我们将使用共轭梯度法和SSOR法作为修饰器。然而，我们应该记住，如果我们碰巧使用更大的时间步长，这将失败。幸运的是，在这种情况下，求解器将只是抛出一个异常，表示收敛失败，而不是默默地产生一个错误的结果。如果发生这种情况，我们就可以简单地用能够处理不确定对称系统的方法来取代CG方法。GMRES求解器通常是处理所有 "坏 "线性系统的标准方法，但它也是一个缓慢的方法。更好的方法是利用对称性的求解器，例如，SymmLQ，它也是在deal.II中实现的。
* 这个程序对[2.x.57]和[2.x.58]"[2.x.59]"进行了巧妙的优化：如果你仔细阅读上述公式，就会发现，速度[2.x.60]只出现在与质量矩阵的乘积中。因此，在[2.x.61]和[2.x.62]中，我们有点浪费：在每个时间步骤中，我们将用质量矩阵求解一个线性系统，只是在下一个时间步骤中再次将该系统的解乘以[2.x.63]。当然，这可以避免，我们在这个程序中就是这样做的。
* 

*[1.x.52][1.x.53]
* 

* 正弦戈登方程有几个分析解，包括一维和二维的。特别是，该程序可以计算出一个具有单一的类似于kink的孤波初始条件的问题的解。 这个解决方案是由Leibbrandt在《物理学》（Phys.）《Rev.》《Lett.》中给出的。\b 41(7)，并在[2.x.64]类中实现。
* 应该指出的是，严格来说，这个闭式解法只对无限空间的初值问题成立（而不是这里考虑的诺伊曼初值问题）。然而，鉴于我们施加了零诺依曼边界条件，我们期望我们的初始边界值问题的解将接近无限空间初始值问题的解，如果波在我们领域边界的反射没有发生的话。在实践中，当然不是这样的，但我们至少可以假设是这样的。
* 二维解决方案中的常数[2.x.65]和[2.x.66]以及三维解决方案中的[2.x.67]、[2.x.68]和[2.x.69]被称为B&auml;cklundtransformation参数。它们控制诸如扭结的方向和深度。为了测试代码与精确解的对比，我们应该选择这些参数，使扭结与网格保持一致。
* 我们在[2.x.70]类中实现的解决方案是这些。[2.x.71] [2.x.72] 在一维中：[1.x.54] 其中我们选择[2.x.73] 。
* 在一维中，更多有趣的分析解是已知的。他们中的许多人被列在http://mathworld.wolfram.com/Sine-GordonEquation.html .
* [2.x.74] 在二维：[1.x.55] 其中[2.x.75]定义为[1.x.56]，我们选择[2.x.76] 。
* [2.x.77] 在三维中：[1.x.57] 其中[2.x.78]被定义为[1.x.58]，我们选择[2.x.79] . [2.x.80] 
* 

* 因为它使玩耍更容易，用于设置&mdash; surprise! &mdash; 我们模拟的初始值的[2.x.81]类，只是查询描述初始时值的精确解决方案的类，而不是重复努力实现解决方案的功能。
* 

* [1.x.59] [1.x.60].
* [1.x.61] [1.x.62].
* 

* 
* 关于include文件的解释，读者应参考示例程序 [2.x.82] 到 [2.x.83] 。它们按标准顺序排列，即 [2.x.84] 。
* 
* - [2.x.85] 
* 
* - [2.x.86] 
* 
* - [2.x.87] 
* 
* - [2.x.88] 
* 
* - [2.x.89]（因为这些类别中的每一个都大致建立在以前的基础上），然后是一些用于文件输入/输出和字符串流的C++头文件。
* 

* 
* [1.x.63]
 
* 最后一步和以前的所有程序一样。
* 

* 
* [1.x.64]
 
* [1.x.65] [1.x.66]。
 

* 
* 解决问题的整个算法被封装在这个类中。和以前的例子程序一样，这个类在声明时有一个模板参数，那就是空间维度，这样我们就可以在一个、两个或三个空间维度上求解正弦-戈登方程。关于这个问题的独立于维度的类封装的更多信息，读者应该参考 [2.x.90] 和 [2.x.91] 。  
* 与[2.x.92]和[2.x.93]相比，在程序的一般结构中没有任何有价值的东西（当然，在各种函数的内部运作中也有！）。最明显的区别是出现了两个新的函数[2.x.94]和[2.x.95]，计算系统矩阵的非线性贡献和第一个方程的右手边，正如在介绍中讨论的那样。此外，我们必须有一个向量[2.x.96]，它包含在每个牛顿步骤中对解向量的非线性更新。  
*正如介绍中也提到的，我们在这个程序中不存储速度变量，而是质量矩阵乘以速度。这是在[2.x.97]变量中完成的（"x "是代表 "次数"）。  
* 最后，[2.x.98]变量存储了在生成图形输出之前每次所需的时间步数。这一点在使用细网格（因此也是小的时间步数）时非常重要，在这种情况下，我们会运行大量的时间步数，并创建大量的输出文件，这些文件中的解看起来几乎是一样的。这只会堵塞我们的可视化程序，我们应该避免创建比我们真正感兴趣的更多的输出。因此，如果这个变量被设置为大于1的值[2.x.99]，那么只有在每一个[2.x.100]的时间步长时才会产生输出。
* 

* 
* [1.x.67]
* 
* [1.x.68] [1.x.69] * [1.x.68] [1.x.69]。
 

* 
* 在下面两类中，我们首先实现本程序介绍中提到的一维、二维和三维的精确解。如果想通过比较数值解和分析解来测试程序的准确性，这个时空解可能会有独立的意义（但是要注意，程序使用的是有限域，而这些是无界域的分析解）。例如，这可以用[2.x.101]函数来完成。再次注意（正如在[2.x.102]中已经讨论过的），我们如何将时空函数描述为依赖于时间变量的空间函数，该变量可以使用FunctionTime基类的[2.x.103]和[2.x.104]成员函数进行设置和查询。
* 

* 
* [1.x.70]
 
* 在本节的第二部分，我们提供初始条件。我们很懒惰（也很谨慎），不想第二次实现与上面相同的函数。相反，如果我们被询问初始条件，我们创建一个对象[2.x.105]，将其设置为正确的时间，并让它计算当时的精确解的任何值。
* 

* 
* [1.x.71]
* 
* [1.x.72] [1.x.73]
 

* 
* 让我们继续讨论主类的实现，因为它实现了介绍中概述的算法。
* 

* 
* [1.x.74] [1.x.75].
* 

* 
* 这是[2.x.106]类的构造函数。它指定了所需的有限元的多项式程度，关联了一个[2.x.107]对象（就像在示例程序[2.x.108]和[2.x.109]中一样），初始化了当前或初始时间，最终时间，时间步长，以及用于时间步长方案的[2.x.110]值。由于我们在这里计算的解是时间周期性的，所以开始时间的实际值并不重要，我们选择它是为了让我们在一个有趣的时间开始。  
* 注意，如果我们选择显式欧拉时间步进方案（[2.x.111]），那么我们必须选择一个时间步长[2.x.112]，否则该方案不稳定，解中可能出现振荡。Crank-Nicolson方案（[2.x.113]）和隐式Euler方案（[2.x.114]）不存在这个缺陷，因为它们是无条件稳定的。然而，即使如此，时间步长也应选择在[2.x.115]的数量级上，以获得一个好的解决方案。由于我们知道我们的网格是由矩形的均匀细分而来，我们可以很容易地计算出这个时间步长；如果我们有一个不同的域，[2.x.116]中的技术使用[2.x.117]也是可以的。
* 

* 
* [1.x.76]
* 
* [1.x.77] [1.x.78]。
 

* 
* 这个函数在[2.x.118]维度上创建一个矩形网格，并对其进行多次细化。同时，一旦自由度被集合起来，[2.x.119]类的所有矩阵和向量成员都被初始化为它们适当的大小。像[2.x.120]一样，我们使用[2.x.121]函数来生成质量矩阵[2.x.122]和拉普拉斯矩阵[2.x.123]，并在程序的剩余时间里将它们存储在适当的变量中。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81].
 

* 
* 这个函数为牛顿方法的每次迭代组装系统矩阵和右手边向量。关于系统矩阵和右手边的明确公式，读者应该参考导论。  
* 注意，在每个时间步长中，我们必须把对矩阵和右手边的各种贡献加起来。与[2.x.124]和[2.x.125]相比，这需要集合更多的条款，因为它们取决于前一个时间步骤或前一个非线性步骤的解决方案。我们使用函数[2.x.126]和[2.x.127]来做到这一点，而本函数提供了顶层逻辑。
* 

* 
* [1.x.82]
* 
* 首先我们组装雅各布矩阵[2.x.128]，其中[2.x.129]为方便起见被存储在向量[2.x.130]中。
* 

* 
* [1.x.83]
* 
* 接下来我们计算右手边的向量。这只是介绍中对[2.x.131]的描述所暗示的矩阵-向量的组合。
* 

* 
* [1.x.84]
* 
* [1.x.85] [1.x.86]。
 

* 
* 这个函数计算向量[2.x.132]，它出现在分裂公式的两个方程的非线性项中。这个函数不仅简化了这个项的重复计算，而且也是我们在时间步长为隐式时使用的非线性迭代求解器的一个基本部分（即[2.x.133]）。此外，我们必须允许该函数接收一个 "旧 "和一个 "新 "的解决方案作为输入。这些可能不是存储在[2.x.134]中的问题的实际解决方案，而只是我们线性化的两个函数。为了这个函数的目的，让我们在下面这个类的文档中分别调用前两个参数 [2.x.135] 和 [2.x.136]。  
* 作为一个旁注，也许值得研究一下什么阶次的正交公式最适合这种类型的积分。由于[2.x.137]不是一个多项式，可能没有正交公式可以准确地积分这些项。通常只需确保右手边的积分达到与离散化方案相同的精度即可，但通过选择更精确的正交公式，也许可以改善渐近收敛声明中的常数。
* 

* 
* [1.x.87]
* 
* 一旦我们将[2.x.138]实例化重新初始化到当前单元，我们就利用[2.x.139]例程来获取所选正交公式节点上的 "旧 "数据（大概在[2.x.140]）和 "新 "数据（大概在[2.x.141]）的值。
* 

* 
* [1.x.88]
* 
* 现在，我们可以使用所需的正交公式评估[2.x.142]。
* 

* 
* [1.x.89]
* 
* 最后，我们将各单元的积分相加，得出全局积分的贡献。
* 

* 
* [1.x.90]
* 
* [1.x.91] [1.x.92].
 

* 
* 这是处理非线性方案的第二个函数。它计算矩阵 [2.x.143] ，它出现在 [2.x.144] 的雅各布项的非线性项中。正如[2.x.145]一样，我们必须让这个函数接收一个 "旧 "和一个 "新 "的解决方案作为输入，我们再次将其称为[2.x.146]和[2.x.147]，分别如下。
* 

* 
* [1.x.93]
* 
* 同样，首先我们将我们的[2.x.148]实例化重新初始化为当前单元格。
* 

* 
* [1.x.94]
* 
* 然后，我们使用所需的正交公式评估[2.x.149]。
* 

* 
* [1.x.95]
* 
* 最后，我们把各单元的积分贡献加到全局积分上。
* 

* 
* [1.x.96]
* 
* [1.x.97] [1.x.98].
 

* 
* 正如在介绍中所讨论的，这个函数在线性方程组上使用CG迭代求解器，该方程组是由牛顿方法的每个迭代的有限元空间离散化产生的，用于分割公式的（非线性）第一个方程。该系统的解实际上是[2.x.150]，所以它被存储在[2.x.151]的[2.x.152]函数中。  
* 请注意，我们在求解前将解的更新值重新设置为零。这是没有必要的：迭代求解器可以从任何一点开始并收敛到正确的解。如果对线性系统的解有一个很好的估计，那么从这个向量开始可能是值得的，但是作为一个一般的观察，事实是起点并不重要：它必须是一个非常非常好的猜测，以减少超过几个迭代的次数。事实证明，对于这个问题，使用以前的非线性更新作为起点实际上会损害收敛性，并增加所需的迭代次数，所以我们简单地将其设置为零。  
* 该函数返回收敛到一个解决方案所需的迭代次数。这个数字以后将被用来在屏幕上生成输出，显示每次非线性迭代需要多少次迭代。
* 

* 
* [1.x.99]
* 
* [1.x.100] [1.x.101].
 

* 
* 这个函数将结果输出到一个文件。它与 [2.x.153] 和 [2.x.154] 中的相应函数基本相同。
* 

* 
* [1.x.102]
* 
* [1.x.103] [1.x.104]。
 

* 
* 这个函数对一切都有最高级别的控制：它运行（外部）时间步长循环，（内部）非线性求解器循环，并在每个时间步长后输出解。
* 

* 
* [1.x.105]
 
* 为了确认初始条件，我们必须使用函数 [2.x.155] 来计算 [2.x.156] 。为此，下面我们将创建一个类型为[2.x.157]的对象；注意，当我们创建这个对象时（它来自[2.x.158]类），我们将其内部的时间变量设置为[2.x.159]，以表明初始条件是在[2.x.160]处评价的空间和时间的函数。    
* 然后我们通过使用[2.x.163]将[2.x.162]投影到网格上，产生[2.x.161]。我们必须使用与[2.x.164]相同的使用悬挂节点约束的构造：[2.x.165]函数需要一个悬挂节点约束对象，但为了使用它，我们首先需要关闭它。
* 

* 
* [1.x.106]
* 
* 为了完整起见，我们像其他时间步骤一样，将第2个时间步骤输出到一个文件中。
* 

* 
* [1.x.107]
* 
* 现在我们进行时间步进：在每个时间步进中，我们解决与问题的有限元离散化相对应的矩阵方程，然后根据我们在介绍中讨论的时间步进公式推进我们的解决方案。
* 

* 
* [1.x.108]
 
* 在每个时间步长的开始，我们必须通过牛顿方法求解分裂公式中的非线性方程
* 
* - - 即先求解[2.x.166]，然后计算[2.x.167]，如此反复。这种非线性迭代的停止标准是：[2.x.168] 。因此，我们需要在第一次迭代中记录残差的规范。        
* 在每次迭代结束时，我们向控制台输出我们花了多少次线性求解器的迭代。当下面的循环完成后，我们有（一个近似的） [2.x.169] 。
* 

* 
* [1.x.109]
* 
* 在得到问题的第一个方程[2.x.170]的解后，我们必须更新辅助速度变量 [2.x.171] 。然而，我们不计算和存储[2.x.172]，因为它不是我们在问题中直接使用的一个量。因此，为了简单起见，我们直接更新[2.x.173]。
* 

* 
* [1.x.110]
* 
* 很多时候，特别是对于细网格，我们必须选择相当小的时间步长，以使方案稳定。因此，有很多的时间步长，在求解过程中 "没有什么有趣的事情发生"。为了提高整体效率
* 
* - 特别是加快程序的速度和节省磁盘空间
* 
* - 我们每隔[2.x.174]个时间步骤才输出解。
* 

* 
* [1.x.111]
* 
* [1.x.112] [1.x.113]。
 

* 
* 这是该程序的主函数。它创建一个顶层类的对象并调用其主函数。如果在执行[2.x.175]类的运行方法时抛出了异常，我们会在这里捕获并报告它们。关于异常的更多信息，读者应该参考 [2.x.176] 。
* 

* 
* [1.x.114]
* [1.x.115][1.x.116] 。
* 显式欧拉时间步进方案（[2.x.177]）对于我们希望解决的问题来说表现得很充分。不幸的是，由于稳定性问题，必须选择一个相当小的时间步长。
* 
* - - [2.x.178]似乎对我们进行的大多数模拟都有效。另一方面，Crank-Nicolson方案（[2.x.179]）是无条件稳定的，而且（至少对于一维呼吸器的情况）我们可以选择大到[2.x.180]的时间步长而不对解决方案产生任何不良影响。隐式欧拉方案（[2.x.181]）是 "指数阻尼 "的，所以它不是解决正弦戈登方程的好选择，因为它是保守的。然而，[2.x.182]-方法提供的连续体中的一些阻尼方案对于消除边界效应引起的虚假振荡很有帮助。
* 在下面的模拟中，我们在一维的区间[2.x.183]和二维的正方形[2.x.184]上解决正弦-戈登方程。在每种情况下，各自的网格被均匀地细化6次，即[2.x.185] 。
*[1.x.117][1.x.118] 。
* 我们讨论的第一个例子是所谓的正弦-戈登方程的一维（静止的）呼吸解。该呼吸器有以下封闭式表达，正如在介绍中提到的：[1.x.119]其中[2.x.186]、[2.x.187]和[2.x.188]是常数。在下面的模拟中，我们选择[2.x.189]、[2.x.190]、[2.x.191]。此外，我们知道呼吸器的振荡周期是[2.x.192]，因此我们选择了[2.x.193]和[2.x.194]，这样我们可以观察到溶液的三次振荡。然后，取[2.x.195]，[2.x.196]和[2.x.197]，程序计算出以下解。
* [2.x.198] 
* 虽然程序中没有显示如何做，但另一种可视化(1+1)-d解决方案的方法是使用DataOutStack类产生的输出；它允许 "堆叠 "各个时间步骤的解决方案，因此我们从一维时间相关的解决方案中得到二维时空图。这就产生了下面的时空图，而不是上面的动画。
* [2.x.199] 
* 此外，由于呼吸器是正弦戈登方程的分析解，我们可以用它来验证我们的代码，尽管我们必须假设我们选择的诺伊曼边界条件所带来的误差与数值误差相比是很小的。在这种假设下，我们可以使用[2.x.200]函数来计算数值解和本程序的[2.x.201]类描述的函数之间的差异。对于上面两幅图所示的模拟，每个时间步长的无限元解的[2.x.202]准则误差仍然在[2.x.203]的数量级。因此，我们可以得出结论，数值方法已经在程序中得到了正确的实现。
* 

* [1.x.120][1.x.121] 。
* 

* 在文献中可以找到的正弦戈登方程在(2+1)D中的唯一分析解是所谓的kink孤波。它有以下的闭合式表达。 [1.x.122]与[1.x.123]其中[2.x.204]、[2.x.205]和[2.x.206]是常数。在下面的模拟中，我们选择了[2.x.207]。请注意，如果[2.x.208]的扭结是静止的，因此它将成为一个很好的解决方案，我们可以根据它来验证二维的程序，因为没有发生域边界的反射。
* 下面显示的模拟是用[2.x.209]、[2.x.210]、[2.x.211]、[2.x.212]和[2.x.213]进行的。每个时间步长的有限元解的[2.x.214]误差准则保持在[2.x.215]的数量级上，表明该程序在二维和一维都能正常工作。不幸的是，这个解决方案不是很有趣，尽管如此，为了完整起见，我们还是把它的一个快照放在下面。
* [2.x.216] 
* 现在我们已经验证了一维和二维的代码，我们转到一个分析解未知的问题上。
* 为此，我们将上面讨论的扭结解围绕[2.x.217]轴旋转：我们让[2.x.218] 。后者的结果是不与网格对齐的孤波，所以反射立即发生在域的边界上。在下面的模拟中，我们选择了[2.x.219]、[2.x.220]、[2.x.221]、[2.x.222]和[2.x.223] 。此外，我们不得不选择[2.x.224]，因为对于任何[2.x.225]的边界都会产生振荡，这可能是由于方案而不是方程造成的，因此选择[2.x.226]的值，在时间步进方案的 "指数阻尼 "频谱内，可以确保这些振荡不会被产生。
* [2.x.227] 
* 正弦戈登方程的另一个有趣的解决方案（无法通过分析获得）可以通过使用两个一维呼吸器来构建以下可分离的二维初始条件来产生：[1.x.124]其中[2.x.228], [2.x.229]与我们上面讨论的一维情况一样。在下面的模拟中，我们选择了[2.x.230]、[2.x.231]、[2.x.232]和[2.x.233] 。解决方案是相当有趣的
* 
* --它的作用就像一个呼吸器（就图片而言）；然而，它似乎是分解和重新组装，而不仅仅是振荡。
* [2.x.234] 
* 

* [1.x.125][1.x.126][1.x.127] 。
* 

* 改变初始条件是有意义的。大多数选择不会导致保持局部的解决方案（在孤子界，这样的解决方案被称为 "静止的"，尽管解决方案确实随时间变化），而是导致解决方案，其中方程的波状特征占主导地位，波从局部初始条件的位置走出去。例如，值得玩一玩[2.x.235]类，把对[2.x.236]类的调用改为类似这样的函数：[1.x.128]如果[2.x.237]，而[2.x.238]在这个区域之外。
* 第二个方面是研究该方案是否是能量保留的。对于[2.x.239]"[2.x.240]"中讨论的纯波方程，如果我们选择时间步进参数，使我们得到Crank-Nicolson方案，情况就是这样。我们可以在这里做类似的事情，注意到正弦-戈登解的能量定义为[1.x.129]（我们在公式中使用[2.x.241]而不是[2.x.242]，以确保对能量的所有贡献都是正的，因此衰减解在无界域上具有无限的能量）。
* 除此之外，还有两个明显的领域。
* 
* 显然，自适应性（即时间自适应网格）会对这样的问题感兴趣。它们的复杂性导致我们再次将其排除在本计划之外，尽管[2.x.243]" [2.x.244]"介绍中的一般评论仍然是正确的。
* 
* - 更快的方案来解决这个问题。虽然今天的计算机已经足够快，可以在不长的时间内解决二维甚至三维静止的问题，但时间相关的问题提出了一个完全不同的问题类别。我们在[2.x.245]中讨论了这个问题，在那里我们展示了如何并行地解决这个问题，而且根本不需要组装或反转任何矩阵。
* 

* [1.x.130][1.x.131] [2.x.246] 。
* [0.x.1]

