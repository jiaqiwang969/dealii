include/deal.II-translator/A-tutorial/step-48_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23]
* 
* [1.x.24][1.x.25]。
* [1.x.26][1.x.27][1.x.28] 。
 

* 本程序演示了如何使用MatrixFree类的基于单元的有限元算子实现，该类首次在[2.x.3]中介绍，用来解决非线性偏微分方程。最后，我们将使用明确的时间步进方法来解决问题，并介绍高斯-洛巴特有限元，在这种情况下非常方便，因为它们的质量矩阵可以准确地由对角线接近，因此是可逆的矩阵。这一特性的两个要素是：首先，根据Gauss-Lobatto正交规则的点分布，对拉格朗日多项式的结点进行分布。其次，正交是用同样的Gauss-Lobatto正交规则完成的。在这个公式中，只要[2.x.5]，积分[2.x.4]就变成零，因为在定义拉格朗日多项式的点中，正好有一个函数[2.x.6]是一，其他都是零。此外，拉格朗日多项式的节点的Gauss-Lobatto分布将节点向元素边界聚集。这就为高阶离散化方法提供了条件良好的多项式基础。事实上，具有等距节点的FE_Q元素的条件数随着度数的增加而呈指数级增长，这破坏了五阶以上的任何好处。因此，高斯-洛巴特点是FE_Q元素的默认分布（但在度数为1和2时，它们等同于等距点）。
*[1.x.29][1.x.30]
* 

* 作为一个例子，我们选择解决正弦-戈登孤子方程[1.x.31] 。
* 这在[2.x.7]中已经介绍过。作为一种简单的显式时间积分方法，我们选择使用方程的二阶形式的跃迁方案。在这种时间步长的情况下，该方案以弱的形式读出
* [1.x.32]其中[1.x.33]表示一个测试函数，索引[1.x.34]代表时间步长。
* 对于空间离散化，我们选择FE_Q元素，其基函数定义为插值高斯-洛巴托正交规则的支持点。此外，当我们计算基函数上的积分以形成质量矩阵和上述方程右边的算子时，我们使用高斯-洛巴特正交规则，其支持点与有限元的节点相同，以评估积分。由于有限元是拉格朗日的，这将产生方程左侧的对角线质量矩阵，使得每个时间步长的线性系统的解决变得微不足道。
* 使用这个正交规则，对于[1.x.35]阶有限元，我们使用[1.x.36]阶精确公式来评估积分。由于在计算质量矩阵时，两个[1.x.37]阶基函数的乘积在每个方向上都给出了一个具有多项式程度[1.x.38]的函数，所以积分的计算并不精确。 然而，整体收敛性能并不受到正交误差的干扰，在具有亲和元素形状的网格上，L2误差与[1.x.39]成正比。但是请注意，当积分项不再是多项式时，在变形（非affine）元素形状的波浪方程上，已经有报道[1.x.40]甚至[1.x.41]的L2误差的次优收敛率的减序[1.x.42]。
* 除了在使用显式时间步进时我们可以避免用这种类型的元素解决线性系统外，它们还有另外两个优点。当我们使用和-因子化方法来评价有限元算子时（参见[2.x.8]），我们必须在正交点评价函数。在Gauss-Lobatto元素的情况下，正交点和无限元素的节点点是重合的，这种操作是微不足道的，因为正交点的函数值是由其一维系数给出的。这样一来，与一般的高斯正交相比，有限元运算估值的算术工作大约减少了2倍。
* 总结一下讨论，通过使用正确的有限元和正交规则组合，我们最终得到的方案是只需要计算对应于上述公式的右手边向量，然后在每个时间步长中乘以对角线质量矩阵的逆。当然，在实践中，我们提取对角线元素并在程序开始时只反转一次。
*[1.x.43][1.x.44]
* 

* 在[2.x.9]中处理约束的通常方法是使用AffineConstraints类，该类建立了一个稀疏矩阵，存储关于哪些自由度（DoF）受到约束以及它们如何受到约束的信息。这种格式使用了不必要的大量内存，因为没有那么多不同类型的约束：例如，在悬挂节点的情况下，当在每个单元上使用线性有限元时，大多数约束具有[2.x.10]的形式，其中系数[2.x.11]总是相同的，只有[2.x.12]不同。虽然存储这些多余的信息在一般情况下不是问题，因为它在矩阵和右手边的装配过程中只需要一次，但它在无矩阵方法中成为一个瓶颈，因为每次我们应用算子时都要访问这些信息，而算子评估的其余部分是如此之快。因此，MatrixFree使用一个我们称之为[2.x.13]的变量来收集不同约束的权重，而不是一个AffineConstraints对象。然后，只需要存储网格中每个约束的标识符而不是所有的权重。此外，约束不是在前后处理步骤中应用的，而是在我们评估有限元运算器时应用的。因此，约束信息被嵌入到变量[2.x.14]中，该变量用于从全局矢量中提取单元信息。如果一个DoF受到约束，[2.x.15]变量包含了它所约束的DoF的全局指数。然后，我们还有一个变量[2.x.16]，在每个单元中都有被约束的DoF的局部指数，以及约束类型的标识符。幸运的是，你不会在示例程序中看到这些数据结构，因为类[2.x.17]会在没有用户交互的情况下处理这些约束。
* 在存在悬空节点的情况下，通过Gauss-Lobatto正交/节点点程序在元素层面获得的对角质量矩阵并不能直接转化为对角的全局质量矩阵，因为遵循行和列的约束也会增加非对角条目。正如[1.x.45]中所解释的那样，在一个矢量上插值约束，保持质量矩阵的对角线形状，与方程一致，但误差的大小与正交误差相同。在下面的程序中，我们将简单地把质量矩阵的对角线作为一个矢量进行组合，以实现这种近似。
* 

* [1.x.46][1.x.47] 。
* 

* MatrixFree类有三个层次的并行化选项：分布式节点集群上的MPI并行化，由线程积木库安排的线程并行化，以及最后通过SIMD数据类型在两个（或更多）单元的批次上工作的矢量化（有时称为交叉元素或外部矢量化）。 正如我们在[2.x.18]中所讨论的，你将通过使用特定于你的系统的指令集来获得最佳性能，例如，使用cmake变量<tt>-DCMAKE_CXX_FLAGS="-march=native"</tt>。在 [2.x.19] 中已经利用了MPI并行化。在这里，我们额外考虑了用TBB进行线程并行化。这相当简单，因为我们需要做的就是告诉MatrixFree对象的初始化，我们想通过变量[2.x.20]使用线程并行方案。 在设置过程中，建立了一个类似于[2.x.21]中描述的依赖图，这允许安排[2.x.22]函数在单元块上的工作，而没有几个线程访问同一个向量索引。相对于WorkStream循环，一些额外的巧妙技巧也被应用，以避免[1.x.48]中描述的全球同步。
* 请注意，这个程序被设计为与分布式三角计算[2.x.23]一起运行，这需要deal.II与[1.x.49]一起配置，如[1.x.50]文件中所述。然而，也支持非分布式三角计算，在这种情况下，计算将以串行方式运行。
*[1.x.51][1.x.52]
* 

* 在我们的例子中，我们选择初始值为[1.x.53]，并在时间区间[-10,10]内解决方程。常数被选择为[2.x.24]和[1.x.54]。正如在[2.x.25]中提到的，在一维中[1.x.55]作为[1.x.56]的函数是正弦-戈登方程的精确解。对于更高的维度，情况并非如此。
* 

* [1.x.57] [1.x.58]。
* 来自deal.II库的必要文件。
* 

* 
* [1.x.59]
* 
* 这包括用于有效实现无矩阵方法的数据结构。
* 

* 
* [1.x.60]
* 
* 我们首先定义了两个全局变量，以便在一个地方收集所有需要改变的参数。一个是尺寸，一个是有限元度。维度在主函数中是作为实际类的模板参数使用的（就像所有其他deal.II程序一样），而有限元的度数则更为关键，因为它是作为模板参数传递给Sine-Gordon算子的实现。因此，它需要成为一个编译时常数。
* 

* 
* [1.x.61]
* 
* [1.x.62] [1.x.63].
 

* 
* [2.x.26]类实现了每个时间步骤中需要的基于单元的操作。这个非线性操作可以在[2.x.27]类的基础上直接实现，与线性操作在这个实现的有限元算子应用中的处理方式相同。我们对该类应用两个模板参数，一个是尺寸，一个是有限元的度数。这与deal.II中的其他函数不同，其中只有维度是模板参数。这对于向[2.x.28]中的内循环提供关于循环长度等的信息是必要的，这对于效率是至关重要的。另一方面，这使得将度数作为一个运行时参数来实现更具挑战性。
* 

* 
* [1.x.64]
* 
* [1.x.65] [1.x.66].
 

* 
* 这是SineGordonOperation类的构造函数。它接收一个对MatrixFree的引用，该引用持有问题信息和时间步长作为输入参数。初始化程序设置了质量矩阵。由于我们使用Gauss-Lobatto元素，质量矩阵是一个对角矩阵，可以存储为一个矢量。利用FEEvaluation提供的数据结构，质量矩阵对角线的计算很容易实现。只要在所有的单元格批次上循环，即由于SIMD矢量化的单元格集合，通过使用[2.x.29]函数与[2.x.30]参数在槽中取值，在所有正交点上常一的函数上积分。最后，我们将对角线条目进行反转，以便在每个时间步长中直接得到反质量矩阵。
* 

* 
* [1.x.67]
* 
* [1.x.68] [1.x.69]
 

* 
* 这个算子实现了程序的核心操作，即对Sine-Gordon问题的非线性算子进行单元范围的积分。其实现是基于 [2.x.31] 中的FEEvaluation类。由于Gauss-Lobatto元素的特殊结构，某些操作变得更加简单，特别是正交点上的形状函数值的评估，这只是单元自由度值的注入。MatrixFree类在初始化时检测正交点的有限元的可能结构，然后由FEEvaluation自动用于选择最合适的数值核。
* 

* 
* 我们必须为时间步进例程评估的非线性函数包括当前时间的函数值[2.x.32]以及前一个时间步进的值[2.x.33]这两个值都在源向量集合[2.x.34]中传递给运算器，该集合只是一个指向实际解向量的指针[2.x.35]。这种将多个源向量收集到一起的结构是必要的，因为[2.x.36]中的单元格循环正好需要一个源向量和一个目的向量，即使我们碰巧使用许多向量，如本例中的两个。请注意，单元格循环接受任何有效的输入和输出类，这不仅包括向量，还包括一般的数据类型。 然而，只有在遇到收集这些向量的[2.x.37]或[2.x.38]时，它才会在循环的开始和结束时调用由于MPI而交换幽灵数据的函数。在单元格的循环中，我们首先要读入与本地值有关的向量中的值。 然后，我们评估当前求解向量的值和梯度以及正交点的旧向量的值。接下来，我们在正交点的循环中结合方案中的条款。最后，我们将结果与测试函数进行积分，并将结果累积到全局解向量[2.x.39] dst。
* 

* 
* [1.x.70]
* 
* [1.x.71] [1.x.72].
 

* 
* 这个函数根据单元本地策略执行时间步进例程。请注意，在添加当前时间步长的积分贡献之前，我们需要将目标向量设置为零（通过[2.x.40]调用）。在本教程中，我们通过传递给[2.x.41]的第五个`true`参数让单元格循环进行归零操作。 循环可以将归零操作安排在更接近对支持的向量项的操作，从而可能提高数据的定位性（首先被归零的向量项后来在`distribute_local_to_global()`调用中重新使用）。单元循环的结构是在单元有限元运算器类中实现的。在每个单元上，它应用定义为类 [2.x.42] 方法的例程 [2.x.43] 。我们也可以提供一个具有相同特征的、不属于类的函数。最后，积分的结果被乘以逆质量矩阵。
* 

* 
* [1.x.73]
* 
* [1.x.74] [1.x.75]。
 

* 
* 我们定义了一个随时间变化的函数，作为初始值使用。通过改变起始时间可以得到不同的解决方案。这个函数取自[2.x.44]，将代表一维中所有时间的分析解，但在这里只是用来设置一些感兴趣的起始解。在 [2.x.45] 中给出了可以测试这个程序的收敛性的更详细的选择。
* 

* 
* [1.x.76]
* 
* [1.x.77] [1.x.78] 。
 

* 
* 这是在 [2.x.46] 中的类基础上的主类。 然而，我们用MatrixFree类代替了SparseMatrix<double>类来存储几何数据。另外，我们在这个例子中使用了一个分布式三角形。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81].
 

* 
* 这是SineGordonProblem类的构造函数。时间间隔和时间步长在此定义。此外，我们使用在程序顶部定义的有限元的度数来初始化一个基于Gauss-Lobatto支持点的FE_Q有限元。这些点很方便，因为与同阶的QGauss-Lobatto正交规则相结合，它们可以得到一个对角线质量矩阵，而不会太影响精度（注意，虽然积分是不精确的），也可以参见介绍中的讨论。请注意，FE_Q默认选择Gauss-Lobatto结点，因为它们相对于等距结点有更好的条件。为了使事情更加明确，我们还是要说明节点的选择。
* 

* 
* [1.x.82]
* 
* [1.x.83] [1.x.84].
 

* 
* 如同在[2.x.47]中，这个函数在[2.x.48]维度上设置了一个范围为[2.x.49]的立方体网格。我们在域的中心位置更多的细化网格，因为解决方案集中在那里。我们首先细化所有中心在半径为11的单元，然后再细化一次半径为6的单元。 这种简单的临时细化可以通过在时间步进过程中使用误差估计器使网格与解相适应来完成，就像在其他例子程序中所做的那样，并使用[2.x.50]来将解转移到新的网格中。
* 

* 
* [1.x.85]
* 
* 我们生成悬挂节点约束，以确保解的连续性。如同在[2.x.51]中，我们需要为约束矩阵配备本地相关自由度的IndexSet，以避免它在大问题中消耗过多的内存。接下来，问题的<code>MatrixFree</code>对象被设置。请注意，我们为共享内存并行化指定了一个特定的方案（因此，人们会使用多线程来实现节点内的并行化，而不是MPI；我们在这里选择了标准选项&mdash；如果我们想在程序中有一个以上的TBB线程的情况下禁用共享内存并行化，我们会选择[2.x.52]也请注意，我们提供一个QGaussLobatto正交公式，而不是使用默认的QGauss正交参数，以实现期望的行为。最后，三个求解向量被初始化。MatrixFree期望有一个特定的鬼魂索引布局（因为它在MPI本地数字中处理索引访问，需要在向量和MatrixFree之间匹配），所以我们只是要求它初始化向量，以确保鬼魂交换得到正确处理。
* 

* 
* [1.x.86]
* 
* [1.x.87] [1.x.88]
 

* 
* 这个函数打印出解的规范，并将解的向量写到一个文件中。法线是标准的（除了我们需要在所有处理器上累积平行网格的法线，我们通过[2.x.53]函数来做），第二项类似于我们在[2.x.54]或[2.x.55]中的做法。请注意，我们可以使用与计算过程中使用的相同的向量进行输出。无矩阵框架中的向量总是提供所有本地拥有的单元的全部信息（这也是本地评估中需要的），包括这些单元上的鬼向量条目。这是[2.x.56]函数以及DataOut中唯一需要的数据。这时唯一要做的就是确保在我们从矢量中读取数据之前更新其鬼魂值，并在完成后重置鬼魂值。这是一个只存在于[2.x.57]类中的特性。另一方面，带有PETSc和Trilinos的分布式向量需要被复制到包括ghost值的特殊向量（见[2.x.58]中的相关章节 ）。如果我们还想访问幽灵单元上的所有自由度（例如，在计算使用单元边界上的解的跳跃的误差估计器时），我们需要更多的信息并创建一个初始化了本地相关自由度的向量，就像在 [2.x.59] 中一样。还请注意，我们需要为输出分配约束条件
* 
* - 它们不是在计算过程中填充的（相反，它们是在无矩阵方法中即时插值的 [2.x.60] 。
* 

* 
* [1.x.89]
 
* [1.x.90] [1.x.91].
 

* 
* 这个函数被主函数调用，并步入该类的子程序中。  
* 在打印了一些关于并行设置的信息后，第一个动作是设置网格和单元运算器。然后，根据构造函数中给出的CFL编号和最细的网格尺寸计算出时间步长。最细的网格尺寸计算为三角形中最后一个单元的直径，也就是网格中最细层次上的最后一个单元。这只适用于一个层次上的所有元素都具有相同尺寸的网格，否则就需要对所有单元进行循环。请注意，我们需要查询所有处理器的最细单元，因为不是所有的处理器都可能持有网格处于最细级别的区域。然后，我们重新调整一下时间步长，以准确地达到最后的时间。
* 

* 
* [1.x.92]
* 
* 接下来是初始值的设定。由于我们有一个两步的时间步进方法，我们还需要一个在时间步进时的解的值。为了得到准确的结果，需要从初始时间的解的时间导数来计算，但在这里我们忽略了这个困难，只是将其设置为该人工时间的初始值函数。
* 

* 
* 然后，我们继续将初始状态写入文件，并在[2.x.61]的指针中收集两个起始解，这些指针后来被[2.x.62]函数所消耗。接下来，根据文件顶部指定的有限元程度，建立一个[2.x.63]的实例。
* 

* 
* [1.x.93]
* 
* 现在对时间步骤进行循环。在每个迭代中，我们将解的向量移动一个，并调用`正弦戈登运算器'类的`应用'函数。然后，我们将解决方案写到一个文件中。我们为所需的计算时间和创建输出所需的时间计时，并在时间步进结束后报告这些数字。    
* 注意这个换位是如何实现的。我们只是在两个向量上调用了交换方法，只交换了一些指针，而不需要复制数据，这在显式时间步进方法中是一个相对昂贵的操作。让我们来看看发生了什么。首先，我们交换[2.x.64]，这意味着[2.x.65]得到[2.x.66]，这就是我们所期望的。同样，在下一步中，[2.x.67]也是如此。在此之后，[2.x.68]持有[2.x.69]，但在这一步中会被覆盖。
* 

* 
* [1.x.94]
* 
* [1.x.95] [1.x.96]。
 

* 
* 与[2.x.70]中一样，我们在程序开始时初始化MPI。由于我们一般会将MPI并行化与线程混合在一起，所以我们也将MPI_InitFinalize中控制线程数量的第三个参数设置为无效数字，这意味着TBB库会自动选择线程的数量，通常是根据系统中可用的核心数量。作为一种选择，如果你想设置一个特定的线程数（例如，当需要只使用MPI时），你也可以手动设置这个数字。
* 

* 
* [1.x.97]
* [1.x.98][1.x.99]。
* 

*[1.x.100][1.x.101]
 

* 为了证明使用MatrixFree类而不是标准的[2.x.71]汇编例程来评估旧的时间步骤的信息的好处，我们研究了一个简单的在非适应性网格上的串行运行的代码。由于许多时间花在评估正弦函数上，我们不仅显示了完整的正弦-戈登方程的数字，还显示了波浪方程（正弦-戈登方程中跳过的正弦项）的数字。我们同时使用二阶和四阶元素。结果总结在以下表格中。
* [2.x.72] 
* 很明显，无矩阵代码远远超过了deal.II中的标准汇编程序。在三维和四阶元素中，一个操作值的速度也几乎是稀疏矩阵-向量积的十倍。
*[1.x.102][1.x.103]
* 

* 我们从12个核心/24线程的工作站上获得的程序输出开始（一个英特尔至强E5-2687W v4 CPU运行在3.2GHz，启用了超线程），以发布模式运行程序。
* [1.x.104]
* 
*在3D中，各自的输出看起来像
* [1.x.105]
* 
* 一个自由度超过一百万度的时间步长需要0.008秒（注意，在求解线性系统时，我们需要很多处理器来达到这样的数字）。
* 如果我们用一个纯粹的MPI并行化取代线程并行化，那么时间就会变成。
* [1.x.106]
* 
* 我们观察到输出的大幅加速（这是有道理的，因为输出的大部分代码没有通过线程并行化，而MPI则是如此），但低于我们从并行性中期望的12的理论系数。更有趣的是，当从只用线程的变量切换到只用MPI的变量时，计算也变得更快。这是对MatrixFree框架的一般观察（截至2019年更新该数据）。主要原因是，为实现并行执行而做出的关于冲突单元批的工作的决定过于悲观：虽然它们确保在不同线程上不会同时对相邻单元进行工作，但这种保守的设置意味着在相邻单元被触及时，相邻单元的数据也会从缓存中被驱逐。此外，对于具有17592个单元的给定网格，目前的方案无法为所有24个线程提供恒定的负载。
* 目前的方案允许混合MPI并行化和线程并行化。当在有多个节点的集群上运行程序时，使用MPI进行节点间并行化，使用线程进行节点内并行化，这是最有利的。在上面使用的工作站上，我们可以在超线程区域运行线程（即在12个MPI等级中每个使用2个线程）。将MPI与线程混合在一起的一个重要设置是确保任务与CPU的正确分工。在许多集群上，通过`mpirun/mpiexec`环境自动放置，或者手动设置。在这里，我们简单地报告了程序的普通版本的运行时间（注意，当适当的定位完成后，事情可以向MPI-only程序的时间改进）。
* [1.x.107]
 
* 

* 
* [1.x.108] [1.x.109]
* 

* 在这个程序中，有几处可以改进，使其更加有效（除了在[2.x.73]中讨论的改进边界条件和物理材料）。
* [2.x.74] [2.x.75] [1.x.110] 从上面的平波方程和正弦-戈登方程的比较中可以明显看出，正弦项的评估在有限元算子应用的总时间中占主导地位。这有几个原因。首先，VectorizedArray场的deal.II正弦计算没有被矢量化（与算子应用的其他部分相反）。这可以通过将正弦计算交给一个具有矢量化正弦计算的库来解决，比如英特尔的数学内核库（MKL）。通过使用MKL中的函数[2.x.76]，该程序在二维中使用了一半的计算时间，在三维中使用了40%的时间。另一方面，正弦计算在结构上要比其他本地操作中的加法和乘法等简单算术操作复杂得多。
* [2.x.77] [1.x.111] 虽然实现允许空间部分的任意顺序（通过调整有限元的程度），但时间步进方案是标准的二阶跃迁方案。由于波的传播问题的解通常是非常平滑的，所以误差很可能被时间步进部分所支配。当然，这可以通过使用较小的时间步长（在固定的空间分辨率下）来解决，但使用高阶时间步长也会更有效率。虽然对于一阶系统来说，这样做是很简单的（使用一些高阶的Runge&ndash;Kutta方案，可能结合像[1.x.112]那样的自适应时间步长选择），但对于二阶公式来说，这更具挑战性。至少在有限差分界，人们通常用PDE来寻找改善时间误差的空间修正项。
* [2.x.78] 
* 

* [1.x.113][1.x.114] [2.x.79] 。
* [0.x.1]

