include/deal.II-translator/A-tutorial/step-34_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25]
* [2.x.2]
* [1.x.26]
* [2.x.3]
* [1.x.27]
*[1.x.28][1.x.29]


*[1.x.30][1.x.31]
* 无粘性流体经过物体时的不可压缩运动（例如空气经过飞机机翼，或空气或水经过螺旋桨），通常用流体动力学的欧拉方程来模拟。
* [1.x.32]其中流体密度[2.x.4]和外力加速度[2.x.5]是给定的，速度[2.x.6]和压力[2.x.7]是未知数。这里[2.x.8]是一个封闭的有界区域，代表流体围绕身体运动。
* 上述方程可以从纳维-斯托克斯方程推导出来，假设与压力梯度、惯性力和外力的影响相比，粘度造成的影响可以忽略不计。这与[2.x.9]中讨论的斯托克斯方程的情况正好相反，斯托克斯方程是主导粘度的极限情况，即速度非常小，惯性力可以忽略不计。另一方面，由于假定的不可压缩性，该方程不适合于非常高速的气体流动，在这种情况下，必须考虑气体的可压缩性和状态方程，导致气体动力学的欧拉方程，一个双曲系统。
* 在本教程中，我们将只考虑没有外力的静止流动：[1.x.33] 。
*

* 欧拉方程的解的唯一性是通过添加边界条件[1.x.34]来保证的。
* 也就是说，身体在我们的坐标系中是静止的，不具有渗透性，而流体在无限远处具有（恒定）速度[2.x.10]。另一种观点是，我们的坐标系随着身体移动，而背景流体在无穷远处处于静止状态。注意，我们将法线[2.x.11]定义为域[2.x.12]的[1.x.35]法线，它与积分域的外法线相反。
* 对于静止和非静止的流动，求解过程从求解第二个方程中的速度开始，然后代入第一个方程以求得压力。静止欧拉方程的求解通常是为了了解给定的（可能是复杂的）几何体在对系统实施规定运动时的行为。
* 这个过程的第一步是将参照系从一个与身体一起运动的坐标系改变为一个身体在无限远处静止的流体中运动的坐标系。这可以通过引入一个新的速度[2.x.13]来表示，对于这个速度，我们发现同样的方程成立（因为[2.x.14]），我们有边界条件[1.x.36]
* 如果我们假设流体是无旋转的，即[2.x.15]中的[2.x.16]，我们可以将速度，以及由此产生的扰动速度，表示为一个标量函数的梯度：[1.x.37因此，上述欧拉方程的第二部分可以改写为未知数[2.x.17]的同质拉普拉斯方程：[1.x.38]，而动量方程则简化为伯努利方程，将压力[2.x.18]表示为势的函数[2.x.19] ：[1.x.39]
* 因此，我们可以通过解决电势的拉普拉斯方程来解决这个问题。  我们回顾一下，下列函数，称为拉普拉斯方程的基本解。
* [1.x.40]
* 在分布意义上满足该方程。
* [1.x.41]
* 其中导数是在变量[2.x.20]中完成的。通过使用通常的格林定理，我们的问题可以只写在边界[2.x.21]上。我们回顾一下第二个格林同位数的一般定义。
* [1.x.42]
* 其中[2.x.22]是[2.x.23]表面的法线，从积分域[2.x.24]向外指向。
* 在我们的例子中，积分域是域[2.x.25]，其边界是[2.x.26]，其中无限远处的 "边界 "被定义为
* [1.x.43]
* 在我们的程序中，法线被定义为域[2.x.27]的[1.x.44]，也就是说，它们实际上是积分域的[1.x.45]，在定义各种法线符号正确的积分时需要注意，即用[2.x.29]取代[2.x.28]。
* 如果我们将[2.x.30]和[2.x.31]与[2.x.32]以及拉普拉斯方程的基本解分别替换为格林%同位数，只要[2.x.33]被选在[2.x.34]区域内，我们就可以得到：[1.x.46]
*其中法线现在指向[1.x.47]这个积分域。
* 注意在上述方程中，我们也有在[2.x.35]的边界比例上的积分。利用我们问题的边界条件，我们发现[2.x.36]在无穷远处为零（这简化了右手边[2.x.37]上的积分）。
* 左手边出现的[2.x.38]上的积分可以通过观察[2.x.39]来处理，这意味着[2.x.40]在无穷远处必然是常数。我们把它的值定义为[2.x.41]。  要证明这一点是很容易的
* [1.x.48]
* 利用这个结果，我们可以使用所谓的单层和双层势能算子，只在边界[2.x.42]上还原上述方程。
* [1.x.49]
* (这些算子的名字来自于它们分别描述了[2.x.43]中由于沿表面的单层薄电荷和由于沿表面的双层电荷和反电荷而产生的电动势。)
* 在我们的例子中，我们知道边界上[2.x.44]的诺伊曼值：[2.x.45] .因此，[1.x.50]如果我们对上述方程的[2.x.46]采取倾向于[2.x.47]的极限，利用众所周知的单层和双层运算符的特性，我们得到一个关于[2.x.48]的方程，就在[2.x.50]边界的[2.x.49] 。
* [1.x.51]
* 这就是我们要找的边界积分方程（BIE），其中[2.x.51]这个量是点[2.x.52]看到积分域[2.x.53]的角度或实体角的分数。
* 特别是，在边界[2.x.55]可微的点[2.x.54]（即光滑），我们有[2.x.56]，但在边界有角或边的点，该值可能较小或较大。
* 代入单层和双层算子，我们得到：二维流动的[1.x.52]和三维流动的[1.x.53]，其中基本决议的法向导数被写成一种形式，使计算更容易。在这两种情况下，[2.x.57]都是完全在边界上提出的积分方程的解，因为[2.x.58]。
* 注意，点[2.x.60]看到域[2.x.61]的角度（2D）或实体角（3D）的分数[2.x.59]可以用双层势本身来定义：[1.x.54] 。
* 如果我们考虑到纯诺伊曼问题的解在一个任意常数[2.x.62]内是已知的，这意味着，如果我们将诺伊曼数据设置为零，那么任何常数[2.x.63]都将是一个解，就可以理解这一点。
* [1.x.55]
* [2.x.64]上的积分是统一的，见上文，所以除以常数[2.x.65]，我们就得到了上面[2.x.66]的明确表达式。
* 虽然本例程序实际上只关注边界积分方程的求解，但在现实的设置中，我们仍然需要对速度进行求解。为此，请注意，我们刚刚计算了[2.x.67]的所有[2.x.68]。在下一步，我们可以在所有的[2.x.70]中计算（如果我们想的话，可以用分析法）解[2.x.69]。为此，回顾一下我们的[1.x.56]，现在我们有了右手边的所有东西（[2.x.71]和[2.x.72]是我们可以评估的积分，边界上的法线速度是给定的，边界上的[2.x.73]我们刚刚计算过）。最后，我们可以将速度恢复为[2.x.74] 。
* 注意，对[2.x.75]的上述公式的评估结果应该是零，因为狄拉克三角[2.x.76]在域[2.x.77]的积分根据定义总是零。
* 作为最后的测试，让我们验证这个速度是否确实满足静止流场的动量平衡方程，也就是说，对于某个（未知）压力[2.x.80]和一个给定的常数[2.x.81]，[2.x.78]是否在[2.x.79]中。换句话说，我们想验证上面所说的伯努利定律是否真的成立。为了证明这一点，我们用这个方程的左手边等于
* [1.x.57]
*其中我们使用了[2.x.82]是常数。我们想把这个表达式写成某个东西的梯度（记住[2.x.83]是一个常数）。如果我们单独考虑方程的各个部分（对出现两次的指数求和是隐含的），那么下一步就比较方便了。
* [1.x.58]
*因为[2.x.84]和[2.x.85] 。接下来。
* [1.x.59]
* 同样，最后一项消失了，因为[2.x.86]是常数，我们可以将第一项和第三项合并为一项。
* [1.x.60]
*
* 我们现在只需要对最后一项再做一些按摩。使用乘积规则，我们得到
* [1.x.61]
* 这些项中的第一个是零（因为，同样，对[2.x.87]的求和得到[2.x.88]，它是零）。最后一项可以写成[2.x.89]，它是理想的梯度形式。因此，我们现在可以最终说明
* [1.x.62]
* 或者以矢量形式：[1.x.63]或者换句话说：[1.x.64]因为压力只确定到一个常数（它在方程中只出现梯度），一个同样有效的定义是[1.x.65]这正是上面提到的伯努利定律。
*

*[1.x.66][1.x.67]


* 边界积分方程(BIE)的数值近似通常被称为边界元素法或面板法(后者主要用于计算流体力学界)。以下测试问题的目标是解决具有Neumann边界条件的拉普拉斯方程的积分形式，分别使用一个圆和一个球体在两个和三个间隔维中，沿途说明了允许人们使用deal.II库处理边界元素问题几乎与有限元问题一样容易。
* 为此，如果[2.x.93]，让[2.x.90]是将平面[2.x.91]细分为[2.x.92]条线段，如果[2.x.95]，让[2.x.94]条四边形。我们将每个单独的线段或四边形称为[1.x.68]或[1.x.69]，与周围空间[2.x.97]的维度[2.x.96]无关。我们将有限维空间[2.x.98]定义为[1.x.70]，基函数[2.x.99]，我们将使用通常的FE_Qfinite元素，但这次是定义在一个一维的流形上（我们通过使用第二个模板参数来做到这一点，通常默认为等于第一个；这里，我们将在一个[2.x.100] 。 [2.x.103]的一个元素[2.x.102]被其系数[2.x.105]的向量[2.x.104]所唯一识别，即：[1.x.71]，其中的求和隐含在重复索引中。请注意，我们可以在这里使用连续的元素；事实上，没有真正的理由使用连续的元素，因为积分公式并没有对我们的试验函数施加任何导数，所以连续性是不必要的，而且在文献中通常只使用片状常数元素。
*[1.x.72][1.x.73]
*

* 到目前为止，最常见的边界积分方程的近似方法是使用基于边界元素的配位法。
* 这种方法要求在一定数量的同位点上对边界积分方程进行评估，同位点的数量等于系统的未知数。这些点的选择是一个微妙的问题，需要仔细研究。假设这些点暂时是已知的，并称它们为[2.x.106]和[2.x.107]。
* 那么问题就变成了：给定基准点[2.x.108]，在[2.x.110]中找到一个函数[2.x.109]，使以下[2.x.111]方程得到满足。
* [1.x.74]
* 其中数量[2.x.112]是点[2.x.113]看到域[2.x.114]的（实体）角度的分数，如上所述，我们设置[2.x.115]为零。  如果适当地选择支持点[2.x.116]，那么问题可以写成以下线性系统。
* [1.x.75]
* 其中
* [1.x.76]
* 从线性代数的角度来看，最佳的坐标点选择是使矩阵[2.x.117]成为最对角线主导的。一个自然的选择是选择[2.x.118]坐标点作为节点基函数[2.x.119]的支持点。在这种情况下，[2.x.120]，因此矩阵[2.x.121]是对角线，其条目[1.x.77]，我们用[2.x.122]作为通常的Lagrangeelements。]、[2.x.124]和右手边[2.x.125]的计算需要对三角形[2.x.126]的元素进行奇异积分的评估。].在这些情况下，通常所有的积分都是在一个参考简单域上进行的，也就是说，我们假设[2.x.129]的每个元素[2.x.128]可以表示为参考边界元素[2.x.130]的线性（二维）或双线性（三维）变换，并且我们在从实数元素[2.x.131]到参考元素[2.x.132]的变量改变后进行积分。
*[1.x.78][1.x.79] 。
*

* 在二维空间中，没有必要计算系统矩阵的对角线元素[2.x.133]，因为即使分母在[2.x.134]时归零，分子也总是为零，因为[2.x.135]和[2.x.136]是正交的（在我们对[2.x.137]边界的多边形近似上），唯一的奇异积分出现在对[2.x.138]的第i个元素的计算上：[1.x.80]
* 这可以通过QGaussLogR正交公式轻松处理。
* 同样地，也可以用QGaussOneOverR正交公式来进行三维的奇异积分。有兴趣的读者可以在其文档中找到关于这些正交规则如何工作的详细解释。
* 结果矩阵[2.x.140]是完整的。根据其大小，使用直接求解器或迭代求解器可能比较方便。为了这个例子代码的目的，我们选择只使用迭代求解器，而不提供任何预处理程序。
* 如果这是一个生产代码，而不是一个原理的演示，有一些技术可以不存储完整的矩阵，而只存储那些大的和/或相关的条目。在关于边界元素方法的文献中，有大量的方法可以确定哪些元素是重要的，哪些是不重要的，从而使这些矩阵的表示明显地更加稀疏，也有利于快速评估向量和矩阵之间的标量积。这不是本程序的目标，我们把它留给更复杂的实现方式。
*

*[1.x.81][1.x.82]


* 实现是相当直接的。在以前的教程中没有使用过的主要一点是，deal.II中的大多数类不仅在维度上有模板，而且实际上在我们提出微分方程的流形的维度以及这个流形嵌入的空间的维度上也有模板。默认情况下，第二个模板参数等于第一个，这意味着我们要在二维空间的二维区域内求解。在这种情况下，要使用的三角类是[2.x.141]，这相当于写成[2.x.142]。
* 然而，情况并非如此：在目前的例子中，我们想在一个球体的表面上求解，这是一个嵌入三维空间的二维法域。因此，正确的类将是[2.x.143]，相应地，我们将使用[2.x.144]作为DoF处理类，[2.x.145]作为有限元。
* 关于人们可以对生活在曲面上的事物做什么的一些进一步细节，可以在报告[1.x.83][1.x.84]中找到。此外，[2.x.146]教程程序将我们在这里展示的内容扩展到流形上提出的方程不是积分算子而实际上涉及导数的情况。
*

*[1.x.85][1.x.86]


* 我们要解决的测试案例是一个圆形（2D）或球形（3D）的障碍物。这些几何体的网格将从当前目录下的文件中读入，然后将一个SphericalManifold类型的对象附加到三角形上，以允许网格细化，从而尊重离散初始网格背后的连续几何体。
* 对于一个半径为[2.x.147]的球体，以[2.x.148]的速度向[2.x.149]方向平移，其势为
* [1.x.87]
* 见，例如J.N. Newman, [1.x.88], 1977,pp.127.对于单位速度和半径，并限制[2.x.150]位于球体表面，[2.x.151] 。在试验问题中，流向是[2.x.152]，所以球面上适当的精确解是上述解与沿[2.x.153]和[2.x.154]轴的类似解的叠加，即[2.x.155] 。
*

* [1.x.89] [1.x.90]。
* [1.x.91] [1.x.92]。



* 程序开始时包括一堆include文件，我们将在程序的各个部分使用这些文件。其中大部分已经在以前的教程中讨论过了。
*


* [1.x.93]
*
* 这里还有一些我们需要的C++标准头文件。
*


* [1.x.94]
*
* 本序言的最后部分是将dealii命名空间中的所有内容导入到本程序中的所有内容中。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。


*
*首先，让我们定义一下边界积分方程的机制。
*

*
* 以下两个函数是单层和双层势能核的实际计算，即 [2.x.156] 和 [2.x.157] 。只有当矢量[2.x.158]不同于零时，它们才是定义良好的。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 边界元素方法代码的结构与有限元素代码的结构非常相似，因此该类的成员函数与其他大多数教程程序的成员函数一样。特别是，现在你应该已经熟悉了从外部文件中读取参数，以及将不同的任务分割成不同的模块。这同样适用于边界元素方法，我们不会对其进行过多的评论，只是说说其中的区别。
*


* [1.x.101]

* 我们在这里发现的唯一真正不同的函数是装配程序。我们以最可能的通用方式编写了这个函数，以便能够方便地推广到高阶方法和不同的基本解（例如斯托克斯或麦克斯韦）。     
* 最明显的区别是，最终的矩阵是完整的，而且我们在通常的单元格循环内有一个嵌套的循环，访问所有自由度的支持点。  此外，当支持点位于我们所访问的单元内时，我们所执行的积分就会变成单数。     
* 实际结果是，我们有两套正交公式、有限元值和临时存储，一套用于标准积分，另一套用于奇异积分，在必要时使用。
*


* [1.x.102]
*
* 这个问题的解决有两个选项。第一个是使用直接求解器，第二个是使用迭代求解器。我们选择了第二种方案。     
* 我们组装的矩阵不是对称的，我们选择使用GMRES方法；然而为边界元素方法构建一个有效的预处理程序并不是一个简单的问题。这里我们使用了一个非预处理的GMRES求解器。迭代求解器的选项，如公差、最大迭代次数等，都是通过参数文件选择的。
*


* [1.x.103]
*
* 一旦我们得到了解决方案，我们就计算计算势的[2.x.159]误差以及实体角的近似值的[2.x.160]误差。我们使用的网格是平滑曲线的近似值，因此计算出的角的分量或实体角的对角线矩阵 [2.x.161] 应该一直等于 [2.x.162] 。在这个例程中，我们输出势的误差和计算角度的近似值的误差。注意，后者的误差实际上不是计算角度的误差，而是我们对球体和圆的近似程度的衡量。     
* 对角度的计算做一些实验，对于较简单的几何形状，可以得到非常准确的结果。为了验证这一点，你可以在read_domain()方法中注释掉tria.set_manifold(1, manifold)一行，并检查程序生成的alpha。通过删除这个调用，每当细化网格时，新的节点将沿着构成粗略网格的直线放置，而不是被拉到我们真正想要近似的表面。在三维案例中，球体的粗网格是从一个立方体开始得到的，得到的字母值在面的节点上正好是[2.x.163]，在边的节点上是[2.x.164]，在顶点的八个节点上是[2.x.165]。
*


* [1.x.104]
*
* 一旦我们在一维领域得到了一个解，我们就想把它插值到空间的其他部分。这可以通过在compute_exterior_solution()函数中再次进行解与核的卷积来完成。     
* 我们想绘制速度变量，也就是势解的梯度。势解只在边界上是已知的，但我们使用与基本解的卷积在标准的二维连续有限元空间上进行插值。外推解的梯度图将给我们提供我们想要的速度。     
* 除了外域上的解，我们还在output_results()函数中输出域的边界上的解，当然了。
*


* [1.x.105]
*
* 为了允许不受维度限制的编程，我们对这个单一的函数进行了专业化处理，以提取整合单元内部的奇异核所需的奇异正交公式。
*


* [1.x.106]
*
* 通常的deal.II类可以通过指定问题的 "cod dimension "来用于边界元素方法。这是通过将Triangulation, FiniteElement和DoFHandler的可选第二模板参数设置为嵌入空间的维度来实现的。在我们的例子中，我们生成了嵌入到2或3维空间的1或2维网格。     
* 可选的参数默认等于第一个参数，并产生我们在之前所有例子中看到的通常的有限元类。     
* 该类的构造方式是允许任意的域（通过高阶映射）和有限元空间的逼近顺序。有限元空间和映射的顺序可以在该类的构造函数中选择。
*


*


* [1.x.107]
*
* 在BEM方法中，生成的矩阵是密集的。根据问题的大小，最终的系统可能通过直接的LU分解来解决，或者通过迭代方法来解决。在这个例子中，我们使用了一个无条件的GMRES方法。为BEM方法建立一个预处理程序是不容易的，我们在此不做处理。
*


*


* [1.x.108]
*
* 接下来的两个变量将表示解决方案[2.x.166]以及一个向量，它将保持[2.x.167]的值（从一个点[2.x.169]可见的[2.x.168]的部分）在我们形状函数的支持点。
*


*


* [1.x.109]
*
*收敛表用于输出精确解和计算的字母的误差。
*


*


* [1.x.110]

* 以下是我们通过参数文件填充的变量。  在这个例子中，我们使用的新对象是[2.x.170]对象和QuadratureSelector对象。     
* [2.x.171]类允许我们通过参数文件轻松快速地定义新的函数对象，自定义的定义可以非常复杂（所有可用的选项见该类的文档）。     
* 我们将使用QuadratureSelector类来分配正交对象，该类允许我们根据一个识别字符串和公式本身的可能程度来生成正交公式。我们用它来允许自定义选择标准积分的正交公式，并定义奇异正交规则的顺序。     
* 我们还定义了几个参数，这些参数是在我们想把解决方案扩展到整个领域的情况下使用的。
*


*


* [1.x.111]
*
* [1.x.112] [1.x.113]。


*
* 构造函数初始化各种对象的方式与有限元程序（如 [2.x.172] 或 [2.x.173] ）中的方式基本相同。这里唯一的新成分是ParsedFunction对象，它在构造时需要说明组件的数量。   
* 对于精确解来说，向量分量的数量是1，而且不需要任何操作，因为1是ParsedFunction对象的默认值。然而，风需要指定dim组件。注意，在为[2.x.174]的表达式声明参数文件中的条目时，我们需要明确指定分量的数量，因为函数[2.x.175]是静态的，对分量的数量没有了解。
*


* [1.x.114]
*
* 对于二维和三维，我们将默认的输入数据设置为：解是[2.x.176]或[2.x.177] 。实际计算出的解在无穷大时的值为零。在这种情况下，这与精确解相吻合，不需要额外的修正，但是你应该意识到，我们任意设置[2.x.178]，而我们传递给程序的精确解需要在无穷远处有相同的值才能正确计算出误差。     
* [2.x.179]对象的使用是非常直接的。[2.x.180]函数需要一个额外的整数参数，指定给定函数的分量数量。它的默认值是1。当相应的[2.x.181]方法被调用时，调用对象必须有与这里定义的相同数量的组件，否则会产生异常。     
* 在声明条目时，我们同时声明二维和三维的函数。然而，最终只有二维的那个被解析。这使得我们对二维和三维的问题都只有一个参数文件。     
* 注意，从数学的角度来看，边界上的风函数应该满足条件[2.x.182]，这样问题才有解。如果不满足这个条件，那么就找不到解，求解器也不会收敛。
*


* [1.x.115]
*
* 在求解器部分，我们设置所有的SolverControl参数。然后，该对象将被送入GMRES求解器的solve_system()函数中。
*


* [1.x.116]
*
* 在向ParameterHandler对象声明了所有这些参数后，让我们读取一个输入文件，该文件将给这些参数提供它们的值。然后我们继续从ParameterHandler对象中提取这些值。
*


* [1.x.117]
*
* 最后，这里还有一个例子说明如何在独立维度编程中使用参数文件。  如果我们想关闭两个模拟中的一个，我们可以通过设置相应的 "运行2D模拟 "或 "运行3D模拟 "标志为假来实现。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 边界元素法三角剖分基本上与（dim-1）维三角剖分相同，不同的是，顶点属于（dim）维空间。   
* deal.II中支持的一些网格格式默认使用三维点来描述网格。这些格式与deal.II的边界元素方法功能兼容。特别是我们可以使用UCD或GMSH格式。在这两种情况下，我们必须特别注意网格的方向，因为与标准有限元的情况不同，这里没有进行重新排序或兼容性检查。  所有的网格都被认为是有方向性的，因为它们被嵌入到一个高维空间中。参见GridIn和Triangulation的文档，以进一步了解三角结构中单元的方向。在我们的例子中，网格的法线是外在于2D的圆和3D的球体。   
* 对边界元素网格进行适当细化所需要的另一个细节是对网格所逼近的流形的准确描述。对于标准有限元网格的边界，我们已经看到过多次（例如在[2.x.183]和[2.x.184]中），这里的原理和用法是一样的，只是SphericalManifold类需要一个额外的模板参数来指定嵌入空间的维度。
*


*


* [1.x.121]
*
* 对[2.x.185]的调用复制了流形（通过[2.x.186]，所以我们不需要担心对[2.x.187]的无效指针。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 这个函数全局地细化网格，分配自由度，并调整矩阵和向量的大小。
*


*


* [1.x.125]
*
* [1.x.126] [1.x.127]。



* 下面是这个程序的主要功能，组装与边界积分方程相对应的矩阵。
*


* [1.x.128]
*
* 首先，我们用正交公式初始化一个FEValues对象，用于在非奇异单元中进行核的积分。这个正交公式是通过参数文件选择的，并且需要相当精确，因为我们要积分的函数不是多项式函数。
*


* [1.x.129]
*
* 与有限元方法不同，如果我们使用拼合边界元方法，那么在每个装配循环中，我们只装配指一个自由度（与支撑点[2.x.188]相关的度）和当前单元之间的耦合信息。这是用一个fe.dofs_per_cell元素的向量完成的，然后它将被分配到全局行的矩阵中 [2.x.189] 。以下对象将持有这些信息。
*


* [1.x.130]
*
* 指数[2.x.190]在拼合点上运行，这些拼合点是[2.x.191]个基函数的支持点，而[2.x.192]在内部积分点上运行。
*

*
* 我们构建一个支持点的向量，它将被用于局部积分。
*


* [1.x.131]
*
* 这样做之后，我们就可以开始对所有单元进行积分循环，首先初始化FEValues对象，得到正交点的[2.x.193]的值（这个向量场应该是常数，但更通用也无妨）。
*


* [1.x.132]
*
* 然后我们在当前单元上形成所有自由度的积分（注意，这包括不在当前单元上的自由度，这与通常的有限元积分有偏差）。如果其中一个局部自由度与支持点[2.x.194]相同，我们需要执行的积分是单数。因此，在循环的开始，我们检查是否是这种情况，并存储哪一个是奇异索引。
*


* [1.x.133]

* 然后我们进行积分。如果指数[2.x.195]不是局部自由度之一，我们只需将单层项加到右边，将双层项加到矩阵中。
*


* [1.x.134]

* 现在我们处理更微妙的情况。如果我们在这里，这意味着在[2.x.196]索引上运行的单元包含support_point[i]。在这种情况下，单层和双层电势都是单数，它们需要特殊处理。                 
* 每当在给定的单元内进行积分时，都会使用一个特殊的正交公式，允许人们对参考单元上的奇异权重进行任意函数的积分。                 
* 正确的正交公式是由get_singular_quadrature函数选择的，下面将详细说明。
*


* [1.x.135]
*
* 最后，我们需要将当前单元格的贡献添加到全局矩阵中。
*


* [1.x.136]
*
* 积分算子的第二部分是术语 [2.x.197] 。由于我们使用的是配位方案，[2.x.198]和相应的矩阵是一个对角线，其条目等于[2.x.199] 。
*

*
* 计算这个实体角的对角线矩阵的一个快速方法是使用诺伊曼矩阵本身。只需将该矩阵与一个元素的矢量相乘，这些元素都等于
*
* - ，得到阿尔法角或实体角的对角矩阵（见介绍中的公式）。然后将这个结果加回到系统矩阵对象上，得到矩阵的最终形式。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 下一个函数简单地解决了线性系统。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。


*
* 误差的计算在其他所有的例子程序中都是完全一样的，我们就不做过多的评论。请注意，这里可以使用有限元方法中的相同方法。
*


* [1.x.143]
*
*α向量的误差可以直接使用[2.x.200]函数来计算，因为在每个节点上，该值应该是[2.x.201] 。然后，所有的误差都被输出并附加到我们的ConvergenceTable对象中，以便以后计算收敛率。
*


* [1.x.144]
*
* 奇异积分需要仔细选择正交规则。特别是deal.II库提供的正交规则是为对数奇异性（QGaussLog, QGaussLogR）以及1/R奇异性（QGaussOneOverR）量身定做的。   
* 奇异积分通常是通过构建具有奇异权重的加权正交公式得到的，因此可以写成
* [1.x.145]
* 其中[2.x.202]是一个给定的奇点，权重和正交点[2.x.203]是精心选择的，以使上述公式对某类函数[2.x.204]是一个等式。   
* 在我们迄今为止看到的所有有限元例子中，正交点本身的权重（即函数[2.x.205]），总是不断等于1。  对于奇异积分，我们有两个选择：我们可以使用上面的定义，从积分中剔除奇异性（即用特殊的正交规则对[2.x.206]进行积分），或者我们可以要求正交规则用[2.x.208]对权重[2.x.207]进行 "标准化"。
* [1.x.146]
* 我们通过QGaussLogR和QGaussOneOverR的[2.x.209]参数，使用这第二个选项。   
* 这些积分有些微妙，特别是在二维空间，由于从实数到参考单元的转换，积分的变量会随着转换的行列式而缩放。   
* 在二维空间中，这个过程不仅导致一个因子作为常数出现在整个积分上，而且还导致一个需要评估的额外积分。   
* [1.x.147]
* 这个过程由QGaussLogR类的构造函数来处理，它增加了额外的正交点和权重，以考虑到积分的第二部分。   
* 类似的推理应该在三维情况下进行，因为奇异正交是在参考单元的半径[2.x.210]的逆上定制的，而我们的奇异函数生活在实空间，然而在三维情况下一切都更简单，因为奇异性与变换的行列式呈线性比例。这使得我们可以只建立一次奇异的二维正交规则，并在所有单元中重复使用它们。   
* 在一维的奇异积分中，这是不可能的，因为我们需要知道正交的缩放参数，而这个参数并不是先验的。这里，正交规则本身也取决于当前单元的大小。由于这个原因，有必要为每个奇异积分创建一个新的正交法则。   
* 不同的正交规则是在get_singular_quadrature中建立的，它专门用于dim=2和dim=3，它们在assemble_system函数中被检索。作为参数给出的索引是奇点所在的单位支持点的索引。
*


*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 我们还想知道一些关于外域中电势[2.x.211]的值：毕竟我们考虑边界积分问题的动机是我们想知道外域中的速度!   
* 为此，我们在此假设边界元素域包含在盒子[2.x.212]中，我们用与基本解的卷积来推算这个盒子内的实际解。这方面的公式在引言中已经给出。   
* 整个空间的解的重构是在一个维数为dim的连续有限元网格上完成的。这些都是常见的，我们不做进一步评论。在函数结束时，我们再次以通常的方式输出这个外部解。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 输出我们的计算结果是一个相当机械的任务。这个函数的所有组成部分在前面已经讨论过了。
*


* [1.x.154]

* [1.x.155] [1.x.156]。


*
* 这是最主要的功能。它应该是不言自明的简短。



* [1.x.157]
*
* [1.x.158] [1.x.159]。



* 这是本程序的主要功能。它和以前所有的教程程序完全一样。



* [1.x.160]
* [1.x.161][1.x.162] 。


* 我们使用以下[2.x.213]文件（也可以在所有其他源文件所在的目录中找到）运行该程序。
* [1.x.163]

*当我们运行该程序时，屏幕上打印出以下内容。
* [1.x.164]

* 从2d中的收敛表可以看出，如果我们选择足够精确的正交公式，那么我们对[2.x.214]得到的误差应该正好是元素数的倒数。用N个大小相等的线段对圆进行近似，会产生一个有N个面的正多边形，其角度正好是[2.x.215]，因此我们的误差应该正好是[2.x.216] 。事实上，这是一个很好的指标，表明我们正在以适当的方式进行奇异积分。
* 势的近似[2.x.217]的误差主要是由于域的近似造成的。通过使用高阶映射可以获得更好的近似值。
* 如果我们修改main()函数，将fe_degree和mapping_degreet设置为2，并提高参数文件中正交公式的阶数，我们可以得到以下二维模拟的收敛表
* [1.x.165]
*
*和
* [1.x.166]
*
*为三维情况。我们可以看到，高阶映射的收敛结果要好得多，这主要是由于曲线几何的分辨率更高。请注意，在自由度相同的情况下，例如在三维模拟中Q1情况的第3步和Q2情况的第2步，误差大约要低三个数量级。
* 运行这些计算的结果是一堆输出文件，我们可以将其传递给我们选择的可视化程序。输出文件有两种：边界元素表面的势，以及扩展到外部和内部领域的势。在二维情况下，这两个文件的组合看起来像
* [2.x.218]
* 而在三维情况下，我们首先显示的是表面上的势，同时还有一个等高线图。
* [2.x.219]
* 然后是势的外部等高线图，不透明度设置为25%。
* [2.x.220]
*

* [1.x.167][1.x.168][1.x.169] 。


* 这是第一个考虑解决嵌入高维空间的表面上定义的方程的教程程序。但这里讨论的方程相对简单，因为它只涉及到一个积分算子，而不是在曲面上更难定义的导数。[2.x.221]教程程序考虑了这类问题并提供了必要的工具。
* 从实践的角度来看，这里使用的边界元素法（BEM）有两个瓶颈。首先是组装矩阵的成本与未知数的数量成二次方，即[2.x.222]，其中[2.x.223]是未知数的总数量。通过查看 "assemble_system() "函数可以看出，它的结构是这样的。
* [1.x.170]
* 这里，第一个循环遍历了所有单元（[2.x.224]的一个因子），而内循环则贡献了[2.x.225]的另一个因子。
* 这必须与局部*的有限元方法进行对比。
微分算子。在那里，我们在所有单元上循环（一个[2.x.226]的因子），在每个单元上做的工作与有多少个单元或未知数无关。这显然是一个瓶颈。
* 第二个瓶颈是系统矩阵是密集的（即是FullMatrix类型），因为每个自由度都与其他自由度耦合。如上所述，仅仅计算*这个带有[2.x.227]非零项的矩阵必然需要至少[2.x.228]次操作，但值得指出的是，仅仅做一个矩阵-向量乘积也要花费这么多操作。如果用于求解线性系统的GMRES方法需要的运算次数随着问题的大小而增加，这就是典型的情况，那么求解线性系统需要的运算次数甚至比[2.x.229]还要快。
* 真正的 "边界元素方法 "通过确定矩阵的哪些项是小的，因而可以忽略的策略来解决这些问题（当然，代价是引入一个额外的错误）。这可以通过认识到矩阵项随着自由度[2.x.230]和[2.x.231]定义的位置之间的（物理）距离衰减而实现。这一点可以在快速多极法（FMM）等方法中得到利用，这些方法可以控制哪些矩阵条目必须被存储和计算以达到一定的精度，以及
*
* - 如果做得好的话
*
* - 导致方法中，线性系统的组装和解决都需要少于[2.x.232]的操作。
* 实现这些方法显然提供了扩展当前程序的机会。
*

* [1.x.171][1.x.172] [2.x.233] 。
* [0.x.1]

