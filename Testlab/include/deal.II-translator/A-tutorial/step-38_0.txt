include/deal.II-translator/A-tutorial/step-38_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.2] 
* [1.x.20]
* [1.x.21]
* [1.x.22][1.x.23]。
 

* 在这个例子中，我们展示了如何在一个由四边形组成的一维表面[2.x.3]上求解偏微分方程（PDE），即在三维的表面或二维的线上。
* [1.x.24]
我们专注于以下的椭圆二阶PDE * [1.x.24]，它概括了我们以前在几个早期教程程序中解决的拉普拉斯方程。我们的实现是基于 [2.x.4] 。 [2.x.5]也解决了低维曲面上的问题；然而，在那里我们只考虑不涉及解变量上的导数的积分方程，而在这里我们实际上必须研究只在（可能是弯曲的）曲面上定义的函数的导数意味着什么。
* 让[2.x.6]是参考元素[2.x.8]对曲面[2.x.7]的参数化，即每个点[2.x.9]诱导一个点[2.x.10]。然后让[1.x.25]表示相应的第一基本形式，其中[2.x.11]是映射的导数（Jacobian）。 ] 或者，对有限元方法来说更方便的是任何一个面[2.x.14]，其中[2.x.15]是[2.x.16]的一个由四边形组成的分区（三角形）。我们现在可以通过[1.x.26]定义一个函数[2.x.17]的切向梯度。 表面拉普拉斯(Laplacian)(也称为Laplace-Beltrami算子)定义为[2.x.18] 。请注意，在光滑表面上计算表面梯度[2.x.19]的另一种方法是[1.x.27]，其中[2.x.20]是[2.x.21]的 "光滑 "延伸。 ]在[2.x.22]的管状邻域的 "平滑 "延伸，[2.x.23]是[2.x.24]的法线。由于[2.x.25]，我们推导出[1.x.28]值得一提的是，上述表达中出现的项[2.x.26]是曲面的总曲率（主曲率之和）。
* 像往常一样，我们只对弱解感兴趣，我们可以使用[2.x.27]有限元（而不是像强解那样要求[2.x.28]的连续性）。因此，我们求助于弱公式[1.x.29]，并利用分区[2.x.29]来进一步写出[1.x.30]此外，上述表达式中的每个积分都是在参考元素[2.x.30]中计算的，以便
* [1.x.31]
*和[1.x.32]最后，我们使用由点[2.x.31]和权重[2.x.32]定义的正交公式来评价上述积分，得到[1.x.33]和[1.x.34]
* 

* 幸运的是，deal.II已经有了计算上述表达式的所有工具。事实上，它们与我们求解通常的拉普拉斯的方式几乎没有区别，只需要在FEValues类的构造器中提供表面坐标映射。这个表面描述给出了，在二维表面情况下，两个程序[2.x.33]和[2.x.34]返回
* [1.x.35]
* 这正好提供了我们的计算所需要的条件。
* 在更广泛的意义上，表面有限元逼近的细节可以在[Dziuk, in Partial differential equations and calculus ofvariations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009]和[Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010]找到。
* 

* 
* [1.x.36][1.x.37] 。
* 

* 一般来说，当你想用数值测试算法的准确性和/或收敛性时，你需要提供一个精确的解决方案。通常的技巧是选择一个我们希望成为解决方案的函数，然后对其应用微分算子，为右手边定义一个强制项。这就是我们在这个例子中所做的。在当前情况下，域的形式显然也是至关重要的。
* 我们为一个二维问题和另一个三维问题制作了一个测试案例。
* [2.x.35] [2.x.36] 在2D中，让我们选择一个半圆作为域。在这个域上，我们选择函数[2.x.37]作为解决方案。为了计算右手边，我们必须计算解函数的表面拉普拉斯。有（至少）两种方法可以做到这一点。第一种是使用[2.x.38]的自然延伸（仍然用[2.x.39]表示）在[2.x.40]上投影掉上述的法向导数，即计算[1.x.38]，其中[2.x.41]是[2.x.42]的总曲率。 由于我们在单位圆上，[2.x.43]和[2.x.44]所以[1.x.39]。
* 一个更简单的方法，至少对于目前二维空间中的曲线的情况，是注意到我们可以用变换[2.x.47]将区间[2.x.45]映射到域[2.x.46]。 在位置[2.x.48]，解的值是[2.x.49]。 考虑到变换是保长的，即长度为[2.x.50]的一段曲线被映射到长度完全相同的一段曲线上，那么切向拉普拉斯就满足以下条件 
* [1.x.40]
*这当然与我们上面的结果相同。[2.x.51] [2.x.52] 在三维中，域又是单位球表面的一半，即半球形或穹顶。我们选择[2.x.53]作为解决方案。我们可以用上面的方法计算方程的右边，[2.x.54]，（用[2.x.55]），得到一个笨拙而冗长的表达。你可以在源代码中找到完整的表达式。[2.x.56] [2.x.57]。
* 在程序中，我们还将计算出解的[2.x.58]半正态误差。由于解函数及其数值近似只在流形上定义，这个误差函数的明显定义是[2.x.59] 。这就要求我们为函数[2.x.61]（首次在[2.x.62]中介绍）提供[1.x.41]梯度[2.x.60]，我们将通过在下面的程序中实现函数[2.x.63]来实现。
* 

*[1.x.42][1.x.43]。
* 

* 如果你已经读完了[2.x.64]，并且理解了上面关于解决方案和右手边如何对应的讨论，你也会立即熟悉这个程序。事实上，只有两件事情是有意义的。
* 
* - 我们生成三角形计算域的网格的方式。
* 
* - 我们使用映射对象来描述我们解决偏微分方程的领域不是平面的，实际上是弯曲的。
* 映射对象已经在[2.x.65]和[2.x.66]中介绍过了，正如那里所解释的那样，只要你对边界的外观有一个有效的描述，你通常不需要知道它们是如何工作的。实质上，我们将简单地声明一个适当的MappingQ类型的对象，它将自动从三角测量中获得边界描述。然后，映射对象将被传递给适当的函数，我们将得到库中预定义的半圆或半球形的边界描述。
* 程序的其余部分紧跟[2.x.67]，就计算误差而言，紧跟[2.x.68]。这个程序的某些方面，特别是在Triangulation、DoFHandler和类似的类上使用两个模板参数，已经在[2.x.69]中作了详细描述；你可能希望也读一下这个教程程序。
* 

* [1.x.44] [1.x.45]。
* [1.x.46] [1.x.47]。
 

* 
* 如果你读过[2.x.70]和[2.x.71]，你会认识到我们已经在那里使用了以下所有的包含文件。因此，我们不会在这里再次解释它们的含义。
* 

* 
* [1.x.48]
* 
* [1.x.49] [1.x.50]。
 

* 
* 这个类几乎与 [2.x.73] 中的 [2.x.72] 类完全相似。
* 

* 
* 本质上的区别是这样的。
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 模板参数现在表示嵌入空间的维度，它不再与域和我们计算的三角形的维度相同。我们通过调用参数[2.x.74]并引入一个等于域的维度的常数[2.x.75]来表明这一点。
* 
* - 这里等于[2.x.76] 。
* 

* 
* 
* - 所有具有几何方面的成员变量现在都需要知道它们自己的维度以及嵌入空间的维度。因此，我们需要指定它们的模板参数，一个是网格的维度[2.x.77]，另一个是嵌入空间的维度，[2.x.78] 这正是我们在[2.x.79]中所做的，请看那里有更深的解释。
* 

* 
* 
* - 我们需要一个对象来描述从参考单元到三角形所组成的单元的哪种映射。从Mapping基类派生出来的类正是这样做的。在deal.II的大部分内容中，如果你不做任何事情，图书馆会假设你想要一个使用（双，三）线性映射的MappingQ1对象。在许多情况下，这就足够了，这就是为什么这些对象的使用大多是可选的：例如，如果你有一个二维空间中的多边形二维域，参考单元到三角形单元的双线性映射会产生该域的精确表示。如果你有一个弯曲的域，你可能想对那些位于域的边界的单元使用一个高阶映射
* 
* - 例如，这就是我们在[2.x.80]中所做的。然而，在这里我们有一个弯曲的域，而不仅仅是一个弯曲的边界，虽然我们可以用双线性映射的单元来近似它，但对所有单元使用高阶映射才是真正谨慎的。因此，这个类有一个MappingQ类型的成员变量；我们将选择映射的多项式程度等于计算中使用的有限元的多项式程度，以确保最佳近似，尽管这种等参数性不是必须的。
* 

* 
* [1.x.51]
* 
* [1.x.52] [1.x.53].
 

* 
* 接下来，让我们定义描述问题的精确解和右手边的类。这与[2.x.81]和[2.x.82]相类似，在那里我们也定义了这类对象。鉴于介绍中的讨论，实际的公式应该是不言自明的。值得关注的一点是，我们是如何使用一般模板的明确特殊化，分别定义2D和3D情况下的值和梯度函数的。除了这样做之外，另一种方法可能是定义一般的模板，并为空间维度的每个可能的值制定一个[2.x.83]声明（或一连串的[2.x.84]s）。
* 

* 
* [1.x.54]
* 
* [1.x.55] [1.x.56]。
 

* 
* 如果你知道 [2.x.85] ，程序的其余部分实际上是很不引人注目的。我们的第一步是定义构造函数，设置有限元和映射的多项式程度，并将DoF处理程序与三角形关联。
* 

* 
* [1.x.57]
 
* [1.x.58] [1.x.59]
 

* 
* 下一步是创建网格，分配自由度，并设置描述线性系统的各种变量。所有这些步骤都是标准的，除了如何创建一个描述曲面的网格。我们可以为我们感兴趣的领域生成一个网格，用一个网格生成器生成一个三角形，然后用GridIn类将其读入。或者，就像我们在这里做的，我们使用GridGenerator命名空间中的设施来生成网格。  
* 具体来说，我们要做的是这样的（围在下面的一组大括号之间）：我们使用[2.x.86]函数为半圆盘（2D）或半球（3D）生成一个[2.x.87]维的网格。这个函数将位于圆盘/球周边的所有面的边界指标设置为零，而在将整个圆盘/球分成两半的直线部分设置为一。接下来就是重点了。[2.x.88]函数创建的网格是由那些作为前一个网格的面的单元组成的，也就是说，它描述了原始（体积）网格的[1.x.60]单元。然而，我们不需要所有的面：只需要那些在圆盘或球的周边，边界指示器为零的面；我们可以用一组边界指示器来选择这些单元，并传递给[2.x.89]。   
* 有一点需要提及。为了在流形是弯曲的情况下适当地细化表面网格（类似于细化与弯曲边界相邻的单元面），三角形必须有一个对象附加在它上面，描述新顶点应该位于何处。如果你不附加这样的边界对象，它们将位于现有顶点之间的中间位置；如果你有一个具有直线边界的域（例如多边形），这是很合适的，但如果像这里一样，流形具有曲率，则不合适。因此，为了让事情正常进行，我们需要将流形对象附加到我们的（表面）三角形上，其方式与我们在1d中为边界所做的大致相同。我们创建一个这样的对象并将其附加到三角形上。  
* 创建网格的最后一步是对其进行多次细化。该函数的其余部分与以前的教程程序相同。
* 

* 
* [1.x.61]
* 
* [1.x.62] [1.x.63].
 

* 
* 下面是这个程序的中心函数，它组装了与表面拉普拉斯（Laplace-Beltrami算子）相对应的矩阵。也许令人惊讶的是，它实际上与在例如 [2.x.90] 中讨论的普通拉普拉斯算子看起来完全一样。关键是[2.x.91]函数发挥了神奇的作用：它返回[2.x.93]个形状函数在[2.x.94]个正交点的表面梯度[2.x.92]。其余的也不需要任何改变。
* 

* 
* [1.x.64]
* 
* [1.x.65] [1.x.66]。
 

* 
* 下一个函数是解决线性系统的函数。在这里，也不需要做任何改变。
* 

* 
* [1.x.67]
* 
* [1.x.68] [1.x.69]。
 

* 
* 这是一个从解决方案中生成图形输出的函数。它的大部分都是模板代码，但有两点值得指出。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
* 
* - [2.x.95]函数可以接受两种向量。一种是之前通过[2.x.96]附加的DoFHandler对象定义的每个自由度有一个值的向量，另一种是三角测量的每个单元有一个值的向量，例如，输出每个单元的估计误差。通常，DataOut类知道如何区分这两种向量：自由度几乎总是比单元多，所以我们可以通过两种向量的长度来区分。我们在这里也可以这样做，但只是因为我们很幸运：我们使用了一个半球体。如果我们用整个球体作为域和[2.x.97]元素，我们将有相同数量的单元格作为顶点，因此这两种向量将有相同数量的元素。为了避免由此产生的混乱，我们必须告诉[2.x.98]函数我们有哪种矢量。DoF数据。这就是该函数的第三个参数的作用。
* 

* 
* 
* - [2.x.99]函数可以生成细分每个单元的输出，这样可视化程序可以更好地解决弯曲流形或更高的多项式程度的形状函数。在这里，我们在每个坐标方向上对每个单元进行细分，细分的次数与使用中的有限元的多项式程度相同。
* 

* 
* [1.x.70]
* 
* [1.x.71] [1.x.72].
 

* 
* 这是最后一块功能：我们要计算数值解的误差。它是之前在 [2.x.100] 中展示和讨论的代码的逐字复制。正如介绍中提到的，[2.x.101]类提供了解决方案的（切向）梯度。为了避免只评估超融合点的误差，我们选择一个足够高阶的正交规则。
* 

* 
* [1.x.73]
* 
* [1.x.74] [1.x.75].
 

* 
* 最后一个函数提供了顶层的逻辑。它的内容是不言自明的。
* 

* 
* [1.x.76]
* 
* [1.x.77] [1.x.78]。
 

* 
* 该程序的其余部分由[2.x.102]函数占据。它完全遵循首次在[2.x.103]中介绍的一般布局，并在随后的所有教程程序中使用。
* 

* 
* [1.x.79]
* [1.x.80][1.x.81]。
* 

* 当你运行该程序时，屏幕上应打印出以下输出。
* [1.x.82]
 
* 

* 通过在[2.x.104]函数中玩弄全局细化的数量，你可以增加或减少网格细化。例如，多做一次细化，只运行三维曲面问题，产生以下输出。
* [1.x.83]
* 
* 这就是我们所期望的：将网格尺寸缩小2倍，误差就会减少4倍（记得我们使用的是双四边形元素）。从一到五次细化的全部误差序列看起来像这样，整齐地遵循理论上预测的模式。
* [1.x.84]
* 
* 最后，该程序产生的图形输出，我们可以直观地看到。下面是结果的图表。
* [2.x.105] 
* 这个程序也适用于2D中的1D曲线，而不仅仅是3D中的2D曲面。你可以通过改变 [2.x.106] 中的模板参数来测试这一点。
* [1.x.85]
* 域是一条2D的曲线，我们可以通过使用第三维（和颜色）来表示函数的值来使解决方案可视化 [2.x.107] 。这样看起来就像这样（白色的曲线是域，彩色的曲线是被挤压到第三维的解决方案，清楚地显示了曲线从域的一个象限移动到相邻象限时的符号变化）。
* [2.x.108] 
* 

* [1.x.86][1.x.87][1.x.88] 。
* 

* 只有当曲面比半球形更有趣时，曲面上的计算才变得有趣。为了达到这个目的，deal.II可以通过通常的GridIn类来读取描述曲面的网格。或者，如果你有一个分析性的描述，一个简单的网格有时可以被拉伸和弯曲成我们所感兴趣的形状。
* 让我们考虑一个相对简单的例子：我们把之前用过的半球体，在Z方向上拉伸10倍，然后把X和Y坐标拼一下。在我们讨论下面的实现细节之前，我们先展示一下计算域和解决方案。
* [2.x.109] 
* [2.x.110] 
* 产生这种网格的方法是通过使用[2.x.111]函数。它需要一个方法来转换每个单独的网格点到不同的位置。让我们在这里使用下面这个相当简单的函数（记住：在一个方向上拉伸，在另外两个方向上混杂）。
* [1.x.89]
* 
* 如果我们遵循[2.x.112]函数，我们将像以前一样提取半球形表面的网格，将其扭曲成我们想要的形状，并根据需要经常进行细化。但这并不像我们所希望的那样简单：细化要求我们有一个适当的流形对象附加到三角形上，描述细化时网格的新顶点应该位于哪里。我相信可以通过简单地撤消上面的变换（重新得到球面），找到球面上新点的位置，然后重新扭曲结果，以一种不太复杂的方式描述这个流形。但我是个懒人，既然这样做并不是真正的重点，让我们的生活变得更容易一些：我们将提取半球体，必要时对其进行细化，摆脱描述流形的对象，因为我们现在不再需要它了，然后最后对网格进行扭曲。使用上面的函数，这将看起来如下。
* [1.x.90]
* 
* 注意，唯一必要的补充是标有asterisks的那一行。这里值得指出的是：由于我们将流形描述从曲面网格中分离出来，当我们在程序的其余部分使用mapping对象时，它就没有曲线边界描述可言了。相反，它将不得不使用隐含的FlatManifold类，该类被用于域的所有部分，并被明确指定为不同的流形对象。因此，无论我们使用MappingQ(2)、MappingQ(15)还是MappingQ1，我们的网格的每个单元都将使用双线性近似进行映射。
* 撇开所有这些缺点不谈，所得到的图片仍然是漂亮的。与[2.x.113]中的内容唯一不同的是，我们将右侧改为[2.x.114]，将边界值（通过[2.x.115]类）改为[2.x.116] 。当然，我们现在不再知道确切的解决方案，所以在[2.x.117]末尾的误差计算将产生一个无意义的数字。
* 

* [1.x.91][1.x.92] [2.x.118] 。
* [0.x.1]

