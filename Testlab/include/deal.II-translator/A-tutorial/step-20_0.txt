include/deal.II-translator/A-tutorial/step-20_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
*[1.x.34][1.x.35][1.x.36] 。
* 

* [2.x.2] 
* 本程序致力于两个方面：混合有限元的使用
* 
* - 特别是Raviart-Thomas元素
* 
* 以及使用块矩阵来定义解算器、预处理器和使用系统矩阵子结构的嵌套版本。我们要解决的方程又是泊松方程，不过有一个矩阵值的系数：[1.x.37] 。
* [2.x.3]被假定为均匀正定，即有[2.x.4]使[2.x.6]的特征值[2.x.5]满足[2.x.7] 。使用符号[2.x.8]而不是通常的[2.x.9]作为解变量将在下一节中变得清晰。
* 在讨论了方程和我们要用来求解的公式之后，这个介绍将包括块状矩阵和向量的使用，求解器和预处理器的定义，以及最后我们要解决的实际测试案例。
* 我们将在[2.x.10]中扩展这个教程程序，不仅要解决混合拉普拉斯方程，还要增加一个描述两种流体混合物运输的方程。
* 这里涉及的方程属于矢量值问题的范畴。对这一主题的概述可以在[2.x.11]模块中找到。
* 

*[1.x.38][1.x.39]
* 

* 在上述形式中，泊松方程（即具有非零右边的拉普拉斯方程）通常被认为是多孔介质中流体流动的良好模型方程。当然，人们通常通过[1.x.40]来模拟流体流动，或者，如果流体速度很慢或粘度很大，则通过[1.x.41]（我们在[2.x.12]中介绍）。在这两个模型中的第一个，作用力是惯性和粘性摩擦，而在第二个，只有粘性摩擦。
* 
* - 即一个流体粒子对附近的粒子所施加的力。另一方面，如果流体被限制在孔隙中，那么孔壁对流体施加的摩擦力变得越来越重要，而内部的粘性摩擦力变得越来越不重要。后者只是泊松方程或拉普拉斯方程的一个不同名称，其内涵是指人们想要应用它的领域：多孔介质中的缓慢流动。从本质上说，速度与驱动流体通过多孔介质的负压梯度成正比。
* 达西方程对驱动流动的压力进行建模。(由于求解变量是压力，我们在此使用[2.x.13]这个名称，而不是通常用于求解偏微分方程的[2.x.14]。)这种拉普拉斯方程观点的典型应用是模拟地下水流，或油藏中的碳氢化合物流动。在这些应用中，[2.x.15]是渗透性张量，即衡量土壤或岩石基质对流体流动的阻力大小。
* 在上述应用中，数值方案的一个理想特征是它应该是局部保守的，也就是说，无论什么东西流入一个单元，也会从该单元流出（或者如果来源为零，则差值等于每个单元的源项的积分）。然而，事实证明，拉普拉斯方程的通常离散化（如[2.x.16]、[2.x.17]或[2.x.18]中使用的那些）并不满足这一特性。但是，我们可以通过选择问题的不同表述和特定的无限元空间组合来实现这一点。
* 

* [1.x.44][1.x.45] 。
* 

* 为此，我们首先引入了第二个变量，称为速度， [2.x.19] 。根据其定义，速度是压力梯度的负方向的一个矢量，乘以渗透性张量。如果渗透性张量与单位矩阵成正比，这个方程就很容易理解和直观：渗透性越高，速度就越高；速度与压力梯度成正比，从高压区到低压区（因此是负号）。
* 有了这第二个变量，就可以找到拉普拉斯方程的另一个版本，称为[1.x.46]：[1.x.47] 。
* 这里，我们将定义速度的方程[2.x.20]乘以[2.x.21]，因为这使得方程组是对称的：其中一个方程有梯度，第二个方程有负发散，这两个方程当然是彼此相邻的，结果是不对称的双线性形式，因此，在[2.x.22]是对称张量的共同假设下，是对称的系统矩阵。
* 这个问题的弱式是通过将两个方程与测试函数相乘，并将一些项分次积分而得到的：[1.x.48] 。
* 其中[1.x.49]
* 这里，[2.x.23]是边界处的外向法向量。请注意，在这种形式中，原问题的迪里希特边界值被纳入了弱的形式中。
* 为了得到良好的解决，我们必须在空间[2.x.24]中寻找[2.x.25]、[2.x.26]和[2.x.27]中寻找[2.x.28]的解和检验函数。众所周知，几乎每一本关于有限元理论的书都提到，如果选择离散的有限元空间来逼近[2.x.29]是不恰当的，那么由此产生的离散问题是不稳定的，离散的解也不会收敛到精确的解。(这里考虑的问题的一些细节
* 
* 属于 "鞍点问题 "的范畴
* 
* 可以在维基百科的[1.x.50]页面上找到）。)
* 为了克服这个问题，已经为[2.x.30]开发了一些不同的有限元对，导致了稳定的离散问题。其中一个对子是用Raviart-Thomas空间[2.x.31]处理速度[2.x.32]，用非连续元素类[2.x.33]处理压力[2.x.34] 。关于这些空间的细节，我们特别参考Brezzi和Fortin的关于混合有限元方法的书，但许多其他关于有限元理论的书，例如Brenner和Scott的经典书，也说明了相关结果。在任何情况下，在适当选择函数空间的情况下，离散的表述如下。找到[2.x.35]，以便[1.x.51]。
* 
* 

* 在继续之前，让我们简短地停顿一下，说明上述函数空间的选择为我们提供了所需的局部守恒特性。特别是，由于压力空间由不连续的片状多项式组成，我们可以选择测试函数[2.x.36]作为在任何给定单元[2.x.37]上等于1，其他地方为0的函数。如果我们也到处选择[2.x.38]（记住，上面的弱式必须对[1.x.52]离散测试函数[2.x.39]成立），那么把这些测试函数的选择放入上面的弱式表述中，特别意味着[1.x.53]
* 我们当然可以用更明确的形式写成[1.x.54]。
* 应用发散定理的结果是，对于每个单元[2.x.41]的选择，[2.x.40]必须满足[1.x.55]的关系。
* 如果你现在记得[2.x.42]是速度，那么左边的积分正是穿过单元[2.x.43]边界的（离散）通量。那么声明是，通量必须等于[2.x.44]内的源的积分。特别是，如果没有源（即[2.x.45]在[2.x.46]中），那么声明是[1.x.56]通量为零，也就是说，无论什么东西流入一个单元，都必须通过单元边界的某个其他部分流出。这就是我们所说的[1.x.57]，因为它对每个细胞都是成立的。
* 另一方面，通常的连续[2.x.47]元素在用于压力时不会产生这种属性（例如，我们在[2.x.48]中所做的），因为我们不能选择一个离散的测试函数[2.x.49]，它在一个单元[2.x.50]上为1，在其他地方为0：它将是连续的，因此不在有限元空间中。严格来说，我们只能说上面的证明对连续元素不起作用。这些元素是否仍会导致局部守恒是一个不同的问题，因为我们可以认为不同的证明可能仍然有效；然而在现实中，该属性确实不成立）。)
* 

* 
* [1.x.58][1.x.59] 。
* 

* deal.II库（当然）实现了任意阶的Raviart-Thomas元素[2.x.51][2.x.52]，以及不连续的元素[2.x.53]。如果我们暂时不考虑它们的特殊属性，那么我们就必须解决一个离散问题[1.x.60] *，该问题具有双线性形式，并且是一个不连续的问题。
*如上所述的双线性形式和右手边，以及[2.x.54] , [2.x.55]。[2.x.56]和[2.x.57]都来自空间[2.x.58]，其中[2.x.59]本身就是一个[2.x.60]维函数的空间，以适应流速为矢量值的事实。
* 矢量值元素已经在以前的教程程序中讨论过了，第一次是在[2.x.61]中详细讨论。其主要区别在于，矢量值空间[2.x.62]的所有分量都是统一的：位移矢量的[2.x.63]分量都是相等的，并且来自同一函数空间。因此，我们可以做的是把[2.x.64]作为[2.x.65]乘以通常的[2.x.66]有限元空间的外积，并以此确保我们所有的形状函数只有一个非零的矢量分量。因此，我们在[2.x.67]中所做的，不是处理矢量值的形状函数，而是查看（标量）唯一的非零分量，并使用[2.x.68]调用来计算出这实际上是哪一个分量。
* 这对Raviart-Thomas元素不起作用：由于它们的构造是为了满足空间[2.x.69]的某些规则性属性，[2.x.70]的形状函数通常在其所有矢量分量中都是不为零。由于这个原因，如果应用[2.x.71]来确定形状函数[2.x.72]的唯一非零分量，就会产生一个例外。我们真正需要做的是在[2.x.73]中获得一个形状函数的所有[2.x.74]矢量分量。在deal.II的字典里，我们把这样的有限元称为[2.x.75]非原始的[2.x.76]，而把标量的有限元或者每个向量值的形状函数只在一个向量分量中不为零的有限元称为[2.x.77]原始的[2.x.78]。
* 那么对于非原始元素，我们要怎么做呢？为了弄清楚这个问题，让我们回到教程程序中去，几乎是在最开始的时候。在那里，我们了解到我们使用[2.x.79]类来确定正交点的形状函数的值和阶差。例如，我们会调用[2.x.80]来获得[2.x.81]的形状函数在编号为[2.x.82]的正交点的值。后来，在[2.x.83]和其他教程程序中，我们了解到这个函数调用也适用于矢量值的形状函数（原始有限元），它返回正交点[2.x.85]处形状函数[2.x.84]唯一非零分量的值。
* 对于非原始形状函数，这显然是行不通的：形状函数[2.x.86]没有单一的非零向量分量，因此调用[2.x.87]就没有多大意义。然而，deal.II提供了第二个函数调用，[2.x.88]，返回正交点[2.x.89]的值[2.x.90]是介于零和当前有限元的矢量分量数量之间的索引；例如，我们将用于描述速度和压力的元素将有[2.x.91]分量。值得注意的是，这个函数调用也可以用于原始形状函数：它将简单地对除一个以外的所有分量返回零；对于非原始形状函数，它一般会对不止一个分量返回非零值。
* 我们现在可以尝试用矢量分量来重写上面的双线性形式。例如，在2d中，第一项可以这样改写（注意[2.x.92]）：[1.x.61] 。
* 如果我们实现了这一点，我们会得到这样的代码。
* [1.x.62]
* 
* 这充其量是繁琐的，容易出错的，而且不是独立的维度。有一些明显的方法可以使事情与维度无关，但最终，代码根本不漂亮。如果我们能够简单地提取形状函数[2.x.93]和[2.x.94]的分量，那就更好了。在程序中，我们以下列方式进行。
* [1.x.63]
* 
* 事实上，这不仅是双线性形式的第一项，而且是整个事情（不包括边界贡献）。
* 这段代码的作用是，给定一个[2.x.96]对象，在正交点[2.x.99]提取形状函数[2.x.98]的第一个[2.x.97]分量的值，也就是该形状函数的速度分量。换句话说，如果我们把形状函数[2.x.100]写成元组[2.x.101]，那么该函数返回这个元组的速度部分。请注意，速度当然是一个[2.x.102]维的张量，并且该函数返回一个相应的对象。类似地，当我们用压力提取器下标时，我们提取标量压力部分。整个机制在[2.x.103]模块中有更详细的描述。
* 在实践中，如果我们在每个最外层的循环中只评估一次形状函数、它们的梯度和发散，并存储结果，我们可以做得更好一些，因为这样可以节省一些重复的计算（通过提前计算所有相关的量，然后只在实际的循环中插入结果，甚至可以节省更多的重复操作，关于这种方法的实现，见[2.x.104]），最后的结果看起来像这样，在每个空间维度上工作。
* [1.x.64]
* 
* 这非常类似于我们最初写下的双线性形式和右手边的形式。
* 有一个最后的条款，我们必须注意：右手边包含条款[2.x.105]，构成压力边界条件的弱执行。我们已经在[2.x.106]中看到了如何处理面积分：本质上与域积分完全相同，只是我们必须使用FEFaceValues类，而不是[2.x.107]。为了计算边界项，我们只需在所有的边界面上进行循环并在那里进行积分。该机制的工作方式与上述相同，也就是说，提取器类也对FEFaceValues对象工作。
* [1.x.65]
* 
* 你会在本程序的源代码中找到与上述完全相同的代码。因此，我们在下面将不作过多评论。
* 

* [1.x.66][1.x.67] 。
* 

* 在组装好线性系统后，我们面临着解系统的任务。这里的问题是，矩阵拥有两个不理想的特性。
* 
* - 它是[1.x.68]，也就是说，它有正负两个特征值。 我们不想在此证明这一特性，但请注意，所有形式为[2.x.108]的矩阵都是如此，如这里的[2.x.109]是正定的。
* 
* - 矩阵的右下方有一个零块（在双线性形式中没有将压力[2.x.110]与压力测试函数[2.x.111]耦合的项）。
* 至少它是对称的，但是上面的第一个问题仍然意味着共轭梯度法是行不通的，因为它只适用于矩阵是对称和正定的问题。我们将不得不求助于其他迭代求解器，如MinRes、SymmLQ或GMRES，它们可以处理不确定的系统。然而，下一个问题立即浮现。由于零块的存在，对角线上有零，通常的 "简单 "预处理程序（Jacobi, SSOR）都不能工作，因为它们需要除以对角线元素。
* 对于我们期望用这个程序运行的矩阵大小，到目前为止最简单的方法就是使用直接求解器（特别是与deal.II捆绑的SparseDirectUMFPACK类）。 [2.x.112]走的就是这条路线，并表明解决[1.x.69]线性系统只需3、4行代码就可以完成。
* 但是，这是一个教程。我们教的是如何做事。因此，在下文中，我们将介绍一些可用于类似这些情况的技术。也就是说，我们将考虑线性系统不是由一个大的矩阵和向量组成，而是要将矩阵分解为[1.x.70]，对应于系统中出现的各个运算符。我们注意到，由此产生的求解器并不是最优的
* 
*--有更好的方法来有效地计算系统，例如在[2.x.113]的结果部分所解释的方法，或者我们在[2.x.114]中对一个类似于当前问题所使用的方法。在这里，我们的目标仅仅是介绍新的求解技术，以及它们如何在本质上实现。
* 

*[1.x.71][1.x.72]
* 

* 鉴于上面提到的使用标准求解器和预处理器的困难，让我们再看一下矩阵。如果我们对自由度进行排序，使所有速度变量排在所有压力变量之前，那么我们可以将线性系统[2.x.115]细分为以下几块：[1.x.73] 。
* 其中[2.x.116]分别是速度和压力自由度的值，[2.x.117]是速度空间的质量矩阵，[2.x.118]对应于负发散算子，[2.x.119]是其转置，对应于梯度。
* 通过区块消除法，我们可以按以下方式对这个系统重新排序（用系统的第一行乘以[2.x.120]，然后再减去第二行）：[1.x.74] 。
* 这里，矩阵[2.x.121]（称为[2.x.122]的[1.x.75]）显然是对称的，由于[2.x.123]的正定性和[2.x.124]具有全列等级，[2.x.125]也是正定的。
* 因此，如果我们能够计算出[2.x.126]，我们就可以对其应用共轭梯度法。然而，计算[2.x.127]是昂贵的，因为它要求我们计算（可能很大的）矩阵[2.x.128]的逆；而[2.x.129]实际上也是一个全矩阵，因为即使[2.x.130]是稀疏的，其逆[2.x.131]通常也是一个密集矩阵。另一方面，CG算法不要求我们真正拥有[2.x.132]的表示：只需要与它进行矩阵-向量积即可。我们可以利用矩阵乘积是关联的这一事实，分步进行（即，我们可以设置括号，使乘积更便于计算）：为了计算[2.x.133]，我们[2.x.134] [2.x.135 ]计算[2.x.136]；[2.x.137]解[2.x.138]为[2.x.139]，使用CG方法应用于正定和对称质量矩阵[2.x.140]；[2.x.141]计算[2.x.142]，得到[2.x.143] 。[2.x.144] 注意我们如何从右到左评估表达式[2.x.145]以避免矩阵-矩阵乘积；这样，我们所要做的就是评估矩阵-向量乘积。
* 在下文中，我们将不得不想出表示矩阵[2.x.146]的方法，以便在共轭梯度求解器中使用它，以及定义我们可以预设涉及[2.x.147]的线性系统解决方案的方法，并处理与矩阵[2.x.148]的线性系统求解（上述第二步骤）。
* [2.x.149] 这一考虑的关键点是要认识到，为了实现CG或GMRES这样的迭代求解器，我们实际上从来不需要矩阵的实际[1.x.76]! 所需要的只是我们能够进行矩阵-向量乘积。对于预处理程序也是如此。在deal.II中，我们对这一要求进行了编码，只要求提供给求解器类的矩阵和预处理器有一个[2.x.150]的成员函数来做矩阵-向量积。一个类如何选择实现这个函数对求解器来说并不重要。因此，类可以通过实现它，例如，像上面讨论的那样，做一连串的乘积和线溶。
* 

*[1.x.77][1.x.78]
* 

* deal.II包括支持以一种非常普遍的方式来描述这种线性操作。这是由LinearOperator类完成的，与[2.x.151]"MatrixType概念 "一样，它为[1.x.79]向量的线性操作定义了一个最小接口。
* [1.x.80]
* 然而，LinearOperator和普通矩阵的关键区别在于，LinearOperator不允许对底层对象进行任何进一步的访问。你能用LinearOperator做的就是将它的 "动作 "应用于一个向量! 我们借此机会介绍一下LinearOperator的概念，因为它是一个非常有用的工具，可以让你以一种非常直观的方式构造复杂的求解器和预处理器。
* 作为第一个例子，让我们构建一个代表[2.x.152]的LinearOperator对象。这意味着每当这个运算符的[2.x.153]函数被调用时，它必须解决一个线性系统。这就要求我们指定一个解算器（和相应的）前置条件。假设[2.x.154]是对系统矩阵左上块的引用，我们可以写出。
* [1.x.81]
* 我们没有使用SolverControl类，而是使用了ReductionControl类，当达到绝对容限（我们选择[2.x.155]）或者当残差减少了一定的因素（这里是[2.x.156]）时，就停止迭代。相反，SolverControl类只检查绝对公差。在我们的案例中，我们必须使用ReductionControl来解决一个小问题。我们将送入[2.x.157]的右手边基本上是由残差形成的，随着外部迭代的进行，残差的规范自然会大大降低。这使得用绝对公差来控制非常容易出错。
* 我们现在有一个LinearOperator[2.x.158]，我们可以用它来构造更复杂的运算符，如Schur补码[2.x.159]。假设[2.x.160]是对右上方块的引用，构造一个LinearOperator[2.x.161]只需两行。
* [1.x.82]
* 这里，三个LinearOperator对象的乘法产生了一个复合对象[2.x.162]，该函数首先应用[2.x.163]，然后是[2.x.164]（即用[2.x.165]解方程），最后是[2.x.166]到任何指定的输入向量。在这个意义上，[2.x.167]类似于以下代码。
* [1.x.83]
*（[2.x.168]是两个临时向量）。这种方法背后的关键点是，我们实际上从未创建过矩阵的内积。相反，每当我们要用[2.x.169]进行矩阵向量乘法时，我们只需按上述顺序运行所有单独的[2.x.170]操作。
* [2.x.171] 我们可以通过实现一个专门的类[2.x.172]，提供一个合适的[2.x.173]函数，来实现创建一个 "类似矩阵 "的对象的相同目标。跳过一些细节，这可能看起来像下面这样。
* [1.x.84]
* 尽管这两种方法完全等同，但LinearOperator类比这种手工方法有很大的优势。它提供了所谓的[1.x.85][1.x.86]：在数学上，我们认为[2.x.174]是复合矩阵[2.x.175]，LinearOperator类允许你大致上逐字写出。
* [1.x.87]
* 另一方面，手工方法掩盖了这个事实。
* 现在我们要做的就是形成定义[2.x.176]和[2.x.177]的两个方程的右边，然后分别用舒尔补强矩阵和质量矩阵来解决它们。例如，第一个方程的右手边是[2.x.178]。这可以用以下方式实现。
* [1.x.88]
* 同样，这是一个完全有效的方法，但是deal.II要求我们手动调整最终和临时向量的大小，而且每一个操作都要占用一个新的行，这就使我们难以阅读。这就是线性运算符框架中的第二个类可以帮助我们的地方。与LinearOperator的精神类似，PackagedOperation存储一个 "计算"。
* [1.x.89]
* 该类允许[1.x.90]涉及向量和线性运算符的表达式。这是通过存储计算表达式来实现的，只有当对象被转换为矢量对象，或者[2.x.179]（或[2.x.180]被手动调用时才会执行计算。假设[2.x.181]是右边的两个向量，我们可以简单地写出。
* [1.x.91]
* 这里，[2.x.182]是一个打包的操作，[1.x.92]是我们指定的计算。它不会立即创建一个带有实际结果的向量。
* 有了这些先决条件，解决[2.x.183]和[2.x.184]的问题就是创建另一个求解器和逆向。
* [1.x.93]
* 
* [2.x.185] 我们在这个例子中手工开发的功能在库中已经可以使用了。看看tschur_complement(), condense_schur_rhs(), and postprocess_schur_solution()。
* 

* [1.x.94][1.x.95] 。
* 

* 有人会问，如果我们有一个Schurcomplement的预处理程序是否会有帮助 [2.x.186] 。一般来说，答案是：当然。问题是，我们对这个舒尔补码矩阵一无所知。我们不知道它的条目，我们所知道的只是它的作用。另一方面，我们必须认识到，我们的求解器是昂贵的，因为在每次迭代中，我们必须与舒尔补矩阵做一次矩阵-向量乘积，这意味着我们必须在每次迭代中对质量矩阵做一次反转。
* 对这样的矩阵有不同的预处理方法。一个极端是使用一些便宜的方法，因此对每次迭代的工作没有实际影响。另一个极端是使用本身非常昂贵的预处理方法，但作为回报，真正降低了用[2.x.187]求解所需的迭代次数。
* 我们将沿着第二种方法进行尝试，既是为了提高程序的性能，也是为了展示一些技术。为此，让我们回顾一下，理想的预处理程序当然是[2.x.188]，但这是无法实现的。然而，将[1.x.96]*作为预处理程序如何？
* 作为一个预处理程序呢？这意味着每次我们必须做一个预处理步骤时，我们实际上必须用[2.x.189]来解决。起初，这看起来几乎和立即用[2.x.190]求解一样昂贵。然而，请注意，在内迭代中，我们不必计算[2.x.191]，而只是计算其对角线的逆值，这很便宜。
* 值得庆幸的是，LinearOperator框架使得这一点很容易写出来。我们之前已经对[2.x.192]矩阵使用了雅可比预处理程序（[2.x.193]）。所以剩下的就是写出近似的舒尔补码应该是什么样子。
* [1.x.97]
* 注意这个算子的不同之处在于，它只是做了一次雅可比扫频（即与对角线的逆数相乘），而不是与整个[2.x.194]相乘（这就是与[2.x.195]相乘的单一雅可比预处理步骤的定义：它是与[2.x.196]对角线的逆数相乘；换言之，对向量[2.x.198]的[2.x.197]操作正是预处理Jacobi的工作）。
* 有了这些，我们几乎完成了预处理程序：它应该是近似舒尔补码的逆。我们再次通过使用inverse_operator()函数创建一个线性算子来实现这一点。但这次我们想为CG解算器选择一个相对较小的容忍度（即反转[2.x.199]）。理由是[2.x.200]，所以我们实际上不需要完全反转它。然而，这产生了一个微妙的问题：[2.x.201]将被用于最后的外层CG迭代，以创建一个正交的基础。但是为了使其发挥作用，每次调用都必须是精确的相同的线性操作。我们通过使用迭代次数控制（IterationNumberControl）来确保这一点，该控制允许我们将执行的CG迭代次数固定为一个固定的小数字（在我们的例子中为30）。
* [1.x.98]
* 
* 这就是全部!
* 很明显，应用这个近似舒尔补码的逆运算是一个非常昂贵的预处理程序，几乎和倒置舒尔补码本身一样昂贵。我们可以期望它能大大减少Schur补码所需的后继迭代次数。事实上，它确实如此：在使用0阶元素的7次细化网格的非典型运行中，outer迭代次数从592次下降到39次。另一方面，我们现在不得不应用一个非常昂贵的预处理程序25次。因此，更好的衡量标准是程序的运行时间：在目前的笔记本电脑上（截至2019年1月），这个测试案例的运行时间从3.57秒下降到2.05秒。这似乎并不令人印象深刻，但在更细的网格和更高阶的元素上，节省的时间变得更加明显了。例如，一个7倍细化的网格和使用2阶元素（相当于约40万个自由度）产生了1134次到83次的外部迭代，运行时间为168秒到40秒。虽然不是惊天动地，但意义重大。
* 

*[1.x.99][1.x.100]
* 

* 在这个教程程序中，我们将以上述的混合模式解决拉普拉斯方程。由于我们想在程序中监测解决方案的收敛性，我们选择右手边、边界条件和系数，以便恢复我们已知的解函数。特别是，我们选择压力解[1.x.101]。
*对于系数，我们选择单位矩阵[2.x.202]，以求得简单性。因此，准确的速度满足[1.x.102]。
* 选择这个解是因为它完全没有发散，使它成为不可压缩流体流动的现实的测试案例。因此，右侧等于[2.x.203]，作为边界值，我们必须选择[2.x.204]。
* 在本程序的计算中，我们选择[2.x.205]。你可以在[1.x.103]中找到结果的解决方案，在注释程序之后。
* 

* [1.x.104] [1.x.105] 。
* [1.x.106] [1.x.107] 。
 

* 
* 因为这个程序只是对[2.x.206]的改编，所以在头文件方面没有多少新东西。在deal.II中，我们通常按照base-lac-grid-dofs-fe-numerics的顺序列出包含文件，然后是C++标准包含文件。
* 

* 
* [1.x.108]
* 
* 唯一值得注意的两个新头文件是LinearOperator和PackagedOperation类的文件。
 

* 
* [1.x.109]
* 
* 这是唯一重要的新头文件，即声明Raviart-Thomas有限元的文件。
* 

* 
* [1.x.110]
 
* 最后，作为本程序中的一项奖励，我们将使用一个张量系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的[2.x.207]类。
* 

* 
* [1.x.111]
* 
* 最后一步和以前所有的程序一样。我们把所有与这个程序相关的代码放到一个命名空间中。(这个想法在 [2.x.208] 中首次提出) 。
* 

* 
* [1.x.112]
* 
* [1.x.113] [1.x.114].
 

* 
* 同样，由于这是对[2.x.209]的改编，主类与该教程程序中的主类几乎相同。在成员函数方面，主要的区别是构造函数将Raviart-Thomas元素的度数作为参数（并且有一个相应的成员变量来存储这个值），并且增加了[2.x.210]函数，在这个函数中，不出意外，我们将计算精确解和数值解之间的差异，以确定我们计算的收敛性。
* 

* 
* [1.x.115]
* 
* 第二个不同之处是，疏散模式、系统矩阵以及解和右手向量现在被封锁了。这意味着什么，人们可以用这些对象做什么，在这个程序的介绍中已经解释过了，下面我们在解释这个问题的线性求解器和预处理器时也会进一步解释。
* 

* 
* [1.x.116]
* 
* [1.x.117] [1.x.118]
 

* 
* 我们的下一个任务是定义我们问题的右手边（即原始拉普拉斯方程中压力的标量右手边），压力的边界值，以及一个描述压力和精确解的速度的函数，以便以后计算误差。请注意，这些函数分别有一个、一个和[2.x.211]分量，我们将分量的数量传递给[2.x.212]基类。对于精确解，我们只声明实际上一次性返回整个解向量（即其中的所有成分）的函数。下面是各自的声明。
* 

* 
* [1.x.119]
* 
* 然后我们还得定义这些各自的函数，当然了。鉴于我们在介绍中讨论了解决方案应该是什么样子的，下面的计算应该是很简单的。
* 

* 
* [1.x.120]
* 
* [1.x.121] [1.x.122]。
 

* 
* 除了其他方程数据外，我们还想使用渗透率张量，或者更好的是
* 
* - 因为这就是出现在弱形式中的所有内容
* 
* - 渗透率张量的逆值，[2.x.213] 。对于验证解的精确性和确定收敛顺序的目的来说，这个张量的作用大于帮助。因此，我们将简单地把它设置为同一矩阵。    
* 然而，在现实生活中的多孔介质流动模拟中，空间变化的渗透率张量是不可缺少的，我们想利用这个机会来展示使用张量值函数的技术。    
* 可能毫不奇怪，deal.II也有一个基类，不仅适用于标量和一般矢量值的函数（[2.x.214]基类），也适用于返回固定维度和等级的张量的函数，即[2.x.215]模板。在这里，所考虑的函数返回一个dim-by-dim矩阵，即一个等级为2、维度为[2.x.216]的张量。然后我们适当地选择基类的模板参数。    
* [2.x.217]类提供的接口本质上等同于[2.x.218]类。特别是，存在一个[2.x.219]函数，它接收一个评估函数的点的列表，并在第二个参数中返回函数的值，一个张量的列表。
* 

* 
* [1.x.123]
* 
* 实现起来就不那么有趣了。和以前的例子一样，我们在类的开头添加一个检查，以确保输入和输出参数的大小是相同的（关于这个技术的讨论见[2.x.220]）。然后，我们在所有的评估点上进行循环，对于每一个评估点，将输出张量设置为身份矩阵。    
* 在函数的顶部有一个奇怪的地方（`(void)point;`语句），值得讨论。我们放到输出`values`数组中的值实际上并不取决于函数被评估的坐标`points`数组。换句话说，`points'参数实际上是不用的，如果我们想的话，可以不给它起名字。但是我们想用`points`对象来检查`values`对象是否有正确的大小。问题是，在发布模式下，`AssertDimension`被定义为一个宏，扩展为空；然后编译器会抱怨`points`对象没有使用。消除这个警告的习惯方法是有一个评估（读取）变量的语句，但实际上不做任何事情：这就是`(void)points;`所做的：它从`points`中读取，然后将读取的结果转换为`void`，也就是什么都没有。换句话说，这句话是完全没有意义的，除了向编译器解释是的，这个变量事实上是被使用的，即使是在发布模式下。(在调试模式下，`AssertDimension`宏会扩展为从变量中读取的东西，所以在调试模式下，这个有趣的语句是不必要的)。
* 

* 
* [1.x.124]
* 
* [1.x.125] [1.x.126]
* 

 
* [1.x.127] [1.x.128]。
 

* 
* 在这个类的构造函数中，我们首先存储传入的关于我们将使用的有限元的度数的值（例如，度数为0，意味着使用RT(0)和DG(0)），然后构造属于介绍中描述的空间[2.x.221]的向量值元素。构造函数的其余部分与早期教程程序中的一样。  
* 这里唯一值得描述的是，这个变量所属的[2.x.222]类的构造函数调用有很多不同的构造函数，都是指将较简单的元素绑定在一起，成为一个较大的元素。在目前的情况下，我们想把一个RT(度)元素与一个DQ(度)元素结合起来。这样做的[2.x.223]构造函数要求我们首先指定第一个基本元素（给定程度的[2.x.224]对象），然后指定这个基本元素的副本数量，然后类似地指定[2.x.225]元素的种类和数量。注意Raviart-Thomas元素已经有[2.x.226]个矢量分量，所以耦合元素将有[2.x.227]个矢量分量，其中第一个[2.x.228]个对应于速度变量，最后一个对应于压力。  
* 还值得比较的是，我们从基本元素中构建这个元素的方式，与我们在[2.x.229]中的方式相比较：在那里，我们将其构建为[2.x.230]，即我们简单地使用[2.x.231]元素，每个坐标方向上的位移都有一份。
* 

* 
* [1.x.129]
* 
* [1.x.130] [1.x.131].
 

* 
* 接下来的函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之关联。
 

* 
* [1.x.132]
 
* 然而，接下来事情就变得不同了。正如介绍中提到的，我们要把矩阵细分为对应于速度和压力这两种不同的变量的块。为此，我们首先要确保与速度和压力相对应的指数不会混在一起。首先是所有速度自由度，然后是所有压力自由度。这样一来，全局矩阵就很好地分离成一个[2.x.232]系统。为了达到这个目的，我们必须根据自由度的矢量分量对其重新编号，这个操作已经很方便地实现了。
* 

* 
* [1.x.133]
 
* 接下来，我们要弄清楚这些块的大小，以便我们可以分配适当的空间。为此，我们调用了[2.x.233]函数，该函数统计了某个向量分量的多少个形状函数为非零。我们有[2.x.234]个向量分量，[2.x.235]将计算有多少个形状函数属于这些分量中的每个。    
* 这里有一个问题。正如该函数的文档所描述的，它 [1.x.134] 将 [2.x.236] -速度形状函数的数量放入 [2.x.237] 中，将 [2.x.238] -速度形状函数的数量放入 [2.x.239] 中（以及类似的3d），并将压力形状函数的数量放入 [2.x.240] 中 。但是，Raviart-Thomas元素的特殊性在于它是非[2.x.241]"原始 "的，也就是说，对于Raviart-Thomas元素，所有的速度形状函数在所有分量中都是非零。换句话说，该函数不能区分[2.x.242]和[2.x.243]速度函数，因为[1.x.135]没有这种区分。因此，它将速度的总体数量放入[2.x.244] , [2.x.245]中的每一个。另一方面，压力变量的数量等于在dim-th分量中不为零的形状函数的数量。    
*利用这一知识，我们可以从[2.x.246]中的任何第一个[2.x.247]元素中得到速度形状函数的数量，然后用下面这个来初始化向量和矩阵块大小，以及创建输出。    
*  

* 
* [2.x.248] 如果你觉得这个概念难以理解，你可以考虑用函数 [2.x.249] 来代替，就像我们在 [2.x.250] 的相应代码中所做的那样。你可能还想阅读一下术语表中[2.x.251]"块 "和[2.x.252]"组件 "之间的区别。
* 

* 
* [1.x.136]
 
* 下一个任务是为我们将要创建的矩阵分配一个稀疏度模式。我们使用与前面步骤一样的压缩稀疏模式，但是由于[2.x.253]是一个块状矩阵，我们使用[2.x.254]类，而不仅仅是[2.x.255] 。这种块状稀疏模式在[2.x.256]模式中有四个块。块的大小取决于[2.x.257]，它持有速度和压力变量的数量。在第二步中，我们必须指示块系统更新它所管理的块的大小的知识；这发生在[2.x.258]的调用中。
* 

* 
* [1.x.137]
* 
* 我们以与非区块版本相同的方式使用压缩的区块稀疏模式来创建稀疏模式，然后创建系统矩阵。
* 

* 
* [1.x.138]
* 
* 然后我们必须以与块压缩稀疏性模式完全相同的方式调整解和右手向量的大小。
* 

* 
* [1.x.139]
* 
* [1.x.140] [1.x.141].
 

* 
* 同样地，组装线性系统的函数在本例的介绍中已经讨论过很多了。在它的顶部，发生的是所有常见的步骤，此外，我们不仅为单元项分配正交和[2.x.259]对象，而且还为面项分配。之后，我们为变量定义通常的缩写，并为本地矩阵和右手贡献分配空间，以及保存当前单元本地自由度的全局数的数组。
* 

* 
* [1.x.142]
 
* 下一步是声明代表源项、压力边界值和方程中的系数的对象。除了这些代表连续函数的对象外，我们还需要数组来保存它们在各个单元格（或面，对于边界值）的正交点的值。请注意，在系数的情况下，数组必须是矩阵的一种。
* 

* 
* [1.x.143]
* 
* 最后，我们需要几个提取器，用来获取矢量值的形状函数的速度和压力分量。它们的功能和使用在[2.x.260] vector_valued报告中详细描述。基本上，我们将把它们作为下面FEValues对象的下标：FEValues对象描述了形状函数的所有矢量分量，而在订阅后，它将只指速度（一组从零分量开始的[2.x.261]分量）或压力（位于[2.x.262]位置的标量分量）。
* 

* 
* [1.x.144]
* 
* 有了这些，我们就可以继续在所有单元上进行循环。这个循环的主体已经在介绍中讨论过了，这里就不再做任何评论了。
* 

* 
* [1.x.145]
 
* 在所有单元的循环中，最后一步是将局部贡献转移到全局矩阵和右手向量中。请注意，我们使用的界面与之前的例子完全相同，尽管我们现在使用的是块状矩阵和向量，而不是常规的。换句话说，对于外界来说，块对象具有与矩阵和向量相同的接口，但它们还允许访问单个块。
* 

* 
* [1.x.146]
* 
* [1.x.147] [1.x.148]
 

* 
* 我们在这个例子中使用的线性求解器和预处理器已经在介绍中进行了详细的讨论。因此，我们在这里不再讨论我们的方法的理由，而只是对剩下的一些实现方面进行评论。
* 

* 
* [1.x.149] [1.x.150].
* 

* 
* 正如在介绍中已经概述的那样，求解功能基本上由两个步骤组成。首先，我们必须形成涉及舒尔补数的第一个方程，并求解压力（解决方案的第一部分）。然后，我们可以从第二个方程（解的第0部分）中重建速度。
* 

* 
* [1.x.151]
* 
* 作为第一步，我们声明对矩阵的所有块状分量、右手边和我们将需要的解向量的引用。
* 

* 
* [1.x.152]
* 
* 然后，我们将创建相应的LinearOperator对象并创建[2.x.263]运算器。
* 

* 
* [1.x.153]
* 
* 这样我们就可以声明舒尔补码[2.x.264]和近似舒尔补码[2.x.265] 。
* 

* 
* [1.x.154]
* 
* 我们现在从[2.x.266]中创建一个预处理程序，应用固定数量的30次（便宜的）CG迭代。
* 

* 
* [1.x.155]
* 
* 现在来看看第一个方程。它的右边是[2.x.267] ，这就是我们在前几行计算的内容。然后我们用CG求解器和我们刚刚声明的预处理器来解决第一个方程。
* 

* 
* [1.x.156]
* 
* 在我们得到压力之后，我们可以计算速度。方程为[2.x.268] ，我们通过首先计算右手边，然后与代表质量矩阵逆的物体相乘来解决这个问题。
* 

* 
* [1.x.157]
* 
* [1.x.158] [1.x.159] 。
 

* 
* [1.x.160] [1.x.161]。
 

* 
* 在我们处理完线性求解器和预处理器之后，我们继续实现我们的主类。特别是，下一个任务是计算我们数值解的误差，包括压力和速度。  
* 为了计算解的误差，我们已经在[2.x.270]和[2.x.271]中介绍了[2.x.269]函数。然而，在那里我们只处理了标量解，而在这里我们有一个矢量值的解，其分量甚至表示不同的量，并且可能有不同的收敛阶数（由于所使用的有限元的选择，这里不是这种情况，但在混合有限元应用中经常是这种情况）。因此，我们要做的是 "掩盖 "我们感兴趣的成分。这很容易做到：[2.x.272]函数将一个指向权重函数的指针作为其参数之一（该参数默认为空指针，意味着单位权重）。我们要做的是传递一个函数对象，在我们感兴趣的成分中等于1，而在其他成分中等于0。例如，为了计算压力误差，我们应该传递一个函数，代表在[2.x.273]分量中具有单位值的常数向量，而对于速度，常数向量在第一个[2.x.274]分量中应该是1，而在压力的位置是0。  
* 在deal.II中，[2.x.275]正是这样做的：它想知道它要表示的函数应该有多少个向量分量（在我们的例子中，这将是[2.x.276]，对于速度-压力联合空间），哪个个体或范围的分量应该等于1。因此，我们在函数的开头定义了两个这样的掩码，接下来是一个代表精确解的对象和一个向量，我们将在其中存储由[2.x.277]计算的单元误差。
* 

* 
* [1.x.162]
* 
* 正如在[2.x.278]中已经讨论过的，我们必须认识到不可能精确地整合误差。我们所能做的就是用正交法对这个积分进行近似。这实际上在这里提出了一个小小的转折：如果我们像人们可能倾向于做的那样天真地选择一个[2.x.279]类型的对象（这就是我们用于积分线性系统的对象），就会发现误差非常小，根本不遵循预期的收敛曲线。现在的情况是，对于这里使用的混合有限元，高斯点恰好是超收敛点，其中的点误差比其他地方小得多（而且收敛的阶数更高）。因此，这些点不是特别好的积分点。为了避免这个问题，我们简单地使用梯形法则，并在每个坐标方向上迭代[2.x.280]次（同样如[2.x.281]中的解释）。
* 

* 
* [1.x.163]
* 
* 有了这个，我们就可以让库计算误差并将其输出到屏幕上。
* 

* 
* [1.x.164]
* 
* [1.x.165] [1.x.166].
 

* 
* 最后一个有趣的函数是我们生成图形输出的函数。请注意，所有的速度分量都得到相同的解名 "u"。再加上使用[2.x.282]，这将使[2.x.283]产生各个速度分量的矢量表示，更多信息见[2.x.284]或[2.x.285]模块的 "生成图形输出 "部分。最后，对于高阶元素来说，在图形输出中每个单元只显示一个双线性四边形似乎不合适。因此，我们生成大小为(度数+1)x(度数+1)的斑块来捕捉解决方案的全部信息内容。关于这方面的更多信息，请参见[2.x.287]教程程序。
* 

* 
* [1.x.167]
* 
* [1.x.168] [1.x.169]。
 

* 
* 这是我们主类的最后一个函数。它唯一的工作是按照自然顺序调用其他函数。
* 

* 
* [1.x.170]
* 
* [1.x.171] [1.x.172].
 

* 
* 我们从 [2.x.288] 而不是 [2.x.289] 中偷来的主函数。它几乎等同于 [2.x.290] 中的函数（当然，除了改变的类名），唯一的例外是我们将有限元空间的度数传递给混合拉普拉斯问题的构造函数（这里，我们使用零阶元素）。
* 

* 
* [1.x.173]
* [1.x.174][1.x.175] 。
* 

* [1.x.176][1.x.177]。
 

* 
* 如果我们按原样运行程序，对于我们使用的[2.x.291]网格，我们得到这样的输出（总共1024个单元，有1024个压力自由度，因为我们使用分片常数，还有2112个速度，因为Raviart-Thomas元素定义了每个面的一个自由度，有[2.x.292]个面平行于[2.x.293] -轴，同样数量平行于[2.x.294] -轴）。
* [1.x.178]
* 
* 迭代次数如此之少的事实，当然是由于我们所开发的良好（但昂贵！）的预处理程序。为了获得对解决方案的信心，让我们看看它。下面三幅图显示了（从左到右）X-速度、Y-速度和压力。
* [2.x.295] 
 

* 
* 让我们从压力开始：它在左边是最高的，在右边是最低的，所以流量将从左到右。此外，虽然在图中几乎看不出来，但我们选择的压力场是这样的：从左到右的流动首先是向中心流动，然后再向外流动。因此，X-速度必须增加以使流动通过狭窄的部分，这一点在左图中很容易看到。中间的图像代表域的左端Y方向的内流，以及域的右端Y方向的外流。
* 

* 
* 作为补充说明，请注意左图中的X-速度在X方向上是连续的，而Y-速度在Y方向上是连续的。其他方向的流场是不连续的。这非常明显地反映了Raviart-Thomaselements的连续性特性，事实上，它只在空间H(div)而不是在空间[2.x.296]。最后，压力场是完全不连续的，但鉴于我们选择了[2.x.297]作为该求解分量的有限元，这并不令人惊讶。
* 

* 
* [1.x.179][1.x.180] 。
* 

* 
* 该程序提供了两个明显的地方，在那里播放和观察收敛性：使用的有限元的程度（传递给[2.x.298]的构造器），和细化水平（在[2.x.299]中确定）。我们可以做的是改变这些值，并观察以后在程序运行过程中计算出的误差。
* 

* 
* 如果这样做，我们会发现压力变量的[2.x.300]误差有如下模式。[2.x.301] 
* 理论上预期的收敛顺序很好地反映在表格最后一行中的实验观察结果中。
* 

* 
* 我们可以用速度变量的[2.x.302]误差做同样的实验。[2.x.303]这里关于收敛顺序的结果是一样的。
* 

* 
* [1.x.181][1.x.182][1.x.183] 。
* 

* [1.x.184][1.x.185]。
* 

* 地下水或石油储层模拟的现实流动计算不会使用恒定的渗透率。下面是改变这种情况的第一个相当简单的方法：我们使用一个在远离中心流线的地方迅速衰减的渗透率，直到它达到一个背景值0.001。这是为了模拟流体在砂岩中的行为：在大部分区域中，砂岩是均匀的，虽然对流体有渗透性，但不是过度的渗透；在另一块石头上，石头沿着一条线出现了裂缝，或者说断层，流体沿着这条大裂缝流得更密了。下面是我们如何实现类似的东西。
* [1.x.186]
* 记住，该函数返回渗透率张量的逆值。
* 

* 
* 用更高的网格分辨率，我们可以用x-和y-速度来可视化。
* [2.x.304] 
* 很明显，流体基本上只沿着中线流动，而不是其他地方。
* 

* 
* 另一种可能性是使用一个随机渗透率场。实现这一点的一个简单方法是在领域周围散布一些中心，然后使用一个渗透率场，它是这些中心的（负）指数之和。然后，流动将试图从一个高渗透率的中心跳到下一个中心。这是一种完全不科学的描述随机介质的尝试，但是实现这种行为的一种可能性是这样的。
* [1.x.187]
* 
* 这个张量的逆的对角线元素的片状常数插值（即[2.x.305]）看起来如下。
* [2.x.306] 
* 

* 有了这样一个渗透率场，我们将得到如下的X-velocities和压力。
* [2.x.307] 
* 我们将在[2.x.308]和[2.x.309]中再次使用这些渗透率场。
* 

* [1.x.188][1.x.189] 。
* 

* 正如介绍中提到的，这里使用的Schur补码求解器并不是可以想象的最好的（也不打算成为一个特别好的）。更好的解算器可以在文献中找到，并且可以使用这里介绍的相同的块矩阵技术来建立。我们在[2.x.310]中再次讨论了这个主题，在那里我们首先为斯托克斯方程建立了一个Schur补数求解器，就像我们在这里所做的那样，然后在[1.x.190]部分讨论了基于求解系统整体的更好方法，但基于单个块的预处理。我们还将在[2.x.311]中再次讨论这个问题。
* 

* [1.x.191][1.x.192] [2.x.312] 。
* [0.x.1]

