include/deal.II-translator/A-tutorial/step-66_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
* [2.x.3]
* [1.x.34]


* [1.x.35][1.x.36][1.x.37] 。


* 本教程程序的目的是演示如何在无矩阵框架内使用牛顿方法解决一个非线性问题。本教程结合了在[2.x.4]、[2.x.5]、[2.x.6]、[2.x.7]和其他文献中已经介绍的几种技术。
*

*[1.x.38][1.x.39]
*在单位圆[2.x.8]上，我们考虑以下非线性椭圆边界值问题，受制于不均匀的Dirichlet边界条件。找到一个函数[2.x.9]，使其成立。
* [1.x.40]
* 这个问题也被称为[1.x.41]，是燃烧理论问题的典型例子，例如见[2.x.10] 。
*

*[1.x.42][1.x.43] 。
* 像往常一样，我们首先推导出这个问题的弱式，即用一个光滑的测试函数[2.x.11]乘以边界条件并在域[2.x.12]上积分。分别进行积分，并将右边的项放到左边，就得到了弱式计算。找到一个函数[2.x.13]，使所有测试函数[2.x.14]都成立。
* [1.x.44]

* 选择拉格朗日有限元空间[2.x.15]，它直接包含了同质Dirichlet边界条件，我们可以定义一个基[2.x.16]，因此只需用这些基函数进行测试即可。因此离散的问题如下。找到[2.x.17]，使所有[2.x.18]都成立。
* [1.x.45]
* 由于每个有限元函数是基础函数[2.x.19]的线性组合，我们可以通过[2.x.20]的一个向量来确定有限元解决方案，该向量由每个自由度（DOF）的未知值组成。因此，我们定义非线性函数[2.x.21]代表离散非线性问题。
* 为了解决这个非线性问题，我们使用牛顿方法。因此，给定一个初始猜测[2.x.22]，它已经满足了Dirichlet边界条件，我们通过连续应用以下方案来确定一连串的牛顿步骤[2.x.23] 。
* [1.x.46]
* 因此，在每个牛顿步骤中，我们必须解决一个线性问题[2.x.24]，其中系统矩阵[2.x.25]由雅各布[2.x.26]表示，右手边[2.x.27]由负残差[2.x.28]表示。在这种情况下，解向量[2.x.29]是[2.x.30]第1个牛顿步骤的牛顿更新。请注意，我们假设初始猜测[2.x.31]已经满足了问题公式中的迪里希特边界条件（事实上这也可能是一个不均匀的迪里希特边界条件），因此牛顿更新[2.x.32]满足不均匀的迪里希特条件。
* 到目前为止，我们只测试了基函数，然而，我们也可以将[2.x.33]的任何函数表示为基函数的线性组合。更确切地说，这意味着[2.x.34]的每个元素都可以通过表示公式与向量[2.x.35]识别。[2.x.36] .因此，利用这一点我们可以给出离散雅各布和残差的表达式。
* [1.x.47]
* 与[2.x.37]相比，我们也可以形成与问题的强表述相对应的非线性函数的Frech{\'e}t导数，并在之后将其具体化。然而，最终我们会得到同样的一组离散方程。
*

* [1.x.48][1.x.49] 。
* 注意，系统矩阵，实际上是雅各布系数，是如何取决于前一个牛顿步骤的 [2.x.38] 。因此，我们需要告诉计算系统矩阵的函数关于最后一个牛顿步骤的解决方案。在经典[2.x.39]函数的实施中，我们将通过使用成员函数[2.x.40]和[2.x.41]从装配过程中的最后一个牛顿步骤中收集这一信息，然后[2.x.42]函数将看起来像。
* [1.x.50]
*
* 由于我们想在不存储矩阵的情况下解决这个问题，我们需要在使用前告诉无矩阵运算器这些信息。因此，在派生类[2.x.43]中，我们将实现一个名为[2.x.44]的函数，它将在使用矩阵-向量实现之前处理最后一个牛顿步骤的信息。此外，我们想为线性求解器使用一个几何多网格（GMG）预处理器，因此为了应用多层次算子，我们需要将最后一个牛顿步骤也传递给这些算子。这是一项棘手的任务，因为包含最后一个牛顿步骤的向量必须被内插到所有级别的三角计算中。在代码中，这项任务将由函数[2.x.45]完成。 注意，与之前我们设置和使用几何多网格预处理的情况的一个根本区别是，我们可以重复使用MGTransferMatrixFree对象来计算所有牛顿步骤。所以我们可以在这里节省一些工作，定义一个类变量，并使用已经设置好的MGTransferMatrixFree对象[2.x.46]，该对象在[2.x.47]函数中被初始化。
* [1.x.51]
*
* 评估非线性的函数与[2.x.49]中评估系数函数的函数[2.x.48]的工作方式基本相同。我们的想法是使用一个FEEvaluation对象来评估牛顿步骤，并将所有单元和所有正交点的表达式存储在一个表中。
* [1.x.52]
*
*

*[1.x.53][1.x.54]
* 正如在[2.x.50]中所说，如果我们选择高阶有限元空间，无矩阵方法会变得更有效率。由于我们想在[2.x.51]维的单位球上解决问题，最好有一个适当的边界逼近来克服收敛问题。出于这个原因，我们使用MappingQGeneric类的异参数方法来恢复平滑边界以及内单元的映射。此外，为了得到一个好的三角计算，我们使用了TransfiniteInterpolationManifold。
*

* [1.x.55] [1.x.56]。
*首先我们包括本教程所需的deal.II库的典型头文件。
*


* [1.x.57]
*
* 特别是，我们需要包括无矩阵框架的头文件。
*


* [1.x.58]
*
* 由于我们要使用几何多网格预处理程序，所以我们还需要多级头文件。
*


* [1.x.59]
*
* 最后是一些常用的C++头文件，用于输入和输出。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 在开始时，我们定义了雅各布的无矩阵算子。作为指导，我们遵循教程[2.x.52]和[2.x.53]，其中对[2.x.54]类的精确接口做了大量的记录。   
* 由于我们希望将雅各布（Jacobian）作为系统矩阵使用，并将其传递给线性求解器以及多级预处理类，我们从[2.x.56]类派生出[2.x.55]类，这样我们就有了正确的接口。我们需要从基类中覆盖的两个函数是[2.x.57]和[2.x.58]函数。为了允许用浮动精度进行预处理，我们定义数字类型作为模板参数。   
* 正如在介绍中提到的，我们需要在最后一个牛顿步骤[2.x.60]中评估雅各布[2.x.59]，以计算牛顿更新[2.x.61]。为了获得最后一个牛顿步骤[2.x.62]的信息，我们的做法与[2.x.63]基本相同，在使用无矩阵算子之前，我们将一个系数函数的值存储在一个表中[2.x.64]。我们在这里实现的不是一个函数 [2.x.65] ，而是一个函数 [2.x.66] 。   
* 作为[2.x.67]的额外私有成员函数，我们实现了[2.x.68]和[2.x.69]函数。第一个是矩阵-向量应用的实际工作函数，我们在[2.x.71]函数中把它传递给[2.x.70]。后一个是计算对角线的工作函数，我们将其传递给[2.x.72]函数。   
* 为了提高源代码的可读性，我们进一步为FEEvaluation对象定义了一个别名。
*


* [1.x.63]

* [2.x.73]的构造函数只是调用基类[2.x.74]的构造函数，而基类本身就是由Subscriptor类派生的。
*


* [1.x.64]
*
* [2.x.75]函数重置了保存非线性值的表格，并调用基类的[2.x.76]函数。
*


* [1.x.65]
*
* [1.x.66] [1.x.67]。


*
* 下面的 [2.x.77] 函数是基于 [2.x.79] 的 [2.x.78] 函数。然而，它并不评估一个函数对象，而是评估一个代表有限元函数的向量，即雅各布系数所需的最后一个牛顿步骤。因此，我们设置了一个FEEvaluation对象，用[2.x.80]和[2.x.81]函数评估正交点的有限元函数。我们将有限元函数的评估值直接存储在[2.x.82]表中。   
* 这样做效果很好，在[2.x.83]函数中我们可以使用存储在表中的值来应用矩阵-向量乘积。然而，我们也可以在这个阶段优化雅各布系数的实现。我们可以直接评估非线性函数[2.x.84]并将这些值存储在表中。这就跳过了在每次调用[2.x.85]函数时对非线性的所有评估。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 现在在[2.x.86]函数中，实际上实现了系统矩阵的单元格动作，我们可以使用存储在表[2.x.87]中的最后一个牛顿步骤的信息。这个函数的其余部分与 [2.x.88] 中的基本相同。我们设置FEEvaluation对象，收集并评估输入向量的值和梯度 [2.x.89] ，根据Jacobian的形式提交值和梯度，最后调用 [2.x.90] 进行单元积分，将局部贡献分配到全局向量 [2.x.91] 。
*


* [1.x.71]
*
*接下来我们使用[2.x.92]对所有单元进行实际循环，计算单元对矩阵-向量积的贡献。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 用于计算对角线的内部工作函数 [2.x.93] 与上述工作函数 [2.x.94] 类似。然而，作为主要的区别，我们不从输入向量中读取数值，也不将任何局部结果分配给输出向量。相反，唯一的输入参数是使用的FEEvaluation对象。
*


* [1.x.75]
*
* 最后我们覆盖了[2.x.95]的基类的[2.x.96]的函数。虽然这个函数的名字表明只是计算对角线，但这个函数的作用更大一些。因为我们实际上只需要矩阵对角线元素的逆值，用于多网格预处理器的切比雪夫平滑器，我们计算对角线并存储逆值元素。因此我们首先初始化[2.x.97] 。然后我们通过将工作函数[2.x.98]传递给[2.x.99]函数来计算对角线。最后，我们在对角线上循环，用手反转这些元素。注意，在这个循环过程中，我们捕捉受限的DOFs，并手动将它们设置为1。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 在实现了无矩阵算子之后，我们现在可以为[1.x.79]定义求解器类。这个类是基于之前所有教程程序的共同结构，特别是它是基于[2.x.100]，解决的也是一个非线性问题。由于我们使用的是无矩阵框架，所以我们不再需要assemble_system函数，相反，在每次调用[2.x.101]函数时都会重建矩阵的信息。然而，对于牛顿方案的应用，我们需要组装线性化问题的右手边并计算残差。因此，我们实现了一个额外的函数[2.x.102]，后来我们在[2.x.103]函数中调用该函数。最后，典型的[2.x.104]函数在这里实现了牛顿方法，而线性化系统的解是在函数[2.x.105]中计算的。由于MatrixFree框架将拉格朗日有限元方法的多项式程度作为模板参数来处理，我们也将其作为问题求解器类的模板参数来声明。
*


* [1.x.80]
*
* 对于并行计算，我们定义了一个 [2.x.106] 由于计算域在二维是一个圆，在三维是一个球，我们除了为边界单元分配SphericalManifold外，还为内部单元的映射分配了TransfiniteInterpolationManifold对象，它负责内部单元的映射。在这个例子中，我们使用了一个等参数的有限元方法，因此使用了MappingQGeneric类。注意，我们也可以创建一个MappingQ类的实例，并在构造器调用中设置[2.x.107]标志为[2.x.108] 。关于MappingQ和MappingQGeneric连接的进一步细节，你可以阅读这些类的详细描述。
*


* [1.x.81]
*
* 像往常一样，我们定义拉格朗日有限元FE_Q和一个DoFHandler。
*


* [1.x.82]
*
* 对于线性化离散系统，我们定义了一个AffineConstraints对象和[2.x.109]，在本例中它被表示为一个无矩阵算子。
*


* [1.x.83]
*
* 多级对象也是基于雅各布系数的无矩阵算子。由于我们需要用最后一个牛顿步骤来评估雅各布式，所以我们也需要用最后一个牛顿步骤来评估水平算子的预调节器。因此，除了[2.x.110]之外，我们还需要一个MGLevelObject来存储每一级的插值解向量。与[2.x.111]一样，我们对预处理程序使用浮点精度。此外，我们将MGTransferMatrixFree对象定义为一个类变量，因为我们只需要在三角形变化时设置一次，然后可以在每个牛顿步骤中再次使用它。
*


* [1.x.84]

* 当然，我们还需要持有 [2.x.112] , [2.x.113] 的向量。这样，我们就可以一直将上一个牛顿步骤存储在解决方案向量中，只需添加更新就可以得到下一个牛顿步骤。
*


* [1.x.85]
*
* 最后我们有一个变量用于线性求解器的迭代次数。
*


* [1.x.86]
*
* 对于与MPI并行运行的程序中的输出，我们使用ConditionalOStream类来避免不同的MPI等级对同一数据的多次输出。
*


* [1.x.87]
*
* 最后，对于时间的测量，我们使用一个TimerOutput对象，它在程序结束后将每个函数的耗时CPU和墙体时间打印在一个格式很好的表格中。
*


* [1.x.88]
*
* [2.x.114]的构造函数初始化了类的变量。特别是，我们为[2.x.115]设置了多级支持，设置映射度等于有限元度，初始化ConditionalOStream，并告诉TimerOutput我们只想在需求时看到墙体时间。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 作为计算域，我们使用[2.x.116]-维的单位球。我们遵循TransfiniteInterpolationManifold类的说明，同时也为边界指定了一个SphericalManifold。最后，我们将初始网格细化为3
*
* - [2.x.117]次全局。
*


* [1.x.92]
*
* [1.x.93] [1.x.94]。


*
* [2.x.118]函数与[2.x.119]中的函数几乎完全相同。唯一的区别显然是只用一个[2.x.120]来测量时间，而不是单独测量每个部分，更重要的是对前一个牛顿步骤的内插解矢量进行MGLevelObject的初始化。另一个重要的变化是MGTransferMatrixFree对象的设置，我们可以在每个牛顿步骤中重复使用它，因为[2.x.121]不会被改变。   
* 请注意，我们可以两次使用同一个MatrixFree对象，用于[2.x.122]和多棱镜预处理程序。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。


*
* 接下来，我们实现了一个函数，它评估了给定输入矢量的非线性离散残差（[2.x.123]）。这个函数随后被用于组装线性化系统的右手边，随后用于计算下一个牛顿步骤的残差，以检查我们是否已经达到了误差容忍度。由于这个函数不应该影响任何类别的变量，我们把它定义为一个常数函数。在内部，我们通过FEEvaluation类和类似于[2.x.125]的[2.x.124]来利用快速有限元评估。   
*首先我们创建一个指向MatrixFree对象的指针，它被存储在 [2.x.126] 中。然后，我们将用于残差的单元评价的工作函数 [2.x.127] 以及输入和输出向量传递给 [2.x.128] 此外，我们在循环中启用输出向量的清零，这比之前单独调用<code>dst = 0.0</code>更有效率。   
* 请注意，使用这种方法，我们不必关心MPI相关的数据交换，因为所有的记账工作都由[2.x.129]完成。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 这是用于评估残差的内部工作函数。本质上，它与 [2.x.131] 的 [2.x.130] 函数具有相同的结构，在给定的单元格 [2.x.133] 上对输入向量 [2.x.132] 进行残差评估。与上述[2.x.134]函数不同的是，我们将[2.x.135]函数分为[2.x.136]和[2.x.137]，因为输入向量可能有受限的DOF。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。


*
* 使用上述函数[2.x.138]来评估非线性残差，现在组装线性化系统的右手边变得非常容易。我们只需调用[2.x.139]函数并将结果与减一相乘。   
* 经验表明，使用FEEvaluation类比使用FEValues和co的经典实现要快很多。
*


* [1.x.104]
*
* [1.x.105] [1.x.106]。


*
* 根据[2.x.140]，下面的函数在[2.x.142]函数的帮助下计算出解的非线性残差的规范。如果我们使用牛顿方法的自适应版本，牛顿步长[2.x.143]就变得很重要。例如，我们将计算不同步长的残差并比较残差。然而，对于我们的问题来说，全牛顿步长[2.x.144]是我们能做的最好的。如果我们没有好的初始值，牛顿方法的自适应版本就变得很有趣。请注意，在理论上，牛顿方法是以二次方顺序收敛的，但只有当我们有一个合适的初始值时才会收敛。对于不合适的初始值，牛顿方法甚至在二次方程下也会发散。一个常见的方法是使用阻尼版本[2.x.145]，直到牛顿步骤足够好，可以进行完整的牛顿步骤。这在[2.x.146]中也有讨论。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 为了在每个牛顿步骤中计算牛顿更新，我们用CG算法和几何多网格预处理器一起解决线性系统。为此，我们首先像在[2.x.147]中那样用切比雪夫平滑器设置PreconditionMG对象。
*


* [1.x.110]

* 我们记得Jacobian取决于存储在解向量中的最后一个牛顿步骤。所以我们更新牛顿步骤的鬼魂值，并将其传递给[2.x.148]来存储信息。
*


* [1.x.111]
*
* 接下来我们还要将最后一个牛顿步骤传递给多级运算符。因此，我们需要将牛顿步骤插值到三角化的所有层次。这是用[2.x.149]来完成的。
*


* [1.x.112]

* 现在我们可以设置预处理程序了。我们定义平滑器并将牛顿步骤的内插向量传递给多级运算器。
*


* [1.x.113]

* 最后我们设置了SolverControl和SolverCG来解决当前牛顿更新的线性化问题。实现SolverCG或SolverGMRES的一个重要事实是，持有线性系统解决方案的向量（这里是[2.x.150]）可以被用来传递一个起始值。为了使迭代求解器总是以零矢量开始，我们在调用[2.x.152]之前明确地重置了[2.x.151]，然后我们分配了存储在[2.x.153]中的Dirichlet边界条件，并为以后的输出存储了迭代步数。
*


* [1.x.114]
*
* 然后为了记账，我们把鬼魂的值清零。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。


*
* 现在我们为非线性问题实现实际的牛顿求解器。
*


* [1.x.118]
*
* 我们定义了牛顿步骤的最大数量和收敛标准的容忍度。通常，在良好的起始值下，牛顿方法在三到六步内收敛，所以最大的十步应该是完全足够的。作为公差，我们使用[2.x.154]作为残差的规范，[2.x.155]作为牛顿更新的规范。这似乎有点过头了，但我们将看到，对于我们的例子，我们将在几步之后达到这些公差。
*


* [1.x.119]

* 现在我们开始进行实际的牛顿迭代。
*


* [1.x.120]
*
* 我们将线性化问题的右侧集合起来，计算牛顿更新。
*


* [1.x.121]
*
* 然后我们计算误差，即牛顿更新的规范和残差。请注意，在这一点上，我们可以通过改变compute_residual函数的输入参数[2.x.156]来加入牛顿方法的步长控制。然而，在这里我们只是使用[2.x.157]等于1来进行普通的牛顿迭代。
*


* [1.x.122]
*
* 接下来我们通过将牛顿更新添加到当前的牛顿步骤中来推进牛顿步骤。
*


* [1.x.123]

* 一个简短的输出将告知我们当前的牛顿步骤。
*


* [1.x.124]
*
* 在每个牛顿步骤之后，我们检查收敛标准。如果其中至少有一个得到满足，我们就完成了，并结束循环。如果我们在牛顿迭代的最大数量之后还没有找到一个满意的解决方案，我们就会通知用户这个缺点。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 解决方案的H1-seminorm的计算可以用与[2.x.158]相同的方式进行。我们更新鬼魂值并使用函数 [2.x.159] 最后我们收集所有MPI等级的所有计算并返回规范。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 我们通过调用[2.x.160]函数，以与[2.x.161]中相同的方式，一次性生成vtu格式的图形输出文件和pvtu主文件。此外，与 [2.x.162] 一样，我们查询每个单元的 [2.x.163] 并将三角形在MPI行列中的分布写进输出文件。最后，我们通过调用[2.x.164]生成解决方案的补丁。然而，由于我们有一个边界弯曲的计算域，我们另外传递[2.x.165]和有限元度作为细分的数量。但这仍然不足以正确表示解决方案，例如在ParaView中，因为我们将TransfiniteInterpolationManifold附加到内部单元上，这导致内部的单元是弯曲的。因此，我们将[2.x.166]选项作为第三个参数，这样内部单元也使用相应的流形描述来构建补丁。   
* 请注意，我们可以用标志[2.x.167]来处理高阶元素，但是由于对ParaView以前版本的兼容性有限，而且VisIt的支持缺失，我们把这个选项留给了未来的版本。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* [1.x.134]的求解器类的最后一个缺失的函数是运行函数。在开始的时候，我们打印关于系统规格和我们使用的有限元空间的信息。该问题在一个连续细化的网格上被解决了几次。
*


* [1.x.135]
*
* 实际解决问题的第一项任务是生成或完善三角图。
*


* [1.x.136]

* 现在我们建立了系统并解决了问题。这些步骤都伴随着时间测量和文本输出。
*


* [1.x.137]
*
* 在问题被解决后，我们计算出解决方案的法线，并生成图形输出文件。
*


* [1.x.138]
*
* 最后在每个周期后，我们打印计时信息。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 作为使用MPI并行运行的典型程序，我们设置了MPI框架，并通过将线程数限制为1来禁用共享内存并行化。最后，为了运行[1.x.142]的求解器，我们创建一个[2.x.168]类的对象并调用运行函数。举例来说，我们用四阶拉格朗日有限元在二维和三维中各解一次问题。
*


* [1.x.143]
* [1.x.144][1.x.145] 。


*本教程步骤的目的是演示用无矩阵框架解决一个非线性PDE。
*


*[1.x.146][1.x.147]
* 通过释放模式在两个进程上运行程序
* [1.x.148]
* 在控制台给出以下输出
* [1.x.149]
*
* 我们在下图中显示了二维和三维问题的解决方案。
* [2.x.169]



* [1.x.150][1.x.151] 。
* 在上面的程序输出中，我们发现一些关于牛顿迭代的有趣信息。每个细化周期的终端输出显示了牛顿方法的详细诊断，首先显示了牛顿步骤的数量，以及每一步的残差[2.x.170]，牛顿更新的规范[2.x.171]，和CG迭代的数量[2.x.172]。
* 我们观察到，在所有情况下，牛顿方法大约在三到四步内收敛，这表明牛顿方法在全步长下的二次收敛 [2.x.173] 。通常，如果你没有一个合适的初始猜测，你可以尝试减少步长的几个阻尼牛顿步骤[2.x.175]，直到牛顿步骤再次进入二次收敛域。这种阻尼和放松牛顿步长的做法确实需要更复杂的牛顿方法的实现，我们将其指定为本教程的一个可能的扩展。
* 此外，我们看到，随着网格的不断细化和DoF数量的增加，CG的迭代次数大致不变。这当然是由于几何多网格预处理的缘故，而且与其他使用这种方法的教程中的观察结果相似，例如 [2.x.176] 和 [2.x.177] 。仅举一例，在三维案例中，经过五次修正后，我们有大约1470万个分布式DoFs和四阶拉格朗日有限元，但CG迭代的次数仍然少于10次。
* 此外，我们还应用了一个非常有用的优化，在此应该提及。在[2.x.178]函数中，我们在将牛顿更新的矢量作为输出矢量传递给求解器之前，明确地重置了该矢量。在这种情况下，我们为CG方法使用了一个零的起始值，这比之前的牛顿更新更合适，[2.x.179]的实际内容在重置之前，因此减少了几步CG迭代的次数。
*


* [1.x.152][1.x.153] 。
* 有几个可能的扩展是关于目前代码的小更新，以及对格尔凡德问题进行更深入的数值研究。
* [1.x.154][1.x.155]
* 除了在[2.x.180]中已经提到的牛顿迭代的步长控制版本外，我们还可以为牛顿迭代实现一个更灵活的停止准则。例如，我们可以取代对残差的固定公差[2.x.181]，实现一个具有给定绝对和相对公差的混合误差控制，这样牛顿迭代就可以成功存在，例如。
* [1.x.156]
* 对于有许多非线性系统需要解决的更高级的应用，例如，在时间依赖性问题的每个时间步长，事实证明，没有必要在每一个牛顿步长甚至每个时间步长重新设置和组装雅各布系数。相反，在牛顿迭代中可以使用前一个步骤中的现有Jacobian。只有在牛顿迭代收敛过慢的情况下，才会重新建立雅各布式，例如，牛顿迭代。这样的想法产生了一个[1.x.157]。诚然，当使用无矩阵框架时，无论如何都会省略雅各布矩阵的组装，但通过这种方式，我们可以尝试优化几何多网格预处理的重新组装。请记住，每次来自旧牛顿步骤的解决方案都必须分布到所有层面，并且必须重新初始化多重网格预处理程序。
* [1.x.158][1.x.159] 。
* 在[2.x.182]和其他文章的结果部分，无矩阵框架在大量处理器上的并行可扩展性已经得到了非常令人印象深刻的证明。在我们这里考虑的非线性情况下，我们注意到瓶颈之一可能成为无矩阵雅可比算子及其多阶段算子在前一个牛顿步骤中的转移和评估，因为我们需要在每个步骤中的所有阶段转移旧的解决方案。[2.x.183]中的首次并行可扩展性分析显示，当问题规模足够大时，可扩展性非常好。然而，为了得到可靠的结果，还需要进行更详细的分析。此外，到目前为止，这个问题只用MPI解决，没有使用线程的共享内存并行化的可能性。因此，对于这个例子，你可以尝试使用MPI和线程的混合并行化，如[2.x.184]中所述。
* [1.x.160][1.x.161] 。
* 类似于[2.x.185]和提到的[2.x.186]的可能扩展，你可以说服自己哪个方法更快。
* [1.x.162][1.x.163] 。
* 我们可以考虑相应的特征值问题，也就是所谓的Bratuproblem。例如，如果我们定义一个固定的特征值[2.x.187]，我们可以计算出相应的离散特征函数。你会注意到，随着[2.x.188]的增加，牛顿步骤的数量也会增加。为了减少牛顿步数，你可以使用以下技巧：从某个[2.x.189]开始，计算特征函数，增加[2.x.190]，然后使用之前的解作为牛顿迭代的初始猜测。最后你可以在特征值[2.x.192]上绘制出[2.x.191]-norm。如果进一步增加[2.x.193]，你会观察到什么？
*

* [1.x.164][1.x.165] [2.x.194] 。
* [0.x.1]

