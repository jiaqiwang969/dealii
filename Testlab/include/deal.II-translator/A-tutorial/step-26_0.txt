include/deal.II-translator/A-tutorial/step-26_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
*[1.x.23][1.x.24][1.x.25] 。


* [2.x.2] ( [2.x.3] )


* 这个程序实现了热力方程
* [1.x.26]
* 从某种意义上说，这个方程比我们在前面的程序[2.x.4]、[2.x.5]、[2.x.6]中讨论的方程（即波浪方程）更简单。这是由于热方程随着时间的推移平滑了解，因此在许多方面更宽容。例如，当使用隐式时间步长方法时，我们实际上可以采取大的时间步长，我们不会因为每隔几步调整网格而引入小的干扰而产生麻烦，等等。
* 我们在这里的目标是使用theta-scheme来解决上述方程，该方程在时间上使用以下方法进行解算，我们希望[2.x.7]在某个时间[2.x.9]近似于[2.x.8] 。
* [1.x.27]
* 这里，[2.x.10]是时间步长。Theta-scheme概括了显式欧拉（[2.x.11]）、隐式欧拉（[2.x.12]）和Crank-Nicolson（[2.x.13]）时间离散。由于后者具有最高的收敛顺序，我们将在下面的程序中选择[2.x.14]，但要使这个参数的玩法保持简单。如果你对玩更高阶的方法感兴趣，可以看看[2.x.15]）。
* 考虑到这种时间离散化，空间离散化会像往常一样发生，通过与测试函数相乘，通过部分积分，然后将一切限制在一个有限维的子空间。在与[2.x.16]相乘之后，产生了以下一组完全离散的方程。
* [1.x.28]
* 其中[2.x.17]是质量矩阵，[2.x.18]是对拉普拉斯进行微分后得到的刚度矩阵。把所有已知的量带到右手边，得到我们在每一步都要解决的线性系统。
* [1.x.29]
* 左手边的线性系统是对称的和正定的，所以我们用共轭梯度法来解决它应该没有问题。
* 如果我们在初始时间有一组节点系数[2.x.19]，我们可以开始上面的迭代。在这里，我们采用将初始值[2.x.20]插值到第一个时间步骤所用的网格上得到的系数。我们还需要选择一个时间步长；在这里我们只选择固定的时间步长，但显然先进的仿真器会希望自适应地选择它。我们将在[1.x.30]中简要地回过头来讨论这个问题。
*

*[1.x.31][1.x.32]


* 在前面几个程序中求解波浪方程及其变体时，我们保持了固定的网格。就像静止方程一样，我们可以很好地证明这不是最聪明的方法，通过调整网格可以节省大量的费用。然而，与静止的情况相比，还有很大的困难。让我们依次来看看这些困难。
* [2.x.21] [2.x.22] [1.x.33]:对于静止的问题，一般的方法是 "将网格做得越细越好"。对于有奇点的问题，这往往会导致我们在角落或界面上得到许多细化层次的情况。第一个使用自适应网格的教程，[2.x.23]，已经是一个案例了。
* 然而，对于时间相关问题，我们通常需要选择与网格大小相关的时间步长。对于显性时间离散，这是显而易见的，因为我们需要尊重CFL条件，将时间步长与最小的网格尺寸联系起来。对于隐式时间离散，不存在这样的硬性限制，但在实践中，如果我们使网格尺寸变小，我们仍然希望使时间步长变小，因为我们通常有[2.x.24]形式的误差估计，其中[2.x.25]分别是时间和空间离散的收敛阶。我们只有减少这两个项，才能使误差变小。理想情况下，像这样的估计会建议选择[2.x.26] 。因为，至少对于非光滑解的问题，误差通常集中在最小的网格尺寸的单元中，我们必须确实选择[2.x.27] ，使用[1.x.34]的网格尺寸。
* 其结果是，在一个地方进一步细化网格，不仅意味着稍微增加自由度的适度额外努力，而且由于时间步长较小，必须更频繁地解决[1.x.35]线性系统的问题。
* 在实践中，人们通常通过承认我们不能使时间步长任意地小，因此也不能使局部网格大小任意地小来处理这个问题。相反，我们设置了一个最大的细化水平，当我们标记单元进行细化时，我们只是不细化那些子单元会超过这个最大的细化水平。
* 还有一个类似的问题，即我们将选择一个右手边，在不同的时间在领域的不同部分开启。为了避免在我们突然需要更细的网格的地方，被太粗的网格抓个正着，我们也将在程序中强制执行[1.x.36]的网格细化水平。
* [2.x.28] [1.x.37]。让我们再次考虑我们上面写下的半离散方程。
* [1.x.38]
* 我们在这里可以把[2.x.29]视为数据，因为它可能已经被计算过了。现在，让我们来替换
* [1.x.39]
*乘以测试函数[2.x.30]，并在必要时进行部分积分。在上述的过程中，这将产生
* [1.x.40]
* 现在想象一下，我们在时间步骤[2.x.31]和[2.x.32]之间改变了网格。那么问题来了，我们在[2.x.33]和[2.x.34]中使用的基函数是不同的！这与[2.x.32]中的项有关。这与右手边的项有关，其中第一个项我们可以更清楚地写成（第二个项也是如此
* [1.x.41]
* 如果这两个时间步骤中使用的网格是相同的，那么[2.x.35]就会形成一个方形质量矩阵[2.x.36]。然而，如果网格不一样，那么一般来说，矩阵是矩形的。更糟的是，甚至很难计算这些积分，因为如果我们在时间步长[2.x.37]的网格单元上循环，那么我们需要在这些单元的正交点上评估[2.x.38]，但它们不一定对应于时间步长[2.x.39]的网格单元，[2.x.40]也不通过这些单元定义；当然，如果我们想通过对网格[2.x.41]的单元积分计算这些积分，也是如此。
* 在任何情况下，我们必须面对的情况是，我们需要整合定义在两个不同网格上的形状函数。这是可以做到的，事实上在[2.x.42]中也有演示，但这个过程最多只能用 "尴尬 "一词来形容。
* 在实践中，人们通常并不希望这样做。相反，我们在每次调整网格时，通过从旧的网格插值到新的网格来避免整个情况。换句话说，我们不是求解上面的方程，而是求解这个问题
* [1.x.42]
* 其中[2.x.43]是对时间步长[2.x.44]中使用的有限元空间的插值算子。这不是最佳的方法，因为它除了时间和空间离散化之外，还引入了一个额外的误差，但这是一个务实的方法，使得做时间适应网格是可行的。[2.x.45]



*[1.x.43][1.x.44]


* 在实现无限元素代码时，通常会有许多事情出错。特别是，对于时间相关问题，以下是常见的错误来源。
*
* 时间积分，例如把涉及当前和前一个时间步骤的条款前面的系数弄错了（例如，把[2.x.46]的系数混为[2.x.47]）。
*
* - 处理右手边，例如忘记了[2.x.48]或[2.x.49]的一个系数。
*
* - 错误地处理边界值，例如同样忘记了[2.x.50]或[2.x.51]的系数，或忘记了不仅对右手边而且对系统矩阵应用非零边界值。
* 一个不太常见的问题是把初始条件弄错了，因为一般来说，只要输出第一个时间步长就可以看出它是错的。在任何情况下，为了验证代码的正确性，有一个测试协议是很有帮助的，它允许我们单独验证这些组件中的每一个。这意味着。
*
* 在初始条件为非零但右手边和边界值为零的情况下测试代码，并验证时间演变是否正确。
*
* 然后用零初始条件和边界值但非零右手边进行测试，再次确保正确性。
*
* - 最后，用零的初始条件和右手边但非零的边界值进行测试。
* 这听起来很复杂，但幸运的是，对于像这里这样没有系数（或恒定系数）的线性偏微分方程，有一个相当标准的协议，它基于以下观察：如果你选择一个正方形[2.x.52]作为你的领域（或者，稍作修改，一个矩形），那么精确的解决方案可以写成
* [1.x.45]
*（有整数常数[2.x.53]），只要初始条件、右手边和边界值也都是[2.x.54]形式。这是由于函数[2.x.55]是拉普拉斯算子的特征函数，允许我们以分析的方式计算诸如时间因子[2.x.56]的东西，因此，与我们得到的数值进行比较。
* 作为一个例子，让我们考虑有[2.x.57]和[2.x.58]的情况。通过对[2.x.59]的上述形式的主张（ansatz），我们可以得到
* [1.x.46]
* 为了使其等于[2.x.60]，我们需要
* [1.x.47]
*并且由于初始条件，[2.x.61] 。这个微分方程可以被积分，从而得到
* [1.x.48]
* 换句话说，如果初始条件是正弦的乘积，那么解决方案的形状与正弦的乘积完全一样，它以已知的时间依赖性衰减到零。如果你有足够细的网格和足够小的时间步长，这一点是很容易测试的。
* 如果你弄错了时间积分方案（例如，在变量前面有错误的[2.x.62]或[2.x.63]的因子），通常会发生的情况是你没有得到正确的解决方案的时间行为。仔细检查各种因素，直到你得到正确的行为。你可能还想验证一下时间衰减率（例如，通过在固定点绘制解决方案的值来确定），而不是在你把时间步长或网格大小加倍或减半时，时间衰减率就加倍或减半了。你知道这不是对边界条件或右手边的处理，因为这些都是零。
* 如果你已经验证了时间积分器是正确的，那么就采取右手边不为零但初始条件为零的情况。  [2.x.64] 和 [2.x.65] 。再说一遍。
* [1.x.49]
*而要使其等于[2.x.66]，我们需要的是
* [1.x.50]
*并且由于初始条件，[2.x.67] 。对这个方程进行时间积分可以得到
* [1.x.51]
*
* 同样，如果你在右侧条款前面有错误的[2.x.68]或[2.x.69]的因素，你将不会得到正确的时间行为的解决方案，或者它将收敛到一个最大值，而不是[2.x.70]。
* 一旦我们验证了使用这个方案的时间积分和右侧处理是正确的，我们就可以继续验证我们的边界值是否正确，使用一个非常类似的方法。
*


*[1.x.52][1.x.53]


* 在一个具有简单右手边的简单域上求解热方程，几乎总是导致解非常无聊，因为它们很快就变得非常光滑，然后就不再有什么变化。相反，我们在这里解决L型域上的方程，其边界值为零，初始条件为零，但作为右手边，我们选择
* [1.x.54]
* 这里。
* [1.x.55]
* 换句话说，在每一个长度为[2.x.71]的周期中，右手边首先在域1中闪烁，然后完全关闭，然后在域2中打开，然后再次完全关闭。通过[1.x.56]中所示的解决方案的小动画，这种模式可能是最好的观察。
* 如果你把热方程解释为寻找导电固体的空间和时间可变的温度分布，那么上面的测试案例对应于一个L形体，我们保持边界为零温度，并在域的两个部分交替加热。在加热过程中，这些地方的温度会上升，之后温度会扩散并再次降低。这些初始条件的意义在于，它们为我们提供了一个在时间上（当源开关时）和时间上（在再入角以及在源作用区域的边缘和角落）都有奇点的解决方案。
*

* [1.x.57] [1.x.58]。
* 该程序以通常的包含文件开始，所有这些文件你现在应该都见过了。
*


* [1.x.59]
*
* 然后按照惯例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。
*


* [1.x.60]
*
* [1.x.61] [1.x.62].
* 下一个部分是这个程序的主类的声明。它沿用了以前的例子中很好的路径。如果你看过[2.x.72]，例如，这里唯一值得注意的是，我们需要建立两个矩阵（质量和拉普拉斯矩阵），并保存当前和前一个时间步长的解。然后，我们还需要存储当前时间、时间步长和当前时间步长的编号。最后一个成员变量表示引言中讨论的theta参数，它允许我们在一个程序中处理显式和隐式欧拉方法以及Crank-Nicolson方法和其他通用方法。   
* 就成员函数而言，唯一可能的惊喜是[2.x.73]函数需要最小和最大的网格细化水平的参数。这方面的目的在介绍中已经讨论过了。
*


* [1.x.63]
*
* [1.x.64] [1.x.65]。


*
* 在下面的类和函数中，我们实现了定义这个问题的各种数据（右手边和边界值），这些数据在这个程序中使用，我们需要函数对象。右手边的选择是在介绍的最后讨论的。对于边界值，我们选择零值，但这很容易在下面改变。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]
* 现在是实现主类的时候了。让我们从构造函数开始，它选择了一个线性元素，一个时间步长为1/500的常数（记得上面将右边的源的一个周期设置为0.2，所以我们用100个时间步长来解决每个周期），并通过设置[2.x.74]选择了Crank Nicolson方法.
*


* [1.x.69]
*
* [1.x.70] [1.x.71]
* 下一个函数是设置DoFHandler对象，计算约束条件，并将线性代数对象设置为正确的大小。我们还在这里通过简单地调用库中的两个函数来计算质量和拉普拉斯矩阵。   
* 请注意，在组装矩阵时，我们不考虑悬挂节点的约束（两个函数都有一个AffineConstraints参数，默认为空对象）。这是因为我们要在结合当前时间步长的矩阵后，在run()中浓缩约束。
*


* [1.x.72]
*
* [1.x.73] [1.x.74].
* 下一个函数是解决单个时间步骤的实际线性系统的函数。这里没有什么值得惊讶的。
*


* [1.x.75]
*
* [1.x.76] [1.x.77]
* 除了我们告诉DataOut对象当前的时间和时间步长是多少之外，在生成图形输出方面也没有什么新的内容，这样就可以将其写入输出文件中。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]
* 这个函数是程序的有趣部分。它负责自适应网格细化的工作。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，最终在两个不同的网格之间传输解向量。第一个任务是通过使用成熟的凯利误差估计器来实现的。第二项任务是实际进行再细化。这也只涉及到基本的函数，例如[2.x.75]，它可以细化那些具有最大估计误差的单元，这些误差加起来占60%，并粗化那些具有最小误差的单元，这些单元加起来占40%的误差。请注意，对于像目前这样的问题，即有事发生的区域正在四处移动，我们希望积极地进行粗化，以便我们能够将单元格移动到有必要的地方。   
* 正如在介绍中已经讨论过的，太小的网格会导致太小的时间步长，而太大的网格会导致太小的分辨率。因此，在前两个步骤之后，我们有两个循环，将细化和粗化限制在一个允许的单元范围内。
*


* [1.x.81]
*
* 上面这两个循环略有不同，但这很容易解释。在第一个循环中，我们没有调用[2.x.76]，而是调用了[2.x.77] 。这两个调用应该产生相同的迭代器，因为迭代器是按级别排序的，不应该有任何级别高于[2.x.78]的单元格。事实上，这段代码确保了这种情况的发生。
*

*
* 作为网格细化的一部分，我们需要将旧网格中的解向量转移到新网格中。为此，我们使用了SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦我们完成了细化，我们将失去旧的网格，所以转移必须与细化同时发生）。在我们调用这个函数的时候，我们将刚刚计算出解决方案，所以我们不再需要old_solution变量（它将在网格被细化后被解决方案覆盖，也就是在时间步长结束时；见下文）。换句话说，我们只需要一个求解向量，并将其复制到一个临时对象中，当我们在下面进一步调用 [2.x.79] 时，它就不会被重置。     
* 因此，我们将一个SolutionTransfer对象附加到旧的DoF处理程序中，以初始化它。然后，我们准备好三角形和数据向量以进行细化（按照这个顺序）。
*


* [1.x.82]
*
* 现在一切都准备好了，所以进行细化并在新网格上重新创建DoF结构，最后在[2.x.80]函数中初始化矩阵结构和新向量。接下来，我们实际执行从旧网格到新网格的插值解。最后一步是对解向量应用悬空节点约束，即确保位于悬空节点上的自由度值，使解是连续的。这是必要的，因为SolutionTransfer只对单元格进行局部操作，不考虑邻域。
*


* [1.x.83]
*
* [1.x.84] [1.x.85]。
* 这是程序的主要驱动，我们在这里循环所有的时间步骤。在该函数的顶部，我们通过重复第一个时间步长来设置初始全局网格细化的数量和自适应网格细化的初始周期数。然后，我们创建一个网格，初始化我们要处理的各种对象，设置一个标签，说明我们在重新运行第一个时间步长时应该从哪里开始，并将初始解插值到网格上（我们在这里选择了零函数，当然，我们可以用更简单的方法，直接将解向量设置为零）。我们还输出一次初始时间步长。   
*


* [2.x.81] 如果你是一个有经验的程序员，你可能会对我们在这段代码中使用[2.x.82]语句而感到惊讶  [2.x.83] 语句现在已经不是特别受人欢迎了，因为计算机科学界的伟人之一Edsgar Dijkstra在1968年写了一封信，叫做 "去语句认为是有害的"（见[1.x.86]）。这段代码的作者全心全意地赞同这一观念。  [2.x.84]是难以理解的。事实上，deal.II几乎不包含任何出现的情况：不包括基本上是从书本上转录的代码，也不计算重复的代码片断，在写这篇笔记时，在大约60万行代码中有3个位置；我们还在4个教程程序中使用它，与这里的背景完全相同。与其在这里试图证明这种情况的出现，不如先看看代码，我们在函数的最后再来讨论这个问题。
*


* [1.x.87]
*
* 然后我们开始主循环，直到计算的时间超过我们的结束时间0.5。第一个任务是建立我们需要在每个时间步骤中解决的线性系统的右手边。回顾一下，它包含项[2.x.85] 。我们把这些项放到变量system_rhs中，借助于一个临时矢量。
*


* [1.x.88]
*
* 第二块是计算源项的贡献。这对应于项 [2.x.86] 。下面的代码调用[2.x.87]来计算向量[2.x.88]，在这里我们在评估之前设置右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。
*


* [1.x.89]
*
* 接下来，我们将强迫项添加到来自时间步长的强迫项中，同时建立矩阵[2.x.89]，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。
*


* [1.x.90]
*
* 在我们解决这个问题之前，还有一个操作需要做：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。
*


* [1.x.91]
*
* 有了这些，我们要做的就是解决这个系统，生成图形数据，然后......
*


* [1.x.92]
*
* ...负责网格细化工作。在这里，我们要做的是：(i)在求解过程的最开始就细化所要求的次数，之后我们跳到顶部重新开始时间迭代，(ii)之后每隔五步细化一次时间。         
* 时间循环，事实上，程序的主要部分以开始进入下一个时间步骤为结束，将old_solution设置为我们刚刚计算的解决方案。
*


* [1.x.93]
*
* 现在你已经看到了这个函数的作用，让我们再来看看 [2.x.90] 的问题。从本质上讲，该代码所做的事情是这样的。  [2.x.91] 这里，"对结果满意 "的条件是我们是否愿意保留当前的网格，或者宁愿细化网格，然后在新的网格上重新开始。当然，我们可以用下面的方法取代 [2.x.92] 的使用。  [2.x.93] 这样做的好处是摆脱了[2.x.94]，但缺点是必须在两个不同的地方重复实现 "solve timestep "和 "postprocess "操作的代码。这可以通过将这些部分的代码（在上面的实际实现中是相当大的块）放到自己的函数中来解决，但是一个带有[2.x.96]语句的[2.x.95]循环并不是真的比一个[2.x.97]容易阅读或理解。
*

*
* 最后，人们可能只是同意[1.x.96][2.x.98]语句是个坏主意，但要务实地指出，在某些场合，它们可能有助于避免代码重复和控制流的尴尬。这可能是其中的一个地方，它与Steve McConnell在他关于良好编程实践的优秀书籍 "Code Complete" [2.x.99]中所采取的立场相吻合（见[2.x.100]的介绍中提到的这本书），该书花了惊人的10页来讨论[2.x.101]的一般问题。
*



*
* [1.x.97] [1.x.98]。


*
*走到这一步，这个程序的主函数又没有什么好讨论的了：它看起来就像自[2.x.102]以来的所有此类函数。
*


* [1.x.99]
*[1.x.100][1.x.101]


* 如同许多教程一样，程序的实际输出并不重要，重要的是我们如何到达那里。尽管如此，它还是在这里。
* [1.x.102]
*
* 也许更有意义的是解决方案的可视化和计算的网格。
* [2.x.103]
* 这部电影显示了两个信号源的开关情况以及网格的反应。很明显，现在的网格可能不是我们能想出来的最好的。我们将在下一节再讨论这个问题。
*

*[1.x.103][1.x.104][1.x.105]


* 至少有两个方面可以大大改善这个程序：自适应时间步进和更好地选择网格。
* [1.x.106][1.x.107] 。
*

* 由于选择了隐式时间步进方案，我们不受任何类似CFL的时间步进条件的约束。此外，由于在热力方程中发生变化的时间尺度不受细胞直径的约束（不像波浪方程那样，我们有一个固定的信息传输速度，将时间尺度和空间尺度结合起来），我们可以随意选择时间步长。或者，最好是按照我们认为必要的精确度来选择。
* 看一下这个解决方案，很明显，行动并不是随着时间的推移而均匀发生的：在我们打开一个源的时候，很多东西都在发生变化，一旦一个源开启了一段时间，事情就变得不那么戏剧化了，而当两个源都关闭时，我们就进入了衰退阶段。在这些时候，我们可以肯定地使用比以前更大的时间步长而不牺牲太多准确性。
* 文献中有许多关于如何适应性地选择时间步长的建议。例如，可以从ODE求解器选择其时间步长的方式中学到很多。我们还可以从后验误差估计器中得到启发，理想情况下，后验误差估计器的编写方式包括对整体误差的时间和空间贡献。如果时间上的贡献太大，我们应该选择一个较小的时间步长。例如，这个方向的想法可以在deal.II的前主要开发者Ralf Hartmann的博士论文中找到，该论文由德国海德堡大学在2002年出版。
*

*[1.x.108][1.x.109] 。


* 我们在这里使用了一种比较简单的时间步进方法，即二阶时间的Crank-Nicolson方法。然而，更精确的方法，如Runge-Kutta方法，也是可以使用的，因为它们并不代表太多的额外努力。对于目前的程序来说，实现这一点并不困难，但在[2.x.104]中也给出了一个更系统的处理。
*

*[1.x.110][1.x.111] 。


* 如果你看一下上面电影中的网格，很明显，它们并不特别适合手头的工作。事实上，它们看起来相当随机。
* 有两个因素在起作用。首先，有一些岛屿，其中的细胞已经被细化，但周围是未细化的细胞（可能还有一些偶尔被粗化的岛屿）。这些并不可怕，因为它们大多数时候并不影响网格的近似质量，但是它们也没有帮助，因为它们的许多额外的自由度实际上是受到悬挂节点约束的。也就是说，这很容易解决：Triangulation类在它的构造器中接受一个参数，表示 "网格平滑 "的程度。传递一个可能的标志，这将指示三角结构细化一些额外的单元，或者不细化一些单元，这样得到的网格就不会有这些假象了。
* 第二个问题更为严重：网格出现滞后于解的情况。根本原因是我们每隔五步才调整一次网格，而且在这些情况下只允许进行一次细化。每当资源开启时，解决方案在这一区域之前是非常平滑的，因此网格是相当粗糙的。这意味着在下一个时间步骤中，当我们对网格进行细化时，我们将在这一区域获得更多的细化级别，而在五个时间步骤之后，将获得另一个级别，等等。但这还不够：首先，我们应该在一个源打开时立即进行细化（毕竟在当前情况下，我们至少知道右手边是什么），而且我们应该允许多于一个细化级别。当然，所有这些都可以用deal.II来完成，只是需要在如何实现这一工作方面有一些算法上的思考。
*

*[1.x.112][1.x.113] 。


* 为了提高你的模拟在时间上的准确性和分辨率，通常会减少时间步长[2.x.105]。如果你在这个特定的例子中开始玩弄时间步长，你会注意到，如果[2.x.106]低于某个阈值，解决方案会变成部分负值。这不是我们所期望发生的（在自然界）。
* 为了从数学上了解这种行为，让我们考虑一个一般的、完全离散的问题。
* [1.x.114]
* 然后，[2.x.107]th方程的一般形式为。
* [1.x.115]
* 其中[2.x.108]是自由度[2.x.109]耦合的自由度集合（即矩阵[2.x.110]或矩阵[2.x.111]在[2.x.112]位置有一个非零条目）。如果所有系数都满足以下条件。
* [1.x.116]
*所有解[2.x.113]的符号与之前的解[2.x.114]保持一致，并因此与初始值[2.x.115]保持一致。关于正性保持的更多信息，请参见例如[1.x.117]。
* 根据要解决的PDE和使用的时间积分方案，我们可以推导出时间步长的条件[2.x.116]。对于采用Crank-Nicolson方案的热方程，[1.x.118]已将其翻译为以下内容。
* [1.x.119]
* 其中[2.x.117]表示质量矩阵，[2.x.118]表示刚度矩阵，[2.x.119]分别为[2.x.120]。有了[2.x.121]，我们可以对全局时间步长[2.x.122]制定如下的界限。
* [1.x.120]
* 换句话说，在Crank-Nicolson方案的情况下，时间步长受到[1.x.121]的约束。这些约束应该与CFL条件一起考虑，以确保执行模拟的重要性。
* 无法使时间步长达到我们所希望的那样小，以获得更多的精度而又不失去正数特性是令人讨厌的。这就提出了一个问题：在这个特定的教程中，我们是否至少可以[1.x.122]选择最小的时间步长来确保正性的保留。事实上，我们可以使用MatrixCreator函数创建的质量和刚度的稀疏矩阵对象。通过SparseMatrixIterators遍历每个条目，我们可以检查对角线和非对角线条目，以动态地设置一个适当的时间步长。对于二次矩阵，对角线元素被存储为一行的第一个成员（见SparseMatrix文档）。下面是一个关于如何从[2.x.123]中抓取感兴趣的条目的示例性代码片段。
* [1.x.123]
*
* 使用这样计算出来的信息，我们可以通过上面的公式来约束时间步长。
*

* [1.x.124][1.x.125] [2.x.124]。
* [0.x.1]

