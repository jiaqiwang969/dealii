include/deal.II-translator/A-tutorial/step-16_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.2] 
* [1.x.20]
* [1.x.21][1.x.22][1.x.23] 。
 

* 
* 这个例子显示了deal.II中多级函数的基本用法。它解决的问题与[2.x.3]中使用的问题几乎相同，但展示了使用多网格作为预处理程序时必须提供的东西。特别是，这要求我们定义一个层次结构，提供从一个层次到下一个层次以及返回的转移算子，并在每个层次上提供拉普拉斯算子的表示。
* 为了使微分方程系统和块状预处理程序具有足够的灵活性，在开始使用多层次方法之前，必须创建一些不同的对象，尽管大部分需要做的事情是由deal.II本身提供。这些对象是
* 

* 
* 

 
* 
* - 网格之间的对象处理转移；我们使用MGTransferPrebuilt类来处理这个问题，它几乎完成了库内的所有工作。
 

* 
* 

* 
* 
* - 最粗层次上的求解器；这里，我们使用MGCoarseGridHouseholder。
* 

 
 

 
* 
* - 所有其他级别的平滑器，在我们的例子中，这将是使用SOR作为基本方法的[2.x.4]类。
* 

* 
* 

* 
 
* 和[2.x.5]一个具有特殊水平乘法的类，即我们基本上为每个网格水平存储一个矩阵并允许与之相乘。
* 这些对象中的大多数只在实际解决线性系统的函数中需要。在这里，这些对象被合并到一个多网格类型的对象中，其中包含V-循环的实现，它又被预设条件器PreconditionMG使用，准备插入到LAC库的线性求解器。
* 这里实现的自适应细化网格的多网格方法遵循[2.x.6]"多网格论文 "中的大纲，其中描述了交易二中的基本实现方式，也介绍了很多术语。首先，我们必须区分层次网格和叶子网格，前者是指与粗略网格有相同解析距离的单元，后者是由层次结构中的活动单元组成的（在较早的工作中，我们将其称为全局网格，但这个术语被过度使用）。最重要的是，叶状网格与最细层次的网格不完全相同。下面的图片显示了我们所认为的 "水平网格"。
* [2.x.7] 
* 这个网格中的精细层次只包括在精炼单元上定义的自由度，而没有延伸到没有精炼的域的那一部分。虽然这保证了整体工作的增长[2.x.8]为最佳多网格复杂度所必需的，但它导致了在定义平滑的位置和对个别层次上定义的算子提出什么边界条件时的问题，如果层次边界不是外部边界。这些问题在上面引用的文章中有详细的讨论。
*[1.x.24][1.x.25]
* 

* 我们在这里解决的问题与[2.x.9]相似，主要有两个不同之处：首先，显然是多网格预处理程序。我们还改变了系数的不连续性，使局部汇编器看起来不会比必要的更复杂。
* 

* [1.x.26] [1.x.27].
* [1.x.28] [1.x.29].
* 

* 
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
* 

 
* [1.x.30]
* 
* 现在，这些是多级方法所需的include。第一个声明了如何处理多网格方法每个层次上的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更低的层次。
* 

* 
* 其余的include文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学问题。
* 

 
* [1.x.31]
* 
* 我们将使用[2.x.10]来循环计算单元，所以在这里包括它。
* 

* 
* [1.x.32]
* 
* 这就是C++。
* 

* 
* [1.x.33]
* 
* [1.x.34] [1.x.35]。  
* 我们使用[2.x.11]来组装我们的矩阵。为此，我们需要一个ScratchData对象来存储每个单元的临时数据（这只是FEValues对象）和一个CopyData对象，它将包含每个单元组装的输出。关于scratch和copy对象的用法的更多细节，请参阅WorkStream命名空间。
* 

* 
* [1.x.36]
* 
* [1.x.37] [1.x.38]
 

* 
* 这个主类与 [2.x.12] 中的同一类相似。就成员函数而言，唯一增加的是。
* 

* 
* 
* - [2.x.13]中的函数，它组装了对应于中间层的离散运算符的矩阵。
* 

* 
* 
* - [2.x.14]函数将我们的PDE组装在一个单元上。
* 

* 
* [1.x.39]
 
* 以下成员是多网格方法的基本数据结构。前四个表示稀疏模式和多级层次结构中各个层次上的矩阵，非常像上面全局网格的对象。    
* 然后我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，正如[2.x.15]"多网格论文 "中详细介绍的那样。    
* 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints类似，但在每个层次上。
* 

* 
* [1.x.40]
 
* [1.x.41] [1.x.42].
 

* 
* 关于三角形的构造函数只有一个简短的评论：按照惯例，deal.II中所有自适应细化的三角形在单元格之间的面的变化都不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。  
* [2.x.16]    
* 这可以通过向三角化类的构造函数传递[2.x.17]标志来实现。
* 

* 
* [1.x.43]
* 
* [1.x.44] [1.x.45].
 

* 
* 除了只是在DoFHandler中分配自由度外，我们在每一层都做同样的事情。然后，我们按照之前的程序，在叶子网格上设置系统。
* 

* 
* [1.x.46]
* 
* 多网格约束必须被初始化。他们需要知道哪里有迪里希特边界条件的规定。
* 

* 
* [1.x.47]
 
* 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏度模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是[2.x.18] 。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。
* 

* 
* [1.x.48]
* 
* 现在，我们必须在每个层次上提供一个矩阵。为此，我们首先使用[2.x.19]函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，请参见[2.x.20]模块），然后把它复制到我们真正想要的那个层次上。下一步是用拟合的稀疏度模式初始化接口矩阵。    
* 值得指出的是，界面矩阵只有位于较粗和较细的网格之间的自由度条目。因此，它们甚至比我们的多网格层次结构中的各个层次的矩阵还要稀疏。因此，我们使用一个专门为此目的而建立的函数来生成它。
* 

* 
* [1.x.49]
* 
* [1.x.50] [1.x.51].
 

* 
* cell_worker函数用于在给定的单元上组装矩阵和右手边。这个函数用于活动单元生成system_matrix，并在每个层次上建立层次矩阵。  
* 请注意，当从assemble_multigrid()调用时，我们也会组装一个右手边，尽管它没有被使用。
* 

* 
* [1.x.52]
* 
* [1.x.53] [1.x.54]
 

* 
* 下面的函数将线性系统组装在网格的活动单元上。为此，我们向Mesh_loop()函数传递两个lambda函数。cell_worker函数重定向到同名的类成员函数，而copyer是这个函数特有的，它使用约束条件将本地矩阵和向量复制到相应的全局矩阵。
* 

* 
* [1.x.55]
* 
* [1.x.56] [1.x.57]
 

* 
* 下一个函数是建立矩阵，定义每一层网格上的多网格方法。集成的核心与上面的相同，但是下面的循环将遍历所有的现有单元，而不仅仅是活动的单元，而且结果必须输入正确的层次矩阵。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数与之前的函数的区别只在于汇编器的设置和循环中不同的迭代器。  
* 我们为每个层次生成一个AffineConstraints对象，其中包含了边界和界面道夫作为约束条目。然后，相应的对象被用来生成层次矩阵。
* 

* 
* [1.x.58]
* 
* 在填充mg_matrices[cd.level]时，界面条目被上面的boundary_constraints对象所忽略。相反，我们手动将这些条目复制到当前级别的界面矩阵中。
* 

* 
* [1.x.59]
* 
* [1.x.60] [1.x.61]
 

* 
* 这是支持多级求解器（或者说，事实上，我们使用多级方法的前置条件器）的另一个明显不同的函数。  
* 让我们首先建立多层次方法的两个组成部分：层次间的转移算子和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束和MGConstrainedDoFs对象，该对象知道每个层次的边界条件和不同细化层次之间接口的自由度，可以从具有层次自由度的DoFHandler对象建立这些转移操作的矩阵。  
* 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。
* 

* 
* [1.x.62]
 
* 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上有一个平滑器。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或解算方法的少量迭代（如CG或GMRES）。[2.x.21]和MGSmootherPrecondition类为这两种平滑器提供支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。    
* 最后一步是用我们的水平矩阵初始化平滑器对象并设置一些平滑参数。[2.x.22]函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在目前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对[2.x.23]的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对[2.x.24]对象的构造函数调用中设置更多选项。    
* 最后一步的结果是我们使用SOR方法作为平滑器的事实
* 
* - 这不是对称的
* 
* - 但我们使用共轭梯度迭代（这需要一个对称的预处理程序）下面，我们需要让多级预处理程序确保我们得到一个对称的算子，即使是非对称的平滑器。
* 

* 
* [1.x.63]
* 
* 下一个准备步骤是，我们必须将我们的级别和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法稍后将使用转置运算器进行后一种操作，允许我们用已经建立的矩阵初始化该运算器的向上和向下版本。
* 

* 
* [1.x.64]
* 
* 现在，我们已经准备好设置V-循环算子和多级预处理。
* 

* 
* [1.x.65]
* 
* 有了这一切，我们终于可以用通常的方法来解决这个线性系统了。
* 

* 
* [1.x.66]
* 
* [1.x.67] [1.x.68].
 

* 
* 以下两个函数在计算出解决方案后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与[2.x.25]中的函数几乎没有变化。
* 

* 
* [1.x.69]
* 
* [1.x.70] [1.x.71].
 

* 
* 和上面的几个函数一样，这几乎是对 [2.x.26] 中相应函数的复制。唯一的区别是对[2.x.27]的调用，它负责形成我们在多网格方法中需要的每一层的矩阵。
* 

* 
* [1.x.72]
* 
* [1.x.73] [1.x.74]
 

* 
* 这又是与[2.x.28]中相同的功能。
 

* 
* [1.x.75]
* [1.x.76][1.x.77] 。
* 

* 在最细的网格上，解决方案看起来像这样。
* [2.x.29] 
* 更重要的是，我们想看看多网格方法是否真的改善了求解器的性能。因此，这里是文本输出。
<pre>第0周期 活动单元数：80 自由度数：89 (按级别：8, 25, 89) CG迭代数。8
* 周期1 活跃单元数：158 自由度数：183（按级别：8，25，89，138） CG迭代次数：9。9
* 周期2 活跃单元数：302 自由度数：352 (按级别：8, 25, 89, 223, 160) CG迭代次数。10
*周期3 活跃单元数：578 自由度数：649 (按级别：8, 25, 89, 231, 494, 66) CG迭代次数。10
* 第四周期 活跃单元数：1100 自由度数：1218 (按级别：8, 25, 89, 274, 764, 417, 126) CG迭代次数。10
* 周期5 活跃单元数：2096 自由度数：2317 (按级别：8, 25, 89, 304, 779, 1214, 817) CG迭代次数。11
* 第六周期 活跃单元数：3986 自由度数：4366 (按级别：8, 25, 89, 337, 836, 2270, 897, 1617) CG迭代次数。10
*周期7 活动单元数：7574 自由度数：8350 (按级别：8, 25, 89, 337, 1086, 2835, 2268, 1789, 3217) CG迭代次数。11</pre>
* 这几乎是完美的多重网格性能：线性残差在10次迭代步骤中减少了12个数量级，而且结果几乎与网格大小无关。这显然部分是由于所解决的问题的简单性质，但它显示了多网格方法的力量。
* 

* [1.x.78][1.x.79].
* 

* 
* 我们鼓励你生成solve()调用的时间，并与 [2.x.30] 进行比较。你会看到多网格方法在粗网格上有相当大的开销，但在细网格上，由于其最佳的复杂性，它总是能击败其他方法。
* 仔细检查这个程序的性能，就会发现它主要是由矩阵-向量操作主导的。 [2.x.31]展示了一种可以通过使用无矩阵方法来避免这种情况的方法。
* 另一个途径是使用代数多网格方法。这里使用的几何多网格方法有时会有点难实现，因为它需要所有这些额外的数据结构，如果程序要在通过MPI耦合的机器上并行运行，例如，就会变得更加困难。在这种情况下，如果我们能使用一个黑盒子去修饰，那就更简单了，它使用某种多网格层次结构以获得良好的性能，但可以自己计算出水平矩阵和类似东西。代数多栅方法正是这样做的，我们将在[2.x.32]中使用它们来解决斯托克斯问题，在[2.x.33]和[2.x.34]中使用它们来解决平行变分。也就是说，这个例子程序的MPI并行版本可以在[2.x.35]中找到。
* 最后，人们可能想考虑如何将几何多网格用于其他类型的问题，特别是[2.x.36]"矢量值问题"。这是[2.x.37]的主题，我们在这里使用了斯托克斯方程的技术。
* 

* [1.x.80][1.x.81] [2.x.38] 。
* [0.x.1]

