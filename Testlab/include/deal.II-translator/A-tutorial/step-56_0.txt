include/deal.II-translator/A-tutorial/step-56_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [1.x.29]
* [2.x.3]
* [1.x.30][1.x.31][1.x.32] 。


*[1.x.33][1.x.34]


* 本教程的目的是为斯托克斯方程创建一个高效的线性求解器，并将其与其他方法进行比较。  在这里，我们将使用FGMRES与几何多栅作为预处理速度块，并将在结果部分显示，这是比[2.x.4]中使用的线性求解器（包括 "可能的扩展 "中描述的方案）更好的根本性方法。  从根本上说，这是因为只有多网格才有可能获得[2.x.5]的求解时间，其中[2.x.6]是线性系统的未知数的数量。通过使用Timer类，我们收集了一些统计数据来比较设置时间、求解时间和迭代次数。我们还计算错误，以确保我们所实现的是正确的。
* 让[2.x.7]和[2.x.8] 。斯托克斯方程在非维度形式下读作如下。
* [1.x.35]
*
* 注意，我们使用的是变形张量而不是[2.x.9]（关于两者之间的区别的详细描述可以在[2.x.10]中找到，但总的来说，变形张量更有物理意义，也更昂贵）。
*[1.x.36][1.x.37]
*

* 离散方程的微弱形式自然导致速度场和压力场的节点值的以下线性系统：[1.x.38] 。
*
* 我们的目标是比较几种解决方法。  虽然[2.x.11]使用 "舒尔补码法 "分两步解决了线性系统，但我们本着[2.x.12]中 "结果 "一节所述的方法的精神，使用FMGRES与有效的预处理器一次性解决了该系统。其思路如下：如果我们找到一个块状修饰器[2.x.13]，使矩阵
* [1.x.39]
*
* 是简单的，那么使用该预处理程序的迭代求解器将在几个迭代中得到解决。请注意，我们在这里做的是正确的预处理。  使用舒尔补码[2.x.14]，我们发现
* [1.x.40]
*
*是一个很好的选择。让[2.x.15]是[2.x.16]的近似值，[2.x.17]是[2.x.18]的近似值，我们看到[1.x.41]。
*
* 由于[2.x.19]的目的只是作为一个预处理程序，我们将在上面的方程中使用右边的近似值。
* 正如在[2.x.20]、[2.x.21]中所讨论的，其中[2.x.22]是压力质量矩阵，通过使用CG与ILU作为预处理程序来近似求解，而[2.x.23]是通过多种方法之一得到的：用CG和ILU作为预处理程序求解线性系统，仅仅使用ILU的一次应用，用CG和GMG（GeometricMultigrid，如[2.x.24]中所述）作为预处理程序求解线性系统，或者仅仅执行GMG的一个V-循环。
* 作为比较，我们还在整个系统上使用了直接求解器UMFPACK，而不是FGMRES，来比较我们的结果。  如果你想使用直接求解器（如UMFPACK），系统需要是可逆的。为了避免恒定压力带来的一维无效空间，我们将第一个压力未知数固定为零。这对迭代求解器来说是没有必要的。
*

*[1.x.42][1.x.43] 。


* 测试问题是一个 "制造的解决方案"（详见[2.x.25]），我们选择[2.x.26]和[2.x.27] .我们在域的整个边界上对速度应用迪里希特边界条件[2.x.28] .为了执行边界条件，我们可以直接使用我们的参考解决方案。
* 如果你在deal.II手册中查找创建一个源自[2.x.29]的类所需的内容，你会发现这个类有许多[2.x.30]函数，包括[2.x.31] [2.x.32] [2.x.33]等，所有这些都可以被重载。  deal.II的不同部分将需要这些特定函数中的不同部分。这在一开始会让人感到困惑，但幸运的是，你真正需要实现的只有[2.x.34]，函数类中的其他虚拟函数在默认情况下会调用你对[2.x.35]的实现。
* 请注意，我们的参考方案符合 [2.x.36] 。此外，压力被选择为平均值为零。  在[2.x.37]的 "制造解决方案的方法 "中，我们需要找到[2.x.38]，以便。
* [1.x.44]

* 使用上面的参考解，我们得到。
* [1.x.45]
*
* [1.x.46][1.x.47] 。


*因为我们在线性系统中没有强制要求平均压力为零，所以我们需要在求解后对解决方案进行后处理。为了做到这一点，我们使用[2.x.39]函数来计算压力的平均值，并将其从压力中减去。
*

*[1.x.48][1.x.49]


* 我们在这里实现几何多网格的方式只对速度变量（即上面描述的[2.x.40]矩阵）而不是压力进行执行。我们可以用不同的方法来实现这一点，包括将所有粗网格操作视为作用于[2.x.41]块系统，而我们只考虑左上角的块。另外，我们也可以通过真正只考虑整个有限元离散化的速度部分的线性系统来实现。后者是我们在这里想要使用的方式。
* 为了实现这一点，我们需要能够提出这样的问题："我可以只拥有一个DoFHandler的一部分吗？"。在写这个程序的时候，这是不可能的，所以为了满足我们的需求，我们只是为velocities创建一个单独的、第二个DoFHandler。然后，我们只根据这个第二DoFHandler为多网格预处理程序建立线性系统，并简单地将第一块（整体）向量转为整个第二DoFHandler的相应向量。为了实现这一目的，我们必须保证两个DoFHandler对象中的（速度）自由度排序的[1.x.50]是相同的。这实际上是通过首先在两个对象上分配自由度，然后在两个对象上使用相同的DoFRenumbering操作序列来实现的。
*

*[1.x.51][1.x.52]


* [2.x.42]和[2.x.43]之间的主要区别是，我们使用块解算器而不是[2.x.44]中使用的Schur补足方法。这种方法的细节可以在[2.x.45]的 "可能的扩展 "部分的 "Block Schur Complement preconditioner "小节中找到。对于速度块的预处理，我们从[1.x.53]中借用了一个名为[2.x.46]的类，该类可以选择求解[2.x.47]的逆，或者只对其应用一个预处理扫频，这分别为我们提供了一种昂贵和便宜的方法。
*

* [1.x.54] [1.x.55]。
* [1.x.56] [1.x.57]。



*


* [1.x.58]
*
* 我们需要包括以下文件来做计时。
*


* [1.x.59]
*
* 这包括我们使用几何多网格所需的文件
*


* [1.x.60]
*
* 为了方便在使用的不同求解器之间进行切换，我们声明了一个枚举，可以作为参数传递给主类的构造函数。
*


* [1.x.61]
*
* [1.x.62] [1.x.63].
* 类Solution是用来定义边界条件和计算数值解的误差的。请注意，我们需要定义数值和梯度，以便计算L2和H1误差。在这里，我们决定使用模板的特殊化来分离2D和3D的实现。   
* 请注意，前面的昏暗分量是速度分量，最后一个是压力。
*


* [1.x.64]
*
* 注意，对于梯度，我们需要返回一个Tensor<1,dim>。
*


* [1.x.65]
*
* [2.x.48]的实现。更多信息见介绍。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。



* 在下文中，我们将实现一个预处理程序，它扩展了 [2.x.49] 的结果部分所讨论的想法。具体来说，我们1.使用一个上块三角的预处理器，因为我们想使用右预处理。2.可选择允许使用速度块的内部求解器，而不是单一的预处理程序应用。3.不使用InverseMatrix，而是明确地调用SolverCG。这种方法也被用于ASPECT代码（见https://aspect.geodynamics.org），该代码在模拟地幔对流的背景下求解斯托克斯方程，该代码已被用于解决成千上万个处理器上的问题。   
* 构造函数中的bool标志[2.x.50]允许我们对速度块应用一次预处理，或者使用内部迭代求解器来代替更精确的近似。   
* 注意我们是如何跟踪内部迭代的总和（预处理程序的应用）的。
*


* [1.x.69]

*首先用S的近似值求解
*


* [1.x.70]
*
* 其次，应用右上方的块状物（B^T）。
*


* [1.x.71]
*
* 最后，要么用左上角的区块进行求解，要么只应用一个预处理器进行清扫
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。
* 这是该问题的主要类别。
*


* [1.x.75]

* 仅为速度的有限元。
*


* [1.x.76]

* 整个系统的有限元。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 这个函数设置了DoFHandler、矩阵、向量和Multigrid结构（如果需要）。
*


* [1.x.80]
*
* 主DoFHandler只需要活动的DoF，所以我们不在这里调用distribution_mg_dofs()。
*


* [1.x.81]
*
* 这个块结构将dim速度分量与压力分量（用于重新排序）分开。注意，我们有2个而不是像[2.x.51]中的dim+1块，因为我们的FES系统是嵌套的，dim速度分量作为一个块出现。
*


* [1.x.82]
*
* 速度从组件0开始。
*


* [1.x.83]
*
* 如果我们应用重排序来减少填充，ILU的表现会更好。对于其他求解器来说，这样做并没有什么好处。
*


* [1.x.84]
*
* 这确保所有的速度DoF在压力未知数之前被列举出来。这允许我们使用块来处理向量和矩阵，并允许我们为dof_handler和velocity_dof_handler获得相同的DoF编号。
*


* [1.x.85]
*
* 这将在一个单独的DoFHandler中分配速度空间的主动道夫和多网格道夫，如介绍中所述。
*


* [1.x.86]
*
* 下面的代码块初始化了MGConstrainedDofs（使用速度的边界条件），以及每个层次的稀疏模式和矩阵。MGLevelObject<T>的resize()函数将破坏所有现有的包含对象。
*


* [1.x.87]
*
* 下面利用分量掩码对速度的边界值进行插值，这在矢量值dealii [2.x.52]教程中进一步解释。
*


* [1.x.88]
*
* 正如介绍中所讨论的，我们需要固定压力变量的一个自由度以确保问题的可解性。我们在这里通过标记第一个压力自由度来做到这一点，该自由度的索引为n_u，是一个受约束的自由度。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 在这个函数中，系统矩阵被组装起来。我们在(1,1)块中组装压力质量矩阵（如果需要），并在此函数结束时将其移出该位置。
*


* [1.x.92]
*
* 如果是真的，我们将在(1,1)块中组装压力质量矩阵。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 在这里，就像在[2.x.53]中一样，我们有一个函数来组装多棱镜前处理程序所需的水平和界面矩阵。
*


* [1.x.96]
*
* 这个迭代器覆盖所有的单元格（不仅仅是活动的）。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 这个函数根据你是否想使用ILU或GMG作为预处理程序来设置不同的东西。  这两种方法共享相同的求解器（FGMRES），但需要初始化不同的预处理器。在这里，我们不仅对整个求解函数进行计时，而且对预调节器的设置以及求解本身分别进行计时。
*


* [1.x.100]
*
*在这里，我们必须确保以 "足够好 "的精度来解决残差问题
*


* [1.x.101]
*
* 这是用来传递我们是否要在预处理程序中求解A的信息。  我们可以把它改为false，看看是否还有收敛性，如果有的话，程序会不会运行得更快或更慢。
*


* [1.x.102]
*
* 在各级之间转移操作者
*


* [1.x.103]
*
*设置粗略的网格求解器
*


* [1.x.104]
*
* Multigrid，当作为CG的预处理程序时，需要是一个对称的算子，所以平滑器必须是对称的
*


* [1.x.105]

* 现在，我们准备设置V型循环算子和多级预处理程序。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 这个函数计算出解决方案的L2和H1误差。为此，我们需要确保压力的平均值为零。
*


* [1.x.109]
*
* 计算平均压力[2.x.54]，然后从每个压力系数中减去它。这将产生一个平均值为零的压力。这里我们利用了压力是分量[2.x.55]和有限元空间是节点的事实。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 这个函数生成图形输出，就像在 [2.x.56] 中那样。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
*斯托克斯类的最后一步是，像往常一样，生成初始网格的函数，并按各自的顺序调用其他函数。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。



* [1.x.119]
*
* SolverType的选项。umfpack fgmres_ilu fgmres_gmg
*


* [1.x.120]
*[1.x.121][1.x.122]


*[1.x.123][1.x.124] 。


* 我们首先运行代码，确认有限元解以混合有限元问题的误差分析所预测的正确速率收敛。鉴于足够平滑的精确解[2.x.57]和[2.x.58]，Taylor-Hood元[2.x.59]的误差应该是
* [1.x.125]
*例如见Ern/Guermond "有限元素的理论与实践"，第4.2.5节第195页。这确实是我们观察到的，以[2.x.60]元素为例（这就是代码中的做法，但在[2.x.61]中很容易改变）。
* [2.x.62]
* [1.x.126][1.x.127]。
*

* 让我们比较一下使用UMFPACK的直接求解方法和我们选择[2.x.63]和[2.x.64]的两种方法，即使用CG求解[2.x.65]的线性系统。CG的预处理程序是ILU或GMG。下表总结了求解器的迭代次数、时间和虚拟内存（VM）的峰值使用。
* [2.x.66]
* 从表中可以看出。
* 1. UMFPACK使用了大量的内存，特别是在3D中。而且，UMFPACK的优化并不随问题的大小而扩展。
* 2. 因为我们对[2.x.67]和[2.x.68]使用内部求解器，ILU和GMG需要相同数量的外部迭代。
* 3. ILU对[2.x.69]的（内部）迭代次数随着细化而增加，导致求解时间的线性扩展性差。相比之下，[2.x.70]的内部迭代次数在GMG中保持不变，导致解算时间几乎完美的缩放。
* GMG需要比ILU多一点的内存来存储水平和界面矩阵。
* [1.x.128][1.x.129] 。
*

*[1.x.130][1.x.131]


* 用高阶稳定的FE对进行实验，检查你是否观察到正确的收敛率。
*[1.x.132][1.x.133]
*

* 介绍中还概述了另一种对整个系统进行预处理的方案，即我们不选择上表中的[2.x.71]，而只选择[2.x.72]，分别用GMG或ILU的单一预处理程序。
* 这实际上是在代码中实现的。目前，布尔值[2.x.73]被设置为[2.x.74] 上面提到的选项是通过设置为[2.x.75]得到的。
* 你会发现，如果你以这种方式使用GMG，FGMRES的迭代次数在细化过程中是不变的。这意味着Multigrid是最优的，并且与[2.x.76]无关。
*

*[1.x.134][1.x.135] [2.x.77]
* [0.x.1]

