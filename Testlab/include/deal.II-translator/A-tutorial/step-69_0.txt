include/deal.II-translator/A-tutorial/step-69_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16 ][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31]
* [1.x.32]
* [2.x.3] [2.x.4] 桑迪亚国家实验室是由霍尼韦尔国际公司的全资子公司桑迪亚国家技术与工程解决方案有限公司根据DE-NA0003525号合同为美国能源部国家核安全局管理和运营的一个多任务实验室。本文件描述了客观的技术结果和分析。文件中可能表达的任何主观观点或意见不一定代表美国能源部或美国政府的观点。[2.x.5] 
* [2.x.6] 本教程步骤实现了一个基于一阶精确的[1.x.33]，用于解决欧拉气体动力学方程[2.x.7]。因此，它主要是为教育目的而提出的。对于实际的研究计算，你可能要考虑探索相应的[1.x.35]，使用[1.x.36]技术，以及强保稳（SSP）时间积分，见[2.x.8] （[1.x.37]）。
* [2.x.9] 
* [1.x.38][1.x.39][1.x.40]
* 

* 本教程提出了一个用于求解可压缩欧拉方程的一阶方案，该方案基于三个要素：在有限元背景下对欧拉方程进行[1.x.41]型离散化；基于[1.x.42]局部波速上界的图粘性稳定化；以及明确的时间步进。因此，本教程步骤中提出的想法和技术与[2.x.10]中使用的想法和技术有很大的不同，后者侧重于使用自动微分。从编程的角度来看，本教程将关注在大规模计算中发现的一些技术：混合线程-MPI并行化；有效的局部自由度编号；使用工作线程的并发后处理和结果的写入；以及检查点和重新启动。
* 应该指出的是，双曲守恒定律背景下的一阶方案需要太多的自由度来解决模拟流体的某些关键特征，因此，通常只能作为高阶方案的基本构件 [2.x.11] 。然而，我们希望读者在进入完整的研究代码（如[2.x.12]中讨论的二阶方案）之前，仍然认为这个教程步骤是一个很好的起点（特别是在编程技术方面）。
* 

* [1.x.43][1.x.44][1.x.45] 。
* 

* 气体动力学的可压缩欧拉方程以非保守形式书写如下。
* [1.x.46]
* 其中[2.x.13] ，和[2.x.14] ，以及[2.x.15]是间隔维。我们说，[2.x.16]是状态，[2.x.17]是系统的通量。在欧拉方程的情况下，状态由[2.x.18]给出：其中[2.x.19]表示密度，[2.x.20]是动量，而[2.x.21]是系统的总能量。系统的通量[2.x.22]被定义为
* [1.x.47]
*其中[2.x.23]是身份矩阵，[2.x.24]表示张量积。在这里，我们介绍了压力[2.x.25]，在一般情况下，它是由一个封闭式的状态方程定义的。在本教程中，我们将讨论限制在多暴发性气体的范畴内，对于这些气体，压力由以下公式给出
* [1.x.48]
*其中因子[2.x.26]表示[1.x.49]。
* 

* [1.x.50][1.x.51] 。
* 

* 双曲守恒定律，如
* [1.x.52]
* 对解决理论构成了重大挑战。一个明显的现象是，以变分形式重写方程并以解本身进行检验并不能得出能量估计，因为配对[2.x.27]（可理解为[2.x.28]内积或对偶性配对）不能保证是负的。在这种情况下，诸如能量稳定性或[2.x.29]稳定性之类的概念（一般来说）是没有意义的。
* 历史上，为了加深对双曲守恒定律的理解而采取的最有成效的步骤是假设解决方案被正式定义为[2.x.30]，其中[2.x.31]是抛物线正则化的解决方案。
* [1.x.53]
* 这是因为在物理上[2.x.32]可以被理解为与流体的粘度有关，也就是说，一个表示以不同速度运动的相邻气体粒子对彼此施加的摩擦力的量。欧拉方程本身是在无摩擦的假设下推导出来的，但在物理上可以期望描述摩擦力或粘度消失的极限情况。）这种解决方案的全球存在和唯一性是一个开放的问题。然而，我们至少知道，如果这种粘度解决方案存在，它们必须满足所有[2.x.34]和[2.x.35]的约束条件，其中
* [1.x.55]
* 这里，[2.x.36]表示比熵。
* [1.x.56]
* 我们将把[2.x.37]称为欧拉方程的不变集。换句话说，一个状态[2.x.38]服从密度的正性，内能的正性，以及比熵的局部最小原则。这个条件是一类由精确（粘性）解满足的点状稳定性约束的简化版。我们所说的 "点 "是指该约束必须在域的每一点上得到满足，而不仅仅是在平均（积分，或高阶矩）意义上。
* 在数值逼近的背景下，违反这样的约束会产生可怕的后果：它几乎肯定会导致数值方案的灾难性失败，失去双曲性，以及总体上失去（离散）问题的良好处理性。这也意味着我们计算了一些不能从物理上解释的东西。(例如，我们该如何看待一个具有负密度的计算出的解？) 在下文中，我们将制定一个方案，确保[2.x.39]的离散近似值保持在[2.x.40]中。
* 

* [1.x.57][1.x.58] 。
* 

* 根据[2.x.41]、[2.x.42]、[2.x.43]和[2.x.44]，在这一点上，可能会试图将欧拉方程的离散化建立在（半离散）变分公式之上。
* [1.x.59]
* 这里，[2.x.45]是一个适当的有限元空间，[2.x.46]是一些线性稳定方法（可能辅以一些临时的冲击捕捉技术，例如见[2.x.47]的第五章和其中的参考文献）。在deal.II教程中描述的大多数时间相关离散化方法都是基于这样一种（半离散）的变分方法。从根本上说，从分析的角度来看，变分离散化被认为是提供某种全局（积分）稳定性的概念，也就是说，一个估计的形式是
* [1.x.60]
*成立，其中[2.x.48]可以代表[2.x.49]准则，或者更广泛地代表一些离散的（可能与网格有关）能量准则。自80年代中期以来，双曲守恒定律的变异离散化非常流行，特别是与SUPG型稳定化和/或上绕技术相结合（见[2.x.50]和[2.x.51]的早期工作）。它们已被证明是在亚声速无冲击体系和类似的良性情况下进行模拟的一些最佳方法。
* <! -- 特别是，教程[2.x.52]侧重于使用dG技术研究亚声速体系中的欧拉气体动力学方程。
* 
* - >
* 然而，在跨音速和超音速体系中，以及冲击-流体力学应用中，使用变分方案可能是值得怀疑的。事实上，在写这篇文章的时候，大多数冲击-流体力学代码仍然坚定地以有限体积方法为基础。变分方案在这种极端状态下失败的主要原因是缺乏点可控性。这是因为[1.x.61]对积分量（如矩积分）的约束一般对解的点定性没有影响。虽然其中一些问题可以通过对正确的冲击捕捉方案的（永久）追逐而得到缓解，但类似有限差分和有限体积方案在许多方面仍有优势。
* 因此，在这一教程步骤中，我们偏离了变分方案。我们将提出一个完全代数化的表述（具有ollocation类型方案的味道），该表述在点上保留约束，即。
* [1.x.62]
* 与有限差分/体积方案相反，本步骤实现的方案最大限度地利用了有限元软件的基础设施，在任何空间维度的任何网格上都能工作，并且理论上保证始终工作，没有例外。这说明deal.II的使用范围远远超出了希尔伯特空间中的变分方案，deal.II中的大量类、模块和命名空间都可以用于这一目的。
* 

* [1.x.63][1.x.64] 。
* 

* 让[2.x.53]为标量值的有限维空间，由abasis[2.x.54]跨越，其中。 [2.x.55]和[2.x.56]是识别网格中每个标量自由度（DOF）的所有指数（非负整数）的集合。因此，标量有限元函数[2.x.57]可以写成[2.x.58]与[2.x.59] 。我们引入矢量值近似空间的符号 [2.x.60] 。设[2.x.61]，则可以写成[2.x.62]，其中[2.x.63]和[2.x.64]是标量值的形状函数。
* [2.x.65] 我们特意在符号中不使用矢量值有限元空间。矢量值有限元空间对于PDE系统（例如Navier-Stokes）的变分公式是很自然的。在这种情况下，必须计算的相互作用描述了[1.x.65]：通过对矢量值DoFHandler的适当重新编号（即用FESystem初始化），可以相对容易地计算块矩阵（为了推进解决方案而需要）。然而，在时间明确的搭配型方案（如有限差分和/或本教程中提出的方案）的背景下，必须计算的相互作用可以更好地描述为[1.x.66]（而不是在DOF之间）。此外，在我们的案例中，我们不解决线性方程，以推进解决方案。这使得在理论和/或实践中使用矢量值无限元空间的理由非常少。
* 我们将使用通常的拉格朗日有限元：让[2.x.66]表示所有支持点的集合（见[2.x.67] "thisglossary entry"），其中[2.x.68] 。那么每个索引[2.x.69]都能唯一地识别一个支持点[2.x.70]，以及ascalar-value形状函数[2.x.71] 。有了这个符号，我们可以将（显式时间步进）方案定义为。
* [1.x.67]
* 其中
* 

* 
* 

 
* 
* - [2.x.72]是块状质量矩阵
* 

* 
* 

* 
* 
* - [2.x.73]是时间步长大小
* 

* 
* 

* 
* 
* - [2.x.74]（注意[2.x.75]）是一个矢量值矩阵，被用来在弱意义上近似通量的发散。
* 

* 
* 

* 
* 
* - [2.x.76]是包含与索引[2.x.77]耦合的所有自由度的邻接列表。换句话说，[2.x.78]包含行索引i的所有非零列索引。[2.x.79]也将被称为 "模版"。
* 

* 
* 

* 
* 
* - [2.x.80]是针对与支持点[2.x.83]相关的状态[2.x.82]评估的双曲系统的通量[2.x.81] 。
* 

* 
* 

* 
* 
* - [2.x.84] 如果[2.x.85]是所谓的[1.x.68]。图形粘度作为一个稳定项，它在某种程度上是[2.x.86]的离散对应物，出现在上述的粘度解的概念中。我们将把[2.x.87]的构造建立在最大局部波速[2.x.88]的估计上，稍后将详细解释。
* 

* 
* 

* 
* 
* - 粘度矩阵的对角线项被定义为 [2.x.89] 。
* 

* 
* 

* 
* 
* - [2.x.90]是[2.x.91]矩阵的归一化，它进入了近似黎曼求解器，我们用它来计算本地波速的近似值[2.x.92]。这将在下文中进一步解释）。
* [2.x.93]的定义远非易事，我们将推迟精确的定义，以便首先关注一些算法和实施问题。我们注意到
* 

* 
* 

* 
* 
* - [2.x.94]和[2.x.95]在时间上不发生变化（只要我们保持离散性固定）。因此，在所谓的[1.x.69]中对这些矩阵/向量进行一次组装并在每个时间步长中重复使用是有意义的。它们是我们所说的离线数据的一部分。
* 

* 
* 

* 
* 
* - 在每个时间步骤中，我们必须评估[2.x.96]和[2.x.97]，这将构成大部分的计算成本。
* 考虑以下伪代码，说明在新的时间[2.x.99]计算解决方案[2.x.98]的可能直接策略，给定时间[2.x.101]的已知状态[2.x.100] 。
* [1.x.70]
* 
* 我们在这里注意到。
* 
* - 这种 "装配 "不需要任何形式的正交或单元循环。
* 
* - 这里[2.x.102]和[2.x.103]是一个全局矩阵和一个全局向量，分别包含所有向量[2.x.104]和所有状态[2.x.105]。
* 
* - [2.x.106]、[2.x.107]和[2.x.108]是假设的实现，它们是收集（来自）或写入（进入）全局矩阵和向量。
* 
* - 如果我们假设一个二维空间的笛卡尔网格，一阶多项式空间 [2.x.109] ，并且 [2.x.110] 是一个内部节点（即 [2.x.111] 不在域的边界上），那么。 [2.x.112]应该包含九个状态矢量元素（即与形状函数[2.x.113]相关的补丁/宏元素中的所有状态）。这是与通常的基于单元的循环的主要区别之一，在这种循环中，收集功能（在deal.II的情况下编码为FEValuesBase<dim, spacedim>.get_function_values()）只收集本地单元的值（只是补丁的一个子集）。
* 实际执行将在一个关键方面偏离上述代码：时间步长[2.x.114]必须在CFL条件下选择。
* [1.x.71]
*其中[2.x.115]是一个选定的常数。这将需要在实际执行上述更新之前，在一个单独的步骤中计算所有的[2.x.116]。但核心原则没有改变：我们不在单元格上循环，而是在稀疏图的所有边上循环。
* [2.x.117] 在有限元社区之外，在更广泛的CFD社区，遇到这种全代数方案（即没有双线性形式，没有单元循环，也没有正交）并不罕见。这类方案有丰富的应用历史，也被称为[1.x.72]或[1.x.73]有限元方案（例如，见[2.x.118]的历史概述）。然而，需要强调的是，该方案的代数结构（在本教程中介绍）和节点循环并不只是一个性能上的噱头。实际上，这个方案的结构是出于理论上的需要：该方案的点稳定性证明取决于该方案的特定代数结构。此外，不可能用单元环计算代数粘度[2.x.119]，因为它们非线性地依赖于跨越一个以上单元的信息（叠加不成立：将不同单元的贡献相加不会导致正确结果）。
*[1.x.74][1.x.75]
* 

* 在本教程所考虑的例子中，我们使用了三种不同类型的边界条件：本质类边界条件（我们在域的左侧边界规定了一个状态），域的右侧边界的流出边界条件（也称为 "无为 "边界条件），以及障碍物顶部、底部和表面的 "反射 "边界条件[2.x.120]（也称为 "滑动 "边界条件）。我们不会过多地讨论必要的和 "无为 "的边界条件，因为它们的实现相对容易，读者可以直接从（有记录的）源代码中获取实现。在这部分介绍中，我们将只关注 "反映 "的边界条件，这在某种程度上是比较棘手的。
* [2.x.121] 在写这篇文章的时候（2020年初），说双曲守恒定律系统的稳定边界条件的分析和实现都是一个开放的问题也不是没有道理的。对于变量公式的情况，稳定的边界条件是那些导致良好的（胁迫的）双线性形式。但对于一般的双曲守恒定律系统（以及本教程中使用的代数式），胁迫性作为稳定性的一个概念没有适用性和/或意义。在本教程中，我们将使用不变集的保存作为稳定性的主要概念，它（至少）保证了离散问题的良好处置性。
* 对于反射边界条件的情况，我们将按以下步骤进行。
* 
* - 对于每一个时间步长，完全不满足边界条件的情况下。
* 
* - 让[2.x.122]为我们要执行反射边界条件的那部分边界。在时间步骤结束时，我们在一个后处理步骤中强烈地执行反射边界条件，在这个步骤中我们执行投影   
* [1.x.76]
* 移除[2.x.123]的法线部分。这是一个有点天真的想法，保留了PDE的一些基本属性，我们在下面解释。
* 毫无疑问，在求解抛物线或椭圆方程时，我们通常通过使它们成为近似空间[2.x.124]的一部分来强制执行必要的（类似于Dirichlet的）边界条件，并将自然的（例如Neumann）边界条件作为变量公式的一部分。我们也知道，边界条件的明确处理（在抛物线型PDEs的背景下）几乎肯定会导致灾难性的后果。然而，在非线性双曲方程的背景下，我们有。
* 
* - 比较容易证明（对于反映边界条件的情况）边界条件的明确处理不仅是保守的，而且还能保证对所有[2.x.125]的属性[2.x.126]（良好处理）的保存。这也许是使用边界条件的显式执行的最重要的原因。
* 
* 就我们所知：我们不知道有什么数学结果可以证明，在对近似空间直接执行边界条件或使用尼采惩罚方法（例如广泛用于非连续Galerkin方案）进行弱执行时，有可能保证所有[2.x.127]的特性。此外，其中一些传统的想法导致了相当严格的时间步长约束。
* 
* - 有足够的数值证据表明，在CFL条件下，对Dirichlet-like边界条件的明确处理是稳定的，不会带来任何精度上的损失。
* 如果[2.x.129]代表欧拉方程，在整个边界上反映边界条件（即[2.x.130]），我们在空间和时间上进行积分[2.x.131]，我们将得到
* [1.x.77]
* 尽管我们不会在整个域中使用反射边界条件，但我们想知道我们对反射边界条件的实现与上面提到的守恒特性是一致的。特别是，如果我们在域的全部范围内使用投影[2.x.133]，可以保证以下离散质量平衡。
* [1.x.78]
*其中[2.x.134]是位于边界的节点上的压力。显然，[2.x.135]是[2.x.136]的离散对应物。我们省略了特征[2.x.137]的证明，但我们简要地提到，它取决于[2.x.139]中提供的[1.x.79][2.x.138]的定义。我们还注意到，这种反映边界条件的执行与最初在[2.x.140]中提出的不同。
* 

* [1.x.80] [1.x.81] 。
* [1.x.82] [1.x.83] 。
 

* 
* 这套包含文件是相当标准的。最耐人寻味的部分是，我们将完全依靠deal.II数据结构进行MPI并行化，特别是通过[2.x.141]和[2.x.142]包含的[2.x.143]和[2.x.144] 。我们将使用非分布式的 [2.x.145] ( [2.x.146] ) 来存储 [2.x.147] 、 [2.x.148] 和 [2.x.149] 矩阵的局部部分，而不是 Trilinos 或 PETSc 特定的矩阵类。
* 

* 
* [1.x.84]
* 
* 除了上述deal.II特定的包括，我们还包括四个提升头文件。前两个是二进制文件，我们将用它来实现检查点和重启机制。
* 

* 
* [1.x.85]
* 
* 最后两个头文件是用于在整数间隔上创建自定义迭代器范围。
* 

* 
* [1.x.86]
* 
* 对于[2.x.150] [2.x.151] [2.x.152] [2.x.153]和[2.x.154] 
 

 
* [1.x.87]
* 
* [1.x.88] [1.x.89]。
 

* 
* 我们开始实际的实现，先声明所有的类及其数据结构和方法。与之前的例子步骤相比，我们使用了更精细的概念、数据结构和参数封装到各个类中。因此，一个单一的类通常围绕着一个单一的数据结构（如[2.x.155]类中的Triangulation），或者一个单一的方法（如[2.x.157]类的[2.x.156]函数）。我们通常声明参数变量和抓取数据对象为 "私有"，并使其他类使用的方法和数据结构为 "公共"。
* 

* 
* 

* 
* [2.x.158] 一个更干净的方法是通过[1.x.90]来保护对所有数据结构的访问。为了简洁起见，我们不采用这种方法，不过。
* 

* 
* 我们还注意到，绝大多数的类都是从ParameterAcceptor派生的。这有利于将所有的全局参数归入一个（全局）ParameterHandler。关于从ParameterAcceptor继承作为全局订阅机制的更多解释可以在 [2.x.159] 中找到。
* 

* 
* [1.x.91]
 
* 我们首先定义了一些[2.x.160]常量，在整个教程步骤中使用。这使得我们可以用一个助记符（如[2.x.161] ）而不是一个数值来指代边界类型。
* 

* 
*  

* 
* [1.x.92]
* 
* [1.x.93] [1.x.94].   
* [2.x.162]类包含所有关于问题的网格（三角形）和离散化（映射、有限元、正交）的数据结构。如前所述，我们使用ParameterAcceptor类来自动填充特定问题的参数，如几何信息（[2.x.163] 等）或来自参数文件的细化水平（[2.x.164] ）。这就要求我们把数据结构的初始化分成两个函数。我们在构造函数中初始化所有不依赖于参数的东西，并将网格的创建推迟到[2.x.165]方法，一旦所有参数通过[2.x.166]读入，就可以调用该方法。
 

* 
* [1.x.95]
* 
* [1.x.96] [1.x.97].   
* [2.x.167]类包含了离散化中几乎所有不随时间演变的组件，特别是DoFHandler、SparsityPattern、边界图、块状质量矩阵、[2.x.168]和[2.x.169]矩阵。这里，术语[1.x.98]指的是[2.x.170]的所有类成员都有明确定义的值，与当前时间步长无关。这意味着它们可以提前初始化（在[1.x.99]），并且不意味着在以后的任何时间步长中被修改。例如，稀疏模式不应该随着时间的推进而改变（我们在空间上不做任何形式的适应性）。同样地，包络质量矩阵的条目也不应该随着时间的推进而被修改。  
* 我们还计算并存储一个[2.x.171]，其中包含一个从边界自由度的[2.x.172]类型的全局索引到一个由法向量、边界ID和与自由度相关的位置组成的元组的映射。我们必须在这个类中计算和存储这些几何信息，因为我们在后面的代数循环中无法获得几何（或基于单元）的信息。  
*  

* 
* [2.x.173] 尽管这个类目前没有任何可以从参数文件中读入的参数，但我们还是从ParameterAcceptor派生出来，并遵循与Discretization类相同的习惯，提供一个[2.x.174] )方法。
* 

* 
* [1.x.100]
* 
* [1.x.101] [1.x.102].   
* 这个类的成员函数是欧拉方程特有的实用函数和数据结构。
* 

* 
* 
* - 类型别名[2.x.175]用于状态[2.x.176]。
* 

* 
* 
* - 类型别名 [2.x.177] 用于通量 [2.x.178] 。
* 

* 
* 
* - [2.x.179]函数从状态向量[2.x.181]中提取[2.x.180]并存储在[2.x.182]中。
* 

* 
* 
* - [2.x.183]函数从给定的状态向量[2.x.185]中计算出[2.x.184] 。  
* 类成员 [2.x.186] , [2.x.187] 的目的从它们的名字就可以看出。我们还提供了一个函数 [2.x.188] ，用于计算上面提到的波速估计， [2.x.189] ，用于计算 [2.x.190] 矩阵。  
*  

* 
* [2.x.191] [2.x.192]宏扩展为一个（编译器特定的）pragma，确保在这个类中定义的相应函数总是内联的，也就是说，在每次调用该函数时，函数体都被放在原位，而不会产生调用（和代码指示）。这比[2.x.193]关键字更强，后者或多或少是对编译器的一个（温和的）建议，即程序员认为内联该函数是有益的。 [2.x.194]应该只在很少的情况下谨慎使用，比如在这种情况下，我们实际上知道（由于基准测试），内联有关的函数可以提高性能。  
* 最后，我们观察到这是本教程步骤中唯一一个与特定的 "物理学 "或 "双曲守恒定律"（在本例中是欧拉方程）相联系的类。所有其他的类主要是 "离散化 "类，与正在解决的特定物理学问题无关。
* 

* 
* [1.x.103]
 
* [1.x.104] [1.x.105].   
* [2.x.195]类的唯一公共数据属性是一个[2.x.196][2.x.197]，用于计算给定点和时间的初始状态。这个函数用于填充初始流场，以及在每个时间步骤中明确设置迪里切特边界条件（在流入边界）。  
* 在这个例子中，我们只是实现了一个均匀的流场，其方向和一维原始状态（密度、速度、压力）都是从参数文件中读取的。  
* 最好是一次性初始化这个类：初始化/设置参数并定义依赖于这些默认参数的类成员。然而，由于我们不知道参数的实际值，这在一般情况下是没有意义的，也是不安全的（我们希望有机制来检查输入参数的一致性）。我们没有定义另一个[2.x.198]方法在调用[2.x.199]后被调用（手动），而是为类成员[2.x.200]提供了一个 "实现"，当调用[2.x.201]时，每个继承自ParameterAceptor的类都会自动调用。
* 

* 
* [1.x.106]
* 
* 我们声明一个私有的回调函数，它将被连接到[2.x.202]信号上。
* 

* 
* [1.x.107]
* 
* [1.x.108] [1.x.109].   
* 有了[2.x.203]类在手，我们现在可以实现上面讨论中介绍的显式时间步进方案。[2.x.204]类的主要方法是<code>make_one_step(vector_type &U, double t)</code>，它接受对状态向量[2.x.205]的引用（作为输入参数）计算更新的解决方案，将其存储在向量[2.x.206]中，并返回选择的[2.x.207]大小[2.x.208] 。  
* 另一个重要的方法是[2.x.209]，主要是为临时向量[2.x.210]分别设置适当的分区和稀疏模式。
* 

* 
* [1.x.110]
* 
* [1.x.111] [1.x.112]。  
* 在其核心，Schlieren类实现了类成员 [2.x.211] 。这个类成员的主要目的是计算一个辅助的有限元场[2.x.212]，它在每个节点上由[1.x.113]定义，[2.x.213]原则上可以是任何标量。但在实践中，密度是一个自然的候选量，即[2.x.214] 。[1.x.114]后处理是一种标准的方法，用于增强可视化的对比度，其灵感来自实际的实验X射线和可视化的阴影技术。见[2.x.215]中另一个例子，我们创建了一个Schlieren图）。
* 

* 
* [1.x.115]
* 
* [1.x.116] [1.x.117].   
* 现在，剩下的就是把[2.x.216],和[2.x.217]类中实现的方法连在一起。我们在一个单独的类[2.x.218]中做到这一点，该类包含每个类的一个对象，并在ParameterAcceptor类的帮助下再次读入一些参数。
* 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120].
 

* 
* [1.x.121] [1.x.122]。
 

* 
* 手头的第一个主要任务是典型的网格生成、数据结构的设置和装配三合一。在这个例子的步骤中，一个值得注意的创新是使用ParameterAcceptor类，我们用它来填充参数值：我们首先初始化ParameterAcceptor类，用一个表示参数文件中正确分段的字符串[2.x.219]来调用它的构造函数。然后，在构造函数中，每个参数值都被初始化为一个合理的默认值，并通过调用[2.x.220]在ParameterAcceptor类中注册。
* 

* 
* [1.x.123]
 
* 注意，在前面的构造函数中，我们只把MPI通信器传给了[2.x.221]，但我们仍然没有初始化底层的几何体/网格。如前所述，我们必须将这项任务推迟到[2.x.222]函数，该函数在[2.x.223]函数用从参数文件中读取的最终值填充所有参数变量后被调用。  
* [2.x.224]函数是最后一个必须实现的类成员。它创建了实际的三角结构，这是一个基准配置，由一个带有盘状障碍物的通道组成，见 [2.x.225] 。我们通过修改[2.x.226]生成的网格来构建几何体。我们参考[2.x.227]，[2.x.228]和[2.x.229]来了解如何创建高级网格。我们首先创建4个临时的（非分布式的）粗略三角形，用[2.x.230]函数将其拼接起来。我们在[2.x.231]处将圆盘作为中心，直径为[2.x.232] 。通道的左下角有坐标( [2.x.233] ) ，右上角有( [2.x.234] , [2.x.235] ) 。
* 

* 
* [1.x.124]
* 
* 我们必须修复目前位于[2.x.236] [2.x.237]的左边缘，并将其移到[2.x.238] [2.x.239] 。作为最后一步，边界必须被着色，右边是[2.x.240]，[2.x.241]是上下外边界和障碍物。
* 

* 
*  

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127]。
 

* 
* 在[2.x.242]的构造函数中，除了在初始化列表中初始化相应的类成员外，没有做太多的工作。
* 

* 
* [1.x.128]
* 
* 现在我们可以初始化DoFHandler，为本地拥有的和本地相关的DOF提取IndexSet对象，并初始化一个[2.x.243]对象，这是分布式向量需要的。
* 

* 
* [1.x.129]
 
* [1.x.130] [1.x.131].
 

* 
* 我们现在可以为我们的矩阵创建稀疏模式了。有不少特殊性需要详细解释。我们避免使用分布式矩阵类（例如由Trilinos或PETSc提供的），而是依靠deal.II自己的SparseMatrix对象来存储所有矩阵的局部部分。这一设计决定的动机是：(a)我们实际上从未进行过矩阵-向量乘法，(b)我们总是可以在一个给定的MPI等级上专门组装矩阵的局部部分。相反，我们将计算非线性更新，同时迭代连通性模版的（局部）部分；这是deal.II自己的SparsityPattern专门为之优化的任务。    
* 不过，这种设计考虑有一个注意事项。让deal.II SparseMatrix类变得快速的是SparsityPattern中使用的[1.x.132]（见[2.x.244]）。不幸的是，这与全局分布式索引范围不相称，因为具有CSR的稀疏模式不能在索引范围内包含 "洞"。deal.II提供的分布式矩阵通过将全局索引范围转化为连续的局部索引范围来避免这一点。但这正是我们在迭代模版时想要避免的索引操作类型，因为它产生了一个可衡量的开销。    
* [2.x.245]类已经实现了从全局索引范围到连续的局部（每个MPI等级）索引范围的转换：我们不必重新发明车轮。我们只需要使用这种转换能力（一次，而且只有一次），以便为连续的索引范围创建一个 "本地 "稀疏模式 [2.x.246] [2.x.247] [2.x.248] 。这种能力可以通过[2.x.249]函数调用。一旦使用本地索引创建了稀疏模式，剩下要做的就是确保（在实现我们的散布和聚集辅助函数时）我们总是通过调用[2.x.250]来访问分布式向量的元素，这样我们就完全避免了索引转换，并完全使用本地索引进行操作。
* 

* 
*  

* 
* [1.x.133]
* 
* 我们必须手工创建 "局部 "的稀疏模式。因此，我们在所有本地拥有的和重影的单元上进行循环（见 [2.x.251] GlossArtificialCell），并提取与单元DOF相关的（全局） [2.x.252] ，并使用 [2.x.253] 对其重新编号。      
*  

* 
* [2.x.254] 在本地拥有的DOF的情况下，这种重新编号包括应用一个移位（即我们减去一个偏移量），这样，现在它们将成为整数区间[2.x.255] [2.x.256] [2.x.257] 中的一个数字。然而，在重影道次的情况下（即不是本地拥有的），情况就完全不同了，因为与重影道次相关的全局指数（一般来说）不会是一个连续的整数集。
* 

* 
*  

* 
* [1.x.134]
* 
* 这就结束了DoFHandler和SparseMatrix对象的设置。接下来，我们要组装各种矩阵。我们在一个匿名命名空间中定义了一些辅助函数和数据结构。
* 

* 
*  

* 
* [1.x.135]
* 
* [2.x.258]类，将用于使用WorkStream组装离线数据矩阵。它充当一个容器：它只是一个结构，WorkStream在其中存储本地单元的贡献。请注意，它还包含一个类成员 [2.x.259] ，用于存储计算边界法线所需的局部贡献。
* 

* 
*  

* 
* [1.x.136]
* 
* 接下来我们介绍一些辅助函数，它们都是关于读写矩阵和向量条目的。它们的动机主要是为了提供稍微有效的代码和[1.x.137]，否则有些乏味的代码。
* 

* 
* 我们引入的第一个函数[2.x.260]，将用于读取SparsityPattern迭代器[2.x.261]指向的条目所存储的值。该函数绕过了SparseMatrix接口中的一个小缺陷。SparsityPattern关注的是以CRS格式存储的稀疏矩阵的所有索引操作。因此，迭代器已经知道存储在SparseMatrix对象中的低级向量中相应矩阵条目的全局索引。由于SparseMatrix中缺乏直接用SparsityPattern迭代器访问该元素的接口，不幸的是我们必须创建一个临时的SparseMatrix迭代器。我们只需在[2.x.262]函数中隐藏这一点。
* 

* 
*  

* 
* [1.x.138]
* 
* [2.x.263]助手是[2.x.264]的逆向操作：给定一个迭代器和一个值，它在矩阵中设置迭代器所指向的条目。
* 

* 
*  

 
* [1.x.139]
* 
* [2.x.265] : 我们注意到，[2.x.266] 。如果 [2.x.267] 则 [2.x.268] . 这基本上意味着我们需要每个空间维度的一个矩阵来存储[2.x.269]向量。对于矩阵[2.x.270]也有类似的观察。[2.x.271]的目的是检索这些条目并将其存储到[2.x.272]中，以方便我们使用。
* 

* 
*  

* 
* [1.x.140]
* 
* [2.x.273]（第一个接口）：这第一个函数签名，有三个输入参数，将被用来检索矩阵的各个组成部分[2.x.274]。[2.x.275]和[2.x.276]的功能非常相同，但它们的背景不同：函数[2.x.277]不依赖迭代器（实际上知道指向的值），而是依赖条目的索引[2.x.278]，以便检索其实际值。我们应该期望[2.x.279]比[2.x.280]稍微贵一些。[2.x.281]的使用将限于计算代数粘度[2.x.282]的任务，即当[2.x.283]和[2.x.284]都位于边界时的特殊情况。    
*  

* 
* [2.x.285] 读者应该知道，访问一个矩阵的任意[2.x.286]条目（比如说特里诺斯或PETSc矩阵）一般来说是非常昂贵的，无法接受。这里是我们可能想要关注复杂度的地方：我们希望这个操作有恒定的复杂度，这就是目前使用deal.II矩阵的实现的情况。
* 

* 
*  

* 
* [1.x.141]
* 
* [2.x.287]（第二个接口）：这第二个函数签名有两个输入参数，将用于收集节点[2.x.288]的状态，并作为[2.x.289]返回，以方便我们使用。
* 

* 
*  

* 
* [1.x.142]
* 
* [2.x.290] ：这个函数有三个输入参数，第一个参数是指 "全局对象"（比如一个本地拥有的或本地相关的矢量），第二个参数可以是一个[2.x.291] ，最后一个参数代表全局对象的索引。这个函数主要用于将更新的节点值（存储为[2.x.292]）写入全局对象中。
* 

* 
*  

* 
* [1.x.143]
* 
* 我们现在可以将存储在 [2.x.293] 中的所有矩阵集合起来：块状质量条目 [2.x.294] ，矢量值矩阵 [2.x.295] 和 [2.x.296] ，以及边界法线 [2.x.297] 。  
* 为了利用线程并行化，我们使用了[2.x.298]"多处理器的并行计算 "中详述的WorkStream方法来访问共享内存。按照惯例，这需要定义
* 

* 
* 
* - 抓取数据（即进行计算所需的输入信息）：在这种情况下，它是 [2.x.299] 。
* 

* 
* 
* - 工作者：在我们的例子中，这是[2.x.300]函数，它实际上是从抓取数据中计算出本地（即当前单元）贡献。
* 

* 
* 
* - 拷贝数据：一个包含所有本地装配贡献的结构，在这里是[2.x.301]。
* 

* 
* 
* - 一个拷贝数据例程：在这种情况下，它是[2.x.302]，负责将这些本地贡献实际复制到全局对象（矩阵和/或向量）中。  
* 下面的大部分行是用来定义工作器 [2.x.303] 和复制数据例程 [2.x.304] 的。关于WorkStream框架没有太多可说的，因为绝大多数的想法在[2.x.305]、[2.x.306]和[2.x.307]等文件中都有合理的记录。  
* 最后，假设[2.x.308]是边界上的一个支持点，（节点）法线被定义为。  
*  

* 
* [1.x.144]
*    
* 我们将首先计算这个表达式的分子，并将其存储在 [2.x.309] 中。我们将在一个后置循环中对这些向量进行归一化处理。
* 

* 
*  

* 
* [1.x.145]
 
* 下面是WorkStream所需要的初始化抓取数据的内容
* 

* 
*  

* 
* [1.x.146]
 
* 我们以通常的方式计算凑合质量矩阵条目[2.x.310]和向量[2.x.311]的局部贡献。
 

* 
* [1.x.147]
* 
* 现在我们必须计算边界法线。请注意，除非该元素在域的边界上有面，否则下面的循环不会有什么作用。
* 

* 
* [1.x.148]
* 
* 注意 "法线 "将只代表来自形状函数phi_j的支持中的一个面的贡献。所以我们不能在这里对这个局部贡献进行归一化，我们必须 "原封不动 "地接受它，存储它并将它传递给复制数据例程。正确的归一化需要在节点上增加一个循环。这在下面的复制函数中完成。
* 

* 
* [1.x.149]
* 
* 最后，我们按照WorkStream的要求提供了一个copy_local_to_global函数
* 

* 
* [1.x.150]
* 
* 此时，我们已经完成了[2.x.312]和[2.x.313]的计算，但到目前为止，矩阵[2.x.314]只包含矩阵[2.x.315]的副本。这不是我们真正想要的：我们必须对其条目进行标准化。此外，我们还没有填充矩阵[2.x.316]的条目，存储在地图[2.x.317]中的向量也没有被规范化。    
* 原则上，这只是离线数据，过度优化它们的计算并没有什么意义，因为它们的成本会在我们将要使用的许多时间步骤中得到摊销。然而，计算/存储矩阵[2.x.318]的条目是说明线程并行节点循环的完美选择。
* 

* 
* 
* - 我们要访问网格/稀疏图中的每个节点[2.x.319]。
* 

* 
* 
* - 对于每一个这样的节点，我们要访问每一个[2.x.320]，以便[2.x.321] 。    
* 从代数的角度来看，这相当于：访问矩阵中的每一行，并对这些行中的每一行在列上执行循环。节点循环是本教程步骤的一个核心主题（见介绍中的伪代码），它将一次又一次地重复。这就是为什么现在是介绍它们的恰当时机。    
* 我们有线程并行化能力[2.x.322]，在某种程度上比WorkStream框架更通用。特别是，[2.x.323]可以用于我们的节点循环。这个功能需要四个输入参数，我们详细解释（针对我们的线程并行节点循环的具体情况）。
* 

* 
* 
* - 迭代器 [2.x.324] 指向一个行索引。
* 

* 
* 
* - 迭代器 [2.x.325] 指向一个数字较高的行索引。
* 

* 
* 
* - 函数[2.x.326]和[2.x.327]在前面两个子弹中定义的结束和开始迭代器所跨越的范围内定义了一个子范围）对这个子范围内的每个迭代器应用一个操作。我们也可以把[2.x.328]称为 "工作者"。
* 

* 
* 
* - Grainsize：每个线程处理的最小迭代器（在这里代表行）的数量。我们决定最小为4096行。    
* 这里的一个小注意事项是，提供给[2.x.329]和[2.x.330]的迭代器必须是随机访问迭代器：在内部，[2.x.332]将把[2.x.333]和[2.x.334]迭代器定义的范围分成子范围（我们希望能够以恒定的复杂性读取这些子范围的任何条目）。为了提供这样的迭代器，我们求助于[2.x.335]。     
* 下面这段代码的大部分是用来定义 "工作者"[2.x.336]：即在子范围的每一行应用的操作。给定一个固定的[2.x.337]，我们要访问这一行的每一列/每一个条目。为了执行这样的列-循环，我们使用标准库中的[1.x.151]，其中。
* 

* 
* 
* - [2.x.338]给我们一个迭代器，从该行的第一列开始。
* 

* 
* 
* - [2.x.339] 是一个迭代器，指向该行的最后一列。
* 

* 
* 
* - [2.x.340]所要求的最后一个参数是在该行的每个非零条目（本例中为lambda表达式）上应用的操作。    
* 我们注意到，[2.x.341]将对不相交的行集（子行）进行操作，我们的目标是写进这些行。由于我们要进行的操作的简单性质（法线的计算和存储，以及条目[2.x.342]的规范化），线程在试图写同一个条目时不会发生冲突（我们不需要一个调度器）。
* 

* 
* [1.x.152]
 
* 第一个列循环：我们计算并存储矩阵norm_matrix的条目，并将归一化的条目写入矩阵nij_matrix中。
* 

* 
* [1.x.153]
* 
* 最后，我们对存储在 [2.x.343] 的向量进行归一化。这个操作没有被线程并行化，因为它既不能说明任何重要的概念，也不能带来任何明显的速度提升。
* 

* 
* [1.x.154]
 
* 在这一点上，我们已经完成了与离线数据有关的任何工作。
* 

* 
* [1.x.155] [1.x.156]
* 

* 
* 在本节中，我们描述了[2.x.344]类成员的实现。这里的大部分代码是专门针对具有理想气体定律的可压缩欧拉方程的。如果我们想把[2.x.345]重新用于不同的守恒定律（例如：浅水方程），那么这个类的大部分实现就必须改变。但是其他大部分的类（尤其是那些定义循环结构的类）将保持不变。  
* 我们首先实现一些小的成员函数来计算[2.x.346]、[2.x.347]和系统的通量[2.x.348]。这些函数中的每一个的功能都可以从它们的名字中不言自明。
* 

* 
*  

* 
* [1.x.157]
 
* 现在我们讨论 [2.x.349] 的计算。黎曼问题的最大波速的尖锐上界的分析和推导是一个非常技术性的工作，我们不能在本教程中包括对它的高级讨论。在这部分文档中，我们将仅限于简述我们实现函数的主要功能，并指出具体的学术参考文献，以帮助（感兴趣的）读者追踪这些想法的来源（和适当的数学理由）。  
* 一般来说，获得最大波速的尖锐保证上界需要解决一个相当昂贵的标量非线性问题。这通常是用一个迭代求解器来完成的。为了简化本例中的表述，我们决定不包括这样的迭代方案。相反，我们将只是使用一个初始猜测作为最大波速的上限猜测。更确切地说，[2.x.350]的方程（2.11）（3.7）、（3.8）和（4.3）足以定义一个有保障的最大波速的上界。这个估计值通过调用函数 [2.x.351] 返回。在其核心部分，这样一个上界的构造使用了所谓的中间压力的二重化近似 [2.x.352] ，例如，见公式（4.46），在 [2.x.353] 第128页。  
* 由[2.x.354]返回的估计值保证是一个上界，它在一般情况下是相当尖锐的，总体上对我们的目的是足够的。然而，对于一些特定的情况（特别是当其中一个状态接近真空条件时），这样的估计将是过于悲观的。这就是为什么我们使用第二个估计来避免这种退化，它将被调用到函数 [2.x.355] 。这里最重要的函数是 [2.x.356] ，它取的是 [2.x.357] 和 [2.x.358] 所返回的估计值之间的最小值 。  
* 我们再次开始定义几个辅助函数。  
* 第一个函数接收一个状态[2.x.359]和一个单位向量[2.x.360]，并计算单位向量方向上的[1.x.158]一维状态。
* 

* 
* [1.x.159]
* 
* 为此，我们必须把动量改为[2.x.361]，并且必须从总能量中减去垂直部分的动能。
* 

* 
* [1.x.160]
* 
* 我们以[1.x.161]变量而不是守恒量返回一维状态。返回的数组包括密度 [2.x.362] 、速度 [2.x.363] 、压力 [2.x.364] 和局部音速 [2.x.365] 。
* 

* 
*  

* 
* [1.x.162]
 
* 在这一点上，我们还定义了两个小函数，用来返回一个双数的正负部分。
* 

* 
*  

* 
* [1.x.163]
 
* 接下来，我们需要两个局部文数，它们是以原始状态[2.x.366]和给定压力[2.x.367][2.x.368]公式（3.7）定义的。

* 
* [1.x.164]
* 这里，[2.x.369]表示给定参数的正部分。
* 

* 
*  

* 
* [1.x.165]
* 
* 始终如一 [2.x.370] 公式(3.8)。

 
* [1.x.166]
* 
 

* 
  

 
* [1.x.167]
 
* 剩下的就是计算从左右原始状态计算出的[2.x.371]和[2.x.372]的最大值（[2.x.373] 公式（2.11）），其中[2.x.374]由[2.x.375] 公式（4.3）给出。
* 

* 
*  

* 
* [1.x.168]
* 
* 我们计算出最大波速的第二个上界，一般来说，它不像两重化估计那样尖锐。但在接近真空的条件下，当二赖子近似值可能达到极端值时，它将拯救一切。

* 
* [1.x.169]
* 

* 
* [2.x.376] 常数5.0乘以声速的最大值是[1.x.170]一个临时的常数，[1.x.171]一个调整参数。它为任何 [2.x.377] 定义了一个上限。请不要玩弄它!
* 

* 
*  

* 
* [1.x.172]
 
* 下面是我们要调用的主函数，以便计算[2.x.378]。我们简单地计算两个最大的波速估计值并返回最小值。
* 

* 
*  

* 
* [1.x.173]
* 
* 我们通过定义静态数组[2.x.379]来结束本节，这些静态数组包含描述我们的状态向量的组件名称的字符串。我们对维度一、二和三进行了模板特化，这在后面的DataOut中被用来命名相应的组件。
* 

* 
*  

* 
* [1.x.174]
* 
* [1.x.175] [1.x.176]。
 

* 
* 在我们讨论正向欧拉方案的实现之前，最后一个准备步骤是简单地实现`InitialValues`类。  
* 在构造函数中，我们用默认值初始化所有参数，为`ParameterAcceptor`类声明所有参数，并将[2.x.380]槽连接到相应的信号。  
* [2.x.381]槽将在调用[2.x.382]后从ParameterAceptor中调用 在这方面，它的使用适合于参数必须被后处理（在某种意义上）或必须检查参数之间的某些一致性条件的情况。
* 

* 
*  

* 
* [1.x.177]
* 
* 到目前为止，[2.x.383]的构造函数已经为两个私有成员[2.x.384]定义了默认值，并将它们添加到参数列表中。但是我们还没有定义唯一一个我们真正关心的公共成员的实现，也就是[2.x.385]（我们将调用这个函数来实际评估网格节点的初始解）。在这个函数的顶部，我们必须确保提供的初始方向不是零矢量。  
*  

* 
* [2.x.386] 正如所评论的，我们可以避免使用方法 [2.x.387] 并定义一个类成员 [2.x.388] 以便定义 [2.x.389] 的实现。但为了说明问题，我们想在这里记录一种不同的方式，并使用ParameterAcceptor的回调信号。
* 

* 
*  

* 
* [1.x.178]
* 
* 接下来，我们用一个计算均匀流场的lambda函数实现[2.x.390]函数对象。为此，我们必须将给定的原始1d状态（密度[2.x.391]、速度[2.x.392]和压力[2.x.393]）转换为保守的n维状态（密度[2.x.394]、动量[2.x.395]和总能量[2.x.396]）。
* 

* 
*  

* 
* [1.x.179]
* 
* [1.x.180] [1.x.181]。
 

* 
* [2.x.397]类的构造函数不包含任何令人惊讶的代码。
 

* 
*  

* 
* [1.x.182]
* 
* 在类成员 [2.x.398] 中，我们初始化临时向量 [2.x.399] 。向量[2.x.400]将用于在其内容与旧向量交换之前临时存储解决方案的更新。
* 

* 
*  

* 
* [1.x.183]
 
* 现在是实现前向欧拉步骤的时候了。给出一个在时间[2.x.402]的旧状态[2.x.401]的（可写引用），我们就地更新状态[2.x.403]并返回所选择的时间步长。我们首先声明一些对各种不同变量和数据结构的只读引用。我们这样做主要是为了有更短的变量名称（例如，[2.x.404]而不是[2.x.405] ）。
* 

* 
*  

* 
* [1.x.184]
* 
* [1.x.185]: 计算[2.x.406]图的粘性矩阵。    
* 必须强调的是，粘度矩阵必须是对称的，即[2.x.407] 。在这方面，我们在此注意到，[2.x.408]（或等同于[2.x.409]）只要[2.x.410]或[2.x.411]是位于远离边界的支持点。在这种情况下，我们可以通过构造检查出[2.x.412]，这保证了属性[2.x.413] 。    
* 然而，如果两个支持点[2.x.414]或[2.x.415]刚好都位于边界上，那么，等式[2.x.416]和[2.x.417]就不一定成立。对于这个难题，数学上唯一安全的解决方案是计算[2.x.418]和[2.x.419]，并取其最大值。    
* 总的来说，[2.x.420]的计算是相当昂贵的。为了节省一些计算时间，我们利用了粘度矩阵必须是对称的这一事实（如上所述）：我们只计算[2.x.421]的上三角条目，并将相应的条目复制到下三角的对应项。    
* 我们再次使用[2.x.422]进行线程并行的for循环。我们在讨论矩阵的组装[2.x.423]和上面[2.x.424]的归一化时介绍的几乎所有并行遍历的想法在这里再次使用。    
* 我们再次定义了一个 "工作者 "函数[2.x.425]，计算列索引的子范围[i1, i2]的黏度[2.x.426]。
* 

* 
* [1.x.186]
* 
* 对于一个给定的列索引i，我们遍历从[2.x.427]到[2.x.428]的稀疏模式的列。
* 

* 
* [1.x.187]
* 
* 我们只计算[2.x.429]，如果[2.x.430]（上三角条目），随后将数值复制到[2.x.431]。
* 

* 
* [1.x.188]
* 
* 如果两个支持点刚好都在边界上，我们也要计算[2.x.432]，然后取[2.x.433] 。在这之后，我们可以最终设定上三角和下三角的条目。
* 

* 
* [1.x.189]
* 
* [1.x.190]: 计算对角线条目 [2.x.434] 和 [2.x.435] 。
* 

* 
* 到目前为止，我们已经计算了矩阵[2.x.436]的所有非对角线项。我们仍然需要填补其对角线项，定义为 [2.x.437] 。我们再次使用[2.x.438]来实现这一目的。在计算[2.x.439]s的同时，我们也确定了最大的可接受的时间步长，定义为[1.x.191] 注意[2.x.440]的操作本质上是全局的，它在所有节点上操作：首先我们必须在所有线程（特定节点的）上取最小值，然后我们必须在所有MPI进程上取最小值。在目前的实现中。
* 

* 
* 
* - 我们将[2.x.441]（每个节点）存储为[1.x.192]。2.x.442]的内部实现将在一个以上的线程试图同时读取和/或写入[2.x.443]时，负责保护任何可能的竞赛条件。
* 

* 
* 
* - 为了获取所有MPI进程的最小值，我们使用实用函数 [2.x.444] 。
* 

* 
*  

* 
* [1.x.193]
 
* on_subranges()将在每个线程上单独执行。因此，变量[2.x.445]被存储在线程本地。
* 

* 
*  

* 
* [1.x.194]
 
* 我们在对角线位置存储d_ij项的负和
* 

* 
* [1.x.195]
* 
* 并计算出最大的局部时间步长 [2.x.446] 。
* 

* 
* [1.x.196]
* 
* [2.x.447]包含为（线程本地）子范围计算的最大可能的时间步长。在这一点上，我们必须在所有线程上同步该值。这就是我们使用的[1.x.197] [1.x.198]更新机制。
* 

* 
* [1.x.199]
* 
* 在所有线程都完成后，我们可以简单地在所有MPI进程中同步该值。
* 

* 
*  

* 
* [1.x.200]
* 
* 这是一个验证计算出的[2.x.448]确实是一个有效的浮点数的好点。
* 

* 
* [1.x.201]
* 
* [1.x.202]: 执行更新。
* 

* 
* 在这一点上，我们已经计算了所有的粘性系数 [2.x.449] 并且我们知道最大的可接受的时间步长 [2.x.450] 。这意味着我们现在可以计算更新。    
* [1.x.203]     
* 这个更新公式与介绍中讨论的略有不同（在伪代码中）。然而，可以证明这两个公式是代数等价的（它们将产生相同的数值）。我们更倾向于这第二个公式，因为它具有自然的取消属性，可能有助于避免数字伪数的出现。
* 

* 
*  

* 
* [1.x.204]
* 
* [1.x.205]: 修复了边界状态。
* 

* 
* 作为正向欧拉方法的最后一步，我们必须对所有的边界状态进行修复。正如在介绍中所讨论的，我们
* 

* 
* 
* - 在完全不满足边界条件的情况下推进时间。
 

* 
* 
* - 在时间步长结束时，在后处理步骤中强烈执行边界条件。    
* 在这里，我们计算校正[1.x.206]，它消除了[2.x.451]的法线成分。
* 

* 
*  

* 
* [1.x.207]
* 
* 我们只对本地拥有的子集进行迭代。
* 

* 
* [1.x.208]
* 
* 在自由滑移的边界上，我们去除动量的法向分量。
* 

* 
* [1.x.209]
 
* 在Dirichlet边界上，我们强行执行初始条件。
* 

* 
* [1.x.210]
* 
* [1.x.211]: 我们现在在所有MPI等级上更新幽灵层，将临时向量与解决方案向量交换 [2.x.452] （将通过引用返回），并返回选择的时间步长 [2.x.453] 。
* 

* 
*  

* 
* [1.x.212]
* 
* [1.x.213] [1.x.214]。  
* 在不同的时间间隔内，我们将输出解决方案的当前状态[2.x.454]以及所谓的Schlieren图。[2.x.455]类的构造函数同样不包含任何惊喜。我们只是提供默认值并注册两个参数。
* 

* 
* 
* - schlieren_beta：是一个临时的正向放大系数，以增强可视化中的对比度。它的实际值是一个品味问题。
* 

* 
* 
* - schlieren_index: 是一个整数，表示我们将使用状态[2.x.456]的哪个分量来生成可视化。
* 

* 
*  

* 
* [1.x.215]
* 
* 同样，[2.x.457]函数初始化了两个临时向量（[2.x.458]）。
* 

* 
*  

* 
* [1.x.216]
* 
* 我们现在讨论类成员[2.x.459]的实现，它基本上是取状态向量[2.x.460]的一个分量并计算该分量的Schlieren指标（Schlieren指标的公式可以在类的声明[2.x.461]之前找到）。我们首先注意到这个公式需要 "结点梯度" [2.x.462] 。然而，对于[2.x.463]有限元函数来说，梯度的节点值并没有定义。更一般地说，梯度的点值对[2.x.464]函数没有定义。我们可以使用最简单的技术来恢复节点的梯度，即加权平均法。  
* [1.x.217]   
* 其中[2.x.465]是形状函数[2.x.466]的支持，[2.x.467]是权重。权重可以是任何正函数，如[2.x.468]（这将允许我们恢复通常的均值概念）。但是像往常一样，我们的目标是尽可能多地重复使用离线数据。在这个意义上，最自然的权重选择是[2.x.469] 。将这种权重的选择和扩展[2.x.470]插入[2.x.471]中，我们得到:   
* [1.x.218]   
* 使用这最后一个公式，我们可以恢复平均的节点梯度，而不需要借助于任何形式的正交。这个想法与基于边缘的方案（或代数方案）的整个精神相吻合，我们希望尽可能直接对矩阵和向量进行操作，以避免使用双线性形式、单元环、正交，或在输入参数（上一时间步的状态）和计算更新所需的实际矩阵和向量之间的任何其他中间结构/操作。  
* 第二件要注意的事情是，我们必须计算全局最小和最大 [2.x.472] 和 [2.x.473] 。按照在类成员[2.x.474]中用于计算时间步长的相同思路，我们将[2.x.475]和[2.x.476]定义为原子倍数，以便解决线程之间的任何冲突。像往常一样，我们使用[2.x.477]和[2.x.478]来寻找所有MPI进程中的全局最大/最小值。  
* 最后，不可能在所有节点上进行一次循环来计算Schlieren指标。整个操作需要在节点上进行两次循环。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 
* - 第一个循环计算[2.x.479]中所有[2.x.480]的网格，以及边界[2.x.481]和[2.x.482] 。
* 

* 
* 
* - 第二个循环最后用公式计算Schlieren指标   
* [1.x.219]   
* 这意味着我们将不得不为每一个阶段定义两个工作者[2.x.483]。
* 

* 
*  

* 
* [1.x.220]
* 
* 我们将当前MPI进程中的r_i_max和r_i_min定义为原子双数，以避免线程之间的竞赛条件。
* 

* 
* [1.x.221]
* 
* 第一个循环：计算每个节点的平均梯度以及梯度的全局最大值和最小值。
* 

* 
* [1.x.222]
* 
* 我们在自由滑移边界固定梯度r_i，类似于我们在正向欧拉步骤中固定边界状态的方式。这可以避免在自由滑移边界的Schlieren图中出现尖锐的、人为的梯度，这纯粹是一种外观上的选择。
* 

* 
*  

* 
* [1.x.223]
* 
* 我们提醒读者，我们对节点梯度本身不感兴趣。我们只想得到它们的规范，以便计算Schlieren指标（用块状质量矩阵加权 [2.x.484] ）。
* 

* 
* [1.x.224]
* 
* 我们将当前_r_i_max和current_r_i_min（在当前子范围内）与r_i_max和r_i_min（对于当前MPI进程）进行比较，必要时对其进行更新。
* 

* 
*  

* 
* [1.x.225]
 
* 并在所有MPI进程中同步[2.x.485]。
 

* 
*  

* 
* [1.x.226]
* 
* 第二个循环：我们现在有矢量[2.x.486]和标量[2.x.487]可供我们使用。这样我们就可以实际计算Schlieren指标了。
* 

* 
*  

* 
* [1.x.227]
 
* 最后，交换幽灵元素。
* 

* 
* [1.x.228]
* 
* [1.x.229] [1.x.230].   
* 在实现了所有的类之后，现在是时候创建一个[2.x.488]、[2.x.489]和[2.x.490]的实例，并在一个循环中运行正向欧拉步骤。  
* 在[2.x.491]的构造函数中，我们现在初始化所有类的实例，并声明一些控制输出的参数。最值得注意的是，我们声明了一个布尔参数[2.x.492]，它将控制程序是否试图从中断的计算中重新启动。
* 

* 
*  

* 
* [1.x.231]
* 
* 我们首先在匿名命名空间中实现一个辅助函数[2.x.493]，用来在终端输出带有一些漂亮格式的信息。
* 

* 
*  

* 
* [1.x.232]
* 
* 有了[2.x.494]，现在是时候实现[2.x.495]了，它包含我们程序的主循环。
* 

* 
*  

* 
* [1.x.233]
* 
* 我们开始读入参数并初始化所有对象。我们在这里注意到，对[2.x.496]的调用是从参数文件（其名称作为一个字符串参数给出）中读入所有参数。ParameterAcceptor处理一个全局的ParameterHandler，它被初始化为所有从ParameterAceptor派生的类实例的分节和参数声明。对初始化的调用进入了每个每个派生类的分节，并设置所有使用[2.x.497]添加的变量。
* 

* 
*  

* 
* [1.x.234]
* 
* 接下来我们创建三角形，集合所有的矩阵，设置划痕空间，并初始化DataOut<dim>对象。
* 

* 
*  

* 
* [1.x.235]
* 
* 我们将在变量 [2.x.498] 中存储当前的时间和状态。
 

* 
*  

 
* [1.x.236]
* 
* [1.x.237] [1.x.238]。    
* 默认情况下，布尔值[2.x.499]被设置为false，也就是说，下面的代码段不会被运行。然而，如果[2.x.500]我们表示我们确实有一个中断的计算，程序将通过从检查点文件中读入由[2.x.501], [2.x.502]组成的旧状态来重新启动。这些检查点文件将在下面讨论的[2.x.503]程序中创建。
* 

* 
*  

* 
* [1.x.239]
* 
* 我们使用一个[2.x.504]来存储和读取检查点状态的内容。
* 

* 
*  

* 
* [1.x.240]
* 
* [2.x.505] 遍历状态向量的所有组件 [2.x.506] 。我们依次读入组件的每一个条目，并在之后更新鬼魂层。
* 

* 
* [1.x.241]
 
* 随着初始状态的建立，或中断状态的恢复，是时候进入主循环了。
* 

* 
*  

* 
* [1.x.242]
 
* 我们首先打印一个信息性的状态信息
* 

* 
*  

* 
* [1.x.243]
 
* 然后执行一个单一的前向欧拉步骤。注意状态向量[2.x.507]被就地更新，[2.x.508]返回所选择的步骤大小。
* 

* 
*  

* 
* [1.x.244]
* 
* 后期处理、生成输出和写出当前状态是一项CPU和IO密集型的任务，我们不能在每一个时间步骤中都做。
* 
* 特别是在显式时间步进中。因此，我们只在超过[2.x.510]设定的阈值时，通过调用[2.x.509]函数安排输出。
* 

* 
*  

* 
* [1.x.245]
* 
* 我们等待任何剩余的后台输出线程完成，然后打印一个摘要并退出。
* 

* 
* [1.x.246]
* 
* [2.x.511]将初始时间 "t "作为输入参数，并在[2.x.513]对象的帮助下填充一个状态向量[2.x.512]。
* 

* 
*  

* 
* [1.x.247]
* 
* [2.x.514]的函数签名对于[2.x.515]来说不太合适。我们通过以下方式来解决这个问题：首先，创建一个lambda函数，对于一个给定的位置[2.x.516]只返回[2.x.517]的第1个分量的值。在ScalarFunctionFromFunctionObject包装器的帮助下，这个lambda又被转换为一个[2.x.518]。
* 

* 
*  

* 
* [1.x.248]
* 
* [1.x.249] [1.x.250]   
* 写出最终的vtk文件是一项相当密集的IO任务，会让主循环停滞一段时间。为了避免这种情况，我们使用了一个[1.x.251]的策略，即创建一个后台线程，在主循环被允许继续的情况下执行IO。为了使其发挥作用，我们必须注意两件事。
* 

* 
* 
* - 在运行 [2.x.519] 线程之前，我们必须创建一个状态向量 [2.x.520] 的副本。我们把它存储在向量 [2.x.521] 中。
* 

* 
* 
* - 我们必须避免在后台线程中进行任何MPI通信，否则程序可能会死锁。这意味着我们必须在工作线程之外运行后处理程序。
* 

* 
  

* 
* [1.x.252]
* 
* 如果设置了异步回写选项，我们会启动一个后台线程，执行所有的慢速IO到磁盘。在这种情况下，我们必须确保后台线程确实完成了运行。如果没有，我们必须等待它完成。我们用[1.x.253]启动上述背景线程，返回[1.x.254]对象。这个[2.x.522]对象包含了函数的返回值，在我们的例子中就是[2.x.523] 。
* 

* 
*  

* 
* [1.x.255]
 
* 在这一点上，我们制作了一份状态向量的副本，运行schlieren后处理器，并运行[2.x.524] 实际的输出代码是标准的。我们创建一个DataOut实例，附加所有我们想要输出的数据向量并调用[2.x.525]，但是有一个转折。为了在后台线程上执行异步IO，我们将DataOut<dim>对象创建为一个共享指针，传递给工作线程，以确保一旦我们退出这个函数，工作线程完成后，DataOut<dim>对象再次被销毁。
* 

* 
*  

* 
* [1.x.256]
* 
* 接下来我们为后台线程创建一个lambda函数。我们 [1.x.257] [2.x.526] 指针以及输出函数的大部分参数的值，这样我们就可以在lambda函数中访问它们。
* 

* 
* [1.x.258]
* 
* 我们通过做与[1.x.259]讨论的精确的逆向操作来检查当前状态。
* 

* 
*  

* 
* [1.x.260]
* 
* 如果设置了异步回写选项，我们就在[1.x.261]函数的帮助下启动一个新的后台线程。该函数返回一个[1.x.262]对象，我们可以用它来查询后台线程的状态。在这一点上，我们可以从[2.x.527]函数中返回，继续在主循环中进行时间步进
* 
* - 该线程将在后台运行。
* 

* 
* [1.x.263]
* 
* 最后是主函数。
* 

* 
*  

* 
* [1.x.264]
* [1.x.265][1.x.266][1.x.267] 。
* 

* 在发布模式下，以默认参数运行程序，在4核机器上（带超线程）需要大约1分钟。
* [1.x.268]
* 
* 一个明显的事实是，程序花了三分之二的执行时间计算图形粘度d_ij，大约三分之一的执行时间用于执行更新，其中计算flux [2.x.528] 是昂贵的操作。预设的默认分辨率约为37k个网格点，相当于二维的148k个空间自由度。解决方案的动画分层图看起来如下。
* [2.x.529] 
* 很明显，一阶方法的37k个网格点还没有达到解决任何流动特征所需的分辨率。作为比较，下面是用二阶方法和大约9.5个网格点进行的 "参考 "计算（[1.x.269]）。
* [2.x.530] 
* 因此，我们再给一阶方法一个机会，在一个小型计算服务器上用大约240万个网格点运行它。
* [1.x.270]
* 
* 而结果如下。
* [2.x.531] 
* 这大大改善了，当然，代价是在16个核心上运行了大约2个小时的代码。
* 

* 
* [1.x.271][1.x.272][1.x.273]。
* 

* 如上所述，这里展示的程序实际上只是一阶精确。上面的图片说明了这引入了多少扩散，以及这个解决方案离真正解决我们所关心的特征还有多远。
* 这一点是可以解决的，但这将超出本教程*的内容。尽管如此，它还是值得展示通过添加二阶方案可以实现的效果。例如，这里有一段用[1.x.274]计算的视频，它显示了（用不同的颜色方案）对应于上述情况的2d模拟。
* [1.x.275]
* 
* 这个模拟是用3800万个自由度（连续的[2.x.532]有限元）完成的，每一个解向量的分量都是如此。对于这类模拟来说，解决方案的精致细节是显著的，包括在障碍物后面的亚声速区域。
* 我们还可以相对容易地将其进一步扩展到三维情况。
* [1.x.276]
* 
* 然而，解决这个问题变得很昂贵。仿真是以每个组件18.17亿个自由度（连续[2.x.533]有限元）完成的（总共90.9亿个空间自由度），在30,720个MPI等级上运行。该代码达到了每秒969万个网格点的平均吞吐量（每个CPU每秒0.04万个网格点）。前面和后面的墙显示了一个 "Schlieren图"：密度的梯度的大小在一个指数级上，从白色（低）到黑色（高）。所有其他切面和障碍物的表面都显示了白色（低）的涡度大小。
* 
* - 黄色（中）。
* 
* - 黄色（中）* - 黑色（高）的比例。(为了使视觉效果更好，各个剖面的比例已经调整过了)。
 

* [1.x.277][1.x.278] [2.x.534] 。
* [0.x.4]

