include/deal.II-translator/A-tutorial/step-35_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.2] 
* [1.x.29]
* [1.x.30][1.x.31][1.x.32] 。
* 

* [1.x.33][1.x.34][1.x.35] 。
* 本程序的目的是展示如何有效地解决不可压缩的时间依赖性Navier-Stokes方程。这些方程描述了粘性不可压缩流体的流动，其内容如下
* [1.x.36]
* 其中[2.x.3]表示流速，[2.x.4]表示压力。这个方程组由初始条件[1.x.37]与[2.x.5]充分光滑和螺线管，以及合适的边界条件补充而成。例如，一个可接受的边界条件是[1.x.38]，也可以规定其他边界条件。在我们这里解决的测试案例中，边界被划分为两个不相交的子集[2.x.6]，我们有[1.x.39]和[1.x.40]，其中[2.x.7]是外部单位法线。[2.x.8]上的边界条件经常被用来模拟外流条件。
* 在以前的教程中（例如见[2.x.9]和[2.x.10]），我们已经看到了如何使用Schur补数方法来解决时间无关的斯托克斯方程。对于时间依赖的情况，在时间离散化之后，我们将得到一个系统，如
* [1.x.41]
* 其中[2.x.11]是时间步长。尽管这个系统的结构与斯托克斯系统相似，因此可以用Schur补数的方法来解决，但事实证明，Schur补数的条件数与[2.x.12]成正比。这使得该系统非常难以解决，并意味着对于纳维-斯托克斯方程来说，这不是一个有用的解决途径。
* [1.x.42][1.x.43][1.x.44] 。
* 

* 相反，我们需要想出一个不同的方法来解决与时间有关的纳维-斯托克斯方程。解决这些问题的困难来自于速度和压力通过约束[1.x.45]耦合在一起的事实，对于这个约束，压力是拉格朗日乘数。
* 让我们简短地描述一下投影方法在半离散情况下的样子。我们的目标是获得一个速度[2.x.13]和压力[2.x.14]的序列。假设从初始条件和一阶方法的应用中我们已经找到了[2.x.16]和[2.x.17]。那么投影法包括以下步骤。[2.x.18] [2.x.19] [1.x.46]。外推法。定义一下。 [1.x.47] [2.x.20] [1.x.48]。扩散步骤。我们发现[2.x.21]可以解决单一线性方程[1.x.49]。
* [2.x.22] [1.x.50]。投影。找到解决[1.x.51] [2.x.24] [1.x.52]的[2.x.23]。压力校正。这里我们有两个选项。    [2.x.25] [2.x.26] [1.x.53]。压力的更新方式是。     [1.x.54] [2.x.27] [1.x.55]。在这种情况下[1.x.56] [2.x.28] [2.x.29] 。
* 在不详细说明的情况下，让我们对我们刚刚描述的投影方法做一些说明。[2.x.30] [2.x.31] 平流项[2.x.32]被其[1.x.57] [1.x.58]取代，这与连续方程一致（因为[2.x.33]，尽管这对离散解来说不是点状的），并且需要它来保证时间步进方案的无条件稳定性。此外，为了使该术语线性化，我们使用[2.x.35]的二阶外推法[2.x.34] 。  [2.x.36] 投影步骤是亥姆霍兹分解[1.x.59]的实现，其中[1.x.60]和[1.x.61] 事实上，如果我们在[2.x.37]上使用这一分解，我们得到[1.x.62]与[2.x.38] 。取这个方程的发散，我们得出了投影方程。  [2.x.39] 上述两种变体中更准确的是旋转变体。然而，下面的程序同时实现了两种变体。此外，根据作者的经验，如果粘度[2.x.40]是可变的，应该使用标准形式。[2.x.41] 
* 

* [2.x.42] van Kan在[2.x.43] [2.x.44] J. van Kan, "A second-order accurate pressure-correction scheme for viscous incompressible flow", SIAM Journal on Scientific and Statistical Computing, Vol. 7, no. 3, pp. 870-891, 1986 [2.x.45] 并由Guermond在[2.x.46] [2.x.47] J.-L. Guermond, "Un résultat de convergence d'ordre deux en temps pour l'approximation des équations de Navier-Stokes par une technique de projection incrémentale" , ESAIM: Mathematical Modelling and Numerical Analysis, vol. 33, no. 1, pp. 169-189, 1999 [2.x.48 ]的情况[2.x.49]。事实证明，这种技术受到运动压力的非物理边界条件的影响，导致收敛率降低。为了防止这种情况，Timmermans等人在[2.x.50] [2.x.51] L. Timmermans, P. Minev, and F. Van De Vosse, "An approximate projection scheme for incompressible flow using spectral elements", International Journal for Numerical Methods in Fluids, vol. 22, no. 7, pp.673-688, 1996 [2.x.52 2.x.53] [2.x.54] J.-L. Guermond 和 J. Shen, "On the error estimates for the rotational pressure-correction projection methods", Mathematics of Computation, vol. 73, no. 248, pp.1719-1737, 2004 [2.x.55] 对Stokes问题进行了全面分析。[2.x.56] 
* [1.x.63][1.x.64][1.x.65] 。
* 为了获得该方法的完全离散设置，我们一如既往地需要一个变分公式。鉴于边界条件的性质，这里有一个微妙的问题。当我们将方程乘以一个合适的检验函数时，出现的一个项是[1.x.66]如果我们，比如说，在整个边界上有迪里希特边界条件，那么经过部分积分，我们将得到[1.x.67]这种表述的一个优点是，它完全解耦了速度的各个组成部分。此外，它们都共享同一个系统矩阵。这一点可以在程序中加以利用。
* 然而，考虑到非标准的边界条件，为了能够将其考虑在内，我们需要使用下面的%同位素[1.x.68]，这样当我们进行分项积分并考虑到边界条件时，就可以得到[1.x.69]，这是我们必须使用的形式。此外，为了强制执行压力的边界条件，我们需要重写[1.x.70]，在速度的边界条件下，[2.x.57]中的边界积分等于零，在压力的边界条件下，[2.x.58]的边界积分等于零。
* 在边界[2.x.59]平行于坐标轴的简化情况下，即我们下面进行的试验情况下，实际上可以证明[1.x.71]这个问题在文献中不常涉及。更多信息，读者可以参考，例如，[2.x.60] [2.x.61] J.-L. GUERMOND, L. QUARTAPELLE, On the approximation of the unsteady Navier-Stokes equations by finite element projection methods, Numer. Math., 80 (1998) 207-238 [2.x.62] J.-L. GUERMOND, P. MINEV, J. SHEN, Error analysis of pressure-correction schemes for the Navier-Stokes equations with open boundary conditions, SIAM J. Numer. Anal., 43 1 (2005) 239-258. [2.x.63] 
 

* 
* [1.x.72][1.x.73][1.x.74] 。
* 

* 我们对投影方法的实现遵循[1.x.75]上面的描述。然而，我们必须注意到，与其他大多数有多个求解组件的问题不同，我们没有使用向量值的有限元。相反，我们对速度和压力的分量分别使用单独的有限元，并对它们使用不同的[2.x.64]'s。这样做的主要原因是，正如我们从方案的描述中看到的，速度和压力的[2.x.65]分量是解耦的。因此，所有速度分量的方程看起来都是一样的，具有相同的系统矩阵，并且可以以%的方式并行求解。很明显，这种方法也有其缺点。例如，在集合矩阵和右手边时，我们需要保持几个[2.x.66]s和迭代器的同步；获得矢量值函数的固有量（如发散）变得有点尴尬，还有其他的。
* [1.x.76][1.x.77][1.x.78] 。
* 

* 我们在这个程序中使用的测试案例包括围绕一个方形障碍物的流动。其几何形状如下。
* [2.x.67] 
* 与[2.x.68]一起，使几何形状略微不对称。
* 我们在顶壁、底壁和障碍物上都施加了无滑动的边界条件。在左边，我们有流入的边界条件[1.x.79]与[2.x.69]，即流入的边界条件对应于这个配置的Poiseuille流。最后，在右边的垂直壁上，我们施加条件，速度的垂直分量和压力都应该是零。
* 

* [1.x.80] [1.x.81] 。
* [1.x.82] [1.x.83] 。
 

* 
* 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。每一个文件都已经在以前的教程程序中讨论过了，所以我们在这里就不做详细介绍了。
* 

* 
* [1.x.84]
 
* 最后这和以前的所有程序一样。
* 

* 
* [1.x.85]
* 
* [1.x.86] [1.x.87].   
* 由于我们的方法有几个可以微调的参数，我们把它们放到一个外部文件中，这样就可以在运行时确定它们。  
* 这尤其包括辅助变量[2.x.71]的方程表述，为此我们声明一个[2.x.72]。接下来，我们声明一个类，该类将读取和存储我们程序运行所需的所有参数。
* 

* 
* [1.x.88]
* 
* 在这个类的构造函数中，我们声明所有的参数。这方面的细节已经在其他地方讨论过了，例如在 [2.x.73] 。
* 

* 
* [1.x.89]
* 
* [1.x.90] [1.x.91] 。
 

* 
* 在下一个命名空间中，我们声明初始和边界条件。
 

* 
* [1.x.92]
* 
* 由于我们选择了一个完全解耦的公式，我们将不利用deal.II处理矢量值问题的能力。然而，我们确实希望使用一个在某种程度上独立于维度的方程数据的接口。为了做到这一点，我们的函数应该能够知道我们目前在哪个空间分量上工作，而且我们应该能够有一个通用的接口来做到这一点。下面的类是在这个方向上的一个尝试。
* 

* 
* [1.x.93]
* 
* 有了这个类的定义，我们声明描述速度和压力的边界条件的类。
* 

* 
* [1.x.94]
* 
* [1.x.95] [1.x.96]。
 

* 
* 现在是该程序的主类。它实现了纳维-斯托克斯方程的各种版本的投影方法。所有的方法和成员变量的名称应该是不言自明的，考虑到介绍中给出的实现细节。
* 

* 
* [1.x.97]
* 
* 接下来的几个结构和函数是用来做各种并行的事情。它们遵循[2.x.74]中提出的方案，使用WorkStream类。正如那里所解释的，这需要我们为每个汇编器声明两个结构，一个是每个任务的数据，一个是scratch数据结构。然后，这些结构被移交给组装本地贡献的函数，并将这些本地贡献复制到全局对象上。    
* 这个程序的一个特点是，我们不只是有一个代表速度和压力的DoFHandler对象，而是为这两种变量使用单独的DoFHandler对象。当我们想把涉及这两个变量的条款，如速度的发散和压力的梯度，乘以各自的测试函数时，我们要为这种优化付费。在这样做的时候，我们不能再仅仅使用一个FEValues对象，而是需要两个，而且它们需要用单元格迭代器来初始化，这些单元格迭代器指向三角形中的同一个单元格，但不同的DoFHandlers。    
* 为了在实践中做到这一点，我们声明一个 "同步 "迭代器
* 
* 一个内部由多个（在我们的例子中是两个）迭代器组成的对象，每当同步迭代器向前移动一步，内部存储的每个迭代器也向前移动一步，从而始终保持同步。碰巧的是，有一个deal.II类可以促进这种事情。这里重要的是要知道，建立在同一个三角形上的两个DoFHandler对象将以相同的顺序走过三角形的单元。
* 

* 
* [1.x.98]
 
* 同样的一般布局也适用于以下实现平流项组装的类和函数。
* 

* 
* [1.x.99]
* 
* 最后几个函数实现了扩散求解以及输出的后处理，包括计算速度的曲线。
* 

* 
* [1.x.100]
 
* [1.x.101] [1.x.102]
 

* 
* 在构造函数中，我们只是从作为参数传递的[2.x.75]对象中读取所有数据，验证我们读取的数据是否合理，最后，创建三角形并加载初始数据。
* 

* 
* [1.x.103]
* 
* [1.x.104] [1.x.105].
 

* 
* 创建三角形，并对其进行所需次数的细化的方法。在创建三角形后，它创建了与网格相关的数据，即分配自由度并重新编号，并初始化我们将使用的矩阵和向量。
* 

* 
* [1.x.106]
* 
* [1.x.107] [1.x.108]
 

* 
* 该方法创建常数矩阵并加载初始数据
* 

* 
* [1.x.109]
 
* [1.x.110] [1.x.111].
 

* 
* 在这组方法中，我们初始化了稀疏模式、约束条件（如果有的话）并组装了不依赖于时间步长的矩阵 [2.x.76] 。注意，对于拉普拉斯矩阵和质量矩阵，我们可以使用库中的函数来完成。因为这个函数的昂贵操作
* 
* - 创建这两个矩阵
* 
* 是完全独立的，我们原则上可以把它们标记为可以使用[2.x.77]函数并行工作的任务。我们在这里不会这样做，因为这些函数在内部已经被并行化了，特别是由于当前的函数在每个程序运行中只被调用一次，所以在每个时间步长中不会产生费用。然而，必要的修改将是非常直接的。
* 

* 
* [1.x.112]
* 
* 作用于压力空间的矩阵的初始化与作用于速度空间的矩阵相似。
* 

* 
* [1.x.113]
* 
* 对于梯度算子，我们从初始化稀疏模式和压缩它开始。这里需要注意的是，梯度算子从压力空间作用到速度空间，所以我们必须处理两个不同的有限元空间。为了保持循环的同步，我们使用之前定义的别名，即[2.x.78] 。
* 

* 
* [1.x.114]
* 
* [1.x.115] [1.x.116] 。
 

* 
* 这是一个时间行进函数，从[2.x.79]开始，使用时间步长为[2.x.80]的投影法进行时间推进，直到[2.x.81]。  
* 它的第二个参数[2.x.82]表示该函数是否应该输出它在任何特定时刻正在做什么的信息：例如，它将说明我们是否正在进行扩散、投影子步骤；更新前置条件器等。我们没有使用像[2.x.83]那样的代码来实现这种输出，而是使用ConditionalOStream类来为我们做这个。该类接受一个输出流和一个条件，该条件表明你传递给它的东西是否应该被传递到给定的输出流，或者应该被忽略。这样，上面的代码就变成了[2.x.84]，并且在任何情况下都会做正确的事情。
* 

* 
* [1.x.119]
* 
* [1.x.120] [1.x.121]。
 

* 
* 扩散步骤的实现。注意，昂贵的操作是函数末尾的扩散解，我们必须对每个速度分量做一次。为了加快进度，我们允许以%并行方式进行，使用[2.x.85]函数，该函数确保[2.x.86]的求解都得到处理，并被安排到可用的处理器上：如果你的机器有一个以上的处理器核心，并且这个程序的其他部分目前没有使用资源，那么扩散求解将以%并行方式运行。另一方面，如果你的系统只有一个处理器核心，那么以%并行方式运行将是低效的（因为它导致了，例如，缓存拥堵），事情将被顺序执行。
* 

* 
* [1.x.122]
* 
* [1.x.123] [1.x.124]
 

* 
* 下面几个函数是关于集合平流项的，这是扩散步骤的系统矩阵的一部分，在每个时间步骤中都会发生变化。如上所述，我们将使用WorkStream类和其他设施，在所有单元上以%并行方式运行装配循环，如[2.x.87]的文档模块中所述。
* 

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127] * [1.x.126] * [1.x.127]
 

* 
* 这实现了投影的步骤。
* 

* 
* [1.x.128]
 
* [1.x.129] [1.x.130]。
 

* 
* 这是投影法的压力更新步骤。它实现了该方法的标准表述，即[1.x.131]或旋转形式，即[1.x.132] 。
* 

* 
* [1.x.133]
* 
* [1.x.134] [1.x.135] * * [1.x.134] [1.x.135]。
 

* 
* 这个方法绘制了当前的解决方案。主要的困难是我们想创建一个单一的输出文件，其中包含所有的速度分量、压力以及流动的涡度的数据。另一方面，速度和压力存在于不同的DoFHandler对象中，因此不能用一个DataOut对象写入同一个文件。因此，我们必须更努力地把各种数据放到一个DoFHandler对象中，然后用它来驱动图形输出。  
* 我们不会在这里详细说明这个过程，而是参考[2.x.88]，那里使用了一个类似的程序（并且有记录），为所有变量创建一个联合的DoFHandler对象。  
* 我们还注意到，我们在这里将涡度作为一个单独的函数中的标量来计算，使用[2.x.89]中的量[2.x.90]投影到用于速度分量的有限元空间。但原则上，我们也可以把速度作为一个点状量来计算，并通过[2.x.91]和[2.x.92]中讨论的数据后处理机制来实现。
* 

* 
* [1.x.136]
* 
* 下面是一个辅助函数，通过将[2.x.93]项投影到用于速度分量的有限元空间来计算涡度。这个函数只有在我们生成图形输出时才会被调用，所以不是很频繁，因此我们没有像对待其他装配函数那样，麻烦地使用WorkStream概念来并行化它。不过，如果需要的话，这应该不会太复杂。此外，我们在这里的实现只适用于2D，所以如果情况不是这样，我们也会保释。
* 

* 
* [1.x.137]
 
* [1.x.138] [1.x.139]
 

* 
* 主函数看起来与其他所有的教程程序非常相似，所以这里没有什么可评论的。
 

* 
* [1.x.140]
* [1.x.141][1.x.142][1.x.143] 。
* 

* [1.x.144][1.x.145][1.x.146] 。
 

* 我们用下面的[2.x.94]运行代码，它可以在与源代码相同的目录中找到。
* [1.x.147]
* 
* 如果我们把它设置为[2.x.96]，我们就可以得到程序正在做什么以及每个迭代过程需要多少步才能收敛等信息。
* 让我们绘制[2.x.97]（即时间步骤200、1000、2400、4000和5000）的结果，在左边一栏中我们显示涡度，在右边显示速度场。
* [2.x.98] 
* 这些图像很好地显示了障碍物后面的涡流链的发展和延伸，涡度的符号表明这是一个左转或右转的涡流。
* 

* [1.x.148][1.x.149][1.x.150] 。
* 

* 我们可以将参数文件中的雷诺数[2.x.99]改为[2.x.100]的值。这样做，并在一定程度上减少时间步长，在[2.x.101]时产生以下图像。
* [2.x.102] 
* 对于这个较大的雷诺数，我们观察到不符合物理规律的振荡，特别是涡度的振荡。这些现象是典型的离散化方案，它们在未充分解决的情况下缺乏稳健性，其中未充分解决意味着用网格尺寸而不是几何体的物理尺寸计算的雷诺数很大。我们看一下放大的障碍物后面的区域，以及那里的网格尺寸。
* 

* [2.x.103] 
* 我们可以通过在参数文件中多设置一个网格细化来重新运行模拟，从而很容易测试我们的假设。
* [2.x.104] 
* 事实上，现在的涡度场看起来更加平滑。虽然我们可以预期进一步细化网格也会抑制剩余的振荡，但我们应该采取措施在粗解的限制下获得一个强大的方案，如下所述。
* 

* [1.x.151][1.x.152][1.x.153] 。
* 

* 这个方案可以向以下方向扩展。[2.x.105] [2.x.106] 自适应网格细化。正如我们所看到的，我们在一个单一的固定网格上计算了所有的东西。 使用自适应网格细化可以提高精度，同时不明显增加计算时间。
* [2.x.107] 自适应时间步进。虽然目前显然没有关于可变时间步长的投影方法的理论，但实践表明，它们的表现非常好。
* [2.x.108] 高雷诺%数。正如我们从结果中看到的，增加雷诺数会显著改变离散化方案的行为。使用众所周知的稳定技术，我们可以计算这个问题或许多其他问题中的流动，当雷诺数非常大，计算成本要求空间分辨率，而流动只能得到有限的解决，特别是对于三维湍流。
* [2.x.109] 可变密度的不可压缩流。对于密度可变的不可压缩流的情况，有类似投影的方法。如果不同密度的流体混合，例如淡水和盐水，或者酒精和水，这种流动就会发挥作用。
* [2.x.110] 可压缩纳维-斯托克斯方程。这些方程适用于以下情况：速度高到足以使流体变得可压缩，但还没有快到我们进入一个粘度变得可以忽略不计的制度，纳维-斯托克斯方程需要被气体动力学的双曲欧拉方程所取代。如果速度超过音速的三分之一，可压缩性就开始成为一个因素，所以它对几乎所有的地面交通工具来说都不是一个因素。另一方面，商业喷气式飞机的飞行速度约为音速的85%，机翼上的流动变得明显超音速，在这种情况下，可压缩的纳维尔-斯托克斯方程也不再适用。然而，在这两者之间的范围内有重要的应用，如小型飞机或许多欧洲和东亚国家的快速列车。[2.x.111] 
* 

* [1.x.154][1.x.155] [2.x.112] 。
* [0.x.1]

