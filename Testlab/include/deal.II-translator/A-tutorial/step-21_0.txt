include/deal.II-translator/A-tutorial/step-21_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
*[1.x.39][1.x.40][1.x.41] 。
 

* 这个程序是由德克萨斯A&amp;M大学的Yan Li的一个学生项目发展而来的。这个程序的大部分工作是由她完成的。
* 在这个项目中，我们提出了对多孔介质中两个相流问题的数值模拟。这个问题包括一个椭圆方程和一个非线性的、与时间相关的传输方程。因此，这也是第一个时间相关的教程程序（除了[2.x.2]" [2.x.3]"有点奇怪的时间相关）。
* 这里涉及的方程是 [2.x.4] 中已经涉及的材料的扩展。特别是，它们属于向量值问题的范畴。关于这一主题的顶层概述可以在[2.x.5]模块中找到。
* 

* [1.x.42][1.x.43] 。
* 

* 多孔介质中的两相流建模对于环境修复以及石油和地下水储层的管理都很重要。涉及两相流动的实际情况包括含水层中非水相液体的分散，或储层中油和水等流体混合物的联合运动。仿真模型如果要提供真实的预测，就必须准确地考虑到这些影响。
* 为了推导出管理方程，考虑储层中的两相流动[2.x.6]，假设流体的运动由粘性效应主导；也就是说，我们忽略了重力、压缩性和毛细压力的影响。孔隙率将被认为是恒定的。我们将用下标[2.x.7]和[2.x.8]来表示这两个阶段的变量，即水和油的简称。然而，这些方程的解读对其他流体对也是适用的。
* 两相分子的运动速度由达西定律决定，即速度与压力梯度成正比：[1.x.44] 。
* 其中[2.x.9]是相[2.x.10]的速度，[2.x.11]是渗透性张量，[2.x.12]是相[2.x.13]的相对渗透性，[2.x.14]是压力，[2.x.15]是相[2.x.16]的黏性。最后，[2.x.17]是饱和度（体积分数），即一个数值在0和1之间的函数，表示流体混合物的组成。一般来说，系数[2.x.18]可能是空间依赖性的变量，在下文中我们总是将其视为非常数函数。
* 我们将达西定律与每一相的质量守恒声明结合起来，[1.x.45]每相都有一个源项。通过对两相求和，我们可以用所谓的压力方程来表达管理方程：[1.x.46] 。
* 这里，[2.x.19]是总源项，[1.x.47]是总流动性。
* 到目前为止，这看起来是一个普通的静止的、类似泊松的方程，我们可以用前几个教程程序的技术马上解决（例如，看一下[2.x.20]，就可以看到非常类似的东西）。然而，我们还没有提到饱和度的问题，当然，饱和度会随着流体的移动而改变。
* 方程的第二部分是对饱和度动态的描述，即两种液体的相对浓度如何随时间变化。置换流体（水）的饱和方程由以下守恒定律给出：[1.x.48] 。
*可以通过使用前一个方程中的发散算子的乘积规则来重写：[1.x.49] 。
* 这里，[2.x.21]是上面介绍的总流入量，[2.x.22]是置换流体（水）的流速。这两者与分流量[2.x.23]的关系如下：[1.x.50]其中分流量通常通过（启发式）表达式[1.x.51]进行参数化。 将所有这些放在一起，得到饱和方程式，其形式如下：[1.x.52
*其中[2.x.24]是总速度[1.x.53]注意，平流方程包含术语[2.x.25]而不是[2.x.26]，以表明饱和度不是简单地沿途传送；相反，由于两相以不同的速度移动，即使在平流坐标系中，饱和度实际上也可以改变。为了看到这一点，重写[2.x.27]，以观察具有饱和度[2.x.28]的相的[1.x.54]速度是[2.x.29]，而另一个相的速度是[2.x.30]。 因此，[2.x.31]通常被称为[1.x.55]。
* 综上所述，我们得到的是以下两个方程：[1.x.56] 。
* 这里，[2.x.32]现在是随时间变化的函数：虽然在每个时间点上，流场与压力是不平衡的（即我们忽略了动态加速），但饱和度是随着流动而传输的，因此随时间变化，反过来又通过第一个方程对[2.x.33]的依赖而影响流场。
* 这组方程有一个特殊的特点：两个方程中的一个有时间导数，另一个没有。这与压力和速度通过瞬时约束耦合的特点相对应，而饱和度在有限的时间尺度上演变。
* 这样的方程组被称为微分代数方程（DAEs），因为其中一个方程是微分方程，另一个不是（至少就时间变量而言不是），因此是一个 "代数 "方程。这个符号来自常微分方程领域，在这个领域中，所有不具有关于时间变量的导数的东西都必然是代数方程）。这类方程包含了相当知名的情况：例如，依赖时间的斯托克斯和纳维尔-斯托克斯方程（其中代数约束是流场的发散，[2.x.34]，必须为零）以及依赖时间的麦克斯韦方程（这里，代数约束是电位移场的发散等于电荷密度，[2.x.35] ，磁通密度的发散为零。 [2.x.36]）；即使是[2.x.37]的准静态模型也属于这一类别。我们将看到，这两个方程的不同特征将告知我们这两个方程的离散化策略。
* 

*[1.x.57][1.x.58]。
* 

* 在储层模拟界，通常是通过回到一阶混合配方来解决上述方程。为此，我们重新引入总速度[2.x.38]，并将方程写成如下形式：[1.x.59]
* 这种提法还有一个好处，即我们不必将运输方程中出现的总速度[2.x.39]表示为压力的函数，而可以将其作为主变量。鉴于前两个方程的鞍点结构以及它们与我们在[2.x.40]中介绍的混合拉普拉斯公式的相似性，我们将再次使用混合离散化，这并不奇怪。
* 但让我们先把这个问题推迟一下。我们处理这些方程的第一件事是考虑时间离散化问题。在储层模拟中，有一个相当标准的算法，我们将在这里使用。它首先使用隐式方程解决压力问题，然后使用显式时间步进方案解决饱和问题。该算法被称为IMplicit PressureExplicit Saturation（隐式压力显式饱和），很早以前就被提出：1959年由Sheldon等人提出，1961年由Stone和Gardner提出（J. W. Sheldon, B. Zondek andW. T. Cardwell）。[1.x.60], Trans. SPE AIME, 216 (1959), pp. 290-296; H.L. Stone and A. O. Gardner Jr: [1.x.61], Trans. SPE AIME, 222 (1961), pp. 92-104)。在一个稍加修改的形式中，这个算法可以写成如下：对于每个时间步长，求解[1.x.62]
*其中[2.x.41]是一个时间步长。请注意我们是如何解决只取决于先前计算的饱和度[2.x.42]的隐式压力-速度系统的，然后对[2.x.43]做显式时间步长，只取决于先前已知的[2.x.44]和刚计算的[2.x.45]。这样一来，我们就不必像使用全隐式方法那样对系统的非线性进行迭代。(从更现代的角度来看，这应该被看作是一种 "算子拆分 "方法。 [2.x.46]对这背后的想法有一个很长的描述）。)
* 然后，我们可以以弱的形式说明问题，用测试函数[2.x.47]、[2.x.48]和[2.x.49]乘以上述方程，并通过部分积分来表示：[1.x.63] 。
* 注意，在第一项中，我们必须规定边界[2.x.51]上的压力[2.x.50]作为我们问题的边界值。 [2.x.52]表示对[2.x.53]的单位外向法向量，如常。
* 对于饱和方程，我们通过部分积分得到[1.x.64]。
* 利用[2.x.54]这一事实，我们可以重写cell项，得到一个方程如下：[1.x.65] 。
* 我们引入一个DiscreteTime类型的对象，以便在代码中跟踪当前的时间值和时间步长。这个类封装了许多关于调整时间步长和在指定的最终时间停止的复杂情况。
* 

* 
* [1.x.66][1.x.67] 。
* 

* 在每个时间步长中，我们对速度和压力应用[2.x.55]" [2.x.56]"的混合有限方法。为了得到良好的求解，我们对[2.x.58]选择Raviart-Thomas空间[2.x.57]，对[2.x.60]选择类的不连续元素。对于饱和度，我们也将选择[2.x.61]空间。
* 由于我们有不连续的空间，我们必须考虑如何在单元格之间的界面上评估参数，因为不连续的函数在那里并没有真正的定义。特别是，我们必须给饱和度方程左边的最后一个定理赋予一个意义。为此，让我们定义，我们要在以下意义上评估它：[1.x.68] 。
* 其中[2.x.62]表示流入边界，[2.x.63]是边界的流出部分。然后数量[2.x.64]对应于当前单元上的变量值，而[2.x.65]（需要在[2.x.66]的边界流入部分）是取自邻近单元的数量。关于非连续单元技术和流速评估的更多背景，也可以在[2.x.67]和[2.x.68]中找到b。
* 

*[1.x.69][1.x.70]
* 

* 本程序中使用的线性求解器是对[2.x.69]中使用的线性求解器的直接扩展（但没有LinearOperator）。从本质上讲，我们只需要将所有的东西从两个解决组件扩展到三个。如果我们使用上面提到的离散空间，并将形状函数放到双线性形式中，就会发现在时间步长[2.x.70]中需要解决以下线性系统：[1.x.71]其中各个矩阵和向量的定义如下：使用形状函数[2.x.71]（Raviart Thomas[2.x.72]类型）用于velocities，[2.x.73]（2.x.74）类型用于压力和饱和度：[1.x.72]
* 
* [2.x.75] 由于历史事故，与[2.x.78]相比，矩阵[2.x.76]和[2.x.77]的作用在本程序中被还原了。换句话说，这里[2.x.79]指的是发散，[2.x.80]指的是梯度算子，而在[2.x.81]中则正好相反。
* 上面的系统出现了一个复杂的问题。由于矩阵[2.x.82]隐含地依赖于[2.x.83]（速度需要确定细胞边界[2.x.84]的哪些部分是流入或流出的部分），我们只有在解决了速度问题之后才能组装这个矩阵。
* 然后，求解方案包括以下步骤。[2.x.85] [2.x.86] 使用[2.x.88]中介绍的Schur补足技术求解压力[2.x.87] 。
* [2.x.89] 解决速度[2.x.90]，这在[2.x.91]中也有讨论。
* [2.x.92] 计算项[2.x.93] ，使用刚刚计算的速度。
* [2.x.94] 求解饱和度 [2.x.95] 。[2.x.96] 
* 在这个方案中，我们实际上从未建立矩阵[2.x.97]，而是在我们准备好之后生成第三个方程的右边。
* 在程序中，我们使用一个变量[2.x.98]来存储当前时间步骤的解决方案。在每一步结束时，我们将其内容，即其所有三个块状成分，复制到变量[2.x.99]中，以便在下一步使用。
* 

*[1.x.73][1.x.74]
* 

* 在双曲运输方程中，像我们要解决的饱和方程的一般经验法则是，如果我们使用显式时间步长方案，那么我们应该使用一个时间步长，使粒子在一个时间步长内可以移动的距离不大于单个细胞的直径。换句话说，在这里，我们应该选择[1.x.75]。幸运的是，我们处于一个可以做到这一点的位置：我们只需要在我们想要组装饱和方程的右侧时，也就是在我们已经解决了[2.x.100]之后，才需要这个时间步长。因此，在求解速度之后，我们所要做的就是在域中的所有正交点上循环，并确定速度的最大幅度。然后我们可以将饱和方程的时间步长设置为[1.x.76] 。
* 为什么要这样做呢？如果我们不这样做，那么我们就会出现很多地方的饱和度大于1或小于0，这一点很容易得到验证。请记住，饱和度相当于流体混合物中的水的比例，因此物理上必须介于0和1之间）。另一方面，如果我们根据上述标准选择时间步长，这种情况只会非常非常少地发生，事实上在程序的整个运行过程中只有一次。然而，为了安全起见，我们在每个时间步长结束时运行一个函数[2.x.101]，如果饱和度超出了物理范围，则简单地将其投射回间隔[2.x.102]。这很有用，因为函数[2.x.103]和[2.x.104]并不代表这个范围以外的任何物理现象，而且我们不应该期望程序在我们有负的饱和度或大于1的饱和度时做任何有用的事情。
* 请注意，在[2.x.105]和[2.x.106]中，我们对时间步长也有类似的限制，在那里我们要解决时间相关的波浪方程，也是一个双曲问题。我们还将在下面的[1.x.77]一节中回到时间步长的选择问题。
* 

* [1.x.78][1.x.79] 。
* 

* 为简单起见，本程序假定没有源，[2.x.107]，并且异质多孔介质是各向同性的[2.x.108]。其中第一个假设在石油储层中是一个现实的假设：除了注入井和生产井，通常不存在流体突然出现或消失的机制。第二个假设更难证明：在微观层面上，大多数岩石是各向同性的，因为它们是由相互连接的孔隙网络组成的。然而，这种微观尺度超出了今天计算机模拟的范围，我们不得不满足于模拟米级的东西。然而，在这个尺度上，流体运输通常是通过岩石中的裂缝网络，而不是通过孔隙。然而，裂缝往往是由岩层中的外部应力场造成的（例如由构造断层造成的），因此裂缝是大致排列的。这就导致了这样一种情况：在与裂缝平行的方向上，渗透率往往比垂直于裂缝的方向上大几个数量级。然而，在储层模拟中通常面临的一个问题是，建模者不知道裂缝的方向，因为油藏不容易被检查到。在这种情况下，唯一的解决办法是假设一个有效的、各向同性的渗透率。
* 无论怎样，这两个限制，即无源和各向同性，都可以通过程序中的几行代码轻松解除。
* 接下来，为了简单起见，我们的数值模拟将在单元格[2.x.109]上进行，用于[2.x.110] 。我们的初始条件是[2.x.111]；在油藏图中，[2.x.112]表示水的饱和度，这意味着油藏一开始就含有纯油。请注意，我们不需要任何压力或速度的初始条件，因为方程中不包含这些变量的时间衍生物。最后，我们施加以下压力边界条件：[1.x.80]由于压力和速度解决的是混合形式的泊松方程，施加的压力导致了速度的流场结果。另一方面，这个流场决定了边界的某一部分是流入还是流出，这一点很重要，因为我们必须在边界的流入部分施加饱和度的边界条件，[1.x.81]在这个流入的边界上，我们施加以下的饱和度值：[1.x.82] 。
* 换句话说，我们有纯水在左边进入储层，而边界的其他部分与储层的未受干扰部分接触，只要这些边界上发生流入，纯油就会进入。
* 在我们的模拟中，我们选择总的流动性为[1.x.83]，其中我们使用[2.x.113]的粘度。此外，水的部分流量由[1.x.84]给出。
* [2.x.114] 几年后，在[2.x.115]中再回到这个测试案例，发现这个测试案例的设置存在缺陷。为此，考虑到我们可以把饱和度的平流方程写成 [2.x.116] 。现在，在初始时间，我们有[2.x.117]，而在给定的函数[2.x.118]的选择下，我们正好有[2.x.119]。换句话说，在[2.x.120]处，方程对所有[2.x.122]都还原为[2.x.121]，所以饱和度在任何地方都是零，而且在任何地方都会保持零！这就是为什么[2.x.122]处的饱和度为零。尽管[2.x.123]不一定是零：组合流体在移动，但我们选择的部分通量[2.x.124]是这样的：有限数量的润湿流体也只以无限小的速度移动（也就是说，它们粘附在介质上的程度比它们所处的非润湿相要大）。也就是说，我们如何将这一点与润湿液从左边侵入，导致在[1.x.85]中看到的流动模式的知识相联系？这就是我们进入数学的地方。像我们在这里考虑的传输方程有无限多的解决方案，但其中只有一个是物理的：从所谓的粘性极限产生的解决方案，称为[1.x.86]。问题是，在不连续元素的情况下，我们得出了这个粘度极限，因为使用数值通量在数值方案中引入了有限量的人工粘度。另一方面，在[2.x.125]中，我们在每个单元上使用与[2.x.126]成比例的人工粘度，在初始时间为零。因此，那里的饱和度为零并保持为零；然后我们得到的解是[1.x.87]的对流方程的解，但该方法不需要进一步改变就能收敛到粘度解。因此，我们将在该程序中使用一个不同的初始条件。
* 

* 最后，回到测试案例的描述，我们将展示在[2.x.127]"[2.x.128]"的结果部分末尾介绍的两个渗透率函数的计算结果：[2.x.129][2.x.130]一个函数，模拟一个蜿蜒穿过域的单一裂缝。与[2.x.131]相类似，但考虑到我们这里的几何形状略有不同，我们用以下函数来描述它。 [1.x.88] 取最大值是必要的，以确保最大和最小磁导率之间的比率保持有界。如果我们不这样做，渗透率将跨越许多数量级。另一方面，最大和最小渗透率之间的比率是舒尔补矩阵的条件数的一个因素，如果太大，会导致我们的线性求解器不再正常收敛的问题。
* [2.x.132] 一个模拟某种随机介质的函数。这里，我们选择[1.x.89]。
* 其中中心[2.x.133]是域内[2.x.134]随机选择的位置。这个函数模拟了一个领域，其中有[2.x.135]个渗透率较高的中心（例如，岩石已经开裂），嵌入到一个更原始的、未受干扰的背景岩石矩阵中。请注意，在这里，我们在上方和下方都切断了渗透率函数，以确保有一个有界的条件数。[2.x.136] 
 

* [1.x.90] [1.x.91]。
* 本程序是对 [2.x.137] 的改编，包括一些来自 [2.x.138] 的DG方法的技术。因此，该程序的很大一部分与 [2.x.139] 非常相似，我们将不再对这些部分进行评论。只有新的东西会被更详细地讨论。
* 

* 
* [1.x.92] [1.x.93].
* 

* 
* 所有这些包含文件以前都被使用过。
* 

* 
* [1.x.94]
* 
* 在这个程序中，我们使用一个张量值的系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的[2.x.140]类。
* 

* 
* [1.x.95]
* 
* 另外，我们使用[2.x.141]类来执行与时间递增有关的操作。
* 

* 
* [1.x.96]
* 
* 最后一步和以前的所有程序一样。
* 

* 
* [1.x.97]
* 
* [1.x.98] [1.x.99]。
 

* 
* 这是该程序的主类。它接近于[2.x.142]中的一个，但增加了一些功能。  
* [2.x.143] [2.x.144] [2.x.145] 组装饱和方程的右侧。正如介绍中所解释的，这不能被集成到[2.x.146]中，因为它取决于在时间步长的第一部分计算的速度。  
* [2.x.147] [2.x.148]的作用正如其名称所示。这个函数被用于计算时间步长。  
* [2.x.149] [2.x.150] 将所有饱和度小于零的自由度重置为零，将所有饱和度大于一的自由度重置为一。  [2.x.151]    
* 该类的其余部分应该是非常明显的。变量[2.x.152]存储粘度[2.x.153]，它进入了非线性方程中的几个公式。变量[2.x.154]记录了模拟中的时间信息。
* 

* 
* [1.x.100]
* 
* [1.x.101] [1.x.102]。
 

 
* [1.x.103] [1.x.104]。
 

* 
* 目前，压力方程的右侧仅仅是零函数。然而，如果需要的话，程序的其余部分完全可以处理其他的东西。
* 

* 
* [1.x.105]
* 
* [1.x.106] [1.x.107].
 

* 
* 接下来是压力边界值。正如介绍中提到的，我们选择一个线性压力场。
* 

* 
* [1.x.108]
* 
* [1.x.109] [1.x.110]。
 

* 
* 然后我们还需要边界的流入部分的边界值。某物是否为流入部分的问题是在组装右手边时决定的，我们只需要提供边界值的功能描述。这正如介绍中所解释的那样。
* 

* 
* [1.x.111]
* 
* [1.x.112] [1.x.113]。
 

* 
* 最后，我们需要初始数据。实际上，我们只需要饱和度的初始数据，但是我们很懒，所以以后在第一个时间步骤之前，我们会简单地从一个包含所有向量分量的函数中插值出前一个时间步骤的整个解。  
*因此，我们简单地创建一个函数，在所有分量中返回零。我们通过简单地将每个函数转发到[2.x.155]类来做到这一点。为什么不在这个程序中我们目前使用[2.x.156]类的地方立即使用呢？因为这样的话，以后再去选择不同的函数作为初始值就更简单了。
* 

* 
* [1.x.114]
* 
* [1.x.115] [1.x.116].
 

* 
* 正如介绍中所宣布的，我们实现了两个不同的渗透率张量场。我们把它们各自放入一个命名空间，这样以后就可以很容易地在代码中用另一个来代替使用。
* 

* 
* [1.x.117] [1.x.118].
* 

* 
* 渗透率的第一个函数是模拟单个弯曲裂缝的函数。它在[2.x.157]的结尾已经使用过了，它的函数形式在本教程程序的介绍中给出。和以前的一些程序一样，我们必须声明KInverse类的一个（似乎是不必要的）默认构造函数，以避免某些编译器的警告。
* 

* 
* [1.x.119]
* 
* [1.x.120] [1.x.121].
 

* 
* 这个函数的作用与介绍中公布的一样，即在随机的地方创建一个指数的叠加。对于这个类，有一件事值得考虑。这个问题的核心是该类用随机函数创建指数的中心的问题。如果我们因此在每次创建本类型的对象时都创建中心，我们每次都会得到一个不同的中心列表。这不是我们对这种类型的类的期望：它们应该可靠地代表同一个函数。  
* 解决这个问题的方法是使中心列表成为这个类的一个静态成员变量，也就是说，整个程序中只存在一个这样的变量，而不是为这个类型的每个对象。这正是我们要做的。  
* 然而，接下来的问题是，我们需要一种方法来初始化这个变量。由于这个变量是在程序开始时初始化的，我们不能使用普通的成员函数，因为当时身边可能没有这个类型的对象。因此C++标准规定，只有非成员函数和静态成员函数可以用来初始化静态变量。我们通过定义一个函数[2.x.158]来使用后一种可能性，该函数在调用时计算中心点的列表。  
* 注意这个类在2D和3D中都能正常工作，唯一的区别是我们在3D中使用了更多的点：通过实验我们发现我们在3D中比2D中需要更多的指数（毕竟我们有更多的地方需要覆盖，如果我们想保持中心之间的距离大致相等），所以我们在2D中选择40，在3D中选择100。对于任何其他维度，该函数目前不知道该怎么做，所以只是简单地抛出一个异常，表明这一点。
* 

* 
* [1.x.122]
* 
* [1.x.123] [1.x.124] * [1.x.123]。
 

* 
* 还有两个数据我们需要描述，即反迁移函数和饱和曲线。它们的形式也在介绍中给出。
* 

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127]。
 

* 
* 我们使用的线性求解器也完全类似于 [2.x.159] 中使用的。因此，下面的类是逐字逐句地从那里复制的。请注意，这里的类不仅是从[2.x.160]中复制的，而且在deal.II中也有重复的类。在这个例子的未来版本中，它们应该被一个有效的方法所取代，虽然。有一个变化：如果线性系统的大小很小，也就是说，当网格很粗时，那么在[2.x.161]函数中的求解器收敛之前，设置最大的[2.x.162]CG迭代次数有时是不够的。(当然，这是数值取舍的结果，因为我们知道，在纸面上，CG方法最多只能在[2.x.163]步内收敛)。因此，我们设定最大迭代次数等于线性系统大小的最大值和200。
* 

* 
* [1.x.128]
* 
* [1.x.129] [1.x.130].
 

* 
* 这里是主类的实现。它的大部分内容实际上是从[2.x.164]中复制过来的，所以我们不会对它进行过多的评论。你应该先试着熟悉一下那个程序，然后这里发生的大部分事情就应该很清楚了。
* 

* 
* [1.x.131] [1.x.132]。
* 

* 
* 首先是构造函数。我们使用[2.x.165]空间。对于初始化DiscreteTime对象，我们不在构造函数中设置时间步长，因为我们还没有它的值。时间步长最初被设置为零，但在需要增量时间之前，它将被计算出来，正如介绍的一个小节中所描述的。时间对象在内部阻止自己在[2.x.166]时被递增，迫使我们在推进时间之前为[2.x.167]设置一个非零的期望大小。
* 

* 
* [1.x.133]
* 
* [1.x.134] [1.x.135].
 

* 
* 接下来的函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之关联。它所做的事情与[2.x.168]中的相同，只是现在是针对三个组件而不是两个。
* 

* 
* [1.x.136]
* 
* [1.x.137] [1.x.138].
 

* 
* 这是组装线性系统的函数，或者至少是除了(1,3)块之外的所有东西，它取决于在这个时间步长中计算的仍然未知的速度（我们在[2.x.169]中处理这个问题）。它的大部分内容与[2.x.170]中一样，但这次我们必须处理一些非线性问题。 然而，该函数的顶部与往常一样（注意，我们在开始时将矩阵和右手边设置为零&mdash；对于静止问题我们不必这样做，因为在那里我们只使用每个矩阵对象一次，而且在开始时它是空的）。  
* 请注意，在目前的形式下，该函数使用[2.x.171]类中实现的渗透率。切换到单曲裂缝渗透率函数就像改变命名空间名称一样简单。
* 

* 
* [1.x.139]
 
* 这里是第一个显著的区别。我们必须在正交点上获得前一个时间步长的饱和函数值。为此，我们可以使用[2.x.172]（之前已经在[2.x.173]、[2.x.174]和[2.x.175]中使用），这个函数接收一个解向量并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。
* 

* 
* [1.x.140]
* 
* 然后我们还要得到压力的右手边和反渗透性张量在正交点的数值。
 

* 
* [1.x.141]
* 
* 有了这些，我们现在就可以在这个单元的所有正交点和形状函数上进行循环，并将我们在这个函数中处理的矩阵和右手边的那些部分组合起来。鉴于引言中所述的双线性形式的明确形式，贡献中的各个条款应该是不言自明的。
* 

* 
* [1.x.142]
 
* 接下来，我们还必须处理压力边界值。这一点，还是和[2.x.176]中一样。
* 

* 
* [1.x.143]
* 
* 在所有单元的循环中，最后一步是将局部贡献转移到全局矩阵和右手向量中。
* 

* 
* [1.x.144]
* 
* 矩阵和右手边的组装就这么多了。请注意，我们不需要插值和应用边界值，因为它们都已经在弱形式中得到了处理。
* 

* 
*  
*  
* [1.x.145] [1.x.146].
 

* 
* 正如介绍中所解释的，我们只有在计算了速度后才能评估饱和方程的右边。因此，我们有这个单独的函数来实现这个目的。
* 

* 
* [1.x.147]
 
* 首先是单元条款。按照介绍中的公式，这些是[2.x.177] ，其中[2.x.178]是测试函数的饱和成分。
* 

* 
* [1.x.148]
* 
* 其次，我们必须处理面的边界上的通量部分。这就有点麻烦了，因为我们首先要确定哪些是细胞边界的流入和流出部分。如果我们有一个流入的边界，我们需要评估面的另一边的饱和度（或者边界值，如果我们在域的边界）。        
* 所有这些都有点棘手，但在 [2.x.179] 中已经有了一些详细的解释。请看一下，这应该是如何工作的!
* 

* 
* [1.x.149]
* 
* [1.x.150] [1.x.151].
 

* 
* 在所有这些准备工作之后，我们最终以与[2.x.180]中相同的方式解决速度和压力的线性系统。在这之后，我们必须处理饱和方程（见下文）。
* 

* 
* [1.x.152]
 
* 首先是压力，使用前两个方程的压力舒尔补。
* 

* 
* [1.x.153]
 
* 现在是速度。
* 

* 
* [1.x.154]
* 
* 最后，我们必须处理好饱和方程的问题。我们在这里要做的第一件事是使用介绍中的公式来确定时间步长。知道了我们领域的形状和我们通过有规律的划分单元创建的网格，我们可以很容易地计算每个单元的直径（事实上我们使用的是单元坐标方向上的线性扩展，而不是直径）。请注意，我们将在[2.x.181]中学习一种更通用的方法，在那里我们使用[2.x.182]函数。    
* 我们使用一个辅助函数来计算下面定义的最大速度，有了这些，我们就可以评估我们新的时间步长了。我们使用方法[2.x.183]来向DiscreteTime对象建议新的时间步长计算值。在大多数情况下，时间对象使用精确提供的值来增加时间。在某些情况下，时间对象可以进一步修改步骤大小。例如，如果计算出的时间增量超过了结束时间，它将被相应地截断。
* 

* 
* [1.x.155]
 
* 下一步是组装右手边，然后把所有的东西都传到解上。最后，我们把饱和度投射回物理上合理的范围。
* 

* 
* [1.x.156]
* 
* [1.x.157] [1.x.158]。
 

* 
* 这里没有什么令人惊讶的。因为程序会做很多时间步长，所以我们只在每五步时间创建一个输出文件，而在文件的顶部已经跳过所有其他时间步长。  
*在为接近函数底部的输出创建文件名时，我们将时间步长的数字转换为字符串表示，用前导零填充到四位。我们这样做是因为这样所有的输出文件名都有相同的长度，因此在创建目录列表时可以很好地排序。
* 

* 
* [1.x.159]
* 
* [1.x.160] [1.x.161] * [1.x.161]。
 

* 
* 在这个函数中，我们简单地遍历所有的饱和自由度，并确保如果它们应该离开物理上的合理范围，那么它们将被重置到区间 [2.x.184] 。要做到这一点，我们只需要循环解决向量的所有饱和分量；这些分量被存储在块2中（块0是速度，块1是压力）。  
* 值得注意的是，当时间步长选择在介绍中提到的时候，这个函数几乎从不触发。然而，如果我们只选择稍大的时间步长，我们会得到大量超出适当范围的数值。严格来说，如果我们选择的时间步长足够小，这个函数因此是不必要的。从某种意义上说，这个函数只是一个安全装置，以避免由于个别自由度在几个时间步长之前变得不符合物理条件而导致我们的整个解决方案变得不符合物理条件的情况。
* 

* 
* [1.x.162]
* 
* [1.x.163] [1.x.164]
 

* 
* 以下函数用于确定最大的允许时间步长。它的作用是在域中的所有正交点上循环，并找出速度的最大幅度。
* 

* 
* [1.x.165]
* 
* [1.x.166] [1.x.167].
 

* 
* 这是我们主类的最后一个函数。它的简洁不言自明。只有两点是值得注意的。首先，该函数在开始时将初始值投射到有限元空间上；[2.x.185]函数这样做需要一个参数来表明悬挂节点的约束。我们在这个程序中没有（我们在一个均匀细化的网格上计算），但是这个函数当然需要这个参数。所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，在使用前必须进行排序（使用[2.x.186]函数）。这就是我们在这里所做的，这也是为什么我们不能简单地用一个匿名的临时对象[2.x.188]作为第二个参数来调用[2.x.187]函数。  
* 第二点值得一提的是，我们只在求解每个时间步长对应的线性系统的过程中计算当前时间步长。因此，我们只有在时间步长结束时才能输出一个时间步长的当前时间。我们通过调用循环内的方法[2.x.189]来增加时间。由于我们在增量后报告时间和dt，我们必须调用方法[2.x.190]，而不是[2.x.191]。 经过许多步，当仿真到达结束时间时，最后的dt由DiscreteTime类选择，其方式是最后一步正好在结束时间完成。
* 

* 
* [1.x.168]
* 
* [1.x.169] [1.x.170] [1.x.170].
 

* 
* 这就是了。在主函数中，我们将有限元空间的度数传递给TwoPhaseFlowProblem对象的构造函数。 这里，我们使用零度元素，即[2.x.192] 。其余部分与所有其他程序一样。
* 

* 
* [1.x.171]
* [1.x.172][1.x.173] 。
* 

* 这里介绍的代码并没有真正计算出网页上的结果。原因是，即使在一台普通的计算机上，它也要运行超过一天的时间。如果你想重现这些结果，请在两相流问题的构造器中把离散时间对象的结束时间修改为`250'。
* 如果我们运行该程序，我们会得到以下的输出。
* [1.x.174]
* 我们可以看到，时间步长从一开始就非常恒定，这表明域中的速度并不强烈依赖于饱和度的变化，尽管它们肯定是通过压力方程中的因子[2.x.193]来实现的。
* 我们的第二个观察结果是，在第一个和第二个时间步骤之间，解决压力舒尔补足方程所需的CG迭代次数从22次下降到17次（事实上，在其余的计算中，它仍然是17次左右）。原因其实很简单。在我们求解一个时间步长的压力之前，我们没有将[2.x.194]变量重置为零。因此，当我们进入CG求解器时，压力（和其他变量）具有前一个时间步长的值。由于速度和压力在计算过程中变化不大，前一时间段的压力实际上是对这一时间段压力的良好初始猜测。因此，一旦我们计算了一次压力，我们需要的迭代次数就会大大减少。
* 最后的观察是关于解决饱和度问题所需的迭代次数，即一次。这不应该让我们太惊讶：我们要解决的矩阵是质量矩阵。然而，这是[2.x.195]元素的质量矩阵，其中没有元素与相邻单元的自由度相耦合。因此，该矩阵是一个对角线，很明显，我们应该能够在一次CG迭代中反转该矩阵。
* 

* 综上所述，这里有几段影片显示了饱和度是如何随着时间的推移而发展的。首先，这是在[2.x.196]类中实现的单一裂缝模型。
* [2.x.197] 
* 可以看出，富水流体主要是沿着域中间的高渗透区蜿蜒前行，而域的其他部分大部分是不渗透的。这部电影和下一部电影是用[2.x.198]生成的，导致[2.x.199]的网格有大约16000个单元和大约66000个未知数。
* 

* 第二部电影显示了[2.x.200]类随机介质模型的饱和度，其中我们有随机分布的高渗透率中心，流体从这些区域中的一个跳到另一个。
* [2.x.201] 
* 

* 最后，这里是在三个空间维度上的相同情况，在[2.x.202]的网格上，产生了一个大约32000个单元和167000个自由度的网格。
* [2.x.203] 
* 要重复这些计算，你所要做的就是改变这一行
* [1.x.175]
* 将主函数中的一行改为
* [1.x.176]
* 可视化使用了云技术，每个单元的饱和度都由彩色但透明的云来表示。这样一来，人们也可以看到域的深处发生了什么。一种不同的可视化方式是显示饱和度随时间变化的等值线。有一些技术可以透明地绘制等值面，这样人们就可以像看洋葱层一样同时看到几个等值面。
* 那么，为什么我们不显示这样的等值面呢？问题在于计算等值面的方式：它们要求被可视化的场是连续的，因此等值面可以通过遵循至少跨越一个单元的轮廓线来生成。然而，我们的饱和度场是片状常数，而且是不连续的。如果我们想为一个饱和度[2.x.204]绘制一个等值面，那么在这个领域中，很可能没有一个点是真正达到饱和度的。如果我们必须在这种情况下定义等值线，我们将不得不采取细胞之间的界面，其中相邻的两个细胞的饱和度大于，另一个细胞的饱和度小于0.5。然而，大多数可视化程序似乎并不具备做这种转换的能力。
* 

* [1.x.177][1.x.178][1.x.179] 。
* 

* 这个程序有许多可以改进的地方。下面列出了其中的三个。事实上，所有这些都在构成当前程序的延续的教程程序中得到解决。 [2.x.205] .
* 

* [1.x.180][1.x.181] 。
* 

* 目前，该程序不是特别快：二维随机介质计算在1000个左右的时间步数中花费了大约一天时间。相应的三维计算在800个时间步数上几乎花了两天时间。它没有比这更快的原因有两个方面。首先，我们在每个时间步骤中都要重建整个矩阵，尽管有些部分如[2.x.206]、[2.x.207]和[2.x.208]块从未改变。
* 第二，我们可以在求解器和预处理器方面做得更好。目前，我们用CG方法求解舒尔补码[2.x.209]，用[2.x.210]作为预调节器。应用这个预处理程序是很昂贵的，因为它每次都要解决一个线性系统。这对于[2.x.211]"[2.x.212]"可能是合适的，在那里我们只需要解决整个问题一次。然而，在这里，我们必须求解数百次，在这种情况下，值得考虑一个预处理程序，它在第一次设置时比较昂贵，但在以后应用时比较便宜。
* 一种可能性是认识到我们用作预处理的矩阵，[2.x.213]仍然是稀疏的，而且是对称的。如果看一下流场随时间的演变，我们还可以看到，虽然[2.x.214]随时间变化很大，但压力几乎没有变化，因此[2.x.215] 。换句话说，第一个时间步骤的矩阵应该是一个很好的预设条件，也适用于所有后来的时间步骤。 通过一些反反复复的操作，实际上不难得到一个SparseMatrix对象的表示。然后我们可以把它交给SparseMIC类来进行稀疏的不完全Cholesky分解。形成这种分解的成本很高，但是我们只需要在第一个时间步骤中做一次，然后就可以在将来把它作为一个廉价的预处理程序。我们甚至可以通过使用SparseDirectUMFPACK类来做得更好，它不仅可以产生一个不完整的，而且是一个完整的矩阵分解，这应该会产生一个更好的预处理程序。
* 最后，为什么使用近似值[2.x.216]对[2.x.217]进行预处理？后者的矩阵毕竟是拉普拉斯算子在压力空间上的混合形式，对此我们使用线补充。因此，我们可以在直接与拉普拉斯的非混合形式相对应的一侧建立一个单独的矩阵[2.x.218]，例如使用双线性形式[2.x.219]。然后我们可以对这个非混合矩阵进行不完全或完整的分解，并将其作为混合形式的预处理。
* 使用这样的技术，可以合理地预期，求解过程将至少快一个数量级。
* 

*[1.x.182][1.x.183]
* 

* 在引言中，我们确定了时间步长限制[1.x.184]，该限制必须在全局范围内成立，即对所有[2.x.220]。在离散化之后，我们通过选择[1.x.185]来满足它。
* 这种对时间步长的限制有点令人讨厌：我们把网格做得越细，时间步长就越小；换句话说，我们受到了两次惩罚：每个时间步长的求解费用更高，我们必须做更多的时间步长。
* 这一点特别令人恼火，因为大部分额外的工作都花在了解决方程的隐含部分，即压力-维络系统，而正是饱和度的双曲传输方程造成了时间步长的限制。
* 为了避免这一瓶颈，人们发明了一些方法。例如，他们可以每隔几个时间步数才重新计算压力-速度场（或者，如果你愿意，对压力/速度和饱和度方程使用不同的时间步数）。这样就可以保持对廉价显式部分的时间步长限制，而使隐式部分的求解不那么频繁。这个方向的实验肯定是值得的；这种方法的一个出发点是陈章新、桓冠仁和李宝岩的论文：[1.x.186]，Transport in Porous Media，54（2004），pp. 361&mdash;376。当然也有很多其他关于这个主题的论文，但这篇论文是前段时间偶然出现在我们的办公桌上的。
* 

* 
* [1.x.187][1.x.188] 。
* 

* 适应性显然也会有帮助。看一下这些电影，我们可以清楚地看到，大部分的行动都被限制在领域的一个相对较小的部分（这对饱和度来说特别明显，但对velocities和压力来说也是如此）。因此，适应性可望保持必要的低自由度数，或者增加准确度。
* 另一方面，对于时间相关的问题，自适应性并非易事：我们必须每隔几步改变网格，而且每次改变网格时，我们都必须将目前的解决方案传送到下一个网格（SolutionTransfer类可以帮助解决这个问题）。这些都不是不可逾越的障碍，但它们确实需要一些额外的编码，而且比我们认为值得打包到这个教程程序中的还要多。
* 

* [1.x.189][1.x.190] [2.x.221]。
* [0.x.1]

