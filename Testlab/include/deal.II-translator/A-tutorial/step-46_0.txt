include/deal.II-translator/A-tutorial/step-46_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34]
* [2.x.4] 
* [1.x.35]
* 

* [1.x.36][1.x.37][1.x.38] 。
* 

* 这个程序处理的是在领域的不同部分耦合不同物理学的问题。具体来说，让我们考虑以下情况，将斯托克斯流体与弹性固体耦合起来（这两个问题以前在[2.x.5]和[2.x.6]中分别讨论过，你可能想在那里阅读一下各个方程式）。
* 
* - 在[2.x.8]的[2.x.7]部分，我们有一个流动的流体，它满足与时间无关的斯托克斯方程（以涉及应变张量的形式）。
* [1.x.39]
* 这里，[2.x.9]分别是流体的速度和压力。 我们规定了部分外部边界上的速度。
* [1.x.40]
* 而我们假设外部边界的其余部分为自由流动条件。
* [1.x.41]
* 
* 
* - 域的其余部分，[2.x.10]被一个固体占据，其变形场[2.x.11]满足弹性方程。
* [1.x.42]
*其中[2.x.12]是等级4的弹性张量（我们将使用一个特别简单的形式，假设该固体是各向同性的）。 它在对沿固体边界流动的流体所施加的力的反应中发生变形。我们假设这种变形非常小，以至于它对流体没有反馈作用，也就是说，这种耦合只是在一个方向。为了简单起见，我们将假设固体的外部边界是被夹紧的，也就是说。
* [1.x.43]
* 
* 
* - 作为小位移假设的结果，我们将在流体和固体的界面上提出以下边界条件：首先，我们对流体没有滑移边界条件。
* [1.x.44]
* 第二，固体上的力（牵引力）等于流体的法向应力。
* [1.x.45]
* 其中[2.x.13]是[2.x.14]上从固体指向流体的法向量。
* 通过遵循我们通常的规则，即从左边乘以一个测试函数并在域上积分，我们得到了这个问题的弱表述。那么它看起来像这样。找到[2.x.15]，使得
* [1.x.46]
*对于所有测试函数[2.x.16]；第一、第二和第三条线分别对应于流体、固体和界面的贡献。注意[2.x.17]只是上述空间的一个子空间，以适应各种迪里希特边界条件。
* 这种耦合当然可以通过简单地拥有两个Triangulation和两个DoFHandler对象来实现，两个子域各一个。另一方面，如果有一个DoFHandler对象知道整个问题的离散化，那么deal.II使用起来就简单多了。
* 这个程序是关于如何实现这一目标的。请注意，我们的目标并不是呈现一个特别有用的物理模型（一个现实的流体-结构相互作用模型必须考虑到固体的有限变形以及它对流体的影响）：毕竟，这只是一个旨在演示技术的教程程序，而不是解决实际问题。此外，我们将假设子域之间的界面与粗略的网格单元面对齐。
* 

* [1.x.47][1.x.48] 。
* 

* 在进入更多的细节之前，让我们先说明一个显而易见的问题：这是一个有多个求解变量的问题；为此，你可能想先阅读[2.x.18]文件模块，它代表了我们解决有多个求解变量问题的基本哲学框架。但回到手头的问题上。
* 在deal.II中实现这类问题的基本思路如下：在问题的表述中，速度和压力变量[2.x.19]只存在于流体子域[2.x.20]中。但我们假设将它们以零点扩展到整个域[2.x.21]（在一般情况下，这意味着它们沿[2.x.22]将是不连续的）。那么，对于这些变量来说，合适的函数空间是什么？我们知道在[2.x.23]上我们需要[2.x.24]，所以对于[2.x.25]到整个领域的扩展，下面的函数空间似乎是一个有用的集合。
* [1.x.49]
* 由于这对目前的讨论并不重要，我们在选择函数空间时省略了边界值的问题；这个问题也影响到我们是否可以为压力选择[2.x.26]，或者我们是否必须为压力选择空间[2.x.27]。不过，这些问题都与下面的讨论无关）。)
* 请注意，这些确实是一个具有明显规范的线性函数空间。由于在实践中不可能发生混淆，因此我们将再次省略省略号，以表示一个函数对整个域的扩展，并简单地用[2.x.28]指代原始函数和扩展函数。
* 对于离散化，我们需要[2.x.30]的有限维子空间[2.x.29] 。对于斯托克斯，我们从[2.x.31]中知道，适当的选择是[2.x.32]，但这只适用于流体占据的那部分域。对于扩展场，让我们使用定义在三角形上的以下子空间[2.x.33] 。
* [1.x.50]
* 换句话说，在[2.x.34]上，我们选择通常的离散空间，但我们保持（不连续的）扩展为零。需要指出的是，我们现在需要描述一个在单元上为零的函数的有限元空间&mdash；这就是FE_Nothing类的作用：它描述了一个有限维度的函数空间，即恒定为零。这个特殊的线性向量空间的一个特殊属性是它没有自由度：它不仅仅是有限维度的，它实际上是零维的，因此对于这种类型的对象，[2.x.35]将返回零。为了下面的讨论，让我们给这个空间一个合适的符号：[1.x.51]符号[2.x.36]提醒了这个空间的函数为零的事实。很明显，我们选择[2.x.37]。
* 上面的整个讨论可以重复用于我们用来描述弹性方程的变量。这里，对于扩展变量，我们有
* [1.x.52]
* 我们通常会使用这样的有限元空间
* [1.x.53]
*多项式度数[2.x.38]。
* 因此，总的来说，我们要在以下空间中寻找一个离散的矢量估值解[2.x.39]。
* [1.x.54]
 
* 

* 
* [1.x.55][1.x.56] 。
* 

* 那么我们如何实现这种事情呢？首先，我们意识到离散空间[2.x.40]本质上需要两个不同的有限元。首先，在流体子域上，我们需要元素[2.x.41]，在deal.II中很容易通过以下方式实现
* [1.x.57]
* 其中[2.x.42]实现的是永远为零的函数空间。第二，在实体子域上，我们需要元素[2.x.43]，我们用以下方法得到它
* [1.x.58]
* 
* 下一步是我们将这两个元素分别与占据两个子域的单元联系起来。为此，我们认识到，从某种意义上说，这两个元素只是彼此的变化，因为它们具有相同数量的向量分量，但具有不同的多项式度数&mdash；这听起来非常像[2.x.44]有限元方法中的做法，而这正是我们在这里要做的：我们要（ab）使用hp命名空间的类和设施，将不同的元素分配给不同的单元。换句话说，我们将使用[2.x.45]中的两个有限元与适当的[2.x.46]集成，使用[2.x.47]对象，而我们的DoFHandler将处于[1.x.59]模式。你可能希望看一下[2.x.48]，了解所有这些概念的概况。
* 在继续描述测试案例之前，让我们澄清一下[1.x.60]这种将函数以0扩展到整个领域，然后将问题映射到HP-框架上的方法是有意义的。
* 
* - 它使事情变得统一。在所有单元上，向量分量的数量是相同的（这里是[2.x.49]）。这使得各种事情都成为可能，因为统一的描述允许代码的重复使用。例如，计算每个向量分量的自由度[2.x.50]按分量对自由度进行排序[2.x.51]，随后将矩阵和向量分割成块，以及其他许多函数都能一如既往地工作，而不需要给它们添加特殊的逻辑来描述某些变量只存在于部分域的情况。因此，在像现在这样的程序中，你已经有了各种工具，这些工具最初并不是为多物理场情况编写的，但在目前的情况下却能正常工作。
* 
* - 它可以方便地进行图形输出。我们支持的所有图形输出格式都要求输出中的每个字段都定义在网格的所有节点上。但是考虑到现在所有的解决方案组件都存在于各个地方，我们现有的DataOut例程可以像以前一样工作，并产生适合可视化的图形输出。
* 
* - 这些字段将简单地以0扩展，如果不需要的话，可视化程序可以很容易地过滤掉这个值。
* 
* - 基本上没有成本。使用FE_Nothing的技巧不会给整个问题增加任何自由度，我们也从来不需要处理属于这些分量的形状函数&mdash；FE_Nothing没有自由度，也没有形状函数，它所做的只是占用矢量分量。
* 

*[1.x.61][1.x.62]
* 

* 更具体地说，在程序中我们要解决以下几点。
* 
* - 实现双线性形式，特别是处理界面项，包括矩阵和稀疏模式。
* 
* - 在边界的外部和内部部分实现迪里切特边界条件 [2.x.52] 。
* 

* [1.x.63][1.x.64] 。
* 

* 让我们首先讨论实现双线性形式，在离散水平上，我们记得它是
* [1.x.65]
* 鉴于我们已经将场扩展为零，原则上我们可以将子域上的积分写成整个域[2.x.53]，尽管在决定对哪些项进行积分之前，首先询问一个单元是弹性区域还是流体区域的一部分，这几乎是额外的努力。实际上，对这些项进行积分并不十分困难；对于斯托克斯方程，相关步骤已在[2.x.54]中显示，而对于弹性方程，我们基本上采取[2.x.55]模块中的形式（而不是[2.x.56]中的形式）。
* 更令人感兴趣的是界面项，[1.x.66]基于我们的假设，即界面[2.x.57]与单元格边界相吻合，这实际上可以写成一组面积分。如果我们用抽取式注解[2.x.59]来表示形状函数[2.x.58]的速度、压力和位移分量，那么上述条款就会产生对全局矩阵入口[2.x.60]的如下贡献：[1.x.67]虽然不是很明显，但这个条款有一个小小的复杂化：虽然[2.x.61 ]和[2.x.62]是在界面的实体一侧评估的（它们分别是位移的测试函数和[2.x.63]的法向量，我们需要在界面的流体一侧评估[2.x.64]，因为它们对应于流体施加的应力/力。换句话说，在我们的实现中，我们将需要界面两边的FEFaceValue对象。更糟糕的是，我们可能还必须处理这样一个事实，即一方或另一方可能被细化，使我们需要整合一个面的部分内容。请看下面的实现，看看如何处理这个问题。
* 作为一个额外的复杂因素，由这个术语产生的矩阵条目需要以某种方式加入到矩阵的稀疏模式中。这就是DoFTools命名空间中的各种函数的作用，比如[2.x.65]和[2.x.66]从本质上讲，这些函数所做的是模拟系统矩阵装配过程中发生的情况：每当装配将一个非零条目写入全局矩阵时，DoFTools中的函数就会在稀疏模式中添加一个条目。因此，我们可以这样做：让[2.x.67]将所有由常规的逐个单元积分产生的条目添加到稀疏模式中，然后用手将接口项产生的条目也添加进去。如果你看一下下面程序中界面积分的实现，那么如何做应该是显而易见的，最多只需要100行代码就可以了。
* 但我们是懒人：界面项是沿一个面的两个相邻单元的自由度的耦合，这正是人们在非连续Galerkin方案中要做的事情，函数[2.x.68]就是为此而写。与通常的[2.x.69]相比，这是一个矩阵条目的超集，它还将添加所有计算来自所有面的两边自由度耦合项的条目。不幸的是，对于这个函数的最简单版本，这是一个相当大的超集。例如，考虑以下有两个单元和一个[2.x.70]有限元的网格。
* [1.x.68]
* 这里，由[2.x.71]产生的稀疏模式将只有在单元上耦合的自由度的条目。然而，它不会有稀疏模式条目[2.x.72]。然而，由[2.x.73]生成的稀疏模式会有这些条目：它假定你想为相邻单元的自由度[1.x.69]耦合的线性形式建立一个稀疏模式。这不是我们想要的：我们的界面项只作用于一小部分单元，我们当然不需要两个相邻流体单元或两个相邻固体单元之间的所有额外耦合。此外，我们使用高阶元素的事实意味着我们确实会产生比实际需要多得多的条目：在最粗的网格上，在2D中，44,207个非零条目而不是16,635个[2.x.74]，导致我们后来建立的矩阵中出现大量的零（当然，16,635个是不够的，因为它们不包括界面条目）。这个比例在3D中会更糟糕。
* 所以极度懒惰是有代价的：矩阵中的条目太多。但是我们可以适度偷懒：有一个[2.x.75]的变体，允许我们指定有限元的哪些向量分量与哪些分量相耦合，既可以用单元术语，也可以用面术语。对于处于实体子域中的单元，我们将所有位移相互耦合；对于流体单元，所有速度与所有速度和压力耦合，但压力与自身不耦合。由于没有一个单元同时具有这两组变量，因此没有必要区分这两种单元，我们可以这样写掩码。
* [1.x.70]
* 在这里，我们使用了这样一个事实：无限元素的第一个[2.x.76]分量是速度，然后是压力，最后是[2.x.77]位移。(我们也可以说，速度/压力也与位移耦合，因为没有一个单元同时拥有这两组变量)。另一方面，界面条款需要一个类似于这样的掩码。
* [1.x.71]
* 换句话说，所有位移测试函数（组件[2.x.78]）与界面另一侧的所有速度和压力形状函数耦合。这并不完全正确，尽管很接近：事实上，界面的确切形式仅指那些在共同界面上确实为非零的压力位移形状函数，这对所有形状函数来说并不真实；另一方面，它确实耦合了所有velocities（因为积分涉及速度形状函数的梯度，这些梯度在单元的所有面上都是非零的）。然而，上面构建的掩码网络并不具备这些微妙的能力。尽管如此，通过掩码，我们还是设法将稀疏模式的条目数降到了21,028个&mdash; 目前来说已经足够了。
* 

* 
* [1.x.72][1.x.73] 。
* 

* 第二个困难是，虽然我们知道如何在外部边界上强制执行速度或应力为零（使用[2.x.79]调用适当的分量掩码，并为固体和液体外部边界设置不同的边界指标），但我们现在还需要在内部界面上的速度为零，即[2.x.80] 。在写这篇文章的时候，deal.II中没有处理这部分的函数，但用手实现并不特别困难：基本上，我们只需要在所有单元上循环，如果它是一个流体单元，而它的邻居是一个固体单元，然后添加约束，确保这个面上的速度自由度为零。在处理相邻的实体单元被细化的情况时，需要注意一些问题，产生以下代码。
* [1.x.74]
* 
* 调用[2.x.81]告诉AffineConstraints为自由度[2.x.82]启动一个新的约束，其形式为[2.x.83] 。通常情况下，我们会将单个系数[2.x.84]设置为非零值（使用[2.x.85]或将[2.x.86]设置为非零值（使用[2.x.87]不做任何事情，看起来很有趣，只是将约束设为[2.x.88]，这正是我们在当前情况下需要的。对[2.x.89]的调用保证了我们只将速度分量的边界值设置为零，而不是压力分量。
* 请注意，在有些情况下这可能会产生不正确的结果：特别是，一旦我们找到当前流体单元的一个实体邻接子，我们就会假定共同面上的所有邻接子都在实体子域中。但事实并非如此，例如，考虑以下的网格。
* [1.x.75]
* 
* 在这种情况下，我们会将左单元右面的所有速度自由度设置为零，这对该面的顶部自由度来说是不正确的。也就是说，只有当流体和固体子域不与一组完整的粗网格单元重合时，才会发生这种情况；但这与本介绍第一节末尾的假设相矛盾。
* 

* 
* [1.x.76][1.x.77] 。
* 

* 我们将考虑以下情况作为一个测试案例。
* [2.x.90] 
* 正如本文顶部所讨论的，我们需要在一些地方假设一个单元完全在域的流体或固体部分，此外，一个不活动的单元的所有子单元也属于同一子域。如果粗网格已经将网格划分为固体和流体的粗网格单元，这一点肯定可以得到保证；考虑到上述的几何形状，我们可以通过使用[2.x.91]粗网格来做到这一点，[2.x.92]函数可以方便地提供。
* 底部的固定边界意味着[2.x.93]，我们也为顶部的流动规定了迪里希特条件，这样我们就可以在左边得到内流，在右边得到外流。在左边和右边的边界，没有对流动施加明确的边界条件，产生隐含的无应力条件[2.x.94]。两个领域之间的界面条件已经在上面讨论过。
* 为了简单起见，我们选择材料参数为[2.x.95]。在下面的结果部分，我们还将展示可以从同一程序中获得的三维模拟。界限条件和几何形状的定义几乎与上面的2d情况类似。
* 

* [1.x.78][1.x.79] 。
* 

* 在程序中，我们需要一种方法来确定一个单元格在域的哪一部分。有许多不同的方法可以做到这一点。一个典型的方法是使用每个单元的[2.x.96]"subdomain_id "标签，尽管这个字段在%并行计算中具有特殊意义。另一种方法是[2.x.97]"material_id "字段，也是每个单元格都有的。它有一个额外的优点，即在网格细化时，它可以从另一个单元继承到子单元；换句话说，我们在创建网格时设置一次材料ID，即使经过几次细化循环，它对所有活动单元都是正确的。因此，我们采用这种替代方法：我们定义一个[2.x.98]，用符号名称构成材料id数字，并使用它们来识别单元格在域的哪一部分。
* 其次，我们使用一个在[1.x.80]模式下操作的DoFHandler类型的对象。该类需要知道哪些单元将使用斯托克斯（Stokes）元素，哪些单元将使用弹性无限元素。因此，在每个细化周期的开始，我们必须走过所有的单元，并将（在hp-parlance中）活跃的FE索引设置为适合当前情况的索引。虽然我们可以用符号名来表示材料ID，但实际上主动FE索引是一个数字，经常用于索引对象集合（例如[2.x.99]和[2.x.100]类型），这意味着主动FE索引实际上对于流体部分必须是0，对于领域的弹性部分必须是1。
* 

* [1.x.81][1.x.82] 。
* 

* 这个程序主要是为了说明如何处理领域内不同部分的不同物理现象，以及如何在deal.II中实现这些模型。因此，我们不会费力想出一个好的求解器：我们只使用SparseDirectUMFPACK类，它总是能起作用，即使不是以最佳的复杂度。然而，我们将在[1.x.83]部分对可能的其他求解器进行评论。
* 

* [1.x.84][1.x.85] 。
* 

* 这个程序的一个比较棘手的方面是如何估计误差。因为它几乎适用于任何程序，所以我们想使用KellyErrorEstimator，在这里我们也可以用下面这样的代码相对容易地做到。
* [1.x.86]
* 这为每个单元格提供了两套误差指标。我们将以某种方式将它们合并为一个网格细化，例如使用类似下面的代码（注意，我们将两个向量中的平方误差指标归一化，因为误差量的物理单位在当前情况下并不匹配，导致两个子域之间的误差指标可能有数量级的差异）。
* [1.x.87]
* 在代码中，我们实际上以4:1的比例权衡误差指标，以支持在斯托克斯子域上计算的误差指标，因为细化在其他方面严重偏向于弹性子域，但这只是一个技术问题。因素4已被启发式地确定为相当好的工作。)
* 虽然这个原则是合理的，但它并不完全像预期的那样工作。原因是KellyErrorEstimator类是通过整合每个单元面周围的解的梯度跳跃来计算误差指标。在解不连续且扩展为零的地方，这个跳跃可能非常大；它也不会随着网格的细化而变小。KellyErrorEstimator类不能忽视这个接口，因为它基本上只在[1.x.88]模式下看到一个DoFHandler，其中元素类型从一个单元变为另一个单元&mdash；正是[1.x.89]模式所设计的东西，当前程序中的接口看起来与[2.x.101]中的接口没有什么不同，例如，当然也不逊于合法的。尽管如此，最终的结果是，在两个子域之间的界面两侧都有一层细胞，误差指标大得不合理。因此，大部分的网格细化工作都集中在界面上。
* 如果我们有一个真正理解问题的细化指标，并且在积分跳跃项时简单地忽略子域之间的界面，这种情况显然不会发生。另一方面，这个程序是关于如何表示我们有不同的物理学上无所谓的子域的问题，而不是关于KellyErrorEstimator的特殊性，因此我们求助于称为 "启发法 "的大锤子：我们简单地将界面上的单元的误差指标设置为零。这就切断了误差指标的尖峰。乍一看，我们也会认为这将阻止网格在界面上的细化，但是相邻的单元只能有一个细化级别的差异的要求仍然会导致一个合理的细化网格。
* 虽然这显然是一个次优的解决方案，但它目前是有效的，并为将来的改进留下了空间。
* 

* [1.x.90] [1.x.91].
* [1.x.92] [1.x.93].
 

* 
* 这个程序的包含文件与之前许多其他程序的包含文件是一样的。唯一的新文件是在介绍中讨论的声明FE_Nothing的文件。hp目录下的文件已经在 [2.x.102] 中讨论过了。
* 

* 
*  

* 
* [1.x.94]
* 
* [1.x.95] [1.x.96]。
 

* 
* 这是主类。如果你想的话，它是[2.x.103]和[2.x.104]的组合，因为它的成员变量要么针对全局问题（Triangulation和DoFHandler对象，以及[2.x.105]和各种线性代数对象），要么与弹性或斯托克斯子问题有关。然而，该类的一般结构与其他大多数实现静止问题的程序一样。  
* 有几个不言自明的辅助函数（<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>）（对两个子域的符号名称进行操作，这些符号名称将被用作属于子域的单元的 material_ids。正如介绍中所解释的那样）和几个函数（<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>），这些函数已经从其他函数中分离出来，可以在其他许多教程程序中找到，我们将在实现它们时讨论。  
* 最后一组变量（[2.x.106]）描述了用于两个物理模型的材料属性。
* 

* 
* [1.x.97]
* 
* [1.x.98] [1.x.99]。
 

* 
* 下面这个类如其名。速度的边界值分别为2d的[2.x.107]和3d的[2.x.108]。这个问题的其余边界条件都是同质的，在引言中已经讨论过。右边的强迫项对于流体和固体都是零，所以我们不需要为它设置额外的类。
* 

* 
* [1.x.100]
 
* [1.x.101] [1.x.102].
 

 
* [1.x.103] [1.x.104]。
 

* 
* 现在让我们来看看这个程序的主类的实现。最初的几个函数是构造函数和辅助函数，可以用来确定一个单元格在域的哪个部分。鉴于介绍中对这些主题的讨论，它们的实现是相当明显的。在构造函数中，注意我们必须从斯托克斯和弹性的基本元素中构造[2.x.109]对象；使用[2.x.110]函数在这个集合中为它们分配了0和1的位置，这个顺序我们必须记住并在程序的其余部分中一致使用。
* 

* 
* [1.x.105]
* 
* [1.x.106] [1.x.107] * [1.x.107]。
 

* 
* 下一对函数处理生成网格，并确保所有表示子域的标志是正确的。 [2.x.111] ，正如在介绍中所讨论的，生成一个[2.x.112]的网格（或者一个[2.x.113]的三维网格）以确保每个粗略的网格单元完全在一个子域内。生成这个网格后，我们在其边界上循环，并在顶部边界设置边界指标为1，这是我们设置非零迪里希特边界条件的唯一地方。在这之后，我们再次在所有单元上循环，设置材料指标&mdash；用来表示我们处于域的哪一部分，是流体还是固体指标。
* 

* 
* [1.x.108]
 
* 这对函数的第二部分决定了在每个单元上使用哪一个有限元。上面我们已经为每个粗略的网格单元设置了材料指标，正如在介绍中提到的，这个信息在网格细化时可以从母单元继承到子单元。  
*换句话说，只要我们细化（或创建）了网格，我们就可以依靠材料指标来正确描述一个单元所处的域的哪一部分。然后我们利用这一点将单元的活动FE索引设置为该类的[2.x.114]成员变量中的相应元素：流体单元为0，固体单元为1。
* 

* 
* [1.x.109]
 
* [1.x.110] [1.x.111].
 

* 
* 下一步是为线性系统设置数据结构。为此，我们首先要用上面的函数设置活动的FE指数，然后分配自由度，再确定线性系统的约束。后者包括像往常一样的悬挂节点约束，但也包括顶部流体边界的不均匀边界值，以及沿固体子域周边的零边界值。
* 

* 
* [1.x.112]
 
* 不过我们还必须处理更多的约束条件：我们必须确保在流体和固体的界面上速度为零。下面这段代码已经在介绍中介绍过了。
* 

* 
* [1.x.113]
 
* 在这一切结束时，我们可以向约束对象声明，我们现在已经有了所有的约束条件，并且该对象可以重建其内部数据结构以获得更好的效率。
* 

* 
* [1.x.114]
* 
* 在这个函数的其余部分，我们创建了一个在介绍中广泛讨论的稀疏模式，并使用它来初始化矩阵；然后还将向量设置为正确的大小。
* 

* 
* [1.x.115]
* 
* [1.x.116] [1.x.117] * [1.x.117].
 

* 
* 下面是这个程序的中心函数：组装线性系统的函数。它在开始时有一长段设置辅助函数的内容：从创建正交公式到设置FEValues、FEFaceValues和FESubfaceValues对象，这些都是整合单元项以及界面项所必需的，因为在界面上的单元以相同的尺寸或不同的细化程度聚集在一起...
* 

* 
* [1.x.118]
 
* ...描述局部对全局线性系统贡献所需的对象...
 

* 
* [1.x.119]
* 
* ...到变量，允许我们提取形状函数的某些分量并缓存它们的值，而不是在每个正交点重新计算它们。
* 

* 
* [1.x.120]
* 
* 然后是所有单元的主循环，和[2.x.115]一样，为当前单元初始化[2.x.116]对象并提取适合当前单元的FEValues对象。
* 

* 
* [1.x.121]
* 
* 所有这些完成后，我们继续为属于斯托克斯和弹性区域的单元组装单元项。虽然我们原则上可以在一个公式中完成，实际上是实现了介绍中所说的一个双线性形式，但我们意识到，我们的有限元空间是这样选择的：在每个单元上，有一组变量（速度和压力，或者位移）总是为零，因此，计算局部积分的更有效的方法是根据[2.x.117]条款只做必要的部分，以测试我们处于域的哪一部分。        
*局部矩阵的实际计算与[2.x.118]以及[2.x.119]文件模块中给出的弹性方程的计算相同。
* 

* 
* [1.x.122]
* 
* 一旦我们有了单元积分的贡献，我们就把它们复制到全局矩阵中（通过[2.x.120]函数，立即处理约束）。请注意，我们没有把任何东西写进[2.x.121]变量中，尽管我们仍然需要把它传递出去，因为消除非零边界值需要修改局部的，因此也需要修改全局的右手边的值。
* 

* 
* [1.x.123]
* 
* 这个函数更有趣的部分是我们看到的关于沿两个子域之间的界面的脸部条款。为此，我们首先要确保我们只组装一次，即使在所有单元的所有面的循环中会遇到界面的每个部分两次。我们武断地决定，只有当当前单元是固体子域的一部分，并且因此一个面不在边界上，并且它后面的潜在邻居是流体域的一部分时，我们才会评估界面条款。让我们从这些条件开始。
* 

* 
* [1.x.124]
 
* 在这一点上，我们知道当前的单元格是一个候选的整合对象，并且面[2.x.122]后面存在一个邻居。现在有三种可能性。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 邻居处于相同的细化水平，没有子女。
 

* 
* 
* - 邻居有子女。
* 

* 
* 
* - 邻居是比较粗的。                
* 在所有这三种情况下，我们只对它感兴趣，如果它是流体子域的一部分。因此，让我们从第一种最简单的情况开始：如果邻居处于同一层次，没有子女，并且是一个流体单元，那么这两个单元共享一个边界，这个边界是界面的一部分，我们想沿着这个边界整合界面项。我们所要做的就是用当前面和邻接单元的面初始化两个FEFaceValues对象（注意我们是如何找出邻接单元的哪个面与当前单元接壤的），然后把东西传给评估界面项的函数（这个函数的第三个到第五个参数为它提供了抓取数组）。然后，结果再次被复制到全局矩阵中，使用一个知道本地矩阵的行和列的DoF指数来自不同单元的函数。
* 

* 
* [1.x.125]
* 
* 第二种情况是如果邻居有更多的孩子。在这种情况下，我们必须在邻居的所有子节点上进行循环，看它们是否属于流体子域的一部分。如果它们是，那么我们就在共同界面上进行整合，这个界面是邻居的一个面和当前单元的一个子面，要求我们对邻居使用FEFaceValues，对当前单元使用FESubfaceValues。
* 

* 
* [1.x.126]
* 
* 最后一个选项是邻居比较粗大。在这种情况下，我们必须为邻居使用一个FESubfaceValues对象，为当前单元使用一个FEFaceValues；其余的和以前一样。
* 

* 
* [1.x.127]
* 
* 在组装全局系统的函数中，我们将计算接口条款传递给我们在此讨论的一个单独的函数。关键是，尽管我们无法预测FEFaceValues和FESubfaceValues对象的组合，但它们都是从FEFaceValuesBase类派生出来的，因此我们不必在意：该函数只是被调用，其中有两个这样的对象，表示面的两边正交点上的形状函数值。然后我们做我们一直在做的事情：我们用形状函数的值和它们的导数来填充从头数组，然后循环计算矩阵的所有条目来计算局部积分。我们在这里评估的双线性形式的细节在介绍中给出。
* 

* 
* [1.x.128]
* 
* [1.x.129] [1.x.130].
 

* 
* 正如介绍中所讨论的，我们在这里使用了一个相当琐碎的求解器：我们只是将线性系统传递给SparseDirectUMFPACK直接求解器（例如，见[2.x.123]）。我们在求解后唯一要做的就是确保悬挂的节点和边界值约束是正确的。
* 

* 
* [1.x.131]
* 
* [1.x.132] [1.x.133].
 

* 
* 生成图形输出在这里是相当微不足道的：我们所要做的就是确定解向量的哪些分量属于标量和/或向量（例如，见[2.x.124]之前的例子），然后把它全部传递给DataOut类。
* 

* 
* [1.x.134]
* 
* [1.x.135] [1.x.136].
 

* 
* 下一步是细化网格。正如在介绍中所讨论的，这有点棘手，主要是因为流体和固体子域所使用的变量具有不同的物理尺寸，因此误差估计的绝对大小是不能直接比较的。因此，我们将不得不对它们进行缩放。因此，在函数的顶部，我们首先分别计算不同变量的误差估计值（在流体域中使用速度而不是压力，在固体域中使用位移）。
* 

* 
* [1.x.137]
 
* 然后我们通过除以它们的常数对误差估计值进行归一化处理，并按照引言中所讨论的那样，将流体误差指标按4的系数进行缩放。然后将结果加在一起，形成一个包含所有单元的误差指标的向量。
* 

* 
* [1.x.138]
* 
* 在实际细化网格之前，函数的倒数第二部分涉及到我们在介绍中已经提到的启发式方法：由于解是不连续的，KellyErrorEstimator类对位于子域之间边界的单元感到困惑：它认为那里的误差很大，因为梯度的跳跃很大，尽管这完全是预期的，事实上在精确解中也存在这一特征，因此不表明任何数值误差。    
* 因此，我们将界面上的所有单元的误差指标设置为零；决定影响哪些单元的条件略显尴尬，因为我们必须考虑到自适应细化网格的可能性，也就是说，邻近的单元可能比当前的单元更粗，或者事实上可能被细化一些。这些嵌套条件的结构与我们在[2.x.125]中组装界面条款时遇到的情况基本相同。
* 

* 
* [1.x.139]
* 
* [1.x.140] [1.x.141].
 

* 
* 像往常一样，这是控制整个操作流程的函数。如果你读过教程程序[2.x.126]到[2.x.127]，例如，那么你已经对以下结构相当熟悉。
* 

* 
* [1.x.142]
* 
* [1.x.143] [1.x.144]。
 

* 
* 这个，最后的，函数所包含的内容几乎与其他大多数教程程序的内容完全相同。
* 

* 
* [1.x.145]
* [1.x.146][1.x.147][1.x.148] 。
* 

* [1.x.149][1.x.150]。
 

* 
* 当运行该程序时，你应该得到如下的输出。
* [1.x.151]
* 
* 结果很容易直观化。
* [2.x.128] 
* 图形很容易解释：当水流在固体直立部分的左边向下、右边向上时，它产生的压力在左边高，在右边低，这些力量使固体的垂直部分向右弯曲。
* 

*[1.x.152][1.x.153]
* 

* 通过将[2.x.130]中的[2.x.129]类的尺寸改为3，我们也可以运行同样的问题3d。你会得到如下的输出。
* [1.x.154]
* 你会注意到，最大的瓶颈是求解器。SparseDirectUmfpack在2016年的工作站上解决这个问题的最后一次迭代需要将近5个小时和大约80GB的内存（倒数第二次迭代只花了16分钟）。显然，这里需要一个更好的求解器，这个话题将在下面讨论。
* 结果也可以被可视化，并产生良好的图片。这里有一张，显示了速度的矢量图（橙色），实体位移（蓝色），以及实体区域的阴影。
* [2.x.131] 
* 除了缺乏一个好的求解器之外，网格也有点不平衡：网格细化严重偏向于流体子域（在2d中，情况正好相反，促使我们对流体误差指标的权重更高）。显然，如果想继续做更多的三维计算，对两个子域的误差指标的相对重要性进行一些调整是很重要的。
* 

* [1.x.155][1.x.156][1.x.157] 。
* 

* [1.x.158][1.x.159] * [1.x.158][1.x.159]。
 

* 改进程序的一个明显的地方是使用一个更复杂的求解器&mdash；特别是一个能很好地扩展并能解决现实的三维问题的求解器。这在这里应该不难实现，因为从流体到固体是单向耦合的。为此，假设我们对自由度进行了重新排序，首先是所有的速度和压力自由度，然后是所有的位移自由度（用[2.x.132]很容易实现），那么系统矩阵可以分成以下块状形式：[1.x.160] 其中[2.x.133 ]是速度和压力的斯托克斯矩阵（它可以进一步细分为[2.x.134]矩阵，如[2.x.135]，尽管这对目前的目的并不重要），[2.x.136]是位移的弹性方程的结果，而[2.x.137]是来自界面条件的矩阵。现在注意到矩阵[1.x.161]是[2.x.138]的逆值。应用这个矩阵只需要解决[2.x.139]和[2.x.140]，因为[1.x.162]可以被计算为[2.x.141]，然后是[2.x.142]。
* 因此，我们可以预期，如果[2.x.143]，[1.x.163]将是一个好的预处理程序。
* 这意味着，我们只需要为斯托克斯和弹性方程分别提供良好的预处理。这些都是众所周知的：对于斯托克斯，我们可以使用[2.x.144]的结果部分所讨论的预处理程序；对于弹性，一个好的预处理程序将是一个几何或代数多重网格的单一V-循环。然而，还有更多的问题没有解决。对于由两个子预处理器构建的 "优化 "求解器块状三角预处理器来说，经常出现的一点是，在为子预处理器选择参数时，在单独求解两个问题时效果很好的值，在组合成多重物理学预处理器时可能不是最佳值。 特别是，当单独解决固体或流体力学问题时，在收敛所需的迭代次数和每次迭代应用预调节器的成本之间的平衡行为，可能导致人们为斯托克斯问题选择昂贵的预调节器，为弹性问题选择廉价的预调节器（反之亦然）。 然而，当两者结合在一起时，还有一个额外的约束，即你希望这两个子调节器以大致相同的速度收敛，否则便宜的调节器可能会增加全局的迭代次数，而昂贵的调节器则会增加每迭代的成本。例如，虽然单个AMGV循环本身就是一个很好的弹性方法，但当结合到一个多物理问题中时，可能有动力使用一个完整的W循环或多个循环来帮助降低总的求解时间。
* 

* [1.x.164][1.x.165] 。
* 

* 正如介绍中提到的，我们为这个程序使用的细化指标是相当临时的。一个更好的方法是理解解的梯度在界面上的跳跃并不是错误的指示，而是可以预期的，并且在整合跳动值时忽略界面。然而，这并不是KellyErrorEstimator类所做的。另一个更大的问题是，这种估算器首先是否是一个好的策略：例如，如果我们想在位移的一个特定方面（例如实体右上角的位移）有最大的准确性，那么将流体和实体的误差指标扩大到相同的程度是否合适？也许有必要以比固体更高的精度来解决流体问题，因为流体的解决方案会直接影响到固体的解决方案？也许恰恰相反？
* 因此，改进该程序的一个明显的可能性是实施一个更好的细化标准。这方面有一些文献，其中一个可能的起点是Thomas Wick的论文 "Adaptive finite elements for monolithic fluid-structureinteraction on a prolongated domain: 应用于心脏瓣膜模拟"，2011年机械学计算机方法会议论文集（CMM-2011），2011年5月9-12日，波兰华沙。
* 

* [1.x.166][1.x.167] 。
* 

* 上面的结果纯粹是定性的，因为没有证据表明我们的方案实际上是收敛的。因此，一个显而易见的做法是增加一些定量的措施来检查该方案至少收敛到[1.x.168]。例如，我们可以为每个细化周期输出实体的右上角突出到流体子域的部分的挠度。或者我们可以计算出流体对实体施加的净力矢量或扭矩。
* 

*[1.x.169][1.x.170]
* 

* 在现实中，大多数流体结构的相互作用问题都是这样的，即固体的运动确实会影响流体的流动。例如，空气在气膜周围的作用力会导致气膜弯曲并改变其形状。同样地，一面旗帜在风中飘动，完全改变了它的形状。
* 这种双向耦合的问题通常在Arbitrary Lagrangian Eulerian（ALE）框架中处理，其中固体的位移以某种平滑的方式扩展到流体域中，而不是像我们在这里做的那样以零为单位。然后，扩展的位移场被用来使网格变形，我们在上面计算流体流动。此外，界面上流体的边界条件不再是速度为零；相反，在一个随时间变化的程序中，流体速度必须等于沿界面位移的时间导数。
* 

* [1.x.171][1.x.172] [2.x.145]。
* [0.x.1]

