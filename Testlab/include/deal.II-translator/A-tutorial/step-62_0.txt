include/deal.II-translator/A-tutorial/step-62_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.3] 
* [1.x.39] [2.x.4] 
 

 
* [2.x.5] 作为这个程序的先决条件，你需要安装HDF5、复杂的PETSc和p4est库。在[1.x.40]文件中描述了deal.II和这些附加库的安装情况。
* [1.x.41][1.x.42] 。
* 声子晶体是一种周期性的纳米结构，它可以改变机械振动或[声子]的运动(https://en.wikipedia.org/wiki/Phonon)。声子结构可以用来分散、引导和限制机械振动。这些结构在[量子信息](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)方面有潜在的应用，并被用来研究[宏观量子现象](https://science.sciencemag.org/content/358/6360/203)。声子晶体通常在[洁净室]中制造(https://en.wikipedia.org/wiki/Cleanroom)。
* 在本教程中，我们展示了如何设计一个[声子超晶格空腔](https://doi.org/10.1103/PhysRevA.94.033813)，这是一种特殊类型的声子晶体，可以用来限制机械振动。声子超晶格空腔是由两个[分布式布拉格反射器](https://en.wikipedia.org/wiki/Distributed_Bragg_reflector)、镜子和一个[2.x.6]空腔组成，其中[2.x.7]是声学波长。声学DBRs是一种周期性结构，一组具有对比物理特性（声速指数）的双层叠层被重复[2.x.8 ] 次。超晶格空腔通常通过[分子束外延](https://en.wikipedia.org/wiki/Molecular-beam_epitaxy)在[砷化镓](https://en.wikipedia.org/wiki/Gallium_arsenide)晶片上生长。双层对应于GaAs/AlAs镜像对。如下图所示，镜像层（褐色和绿色）的厚度为[2.x.9]，空腔（蓝色）的厚度为[2.x.10] 。
* [2.x.11] 
* 在本教程中，我们计算了一个声子超晶格空腔的[带隙](https://en.wikipedia.org/wiki/Band_gap)和机械共振，但是这里介绍的代码可以很容易地用于设计和计算其他类型的[声子晶体](https://science.sciencemag.org/content/358/6360/203)。
* 本教程的模拟是在二维中完成的，但代码与尺寸无关，可以很容易地用于三维模拟。波导宽度等于域的[2.x.12]维，波导长度等于域的[2.x.13]维。
* 
*-单模。在这种情况下，结构的宽度要比波长小得多。 这种情况可以用有限元法（我们在此采取的方法）或用简单的半分析法[一维转移矩阵形式]（https://en.wikipedia.org/wiki/Transfer_matrix）来解决。
* 
* - 多模。在这种情况下，结构的宽度比波长大。 这种情况可以用有限元法或[散射矩阵形式主义](https://doi.org/10.1103/PhysRevA.94.033813)来解决。 虽然我们在本教程中没有研究这种情况，但通过增加波导宽度参数（jupyter笔记本中的`dimension_y'），很容易达到多模制度。
* 本教程的模拟是在频域中进行的。为了计算传输光谱，我们使用了一个[程序](https://meep.readthedocs.io/en/latest/Python_Tutorials/Resonant_Modes_and_Transmission_in_a_Waveguide_Cavity/)，这在时域[FDTD](https://en.wikipedia.org/wiki/Finite-difference_time-domain_method)模拟中是常用的。在结构的左侧产生一个特定频率的脉冲，在结构的右侧测量传输的能量。首先，我们用声子结构运行模拟，并测量传输的能量。
* [2.x.14] 
* 然后，我们运行没有声子结构的模拟，并测量传输的能量。我们使用没有结构的模拟来进行校准。
* [2.x.15] 
* 传输系数相当于第一个模拟的能量除以校准能量。我们对每个频率步骤重复这个程序。
* 

* [1.x.43][1.x.44] 。
* 我们在这里要模拟的是弹性波的传输。因此，问题的正确描述使用了弹性方程，在时域中由[1.x.45]给出，其中刚度张量[2.x.16]取决于空间坐标，应变是位移的对称梯度，由[1.x.46]给出。
* [完全匹配层（PML）](https://en.wikipedia.org/wiki/Perfectly_matched_layer)可用于在边界处截断解决方案。PML是一种导致复杂坐标拉伸的变换。
* 本教程程序没有采用时域方法，而是通过对时间变量进行傅里叶变换，将上述方程转换为频域。然后，频域中的弹性方程如下[1.x.47] 。
*其中系数[2.x.17]说明了吸收情况。在三维中有3个[2.x.18]系数，在二维中有2个。[2.x.19]的虚部在PML外等于零。PML只对精确的波方程无反射。当方程组被离散化时，PML不再无反射。只要hemedium缓慢变化，反射可以变得任意小，见[绝热定理] (https://doi.org/10.1103/PhysRevE.66) .066608）。在代码中使用了PML的二次开启。线性和三次开启也[已知可行](https://doi.org/10.1364/OE.16.011376)。这些方程可以扩展为[1.x.48][1.x.49]，其中对重复指数进行求和（这里是[2.x.20 ]，以及[2.x.21]和[2.x.22])的求和总是隐含的。注意，在应用PML的复数坐标拉伸后，应变不再是对称的。这组方程可以写成[1.x.50]
* 与应变一样，应力张量在PML内也不是对称的（[2.x.23]）。事实上，PML内的场不是物理的。引入张量[2.x.24]和[2.x.25]是有用的。
* 我们可以乘以[2.x.26]，并在域[2.x.27]上进行积分，并通过部分积分。
* 正是这组方程，我们要解决一组频率[2.x.28]，以计算传输系数作为频率的函数。
* 
*[1.x.54][1.x.55]。
* 在本教程中，我们使用python[jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/ [2.x.29] / [2.x.30] .ipynb)来设置参数和运行模拟。首先，我们创建一个HDF5文件，在其中存储参数和模拟的结果。
* 每个模拟（位移和校准）都存储在一个单独的HDF5组中。
* [1.x.56]
* 
* 

* [1.x.57] [1.x.58]
* [1.x.59] [1.x.60]。
 

* 
* 我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了，特别是在 [2.x.31] 中。
* 

* 
* [1.x.61]
 
* 下面的头文件提供了我们用来表示材料属性的张量类。
* 

* 
* [1.x.62]
* 
* 以下标头对于deal.II的HDF5接口是必要的。
* 

* 
* [1.x.63]
* 
* 这个头是我们用来评估模拟结果的函数[2.x.32]所需要的。
* 

* 
* [1.x.64]
* 
* 我们在函数[2.x.33]中使用的函数[2.x.34]需要这些头文件。
 

* 
* [1.x.65]
* 
* [1.x.66] [1.x.67] 以下类用于存储模拟的参数。
* 

* 
* [1.x.68] [1.x.69] 该类用于定义结构左侧的力脉冲。
* 

* 
* [1.x.70]
* 
* 变量`data`是[2.x.35]，所有的模拟结果都将被储存在其中。注意，变量[2.x.36][2.x.37][2.x.38]和[2.x.39]指向HDF5文件的同一组。当[2.x.40]被复制时，它将指向HDF5文件的同一组。
* 

* 
* [1.x.71]
* 
* 仿真参数作为HDF5属性存储在`data`中。以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
* 

* 
* [1.x.72]
* 
* 在这个特定的模拟中，力只有一个[2.x.41]分量，[2.x.42] 。
* 

* 
* [1.x.73]
* 
* [1.x.74] [1.x.75] 该类用于定义完美匹配层（PML）的形状，以吸收向边界移动的波。
* 

* 
* [1.x.76]
 
* [2.x.43] 所有的模拟结果将被储存在其中。
* 

* 
* [1.x.77]
* 
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
* 

* 
* [1.x.78]
 
* [1.x.79] [1.x.80] 这个类是用来定义质量密度的。
* 

* 
* [1.x.81]
* 
* [2.x.44] 所有的模拟结果将被储存在其中。
* 

* 
* [1.x.82]
* 
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
* 

* 
* [1.x.83]
* 
* [1.x.84] [1.x.85] 这个类包含所有将在模拟中使用的参数。
* 

* 
* [1.x.86]
* 
* [2.x.45] 所有的模拟结果将被储存在其中。
* 

* 
* [1.x.87]
* 
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
* 

* 
* [1.x.88]
* 
* [1.x.89] [1.x.90] 质量和刚度矩阵的计算非常昂贵。这些矩阵对所有的频率步骤都是一样的。右手边的向量对于所有的频率步骤也是一样的。我们用这个类来存储这些对象，并在每个频率步骤中重新使用它们。请注意，这里我们不存储集合的质量和刚度矩阵以及右手边，而是存储单个单元的数据。QuadratureCache "类与 "PointHistory "类非常相似，后者已在 [2.x.46] 中使用。
* 

* 
* [1.x.91]
 
* 我们在变量mass_coefficient和stiffness_coefficient中存储质量和刚度矩阵。我们还存储了右手边和JxW值，这些值对所有的频率步骤都是一样的。
* 

* 
* [1.x.92]
* 
* [1.x.93] [1.x.94]
 

* 
* 这个函数返回材料的刚度张量。为了简单起见，我们认为刚度是各向同性和同质的；只有密度 [2.x.47] 取决于位置。正如我们之前在 [2.x.48] 中所表明的，如果刚度是各向同性和均质的，刚度系数 [2.x.49] 可以表示为两个系数 [2.x.50] 和 [2.x.51] 的函数。系数张量简化为 [1.x.95] 。
* 

* 
* [1.x.96]
* 
* [1.x.97] [1.x.98]。
 

* 
* 接下来让我们来声明这个程序的主类。它的结构与[2.x.52]的教程程序非常相似。主要的区别是。
* 

* 
* 
* - 扫过的频率值。
* 

* 
* 
* - 我们将刚度和质量矩阵保存在`quadrature_cache`中，并将其用于每个频率步骤。
* 

* 
* 
* - 我们在HDF5文件中存储每个频率步骤的探头测量的能量。
* 

* 
* [1.x.99]
* 
* 在每个频率步骤之前都要调用这个程序，以便为缓存变量设置一个原始状态。
* 

* 
* [1.x.100]
* 
* 这个函数在频率向量上循环，为每个频率步骤运行模拟。
* 

* 
* [1.x.101]
* 
* 参数存储在这个变量中。
* 

* 
* [1.x.102]
* 
* 我们把每个单元的质量和刚度矩阵储存在这个向量中。
* 

* 
* [1.x.103]
* 
* 这个向量包含我们要模拟的频率范围。
* 

* 
* [1.x.104]
* 
* 这个向量包含了测量探头的点的坐标[2.x.53]。
* 

* 
* [1.x.105]
* 
* HDF5数据集用于存储频率和`探头位置`向量。
* 

* 
* [1.x.106]
* 
* HDF5数据集，存储探头测量的能量值。
* 

* 
* [1.x.107]
* 
* [1.x.108] [1.x.109].
 

* 
* [1.x.110] [1.x.111].
 

* 
* 构造函数使用[2.x.55]函数从[2.x.54]的`data`中读取所有参数。
* 

* 
* [1.x.112]
* 
* 这个函数定义了力矢量脉冲的空间形状，它采用高斯函数的形式

* 
* [1.x.113]
* 其中[2.x.56]是取力的最大振幅，[2.x.57]和[2.x.58]是[2.x.59]和[2.x.60]成分的标准偏差。注意，脉冲已被裁剪为[2.x.61]和[2.x.62] 。
* 

* 
* [1.x.114]
* 
* [1.x.115] [1.x.116] 。
 

* 
* 和以前一样，构造函数使用[2.x.63]函数从[2.x.64]`data`中读取所有参数。正如我们所讨论的，在jupyter笔记本中已经定义了PML的二次开机。通过改变参数`pml_coeff_degree`，可以使用线性、立方或其他幂度。参数`pml_x`和`pml_y`可以用来打开和关闭`x`和`y`PML。
* 

* 
* [1.x.117]
* 
* `x`部分的PML系数的形式为 [2.x.65] 。
 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120]。
 

* 
* 这个类别是用来定义质量密度的。正如我们之前所解释的，一个声学超晶格空腔是由两个[分布式反射器](https://en.wikipedia.org/wiki/Band_gap)、镜子和一个[2.x.66]空腔组成，其中[2.x.67]是声学波长。声学DBRs是一种周期性结构，其中一组具有对比物理特性（声速指数）的双层叠层被重复[2.x.68]次。波速的变化是由具有不同密度的层交替产生的。
* 

* 
* [1.x.121]
 
* 为了提高精度，我们使用了[子像素平滑法](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)。
* 

* 
* [1.x.122]
* 
* 声速由[1.x.123]定义，其中[2.x.69]是有效弹性常数，[2.x.70]是密度。这里我们考虑波导宽度远小于波长的情况。在这种情况下，可以证明对于二维的情况[1.x.124]和三维的情况[2.x.71]等于杨氏模量。[1.x.125]
* 

* 
* [1.x.126]
* 
* 密度[2.x.72]采取以下形式 <img alt="声学超晶格空腔" src="https://www.dealii.org/images/steps/developer/ [2.x.73] .04.svg" height="200" />其中棕色代表材料_a，绿色代表材料_b。
* 

* 
* [1.x.127]
* 
* 这里我们定义了[subpixel smoothing](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)，它提高了模拟的精度。
* 

* 
* [1.x.128]
* 
* 那么腔体
* 

* 
* [1.x.129]
* 
* 材料_a层
* 

* 
* [1.x.130]
* 
* material_b层
* 

* 
* [1.x.131]
* 
* 最后是默认的 material_a。
* 

* 
* [1.x.132]
* 
* [1.x.133] [1.x.134]。
 

* 
* 构造函数使用[2.x.74]函数从[2.x.75]`data`中读取所有参数。
* 

* 
* [1.x.135]
* 
* [1.x.136] [1.x.137].
 

* 
* 我们需要为质量和刚度矩阵以及右手边的矢量保留足够的空间。
* 

* 
* [1.x.138]
* 
* [1.x.139] [1.x.140].
 

 
* [1.x.141] [1.x.142]。
 

* 
* 这与 [2.x.76] 的构造函数非常相似。此外，我们创建了HDF5数据集`frequency_dataset`，`position_dataset`和`displacement`。注意在创建HDF5数据集时使用了`template'关键字。这是C++的要求，使用`template`关键字是为了将`create_dataset`作为一个依赖的模板名称。
* 

* 
* [1.x.143]
* 
* [1.x.144] [1.x.145].
 

* 
* 这个函数没有什么新内容，与[2.x.77]的唯一区别是，我们不需要应用边界条件，因为我们使用PML来截断域。
* 

* 
* [1.x.146]
* 
* [1.x.147] [1.x.148].
 

* 
* 这个函数也与[2.x.78]非常相似，尽管有明显的区别。我们为每个频率/OMEGA步骤组装系统。在第一步，我们设置`calculate_quadrature_data = True'，我们计算质量和刚度矩阵以及右手边的矢量。在随后的步骤中，我们将使用这些数据来加速计算。
* 

* 
* [1.x.149]
* 
* 这里我们存储了右手边的值，rho和PML。
* 

* 
* [1.x.150]
* 
* 我们计算在jupyter笔记本中定义的[2.x.79]和[2.x.80]的刚度张量。注意，与[2.x.81]相反，刚度在整个领域中是恒定的。
* 

* 
* [1.x.151]
* 
* 我们使用与[2.x.82]相同的方法处理矢量值问题。
* 

* 
* [1.x.152]
* 
* 只有当我们要计算质量和刚度矩阵时，我们才必须计算右手边的值，rho和PML。否则我们可以跳过这个计算，这样可以大大减少总的计算时间。
* 

* 
* [1.x.153]
* 
* 我们在 [2.x.83] 中已经做了这个。获得一个指向当前单元本地的正交缓存数据的指针，作为一种防御措施，确保这个指针在全局数组的范围内。
* 

* 
* [1.x.154]
* 
* quadrature_data变量用于存储质量和刚度矩阵、右手边向量和`JxW`的值。
* 

* 
* [1.x.155]
* 
* 下面我们声明力向量和PML的参数 [2.x.84] 和 [2.x.85] 。
* 

* 
* [1.x.156]
* 
* 下面的块只在第一个频率步骤中计算。
* 

* 
* [1.x.157]
* 
* 存储`JxW`的值。
* 

* 
* [1.x.158]
* 
* 将向量转换为张量并计算xi
* 

* 
* [1.x.159]
* 
* 这里我们计算[2.x.86]和[2.x.87]的张量。
* 

* 
* [1.x.160]
* 
* 计算质量矩阵的值。
* 

* 
* [1.x.161]
* 
* 循环计算刚度张量的[2.x.88]指数。
* 

* 
* [1.x.162]
* 
* 这里我们计算出刚度矩阵。注意，由于PML的存在，刚度矩阵不是对称的。我们使用梯度函数（见[文件](https://www.dealii.org/current/doxygen/deal.II/group__vector__valued.html)），它是一个 [2.x.89] 。矩阵[2.x.90]由条目[1.x.163]组成 注意指数[2.x.91]和[2.x.92]的位置以及我们在本教程中使用的符号。 [2.x.93] . 由于刚度张量不是对称的，所以很容易出错。
* 

* 
* [1.x.164]
* 
* 我们把刚度矩阵的值保存在quadrature_data中
* 

* 
* [1.x.165]
* 
* 并在quadrature_data中保存右手边的值。
* 

* 
* [1.x.166]
* 
* 我们再次循环单元的自由度来计算系统矩阵。这些循环真的很快，因为我们已经计算了刚度和质量矩阵，只有[2.x.94]的值发生了变化。
* 

* 
* [1.x.167]
* 
* [1.x.168] [1.x.169].
 

* 
* 这比 [2.x.95] 更加简单。我们使用并行的直接求解器MUMPS，它比迭代求解器需要更少的选项。它的缺点是不能很好地扩展。用迭代求解器来解决Helmholtz方程并不简单。移位拉普拉斯多网格法是一种众所周知的预处理该系统的方法，但这超出了本教程的范围。
* 

* 
* [1.x.170]
* 
* [1.x.171] [1.x.172] * [1.x.172].
 

* 
* 我们用这个函数来计算位置向量的值。
* 

* 
* [1.x.173]
* 
* 由于运算符+和
* 
* -被重载来减去两个点，所以必须做如下操作。`Point_b<dim> + (-Point_a<dim>)`。
* 

* 
* [1.x.174]
* 
* [1.x.175] [1.x.176].
 

* 
* 这个函数在HDF5文件中存储探头测量的能量。
* 

* 
* [1.x.177]
* 
* 我们存储的是[2.x.96]方向的位移；[2.x.97]方向的位移可以忽略不计。
* 

* 
* [1.x.178]
* 
* 向量坐标包含探针的点在HDF5文件中的坐标，这些点位于本地拥有的单元中。向量displacement_data包含这些点的位移值。
* 

* 
* [1.x.179]
* 
* 然后我们可以把探头各点的位移值存储在`displacement_data`中。
* 

* 
* [1.x.180]
* 
* 我们在HDF5文件中写入位移数据。调用[2.x.98]是MPI集体的，这意味着所有的进程都要参与。
* 

* 
* [1.x.181]
 
* 因此，即使进程没有数据要写，它也必须参与集体调用。为此，我们可以使用[2.x.99] 注意，我们必须指定数据类型，在这种情况下是[2.x.100] 。
* 

* 
* [1.x.182]
* 
* 如果输入文件中的变量`save_vtu_files`等于`True`，那么所有的数据将被保存为vtu。写入`vtu`文件的程序已经在 [2.x.101] 中描述。
* 

* 
* [1.x.183]
 
* 在我们不感兴趣的单元格上，将各自的值设置为一个假的值，以确保如果我们的假设有什么错误，我们会通过查看图形输出发现。
 

* 
* [1.x.184]
* 
* [1.x.185] [1.x.186]
* 

* 
* 这个函数写入尚未写入的数据集。
* 

* 
* [1.x.187]
* 
* 向量`frequency`和`position`对所有进程都是一样的。因此任何一个进程都可以写入相应的`数据集'。因为调用[2.x.102]是MPI集体的，其余进程将不得不调用[2.x.103]。
* 

* 
* [1.x.188]
* 
* [1.x.189] [1.x.190] 。
 

* 
* 我们在计算开始时使用这个函数来设置缓存变量的初始值。这个函数已经在 [2.x.104] 中描述过。与 [2.x.105] 的函数没有区别。
* 

* 
* [1.x.191]
* 
* [1.x.192] [1.x.193].
* 

* 
* 为了清楚起见，我们将[2.x.106]的函数`run`分为函数`run`和`frequency_sweep`。在函数`frequency_sweep`中，我们把迭代放在频率向量上。
* 

* 
* [1.x.194]
* 
* 只写一次模拟参数
* 

* 
* [1.x.195]
* 
* 我们计算这个特定步骤的频率和欧米茄值。
* 

* 
* [1.x.196]
* 
* 在第一个频率步骤中，我们计算出质量和刚度矩阵以及右手边。在随后的频率步骤中，我们将使用这些值。这大大改善了计算时间。
* 

* 
* [1.x.197]
* 
* [1.x.198] [1.x.199].
 

* 
* 这个函数与 [2.x.107] 中的函数非常相似。
* 

* 
* [1.x.200]
* 
* [1.x.201] [1.x.202].
* 

* 
* 主函数与 [2.x.108] 中的函数非常相似。
* 

* 
* [1.x.203]
* 
* 每个模拟（位移和校准）都存储在一个单独的HDF5组中。
* 

* 
* [1.x.204]
* 
* 对于这两个组名中的每一个，我们现在创建组并将属性放入这些组中。具体来说，这些是。
* 

* 
* 
* - 波导的尺寸（在[2.x.109]和[2.x.110]方向）。
* 

* 
* 
* - 探头的位置（在[2.x.111]和[2.x.112]方向）。
* 

* 
* 
* - 探针中的点的数量
* 

* 
* 
* - 全局细化水平
* 

* 
* 
* - 腔体谐振频率
* 

* 
* 
* - 镜像对的数量
* 

* 
* 
* - 材料属性
* 

* 
* 
* - 力的参数
 

* 
* 
* - PML参数
 

* 
 
* - 频率参数
 

* 
*  

* 
* [1.x.205]
 
* 位移模拟。参数从位移HDF5组中读取，结果保存在同一HDF5组中。
* 

 
* [1.x.206]
* 
* 校准模拟。参数从校准HDF5组中读取，结果保存在同一HDF5组中。
* 

* 
* [1.x.207]
* [1.x.208][1.x.209]。
* 

* [1.x.210][1.x.211]。
* 

* 在[jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/ [2.x.113] / [2.x.114] .ipynb)中用以下代码分析结果
* [1.x.212]
* 
* 一个声腔的特点是[共振频率](https://en.wikipedia.org/wiki/Resonance)和[品质因数](https://en.wikipedia.org/wiki/Q_factor)。品质因数等于共振器中储存的能量与每周期耗散的能量之间的比率，大约相当于共振频率与[半满宽度（FWHM）](https://en.wikipedia.org/wiki/Full_width_at_half_maximum)之间的比率。FWHM等于振动功率大于共振频率功率一半的带宽。[1.x.213]
*机械共振[2.x.115]振幅的平方作为频率的函数具有高斯形状[1.x.214]，其中[2.x.116]是共振频率，[2.x.117]是耗散率。我们在jupyter笔记本中使用之前的方程式来拟合机械共振。
*鉴于我们为参数选择的值，人们可以通过分析来估计共振频率。事实上，我们在这个程序中得到的结果证实了这一点：声子超晶格空腔在20GHz时表现出机械共振，质量因子为5046。以下图片显示了在共振频率附近的传输振幅和相位与频率的函数关系。
* [2.x.118] [2.x.119]。
* 上述图像表明，周期性结构有其预期的效果：它实际上只让一个非常特殊的频率的波通过，而所有其他的波都被反射。当然，这正是人们建造这类装置的目的。但这并不十分容易。在实践中，实际上只有一个 "带隙"，也就是说，该设备只在一定的频率范围内阻止20GHz以外的其他波。事实上，要想知道这个 "差距 "有多大，我们可以通过输入文件中的适当参数将频率范围扩大到16GHz。然后我们得到以下图像。
* [2.x.120] 
* 这张图表明，在18到22GHz左右的范围内，实际上只有频率为20GHz的波被允许通过，但在这个范围之外，还有很多其他频率的波可以通过设备。
*[1.x.215][1.x.216]
* 

* 我们可以用Paraview或VisIt检查模式剖面。正如我们已经讨论过的，在共振时，所有的机械能都被传输，运动的振幅在腔内被放大了。
* [2.x.121] 
* 另一方面，在共振之外，所有的机械能都被反射了。下图显示了19.75GHz时的轮廓。注意力脉冲和反射波在[2.x.122]位置的干扰。
* [2.x.123] 
* [1.x.217][1.x.218] 。
* 

* 声波超晶格空腔在[量子光学力学](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)中找到了应用。这里我们介绍了二维超晶格空腔的模拟，但这个代码也可以用来模拟 "现实世界 "的三维器件，如[微柱超晶格空腔](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.060101)，它是研究宏观量子现象的有希望的候选器件。微柱超晶格空腔的20GHz模式本质上是一个机械谐波振荡器，与环境隔离得非常好。如果该装置在稀释冰箱中被冷却到20mK，那么该模式将成为一个宏观的量子谐波振荡器。
* 

*[1.x.219][1.x.220]
* 

* 我们可以用python脚本来设置参数，并将其保存在我们将用于模拟的HDF5文件中，而不是在C++文件中设置这些参数。然后deal.II程序将从HDF5文件中读取这些参数。
* [1.x.221]
* 
* 为了读取HDF5参数，我们必须使用[2.x.124]标志。
* [1.x.222]
* 
* 

* [1.x.223][1.x.224] [2.x.125]。
* [0.x.1]

