include/deal.II-translator/A-tutorial/step-18_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37]
*[1.x.38][1.x.39][1.x.40] 。
 

* 
* 本教程程序是我们在[2.x.2]和[2.x.3]中已经开始的弹性问题系列中的另一个。它将其扩展到两个不同的方向：首先，它用拉格朗日网格移动方法解决了大变形的准静态但随时间变化的弹性问题。其次，它展示了一些使用PETSc线性代数的%并行处理来解决此类问题的更多技术。除此之外，我们还展示了如何解决[2.x.4]中两个主要瓶颈中的一个，即我们只从一个进程中生成图形输出，而这在更多的进程和大型问题上的扩展性非常差。另一个瓶颈，即每个处理器都必须持有整个网格和DoFHandler，已在[2.x.5]中解决。最后，我们还展示了一些在以前的程序中没有展示过的各种改进和技术。
* 正如之前在[2.x.6]中所说，只要你安装了PETSc，程序在单机上的运行也是一样的。关于如何让deal.II知道你的系统上安装了PETSc的信息可以在deal.IIREADME文件中找到，该文件在你安装deal.II的[1.x.41]中被链接到，或者在[1.x.42]中被链接。
* 

*[1.x.43][1.x.44]
* 

* [1.x.45][1.x.46] 。
* 

* 一般来说，随时间变化的小弹性变形由弹性波方程[1.x.47]描述，其中[2.x.7]是体的变形，[2.x.8]和[2.x.9]是密度和衰减系数，[2.x.10]是外力。此外，为了得到唯一的解，需要指定初始条件[1.x.48]和Dirichlet（位移）或 Neumann（牵引）边界条件：[1.x.49]
* 在上述公式中，[2.x.11]是位移的对称梯度，也称为[2.x.12] 应变[2.x.13]。 [2.x.14]是一个等级为4的张量，称为[2.x.15]应力-应变张量[2.x.16]（是[1.x.50]的逆值）。 ])，它包含了材料弹性强度的知识；它的对称性属性确保它将秩为2的对称张量(&ldquo;矩阵&rdquo;的维数[2.x.17]，其中[2.x.18]是空间维数)映射到相同秩的对称张量上。我们将在下面更多地评论应变和应力张量的作用。目前，我们只需说，我们将术语[2.x.19]解释为具有成分[2.x.20]的向量，其中对指数[2.x.21]的求和是隐含的。
* 这个方程的准静态极限的动机如下：身体的每个小的扰动，例如边界条件或加强函数的变化，将导致身体配置的相应变化。一般来说，这将是以波的形式从扰动的位置辐射出去。由于阻尼项的存在，这些波将在例如[2.x.22]的时间尺度上被减弱。现在，假设所有外部强制力的变化发生在比[2.x.23]大得多的时间尺度上。在这种情况下，变化的动态性质并不重要：我们可以认为身体总是处于静态平衡状态，即我们可以假定在任何时候身体都满足[1.x.51] 。
* 注意该微分方程不再包含任何时间导数。
* 
* 所有的时间依赖性都是通过边界条件和可能的时变力函数引入的 [2.x.24] 。因此，不配置的变化可以被认为是同时静止的。另一种观点认为，[2.x.25]并不是真正的时间变量，而只是一个支配问题演变的类似时间的参数。
* 虽然这些方程足以描述小的变形，但计算大的变形要复杂一些，一般来说，会导致非线性方程，如[2.x.26]中处理的那些。在下文中，让我们考虑在模拟变形成为[1.x.52]的问题时，我们会使用一些工具。
* [2.x.27] 我们下面要考虑的模型并不是建立在任何数学上合理的基础上：我们将考虑一个模型，其中我们产生一个小的变形，通过这个变形使物体的物理坐标变形，然后再考虑下一个加载步骤作为一个线性问题。这是不一致的，因为线性的假设意味着变形是无限小的，所以在解决下一个线性问题之前，在我们的网格顶点上移动一个有限的量是一个不一致的方法。因此，我们应该注意到，下面讨论的方程在文献中找不到并不奇怪。[1.x.53] 另一方面，我们所考虑的实现技术正是人们在实现[1.x.54]模型时需要用到的，我们将在[2.x.28]中看到。
* 

* 为了回到定义我们的 "人工 "模型，让我们首先引入一个张量的应力变量[2.x.29]，并以应力为条件写出微分方程：[1.x.55] 。
* 注意，这些方程是在一个随时间变化的域[2.x.30]上提出的，边界根据边界上各点的位移[2.x.31]而移动。为了完成这个系统，我们必须指定应力和应变之间的增量关系，如下所示：[1.x.56][1.x.57]其中一个点表示时间导数。应力[2.x.32]和应变[2.x.33]都是等级2的对称张量。
* 

*[1.x.58][1.x.59]。
* 

* 数值上，该系统的求解方法如下：首先，我们使用后向欧拉方案对时间部分进行离散。这导致了在时间步长[2.x.34]的力的离散平衡：[1.x.60]其中[1.x.61]和[2.x.35]是时间步长[2.x.36]的增量位移。此外，我们必须指定初始数据[2.x.37] .这样，如果我们想解决位移增量，我们必须解决以下系统。
* [1.x.62]
* 这组方程的弱形式，像往常一样是无限元公式的基础，其内容如下：找到[2.x.38]，使[1.x.63]。
* [1.x.64]
*利用[2.x.39]，这些方程可以简化为
* [1.x.65]
* 
* 我们注意到，为了简单起见，在程序中我们总是假设没有边界力，即[2.x.40]，并且身体的变形仅由身体力[2.x.41]和规定的边界位移[2.x.42]驱动。还值得注意的是，当通过部分积分时，我们会得到形式为[2.x.43]的条款，但我们用涉及对称梯度的条款[2.x.44]而不是[2.x.45]取代它们。由于[2.x.46]的对称性，这两个项在数学上是等价的，但对称版本避免了可能出现的四舍五入错误，使所得矩阵略显非对称性。
* 时间步长[2.x.47]的系统将在旧域[2.x.48]上求解，其形式完全是一个静止的弹性问题，因此与我们在以前的示例程序中已经实现的类似。因此，除了说我们再次使用最低阶连续有限元之外，我们将不对空间离散化进行评论。
* 然而，也有不同之处。[2.x.49] [2.x.50] 我们必须在每个时间步骤之后移动（更新）网格，以便能够在新的领域上解决下一个时间步骤。
* [2.x.51] 我们需要知道[2.x.52]来计算下一个增量位移，也就是说，我们需要在时间步长结束时计算它，以确保它在下一个时间步长可用。从本质上讲，应力变量是我们了解体的变形历史的窗口。[2.x.53] 这两个操作在程序中的[2.x.54]和[2.x.55]函数中完成。移动网格只是一个技术问题，更新应力则要复杂一些，将在下一节讨论。
* 

* [1.x.66][1.x.67] 。
* 

* 如上所述，在计算时间步长[2.x.57]时，我们需要有应力变量[2.x.56]，我们可以用[1.x.68][1.x.69]来计算，尽管这个方程表面上很简单，但我们需要讨论两个问题。第一个问题是关于我们存储[2.x.58]的方式：即使我们使用最低阶无限元素计算增量更新[2.x.59]，那么它的对称梯度[2.x.60]一般仍然是一个不容易描述的函数。特别是，它不是一个片状常数函数，在一般的网格上（单元不是平行于坐标轴的矩形）或非恒定应力-应变张量[2.x.61]，它甚至不是一个双线性或三线性函数。因此，如何在计算机程序中存储[2.x.62]是一个先验的问题。
*要决定这一点，我们必须看看它在哪里被使用。唯一需要强调的地方是在术语[2.x.63]中。在实践中，我们当然会用数字正交代替这个术语：[1.x.70]其中[2.x.64]是正交权重，[2.x.65]是单元格[2.x.66]上的正交点。这应该表明，我们真正需要的不是应力[2.x.67]本身，而只是所有单元上的正交点的应力值。然而，这是一个更简单的任务：我们只需要提供一个数据结构，能够为所有单元上的每个正交点容纳一个等级为2的对称张量（或者，因为我们是并行计算，所以是目前MPI进程拥有的所有单元的正交点）。在每个时间步骤结束时，我们只需评估[2.x.68]，将其乘以应力-应变张量[2.x.69]，并使用该结果来更新正交点[2.x.71]的应力[2.x.70]。
* 第二个复杂情况在我们上面选择的符号中是不可见的。这是由于我们在域[2.x.73]上计算了[2.x.72]，然后用这个位移增量来更新应力，并移动网格节点，以达到[2.x.74]，在此基础上计算下一个增量。在这种情况下，我们必须确定的是，移动网格不仅涉及到节点的移动，而且还涉及到应力变量的相应变化：更新的应力是一个相对于旧域中材料的坐标系而定义的变量，必须转移到新域中。其原因可以理解为：在局部，增量变形[2.x.75]可以分解为三个部分：线性平移（点附近的位移增量场的常数部分）、线性分量（位移场的梯度部分，其发散为零）和旋转。材料的线性平移并不影响冻结在其上的应力。
* 
* 应力值被简单地沿线平移。扩张或压缩的变化产生相应的应力更新。然而，旋转分量并不一定会引起非零的应力更新（想想，在2d中，例如[2.x.76]的情况，[2.x.77]的情况）。尽管如此，如果材料在某一方向上受到预应力，那么这一方向将随着材料的旋转而旋转。 为此，我们必须定义一个旋转矩阵[2.x.78]，描述每个点由于位移增量而产生的旋转。不难看出，[2.x.79]对[2.x.80]的实际依赖可以通过位移的卷曲，而不是位移本身或其全部梯度（如上所述，增量的常数分量描述平移，其发散描述扩张模式，而卷曲描述旋转模式）。由于[2.x.81]的确切形式很麻烦，我们只在程序代码中说明，并注意到应力变量的正确更新公式是[1.x.71][1.x.72] 。
* 应力更新和旋转都在示例程序的函数[2.x.82]中实现。
* 

* [1.x.73][1.x.74] 。
* 

* 在[2.x.83]中，就运行时间而言，%并行计算的主要瓶颈是只有第一个处理器产生整个领域的输出。由于产生图形输出是昂贵的，当涉及到更多的处理器时，这并不能很好地扩展。我们将在这里解决这个问题。关于程序 "扩展 "的定义，见[2.x.84]"本词汇表条目"）。
* 基本上，我们需要做的是让每个进程为其拥有的单元格子集生成图形输出，将其写入单独的文件，并有办法在同一时间显示某个时间段的所有文件。这样，代码在每个时间步骤的每个进程中产生一个[2.x.85]文件。两个常见的VTK文件查看器ParaView和Viscit都支持一次打开一个以上的[2.x.86]文件。为了简化挑选正确文件的过程，并允许在时间上移动，两者都支持记录文件，以引用给定时间步长的所有文件。不幸的是，记录文件在VisIt和Paraview之间有不同的格式，所以我们写出了两种格式。
* 代码将生成文件[2.x.87]，其中[2.x.88]是时间步数（从1开始），[2.x.89]是进程等级（从0开始）。这些文件包含本地拥有的时间段和进程的单元。文件[2.x.90]是时间段的访问记录[2.x.91]对ParaView也是如此。较新版本的VisIt实际上也可以读取[2.x.92]文件，但输出这两种记录文件也无妨）。最后，[2.x.93]文件是只有ParaView支持的特殊记录，它引用所有的时间步骤。所以在ParaView中，只需要打开solution.pvd，而在VisIt中则需要选择所有的.visit文件组来达到同样的效果。
* 

* [1.x.75][1.x.76] 。
* 

* 在[2.x.94]中，我们使用了一个在每个处理器上简单复制的常规三角形，以及一个相应的DoFHandler。两者都不知道它们是在%并行环境下使用的。
* 
* 他们只是完整地存在于每个处理器上，我们认为这最终会成为一个主要的内存瓶颈。
* 我们在这里没有解决这个问题（我们将在[2.x.95]中解决这个问题），但使情况稍微自动化一些。在[2.x.96]中，我们创建了三角形，然后手动 "分区"，也就是说，我们为每个单元分配了[2.x.97]"子域ID"，表明哪个[2.x.98]"MPI进程 "拥有该单元。在这里，我们使用了一个类[2.x.99]，它至少自动完成了这一部分：每当你创建或改进这样一个三角形时，它都会自动在所有参与的进程之间进行划分（它知道这些进程，因为你必须告诉它在构建三角形时连接这些进程的[2.x.100]"MPI通信器"），否则，[2.x.101]看起来，就所有实际目的而言，就像一个普通的三角形对象。
* 使用这个类的便利性不仅来自于能够避免手动调用[2.x.102]，相反，DoFHandler类现在也知道你想在并行环境中使用它，并且默认情况下自动列举自由度，使进程0拥有的所有DoF先于进程1拥有的所有DoF，等等。换句话说，你也可以避免对[2.x.103]的调用。
* 还有其他好处。例如，因为三角计算知道它生活在一个%的平行宇宙中，它也知道它 "拥有 "某些单元（即那些子域id等于其MPI等级的单元；以前，三角计算只存储这些子域id，但没有办法使它们有意义）。因此，在汇编函数中，当你使用语法循环所有单元时，你无法测试一个单元是否为 "本地所有"（即，由当前进程拥有，见[2.x.104]）。
* [1.x.77]
* 这种知识延伸到建立在这种三角形上的DoFHandler对象，它可以通过[2.x.106]和[2.x.107]等调用来识别哪些自由度是本地拥有的（见[2.x.105]）。 最后，DataOut类也知道如何处理这种三角形，并将简单地跳过在非本地拥有的单元上生成图形输出。
* 当然，正如在[2.x.108]的讨论中多次指出的那样，在每个进程中保留整个三角计算是无法扩展的：大型问题可能根本无法容纳每个进程的内存，即使我们有足够多的进程可以在合理的时间内解决它们。在这种情况下，[2.x.109]不再是合理的计算基础，我们将在[2.x.110]中展示如何使用[2.x.111]类来解决这个问题，即让每个进程只存储三角形的一个[1.x.78]。
* 

* [1.x.79][1.x.80] 。
 

* 程序的整体结构可以从[2.x.112]函数中推断出来，该函数首先在第一个时间步长中调用[2.x.113]，然后在所有后续时间步长中调用[2.x.114]。这些函数之间的区别仅仅在于，在第一个时间步中，我们在一个粗略的网格上启动，对其进行求解，自适应地细化网格，然后在新的网格上以一个干净的状态再次启动。这个过程给了我们一个更好的起始网格，尽管我们当然应该在迭代过程中不断调整网格。
* 
* - 这不是在这个程序中做的，而是在下面评论的。
* 这两个处理时间步长的函数的共同部分是对当前网格进行以下操作的序列。[2.x.115] [2.x.116] [2.x.117] ] 。 这第一个函数也是最有趣的一个。它集合了对应于方程[1.x.81]离散化版本的线性系统。这导致系统矩阵[2.x.118]由每个单元[2.x.119]上的局部贡献组成，其条目为[1.x.82] 在实践中，[2.x.120]是根据公式[1.x.83]用正交点[2.x.121]和权重[2.x.122]的数值正交计算的。我们以前在[2.x.123]和[2.x.124]中建立过这些贡献，但在这两种情况下，我们都是通过使用等级4张量[2.x.125]的组成知识，并考虑应变张量[2.x.126]的单个元素，相当笨拙地做到这一点。这其实并不方便，特别是如果我们想考虑比各向同性的情况更复杂的弹性模型，而[2.x.127]有方便的形式 [2.x.128] 。虽然我们在本程序中实际上没有使用比这更复杂的形式，但我们还是希望以一种容易实现的方式来编写它。因此，很自然地引入代表等级为2（用于应变和应力）和4（用于应力-应变张量[2.x.129]）的对称张量的类。幸运的是，deal.II提供了这些：[2.x.130]类模板提供了等级[2.x.131]（需要是偶数）和维度[2.x.132]的此类张量的完整实现。
* 然后我们需要的是两件事：一种创建应力-应变等级4张量[2.x.133]的方法，以及从给定单元上正交点[2.x.135]的形状函数[2.x.134]的梯度创建一个等级2的对称张量（应变张量）。在这个例子程序的执行顶部，你会发现这样的函数。第一个，[2.x.136] ，接受两个参数，对应于Lam&eacute;常数[2.x.137]和[2.x.138]，并返回对应于这些常数的各向同性的应力应变张量（在程序中，我们将选择对应于钢的常数）；用一个计算各向异性的张量或考虑到晶体对称性等的函数来替换这个函数将是非常简单。第二个，[2.x.139]和指数[2.x.140]和[2.x.141]，并返回对称梯度，即应变，对应于形状函数[2.x.142]，在[2.x.143]对象最后被重新初始化的单元上评估。
* 鉴于此，[2.x.144]的最内部循环以下列优雅的方式计算对矩阵的局部贡献（变量[2.x.145]，对应于张量[2.x.146]，先前已用上述第一个函数的结果初始化）。
* [1.x.84]
* 值得注意的是这段代码的表达能力，并将其与我们在以前的例子中为弹性问题所经历的复杂情况进行比较。公平地说，在写这些以前的例子时，SymmetricTensor类模板还不存在）。为了简单起见，[2.x.147]在这里规定了偶数等级的对称张量之间的（双重求和）乘积。
* 将局部贡献[1.x.85]组装起来。
* 到[1.x.86]的右手边也同样简单（注意，我们在这里不考虑任何边界牵引[2.x.148]）。请记住，我们只需要在单元格的正交点上存储旧的应力。在程序中，我们将提供一个变量[2.x.149]，允许访问每个正交点的应力[2.x.150]。有了这个，右手边的代码看起来就像这样，同样相当优雅。
* [1.x.87]
* 请注意，在乘法[2.x.151]中，我们利用了这样一个事实：对于所选择的有限元，[2.x.153]中只有一个矢量分量（即[2.x.152]）是非零的，因此我们也只需要考虑[2.x.154]的一个分量。
* 这基本上结束了我们在这个函数中提出的新材料。它后来必须处理边界条件以及悬挂节点约束，但这与我们以前在其他程序中已经要做的事情相类似。
* [2.x.155] [2.x.156] ] 。 与前一个不同，这个函数并不真正有趣，因为它做的是以前所有教程程序中的类似函数
* 
* - 使用CG方法求解线性系统，使用不完整的LU分解作为预处理程序（在%并行的情况下，它分别使用每个处理器的块的ILU）。它与 [2.x.157] 几乎没有变化。
* [2.x.158] [2.x.159] [通过[2.x.160] ] 。基于之前计算的位移场[2.x.161]，我们根据[1.x.88]和[1.x.89]更新所有正交点的应力值，包括坐标系的旋转。
* [2.x.162] [2.x.163] ：给定之前计算的解决方案，在这个函数中，我们通过移动每个顶点的位移矢量场来实现网格的变形。
* [2.x.164] [2.x.165] : 这个函数只是根据我们上面所说的输出解决方案，也就是说，每个处理器只对自己的那部分领域进行计算输出。除了解决方案之外，我们还计算每个单元上所有正交点平均的应力的规范。[2.x.166] 
* 有了这个代码的一般结构，我们只需要定义我们要解决的情况。在本程序中，我们选择模拟一个垂直圆柱体的静态变形，其底部边界是固定的，顶部边界以规定的垂直速度被推倒。然而，顶层边界的水平速度却没有被指定。
* 
* 我们可以把这种情况想象成一块油性良好的板从顶部推到圆柱体上，圆柱体顶部边界上的点被允许沿板的表面水平滑动，但被板强迫向下移动。圆柱体的内部和外部边界是自由的，不受任何规定的偏转或牵引的影响。此外，重力作用在身体上。
* 程序文本将揭示更多关于如何实现这种情况，而结果部分将显示这种模拟产生的位移模式。
* 

* [1.x.90] [1.x.91].
* 首先是通常的头文件列表，这些文件已经在以前的例子程序中使用过了。
 

* 
* [1.x.92]
* 
* 这里是头文件中仅有的三个新东西：一个包含文件，其中实现了等级为2和4的对称张量，正如介绍中所介绍的。
* 

* 
* [1.x.93]
 
* 最后是一个头文件，其中包含一些函数，这些函数将帮助我们计算域中特定点的局部坐标系的旋转矩阵。
* 

* 
* [1.x.94]
* 
* 然后这又是简单的C++。
* 

* 
* [1.x.95]
* 
* 最后一步和以前所有的程序一样。
* 

* 
* [1.x.96]
* 
* [1.x.97] [1.x.98]。
 

* 
* 正如在介绍中提到的，我们必须在正交点存储旧的应力，以便在下一个时间步长中计算该点的剩余力。仅仅这一点就不能保证只有一个构件的结构，但在更复杂的应用中，我们还必须在正交点存储更多的信息，如塑性的历史变量等。实质上，我们必须在这里存储所有影响材料当前状态的信息，在塑性中，这是由变形历史变量决定的。  
* 除了能够存储数据之外，我们不会给这个类任何有意义的功能，也就是说，没有构造函数、析构函数或其他成员函数。在这种 "哑巴 "类的情况下，我们通常选择将其声明为[2.x.167]，以表明它们更接近于C语言风格的结构而不是C++风格的类。
* 

* 
* [1.x.99]
* 
* [1.x.100] [1.x.101].
 

* 
* 接下来，我们定义弹性中的应力和应变之间的线性关系。它由一个等级为4的张量给出，通常写成 [2.x.168] 的形式。这个张量将等级2的对称张量映射到等级2的对称张量。对于Lam&eacute; 常数[2.x.169]和[2.x.170]的给定值，实现其创建的函数是直接的。
* 

* 
* [1.x.102]
* 
* 通过这个函数，我们将在下面定义一个主类的静态成员变量，它将在整个程序中作为应力应变张量使用。请注意，在更复杂的程序中，这可能是某个类的成员变量，或者是一个根据其他输入返回应力-应变关系的函数。例如，在损伤理论模型中，Lam&eacute;常数被认为是一个点的先前应力/应变历史的函数。相反，在塑性中，如果材料在某一点达到了屈服应力，应力-应变张量的形式就会被修改，而且可能还取决于其先前的历史。  
* 然而，在本方案中，我们假设材料是完全弹性和线性的，恒定的应力-应变张量对我们目前的目的是足够的。
* 

* 
*  
*  
 

* 
* [1.x.103] [1.x.104]。
 

* 
* 在程序的其他部分之前，这里有几个我们需要的函数作为工具。这些是在内循环中调用的小函数，所以我们把它们标记为 [2.x.171] 。  
* 第一个是通过形成这个形状函数的对称梯度来计算形状函数[2.x.172]的对称应变张量。当我们想形成矩阵时，我们需要这样做，比如说。  
* 我们应该注意到，在以前处理矢量值问题的例子中，我们总是问有限元对象在哪个矢量分量中的形状函数实际上是不为零的，从而避免计算任何我们反正可以证明为零的项。为此，我们使用了[2.x.173]函数来返回形状函数在哪个分量中为零，同时[2.x.174]和[2.x.175]函数只返回形状函数的单个非零分量的值和梯度，如果这是一个矢量值元素。  
* 这是一个优化，如果不是非常关键的时间，我们可以用一个更简单的技术来解决：只要向[2.x.176]询问给定形状函数的给定分量在给定正交点的值或梯度。这就是[2.x.177]调用的作用：返回形状函数[2.x.179]的[2.x.178]分量在正交点[2.x.180]的全部梯度。如果某个形状函数的某个分量总是为零，那么这将简单地总是返回零。  
* 如前所述，使用[2.x.181]而不是[2.x.182]和[2.x.183]的组合可能效率较低，但其实现已针对这种情况进行了优化，应该不会有很大的减慢。我们在这里演示这个技术，因为它是如此的简单和直接。
* 

* 
* [1.x.105]
* 
* 声明一个临时的，用来保存返回值。
* 

* 
* [1.x.106]
* 
* 首先，填充对角线项，这只是矢量值形状函数的方向[2.x.184]分量的导数。
* 

* 
* [1.x.107]
* 
* 然后填充应变张量的其余部分。注意，由于张量是对称的，我们只需要计算一半（这里：右上角）的非对角线元素，[2.x.185]类的实现可以确保至少到外面的对称条目也被填充（实际上，该类当然只存储一份）。在这里，我们选择了张量的右上半部分，但左下半部分也一样好。
* 

* 
* [1.x.108]
* 
* 第二个函数做了非常类似的事情（因此被赋予了同样的名字）：从一个矢量值场的梯度计算对称应变张量。如果你已经有了一个解场，[2.x.186]函数允许你在正交点提取解场的每个分量的梯度。它返回的是一个秩-1张量的矢量：解的每个矢量分量有一个秩-1张量（梯度）。由此，我们必须通过转换数据存储格式和对称化来重建（对称的）应变张量。我们用和上面一样的方法来做，也就是说，我们通过先填充对角线，然后只填充对称张量的一半来避免一些计算（[2.x.187]类确保只写两个对称分量中的一个就足够了）。  
* 不过在这之前，我们要确保输入有我们期望的那种结构：即有[2.x.188]矢量分量，即每个坐标方向有一个位移分量。我们用[2.x.189]宏来测试这一点，如果不满足条件，我们的程序就会被终止。
* 

* 
* [1.x.109]
* 
* 最后，下面我们将需要一个函数来计算由某一点的位移引起的旋转矩阵。当然，事实上，单点的位移只有一个方向和一个大小，正是方向和大小的变化引起了旋转。实际上，旋转矩阵可以从位移的梯度计算出来，或者更具体地说，从卷曲计算出来。  
* 确定旋转矩阵的公式有点笨拙，特别是在三维中。对于2D来说，有一个更简单的方法，所以我们实现了这个函数两次，一次用于2D，一次用于3D，这样我们就可以在两个空间维度上编译和使用这个程序，如果需要的话
* 
* 毕竟，deal.II是所有关于独立维度的编程和重用算法的，在2D的廉价计算中进行了彻底的测试，在3D的更昂贵的计算中进行了测试。这里有一个例子，我们必须为2D和3D实现不同的算法，但可以用独立于空间维度的方式来编写程序的其余部分。  
* 因此，不再赘述2D的实现。
* 

* 
* [1.x.110]
* 
* 首先，根据梯度计算速度场的卷曲。注意，我们是在2d中，所以旋转是一个标量。
* 

* 
* [1.x.111]
* 
* 由此，计算出旋转的角度。
* 

* 
* [1.x.112]
* 
* 并由此建立反对称的旋转矩阵。我们希望这个旋转矩阵能够代表本地坐标系相对于全局直角坐标系的旋转，因此我们用一个负的角度来构建它。因此，旋转矩阵代表了从本地坐标系移动到全局坐标系所需的旋转。
* 

* 
* [1.x.113]
* 
* 三维的情况就比较复杂了。
* 

* 
* [1.x.114]
* 
* 同样首先计算速度场的卷曲。这一次，它是一个实向量。
* 

* 
* [1.x.115]
* 
* 从这个向量中，利用它的大小，计算出旋转角度的正切值，并从它中计算出相对于笛卡尔基础的实际旋转角度。
* 

* 
* [1.x.116]
* 
* 现在，这里有一个问题：如果旋转角度太小，这意味着没有旋转发生（例如平移运动）。在这种情况下，旋转矩阵就是身份矩阵。    
* 我们强调这一点的原因是，在这种情况下，我们有那个[2.x.190]。再往下看，我们在计算旋转轴的时候需要除以这个数字，这样做除法的时候会遇到麻烦。因此，让我们走捷径，如果旋转角度真的很小，就简单地返回同一矩阵。
* 

* 
* [1.x.117]
* 
* 否则就计算出真实的旋转矩阵。为此，我们再次依靠一个预定义的函数来计算本地坐标系的旋转矩阵。
* 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120].
 

* 
* 这是该程序的主类。由于命名空间已经表明了我们要解决的问题，让我们用它的作用来称呼它：它引导着程序的流程，也就是说，它是顶层驱动。  
* 这个类的成员变量基本上和以前一样，即它必须有一个三角形，一个DoF处理程序和相关的对象，如约束、描述线性系统的变量等。现在还有很多成员函数，我们将在下面解释。  
* 然而，该类的外部接口是不变的：它有一个公共的构造函数和析构函数，并且它有一个[2.x.191]函数来启动所有的工作。
* 

* 
* [1.x.121]
 
* 私有接口比[2.x.192]中更加广泛。首先，我们显然需要创建初始网格的函数，设置描述当前网格上的线性系统的变量（即矩阵和向量），然后是实际组装系统的函数，指导每个时间步长中必须解决的问题，一个解决每个时间步长中出现的线性系统的函数（并返回它的迭代次数），最后输出正确网格上的解向量。
* 

* 
* [1.x.122]
* 
* 除了前两个，所有这些函数都在每个时间步中被调用。由于第一个时间步骤有点特殊，我们有单独的函数来描述在一个时间步骤中必须发生的事情：一个用于第一个时间步骤，一个用于所有后续时间步骤。
* 

* 
* [1.x.123]
* 
* 然后我们需要一大堆函数来做各种事情。第一个是细化初始网格：我们从原始状态的粗网格开始，解决这个问题，然后看一下，并相应地细化网格，然后重新开始同样的过程，再次以原始状态。因此，细化初始网格比在两个连续的时间步骤之间细化网格要简单一些，因为它不涉及将数据从旧的三角测量转移到新的三角测量，特别是存储在每个正交点的历史数据。
* 

* 
* [1.x.124]
 
* 在每个时间步骤结束时，我们要根据这个时间步骤计算的增量位移来移动网格顶点。这就是完成这个任务的函数。
* 

* 
* [1.x.125]
* 
* 接下来是两个处理存储在每个正交点的历史变量的函数。第一个函数在第一个时间步长之前被调用，为历史变量设置一个原始状态。它只对属于当前处理器的单元上的正交点起作用。
* 

* 
* [1.x.126]
* 
* 第二个是在每个时间段结束时更新历史变量。
 

* 
* [1.x.127]
* 
* 这是新的共享三角法。
* 

* 
* [1.x.128]
* 
* 这个程序的一个不同之处在于，我们在类声明中声明了正交公式。原因是在所有其他程序中，如果我们在计算矩阵和右手边时使用不同的正交公式，并没有什么坏处，比如说。然而，在目前的情况下，它确实如此：我们在正交点中存储了信息，所以我们必须确保程序的所有部分都同意它们的位置以及每个单元格上有多少个。因此，让我们首先声明整个程序将使用的正交公式......
* 

* 
* [1.x.129]
* 
* ......然后也有一个历史对象的向量，在我们负责的那些单元格上的每个正交点都有一个（也就是说，我们不为其他处理器拥有的单元格上的正交点存储历史数据）。请注意，我们可以像在 [2.x.193] 中那样使用 CellDataStorage 类来代替我们自己存储和管理这些数据。然而，为了演示的目的，在这种情况下，我们手动管理存储。
* 

* 
* [1.x.130]
* 
* 这个对象的访问方式是通过每个单元格、面或边持有的[2.x.194]：它是一个[2.x.195]指针，可以被应用程序用来将任意的数据关联到单元格、面或边上。程序对这些数据的实际操作属于自己的职责范围，库只是为这些指针分配了一些空间，而应用程序可以设置和读取这些对象中的每个指针。
* 

* 
*  
* 进一步说：我们需要要解决的线性系统的对象，即矩阵、右手边的向量和解向量。由于我们预计要解决大问题，我们使用与[2.x.196]中相同的类型，即建立在PETSc库之上的分布式%并行矩阵和向量。方便的是，它们也可以在只在一台机器上运行时使用，在这种情况下，这台机器正好是我们的%并行宇宙中唯一的机器。    
* 然而，与[2.x.197]不同的是，我们不存储解向量。
* 
* - 这里是在每个时间步骤中计算的增量位移
* 
* - 以分布式的方式。也就是说，在计算时它当然必须是一个分布式矢量，但紧接着我们确保每个处理器都有一个完整的副本。原因是我们已经在[2.x.198]中看到，许多函数需要一个完整的副本。虽然得到它并不难，但这需要在网络上进行通信，因此很慢。此外，这些都是重复的相同操作，这当然是不可取的，除非不必总是存储整个向量的收益超过了它。在编写这个程序时，事实证明，我们在很多地方都需要一份完整的解决方案，以至于只在必要时才获得它似乎不值得。相反，我们选择一劳永逸地获得完整的副本，而立即摆脱分散的副本。因此，请注意，[2.x.199]的声明并没有像中间命名空间[2.x.200]所表示的那样表示一个分布式向量。
* 

* 
* [1.x.131]
* 
* 接下来的变量块与问题的时间依赖性有关：它们表示我们要模拟的时间间隔的长度，现在的时间和时间步数，以及现在时间步数的长度。
* 

* 
* [1.x.132]
* 
* 然后是几个与%并行处理有关的变量：首先，一个变量表示我们使用的MPI通信器，然后是两个数字，告诉我们有多少个参与的处理器，以及我们在这个世界上的位置。最后，一个流对象，确保只有一个处理器实际产生输出到控制台。这与 [2.x.201] 中的所有内容相同。
* 

* 
* [1.x.133]
* 
* 我们正在存储本地拥有的和本地相关的指数。
* 

* 
* [1.x.134]
* 
* 最后，我们有一个静态变量，表示应力和应变之间的线性关系。由于它是一个不依赖任何输入的常量对象（至少在这个程序中不依赖），我们把它作为一个静态变量，并将在我们定义这个类的构造函数的同一个地方初始化它。
* 

* 
* [1.x.135]
* 
* [1.x.136] [1.x.137]
 

* 
* 在我们进入这个程序的主要功能之前，我们必须定义哪些力将作用于我们想要研究的变形的体。这些力可以是体力，也可以是边界力。体力通常是由四种基本的物理力类型之一所介导的：重力、强弱相互作用和电磁力。除非人们想考虑亚原子物体（对于这些物体，无论如何准静态变形是不相关的，也是不恰当的描述），否则只需要考虑引力和电磁力。为了简单起见，让我们假设我们的身体有一定的质量密度，但要么是非磁性的，不导电的，要么周围没有明显的电磁场。在这种情况下，身体的力只是[2.x.202]是材料密度，[2.x.203]是一个负Z方向的矢量，大小为9.81米/秒^2。 密度和[2.x.204]都是在函数中定义的，我们把7700 kg/m^3作为密度，这是对钢的通常假设值。  
* 为了更普遍一点，也为了能够在2d中进行计算，我们意识到体力总是一个返回[2.x.205]维矢量的函数。我们假设重力沿着最后一个坐标的负方向作用，即[2.x.206]个坐标。考虑到以前的例子程序中的类似定义，这个函数的其余实现应该大部分是不言自明的。请注意，体力与位置无关；为了避免编译器对未使用的函数参数发出警告，我们因此注释了[2.x.207]函数的第一个参数的名称。
* 

* 
* [1.x.138]
* 
* [1.x.139] [1.x.140].
 

* 
* 除了体外力，运动可以由边界力和强制边界位移引起。后一种情况相当于以这样一种方式选择力，使其诱发某些位移。  
* 对于准静态位移，典型的边界力是对一个体的压力，或对另一个体的切向摩擦。我们在这里选择了一个更简单的情况：我们规定了边界（部分）的某种运动，或者至少是位移矢量的某些分量。我们用另一个矢量值函数来描述这一点，对于边界上的一个给定点，返回规定的位移。  
* 由于我们有一个随时间变化的问题，边界的位移增量等于在时间段内累积的位移。因此，这个类必须知道当前时间和当前时间步长，然后可以将位移增量近似为当前速度乘以当前时间步长。  
* 在本程序中，我们选择一种简单的边界位移形式：我们以恒定的速度向下位移顶部的边界。边界的其余部分要么是固定的（然后用[2.x.208]类型的对象来描述），要么是自由的（Neumann类型，在这种情况下不需要做什么特别的事情）。 然后，利用我们通过之前所有的例子程序获得的知识，描述持续向下运动的类的实现应该是很明显的。
* 

* 
* [1.x.141]
* 
* [1.x.142] [1.x.143] * * [1.x.143].
 

* 
* 现在是主类的实现。首先，我们初始化应力应变张量，我们将其声明为一个静态常量变量。我们选择了适合于钢铁的Lam&eacute;常数。
* 

* 
* [1.x.144]
* 
* [1.x.145] [1.x.146]
 

* 
* 下一步是构造函数和析构函数的定义。这里没有什么意外：我们为解的每个[2.x.209]矢量分量选择线性和连续的有限元，以及每个坐标方向上有2个点的高斯正交公式。解构器应该是很明显的。
* 

* 
* [1.x.147]
* 
* 最后一个公共函数是指导所有工作的函数， [2.x.210] 。它初始化了描述我们目前所处时间位置的变量，然后运行第一个时间步长，然后在所有其他时间步长上循环。请注意，为了简单起见，我们使用一个固定的时间步长，而一个更复杂的程序当然要以某种更合理的方式自适应地选择它。
* 

* 
* [1.x.148]
* 
* [1.x.149] [1.x.150] [1.x.150].
 

* 
* 按照上面声明的顺序，下一个函数是创建粗略网格的函数，我们从这里开始。对于这个例子的程序，我们想计算一个圆柱体在轴向压缩下的变形。因此第一步是生成一个长度为3，内外半径分别为0.8和1的圆柱体的网格。幸运的是，有一个库函数可以生成这样的网格。  
* 第二步，我们必须将边界条件与圆柱体的上下两个面联系起来。我们为边界面选择一个边界指标0，其特征是中点的Z坐标为0（底面），指标1为Z=3（顶面）；最后，我们对圆柱体外壳内部的所有面使用边界指标2，外部使用3。
* 

* 
* [1.x.151]
 
* 一旦所有这些都完成了，我们就可以对网格进行一次全面的细化。
* 

* 
* [1.x.152]
* 
* 作为最后一步，我们需要设置一个干净的数据状态，我们将这些数据存储在所有单元上的正交点中，在目前的处理器上处理。
* 

* 
* [1.x.153]
* 
* [1.x.154] [1.x.155].
 

* 
* 下一个函数是为一个给定的网格设置数据结构。这与[2.x.211]中的方法基本相同：分配自由度，然后对这些自由度进行排序，使每个处理器得到一个连续的块。请注意，每个处理器的细分块是在创建或细化网格的函数中处理的，与之前的例子程序不同（发生这种情况的时间点主要是口味问题；在这里，我们选择在创建网格时进行，因为在[2.x.212]和[2.x.213]函数中，我们希望在还没有调用当前函数的时候输出每个处理器上的单元数量）。
* 

* 
* [1.x.156]
 
* 下一步是设置由于悬挂节点而产生的约束。这在以前已经处理过很多次了。
* 

* 
* [1.x.157]
* 
* 然后我们要设置矩阵。这里我们偏离了 [2.x.214] ，在那里我们只是利用PETSc的能力，只知道矩阵的大小，然后分配那些被写入的非零元素。虽然从正确性的角度来看，这样做很好，但是效率却不高：如果我们不给PETSc提供关于哪些元素被写入的线索，那么当我们第一次设置矩阵中的元素时（即在第一个时间步中），它就会慢得令人难以忍受。后来，当元素被分配后，一切都快多了。在我们所做的实验中，如果我们指示PETSc哪些元素将被使用，哪些不被使用，那么第一个时间步可以加快近两个数量级。    
* 要做到这一点，我们首先要生成我们要处理的矩阵的稀疏模式，并确保浓缩的悬挂节点约束在稀疏模式中增加必要的额外条目。
* 

* 
* [1.x.158]
* 
* 注意，我们在这里使用了已经在[2.x.216]中介绍过的[2.x.215]类，而不是我们在其他所有情况下使用的[2.x.217]类。其原因是，为了使后一个类发挥作用，我们必须给每一行的条目数提供一个初始的上限，这项任务传统上是由[2.x.218]完成。然而，这个函数有一个严重的问题：它必须计算每一行中非零项的数量的上限，而这是一个相当复杂的任务，特别是在3D中。实际上，虽然它在2D中相当准确，但在3D中经常得出太大的数字，在这种情况下，[2.x.219]一开始就分配了太多的内存，经常是几百MB。后来当[2.x.220]被调用时，我们意识到我们不需要那么多的内存，但这时已经太晚了：对于大问题，临时分配太多的内存会导致内存不足的情况。    
* 为了避免这种情况，我们采用了[2.x.221]类，它的速度较慢，但不需要对每行的非零条目数进行任何预先估计。因此，它在任何时候都只分配它所需要的内存，我们甚至可以为大型的三维问题建立它。    
* 值得注意的是，由于[2.x.222]的特殊性，我们构建的稀疏模式是全局性的，即包括所有的自由度，无论它们是属于我们所在的处理器还是另一个处理器（如果这个程序是通过MPI并行运行的%）。当然，这并不是最理想的
* 
* 它限制了我们可以解决的问题的规模，因为在每个处理器上存储整个稀疏模式（即使只是短时间）的规模并不大。然而，在程序中还有几个地方我们是这样做的，例如，我们总是把全局三角测量和DoF处理对象保留在周围，即使我们只在其中的一部分工作。目前，deal.II没有必要的设施来完全分配这些对象（事实上，这项任务在自适应网格中很难实现，因为随着网格的自适应细化，领域的良好平衡细分往往会变得不平衡）。    
* 有了这个数据结构，我们就可以去找PETSc稀疏矩阵，告诉它预先分配所有我们以后要写的条目。
* 

* 
* [1.x.159]
* 
* 在这一点上，不再需要对稀疏模式有任何明确的了解，我们可以让[2.x.223]这个变量离开范围，而不存在任何问题。
* 

* 
* 这个函数的最后一个任务是将右侧向量和求解向量重置为正确的大小；记住，求解向量是一个本地向量，不像右侧向量是一个分布式的%并行向量，因此需要知道MPI通信器，它应该通过这个通信器来传输消息。
* 

* 
* [1.x.160]
* 
* [1.x.161] [1.x.162]
 

* 
* 同样，组装系统矩阵和右手边的结构与之前许多例子程序的结构相同。特别是，它主要等同于[2.x.224]，除了不同的右手边，现在只需要考虑到内部应力。此外，通过使用[2.x.225]类，组装矩阵明显变得更加透明：请注意形成2级和4级对称张量的标量乘积的优雅性。这个实现也更加通用，因为它与我们可能使用或不使用各向同性的弹性张量的事实无关。  
* 汇编程序的第一部分和以往一样。
* 

* 
* [1.x.163]
 
* 如同在 [2.x.226] 中，我们只需要在属于当前处理器的所有单元中进行循环。
* 

* 
* [1.x.164]
* 
* 然后在所有指数i,j和正交点上循环，并从这个单元中组合出系统矩阵的贡献。 注意我们如何从[2.x.227]对象中提取给定正交点的形状函数的对称梯度（应变），以及我们如何优雅地形成三重收缩[2.x.228]；后者需要与[2.x.229]中需要的笨拙计算进行比较，无论是在介绍中还是在程序的相应位置。
* 

* 
* [1.x.165]
 
* 然后也要把本地的右手边贡献集合起来。为此，我们需要访问这个正交点的先验应力值。为了得到它，我们使用这个单元的用户指针，该指针指向全局数组中对应于本单元第一个正交点的正交点数据，然后添加一个与我们现在考虑的正交点的索引相对应的偏移量。
* 

* 
* [1.x.166]
* 
* 此外，我们需要这个单元上的正交点的外体力值。
 

* 
* [1.x.167]
* 
* 然后我们可以在这个单元的所有自由度上进行循环，并计算出对右侧的局部贡献。
* 

* 
* [1.x.168]
* 
* 现在我们有了对线性系统的局部贡献，我们需要将其转移到全局对象中。这与[2.x.230]中的做法完全相同。
* 

* 
* [1.x.169]
* 
* 现在压缩向量和系统矩阵。
* 

* 
* [1.x.170]
* 
* 最后一步是再次修复边界值，就像我们在以前的程序中已经做的那样。一个稍微复杂的问题是，[2.x.231]函数希望有一个与矩阵和右手边兼容的求解向量（即这里是一个分布式%并行向量，而不是我们在这个程序中使用的顺序向量），以便用正确的边界值预设求解向量的条目。我们以临时向量的形式提供这样一个兼容向量，然后将其复制到顺序向量中。
* 

* 
* 我们通过展示边界值的灵活使用来弥补这一复杂性：按照我们创建三角形的方式，有三个不同的边界指标用来描述领域，分别对应于底面和顶面，以及内/外表面。我们希望施加以下类型的边界条件。内外圆柱体表面没有外力，这一事实对应于自然（诺伊曼型）边界条件，我们不需要做任何事情。在底部，我们希望完全没有运动，对应于圆柱体在边界的这一部分被夹住或粘住。然而，在顶部，我们希望有一个规定的垂直向下的运动来压缩圆柱体；此外，我们只想限制垂直运动，而不是水平运动。
* 
*--可以把这种情况看作是一块油性良好的板子坐在圆柱体的顶部，把它向下推：圆柱体的原子被迫向下移动，但它们可以沿着板子自由地滑动。
* 

* 
* 描述的方法如下：对于边界指标为零（底面），我们使用一个二维的零函数，代表在任何坐标方向上没有运动。对于指标1（顶面）的边界，我们使用[2.x.232]类，但我们为[2.x.233]函数指定一个额外的参数，表示它应该适用于哪些矢量分量；这是一个针对每个矢量分量的bools矢量，由于我们只想限制垂直运动，它只有其最后一个分量的设置。
* 

* 
* [1.x.171]
* 
* [1.x.172] [1.x.173]
 

* 
* 下一个函数是控制在一个时间段内所有必须发生的事情。从函数名称来看，事情的顺序应该是相对不言而喻的。
* 

* 
* [1.x.174]
* 
* [1.x.175] [1.x.176] * [1.x.175]。
 

* 
* 再次求解线性系统的工作原理与之前基本相同。唯一的区别是，我们只想保留一份完整的本地解向量，而不是从PETSc的求解程序中得到的分布式解向量。为此，我们为分布式向量声明了一个本地临时变量，并用本地变量的内容对其进行初始化（记得[2.x.234]中调用的[2.x.235]函数预设了该向量中边界节点的值），用它进行求解，并在函数结束时再次将其复制到我们声明为成员变量的完整本地向量中。然后，挂起的节点约束只分布在本地拷贝上，也就是说，在每个处理器上都是独立的。
* 

* 
* [1.x.177]
* 
* [1.x.178] [1.x.179].
 

* 
* 这个函数生成.vtu格式的图形输出，正如介绍中所解释的那样。每个进程将只对其拥有的单元格进行工作，然后将结果写入自己的文件中。此外，处理器0将写入引用所有.vtu文件的记录文件。  
* 这个函数的关键部分是给[2.x.236]类提供一种方法，只对当前进程拥有的单元格进行处理。
* 

* 
*  

* 
* [1.x.180]
* 
* 然后，就像在[2.x.237]中一样，定义求解变量的名称（这里是位移增量）并排队输出求解向量。请注意在下面的开关中，我们如何确保如果空间维度应该不被处理，我们抛出一个异常，说我们还没有实现这种情况（另一个防御性编程的案例）。
* 

* 
* [1.x.181]
* 
* 接下来的事情是，我们想输出一些类似于我们存储在每个单元格中的应力的平均法线。这可能看起来很复杂，因为在目前的处理器上，我们只在那些实际属于目前进程的单元格上存储正交点的应力。换句话说，我们似乎无法计算出所有单元的平均应力。然而，请记住，我们源自[2.x.238]的类只迭代那些实际属于当前处理器的单元，也就是说，我们不需要为所有其他单元计算任何东西，因为这些信息不会被触及。下面的小循环就是这样做的。我们将整个区块包围在一对大括号中，以确保迭代器变量不会在它们被使用的区块结束后仍然意外地可见。
* 

* 
* [1.x.182]
* 
* 在所有的单元格上循环...
* 

* 
* [1.x.183]
* 
* 在这些单元上，将所有正交点的应力加起来...
* 

* 
* [1.x.184]
* 
* ......然后把平均值的规范写到它们的目的地。
* 

* 
* [1.x.185]
* 
* 在我们不感兴趣的单元格上，将向量中各自的值设置为一个假值（规范必须是正值，一个大的负值应该能吸引你的眼球），以确保如果我们的假设有什么错误，即这些元素不会出现在输出文件中，我们会通过观察图形输出发现。
* 

* 
* [1.x.186]
* 
* 最后把这个向量也附在上面，以便进行输出处理。
 

* 
* [1.x.187]
* 
* 作为最后一个数据，如果这是一个并行的工作，让我们也把域划分为与处理器相关的子域。这与[2.x.239]程序中的工作方式完全相同。
* 

* 
* [1.x.188]
* 
* 最后，有了所有这些数据，我们可以指示deal.II对信息进行合并，并产生一些中间数据结构，其中包含所有这些解决方案和其他数据向量。
* 

* 
* [1.x.189]
 
* 让我们调用一个函数，打开必要的输出文件，将我们生成的数据写入其中。该函数从给定的目录名（第一个参数）和文件名基数（第二个参数）自动构建文件名。它通过由时间步数和 "片数 "产生的片断来增加所产生的字符串，"片数 "对应于整个域的一部分，可以由一个或多个子域组成。    
* 该函数还为Paraview写了一个记录文件（后缀为`.pvd`），描述了所有这些输出文件如何组合成这个单一时间步骤的数据。
* 

* 
* [1.x.190]
 
* 记录文件必须只写一次，而不是由每个处理器来写，所以我们在处理器0上做这个。
* 

* 
* [1.x.191]
* 
* 最后，我们写入paraview记录，它引用了所有.pvtu文件和它们各自的时间。注意，变量times_and_names被声明为静态的，所以它将保留以前的时间段的条目。
* 

* 
* [1.x.192]
* 
* [1.x.193] [1.x.194].
 

* 
* 这个和下一个函数分别处理第一个和下一个时间步骤的整体结构。第一个时间步骤的工作量稍大，因为我们要在连续细化的网格上进行多次计算，每次都从一个干净的状态开始。在这些计算的最后，我们每次都计算增量位移，我们使用最后得到的增量位移的结果来计算产生的应力更新并相应地移动网格。在这个新的网格上，我们再输出解决方案和任何我们认为重要的附加数据。  
* 所有这些都是通过生成输出到控制台来穿插进行的，以更新观看屏幕的人对正在发生的事情。如同在[2.x.240]中一样，使用[2.x.241]可以确保只有一个并行进程实际在向控制台写数据，而不需要在每个产生输出的地方明确地编码一个if语句。
* 

* 
* [1.x.195]
* 
* [1.x.196] [1.x.197]
* 

* 
* 后续的时间步骤比较简单，鉴于上面对前一个函数的解释，可能不需要更多的文件。
* 

* 
* [1.x.198]
* 
* [1.x.199] [1.x.200]。
* 

* 
* 当在连续细化的网格上求解第一个时间步骤时，会调用下面的函数。在每次迭代之后，它计算一个细化准则，细化网格，并将每个正交点的历史变量再次设置为干净的状态。
* 

* 
* [1.x.201]
 
* 首先，让每个进程计算其拥有的单元的误差指标。
* 

* 
* [1.x.202]
* 
* 然后建立一个全局向量，我们将每个并行进程的局部指标合并到其中。
* 

* 
* [1.x.203]
* 
* 一旦我们有了这个，就把它复制回所有处理器上的本地副本，并相应地细化网格。
* 

* 
* [1.x.204]
* 
* 最后，在新的网格上再次设置正交点数据，并且只在那些我们已经确定是我们的单元上设置。
* 

* 
* [1.x.205]
 
* [1.x.206] [1.x.207]
* 

* 
* 在每个时间步骤结束时，我们根据这个时间步骤中计算的增量位移来移动网格的节点。为了做到这一点，我们保留一个标志的向量，用于指示每个顶点是否已经被我们移动过，然后在所有单元中循环，移动那些尚未被移动的单元顶点。值得注意的是，我们从某个顶点相邻的单元中移动这个顶点并不重要：因为我们使用连续有限元计算位移，位移场也是连续的，我们可以从每个相邻的单元中计算某个顶点的位移。我们只需要确保每个节点精确地移动一次，这就是为什么我们要保留标志的矢量。  
*在这个函数中，有两个值得注意的地方。首先，我们如何使用[2.x.242]函数获得给定顶点的位移场，该函数返回给定单元的[2.x.243]的索引。在本例中，k-th坐标方向的位移对应于有限元的k-th分量。使用这样的函数有一定的风险，因为它使用了我们在[2.x.244]元素中为这个程序共同采取的元素顺序的知识。如果我们决定增加一个额外的变量，例如用于稳定的压力变量，并且碰巧将其作为元素的第一个变量插入，那么下面的计算将开始产生无意义的结果。此外，这种计算还依赖于其他假设：首先，我们使用的元素确实有与顶点相关的自由度。对于目前的Q1元素来说确实如此，对于所有多项式阶的Qp元素来说也是如此[2.x.245] 。然而，这对于不连续的元素或混合公式的元素来说是不成立的。其次，它还建立在这样的假设上：一个顶点的位移只由与这个顶点相关的自由度的值决定；换句话说，所有对应于其他自由度的形状函数在这个特定的顶点是零。同样，对于目前的元素来说是这样的，但对于目前在deal.II中的所有元素来说并非如此。尽管有风险，我们还是选择使用这种方式，以便提出一种查询与顶点相关的单个自由度的方法。  
* 在这种情况下，指出一种更普遍的方法是很有意义的。对于一般的有限元来说，应该采取正交公式，将正交点放在单元的顶点上。梯形规则的[2.x.246]公式正是这样做的。有了这个正交公式，我们就可以在每个单元中初始化一个[2.x.247]对象，并使用[2.x.248]函数来获得正交点，即单元顶点的解函数值。这些是我们真正需要的唯一数值，也就是说，我们对与这个特定正交公式相关的权重（或[2.x.249]值）完全不感兴趣，这可以作为[2.x.250]构造器的最后一个参数来指定。这个方案中唯一的一点小的不便是，我们必须弄清楚哪个正交点对应于我们目前考虑的顶点，因为它们可能是以相同的顺序排列，也可能不是。  
* 如果有限元在顶点上有支持点（这里的支持点是有的；关于支持点的概念，见[2.x.251]"支持点"），那么这种不便是可以避免的。对于这种情况，可以使用[2.x.252]构建一个自定义的正交规则，然后第一个[2.x.253]正交点将对应于单元格的顶点，其顺序与[2.x.254]一致，考虑到矢量元素的支持点将被重复[2.x.255]次。  
* 关于这个简短的函数，值得解释的另一点是三角形类输出其顶点信息的方式：通过[2.x.256]函数，它公布了三角形中有多少个顶点。并非所有的顶点都是一直在使用的
* 
*--有些是以前被粗化的单元的遗留物，由于deal.II从不改变顶点的编号，一旦它出现，即使编号较低的顶点消失了，它仍然存在。其次，[2.x.257]返回的位置不仅是一个类型为[2.x.258]的只读对象，而且事实上是一个可以写入的引用。这允许相对容易地移动网格的节点，但值得指出的是，使用这一特性的应用程序有责任确保所得到的单元仍然有用，即没有扭曲到单元退化的程度（例如，用负的雅各布系数表示）。请注意，我们在这个函数中没有任何规定来实际确保这一点，我们只是有信心。  
* 在这个冗长的介绍之后，下面是全部20行左右的代码。
* 

* 
* [1.x.208]
* 
* [1.x.209] [1.x.210].
 

* 
* 在我们计算的开始，我们需要设置历史变量的初始值，例如材料中的现有应力，我们将其存储在每个正交点中。如上所述，我们使用每个单元中可用的[2.x.259]来做这个。  
* 为了从更大的角度来看，我们注意到，如果我们的模型中有先前可用的应力（为了这个程序的目的，我们假设这些应力不存在），那么我们就需要将先前存在的应力场插值到正交点上。同样，如果我们要模拟具有硬化/软化的弹塑性材料，那么我们就必须在每个正交点存储额外的历史变量，如累积塑性应变的当前屈服应力。然后，预先存在的硬化或弱化将通过在当前函数中插值这些变量来实现。
* 

* 
* [1.x.211]
* 
* 为了慎重起见，我们将所有单元格的用户指针，无论是否是我们的，都设置为空指针。这样一来，如果我们访问了一个我们不应该访问的单元格的用户指针，一个分段故障将让我们知道这不应该发生。
* 

* 
*  

* 
* [1.x.212]
* 
* 接下来，分配属于这个处理器职责范围内的正交对象。当然，这等于属于这个处理器的单元格的数量乘以我们的正交公式在每个单元格上的正交点的数量。由于`resize()`函数在要求的新大小小于旧大小的情况下，实际上并没有缩小分配的内存量，所以我们采用了一个技巧，首先释放所有的内存，然后再重新分配：我们声明一个空的向量作为临时变量，然后将旧向量的内容和这个临时变量交换。这确保了`正交点历史'现在确实是空的，我们可以让现在保存着以前的向量内容的临时变量超出范围并被销毁。在下一步，我们可以根据需要重新分配尽可能多的元素，矢量默认初始化`PointHistory`对象，这包括将压力变量设置为零。
* 

* 
* [1.x.213]
* 
* 最后再次循环所有单元，并将属于当前处理器的单元的用户指针设置为指向此类对象的向量中与该单元对应的第一个正交点对象。
* 

* 
* [1.x.214]
 
* 最后，为了慎重起见，确保我们对元素的计数是正确的，而且我们已经用完了之前分配的所有对象，并且没有指向任何超出矢量末端的对象。这样的防御性编程策略总是很好的检查，以避免意外的错误，并防止将来对这个函数的修改忘记同时更新一个变量的所有用途。回顾一下，使用[2.x.260]宏的构造在优化模式下被优化掉了，所以不影响优化运行的运行时间。
* 

* 
* [1.x.215]
* 
* [1.x.216] [1.x.217]
 

* 
* 在每个时间步骤结束时，我们应该计算出一个增量位移更新，使材料在其新的配置中能够容纳这个时间步骤中施加的外部体和边界力减去通过预先存在的内部应力施加的力之间的差异。为了在下一个时间步骤中获得预先存在的应力，我们必须用本时间步骤中计算的增量位移引起的应力来更新预先存在的应力。理想情况下，所产生的内应力之和将完全抵消所有的外力。事实上，一个简单的实验可以确保这一点：如果我们选择边界条件和体力与时间无关，那么强迫项（外力和内应力之和）应该正好是零。如果你做了这个实验，你会从每个时间步长的右手边的规范输出中意识到这几乎是事实：它并不完全是零，因为在第一个时间步长中，增量位移和应力的更新是相对于未变形的网格计算的，然后再进行变形。在第二个时间步骤中，我们再次计算位移和应力的更新，但这次是在变形的网格中计算的
* 
* - 在这里，结果的更新非常小，但不完全是零。这可以迭代，在每一次这样的迭代中，残差，即右手边向量的法线，都会减少；如果做这个小实验，就会发现这个残差的法线会随着迭代次数的增加而呈指数级下降，在最初的非常快速的下降之后，每次迭代大约会减少3.5倍（对于我看的一个测试案例，其他测试案例，以及其他未知数的数量会改变这个系数，但不会改变指数级下降的情况）。
* 

* 
* 在某种意义上，这就可以被认为是一个准时序方案，以解决在一个以拉格朗日方式移动的网格上解决大变形弹性的非线性问题。  
* 另一个复杂的问题是，现有的（旧的）应力是在旧的网格上定义的，我们将在更新应力后移动这个网格。如果这个网格的更新涉及到单元的旋转，那么我们也需要旋转更新的应力，因为它是相对于旧单元的坐标系计算的。  
* 因此，我们需要的是：在目前处理器拥有的每个单元上，我们需要从每个正交点存储的数据中提取旧应力，计算应力更新，将两者相加，然后将结果与从目前正交点的增量位移计算的增量旋转一起旋转。下面我们将详细介绍这些步骤。
* 

* 
* [1.x.218]
* 
* 首先，建立一个[2.x.261]对象，通过该对象我们将评估增量位移及其在正交点上的梯度，同时还有一个保存该信息的矢量。
* 

* 
* [1.x.219]
* 
* 然后在所有单元中循环，在属于我们子域的单元中进行工作。
* 

* 
* [1.x.220]
* 
* 接下来，获得一个指向当前单元的正交点历史数据的指针，作为一种防御措施，确保这个指针在全局数组的范围内。
* 

* 
* [1.x.221]
 
* 然后初始化当前单元上的[2.x.262]对象，并提取正交点上的位移梯度，以便以后计算应变。
* 

* 
* [1.x.222]
 
* 然后循环计算这个单元的正交点。
* 

* 
* [1.x.223]
* 
* 在每个正交点上，从梯度中计算出应变增量，并将其乘以应力-应变张量，得到应力更新。然后把这个更新添加到这个点上已经存在的应变上。
* 

* 
* [1.x.224]
* 
* 最后，我们必须对结果进行旋转。为此，我们首先要从增量位移中计算出目前正交点的旋转矩阵。事实上，它可以从梯度中计算出来，而且我们已经有一个函数用于这个目的。
* 

* 
* [1.x.225]
* 
* 请注意，结果，即旋转矩阵，一般来说是一个等级为2的反对称张量，所以我们必须将其作为一个完整的张量来存储。
* 

* 
* 有了这个旋转矩阵，在我们将对称张量[2.x.263]扩展为全张量后，我们可以通过从左和右的收缩来计算旋转的张量。
* 

* 
* [1.x.226]
* 
* 注意，虽然这三个矩阵的乘法结果应该是对称的，但由于浮点舍入，它并不是对称的：我们得到的结果的非对角线元素有1e-16的不对称。当把结果分配给一个[2.x.264]时，该类的构造函数会检查对称性，并意识到它并不完全对称；然后它会引发一个异常。为了避免这种情况，我们明确地对结果进行对称，使其完全对称。
* 

* 
* 所有这些操作的结果会被写回到原来的地方。
* 

* 
* [1.x.227]
* 
* 这就结束了项目特定的命名空间 [2.x.265] 。其余的和往常一样，并且已经在 [2.x.266] 中显示：一个 [2.x.267] 函数初始化和终止PETSc，调用做实际工作的类，并确保我们捕捉所有传播到这一点的异常。
* 

* 
* [1.x.228]
* [1.x.229][1.x.230]。
* 

* 
* 如果使用调试模式，运行该程序需要很长时间；在我的i7桌面上需要大约11分钟。幸运的是，经过优化编译的版本要快得多；在同一台机器上用<tt>make release</tt>命令重新编译后，程序只需要1分半钟，这是更合理的时间。
* 

* 如果运行，程序会打印出以下输出，解释它在所有这些时间里做了什么。
* [1.x.231]
* 换句话说，它在12,000个单元格和大约52,000个未知数上进行计算。不是很多，但对于一个耦合的三维问题来说，足以让计算机忙上一阵子。在一天结束的时候，这是我们的输出结果。
* [1.x.232]
* 
* 

* 如果我们用VisIt或Paraview将这些文件可视化，我们就能看到我们的强制压缩对圆柱体造成的灾难的全貌（图像中的颜色编码了材料中的应力规范）。
 

* [2.x.268] 
* 

* [2.x.269] 
* 

* 可以清楚地看到，当我们不断压缩圆柱体时，它开始在完全受限的底面附近弯曲，并在大约8个时间单位后，以方位对称的方式弯曲。
* 

* 虽然这个结果对于对称的几何形状和载荷来说似乎是合理的，但是还没有确定计算是否完全收敛。为了看看是否如此，我们再次运行程序，在开始时再进行一次全局精简，时间步长减半。这在单机上会花费很长的时间，所以我们使用了一个合适的工作站，在16个处理器上并行运行。现在输出的开头看起来像这样。
* [1.x.233]
* 考虑到我们是在3D中，这是个相当好的未知数的数字。这个程序的输出是每个时间步骤的16个文件。
* [1.x.234]
* 
* 

* 这里首先是我们计算的网格，以及16个处理器的分区。
 

* [2.x.270] 
* 

* 最后，这里是与我们之前展示的更小的连续情况下相同的输出。
* [2.x.271] 
 

* [2.x.272] 
* 

* 和以前一样，我们观察到，在高轴向压缩时，圆柱体开始弯曲，但这一次最终是在自己身上塌陷。与我们第一次运行不同的是，在模拟结束时，变形模式变得不对称（中央凸起向侧面偏转）。该模型显然没有考虑到这一点（我们所有的力和边界偏转都是对称的），但这种效果可能在物理上是正确的：在现实中，身体材料属性的小不均匀性会导致它向一侧弯曲以逃避强制力；在数值模拟中，小的扰动，如数值舍入或迭代求解器对线性系统的不精确求解，也会产生同样的效果。在自适应计算中，另一个典型的不对称来源是每一步只精炼一定数量的单元，这可能导致不对称的网格，即使最初的粗网格是对称的。
* 

* 如果将其与之前的运行相比较，结果在质和量上都有所不同。因此，之前的计算肯定没有收敛，尽管我们不能确定现在的计算结果如何。我们需要一个更精细的计算来找出答案。然而，这一点可能是没有意义的：详细看一下最后一张图片，很明显，不仅我们选择的线性小变形模型是完全不够的，而且对于一个现实的模拟，我们还需要确保身体在变形过程中不相交（如果我们继续压缩圆柱体，我们会观察到一些自我相交）。
* 

*[1.x.235][1.x.236]
* 

* 这个程序并没有真正解决一个在实践中有很多应用的方程：基于纯弹性法则的准静态材料变形几乎是无聊的。然而，该程序可以作为更有趣的实验的起点，这的确是编写该程序的最初动机。这里有一些建议，说明该程序缺少什么，以及它可以向什么方向扩展。
* [1.x.237][1.x.238] 。
* 

* 最明显的扩展是使用一个现实的材料模型来实现大规模的静态变形。这方面的自然选择是塑性，其中应力和应变之间的非线性关系取代了方程[1.x.239]。塑性模型的编程通常相当复杂，因为应力与应变的关系通常是不平滑的。可以认为材料只能承受一个最大的应力（屈服应力），在这之后它就开始&ldquo;流动&rdquo;。这方面的数学描述可以用变量不等式的形式给出，或者可以将其视为在应力约束[1.x.241]下的弹性能量最小化[1.x.240]。这种扩展使得问题在每个时间步长中都是非线性的，所以我们需要在每个时间步长中再进行一次循环。
* 我们不打算进一步讨论这个模型的细节，我们可以参考Simo和Hughes关于&ldquo;计算非弹性&rdquo;的优秀书籍，以全面了解解决塑性模型的计算策略。另外，S.Commend, A.Truty和Th.Zimmermann在一篇文章中对塑性的算法做了简要的描述。Zimmermann; [2.x.273] 。
* 

*[1.x.242][1.x.243] 。
 

* 我们选择的公式，即对位移矢量的所有分量使用分片（双，三）线性元素，并将应力视为依赖于位移的变量，对大多数材料是合适的。然而，对于不可压缩或接近不可压缩的材料，这种所谓的基于位移的公式变得不稳定，并表现出虚假的模式。虽然流体通常不是弹性的（在大多数情况下，应力取决于速度梯度，而不是位移梯度，但也有例外，如电流变流体），但也有一些固体是几乎不可压缩的，如橡胶。另一种情况是，许多塑性模型最终让材料变得不可压缩，尽管这不在本程序的范围之内。
* 不可压缩性的特点是泊松比[1.x.244]，其中[2.x.274]是材料的Lam&eacute;常数。物理约束表明[2.x.275]（条件也是来自数学稳定性考虑）。如果[2.x.276]接近[2.x.277]，那么材料变得不可压缩。在这种情况下，纯粹的基于位移的公式不再适合于解决这类问题，必须采用稳定化技术来获得稳定和准确的解决方案。上面引用的书和论文给出了如何做到这一点的指示，但在这个问题上也有大量的文献资料；在H.-Y. Duan和Q. Lin的论文的参考文献中可以找到对这个主题的概述的一个良好开端。Duan和Q. Lin；[2.x.278] 。
* 

*[1.x.245][1.x.246] 。
* 

* 在目前的形式下，该程序只对初始网格进行多次细化，然后不再进行细化。对于任何一种现实的模拟，我们都希望能将其扩展到每隔几步就对网格进行细化和粗化。事实上，这并不难做到，但是如果你愿意的话，我们可以把它留给将来的教程或者作为一个练习。
* 我们需要克服的主要复杂问题是，我们必须将存储在旧网格单元正交点中的数据转移到新网格中，最好是通过某种投影方案。这方面的一般方法是这样的。
* 
* - 开始时，数据只存在于各个单元的正交点中，而不是作为一个到处定义的有限元场。
* 
* - 所以让我们找到一个[1.x.247]到处定义的有限元场，这样我们以后就可以把它内插到新网格的正交点上。一般来说，要找到一个与正交点中的数值完全匹配的连续有限元场是很困难的，因为这些场的自由度数与正交点的数量不匹配，而且这个全局场的节点值要么是过定的，要么是欠定的。但是找到一个与正交点数值相匹配的不连续场通常不是很困难；例如，如果你有一个QGauss(2)正交公式（即2D中每个单元4个点，3D中8个点），那么就可以使用FE_DGQ(1)类型的有限元，即双/三线性函数，因为这些函数在2D中每个单元有4个自由度，在3D中有8个自由度。
* 
* - 有一些函数可以使这种从单个点到全局场的转换更简单。如果你使用QGauss(2)正交公式，下面这段伪代码应该有帮助。请注意，下面的投影矩阵的乘法需要一个标量分量的向量，也就是说，我们一次只能将一组标量从正交点转换成自由度，反之亦然。所以我们需要分别存储每个应力分量，这需要[2.x.279]个向量。我们将把这组向量存储在一个二维数组中，以便于用读出应力张量的方式来读出分量。 因此，我们将对每个单元的应力分量进行循环，并将这些值存储在全局历史域中。(前缀[2.x.280]表示我们的工作与正交点中定义的历史变量有关。) 
* [1.x.248]
 
* 
* - 现在我们有了一个全局场，我们可以像往常一样使用SolutionTransfer类来细化网格并转移history_field向量。这将把所有的东西从旧的网格内插到新的网格。
* 
* - 在最后一步，我们必须将数据从现在插值的全局场返回到新网格上的正交点。下面的代码将做到这一点。
* [1.x.249]
* 
* 一旦我们并行运行这个程序，情况就会变得有点复杂，因为每个进程只为它在旧网格上拥有的单元存储这些数据。也就是说，如果你在将正交点转移到全局矢量后调用[2.x.281]，使用平行矢量就可以做到。
* 

* [1.x.250][1.x.251]。
* 

* 目前，程序没有试图确保一个单元在时间步数结束时移动其顶点后，仍然具有有效的几何形状（即其雅各布决定因素是正的，并且在任何地方都远离零）。事实上，设置边界值和强迫项的方式并不难，可以很快得到扭曲和倒置的单元。当然，在某些大变形的情况下，这在有限网格的情况下是不可避免的，但在其他情况下，通过适当的网格细化和/或缩小时间步长，这应该是可以避免的。这个程序没有这样做，但是一个更复杂的版本肯定会采用某种启发式方法来定义哪些单元的变形量是可以接受的，哪些是不可以的。
* 

* [1.x.252][1.x.253] [2.x.283]。
* [0.x.1]

