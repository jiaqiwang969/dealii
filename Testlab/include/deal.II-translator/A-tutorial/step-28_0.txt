include/deal.II-translator/A-tutorial/step-28_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39]
* [2.x.2]
* [1.x.40][1.x.41][1.x.42] 。
* [2.x.3]
*

* [1.x.43][1.x.44] [1.x.45] 。
* 在这个例子中，我们打算解决中子传输方程的多组扩散近似。从本质上讲，看待这个问题的方式如下。在核反应堆中，中子以不同的能量飞驰，被吸收或散射，或开始一个新的裂变事件。如果从足够长的长度尺度来看，中子的运动可以被视为一个扩散过程。
* 对这一过程的数学描述将把中子分成几个能级，并考虑每个能级或能量组中的中子通量的平衡方程。散射、吸收和裂变事件将成为描述中子通量的扩散方程中的算子。假设我们有能量组[2.x.4]，按照惯例，我们假设能量最高的中子在1组，能量最低的中子在[2.x.5]组。然后每组的中子通量满足以下方程：[1.x.46] 。
*由适当的边界条件增强。这里，[2.x.6]是组内中子的速度 [2.x.7] 。换句话说，[2.x.8]组中的中子通量的时间变化是由以下过程所支配的。[2.x.9] [2.x.10] 扩散 [2.x.11] 。这里，[2.x.12]是（空间上可变的）扩散系数。[2.x.13] 吸收 [2.x.14] （注意是负号）。系数[2.x.15]被称为[1.x.47]。[2.x.16] 核裂变 [2.x.17] 。  能量的中子[2.x.18]的产生与能量的中子通量[2.x.19]乘以能量的中子[2.x.21]引起裂变事件的概率[2.x.22]乘以每个裂变事件中产生的中子数量乘以该事件中产生的中子具有能量的概率[2.x.23] 。  [2.x.24]被称为[1.x.48]，[2.x.25]被称为[1.x.49]。我们将在程序中把[2.x.26]这个词表示为[1.x.50]。[2.x.27] 能量为[2.x.28]的中子的散射[2.x.29]产生能量为[2.x.30]的中子 。  [2.x.31]被称为[1.x.51]。弹性、群内散射[2.x.32]的情况也存在，但我们将其归入清除截面。[2.x.33]的情况被称为向下散射，因为中子在这样的事件中失去了能量。另一方面，[2.x.34]对应于上散射：中子在散射事件中从其周围原子的热运动中获得能量；因此，上散射仅对动能已经与热动能相同的中子（即在[2.x.35]以下范围）是一个重要过程。[2.x.36] 一个外源 [2.x.37] 。[2.x.38]
* 然而，如果对某些类型的反应堆（例如压水反应堆，PWR）的中子能谱有足够的了解，那么只用两个能组就可以获得满意的结果。
* 在本教程中显示的程序中，我们提供了一个结构，可以根据需要计算任意多的能量组。然而，为了保持适度的计算时间，并避免将数百个系数列入表格，我们只提供上述两组模拟方程的系数，即[2.x.39] 。然而，我们确实考虑了一个现实的情况，即假设系数不是恒定的，而是取决于以相当复杂的方式组装成反应堆燃料组件的材料（见下文）。
*

*[1.x.52][1.x.53]


* 如果我们同时考虑所有的能量组，我们可以把上述方程写成以下的算子形式：[1.x.54] 。
* 其中[2.x.40]分别是沉降、裂变和散射算子。  这里的[2.x.41]包括扩散和清除项。注意，[2.x.42]是对称的，而[2.x.43]和[2.x.44]不是。
* 众所周知，如果算子[2.x.45]的等值为负，该方程就会有稳定的解。这可以通过将方程乘以[2.x.46]并在域上进行积分而很容易看出，从而得出[1.x.55] 。
* 稳定性意味着解决方案不会增长，也就是说，我们希望左手边的值小于零，如果右边运算器的特征值都是负的，就会出现这种情况。由于显而易见的原因，如果核反应堆产生的中子通量呈指数增长，那就不是很理想了，所以特征值分析是核工程师的面包和主食。因此，本程序的重点是考虑特征值问题[1.x.56] 。
* 其中我们要确保所有的特征值都是正的。请注意，[2.x.47]，即扩散算子加上吸收（去除），是正无限的；因此，所有特征值为正的条件意味着我们要确保裂变和组间散射足够弱，不会将光谱转移到负值。
* 在核工程中，人们通常关注的是特征值问题的一个略微不同的形式。为此，我们不只是与[2.x.48]相乘并积分，而是与[2.x.49]相乘。我们得到以下进化方程：[1.x.57] 。
* 如果以下问题的特征值都是负的，那么稳定性就得到了保证：[1.x.58] 。
* 这等同于特征值问题[1.x.59] 。
* 核工程中的典型表述是将其写为[1.x.60] 。
* 直观地说，[2.x.51]类似于每个典型时间尺度的中子的乘法系数，对于反应堆的稳定运行来说，它应该小于或等于1：如果它小于1，链式反应就会停止，而核弹等的特征值[2.x.52]大于1。一个稳定的反应堆应该有[2.x.53] 。
* 对于那些想知道如何在实践中实现这一点，而不在不经意间变得比一稍大而引发核弹的人来说：首先，裂变过程发生在不同的时间尺度上。虽然大多数中子在裂变事件后很快就被释放出来，但少量的中子只有在裂变开始后的10-60秒内，经过几次进一步的衰变才由子核释放出来。因此，如果稍稍超过[2.x.54]，就会有许多秒的时间进行反应，直到裂变中产生的所有中子重新进入裂变循环。然而，核反应堆中吸收中子的控制棒
*
* - 因此减少[2.x.55]。
*
* - 被设计成这样的方式，它们在最多2秒内全部进入反应堆。
* 因此，如果[2.x.56]在一段时间内大于1，正如不断增长的中子通量所表明的那样，人们有10-60秒的时间来调节核反应。调节可以通过持续监测中子通量来实现，必要时通过将吸收中子的控制棒移入或移出反应堆几毫米来增加或减少中子通量。在更大的范围内，冷却反应堆的水含有硼，这是一种良好的中子吸收剂。每隔几个小时，通过添加硼或稀释冷却剂来调整硼的浓度。
* 最后，一些吸收和散射反应具有一定的稳定性；例如，较高的中子通量导致局部温度升高，这降低了水的密度，因此减少了散射体的数量，而这些散射体是在中子开始裂变事件之前将中子从高能量变为低能量所必需的。
* 在这个教程程序中，我们解决上述[2.x.57]-两个能量组的特征值问题，我们正在寻找最大的乘法系数[2.x.58]，它与最小特征值的逆值加1成正比。为了解决特征值问题，我们通常使用[1.x.61]的修改版。该算法看起来像这样。
* [2.x.59] [2.x.60] 用[2.x.63]和[2.x.64]初始化[2.x.61]和[2.x.62]，让[2.x.65] 。
* [2.x.66] 通过[1.x.63]定义所谓的[1.x.62]。

* [2.x.67] 用[1.x.64]求解所有群通量[2.x.68] 。
*
* [2.x.69] 更新[1.x.65]。

* [2.x.70] 比较 [2.x.71] 和 [2.x.72] 。  如果变化大于规定的公差，则设置 [2.x.73] 从步骤2开始重复迭代，否则结束迭代。[2.x.74]
* 请注意，在这个方案中，我们在每次迭代中不完全解决群通量，而是考虑以前只计算 [2.x.75] 下散射事件 [2.x.76] 。上散射仅通过使用旧迭代器[2.x.77]来处理，实质上是假设散射操作器是三角形的。这是物理上的原因，因为向上散射在中子散射中并不扮演太重要的角色。此外，实践表明，即使使用这种简化方法，反功率迭代也是稳定的。
* 还需要注意的是，人们可以使用很多外推技术来加速上述的功率迭代。然而，这些都没有在本例中实现。
*

*[1.x.66][1.x.67]


* 人们可能会问，在同一网格上求解各个能量组方程的解是否合适。这个问题可以归结为：[2.x.78]和[2.x.79]是否具有类似的光滑性？如果是这样的话，那么对两者使用相同的网格是合适的；一个非典型的应用可能是化学燃烧，通常所有或大多数化学物种的浓度在火焰前沿快速变化。事实证明，正如在本教程程序的结果部分所显示的图表所显示的那样，这里的情况并非如此：由于不同能量组的扩散系数是不同的，快中子（在小组数[2.x.80]的组别中）有一个非常平滑的网格。] 有一个非常平滑的通量函数，而慢速中子（在有大组数的仓中）受当地材料特性的影响更大，如果系数是粗糙的，就像我们这里计算的情况一样，有一个相应的粗糙的解决方案。因此，我们希望使用不同的网格来计算每个能量组。
* 这有两个影响，我们必须加以考虑。首先，我们需要找到一种方法来单独细化这些网格。第二，为反功率迭代组装源码，我们必须将定义在网格[2.x.82]上的解[2.x.81]与定义在网格[2.x.83]上的形状函数进行整合，这将成为一项更为复杂的任务。
*

*[1.x.68][1.x.69] 。


* 我们使用通常的范式：在一个给定的网格上求解，然后对每个网格的每个单元评估一个误差指标。因为它非常方便，我们再次使用Kelly, Gago, Zienkiewicz和Babuska的后验误差估计器，该估计器通过整合每个单元面的解的梯度跳跃来接近每个单元的误差。使用这个方法，我们可以得到指标[1.x.70] 。
*其中[2.x.84]是用于解决[2.x.85]的三角结构。问题是该如何处理这个问题。首先，很明显，只提炼那些误差指标最高的单元可能会导致不好的结果。为了理解这一点，必须认识到[2.x.86]与[2.x.87]的二阶导数成比例。换句话说，如果我们有两个能量组[2.x.88]，它们的解同样平滑，但其中一个大了一万倍，例如，那么只有该网格的单元会被细化，而小幅度的解的网格会保持粗糙的。这可能不是我们想要的，因为我们可以认为解决方案的两个部分同样重要。
* 从本质上讲，我们必须用一个重要系数[2.x.90]来衡量[2.x.89]，即在任何特定精度下解决[2.x.91]的重要性。这样的重要系数可以用对偶性技术来计算（例如，见[2.x.92]教程程序，以及那里引用的Bangerth和Rannacher的书的参考资料）。然而，我们不会走到这一步，而是简单地假设所有的能量组都同样重要，因此将用解[2.x.95]的最大值对组[2.x.93]的误差指标进行归一化。然后我们细化那些误差满足[1.x.71]的单元。
* 并粗化满足[1.x.72]的单元格。
* 我们在代码中选择[2.x.96]和[2.x.97]。注意，这当然会导致不同能量组的不同网格。
* 上面的策略基本上意味着以下几点。如果对于能量组[2.x.98]来说，有许多单元[2.x.99]的误差很大，例如因为全局的解非常粗糙，那么许多单元将在阈值之上。另一方面，如果有几个单元的误差较大，而许多单元的误差较小，例如，因为除少数地方外，解决方案总体上是比较光滑的，那么，只有少数有较大误差的单元将被细化。因此，该策略可以使网格很好地跟踪相应解的整体光滑性属性。
*

*[1.x.73][1.x.74]


* 如上所述，多组细化策略对不同的解[2.x.100]产生不同的网格。那么问题出在哪里呢？实质上是这样的：在特征值迭代的第三步，我们必须像往常一样通过与定义在网格前能群[2.x.103]上的测试函数[2.x.102]相乘，形成方程的弱形式来计算[2.x.101]；在这个过程中，我们必须计算包含以下形式的条款的右手边向量：[1.x.75]
*其中[2.x.104]是用于特征值方程右侧的系数函数[2.x.105]或[2.x.106]中的一个。现在的困难是[2.x.107]是定义在能量组[2.x.108]的网格上，即它可以扩展为[2.x.109]，基函数[2.x.110]定义在网格[2.x.111]。因此，对右手边的贡献可以写成[1.x.76] 。
* 另一方面，测试函数[2.x.112]被定义在网格[2.x.113]上。这意味着我们不能将积分[2.x.114]分割成网格[2.x.115]或[2.x.116]上的积分，因为其他的基函数可能不在这些单元上定义。
* 这个问题的解决方法在于[2.x.117]和[2.x.118]的网格都是通过自适应细化从一个共同的粗大网格中得到的。因此，我们总是能找到一组满足以下条件的单元，我们用[2.x.119]表示。[2.x.120] [2.x.121] 这些单元的联合覆盖了整个领域，并且[2.x.122] 一个单元[2.x.123] 在两个网格中至少有一个是活动的。[2.x.124]构造这个集合的方法是，取粗网格的每个单元，做以下步骤。(i) 如果该单元在[2.x.125]或[2.x.126]上处于活动状态，则将该单元加入该集合；(ii) 否则，即如果该单元在两个网格上都有子代，则对该单元的每个子代进行步骤(i)。事实上，deal.II有一个函数[2.x.127]可以准确地计算出在两个网格中至少有一个处于活动状态的单元的集合。
* 有了它，我们可以将上述积分写成：[1.x.77] 。
* 在代码中，我们在函数[2.x.128]中计算右手边，其中（除其他外）我们在共同的最精炼的单元集上循环，在每一对这些单元上调用函数[2.x.129]。
* 根据结构，现在有三种情况需要考虑。[2.x.130] [2.x.131] 单元[2.x.132]在两个网格上都是有效的，也就是说，基函数[2.x.133]和[2.x.134]都是在[2.x.135]上定义。[2.x.136] 单元[2.x.137]在网格[2.x.138]上有效，但在[2.x.139]上无效，即[2.x.140]定义在[2.x.141]上，而[2.x.142]定义在[2.x.143]的子网格上。[2.x.144] 单元[2.x.145]在网格[2.x.146]上是有效的，但在[2.x.147]上不是，结论与(ii)中相反。[2.x.148]
* 为了计算上面的右手边，我们需要对这三种情况有不同的代码，如下所示。[2.x.149] [2.x.150] 如果单元[2.x.151]在两个网格上都是活动的，那么我们可以直接评估积分。事实上，我们甚至不必理会基函数[2.x.152]，因为我们所需要的只是[2.x.153]在正交点的值。我们可以使用[2.x.154]函数来完成这个任务。这可以直接在[2.x.155]函数中完成。
* [2.x.156] 如果单元[2.x.157]在网格[2.x.158]上被激活，而不是[2.x.159]，那么基函数[2.x.160]只定义在子单元[2.x.161]上，或者如果单元[2.x.162]在网格[2.x.163]上被精化了一次以上，则定义在这些子单元的子节点上。
* 让我们假设[2.x.164]在网格[2.x.165]上只比在网格[2.x.166]上多精炼一次。利用我们使用嵌入式有限元空间的事实，即一个网格上的每个基函数可以写成下一个细化网格上的基函数的线性组合，我们可以将[2.x.167]对子单元[2.x.168]的限制扩展为定义在该子单元上的基函数（即定义了基函数[2.x.169]的单元上）。  [1.x.78]
* 在这里，以及在下文中，暗示了对出现两次的指数进行求和。矩阵[2.x.170]是将数据从一个单元内插到其[2.x.171]-个子的矩阵。
* 那么我们可以把单元格[2.x.172]对右侧分量[2.x.173]的贡献写成[1.x.79] 。
* 在矩阵符号中，这可以写成[1.x.80] 。
*其中[2.x.174]是单元格[2.x.176]的子[2.x.175]上的加权质量矩阵。
* 接下来的问题是，如果[2.x.178]的子单元[2.x.177]不活跃会怎样。然后，我们必须递归地应用这个过程，即我们必须将基函数[2.x.179]插值到[2.x.181]的子单元[2.x.180]上，然后插值到该单元的子单元[2.x.182]上，插值到该单元的子单元[2.x.183]上，等等，直到我们找到一个活动单元。然后，我们必须将单元格[2.x.184]的所有子代、孙代等的贡献相加，其贡献形式为[1.x.81] 。
*或[1.x.82]。
*等等。我们递归地做这个过程，即如果我们坐在单元格[2.x.185]上，看到它在网格[2.x.186]上有子代，那么我们用一个身份矩阵调用一个函数[2.x.187]；该函数将从左边的参数乘以延长矩阵；如果该单元格还有子代，它将用这个新矩阵调用自己，否则它将执行积分。
* [2.x.188] 最后一种情况是，[2.x.189]在网格[2.x.190]上是有效的，但在网格[2.x.191]上不是。在这种情况下，我们必须用定义在单元格 [2.x.193] 上的基函数来表达基函数 [2.x.192] ，而不是像之前那样用 [2.x.194] 来表达。这当然是以完全相同的方式进行的。如果[2.x.195]的子单元在网格[2.x.196]上是活动的，那么就会导致表达式[1.x.83] 。
* 在矩阵符号中，这个表达式现在读作[1.x.84] 。
* 对于单元格[2.x.197]在网格[2.x.198]上被精炼一次以上的情况，相应地：[1.x.85] 。
*或[1.x.86] 。
*等等。换句话说，这个过程与之前的工作方式完全相同，只是我们必须采取延长矩阵的转置，并需要从另一侧乘以质量矩阵。[2.x.199]
*

*情况(ii)和(iii)的表达式可以理解为将标量积[2.x.200]中的左或右基函数反复内插到子单元上，然后在最后的单元上形成内积（质量矩阵）。为了使这些情况的对称性更加明显，我们可以这样写：对于情况（二），我们有[1.x.87] 。
*而对于情况(iii)，我们得到[1.x.88]。
*
*


*[1.x.89][1.x.90]


* 核反应堆堆芯是由不同类型的组件组成的。一个组件基本上是最小的单元，可以在反应堆中移动，通常是矩形或方形。然而，组件并不是固定的单位，因为它们是由不同的燃料棒、控制棒和仪器元件组成的复杂晶格，通过永久连接在棒上的间隔物来保持彼此之间的位置。
* 显然，组件的排列以及组件内棒的排列会影响反应堆内中子通量的分布（通过查看本程序结果部分中显示的解决方案，这一事实就会很明显）。例如，燃料棒在铀235或钚239的富集度方面彼此不同。另一方面，控制棒具有零裂变，但散射和吸收截面不为零。
* 这整个安排将使描述或空间依赖的材料参数变得非常复杂。它不会变得更简单，但我们将做一个近似：我们将每个圆柱杆和周围的水所居住的体积合并成二次截面的体积，在所谓的 "pin cell "中，用核数据库和中子光谱的知识获得同质化的材料数据。同质化使所有材料数据在具有新鲜燃料的反应堆的求解域上成为片状常数。然后为一个点所在的二次元组合查询空间相关的材料参数，然后为该组合中的二次元钳子查询。
* 在这个教程程序中，我们模拟了一个由[2.x.201]组件组成的反应堆的四分之一。我们使用对称性（诺伊曼）边界条件将问题减少到四分之一的领域，因此只模拟[2.x.202]组的装配。其中两个将是UO[2.x.203]燃料，另外两个是MOX燃料。这些组件中的每一个都由不同成分的[2.x.204]棒组成。因此，我们总共创造了一个[2.x.205]棒的网格。为了使以后的事情更简单，我们通过创建一个[2.x.206]单元的粗大网格来反映这一事实（尽管领域是方形的，我们通常会使用一个单元）。在deal.II中，每个单元都有一个[2.x.207]，可以用来将每个单元与识别该单元体积的材料的特定数字联系起来；我们将使用这个材料ID来识别在这个测试案例中使用的8种不同类型的棒材中的哪一种构成了一个特定的单元。请注意，在网格细化后，单元格的子代会继承材料ID，这样即使在网格细化后也能简单地跟踪材料。
* 在结果部分的图片中可以清楚地看到杆件的排列。材料和两个能量组的截面取自OECD/NEA的基准问题。详细的配置和材料数据在代码中给出。
*

*[1.x.91][1.x.92] 。


* 作为对程序具体工作的粗略概述，这里是基本的布局：从一个对每个能量组都相同的粗略网格开始，我们计算反特征值迭代来计算特定网格集上的[2.x.208]特征值。当特征值的变化低于一定的容忍度时，我们停止这些迭代，然后写出每个能量组的网格和解，供图形程序检查。由于解决方案的网格是不同的，我们必须为每个能量组生成一个单独的输出文件，而不是将所有能量组的解决方案加入同一个文件。
* 在这之后，我们对每个网格的误差指标进行评估，并对每个网格的单元进行独立的细化和粗化。由于特征值迭代是相当昂贵的，我们并不想在新的网格上重新开始；相反，我们使用SolutionTransferclass在网格细化时将前一个网格的解插到下一个网格。一个简单的实验会让你相信，这比我们省略这一步要便宜很多。这样做之后，我们在下一组网格上继续进行特征值迭代。
* 该程序由一个参数文件控制，使用ParameterHandler类。我们将在本教程的结果部分展示一个参数文件。目前，我们只需要说它控制了所使用的有限元的多项式程度，能量组的数量（尽管目前实现的都是2组问题的系数），停止反特征值迭代的容忍度，以及我们要做的细化循环的数量。
*

* [1.x.93] [1.x.94]。
* [1.x.95][1.x.96] [1.x.96]。



* 我们从一堆包含文件开始，这些文件在以前的教程程序中已经解释过了。一个新的是[2.x.209] ：这是第一个使用Timer类的例子程序。Timer同时记录了经过的挂钟时间（即安装在墙上的时钟所测量的时间）和CPU时钟时间（当前进程在CPU上使用的时间）。我们将在下面使用一个Timer来测量每个网格细化周期所需的CPU时间。
*


* [1.x.97]
*
* 我们使用下一个include文件来访问块向量，它为我们提供了一种方便的方式来管理所有能量组的解和右手向量。
*


* [1.x.98]
*
* 这个包含文件是用来将一个网格的解转移到另一个不同的网格。我们在每次网格迭代后初始化解法时使用它。
*


* [1.x.99]
*
* 当在一个网格上定义的函数与在另一个网格上定义的形状函数进行积分时，我们需要一个函数[2.x.210]（在介绍中讨论过），该函数定义在以下头文件中。
*


* [1.x.100]
*
* 我们使用boost中的一个小工具类来保存输出流的状态（见下面的[2.x.211]函数）。
*


* [1.x.101]
*
* 下面是另外两个C++标准头文件，我们用它来定义列表数据类型，以及微调我们生成的输出。
*


* [1.x.102]

* 最后一步和以前的所有程序一样。



* [1.x.103]
*
* [1.x.104] [1.x.105]。


*
* 首先，我们需要定义一个类，为主类提供材料数据（包括扩散系数、清除截面、散射截面、裂变截面和裂变光谱）。   
*构造函数的参数决定了我们为多少个能量组设置了相关的表格。目前，这个程序只包括2个能量组的数据，但更复杂的程序可能也能初始化更多能量组的数据结构，这取决于在参数文件中选择了多少个能量组。   
* 对于每个不同的系数类型，都有一个函数来返回该系数在特定能量组（或能量组的组合，如分布截面[2.x.212]或散射截面[2.x.213]）的值。除了能量组之外，这些系数还取决于燃料或控制棒的类型，正如介绍中所解释的那样。因此，这些函数需要一个额外的参数，[2.x.214] material_id，以确定特定种类的棒。在这个程序中，我们使用[2.x.215]不同种类的棒。   
* 除了散射截面，每个系数都可以表示为一个二维浮点数组中的条目，该数组由能量组编号以及材料ID索引。表类模板是存储此类数据的理想方式。最后，散射系数取决于两个能量组的索引，因此需要存储在一个三维数组中，为此我们再次使用表类，这时第一个模板参数（表示数组的维度）当然需要是三。
*


* [1.x.106]
*
* 该类的构造函数用于初始化所有的材料数据数组。它把能量组的数量作为一个参数（如果这个值不等于2，就会抛出一个错误，因为目前只实现了两个能量组的数据；但是，使用这个参数，这个函数仍然是灵活的，可以扩展到未来）。在开始的成员初始化部分，它也将数组的大小调整为正确的大小。   
* 目前，材料数据被存储为8种不同类型的材料。这一点在将来也可以很容易地被扩展。
*


* [1.x.107]
*
* 接下来是返回给定材料和能量组的系数值的函数。它们所做的就是确保给定的参数在允许的范围内，然后在相应的表格中查找各自的值。
*


* [1.x.108]
*
* 计算裂变分布截面的函数略有不同，因为它将其值计算为另外两个系数的乘积。我们不需要在这里检查参数，因为这在我们调用其他两个相关函数时已经发生了，尽管这可能也无妨。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 第一个有趣的类是包含所有特定于单个能量组的东西。为了将那些属于单个对象的东西组合在一起，我们声明了一个结构，它包含了用于单个能量组的网格的Triangulation和DoFHandler对象，以及一些其他对象和成员函数，我们将在下面的章节中讨论。   
* 这个类的主要原因如下：对于正向问题（有指定的右手边）和特征值问题，人们通常解决一连串的问题，而不是完全耦合的问题。一旦意识到单一能量组的系统矩阵是对称和正定的（它只是一个扩散算子），而完全耦合问题的矩阵通常是非对称和非定值的，这就可以理解了。如果涉及几个以上的能量组，它也是非常大和相当完整的。   
* 让我们首先看看在外部右手边的情况下要解决的方程（对于时间无关的情况）。[1.x.112]
*
* 我们通常会通过将右手边的所有项与[2.x.216]移到左手边来解决这个方程，并求出[2.x.217] 。当然，我们还不知道[2.x.218]，因为这些变量的方程包括涉及[2.x.219]的右侧项。在这种情况下，通常的做法是进行迭代：计算[1.x.113] 。
*
*换句话说，我们逐一解决方程，如果[2.x.222]，则使用前一次迭代中[2.x.221]的值，如果[2.x.224]，则使用本次迭代中已经计算的[2.x.223]的值。   
* 在计算特征值时，我们做了一个非常类似的迭代，只是我们没有外部的右手边，而且每次迭代后的解都是按比例计算的，正如在介绍中所解释的。   
* 在任何一种情况下，如果我们所做的只是让下面这一类人具备这些能力，那么这两种情况就可以共同处理。(i) 形成左手边的矩阵，(ii) 形成组内右手边的贡献，即涉及到不相干的来源，以及(iii) 形成源于组[2.x.225]的对右手边的那份贡献。这个类正是做这些工作（以及一些簿记工作，如网格细化、设置矩阵和向量等）。另一方面，这个类本身不知道有多少个能量组，特别是它们如何相互作用，也就是说，决定外部迭代的方式（以及因此我们是解决一个特征值还是一个直接问题）是留给本程序下面的NeutronDiffusionProblem类的。   
* 所以让我们来看看这个类和它的接口。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]
* 该类有相当数量的公共成员函数，因为其操作方式是由外部控制的，因此所有做重要事情的函数都需要从另一个类中调用。让我们从记账开始：该类显然需要知道它代表哪个能源组，使用哪种材料数据，以及从哪个粗略的网格开始。构造函数需要这些信息，并且用这些信息初始化相关的成员变量（见下文）。     
* 然后，我们还需要一些函数来设置线性系统，即正确地确定矩阵的大小和它的稀疏模式，等等，给定一个有限元对象来使用。[2.x.226]函数就是这样做的。最后，对于这个初始块，有两个函数可以返回这个对象中使用的活动单元和自由度的数量
*
* - 利用这一点，我们可以使三角化和DoF处理程序成员变量私有化，不必授予外部使用它，增强了封装性。
*


* [1.x.117]
*
* 然后有一些函数为每个迭代和目前的能量组组装线性系统。请注意，该矩阵与迭代次数无关，因此在每个细化周期只需计算一次。对于必须在每次逆功率迭代中更新的右手边来说，情况就有点复杂了，而且由于计算它可能涉及到几个不同的网格，正如介绍中所解释的那样，这就更复杂了。为了使事情在解决正向或特征值问题方面更加灵活，我们将右手边的计算分成一个函数，将无关的源和组内贡献（我们将其称为零函数，作为特征值问题的源项）和一个计算来自另一个能量组的右手边的贡献。
*


* [1.x.118]
*
* 接下来我们需要一组函数来实际计算线性系统的解，并对其进行处理（比如计算介绍中提到的裂变源贡献，将图形信息写入输出文件，计算误差指标，或者根据这些标准和阈值实际细化和粗化网格）。所有这些函数以后都可以从驱动类[2.x.227]中调用，或者你想实现的任何其他类来解决涉及中子通量方程的问题。
*


* [1.x.119]
*
* [1.x.120] [1.x.121].
* 作为面向对象编程的良好实践，我们通过将大多数数据成员变成私有的来隐藏它们。然而，我们必须授予驱动进程的类对解向量以及上一次迭代的解的访问权，因为在幂迭代中，解向量在每次迭代中都被我们正在寻找的特征值的当前猜测所缩放。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。
* 其余的数据成员是私有的。与之前所有的教程程序相比，唯一的新数据成员是一个存储该对象所代表的能量组的整数，以及该对象的构造函数从驱动类得到的材料数据对象的引用。同样，构造函数也得到了一个对我们要使用的有限元对象的引用。     
* 最后，我们必须在每次迭代中对线性系统应用边界值，即相当频繁。我们不是每次都插值，而是在每个新网格上插值一次，然后和这个类的所有其他数据一起存储。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。
* 这个类中有一个私有成员函数。它递归地走过两个网格的单元，以计算跨组的右手边项。这方面的算法在本程序的介绍中有所解释。这个函数的参数是对一个对象的引用，该对象代表了我们想要整合的右手项的能量组，一个指向用于当前能量组的网格单元的迭代器，一个指向另一个网格上相应单元的迭代器，以及将自由度从两个单元中较粗的单元插补到较细的单元的矩阵。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 这个类的前几个函数大多是不言自明的。构造函数只设置了几个数据成员，并创建了一个给定三角图的副本，作为这个能量组所用的三角图的基础。接下来的两个函数只是从私有数据成员中返回数据，从而使我们能够使这些数据成员私有化。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]
* 第一个 "实 "函数是在新的网格上或在网格细化后设置网格、矩阵等的函数。我们用这个函数来初始化稀疏系统矩阵，以及右手边的向量。如果求解向量之前从未被设置过（如用零大小表示），我们也会初始化它并将其设置为默认值。如果它已经有一个非零的大小（即这个函数是在网格细化之后调用的），我们就不这么做了，因为在这种情况下，我们希望在网格细化中保留解决方案（这一点我们在[2.x.228]函数中做过）。
*


* [1.x.134]
*
* 在这个函数的最后，我们更新边界节点的列表和它们的数值，首先清除这个列表和重新插值的边界数值（记住，这个函数是在第一次设置网格后调用的，每次在网格细化后调用）。     
* 为了理解这段代码，有必要认识到我们使用[2.x.229]函数来创建网格（在[2.x.230]），其中我们将最后一个参数设置为[2.x.231] 。这意味着域的边界是 "彩色 "的，也就是说，域的四个（或六个，在3D中）边被赋予不同的边界指标。结果是，底部边界得到指标0，顶部的一个边界得到指标1，而左右边界分别得到指标2和3。     
* 在这个程序中，我们只模拟一个，即右上角的反应器的四分之一。也就是说，我们只想在顶部和右侧边界插值边界条件，而在底部和左侧边界不做任何事情（即施加自然的、无流量的诺伊曼边界条件）。这很容易被推广到任意维度，即我们想在指标为1、3、......的边界上插值，我们在下面的循环中这样做（注意，对[2.x.232]的调用是加法的，即它们不会首先清除边界值图）。
*


* [1.x.135]
*
* [1.x.136] [1.x.137].
* 接下来我们需要函数来组装系统矩阵和右手边。考虑到介绍中列出的方程以及我们在以前的例子程序中看到的内容，组装矩阵是很简单的。注意使用[2.x.233]来获取一个单元的材料种类。还要注意我们如何设置正交公式的顺序，以便它总是适合使用的有限元。   
* 最后，请注意，由于我们在这里只组装了系统矩阵，所以我们还不能消除边界值（我们需要右边的向量来实现）。我们将此推迟到[2.x.234]函数中，此时所有的信息都可以得到。
*


* [1.x.138]
*
* [1.x.139] [1.x.140]。
* 正如[2.x.235]类的文档中所解释的，我们把组装右手边分成两部分：组内耦合和跨组耦合。首先，我们需要一个函数来组装这里的一个特定组的右手边，即包括一个无关的源（我们将在特征值问题上设置为零）以及组内裂变贡献。  组内散射已经在清除截面的定义中得到了考虑）。该函数的工作原理就组装右手边而言是非常标准的，因此不需要更多的评论，只是我们要提到在函数的开始部分将右手边的向量设置为零
*
* 这一点我们不打算为跨组项做，因为它们只是简单地加到右手边的向量上。
*


* [1.x.141]
*
* [1.x.142] [1.x.143]。
* 对于组装单一能量组方程的右手向量来说，更有趣的函数是将能量组[2.x.236]和[2.x.237]耦合起来。正如介绍中所解释的，我们首先要找到两个能量组的网格所共有的单元格集合。首先我们调用[2.x.238]来获得这一对来自两个网格的共同单元的列表。一对单元格中的两个单元格可能都不活跃，但至少有一个是活跃的。然后，我们将这些单元格对中的每一个交给一个函数，以递归地计算右手边的项。   
* 注意，组内耦合在之前已经处理过了，所以如果[2.x.239]，我们提前退出函数。
*


* [1.x.144]
*
* [1.x.145][1.x.146] 。
* 这是最后一个处理在潜在的不同网格上递归地组装右手边项的函数，使用介绍中描述的算法。该函数需要一个对代表能量组[2.x.240]的对象的引用，以及对能量组[2.x.241]和[2.x.242]的网格中相应单元的迭代器。起初，即从上面的函数中调用这个函数时，这两个单元将是两个网格上的匹配单元；然而，这两个单元中的一个可能被进一步细化，我们将递归地调用这个函数，两个迭代器中的一个被原始单元的一个子单元所替代。   
* 最后一个参数是介绍中的矩阵乘积矩阵[2.x.243]，它从两个单元中较粗的单元插值到较细的单元。如果这两个单元格匹配，那么这就是身份矩阵。
*
* - 正是我们最初传递给这个函数的东西。   
* 该函数必须考虑两种情况：两个单元格都没有进一步细化，即没有子代，在这种情况下，我们可以最终组装这对单元格的右侧贡献；两个单元格中的一个被进一步细化，在这种情况下，我们必须通过循环未激活的单元格的子代来继续递归。下面将讨论这两种情况。
*


* [1.x.147]

* 第一种情况是，两个单元都没有进一步细化。在这种情况下，我们可以组装相关条款（见介绍）。这涉及到在两个单元中较细的单元上组装质量矩阵（事实上，有两个具有不同系数的质量矩阵，一个用于裂变分布截面[2.x.244]，一个用于散射截面[2.x.245]）。这是直截了当的，但请注意我们如何通过查看两个单元的细化水平来确定哪个是更细的单元。
*


* [1.x.148]
*
* 现在我们有了所有的插值（延长）矩阵以及局部质量矩阵，所以我们只需要根据两个单元中哪一个更细，形成乘积 [1.x.149] 或 [1.x.150] 。我们使用 [2.x.246] 函数提供的矩阵-向量乘积，或者使用 [2.x.247] 与转置矩阵进行乘积。这样做之后，我们将结果转移到能量组的全局右侧向量中 [2.x.248] 。
*


* [1.x.151]
*
* 另一种情况是，两个单元中的一个被进一步细化。在这种情况下，我们必须在所有的子单元上循环，将现有的矩阵的插值（延长）乘以从现在的单元到其子单元的插值（使用矩阵-矩阵乘法函数[2.x.249]），然后将结果再次交给这个非常相同的函数，但有子单元被其子单元之一取代。
*


* [1.x.152]
*
* [1.x.153] [1.x.154]。
* 在（反）功率迭代中，我们使用综合裂变源来更新[2.x.250] -特征值。鉴于其定义，以下函数基本上是不言自明的。
*


* [1.x.155]
*
* [1.x.156] [1.x.157].
* 接下来是一个解决之前组装的线性系统的函数。事情基本是标准的，只是我们把应用边界值的时间推迟到了这里，因为在之前的所有函数中，我们还是在为右边的向量做加法。
*


* [1.x.158]
*
* [1.x.159] [1.x.160].
* 网格细化被分成两个函数。第一个函数估计每个单元的误差，通过解的大小将其归一化，并将其返回到作为参数的矢量中。调用函数收集所有能量组的所有误差指标，并计算出细化和粗化单元的阈值。
*


* [1.x.161]
*
* [1.x.162] [1.x.163]。
* 第二部分是给定前一个函数中计算的误差指标和误差阈值来细化网格，超过这个阈值的单元应被细化，低于这个阈值的单元应被粗化。注意，我们在这里没有使用[2.x.251]中的任何函数，而是自己设置细化标志。   
* 在设置完这些标志后，我们使用SolutionTransfer类将求解向量从旧网格转移到新网格。这里使用的程序在该类的文档中已有详细描述。
*


* [1.x.164]
*
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
*


* [1.x.165]
*
* [1.x.166] [1.x.167].
* 本类的最后一个函数在每次网格迭代后输出网格和解。这在以前已经显示过很多次了。唯一值得指出的是使用[2.x.252]函数将一个整数转换成其字符串表示。该函数的第二个参数表示我们应使用多少个数字
*
* - 如果这个值大于1，那么这个数字将被填充前导零。
*


* [1.x.168]

* [1.x.169] [1.x.170]。


*
* 这是程序的主类，并不是因为它实现了所有的功能（事实上，大部分的功能都在[2.x.253]类中实现了），而是因为它包含了决定什么时候计算的驱动算法。它主要是像其他许多教程程序中显示的那样，它有一个公共的[2.x.254]函数和私有函数来做其他的事情。在一些地方，我们必须为所有能源组做一些事情，在这种情况下，如果deal.II被配置为多线程，我们将为每个组启动任务，让这些事情并行运行。  关于并行化的策略，请看一下[2.x.255]模块。   
* 与以前的例子程序最大的不同是，我们还声明了一个嵌套类，该类有成员变量，用于所有可在输入文件中传递给程序的运行时参数。现在，这些参数是能量组的数量、细化周期的数量、要使用的有限元的多项式程度，以及用于确定反幂迭代何时收敛的公差。此外，我们有一个该类的构造函数，将所有这些值设置为默认值，还有一个函数[2.x.256]向ParameterHandler类描述输入文件中接受哪些参数，还有一个函数[2.x.257]可以从ParameterHandler对象中提取这些参数的值。另一个使用ParameterHandler的例子见[2.x.258]。
*


* [1.x.171]
*
* [1.x.172] [1.x.173]。



* 这个类中没有那么多的成员函数，因为大部分的功能已经被移到了[2.x.259]类中，只是从这个类的[2.x.260]成员函数中调用。保留下来的成员函数有不言自明的名字。
*


* [1.x.174]
*
* [1.x.175] [1.x.176]。


*
* 接下来，我们有几个成员变量。特别是，这些是（i）对参数对象的引用（由本程序的主函数拥有，并传递给本类的构造函数），（ii）描述输入文件中要求的能量组数量的材料参数的对象，以及（iii）所有能量组要使用的有限元。
*


* [1.x.177]
*
* 此外，我们还有(iv)目前迭代时计算出的特征值的值。事实上，这也是所有能量组之间唯一共享的解的部分
*
* - 解决方案的所有其他部分，如中子通量都是特定于一个或另一个能量组的，因此被存储在描述单一能量组的对象中。
*


* [1.x.178]
*
* 最后一个计算对象（v）是一个指向能量组对象的指针数组。当然，这个数组的长度等于参数文件中指定的能量组的数量。
*


* [1.x.179]
*
* 最后（vi）我们有一个文件流，我们将把总结的输出保存到这个文件中。
*


* [1.x.180]
*
* [1.x.181] [1.x.182]。


*
* 在继续实现外层类之前，我们必须先实现参数结构的功能。这是非常直接的，事实上，对于所有使用ParameterHandler功能的这类参数类来说，看起来都是一样的。因此，我们将不再对此进行评论。
*


* [1.x.183]
*
* [1.x.184] [1.x.185]。


*
* 现在是[2.x.261]类。构造函数和析构函数没有什么值得注意的地方。
*


* [1.x.186]
*
* [1.x.187] [1.x.188]。
* 第一个感兴趣的函数是设置反应堆核心的几何形状的函数。这在介绍中会有更详细的描述。   
* 该函数的第一部分定义了几何数据，然后创建了一个粗略的网格，其单元数与我们模拟的那部分反应堆堆芯中的燃料棒（或针状单元）的数量相同。正如上面插值边界值时提到的，[2.x.262]函数的最后一个参数指定域的两侧应具有唯一的边界指标，这将使我们以后能够以简单的方式确定哪些边界具有诺伊曼条件，哪些具有迪里希特条件附加在上面。
*


* [1.x.189]
*
* 该函数的第二部分涉及到每种类型组件的销钉单元的材料数量。在这里，我们定义了四种不同类型的组件，对于这些组件，我们在以下表格中描述了燃料棒的安排。     
* 这里描述的装配体取自介绍中提到的基准，它们是（按顺序）。  [2.x.263] [2.x.264] 'UX'组件。二氧化铀燃料组件，带有24个导向管和一个中央可移动裂变室 [2.x.265] 'UA' 组件。带有24个AIC的二氧化铀燃料组件和一个中央可移动裂变室 [2.x.266] 'PX'组件。MOX燃料组件，带有24个导气管和一个中央可移动裂变室 [2.x.267] 'R'组件：一个反射器。   [2.x.268]
* 请注意，这里列出的数字和从基准描述中提取的数字，以良好的老Fortran方式，是基于一的。我们以后在给各个单元分配材料时将从每个数字中减去1，以便将事情转换为C语言风格的基于零的索引。
*


* [1.x.190]
*
* 在描述了组成装配体的材料之后，我们必须指定装配体在核心中的排列方式。我们使用一个对称的模式，实际上只使用 "UX "和 "PX "组件。
*


* [1.x.191]

* 我们现在可以为每个单元实际设置材料ID。为此，我们对所有单元进行循环，查看单元中心的位置，并确定这将在哪个组件和燃料棒中。我们增加了一些检查，以确保我们计算的位置在我们必须查找材料的数组的范围内）。在循环结束时，我们相应地设置材料标识符。
*


* [1.x.192]
*
* 在粗略网格被初始化后，我们创建适当数量的能量组对象，并让它们用上面生成的粗略网格初始化各自的网格。
*


* [1.x.193]
*
* [1.x.194] [1.x.195]。
* 在特征值计算中，我们需要在每次功率迭代后计算裂变中子源总量。然后用总功率来更新K效。   
* 因为总裂变源是所有能量组的总和，而且每个总和都可以独立计算，所以我们实际上是并行进行的。其中一个问题是，[2.x.269]类中计算裂变源的函数会返回一个值。我们想在循环本身中把这些值加在一起：理想的情况是，每个任务计算它的值，然后立即把它加到总数中。以这种方式同时加值需要两个功能。  [2.x.270] [2.x.271] 我们需要一种存储数值的方式，使多个线程能够以防止数据竞赛的方式并发地读入和写入（即线程安全的读写）。[2.x.272] [2.x.273] 我们需要一种方法来增加这样一个值，而且是线程安全的。[2.x.274] [2.x.275]
* 第一个特性可以通过模板类实现 [2.x.276] 。然而，由[2.x.277]实现的第二个特性只在C++20及以后的版本中可用：由于deal.II支持旧版本的C++语言标准，我们还不能使用这一特性。因此，取而代之的是，我们简单地将每个组的值写成一个向量的条目，并在函数的最后将这些值相加。
*


* [1.x.196]
*
* [1.x.197] [1.x.198]。
* 下一个函数让各个能量组对象细化其网格。这其中的大部分，也是可以独立并行完成的任务：首先，让所有的能量组对象并行计算它们的误差指标，然后计算所有能量组的最大误差指标，并确定细化和粗化单元的阈值，然后要求所有的能量组相应地细化它们的网格，也是并行的。
*


* [1.x.199]
*
* [2.x.278]的析构器加入了所有线程，所以我们知道在我们退出范围时，计算已经完成。
*


*


* [1.x.200]
*
* [1.x.201] [1.x.202].
* 最后，这就是肉的函数：在一连串的网格上迭代，并对每一个网格进行幂级迭代来计算特征值。   
* 鉴于介绍中对算法的描述，实际上没有什么可评论的。
*


* [1.x.203]
*
* 我们希望只为这个函数改变输出精度，并在这个函数返回时恢复[2.x.279]的状态。因此，我们需要一种方法来撤销输出格式的改变。Boost提供了一种方便的方法来保存输出流的状态，并在当前块结束时（当调用[2.x.280]的析构器时）用[2.x.281]类来恢复它，我们在这里使用这个方法。
*


* [1.x.204]
*
* 我们通过k_eff的变化来计算下面的误差（即k_eff_old的差异。
*


* [1.x.205]
*
* 我们将在下面测量每个周期所花费的CPU时间。计时器的构造函数调用了[2.x.282]，所以一旦我们创建了一个计时器，就可以查询它的信息。由于这个循环的许多部分是用任务并行化的，所以我们测量的CPU时间（如果我们用一个以上的线程运行）将大于墙的时间。
*


* [1.x.206]
*
* 打印出关于模拟的信息以及耗费的CPU时间。我们可以不先调用[2.x.283]来获得调用该函数时的已用CPU时间。
*


* [1.x.207]
*
* [1.x.208] [1.x.209]。



* 程序中的最后一件事是[2.x.285]函数。其结构与其他大多数教程程序一样，唯一的例外是我们在这里处理一个参数文件。  为此，我们首先看一下传递给这个函数的命令行参数：如果在命令行上没有指定输入文件，那么就使用 "project.prm"，否则就取命令行上作为第一个参数给出的文件名。
*

*
* 有了这个，我们创建一个ParameterHandler对象，让[2.x.286]类声明它想在输入文件中看到的所有参数（或者，采取默认值，如果参数文件中没有列出任何参数），然后读取输入文件，要求参数对象提取数值，最后把所有东西交给[2.x.287]类型的对象，以便计算特征值。
*


* [1.x.210]
*[1.x.211][1.x.212]


* 我们可以用以下输入文件来运行程序。
* [1.x.213]
* 该程序的输出包括控制台输出，一个名为 "convergence_table "的文件记录了网格迭代的主要结果，以及vtu格式的图形输出。
* 控制台的输出看起来像这样。
* [1.x.214]
*
* 我们看到在第0周期后，动力迭代确实收敛得比较快，这是因为用上一次网格迭代的解进行了初始化。`convergence_table'的内容是。
* [1.x.215]
* 列的含义是：网格迭代次数，快速能量组的自由度数，热能组的自由度数，收敛效果和快速通量的最大值与热能组的最大值之比。
* 网格迭代#9时，快速和热能组的网格看起来如下。
* [2.x.288] &nbsp; [2.x.289] 。
* 我们看到热能组的网格要比快速组的网格细得多。在这些网格上的解是，（注意：通量被归一化，总裂变源等于1）。
* [2.x.290] &nbsp; [2.x.291] 。
* 然后我们绘制多项式阶数等于1、2和3的收敛数据。
* [2.x.292]
* 估计的 "精确 "k-effective=0.906834721253，这只是从多项式阶数为3减去2e-10的lastmesh迭代得出的。我们看到，h-adaptive计算提供了一个代数收敛。多项式阶数越高，网格迭代收敛的速度越快。在我们的问题中，我们需要较少的DoFs数量来实现较高的多项式阶数下的相同精度。
*

* [1.x.216][1.x.217] [2.x.293] 。
* [0.x.1]

