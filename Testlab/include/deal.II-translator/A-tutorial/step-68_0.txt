include/deal.II-translator/A-tutorial/step-68_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.2] 
* [1.x.29]
*[1.x.30][1.x.31]
 

* [1.x.32][1.x.33] * [1.x.32][1.x.33]。
* 

* 粒子在大量应用的数值模型中发挥着重要作用。粒子通常被用作无质量的追踪器，以显示瞬时流动的动态。它们也可以作为更复杂的有限元模型的一部分发挥固有的作用，如颗粒在单元（PIC）方法[2.x.3]，或者它们甚至可以用来模拟颗粒物质的运动，如离散元素法（DEM）[2.x.4] 。在DEM的情况下，所产生的模型不再与有限元方法有关，而只是导致了一个描述颗粒运动和它们碰撞动态的常微分方程系统。所有这些模型都可以用deal.II的粒子处理能力来建立。
* 在本步骤中，我们使用粒子作为无质量的追踪器来说明涡流的动态。由于粒子是无质量追踪器，每个粒子[2.x.5]的位置由以下的常微分方程（ODE）描述：[1.x.34
* 其中[2.x.6]是粒子[2.x.7]的位置，[2.x.8]是其位置的流速。在本步骤中，使用显式欧拉方法解决这个ODE。得到的方案是：[1.x.35] 。
* 其中[2.x.9]和[2.x.10]分别是粒子[2.x.11]在时间[2.x.12]和[2.x.13]的位置，[2.x.14]是时间步骤。在本步骤中，粒子位置的速度以两种不同的方式获得。
* 
* - 通过评估粒子位置的速度函数。
* 
* 通过在背景三角图上评估速度函数，并使用有限元支持，在粒子的位置进行内插。
* 第一种方法并不实用，因为速度剖面通常不是以分析方式知道的。第二种方法，基于对粒子位置的内插求解，完全模仿了现实计算流体动力学模拟中的做法，这也是我们在[2.x.15]中对粒子位置的有限元求解进行评估的方式。在这一步中，我们说明了这两种策略。
* 我们注意到，使用四阶Runge-Kutta方法或其他适当的方案对粒子的运动进行时间积分，可以获得更大的精度。 实施一个更先进的时间积分方案将是这一步骤的直接延伸。
*[1.x.36][1.x.37]
* 

* 在交易二中，[2.x.16]是非常简单和灵活的实体，可以用来建立PIC、DEM或任何类型的基于粒子的模型。粒子在现实空间中有一个位置，在它们所在的元素的参考空间中有一个位置，还有一个唯一的ID。在大多数情况下，包含粒子的模拟需要大量的粒子。因此，通过一个集合所有粒子的实体来处理所有的粒子变得很有意义。
* 默认情况下，粒子没有直径、质量或任何其他我们通常期望的物理粒子的物理属性。然而，通过ParticleHandler，粒子可以访问[2.x.18]这个PropertyPool是一个数组，可以用来存储与粒子相关的任意数量的属性。因此，用户可以建立他们自己的粒子解算器，并将所需的属性赋予粒子（例如，质量、电荷、直径、温度等）。在本教程中，它被用来存储流体速度的值和粒子所属的过程ID。
* [1.x.38][1.x.39] 。
* 

* 尽管本步骤不是计算密集型的，但包括许多粒子的模拟可能是计算要求很高的，需要并行化。
* 
* - 在分布式三角形上生成粒子。
* 
* - 在处理器之间交换离开本地域的粒子。
* 
* - 负载平衡模拟，使每个处理器都有类似的计算负载。这些挑战和它们在deal.II中的解决方案已经在[2.x.19]中详细讨论过了，但我们将在下文中总结它们。
* 当然，还有一些关于简单设置使用粒子的代码的问题。这些问题在 [2.x.20] 中已经基本解决了。一些更高级的技术也将在 [2.x.21] 中讨论。
* [1.x.40][1.x.41] 。
* 

* 以可扩展的方式生成分布式粒子并不简单，在找到它们所在的单元之前，必须首先确定它们所属的处理器。交易.II通过[2.x.22]命名空间提供了许多生成粒子的功能。 其中一些粒子生成器只在本地拥有的子域上创建粒子。例如，[2.x.23]在本地子域的每个单元内创建相同参考位置的粒子，[2.x.24]使用全局定义的概率密度函数来确定在本地生成粒子的数量和位置。
* 在其他情况下，如本步骤，粒子必须在单元格上的特定位置生成，而这些单元格可能只属于处理器的一个子集。在大多数情况下，粒子的插入只在有限的时间步数内完成，因此，不构成计算成本的很大一部分。对于这些情况，deal.II提供了方便的[2.x.25]，可以在全局范围内插入粒子，即使粒子不在启动创建粒子的调用的并行进程所拥有的单元中。生成器首先定位粒子所处的子域，确定它们位于哪个单元中，并在处理器之间交换必要的信息，以确保生成的粒子具有正确的属性。因此，这种类型的粒子生成可能是通信密集型的。[2.x.26]和[2.x.27]分别使用三角法和相关DoFHandler或四分法的点来生成粒子。用于生成粒子的三角法可以是用于背景网格的同一三角法，在这种情况下，这些函数与上一段所述的[2.x.28]函数非常相似。然而，用于生成粒子的三角形也可以与背景网格的三角形不同（不匹配），这对于生成特定形状的粒子（如本例），或者在两个不同的计算网格之间传递信息（如[2.x.29]）是很有用的。 此外，[2.x.30]类提供了[2.x.31]函数，可以从任意点的矢量和边界盒的全局矢量中插入粒子。在本步骤中，我们在非匹配三角形上使用[2.x.32]函数来插入位于圆盘形状的位置上的粒子。
*[1.x.42][1.x.43]
* 

* 当粒子在平行分布式计算中移动时，它们可能会离开本地拥有的子域，并需要转移到它们的新主人进程中。这种情况可能以两种非常不同的方式出现。首先，如果先前拥有的进程知道丢失的粒子的新主人（例如，因为粒子从一个处理器的本地拥有的单元移动到一个分布式三角计算的相邻的幽灵单元），那么转移可以作为每个进程和新主人之间的点对点通信来有效处理。每当粒子被分类到新单元时，这种转移就会自动发生。第二，以前的所有者可能不知道粒子被转移到哪个进程。在这种情况下，粒子会被默认丢弃，因为在全局范围内搜索粒子的主人可能会很昂贵。 [2.x.33]展示了这样一个被丢弃的粒子如何仍然可以被收集、解释，并可能被用户重新插入。在本例中，我们通过在时间步骤上施加一个CFL准则来防止第二种情况，以确保粒子最多只能移动到本地进程的幽灵层，因此可以自动发送到邻近的进程。
*[1.x.44][1.x.45]
* 

* 在使用粒子的并行分布式计算中出现的最后一个挑战是平衡计算负载，即在网格上进行的工作，例如解决有限元问题，以及在粒子上进行的工作，例如移动粒子或计算粒子之间或粒子与网格之间的力。默认情况下，例如在[2.x.34]中，deal.II将背景网格尽可能均匀地分配给可用的进程，即平衡每个进程中的单元数量。然而，如果一些单元比其他单元拥有更多的粒子，或者如果一个单元的粒子比其他单元的粒子在计算上要昂贵得多，那么这个问题就不再有效地扩展了（关于我们认为的 "可扩展 "程序的讨论，见[2.x.35]"本词汇表条目"）。因此，我们必须应用某种形式的 "负载平衡"，这意味着我们估计与每个单元及其粒子相关的计算负载。然后，重新划分网格时要考虑到这个综合的计算负荷，而不是简单地假设单元的数量[2.x.36] 。
* 在本节中，我们只讨论了分布式计算中针对粒子的挑战。粒子与有限元解决方案共享的并行挑战（并行输出，网格细化过程中的数据传输）可以用其他例子中已经讨论过的有限元问题的解决方案来解决。
*[1.x.46][1.x.47]
* 

* 在本步骤中，我们使用粒子作为无质量追踪器来说明一个特殊的涡流的动力学：Rayleigh--Kothe涡流。这种流动模式通常被用作界面跟踪方法（如流体体积和水平集方法）的复杂测试案例，因为它导致了流体的强烈旋转和拉长 [2.x.37] 。
* 这个Rayleigh-Kothe涡流的流函数[2.x.38]被定义为。
* [1.x.48]其中[2.x.39]是流动周期的一半。二维的速度曲线（[2.x.40]）为：[1.x.49] 。
* 
* 该速度剖面在以下动画中得到说明。
* [1.x.50]
* 
* 可以看出，由于[2.x.41]项的作用，这个速度会周期性地逆转，材料在每一个长度为[2.x.42]的周期后会结束在其起始位置。我们将精确地运行这个教程程序一个周期，并将最终的粒子位置与初始位置进行比较，以说明这一流动特性。这个例子使用测试案例产生了两个模型，它们对粒子的处理略有不同。第一个模型将精确的分析速度解作为每个粒子的速度。因此，在这个模型中，分配给粒子的速度是没有错误的，在给定的时间内，粒子位置与分析位置的任何偏差都是由于使用时间步进法精确求解粒子的运动方程的错误造成的。在第二个模型中，理论速度场首先被内插到一个有限元矢量空间中（以模拟速度是通过求解一个有限元问题得到的情况，与[2.x.43]中每个粒子的ODE取决于一个有限元解的方式相同）。然后在粒子的位置上对这个有限元 "解决方案 "进行评估，以解决其运动方程。这两种情况之间的差异允许评估所选择的有限元空间是否足够准确，以所选择的粒子平流方案的最佳收敛率来平流粒子，这个问题在实践中对确定组合算法的准确性很重要（例如，见[2.x.44]）。
* 

* [1.x.51] [1.x.52]。
* [1.x.53] [1.x.54]。
 

* 
*  

 
* [1.x.55]
* 
* 从下面的include文件中，我们导入了ParticleHandler类，该类允许你管理浮在[2.x.45]上的粒子集合（类型为[2.x.45]的对象，代表具有一些附加属性（如id）的点集合）。 命名空间Particles中的方法和类允许人们轻松实现Particle-In-Cell方法和分布三角上的粒子追踪。
* 

* 
* [1.x.56]
* 
* 我们导入粒子发生器，使我们能够插入粒子。在本步骤中，粒子是使用非匹配的超壳三角法进行全局插入的。
* 

* 
* [1.x.57]
 
* 由于粒子没有形成三角形，它们有自己特定的DataOut类，这将使我们能够把它们写成常用的并行vtu格式（或任何数量的其他文件格式）。
* 

* 
* [1.x.58]
* 
* [1.x.59] [1.x.60]
 

* 
* 与[2.x.47]中的做法类似，我们设置了一个持有我们问题的所有参数的类，并从ParameterAcceptor类派生出来，以简化参数文件的管理和创建。  
* ParameterAcceptor范式要求所有的参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的bug（比如写成`if (time = 0)`而不是`if(time == 0)`），我们在一个外部类中声明所有的参数，该类在实际的`ParticleTracking`类之前被初始化，并将其作为`const`引用传递给主类。  
* 该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了[2.x.48]方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。
* 

* 
* [1.x.61]
* 
* 这个类主要由成员变量组成，描述了粒子跟踪模拟及其离散化的细节。下面的参数是关于输出应该写到哪里，速度的空间离散化（默认是[2.x.49]），时间步长和输出频率（在我们再次产生图形输出之前应该经过多少时间步长）。
* 

* 
* [1.x.62]
 
* 我们允许每一个网格都可以独立地进行细化。在本教程中，流体网格上没有物理学的解析，其速度是分析计算的。
* 

* 
* [1.x.63]
 
* 还有一个任务就是声明我们在输入文件中可以接受哪些运行时参数。由于我们的参数数量非常有限，所有的参数都在同一章节中声明。
* 

* 
* [1.x.64]
* 
* [1.x.65] [1.x.66].
 

* 
* 速度曲线是作为一个函数对象提供的。这个函数在例子中是硬编码的。
* 

* 
* [1.x.67]
* 
* Rayleigh-Kothe顶点的速度曲线是随时间变化的。因此，必须从函数对象中收集模拟中的当前时间（t）。
* 

* 
* [1.x.68]
* 
* [1.x.69] [1.x.70].
 

* 
* 我们现在准备介绍我们教程程序的主类。
* 

* 
* [1.x.71]
* 
* 这个函数负责在背景网格之上初始生成粒子。
* 

* 
* [1.x.72]
* 
* 当速度剖面被内插到粒子的位置时，必须首先使用自由度进行存储。因此，与其他并行情况一样（例如[2.x.50]），我们在背景网格上初始化自由度。
* 

* 
* [1.x.73]
* 
* 在其中一个测试案例中，该函数被映射到背景网格上，并使用有限元插值来计算粒子位置的速度。这个函数计算三角形的支持点处的函数值。
* 

* 
* [1.x.74]
* 
* 接下来的两个函数分别负责对速度场在粒子位置插值或分析计算的情况下进行显式欧拉时间积分的步骤。
* 

* 
* [1.x.75]
* 
* `cell_weight()`函数向三角计算表明在这个单元上预计会发生多少计算工作，因此需要对域进行划分，以便每个MPI等级收到大致相等的工作量（可能不是相等数量的单元）。虽然该函数是从外部调用的，但它与该类内部的相应信号相连，因此它可以是 "私有 "的。
* 

* 
* [1.x.76]
* 
* 以下两个函数分别负责输出粒子的模拟结果和背景网格上的速度曲线。
* 

* 
* [1.x.77]
* 
* 这个类的私有成员与其他并行deal.II例子相似。参数被存储为`const`成员。值得注意的是，我们保留了`Vortex`类的成员，因为它的时间必须随着模拟的进行而被修改。
* 

* 
*  

* 
* [1.x.78]
* 
* [1.x.79] [1.x.80]。
 

 
* [1.x.81] [1.x.82].
 

* 
* 构造函数和析构函数是相当微不足道的。它们与 [2.x.51] 中的做法非常相似。我们将我们想要工作的处理器设置为所有可用的机器（`MPI_COMM_WORLD`），并初始化 [2.x.52] 变量，只允许处理器0输出任何东西到标准输出。
* 

* 
*  

* 
* [1.x.83]
 
* [1.x.84] [1.x.85]。
 

* 
* 这个函数是让我们动态地平衡本例计算负荷的关键部分。该函数为每个单元赋予一个权重，代表该单元的计算工作。在这里，大部分的工作预计会发生在粒子上，因此这个函数的返回值（代表 "这个单元的工作"）是根据当前单元中的粒子数量来计算。该函数与三角形内部的cell_weight()信号相连，每一个单元将被调用一次，每当三角形在等级之间重新划分领域时（该连接是在该类的generate_particles()函数中创建的）。
* 

* 
* [1.x.86]
* 
* 我们不给我们不拥有的单元分配任何权重（即人工或幽灵单元）。
* 

* 
* [1.x.87]
* 
* 这决定了粒子工作与细胞工作相比有多重要（默认情况下每个细胞的权重为1000）。我们把每个粒子的权重设置得更高，以表明在这个例子中，粒子的负载是唯一对分配单元很重要的。这个数字的最佳值取决于应用，可以从0（廉价的粒子操作，昂贵的单元操作）到远远大于1000（昂贵的粒子操作，廉价的单元操作，就像本例中假定的那样）。
* 

* 
* [1.x.88]
* 
* 这个例子没有使用自适应细化，因此每个单元都应该有`CELL_PERSIST`的状态。然而这个函数也可以用来在细化过程中分配负载，因此我们也考虑细化或粗化的单元。
* 

* 
* [1.x.89]
* 
* [1.x.90] [1.x.91].
 

* 
* 这个函数生成示踪粒子和这些粒子演化的背景三角图。
* 

* 
* [1.x.92]
* 
* 我们创建了一个超立方体三角图，并对其进行全局细化。这个三角形覆盖了粒子的全部运动轨迹。
* 

* 
* [1.x.93]
* 
* 为了在重新划分三角形时考虑粒子，该算法需要知道三件事。    
* 1.给每个单元分配多少权重（里面有多少粒子）；2.在运送数据之前如何包装粒子；3.在重新分区之后如何解开粒子的包装。    
* 我们将正确的函数附加到信号里面 [2.x.53] 这些信号将在每次调用repartition()函数时被调用。这些连接只需要创建一次，所以我们不妨在这个类的构造函数中设置它们，但为了这个例子，我们要把粒子相关的指令分组。
* 

* 
* [1.x.94]
* 
* 这将初始化粒子所处的背景三角，以及粒子的属性数量。
* 

* 
* [1.x.95]
* 
* 我们创建一个粒子三角图，它只用于生成将用于插入粒子的点。这个三角形是一个偏离模拟域中心的超壳。这将被用来生成一个充满粒子的圆盘，这将使我们能够很容易地监测由于漩涡而产生的运动。
* 

* 
* [1.x.96]
 
* 我们为粒子发生器生成必要的边界盒。这些边界框是用来快速识别插入的粒子位于哪个进程的子域中，以及哪个单元拥有它。
* 

* 
* [1.x.97]
* 
* 我们生成一个空的属性向量。一旦粒子生成，我们将把属性赋予它们。
* 

* 
* [1.x.98]
* 
* 我们在单点正交的位置生成粒子。因此，在每个单元的中心点将生成一个粒子。
* 

* 
* [1.x.99]
* 
* [1.x.100] [1.x.101].
 

* 
* 这个函数设置了用于速度插值的背景自由度，并分配了存储整个速度场解决方案的场向量。
* 

* 
* [1.x.102]
* 
* 这个函数负责将涡流速度场插值到场向量上。这可以通过使用[2.x.54]函数相当容易地实现。
* 

* 
* [1.x.103]
* 
* [1.x.104] [1.x.105]。
 

* 
* 我们使用分析定义的速度场来整合粒子的轨迹。这证明了粒子的一个相对微不足道的用法。
* 

* 
* [1.x.106]
* 
* 使用粒子迭代器在域中的所有粒子上循环运行
* 

* 
* [1.x.107]
* 
* 我们使用粒子的当前位置来计算其速度。
* 

* 
* [1.x.108]
* 
* 这将更新粒子的位置，并将旧的位置设置为等于粒子的新位置。
* 

* 
* [1.x.109]
* 
* 我们在粒子属性中存储处理器ID（一个标量）和粒子速度（一个矢量）。在这个例子中，这样做纯粹是为了可视化的目的。
* 

* 
* [1.x.110]
* 
* 与前面的函数相反，在这个函数中，我们通过将自由度处的速度场的值插值到粒子的位置来整合粒子的轨迹。
* 

* 
* [1.x.111]
* 
* 我们循环计算所有的局部粒子。虽然这可以直接通过循环所有的单元格来实现，但这将迫使我们循环许多不包含粒子的单元格。相反，我们在所有的粒子上循环，但是，我们得到粒子所在的单元格的参考，然后在该单元格内循环所有的粒子。这使我们能够从 "velocity_field "向量中收集一次速度值，并将其用于该单元中的所有粒子。
* 

* 
* [1.x.112]
* 
* 接下来，通过评估粒子位置的有限元解来计算粒子位置的速度。这基本上是第19步中粒子平流功能的一个优化版本，但我们不是为每个单元创建正交对象和FEValues对象，而是用手来进行评估，这在一定程度上更有效率，而且只对本教程重要，因为粒子工作是整个程序的主要成本。
* 

* 
* [1.x.113]
 
* 同样，我们在粒子属性中存储了粒子的速度和处理器的ID，以达到可视化的目的。
* 

* 
* [1.x.114]
* 
* [1.x.115] [1.x.116]
 

* 
* 接下来的两个函数负责将粒子和背景网格用pvtu记录写入vtu。这可以确保在并行启动仿真时，仿真结果可以被可视化。
* 

* 
* [1.x.117]
 
* 将解决方案的数据附加到data_out对象上
* 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120] 这个函数协调了整个模拟过程。它与其他时间相关的教程程序非常相似
* 
* - 以[2.x.55]或[2.x.56]为例。注意，我们使用DiscreteTime类来监控时间、时间步长和[2.x.57]数。这个函数相对来说是比较简单的。
* 

* 
*  

* 
* [1.x.121]
* 
* 我们通过在分析法和插值法的情况下进行时间步长为0的显式欧拉迭代来设置粒子的初始属性。
* 

* 
* [1.x.122]
 
* 粒子是通过循环的时间进行平流的。
* 

* 
* [1.x.123]
* 
* 在粒子被移动之后，有必要确定它们现在所在的单元。这可以通过调用[2.x.58]来实现。
* 

* 
* [1.x.124]
* 
* [1.x.125] [1.x.126]。
* 

* 
* 代码的其余部分，即`main()`函数，是标准的。我们注意到，我们用分析速度和插值速度运行粒子跟踪，并产生两种结果
* 

* 
* [1.x.127]
* [1.x.128][1.x.129] 。
* 

* 如果你没有在命令行上指定一个参数文件作为参数，程序将尝试默认读取文件 "parameters.prm"，并将执行代码。
* 在任何数量的核心上，模拟输出将看起来像。
* [1.x.130]
* 
* 我们注意到，在默认情况下，仿真会以分析速度运行粒子跟踪2000次迭代，然后从头开始，以相同的时间运行速度插值的粒子跟踪。每10次迭代都会写出结果。
*[1.x.131][1.x.132]
* 

* 下面的动画显示了粒子被流场吸引时的轨迹。我们看到，在流场的整个持续时间之后，粒子又回到了它们的初始配置，这是预料之中的。
* [1.x.133]
* 
*[1.x.134][1.x.135]
* 

* 下面的动画显示了动态负载平衡的影响。我们清楚地看到，子域适应自己以平衡每个子域的粒子数量。然而，完美的负载平衡并没有达到，部分原因是由于背景网格的粗糙性。
* [1.x.136]
* 
* 

* [1.x.137][1.x.138] * [1.x.138].
* 

* 这个程序强调了在deal.II中处理粒子的一些主要能力，特别是它们在分布式并行模拟中使用的能力。然而，这个步骤可以以多种方式进行扩展。
* 
* 高阶时间积分（例如使用Runge-Kutta 4方法）可以用来提高精度，或者在相同精度下允许更大的时间步长。
* 
* - 完整的运动方程（含惯性）可以为粒子求解。在这种情况下，粒子需要有额外的属性，如它们的质量，如[2.x.59]，如果还想考虑与流体的相互作用，它们的直径。
* 
* - 耦合到流动求解器。这一步可以直接与任何解决斯托克斯方程（[2.x.60]、[2.x.61]）或纳维-斯托克斯方程（例如[2.x.62]）的并行程序相耦合。
* 
* - 计算两个模型之间最终粒子位置的差异，可以量化插值误差对粒子运动的影响。
* 

* [1.x.139][1.x.140] [2.x.63] 。
* [0.x.1]

