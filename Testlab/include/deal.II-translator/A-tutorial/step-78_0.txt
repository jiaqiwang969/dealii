include/deal.II-translator/A-tutorial/step-78_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]
*[1.x.22][1.x.23][1.x.24] 。


* 布莱克-斯科尔斯方程是一个偏微分方程，有点超出了普通方案。它描述了一个 "欧罗巴 "股票期权的公平价格是多少。在不做过多解释的情况下，股票 "期权 "是一份可以从银行购买的合同，它允许我，但不要求我，在未来的固定时间[2.x.3]以固定的价格[2.x.2]购买特定的股票。那么，作为这种期权的买方要回答的问题是 "我认为这样的合约值多少钱？"，或者作为卖方 "我需要为这个合约收取多少钱？"，这既是合约在时间[2.x.5]前的函数[2.x.4]，也是股票价格的函数[2.x.6]。费舍尔-布莱克和迈伦-斯科尔斯在假设股票价格表现出随机的价格波动，具有一定的 "波动性 "和背景的指数价格增长（可以认为是通货膨胀率，随着时间的推移，所有的货币都会贬值）的情况下，得出了这种期权的公平价格的偏微分方程[2.x.7]。由于他们的工作，布莱克和斯科尔斯在1997年获得了诺贝尔经济科学奖，这也是第一个处理有人获得诺贝尔奖的问题的教程程序[2.x.8] 。
* 方程如下。
* [1.x.25]
* 其中
* [1.x.26]
*
* 我们应该这样理解这个方程，它是一个时间依赖的偏微分方程，其中一个 "空间 "变量 [2.x.9]是股票的价格，[2.x.10]是如果当时的股票价格是[2.x.12]时，期权的价格。
*[1.x.27][1.x.28] 。


* 这个方程有一些奇怪的地方，值得在讨论其数值解法之前讨论一下。首先，"空间 "域[2.x.13]是无界的，因此[2.x.14]的值也可以是无界的。这是因为股票价格可能有一个实际的上限，但不是一个概念上的。边界条件[2.x.15]和[2.x.16]可以被解释为如下。如果股票价格（今天或在[2.x.18]时）是[2.x.19]，那么允许我以价格[2.x.17]购买股票的期权的价值是多少？人们期望它是[2.x.20]加上一些通货膨胀的调整，或者，如果我们真的真正考虑[2.x.21]的巨大价值，我们可以忽略[2.x.22]，得出无限边界的边界值应该是上面所说的[2.x.23]的形式。
* 在实践中，对于我们使用有限元方法来解决这个问题，我们将需要约束[2.x.24]。由于这个方程描述的是价格，而谈论价格为负值是没有意义的，我们将设定[2.x.25]的下限为0。然后，对于上限，我们将选择一个非常大的数字，一个[2.x.26]不太可能达到的数字。我们称之为[2.x.27].因此，[2.x.28] 。
* 第二，在截断域之后，我们需要问在这个现在的有限边界上我们应该设置什么边界值。为了解决这个问题，我们使用 "放-叫 "奇偶性 [2.x.29] 。一个 "拉动期权 "是指我们被允许，但不是必须，在未来的某个时间[2.x.31]以价格[2.x.30]向某人出售*股票。这说明
* [1.x.29]
* 其中[2.x.32]是看涨期权的价值，[2.x.33]是投入期权的价值。由于我们期望[2.x.34]与[2.x.35]一样，这意味着
* [1.x.30]
* 我们可以用这个作为我们的有限点[2.x.36]的合理边界条件。
* Block-Scholes方程的第二个复杂问题是，我们得到的是一个最终条件，而不是一个初始条件。这是因为我们知道期权在[2.x.37]时的价值：如果[2.x.38]时的股票价格是[2.x.39]，那么我们就没有动力使用我们的期权买入价格[2.x.40]，因为我们可以在公开市场上以更低的价格买入该股票。所以[2.x.41]为[2.x.42]。另一方面，如果在[2.x.43]时我们有[2.x.44]，那么我们可以通过期权以[2.x.45]的价格买入股票，并立即在市场上以[2.x.46]的价格再次卖出，给我带来[2.x.47]的利润。换句话说，[2.x.48]换取[2.x.49]。因此，我们只知道结束时的[2.x.50]的价值*，而不知道初始时的价值
*
* 事实上，找出当前时间（通常认为是[2.x.51]）的公平价格就是解决这些方程的目的。
* 这意味着这不是一个在时间上向前提出的方程，而实际上是在时间上向后*。因此，通过改变变量[2.x.52]来反向解决这个问题是有意义的，现在[2.x.53]表示打击时间[2.x.54]之前的时间。
* 通过所有这些，我们最终得到了以下问题。
* [1.x.31]
*
* 从概念上讲，这是一个变量[2.x.55]的平流-扩散-反应问题：有一个二阶导数的扩散项，一个一阶导数的平流项，以及一个零阶反应项。但是，由于问题中的平流项，我们将不得不小心地进行网格细化和时间步长的选择。还有一个问题是，扩散项是以非保守形式写成的，因此按部分积分并不明显。这将在下一节中讨论。
*[1.x.32][1.x.33]
*

* 我们将使用IMEX方法解决这个问题。特别是，我们首先用theta方法进行时间离散，随后将为平流和扩散项选择不同的theta值。
* [1.x.34]
* 这里，[2.x.58]是时间步长。鉴于这种时间离散化，我们可以通过与测试函数相乘，然后通过部分积分来进行空间离散化。因为在这个方程中，有一些有趣的细节，由于这个方程中的平流和非平流项，这个过程将被详细解释。
* 因此，我们首先用测试函数相乘，[2.x.59] 。
* [1.x.35]
*
*

* 像往常一样，（1）变成了[2.x.60]，（4）变成了[2.x.61]，其中[2.x.62]，我们不仅用[2.x.63]表示函数[2.x.64]，还用离散化后的节点值向量表示，这是一种自由。
* 有趣的部分来自于（2）和（3）。
*

* 对于（2），我们有。
* [1.x.36]
*
* 这里有两个积分，或多或少都是一样的，区别在于积分前面的系数略有不同，以及V的时间步骤不同。因此，考虑一般的积分，我们将用部分积分的方法来解决。
* [1.x.37]
*
* 因此，在加入常数并将[2.x.65]换成[2.x.66]（如适用）后，我们得出以下（2）的结果。
* [1.x.38]
* 但是，由于矩阵[2.x.67]涉及一个平流项，我们将选择[2.x.68]。
*
* --换句话说，我们使用显式欧拉方法来处理平流问题。相反，由于矩阵[2.x.69]涉及扩散项，我们将选择[2.x.70]在那里
*
* - 即我们用二阶Crank-Nicolson方法来处理扩散问题。
* 因此，我们得出以下结果。
* [1.x.39]
*
* 现在，要处理（3）。为此，我们将再次通过考虑上述的一般情况来进行。
* [1.x.40]

* 因此，在加入常数并将[2.x.71]换成[2.x.72]（如适用）后，我们对（3）得出如下结果。
* [1.x.41]
* 与之前一样，我们将用[2.x.73]表示矩阵[2.x.74]，用[2.x.75]表示矩阵[2.x.76]。因此，我们对(3)得出以下结果。
* [1.x.42]
*
* 现在，把所有的东西放在一起，我们得到布莱克-斯科尔斯方程的以下离散形式。
* [1.x.43]
* 因此，我们总共有。
* [1.x.44]
*
* 像往常一样，我们可以把未知量写在左边，把已知量写在右边。这导致了在每个时间步长中必须解决的以下线性系统。
* [1.x.45]
*
*


*

*[1.x.46][1.x.47]
* 对于这个程序，我们将使用制造解决方案的方法（MMS）来测试它是否正确工作。这意味着我们将选择我们的解决方案是类似于 [2.x.77] 的某个函数。对于我们的案例，我们将使用。
* [1.x.48]
* 这意味着，使用我们的PDE，我们得出以下问题。
* [1.x.49]
* 其中，[2.x.78] .这个设置现在有方程本身和[2.x.79]处的边界条件的右手边，这是我们之前没有的，还有不符合实际情况的 "最终 "条件（或者，用[2.x.80]的时间 "初始条件"）。我们将以这样的方式在代码中实现这一点，以方便交换
*
* - 上述变化的引入只是为了能够使用一个制造的解决方案。
* 如果程序工作正常，那么它应该产生（**）作为解决方案。这确实意味着我们需要对我们的变异形式进行一些修改，以考虑到非零的右手边。
* 首先，我们定义如下。
* [1.x.50]
* 因此，我们得出了新的方程。
* [1.x.51]
*
* 然后我们按照上面的方法解决这个方程。
*

* [1.x.52] [1.x.53]。
* [1.x.54] [1.x.55]。



* 该程序以通常的包含文件开始，所有这些文件你现在应该都见过了。
*


* [1.x.56]
*
* 然后照例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入我们将要工作的空间。我们还定义了一个标识符，以便在定义[2.x.81]时可以运行MMS代码。否则，该程序就会解决原来的问题。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 本节为使用MMS进行测试时的已知解决方案创建一个类。这里我们使用[2.x.82]作为解决方案。我们需要包括求解方程和梯度，以便进行H1半正态计算。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。



* 在下面的类和函数中，我们实现了定义这个问题的右手边和边界值，为此我们需要函数对象。右手边的选择是在介绍的最后讨论的。   
* 首先，我们处理初始条件。
*


* [1.x.63]
*
* 接下来，我们处理左边的边界条件。
*


* [1.x.64]
*
* 然后，我们处理正确的边界条件。
*


* [1.x.65]

* 最后，我们处理右手边的问题。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 下一块是这个程序的主类的声明。这与[2.x.83]的教程非常相似，只是做了一些修改。必须添加新的矩阵来计算A和B矩阵，以及介绍中提到的[2.x.84]向量。我们还定义了问题中使用的参数。
*


*


*


*


*


*


*


*
* - [2.x.85] ：空间领域的强加上限。这是允许的最大股票价格。
*


*
* - [2.x.86] ：时间域的上限。这就是期权到期的时间。
*


*
* - [2.x.87] ：股票价格的波动性./n
*


*
* - [2.x.88] ：无风险利率。
*


*
* - [2.x.89] ：买方在到期时可选择购买股票的约定价格。   
* 本程序与[2.x.90]之间的一些细微差别是创建了[2.x.91]，这在介绍中有所描述。然后，我们还需要存储当前时间，时间步长的大小，以及当前时间步长的数量。接下来，我们将把输出存储到[2.x.92]变量中，因为我们将把每个时间的解分层在上面，形成解流形。然后，我们有一个变量来存储当前的周期和我们在计算解决方案时将运行的周期数。循环是给定一个网格的一个完整的解决方案计算。我们在每个周期之间细化一次网格，以展示我们程序的收敛特性。最后，我们将收敛数据存储到一个收敛表中。   
* 就成员函数而言，我们有一个函数可以计算每个周期的收敛信息，称为[2.x.93] 。这就像在 [2.x.94] 中所做的那样。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 现在，我们进入主类的实现。我们将为问题中使用的各种参数设置值。选择这些是因为它们是这些参数的相当正常的值。虽然股票价格在现实中没有上限（事实上是无限的），但我们施加了一个上限，即行权价格的两倍。选择两倍的行权价有点随意，但它足够大，可以看到解决方案的有趣部分。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 下一个函数设置了DoFHandler对象，计算了约束条件，并将线性代数对象设置为正确的大小。我们还在这里通过调用库中的一个函数来计算质量矩阵。接下来我们将计算其他三个矩阵，因为这些矩阵需要 "手工 "计算。   
* 注意，时间步长在这里被初始化，因为计算时间步长需要成熟时间。
*


* [1.x.75]

* 下面是创建非常数系数的拉普拉斯矩阵的代码。这与介绍中的矩阵D相对应。这个非恒定系数在[2.x.95]变量中表示。
*


* [1.x.76]

* 现在我们将创建A矩阵。下面是创建矩阵A的代码，在介绍中已经讨论过。非恒定系数再次用[2.x.96]这个变量表示。
*


* [1.x.77]

* 最后我们将创建矩阵B。下面是创建矩阵B的代码，在介绍中已经讨论过。非恒定系数再次用[2.x.97]这个变量表示。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]。


*
* 下一个函数是解决单个时间步长的实际线性系统的函数。这里唯一有趣的是，我们建立的矩阵是对称正定的，所以我们可以使用共轭梯度法。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 这是一个简单的函数，用于将解决方案的碎片拼接起来。为此，我们在每个时间段创建一个新的层，然后添加该时间段的解决方案向量。然后，该函数使用 "build_patches "将其与旧的解决方案缝合在一起。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 对于我们所做的全局细化来说，有一个函数是有些不必要的。之所以有这个函数，是为了允许以后有可能进行适应性细化。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。



* 这是我们计算收敛和误差数据的地方，以评估程序的有效性。在这里，我们计算[2.x.98]、[2.x.99]和[2.x.100]的准则。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 接下来的部分是建立收敛和误差表。通过这个，我们需要设置如何输出在 [2.x.101] 期间计算的数据。首先，我们将创建标题并正确设置单元格。在这期间，我们还将规定结果的精度。然后，我们将把基于[2.x.102]、[2.x.103]和[2.x.104]规范的计算误差写到控制台和误差LaTeX文件中。
*


* [1.x.93]

* 接下来，我们将制作收敛表。我们将再次把这个写到控制台和收敛的LaTeX文件中。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。



* 现在我们进入了程序的主要驱动部分。在这里，我们完成了所有的工作，即通过时间步数的循环和每次计算解的向量。在这里的顶部，我们设置初始细化值，然后创建一个网格。然后我们对这个网格进行一次细化。接下来，我们设置了data_out_stack对象来存储我们的解决方案。最后，我们启动一个for循环来循环处理这些循环。这让我们为每一个连续的网格细化重新计算出一个解决方案。在每次迭代开始时，我们需要重新设置时间和时间步长。我们引入一个if语句来完成这个任务，因为我们不希望在第一次迭代时就这样做。
*


* [1.x.97]
*
* 接下来，我们运行主循环，该循环一直运行到超过成熟时间。我们首先计算方程的右边，这在导言中已经描述过。回顾一下，它包含术语[2.x.105] 。我们把这些项放到变量system_rhs中，借助于一个临时向量。
*


* [1.x.98]
*
* 第二块是计算源项的贡献。这对应于术语 [2.x.106] 。下面的代码调用[2.x.107]来计算向量[2.x.108]，在这里我们在评估之前设置右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。
*


* [1.x.99]
*
* 接下来，我们将强迫项添加到来自时间步长的强迫项中，同时建立矩阵[2.x.109]，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。
*


* [1.x.100]
*
* 在我们解决这个问题之前，还有一个操作需要做：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。
*


* [1.x.101]
*
* 有了这些，我们要做的就是求解系统，在最后一个周期生成图形数据，并创建收敛表数据。
*


* [1.x.102]
*
* [1.x.103] [1.x.104]。


*
*走到这一步，这个程序的主函数又没有什么好讨论的了：它看起来就像自[2.x.110]以来的所有此类函数。
*


* [1.x.105]
* [1.x.106][1.x.107] 。


*
* 以下是该程序的输出。
* [1.x.108]
*
* 更有趣的是收敛表的输出。它们被输出到控制台，以及一个LaTeX文件中。收敛表显示在上面。在这里，你可以看到，相对于[2.x.112]-norm，解决方案的收敛率为[2.x.111]，相对于[2.x.114]-norm，解决方案的收敛率为[2.x.113]。
*

* 以下是解决方案的可视化。
* [2.x.115]
*

* [1.x.109][1.x.110] [2.x.116] 。
* [0.x.1]

