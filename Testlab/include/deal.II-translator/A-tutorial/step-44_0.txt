include/deal.II-translator/A-tutorial/step-44_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45][1.x.46][1.x.47][1.x.48][1.x.49][1.x.50][1.x.51]
* [2.x.2]
* [1.x.52]
* [2.x.3]
* [1.x.53][1.x.54][1.x.55] 。
*

* 本教程的主题是非线性固体力学。经典的单场方法（例如，见[2.x.4)不能正确描述准不可压缩材料的响应，其响应过于僵硬；这种现象被称为锁定。
* 本报告的目的是为使用deal.II处理非线性固体力学问题提供基础。线性问题在[2.x.5]中得到了解决。在[2.x.6]中部分考虑了几何非线性问题的非标准、超弹性类型的形式：使用线性化构成关系的速率形式，问题域随运动变化而变化。围绕非线性运动学的重要概念在理论和实施中都没有。然而，[2.x.7]确实描述了许多关键概念，以便在交易框架内实现弹性。
* 我们从非线性运动学的速成课程开始。为了简单起见，我们将注意力限制在准静态问题上。此后，我们介绍了各种关键的应力措施，并描述了构成模型。
* [2.x.8] 本教程是针对三维空间的弹性问题而开发的（并在介绍中进行了描述）。虽然空间维度可以在main()例程中改变，但需要注意的是。一般来说，二维弹性问题只是作为三维问题的理想化而存在。也就是说，它们要么是平面应变，要么是平面应力。这些选择中的任何一个的假设都需要被一致地施加。更多信息见 [2.x.9] 中的说明。
* [1.x.56][1.x.57] 。
*

* 这里实施的三场公式是由Simo等人（1985年）开创的，被称为混合雅各布-压力公式。重要的相关贡献包括Simo和Taylor（1991年）以及Miehe（1994年）。这里采用的符号在很大程度上借鉴了Holzapfel（2001年）对非线性固体力学理论方面的出色概述。
* [2.x.10] [2.x.11] J.C. Simo, R.L. Taylor and K.S. Pister (1985), Variational and projection methods for the volume constraint in finite deformation elasto-plasticity,［2.x.12DOI: [1.x.58]; [2.x.14] J.C. Simo and R.L. Taylor (1991), 本质拉伸中的准不可压缩的有限弹性。Continuum basis and numerical algorithms, [2.x.15] Computer Methods in Applied Mechanics and Engineering [2.x.16] , <strong> 85 </strong>, 3, 273-310. DOI: [1.x.59]; [2.x.17] C. Miehe（1994）, Aspects of the formulation and finite element implementation of large strain isotropic elasticity [2.x.18国际工程数值方法杂志 [2.x.19] <strong> 37 </strong>, 12, 1981-2004. DOI: [1.x.60]; [2.x.20] G.A. Holzapfel（2001），非线性固体力学。ISBN: 0-471-82304-X; [2.x.21] T.J.R.Hughes (2000), The Finite Element Method., A Continuum Approach for Engineering, John Wiley & Sons:ISBN: 978-0486411811 [2.x.22] T.J.R. Hughes (2000), The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Dover.
* 一个在耦合问题中使用这种三场公式的例子记录在[2.x.23] [2.x.24] J-P.V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), Computational electro-and magneto-elasticity for quasi-incompressible media immersed in free space, [2.x.25] International Journal for Numerical Methods in Engineering [2.x.26] 。 DOI: [1.x.61] [2.x.27] 。
* [1.x.62][1.x.63] 。
*

* 我们可以把四阶张量看作是将二阶张量（矩阵）映射到自己身上的线性算子，其方式与矩阵将向量映射到向量上一样。]和[2.x.29]由[1.x.64]定义，注意[2.x.30]。此外，我们用[1.x.65]定义对称和偏斜对称的四阶单位张量，这样[1.x.66]由identity_tensor()返回的四阶[2.x.31]是[2.x.32] 。
*

*[1.x.67][1.x.68]


*让时间域表示为[2.x.33]，其中[2.x.34]和[2.x.35]是总的问题持续时间。考虑一个连续体，在时间[2.x.37]占据参考配置[2.x.36]。%参考配置中的粒子由位置矢量[2.x.38]识别。称为当前配置，表示为[2.x.40]，粒子由矢量[2.x.41]识别。参考配置和当前配置之间的非线性映射，表示为[2.x.42]，作用如下：[1.x.69]粒子位移的材料描述定义为[1.x.70] 。]
* 变形梯度[2.x.43]被定义为运动的材料梯度：[1.x.71]变形梯度[2.x.44]的行列式在参考配置和当前配置中对应的体积元素，分别表示为[2.x.45]和[2.x.46]，为[1.x.72] 。
* 就空间和材料坐标而言，变形的两个重要衡量标准是左和右Cauchy-Green张量，分别表示为[2.x.47]和[2.x.48] .它们都是对称和正定的。
* 格林-拉格朗日应变张量定义为[1.x.73]，如果假设变形量为无穷小，那么右边的第二个项可以忽略，[2.x.49]（线性化应变张量）是应变张量的唯一组成部分。从问题的设置来看，这一假设在[2.x.50]中是无效的，因此在该教程程序中使用线性化[2.x.51]作为应变度量是值得怀疑的。
* 为了处理材料在受到体型和剪切型变形时表现出的不同响应，我们考虑将变形梯度[2.x.52]和左Cauchy-Green张量[2.x.53]分解为体积变化（volumetric）和体积保持（isochoric）部分：[1.x.74] 显然，[2.x.54] 。
* 空间速度场表示为[2.x.55] .空间速度场相对于空间坐标的导数给出了空间速度梯度[2.x.56] ，即[1.x.75] 其中[2.x.57] .
*

*[1.x.76][1.x.77] 。


* 考奇应力定理将作用在当前构型[2.x.59]中无限小的表面元素上的考奇牵引力[2.x.58]等同于考奇应力张量[2.x.60]（一个空间量）与表面的外向单位法线[2.x.61]的乘积，即[1.x.78]考奇应力是对称的。] 作用于参考构型[2.x.63]中的无限小的表面元素，是第一Piola-Kirchhoff应力张量[2.x.64]（两点张量）与表面的外向单位法线[2.x.65]的乘积，如[1.x.79]Cauchy牵引[2.x.66]和第一Piola-Kirchhoff牵引[2.x.67]的关系为[1.x.80] 这可以用[1.x.81] 来证明。
* 第一Piola-Kirchhoff应力张量与Cauchy应力的关系为[1.x.82]，其他重要的应力测量是（空间）Kirchhoff应力[2.x.68]和（参考）第二Piola-Kirchhoff应力[2.x.69] 。
*

*[1.x.83][1.x.84] 。


* 前推和后拉运算允许人们在材料和空间设置之间转换各种措施。这里使用的应力措施是忌变的，而应变措施是协变的。
* 二阶协变张量的前推和后拉运算[2.x.70]分别由以下公式给出：[1.x.85] 。
* 二阶不变量张量[2.x.71]的前推和后拉操作分别由：[1.x.86]例如[2.x.72] 。
*

*[1.x.87][1.x.88] 。


* 例如，如果亥姆霍兹自由能取决于右Cauchy-Green张量[2.x.74]，那么各向同性的超弹性反应就是[1.x.89]。如果亥姆霍兹自由能取决于左Cauchy-Green张量[2.x.75]，那么各向同性的超弹性反应就是[1.x.90] 。
* 按照变形梯度的乘法分解，亥姆霍兹自由能可以分解为[1.x.91]同样，基尔霍夫应力可以分解为体积部分和等熵部分[2.x.76]，其中。
* [1.x.92]
*其中[2.x.77]是压力反应。[2.x.78]是投影张量，它提供了欧拉设置中的偏差算子。虚构的基尔霍夫应力张量[2.x.79]由[1.x.93]定义。
*

*
* [2.x.80] 上面定义的压力响应不同于固体力学中广泛使用的压力定义[2.x.81] .这里[2.x.82]是静水压力。我们在本教程中使用压力响应（尽管我们把它称为压力）。
* [1.x.94][1.x.95] 。
*

* 与可压缩性[1.x.96]相对应的亥姆霍兹自由能由[1.x.97]给出，其中[2.x.83]是体积模量（[2.x.84]和[2.x.85]是Lam&eacute;参数）和[2.x.86] .函数[2.x.87]被要求是严格凸的并满足[2.x.88]等条件，进一步细节见 Holzapfel （2001）. 在这项工作[2.x.89] .
* 不可压缩性对所有运动施加了等时约束[2.x.90] [2.x.91] .对应于不可压缩的新胡克材料的Helmholtz自由能由[1.x.98]给出，其中[2.x.92] .因此，不可压缩响应是通过从可压缩自由能中去除体积成分并强制执行[2.x.93] 得到的。
*

*[1.x.99][1.x.100]


* 我们将使用牛顿-拉弗森策略来解决非线性边界值问题。因此，我们需要线性化构成关系。
* 材料描述中的四阶弹性张量定义为[1.x.101]空间描述中的四阶弹性张量[2.x.94]由[2.x.95]的前推得到[1.x.102]四阶弹性张量（对于超弹性材料）拥有主要对称性和次要对称性。
* 四阶空间弹性张量可以写成以下解耦形式：[1.x.103]其中
* [1.x.104]
*其中空间描述中的虚构弹性张量[2.x.96]由[1.x.105]定义。
*[1.x.106][1.x.107] 。
*

* 系统的总势能[2.x.97]是内部和外部势能的总和，分别表示为[2.x.98]和[2.x.99]。我们希望通过最小化势能找到平衡配置。
* 如上所述，我们采用三场公式。我们用[2.x.100]表示主要未知数集。独立运动变量[2.x.101]作为对[2.x.102]的约束进入公式，由拉格朗日乘数[2.x.103]（压力，我们将看到）执行。
* 这里使用的三场变分原理由[1.x.108]给出，其中外部势由[1.x.109]定义。当前配置[2.x.104]的边界由两部分组成，即[2.x.105]，其中[2.x.106].规定的Cauchy牵引力，表示为[2.x.107]，被应用于[2.x.108]，而运动被规定在边界的其余部分[2.x.109].每单位当前体积的体力表示为[2.x.110] 。
*

*
*势的静止性如下
* [1.x.110]
* 对于所有虚拟位移[2.x.111]，受[2.x.112]对[2.x.113]的约束，以及所有虚拟压力[2.x.114]和虚拟膨胀[2.x.115]。
* 人们应该注意到，三场公式中的体积基尔霍夫应力[2.x.116]和随后的体积正切的定义与超弹性材料一节中给出的一般形式略有不同，其中[2.x.117].这是因为压力[2.x.118]现在是一个主要场，而不是一个构成性的派生量。人们需要仔细区分主要场和那些从构成性关系中获得的场。
* [2.x.119] 虽然变量都是用空间量表示的，但积分域是初始配置。这种方法被称为[2.x.120] 总拉格朗日公式[2.x.121] 。[2.x.122] 中给出的方法，其积分域是当前配置，可称为[2.x.123] 更新拉格朗日公式[2.x.124] 。这两种方法的各种优点在文献中被广泛讨论。但应注意，它们是等同的。
*

* 与残余物相对应的欧拉-拉格朗日方程是：。
* [1.x.111]
* 第一个方程是空间设置中的（准静态）平衡方程。第二个是约束条件，即 [2.x.125] .第三个是压力的定义 [2.x.126] 。
* [2.x.127] 下面简化的单场推导（[2.x.128]是唯一的主要变量）使我们清楚地知道如何将积分的极限转化为参考域。
* [1.x.112]
* 其中[2.x.129] 。
* 我们将使用迭代牛顿-拉弗森方法来解决非线性残差方程 [2.x.130] .为了简单起见，我们假设死荷载，即荷载不因变形而改变。
* 在[2.x.131]的已知状态和[2.x.132]的当前未知状态之间的量的变化表示为[2.x.133] .在当前迭代[2.x.134]的量的值表示为[2.x.135] .迭代[2.x.136]和[2.x.137]之间的增量变化表示为[2.x.138] 。
* 假设在某个迭代[2.x.139]中系统的状态是已知的。使用牛顿-拉弗森方法解决非线性治理方程的线性化近似是：找到[2.x.140]，使[1.x.113]，然后设置[2.x.141].切线由以下方法给出
* [1.x.114]因此。
* [1.x.115]
*其中
* [1.x.116]
*
* 请注意，以下条款被称为几何应力和材料对切线矩阵的贡献。
* [1.x.117]
*
*

*[1.x.118][1.x.119]


* 这里使用的三场公式对准不可压缩材料是有效的，即在[2.x.142]（其中[2.x.143]是[1.x.120]）的情况下，对[2.x.144]和[2.x.145]的插值场进行良好选择。通常选择[2.x.146] 。一个流行的选择是[2.x.148]，它被称为平均扩张法（见Hughes（2000）的直观讨论）。
* 对于完全不可压缩的材料，[2.x.152]和三场公式仍然会表现出锁定行为。这可以通过在自由能中引入一个额外的约束条件来克服，其形式为[2.x.153]。
* 线性化问题可以写成[1.x.121]，其中
* [1.x.122]

* 因此，压力和膨胀的不连续有限元插值产生了[2.x.155]、[2.x.156]和[2.x.157]的块对角矩阵，因此我们可以很容易地表达每个单元上的场[2.x.158]和[2.x.159]，只需反转一个局部矩阵并乘以局部右手。然后，我们可以将结果插入其余的方程中，并恢复一个经典的基于位移的方法。为了在元素层面凝结出压力和膨胀贡献，我们需要以下结果。
* [1.x.123]
* 因而[1.x.124]其中[1.x.125]注意，由于[2.x.160]和[2.x.161]被选择为元素级的不连续，所有需要反转的矩阵都在元素级定义。
*构建各种贡献的程序如下。
*
* - 构建 [2.x.162] 。
*
* - 为元素形成[2.x.163]，并将[2.x.164]存储在[2.x.165]的地方 .
*
* - 形成 [2.x.166] 并添加到 [2.x.167] 得到 [2.x.168] 。
*
* - 修改后的系统矩阵被称为 [2.x.169] 。  也就是 [1.x.126] 。
*

* [1.x.127][1.x.128] 。


* 在本教程中，我们只有一个名为Material_Compressible_Neo_Hook_Three_Field的材料类，理想情况下，这个类会派生自HyperelasticMaterial类，而HyperelasticMaterial则派生自基类Material。
* 三场公式的Helmholtz自由能函数是[2.x.170].Kirchhoff应力的等效部分[2.x.171]与使用超弹性材料的单场公式得到的是一样的。因此，对于三场公式来说，基尔霍夫应力[2.x.173]的体积部分（和正切）的构成反应并不像单场公式那样由超弹性构成法给出。我们可以将术语[2.x.174]标记为体积基尔霍夫应力，但是压力[2.x.175]并不是由自由能得出；它是一个主场。
*为了有一个灵活的方法，决定Material_Compressible_Neo_Hook_Three_Field仍然能够计算并返回体积Kirchhoff应力和切线。为了做到这一点，我们选择将内插的主场[2.x.176]和[2.x.177]存储在与正交点相关的Material_Compressible_Neo_Hook_Three_Field类中。这个决定应该在以后的阶段，当教程被扩展到考虑其他材料时再进行讨论。
*

*[1.x.129][1.x.130]


*这里考虑的数值例子是一个压缩下的几乎不可压缩的块。这个基准问题取自于
*
* - S. Reese, P. Wriggers, B.D. Reddy (2000), A new locking-free brick element technique for large deformation problems in elasticity, [2.x.178] Computers and Structures [2.x.179] , <strong> 75</strong>, 291-304.  DOI：[1.x.131] 。
* [2.x.180]
* 该材料是准不可压缩的新胡克式，具有[1.x.132] [2.x.181]和[2.x.182] .对于这样一个材料属性的选择，传统的单场[2.x.183]方法将被锁定。初始和最终配置如上图所示。利用对称性，我们只求解四分之一的几何体（即尺寸为[2.x.184]的立方体），域上表面的内四分之一受到[2.x.185]的载荷。
*

* [1.x.133] [1.x.134]。
* 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。它们已经在以前的教程程序中详细讨论过了，所以你只需要参考过去的教程就可以了。
*


* [1.x.135]
*
* 这个标头给我们提供了在正交点存储数据的功能
*


* [1.x.136]
*
* 这里是使用LinearOperator类所需的头文件。这些也都被方便地打包到一个头文件中，即<deal.II/lac/linear_operator_tools.h>，但为了透明起见，我们在此列出那些特别需要的头文件。
*


* [1.x.137]
*
* 这两个标题中定义了一些与有限应变弹性相关的操作。第一个将帮助我们计算一些运动量，第二个提供一些标准的张量定义。
*


* [1.x.138]
*
* 然后我们把所有与这个教程程序有关的东西都塞进一个自己的命名空间，并把所有deal.II的函数和类名导入其中。
*


* [1.x.139]
*
* [1.x.140] [1.x.141].
* 有几个参数可以在代码中设置，所以我们设置了一个ParameterHandler对象，在运行时读入选择。
*


* [1.x.142]
*
* [1.x.143] [1.x.144]。


*
* 正如介绍中提到的，对于位移[2.x.186]应该使用不同的阶次插值，而不是压力[2.x.187]和膨胀[2.x.188]。  选择[2.x.189]和[2.x.190]作为元素层面的不连续（常数）函数，导致平均扩张方法。不连续的近似允许[2.x.191]和[2.x.192]被浓缩出来，并恢复了一个基于位移的经典方法。这里我们指定用于近似解的多项式阶数。正交阶数应作相应调整。
*


* [1.x.145]
*
* [1.x.146] [1.x.147]。



*对问题的几何形状和施加的载荷进行调整。  由于这里所模拟的问题相当特殊，因此可以将荷载比例改变为特定的数值，以便与文献中给出的结果进行比较。
*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 我们还需要新胡克材料的剪切模量[2.x.193]和泊松率[2.x.194]。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 接下来，我们选择求解器和预处理器的设置。  当牛顿增量中出现大的非线性运动时，使用有效的预处理程序对于确保收敛性至关重要。
*


* [1.x.154]

* [1.x.155] [1.x.156]。



* 使用牛顿-拉弗森方案来解决非线性治理方程组。  我们现在定义牛顿-拉普森非线性求解器的公差和最大迭代次数。
*


* [1.x.157]
*
* [1.x.158] [1.x.159]。


*
* 设置时间步长[2.x.195]和模拟结束时间。
*


* [1.x.160]
*
* [1.x.161] [1.x.162]。


*
* 最后，我们将上述所有的结构合并到一个容器中，该容器容纳我们所有的运行时选择。
*


* [1.x.163]
*
* [1.x.164] [1.x.165]。


*
* 一个简单的类来存储时间数据。它的功能是透明的，所以没有必要讨论。为了简单起见，我们假设一个恒定的时间步长。
*


* [1.x.166]
*
* [1.x.167] [1.x.168]。



* 正如在介绍中所讨论的，新胡克材料是一种超弹性材料。  整个领域被假定为由可压缩的新胡克材料组成。  这个类别定义了这种材料在三场公式中的行为。  可压缩的新胡克材料可以用应变能量函数（SEF）来描述 [2.x.196] 。   
* 等效响应由[2.x.197]给出，其中[2.x.198]和[2.x.199]是左或右等效Cauchy-Green变形张量的第一不变量。这就是[2.x.200] 。在这个例子中，支配体积响应的SEF定义为[2.x.201] ，其中[2.x.202]是[1.x.169]，[2.x.203]是[1.x.170] 。   
* 下面的类将被用来描述我们工作的材料的特征，并提供了一个中心点，如果要实现不同的材料模型，就需要对其进行修改。为了工作，我们将在每个正交点存储一个这种类型的对象，并在每个对象中存储当前状态（由三个场的值或度量来表征），以便我们能够计算围绕当前状态线性化的弹性系数。
*


* [1.x.171]
*
* 我们根据[2.x.204]以及压力[2.x.205]和膨胀[2.x.206]，用各种与变形有关的数据更新材料模型，并在函数的最后包括一个内部一致性的物理检查。
*


* [1.x.172]
*
* 第二个函数决定了基尔霍夫应力[2.x.207] 。
*


* [1.x.173]
*
*空间设置中的四阶弹性张量[2.x.208]由SEF[2.x.209]计算为[2.x.210] 其中[2.x.211]



* [1.x.174]
*
* 体积自由能相对于[2.x.212]的导数 返回[2.x.213]



* [1.x.175]
*
* 相对于[2.x.214]的体积自由能的二阶导数。我们需要在切线中明确地进行以下计算，所以我们将其公开。  我们计算[2.x.215]。
*


* [1.x.176]
*
* 接下来的几个函数返回各种数据，我们选择与材料一起存储。
*


* [1.x.177]
*
* 定义构成模型参数 [2.x.216] （体积模量）和新胡克模型参数 [2.x.217] 。
*


* [1.x.178]

* 模型的具体数据，方便与材料一起存储。
*


* [1.x.179]
*
* 以下函数在内部用于确定上述一些公共函数的结果。第一个是确定体积基尔霍夫应力 [2.x.218] 。
*


* [1.x.180]
*
* 接下来，确定等时基尔霍夫应力 [2.x.219] 。
*


* [1.x.181]
*
* 然后，确定虚构的基尔霍夫应力[2.x.220] 。
*


* [1.x.182]
*
*计算切线的体积部分 [2.x.221] 。
*


* [1.x.183]
*
*计算切线的等值部分 [2.x.222] 。
*


* [1.x.184]
*
* 计算虚构的弹性张量 [2.x.223] 。对于所选择的材料模型，这只是零。
*


* [1.x.185]
*
* [1.x.186] [1.x.187]。


*
* 正如在[2.x.224]中所看到的，[2.x.225]类提供了一种在正交点存储数据的方法。  这里每个正交点都持有一个指向材料描述的指针。  因此，不同的材料模型可以用在域的不同区域。  在其他数据中，我们选择为正交点存储Kirchhoff应力[2.x.226]和正切[2.x.227]。
*


* [1.x.188]
*
* 第一个函数用于创建一个材料对象并正确地初始化所有的张量。第二个函数根据当前的变形量[2.x.228]、压力[2.x.229]和扩张[2.x.230]场值更新存储的数值和应力。
*


* [1.x.189]
*
* 为此，我们从位移梯度[2.x.232]中计算出变形梯度[2.x.231]，即[2.x.233]，然后让与此正交点相关的材料模型自行更新。当计算变形梯度时，我们必须注意和[2.x.234]的数据类型：由于[2.x.235]的数据类型是SymmetricTensor，只要写出[2.x.236]就可以将第二个参数转换成对称张量，执行和，然后将结果投给Tensor（即可能是非对称张量的类型）。然而，由于[2.x.237]在一般情况下是非对称的，转换为SymmetricTensor将会失败。我们可以通过先将[2.x.238]转换为张量，然后像在非对称张量之间一样执行加法，来避免这种来回奔波。
*


* [1.x.190]
*
* 材料已经更新，所以我们现在计算基尔霍夫应力[2.x.239]，切线[2.x.240]和体积自由能的一、二次导数。       
* 我们还存储了变形梯度的逆值，因为我们经常使用它。
*


* [1.x.191]
*
* 我们提供一个接口来检索某些数据。  下面是运动学变量。
*


* [1.x.192]
*
* ...和动力学变量。  这些都用于材料和全局切线矩阵和残余装配操作。
*


* [1.x.193]

* 最后是切线。
*


* [1.x.194]
*
* 在成员函数方面，这个类为它所代表的正交点存储了一个材料类型的副本，以备在域的不同区域使用不同的材料，以及变形梯度的逆值...
*


* [1.x.195]
*
* ......和应力型变量与切线[2.x.241]一起。



* [1.x.196]
*
* [1.x.197] [1.x.198]。


*
* Solid类是中心类，它代表了手头的问题。它遵循通常的方案，即它真正拥有的是一个构造函数、解构函数和一个[2.x.242]函数，该函数将所有的工作分派给该类的私有函数。
*


* [1.x.199]
*
* 在这个类的私有部分，我们首先向前声明一些对象，这些对象在使用WorkStream对象进行并行工作时使用（关于这方面的更多信息，请参见[2.x.243]模块）。     
* 我们声明这样的结构，用于正切（刚度）矩阵和右手向量的计算，静态冷凝，以及更新正交点。
*


* [1.x.200]
*
* 我们以一个建立网格的成员函数开始收集。
*


* [1.x.201]
*
* 设置要解决的有限元系统。
*


* [1.x.202]
*
* 为增量位移场创建Dirichlet约束。
*


* [1.x.203]
*
* 有几个函数使用多线程来组装系统和右侧矩阵。它们中的每一个都是包装函数，一个是在WorkStream模型中对一个单元做工作时执行的，另一个是将对这一个单元做的工作复制到代表它的全局对象中。
*


* [1.x.204]
*
* 还有类似的执行全局静态凝结。
*


* [1.x.205]
*
* 创建并更新正交点。在这里，没有数据需要被复制到全局对象中，所以copy_local_to_global函数是空的。
*


* [1.x.206]
*
* 用Newton-Raphson方法求解位移。我们把这个函数分成非线性循环和解决线性化的Newton-Raphson步骤的函数。
*


* [1.x.207]
*
* 解决方案的检索以及后期处理和将数据写入文件。
*


* [1.x.208]
*
* 最后是一些描述当前状态的成员变量。用于描述问题设置的参数的集合...
*


* [1.x.209]
*
* ...参考配置的体积...
*


* [1.x.210]
*
* ......以及解决该问题所依据的几何形状的描述。
*


* [1.x.211]
*
* 同时，记录当前时间和评估某些函数的时间
*


* [1.x.212]
*
* 一个用于正交点信息的存储对象。与[2.x.244]相反，这里采用了deal.II的本地正交点数据管理器。
*


* [1.x.213]
*
* 对有限元系统的描述，包括位移多项式程度、自由度处理程序、每个单元的DoF数量以及用于从解向量中检索信息的提取器对象。
*


* [1.x.214]
*
* 描述块系统是如何安排的。有3个块，第一个包含一个矢量DOF [2.x.245] ，而另外两个描述标量DOF， [2.x.246] 和 [2.x.247] 。
*


* [1.x.215]
*
* 单元和面的高斯正交规则。单元和面的正交点的数量被记录下来。
*


* [1.x.216]
*
* 用于存储收敛的解和右手边向量以及切线矩阵的对象。有一个AffineConstraints对象，用于跟踪约束条件。  我们利用了为块状系统设计的稀疏性模式。
*


* [1.x.217]
*
* 然后定义一些变量来存储规范，并更新规范和归一化系数。
*


* [1.x.218]
*
* 计算误差措施的方法
*


* [1.x.219]
*
* 计算空间配置中的体积
*


* [1.x.220]
*
* 以一种令人愉悦的方式将信息打印到屏幕上...
*


* [1.x.221]
*
* [1.x.222] [1.x.223]。


*
* [1.x.224] [1.x.225]。


*
* 我们使用从参数文件中提取的数据来初始化Solid类。
*


* [1.x.226]
*
* 有限元系统由昏暗的连续位移DOF，以及不连续的压力和膨胀DOF组成。为了满足Babuska-Brezzi或LBB稳定性条件（见Hughes (2000)），我们设置了一个[2.x.248]系统。  [2.x.249]元素满足这一条件，而[2.x.250]元素不满足。然而，事实证明，后者还是表现出良好的收敛特性。
*


* [1.x.227]
*
* 在解决准静态问题时，时间成为一个加载参数，即我们随着时间线性增加加载量，使得这两个概念可以互换。我们选择用一个恒定的时间步长来线性增加时间。   
* 我们以预处理开始函数，设置初始扩张值，然后输出初始网格，再以第一次时间（和载荷）递增开始模拟。   
* 在对初始解场施加约束[2.x.251]时，必须注意（或者至少要考虑一下）。该约束对应于未变形构型中变形梯度的行列式，也就是身份张量。我们使用FE_DGPMonomial基数来插值扩张场，因此我们不能简单地将相应的dof设置为unity，因为它们对应于单项式系数。因此，我们使用[2.x.252]函数来为我们做这个工作。[2.x.253]函数需要一个表明悬挂节点约束的参数。我们在这个程序中没有 所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，必须先进行排序（使用[2.x.254]函数）才能使用。请看 [2.x.255] 以了解更多信息。我们只需要强制执行扩张的初始条件。为了做到这一点，我们使用ComponentSelectFunction，它作为一个掩码，将n_components的J_component设置为1。 这正是我们想要的。请看一下[2.x.256]中的用法，以了解更多信息。
*


* [1.x.228]
*
* 然后我们宣布增量解决方案更新[2.x.257]，并开始在时域上循环。     
* 在开始的时候，我们重新设定这个时间步骤的解决方案更新...
*


* [1.x.229]
*
* ...解决当前的时间步骤并更新总的解决方案向量 [2.x.258] ...
*


* [1.x.230]
*
* ......并在愉快地进入下一个时间步骤之前绘制结果。
*


* [1.x.231]
*
* [1.x.232] [1.x.233]。



* [1.x.234] [1.x.235]。


*
* 第一组私有成员函数与并行化有关。我们使用线程积木库（TBB）来执行尽可能多的计算密集型分布式任务。特别是，我们使用TBB组装正切矩阵和右手向量、静态凝结贡献，以及更新存储在正交点的数据。我们在这方面的主要工具是WorkStream类（更多信息见[2.x.259]线程模块）。
*

*
* 首先我们处理切线矩阵和右手边的装配结构。PerTaskData对象存储了本地对全局系统的贡献。
*


* [1.x.236]
*
* 另一方面，ScratchData对象存储了较大的对象，如形状函数值数组（ [2.x.260] ）和形状函数梯度和对称梯度向量，我们将在装配时使用这些对象。
*


* [1.x.237]
*
* 然后我们定义结构来组装静态凝结的切线矩阵。回顾一下，我们希望解决一个基于位移的公式。由于[2.x.261]和[2.x.262]字段是元素间不连续的，所以我们在元素层面上进行缩合。  由于这些操作是基于矩阵的，我们需要设置一些矩阵来存储一些切线矩阵子块的局部贡献。  我们将这些放在PerTaskData结构中。   
* 我们选择不在[2.x.263]函数中重置任何数据，因为矩阵提取和替换工具会处理这个问题。
*


* [1.x.238]
*
* 我们希望在这里执行的操作的ScratchData对象是空的，因为我们不需要临时数据，但它仍然需要为当前deal.II中TBB的实现进行定义。  所以我们为此创建了一个假结构。
*


* [1.x.239]
*
* 最后我们定义结构以协助更新正交点信息。与SC的装配过程类似，我们不需要PerTaskData对象（因为这里没有什么可存储的），但还是必须定义一个。请注意，这是因为对于我们这里的操作来说
*
*-更新正交点的数据
*
* 该操作是纯粹的本地操作：我们在每个单元上做的事情在每个单元上都会被消耗掉，没有任何全局的聚合操作，就像使用WorkStream类时通常的情况一样。我们仍然必须定义每个任务的数据结构，这表明WorkStream类可能不适合这种操作（原则上，我们可以简单地使用[2.x.264]为每个单元创建一个新的任务），但无论如何这样做并没有什么坏处。此外，如果有不同的材料模型与一个正交点相关联，需要不同程度的计算费用，那么这里使用的方法可能是有利的。
*


* [1.x.240]
*
* ScratchData对象将被用来存储解向量的别名，这样我们就不必复制这个大的数据结构。然后我们定义一些向量来提取正交点的解值和梯度。
*


* [1.x.241]
*
* [1.x.242] [1.x.243]。



* 进入第一个私有成员函数。在这里我们创建域的三角形，为此我们选择了按比例的立方体，每个面都有一个边界ID号。  对于压痕问题，网格必须至少被细化一次。   
* 然后我们确定参考配置的体积并打印出来进行比较。
*


* [1.x.244]
*
* 因为我们希望将诺伊曼BC应用于顶面的一个补丁，所以我们必须找到域的这一部分的单元面，并用一个明显的边界ID号来标记它们。  我们要找的面在+y面上，将得到边界ID 6（0到5已经在创建立方体域的六个面时使用了）。
*


* [1.x.245]
*
* [1.x.246] [1.x.247]。


*
* 接下来我们描述FE系统是如何设置的。  我们首先确定每块的分量数量。由于位移是一个矢量分量，前两个分量属于它，而后两个分量描述标量压力和扩张DOF。
*


* [1.x.248]
*
* 然后，DOF处理程序被初始化，我们以一种有效的方式对网格进行重新编号。我们还记录了每块DOF的数量。
*


* [1.x.249]
*
* 设置稀疏模式和切线矩阵
*


* [1.x.250]
*
* 全局系统矩阵最初具有以下结构


* [1.x.251]
* 我们优化了稀疏模式以反映这种结构，并防止为右对角块成分创建不必要的数据。
*


* [1.x.252]
*
* 然后我们设置了存储向量
*


* [1.x.253]
*
* ...最后设置正交点历史。



* [1.x.254]
*
* [1.x.255] [1.x.256] 接下来，我们从FE系统中计算出一些信息，描述哪些局部元素DOF是连接到哪个块组件。  这将在后面用于从全局矩阵中提取子块。   
* 从本质上讲，我们所需要的是FESystem对象指出参考单元上的DOF连接到哪个块状部件上。  目前，插值场的设置是这样的：0表示位移DOF，1表示压力DOF，2表示膨胀DOF。
*


* [1.x.257]
*
* [1.x.258] [1.x.259] 用于存储正交信息的方法已经在 [2.x.265] 中描述。这里我们为SMP机器实现一个类似的设置。   
* 首先，实际的QPH数据对象被创建。这必须在网格被细化到最细的程度后才能完成。
*


* [1.x.260]

* 接下来我们设置初始正交点数据。请注意，当正交点数据被检索时，它将作为一个智能指针的向量返回。
*


* [1.x.261]
*
* [1.x.262] [1.x.263] 由于QP信息的更新经常发生，并涉及一些昂贵的操作，我们定义了一个多线程的方法，将任务分布在若干CPU核心上。   
* 要开始这样做，首先我们需要获得这个牛顿增量时的总解，然后创建初始的从头开始和复制数据对象的副本。
*


* [1.x.264]
*
* 然后我们将它们和单细胞更新函数传递给WorkStream进行处理。
*


* [1.x.265]
*
* 现在我们描述一下我们如何从解决方案向量中提取数据并将其传递给每个QP存储对象进行处理。
*


* [1.x.266]
*
* 我们首先需要找到当前单元内正交点的数值和梯度，然后利用位移梯度和总压力及扩张解数值更新每个局部QP。
*


* [1.x.267]
*
* [1.x.268] [1.x.269]。


*
* 下一个函数是牛顿-拉弗逊方案的驱动方法。在它的顶部，我们创建一个新的向量来存储当前的牛顿更新步骤，重置错误存储对象并打印求解器头。
*


* [1.x.270]
*
* 我们现在进行一些牛顿迭代来迭代解决这个非线性问题。  由于问题是完全非线性的，而且我们使用的是完全牛顿方法，所以存储在正切矩阵和右手边向量中的数据是不能重复使用的，必须在每个牛顿步骤中清除。然后，我们最初建立线性系统并检查收敛性（并在第一次迭代中存储这个值）。rhs向量的无约束DOF保存了失去平衡的力，并共同决定是否达到了平衡解。     
* 尽管对于这个特定的问题，我们可以在组装系统矩阵之前构建RHS向量，但为了扩展性，我们选择不这样做。分别组装RHS向量和系统矩阵的好处是，后者是一个昂贵的操作，我们可以通过在达到收敛时不组装切线矩阵来避免一个额外的组装过程。然而，这使得使用MPI并行化代码变得更加困难。此外，当把问题扩展到瞬态情况时，由于时间离散化和对速度和加速度场的约束应用，可能会对RHS产生额外贡献。
*


* [1.x.271]
*
* 我们构建线性系统，但暂不求解它（这个步骤应该比组装要贵得多）。
*


* [1.x.272]
*
* 我们现在可以确定归一化的残余误差并检查解决方案的收敛性。
*


* [1.x.273]
*
* 如果我们已经决定要继续迭代，我们就解决线性化系统。
*


* [1.x.274]
*
* 我们现在可以确定归一化的牛顿更新误差。
*


* [1.x.275]
*
* 最后，由于我们隐含地接受了求解步骤，我们可以对当前时间步骤的求解增量进行实际更新，更新与这个新位移和应力状态有关的所有正交点信息，并继续迭代。
*


* [1.x.276]
*
* 在最后，如果发现我们事实上做了比参数文件允许的更多的迭代，我们会引发一个异常，可以在main()函数中捕获。调用<code>AssertThrow(condition, exc_object)</code>实质上等同于<code>if (!cond) throw exc_object;</code>，但前一种形式在异常对象中填充了某些字段，这些字段标识了异常发生的位置（文件名和行号），以便更简单地识别问题发生的位置。
*


* [1.x.277]
*
* [1.x.278] [1.x.279]。


*
* 这个程序在一个漂亮的表格中打印出数据，这个表格在每次迭代的基础上更新。接下来的两个函数设置了表头和表脚。
*


* [1.x.280]
*
* [1.x.281] [1.x.282]。


*
*计算空间配置中的域的体积
*


* [1.x.283]
*
* 与之前调用的不同，在这个例子中，正交点数据是特别不可修改的，因为我们将只访问数据。我们通过将这个更新函数标记为常量来确保正确的get_data函数被调用。
*


* [1.x.284]
*
* 从[2.x.268]的误差[2.x.269]计算扩张[2.x.266]与[2.x.267]的吻合程度。我们还返回域的当前体积与参考体积的比率。这对不可压缩介质很有意义，因为我们要检查等压线约束的执行情况。
*


* [1.x.285]
*
* [1.x.286] [1.x.287]。


*
*确定问题的真实残差误差。  也就是说，确定无约束自由度的残差误差。  注意，要做到这一点，我们需要忽略受约束的自由度，将这些向量分量的残差设置为零。
*


* [1.x.288]
*
* [1.x.289] [1.x.290]。


*
*确定问题的真实牛顿更新误差
*


* [1.x.291]
*
* [1.x.292] [1.x.293]。


*
* 这个函数提供了总解，它在任何牛顿步都是有效的。这是必须的，因为为了减少计算误差，总解只在时间步数结束时更新。
*


* [1.x.294]
*
* [1.x.295] [1.x.296]。


*
* 因为我们使用TBB进行装配，所以我们只需设置一个流程所需的数据结构的副本，并将它们和装配函数一起传递给WorkStream对象进行处理。请注意，我们必须确保在任何装配操作发生之前，矩阵和RHS向量被重置。此外，由于我们描述的是一个诺伊曼BC的问题，我们将需要面的法线，因此必须在面的更新标志中指定这个。
*


* [1.x.297]
*
* 这里用于向WorkStream类传递数据的语法在 [2.x.270] 中讨论。
*


* [1.x.298]

* 当然，我们仍然要定义我们如何为单个单元组装切线矩阵的贡献。  我们首先需要重置和初始化一些从头开始的数据结构，并检索一些关于这个单元上DOF编号的基本信息。  我们可以预先计算单元的形状函数值和梯度。请注意，形状函数梯度是针对当前配置而定义的。  也就是 [2.x.271] 。
*


* [1.x.299]
*
* 现在我们建立局部单元刚度矩阵和RHS向量。由于全局和局部系统矩阵是对称的，我们可以利用这一特性，只建立局部矩阵的下半部分，并将其值复制到上半部分。  所以我们只组装一半的[2.x.272] , [2.x.273] , [2.x.274]块，而整个[2.x.275] , [2.x.276] , [2.x.277]块被建立。     
*在这样做的时候，我们首先从我们的正交历史对象中提取一些配置相关的变量，用于当前的正交点。
*


* [1.x.300]
*
* 这两个张量存储了一些预先计算的数据。它们的用途将很快得到解释。
*


* [1.x.301]

* 接下来我们定义一些别名，使装配过程更容易操作。
*


* [1.x.302]

* 我们首先计算来自内力的贡献。  注意，根据rhs作为残差负数的定义，这些贡献被减去。
*


* [1.x.303]
*
* 在我们进入内循环之前，我们还有最后一次机会来引入一些优化。我们已经考虑到了系统的对称性，现在我们可以预先计算一些在内循环中反复应用的常用项。我们在这里不会过分，而是将重点放在昂贵的操作上，即那些涉及等级4材料刚度张量和等级2应力张量的操作。             
* 我们可以观察到的是，这两个张量都是以 "i "DoF为索引的形状函数梯度收缩的。这意味着，当我们在 "j "DoF上循环时，这个特殊的操作保持不变。出于这个原因，我们可以从内循环中提取这个操作，并节省许多操作，对于每个正交点和DoF索引 "i "和重复索引 "j"，需要用等级4的对称张量来双重收缩等级2的对称张量，以及用等级2的张量收缩等级1的张量。             
* 在损失一些可读性的情况下，当使用模拟默认参数时，这个小变化将使对称系统的装配时间减少约一半，并且随着h-精化水平的提高而变得更加显著。
*


* [1.x.304]
*
* 现在我们准备计算正切矩阵的贡献。
*


* [1.x.305]
*
* 这是[2.x.278]贡献。它包括一个材料贡献，和一个几何应力贡献，只沿局部矩阵对角线添加。
*


* [1.x.306]
*
* 材料的贡献。
*


* [1.x.307]
*
* 几何应力的贡献。
*


* [1.x.308]
*
* 接下来是[2.x.279]的贡献
*


* [1.x.309]

* 最后是[2.x.280]和[2.x.281]的贡献。
*


* [1.x.310]
*
* 接下来我们组装诺伊曼贡献。我们首先检查单元格面是否存在于一个施加了牵引力的边界上，如果是这样的话，我们就加入贡献。
*


* [1.x.311]
*
* 使用该正交点的面法线，我们指定参考配置中的牵引力。对于这个问题，在参考构型中施加一个定义的压力。假设施加的牵引力的方向不随领域的变形而变化。牵引力的定义是使用第一个Piola-Kirchhoff应力，即[2.x.282]我们使用时间变量来线性增加压力负荷。               
* 请注意，我们在这里计算的右手边矢量的贡献只存在于矢量的位移成分中。
*


* [1.x.312]
*
* 最后，我们需要将本地矩阵的下半部分复制到上半部分。
*


* [1.x.313]
*
* [1.x.314] [1.x.315] 这个问题的约束条件很容易描述。在这个特殊的例子中，边界值将被计算为牛顿算法的两次第一次迭代。一般来说，我们会在第2次迭代中建立非均质约束（也就是在后面的代码块中`apply_dirichlet_bc == true`时），在接下来的步骤中只建立相应的均质约束。虽然目前的例子只有同质约束，但以前的经验表明，一个常见的错误是在重构代码到特定用途时忘记添加额外的条件。这可能导致难以调试的错误。本着这种精神，我们选择让代码在每个牛顿步骤中执行什么操作方面更加节略。
*


* [1.x.316]
*
* 由于我们(a)处理的是牛顿迭代方法，(b)使用位移的增量公式，以及(c)将约束条件应用于增量位移场，对位移更新的任何非同质约束只应在第2次迭代时指定。由于该迭代后约束条件将被完全满足，因此不需要做后续的贡献。
*


* [1.x.317]
*
* 此外，在一个时间段内的第一次牛顿迭代后，约束条件保持不变，只要不清除[2.x.283]对象，我们就不需要修改或重建它们。
*


* [1.x.318]
*
* 在牛顿第2次迭代时，我们希望应用代表位移增量的边界条件的全套非均质和均质约束。由于一般情况下，每个时间步长的约束条件可能是不同的，我们需要清除约束矩阵并完全重建它。一个例子是，如果一个表面正在加速，在这种情况下，每个时间步长之间的位移变化是不恒定的。
*


* [1.x.319]
*
* 3D中压痕问题的边界条件如下。在
*
* - ,
*
* - 和
*
* -面（IDs 0,2,4）我们设置了一个对称条件，只允许平面运动，而+x和+z面（IDs 1,5）是无牵引的。在这个设计好的问题中，+y面的一部分（ID 3）被设定为在x-和z-分量上没有运动。最后，如前所述，+y面的另一部分有一个施加的压力，但在x和z方向上也受到约束。         
* 在下文中，我们将不得不告诉函数插值的边界值应该约束解向量的哪些分量（即，是x-、y-、z-位移还是它们的组合）。这是用ComponentMask对象完成的（见[2.x.284]），如果我们为有限元提供一个我们希望选择的分量的提取器对象，我们可以从有限元得到这些对象。为此，我们首先设置了这样的提取器对象，然后在生成相关构件掩码时使用它。
*


* [1.x.320]
*
* 由于所有的Dirichlet约束在牛顿第2次迭代后被完全满足，我们要确保对这些条目不做进一步的修改。这意味着我们要将所有非均质的Dirichlet约束转换成均质的约束。         
* 在这个例子中，这样做的程序是非常直接的，事实上，当只应用同质边界条件时，我们可以（也将）规避任何不必要的操作。在一个更普遍的问题中，我们应该注意悬挂节点和周期性约束，这也可能引入一些不均匀性。那么，为不同类型的约束保留不同的对象可能是有利的，一旦构建了同质的Dirichlet约束，就将它们合并在一起。
*


* [1.x.321]
*
* 由于仿生约束是在上一次牛顿迭代中确定的，所以不能直接修改。所以我们需要将它们复制到另一个临时对象中并在那里进行修改。一旦我们完成了，我们将把它们转移回主[2.x.285]对象。
*


* [1.x.322]
*
* [1.x.323] [1.x.324] 解决整个块系统有点问题，因为没有对[2.x.286]块的贡献，使其不可逆转（当使用迭代求解器时）。由于压力和扩张变量DOFs是不连续的，我们可以将它们浓缩成一个较小的仅有位移的系统，然后我们将求解并随后进行后处理以检索压力和扩张的解决方案。
*

*
* 静态凝结过程可以在全局层面进行，但我们需要其中一个块的逆。然而，由于压力和膨胀变量是不连续的，静态凝结（SC）操作也可以在每个单元的基础上进行，我们可以通过反转局部块产生块对角线[2.x.287]块的逆。我们可以再次使用TBB来做这件事，因为每个操作将是相互独立的。   
* 通过WorkStream类使用TBB，我们将每个元素的贡献集合起来，形成[2.x.288]。然后这些贡献被添加到全局刚度矩阵中。鉴于这样的描述，以下两个功能应该是清楚的。
*


* [1.x.325]
*
* 现在我们描述一下静态凝结过程。按照惯例，我们必须首先找出这个单元上的自由度有哪些全局数字，并重置一些数据结构。
*


* [1.x.326]
*
* 我们现在提取与当前单元相关的道夫对全局刚度矩阵的贡献。  [2.x.289]和[2.x.290]插值的不连续性质意味着它们在全局水平上没有局部贡献的耦合。而[2.x.291]道夫则不是这种情况。  换句话说，[2.x.292]、[2.x.293]和[2.x.294]，当从全局刚度矩阵中提取时是元素贡献。  这不是[2.x.295]的情况。     
* 注意：小写的符号用于表示元素刚度矩阵。
*

*
* 目前，与当前元素相关的dof对应的矩阵（有点松散地表示为[2.x.296]）是这样的。


* [1.x.327]
*
* 我们现在需要修改它，使其显示为


* [1.x.328]
* 与 [2.x.297] 其中 [2.x.298] 和 [2.x.299] .     
* 在这一点上，我们需要注意到全局数据已经存在于[2.x.300] , [2.x.301] 和 [2.x.302] 子块中。  因此，如果我们要修改它们，我们必须考虑到已经存在的数据（也就是说，如果需要的话，简单地添加到它或删除它）。  由于copy_local_to_global操作是一个 "+="操作，我们需要考虑到这一点
* 特别是对于[2.x.303]块，这意味着已经从周围的单元格中添加了贡献，所以我们在操作这个块时需要小心。  我们不能直接擦除子块。     
* 这就是我们将采用的策略，以获得我们想要的子块。
*


*


*


*


*


*


*


*


*


*
* - [2.x.304] : 由于我们无法访问[2.x.305]，但我们知道它的贡献被添加到全局[2.x.306]矩阵中，我们只想添加元素明智的静态凝结[2.x.307] 。
*


*


*


*


*


*


*


*


*


*
* - [2.x.308] : 同样，[2.x.309]也存在于子块中。由于复制操作是一个+=操作，我们除了要 "添加 "我们希望替换的[2.x.310]子矩阵外，还需要减去现有的[2.x.310]子矩阵。
*


*


*


*


*


*


*


*


*


*
* - [2.x.311] : 由于全局矩阵是对称的，这块和上面的一样，我们可以简单地用[2.x.312]来代替这块。     
* 我们首先从系统矩阵中提取元素数据。所以首先我们得到单元格的整个子块，然后提取[2.x.313]与当前元素相关的道夫值
*


* [1.x.329]

* 接下来是[2.x.314][2.x.315]和[2.x.316]的局部矩阵。



* [1.x.330]
*
* 为了得到[2.x.317]的逆值，我们直接将其反转。  这个操作相对便宜，因为[2.x.318]是块状对角线的。
*


* [1.x.331]
*
* 现在我们可以做凝结项来添加到[2.x.319]块中，并把它们放在单元格局部矩阵[2.x.320]中。
*


* [1.x.332]
*
* [2.x.321]



* [1.x.333]
*
* [2.x.322]



* [1.x.334]
*
* [2.x.323]



* [1.x.335]
*
* 接下来我们把[2.x.324]放在[2.x.325]块中进行后处理。  再次注意，我们需要删除那里已经存在的贡献。
*


* [1.x.336]
*
* [1.x.337] [1.x.338] 我们现在拥有所有必要的组件，可以使用两种可能的方法之一来解决线性化系统。第一种是在元素层面上进行静态凝结，这需要对切线矩阵和RHS向量进行一些改动。或者，可以通过在全局层面上进行凝结来解决全块系统。下面我们将实现这两种方法。
*


* [1.x.339]
*
* 首先，这里是使用切线矩阵的（永久）增量的方法。对于下面的内容，请记住，


* [1.x.340]
*和


* [1.x.341]
*因而[1.x.342]其中[1.x.343]
*

*
* 在顶部，我们分配了两个临时向量以帮助静态凝结，还有一些变量用来存储线性求解器的迭代次数和（希望是收敛的）残差。
*


* [1.x.344]
*
* 在这个函数的第一步，我们求解增量位移 [2.x.326] 。  为此，我们进行静态浓缩，使[2.x.327]，并将[2.x.328]放入原[2.x.329]块中。也就是说，我们做出[2.x.330] 。
*


* [1.x.345]
*
* [2.x.331]



* [1.x.346]
*
* [2.x.332]



* [1.x.347]
*
* [2.x.333]



* [1.x.348]
*
* [2.x.334]



* [1.x.349]
*
* [2.x.335]



* [1.x.350]
*
* [2.x.336]



* [1.x.351]
*
* 我们默认选择了SSOR预调节器，因为它似乎为这个问题在单线程机器上提供了最快的求解器收敛特性。  然而，对于不同的问题规模，这可能不是真的。
*


* [1.x.352]
*
* 否则，如果问题足够小，可以利用直接求解器。
*


* [1.x.353]
*
* 现在我们有了位移更新，把约束分配回牛顿更新。
*


* [1.x.354]
*
* 解决位移问题后的下一步是进行后处理，从替换中得到扩张解。  [2.x.337]
*


* [1.x.355]
*
* [2.x.338]



* [1.x.356]
*
* [2.x.339]



* [1.x.357]
*
* [2.x.340]



* [1.x.358]
*
* [2.x.341]



* [1.x.359]
*
* 我们在这里确保任何迪里希特约束都分布在更新的解决方案上。
*


* [1.x.360]

* 最后我们用代入法求解压力的更新。  [2.x.342]
*


* [1.x.361]
*
* [2.x.343]



* [1.x.362]
*
* [2.x.344]



* [1.x.363]
*
* [2.x.345]



* [1.x.364]
*
* 和最后....  [2.x.346]



* [1.x.365]
*
* 我们现在已经到了终点，所以我们将所有受限的道夫分配回牛顿更新。
*


* [1.x.366]
*
* 在局部水平上手动凝结扩张和压力场，以及随后的后处理，需要花费相当大的努力才能实现。简而言之，我们必须产生逆矩阵[2.x.347]，并将其永久写入全局切线矩阵中。然后我们对[2.x.348]进行永久修改，产生[2.x.349]。这涉及到对切线矩阵的局部子块的提取和操作。在对位移进行求解后，对扩张和压力进行求解所需的各个矩阵-向量操作被仔细地执行。将这些众多的步骤与使用LinearOperator类提供的功能进行的更简单、更透明的实现形成对比。
*

*
* 为了便于以后使用，我们为RHS向量中的块定义了一些别名
*


* [1.x.367]
*
* ... 对于牛顿更新向量中的块。
*


* [1.x.368]
*
* 接下来我们为切线矩阵子块定义一些线性算子 我们将利用系统的对称性，所以并不是所有的块都需要。
*


* [1.x.369]
*
* 然后我们构造一个LinearOperator，代表（方形块）[2.x.350]的逆。由于它是对角线的（或者，当使用高阶分解时，几乎是对角线的），所以雅可比预处理器是合适的。
*


* [1.x.370]
*
* 现在我们可以构建[2.x.351]的那个转置和一个线性算子，它代表了浓缩的操作[2.x.352]和[2.x.353]以及最后的增强矩阵[2.x.354] 。请注意，schur_complement()算子在这里也能派上用场，但为了清楚起见，也为了展示线性求解方案的表述和实现之间的相似性，我们将手动执行这些操作。
*


* [1.x.371]
*
* 最后，我们定义了一个增强刚度矩阵的逆运算，即 [2.x.355] 。请注意，增强的刚度矩阵的预处理与我们使用静态凝结的情况不同。在这种情况下，预处理程序是基于未修改的[2.x.356]，而在第一种方法中，我们实际上修改了这个子块的条目。然而，由于[2.x.357]和[2.x.358]在同一空间操作，它对这个问题仍然足够。
*


* [1.x.372]

* 现在我们可以对位移场进行求解了。我们可以对线性运算进行嵌套，结果立即被写入牛顿更新向量中。很明显，这个实现紧密地模仿了介绍中所说的推导。
*


* [1.x.373]
*
* 需要对扩张场和压力场进行后处理的操作，也同样容易表达。
*


* [1.x.374]

* 用直接求解器求解全块系统。由于它是相对稳健的，它可能对因零[2.x.359]块的存在而产生的问题免疫。
*


* [1.x.375]
*
* 最后，我们在此再次确保任何迪里切特约束都分布在更新的解决方案上。
*


* [1.x.376]
*
* [1.x.377] [1.x.378] 这里我们介绍如何将结果写入文件，以便用ParaView或Visi来查看。该方法与以前的教程中显示的方法类似，因此将不作详细讨论。
*


* [1.x.379]
*
* 因为我们要处理的是一个大的变形问题，如果能在一个位移的网格上显示结果就更好了!  与DataOut类相连的MappingQEulerian类提供了一个接口，通过这个接口可以实现这一点，而不需要我们自己物理性地移动Triangulation对象中的网格点。  我们首先需要将解决方案复制到一个临时矢量，然后创建欧拉映射。我们还向DataOut对象指定了多项式的程度，以便在使用高阶多项式时产生更精细的输出数据集。
*


* [1.x.380]
*
* [1.x.381] [1.x.382] 最后，我们提供了主要的驱动功能，看起来与其他教程没有什么不同。
*


* [1.x.383]
* [1.x.384][1.x.385] 。


* 首先，我们提出了一系列与文献（见Reese等人(2000)）中的3维结果的比较，以证明该程序如预期的那样工作。
* 我们首先比较了[2.x.360]和[2.x.361]方案的网格细化收敛情况，如下图所示。结果与文献中的结果一致。低阶公式通常高估了低水平细化的位移，而高阶插值方案则低估了位移，但程度较轻。这个基准，以及其他一系列未在此显示的基准，使我们相信代码在正常工作。
* [2.x.363]
*

* 很明显，使用Newton-Raphson方法，可以得到二次收敛的解决方案。
* [1.x.386]

*

*
* 使用Timer类，我们可以看出代码的哪些部分需要最高的计算费用。对于一个有大量自由度的案例（即高水平的细化），Timer的一个典型输出如下。由于超过93%的时间花在线性求解器上，很明显，对于大型三维问题，可能有必要投资一个更好的求解器。
*


* [1.x.387]

*

* 然后我们用ParaView来显示两种情况的结果。第一种是最粗的网格和最低阶插值方法。  第二种是使用[2.x.368]公式的精炼网格。位移的垂直分量、压力[2.x.369]和膨胀[2.x.370]场显示如下。
*

* 对于第一种情况，很明显，粗略的空间离散化加上大的位移导致了低质量的解决方案（加载比为[2.x.371]）。此外，元素之间的压力差非常大。在这种离散性较差的情况下，也不会出现锁定现象。扩张解场和压力场明显相关，正的扩张表示正压区域，负的表示压缩区域。正如介绍中所讨论的，压缩压力有一个负号，而扩张压力有一个正号。
*

* [2.x.373]
*结合空间细化和高阶插值方案，产生了高质量的解决方案。三个网格细化加上一个[2.x.374]的公式，产生了一个清楚地抓住问题力学的结果。我们现在可以观察到施加牵引力的实际范围，最大的力施加在表面的中心点，造成最大的压缩。在压缩和膨胀区域之间有明显的区别和过渡，压力场的线性近似允许在子元素尺度上对压力进行精细的可视化处理，但是应该注意的是，压力场仍然是不连续的，可以在连续网格上进行平滑处理以达到后处理目的。
*


* [2.x.375]
* 这个简短的结果分析表明，三场公式能够有效地规避高度不可压缩介质的体积锁定。混合公式能够准确地模拟一个接近不可压缩的块在压缩下的位移。
* 就运行时间而言，[2.x.376]公式往往比[2.x.377]公式的计算费用更高。高阶方法计算时间的增加可能是由于高阶元素所需的带宽增加了。如前所述，使用更好的求解器和预调节器可以减轻使用高阶公式的费用。据观察，对于给定的问题，与单线程的SSOR预处理程序相比，使用多线程的Jacobi预处理程序可以减少72%的计算运行时间（在最坏的情况下是具有大量自由度的高阶公式）。
*

* [2.x.378]


* 最后，下面展示了两个不同层次的网格细化的2维问题的位移解决方案的结果。很明显，由于2维模拟的额外限制，所产生的位移场，虽然在质量上相似，但与3维情况不同。
*

* [2.x.379]
* [1.x.388][1.x.389][1.x.390] 。


*这项工作有许多明显的延伸。
*
* - 首先，可以在自由能函数中增加一个额外的约束条件，以便在材料中强制执行高度的不可压缩性。一个额外的拉格朗日乘数将被引入，但这可以最容易地使用增强的拉格朗日乘数的原则来处理。这在 [2.x.380] Simo和Taylor (1991) [2.x.381] 中得到了证明。
*
* - 本模型中使用的构成关系是比较基本的。将材料类分成两个独立的类，一个处理体积响应，另一个处理等熵响应，并产生一个通用的材料类（即具有抽象的虚拟函数，派生类必须实现），允许增加更复杂的材料模型，可能是有益的。这样的模型可以包括其他超弹性材料、塑性和粘弹性材料及其他。
*
* - 该程序是为解决单节点多核机器上的问题而开发的。只要稍加努力，该程序就可以通过使用Petsc或Trilinos扩展到大规模的计算环境，使用的技术与 [2.x.382] 中演示的类似。这主要涉及对设置、装配、[2.x.383]和线性求解器程序的修改。
*
* - 由于该程序假定为准静态平衡，因此有必要进行扩展以包括动态效应，以研究惯性效应重要的问题，例如涉及冲击的问题。
*
* - 对于高度非线性问题，负载和解决方案限制程序可能是必要的。可以增加一个线搜索算法，将步长限制在牛顿增量范围内，以确保最佳收敛性。也可能需要使用负载限制方法，如Riks方法，来解决涉及几何不稳定性的不稳定问题，如屈曲和快穿。
*
* - 许多物理问题涉及接触。有可能将物体之间的摩擦或无摩擦接触的影响纳入本程序。这将涉及到在自由能函数中增加一个额外的项，因此需要增加装配程序。我们还需要管理接触问题（检测和应力计算）本身。在自由能函数中增加惩罚项的一个替代方法是使用主动集方法，如[2.x.384]中使用的方法。
*
* - 使用LinearOperators的完整凝结程序已经被编码到线性求解器例程中。这也可以通过应用schur_complement()操作符来实现，以更自动化的方式缩减一个或多个字段。
*
* - 最后，自适应网格细化，如[2.x.385]和[2.x.386]所示，可以提供额外的求解精度。
*

* [1.x.391][1.x.392] [2.x.387]。
* [0.x.1]

