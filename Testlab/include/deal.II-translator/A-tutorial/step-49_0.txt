include/deal.II-translator/A-tutorial/step-49_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16 ][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31]
* [1.x.32]
* [1.x.33][1.x.34][1.x.35] 。
* 本教程是对[2.x.2]的扩展，演示了几种方法，以获得比那里显示的更多的网格。
* [2.x.3] 本教程也可以作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下可用。
* 生成复杂的几何图形是一项具有挑战性的任务，尤其是在三空间维度上。我们将讨论几种方法，但这个清单并不详尽。此外，也没有一种方法适合所有的问题。
* 这个例子程序显示了一些为计算而创建和修改网格的方法，并以与我们在[2.x.5]中相同的方式将它们输出为[2.x.4]文件。没有做其他的计算或适应性修正；我们的想法是，你可以把这里使用的技术作为其他更复杂的模拟器的构建模块。请注意，这个示例程序并没有展示本介绍中所讨论的所有生成网格的方法。
* 

* [1.x.36][1.x.37] 。
* 

* 当你使用自适应网格细化时，你肯定希望初始网格尽可能地粗大。原因是只要你有内存和CPU时间，你就可以用自适应细化技术把它做得很细。然而，这就要求你不要把网格单元浪费在域的某些地方，因为这些单元是没有价值的。因此，你不希望从一个太细的网格开始，因为这已经占用了你的单元预算的很大一部分，而且你无法粗化初始网格中的单元。
* 也就是说，你的网格需要充分地捕捉给定的几何体。
* 

* [1.x.38][1.x.39] 。
* 

* 有几种方法来创建初始网格。网格可以通过多种方式进行修改或组合，这一点将在后面讨论。
* [1.x.40][1.x.41].
* 

* 生成网格最简单的方法是使用namespaceGridGenerator中的函数，在 [2.x.6] 中已经讨论过。 有许多不同的辅助函数可用，包括 [2.x.7] [2.x.8] [2.x.9] 和 [2.x.10] 。
* 

* [1.x.42][1.x.43] 。
 

* 如果GridGenerator命名空间中没有适合你想要做的事情，你总是可以在你的程序中 "手工 "创建一个三角测量。为此，你需要一个带有坐标的顶点列表和一个引用这些顶点的单元格列表。你可以在[2.x.11]中的函数<tt>create_coarse_grid()</tt>中找到一个例子。GridGenerator中的所有函数都是以这种方式实现。
* 我们很乐意接受更多的函数被添加到GridGenerator中。所以，如果你最终写了一个对更多人有用的函数，请贡献出来。
* 

* [1.x.44][1.x.45] 。
* 

* GridIn类可以从磁盘的文件中读取许多不同的网格格式。如何做到这一点，在[2.x.12]中有解释，在这个例子中可以看到函数[2.x.13]，请看下面的代码。
* 网格可以由不同的工具生成，如[1.x.46]、[1.x.47]和[1.x.48]。更多信息见GridIn的文档。问题是，deal.II需要的网格只由四边形和六面体组成。
* 
* - 四面体网格无法工作（这意味着不能直接使用tetgen等工具）。
* 我们将描述一个使用%Gmsh的可能工作流程。%Gmsh是我们所知道的最小的、最快速设置的开源工具。它可以生成非结构化的二维四边形网格。在三维中，它可以将二维网格挤压成六面体网格；可以将非结构化的几何体三维网格化为六面体，尽管这些网格的质量有一些问题，这意味着这些网格有时只能在交易中工作。
* 在%Gmsh中，网格的基本描述是基于文本的[2.x.14]文件，其格式可以包含计算、循环、变量等。这种格式相当灵活，允许描述复杂的几何形状。网格是由表面表示法生成的，表面表示法是由线环列表建立的，线环列表是由线组成的，而线又是由点组成的。[2.x.15]脚本可以手工编写和编辑，也可以通过在%Gmsh中以图形方式创建对象自动生成。在许多情况下，最好把这两种方法结合起来。如果你想用手写的话，可以在 "Geometry "标签下按 "reload "键轻松加载该文件，并在gmsh的图形用户界面上看到效果。
* 本教程包含一个[2.x.16]文件的例子，它描述了一个内部有两个物体被切割出来的盒子。这就是[2.x.17]在%Gmsh中的样子（显示边界指示器以及下面要讨论的网格）。
* [2.x.18] 
* 你可能想用文本编辑器打开[2.x.19]文件（它与<tt> [2.x.20] .cc</tt>源文件位于同一目录下），看看它的结构如何。你可以看到域的边界是如何由一些线组成的，以及后来我们如何将一些线组合成 "物理线"（或 "物理面"），列出逻辑线的编号。"物理 "对象是携带边界指标信息的对象（见[2.x.21]"本词汇表条目"）。
* [2.x.22] 这个文件包含 "物理线 "和 "物理面 "是很重要的。它们提供了在deal.II中使用的边界指标和材料ID。没有这些物理实体，任何东西都不会被导入到deal.II中。
* deal.II的GridIn类可以读取由%Gmsh编写的[2.x.23]格式，该格式包含为[2.x.24]描述的几何体创建的网格，通过运行以下命令，可以从[2.x.25]中创建网格
* [1.x.49]
* 
*在命令行中，或者在加载文件后点击%Gmsh中的 "Mesh "和 "2D"。 现在这是从[2.x.26]文件中读取的网格，并由deal.II再次保存为图像（见当前程序的[2.x.27]功能）。
* [2.x.28] 
* [2.x.29] %Gmsh有许多其他接口，人们可以通过这些接口来描述几何图形。特别是，它能够与Python和Julia这样的脚本语言对接，但它也可以用C++来编写脚本。这些接口很有用，如果人们不只是想为一个单一的几何体生成网格（在这种情况下，图形界面或者在简单的情况下，手写的".geo "文件可能是最简单的方法），而是想对几何体进行参数化研究，为此需要为某些参数不同的几何体生成许多网格。另一种情况是，如果已经有一个CAD几何体，只需要一个网格；事实上，这可以在deal.II中使用[2.x.30]函数来完成。
* 

* [1.x.50][1.x.51] 。
* 

* 在以上述方式获得一个(或几个)网格后，有许多方法可以在有限元计算中使用它们之前对它们进行操作。
* 

* [1.x.52][1.x.53] 。
* 

* GridTools命名空间包含了一系列的小函数，用于以不同的方式转换给定的网格。函数[2.x.31][2.x.32][2.x.33]的用法相当明显，所以我们不在此讨论这些函数。
* 函数[2.x.34]允许你用一个平滑函数来变换给定网格的顶点。在[2.x.35]的结果部分也给出了一个使用的例子，但让我们在这里展示一个更简单的例子：在当前程序的函数[2.x.36]中，我们用正弦曲线扰动一个网格的Y坐标。
* [2.x.37] 
* 同样地，我们可以用公式[2.x.38]将一个有规律的细化的正方形转化为y方向的墙体适应的网格。这在本教程的 [2.x.39] 中完成。[2.x.40] 
* 最后，函数[2.x.41]允许你将网格中的顶点（可选择忽略边界节点）以随机的数量移动。这在[2.x.42]中进行了演示，其结果如下。
* [2.x.43] 
* 这个函数主要是为了否定在研究常规网格收敛时得到的一些超级收敛效应，同时也是为了抑制deal.II中的一些优化，这些优化可以利用细胞形状相似的事实。超级收敛是指，如果一个网格具有某些对称性，那么它的收敛性就会降低。
* 
* 例如，如果进入一个顶点的边对这个顶点是对称的，并且如果对一个单元的所有顶点都是这样的话
* 
* 解往往比通常的误差分析所预期的更高阶收敛。最后，这是一个事实，即如果对误差进行泰勒扩展，对称性导致了这样一个事实，即预期的扩展的下一个项恰好是零，而误差的阶数是由第二项决定的。
*第二项下*项。一个扭曲的网格没有这些对称性，因此误差反映了在任何*种网格上解方程时都会看到的情况，而不是显示只反映特定情况的东西)。
* 

* [1.x.54][1.x.55] 。
* 

* 函数[2.x.44]允许你将两个给定的三角形对象合并成一个。 要做到这一点，共享边或面的顶点必须完全匹配。 排列两个网格可以用 [2.x.45] 和 [2.x.46] 来实现。 在本教程的函数 [2.x.47] 中，我们合并了一个带圆孔的正方形（用 [2.x.48] 生成）和一个三角形（用 [2.x.49] 生成）。函数 [2.x.50] 允许你指定重复的数量和角的位置，所以这里不需要手动转移三角网格。你应该以图形方式检查网格，以确保单元格排布正确，并且在三角剖分中没有未配对的节点存在。
* 这些是输入的网格和输出的网格。
* [2.x.51] 
* 

* [1.x.56][1.x.57] 。
* 

* 函数 [2.x.52] 展示了在现有网格中挑选单个顶点并移动它们的能力。请注意，这有可能产生退化或倒置的单元，你不应该指望使用这样的网格会产生任何有用的东西。这里，我们通过向上移动顶部顶点来创建一个不完全居中的圆柱形孔的盒子。
* [2.x.53] 
* 关于如何做到这一点的确切方法，见下面的代码。
* 

* [1.x.58][1.x.59] 。
* 

* 如果你需要一个可以通过挤压给定的2D网格（可以通过上述任何一种方式创建）来创建的3D网格，你可以使用函数[2.x.54] 参见本教程中的[2.x.55]函数为例。请注意，在这个特殊的情况下，给定的结果也可以用3D版本的[2.x.56]来实现。主要用途是一个2dmesh，例如用%Gmsh生成，如上所述从[2.x.57]文件中读入。这是grid_4()的输出。
* [2.x.58] 
* 

* [1.x.60][1.x.61] 。
* 

* 使用上面讨论的方法创建一个粗略的网格只是第一步。当你有了它，它通常会作为进一步细化网格的基础。这并不困难，事实上，如果你的几何体只由直面组成，那就没有其他事情可做。然而，如果你有一个更复杂的几何体，情况往往就不是这样了，除了创建网格之外，还有更多的步骤是必须的。我们将在下面的[1.x.62]中介绍其中的一些步骤。
* 

* [1.x.63] [1.x.64].
* 这个教程程序很奇怪，因为与其他大多数步骤不同，介绍中已经提供了大部分关于如何使用各种策略生成网格的信息。因此，这里没有什么需要评论的，我们在代码中穿插了相对较少的文字。从本质上讲，这里的代码只是提供了一个在介绍中已经描述过的参考实现。
* 

* 
* [1.x.65] [1.x.66].
* 

* 
*  

 
* [1.x.67]
* 
* [1.x.68] [1.x.69]。
 

* 
* 下面的函数为我们将在本程序的剩余部分中生成的任何网格生成一些输出。特别是，它生成了以下信息。
* 

* 
* 

* 
* 
* - 一些关于这个网格所处的空间维数和它的单元数的一般信息。
* 

* 
* 
* - 使用每个边界指标的边界面的数量，这样就可以与我们所期望的进行比较。
* 

* 
* 最后，该函数将网格输出为VTU格式，可以很容易地在Paraview或VisIt中进行可视化。
* 

* 
* [1.x.70]
* 
* 接下来循环所有单元的所有面，并找出每个边界指标的使用频率（记得如果你访问一个不存在的[2.x.59]对象的元素，它将被隐式创建并默认初始化
* 
* - 为零，在当前情况下
* 
* - 在我们向它递增之前）。)
* 

* 
* [1.x.71]
 
* 最后，产生一个网格的图形表示到一个输出文件。
* 

* 
* [1.x.72]
* 
* [1.x.73] [1.x.74]
 

* 
* [1.x.75] [1.x.76].
 

* 
* 在这第一个例子中，我们展示了如何加载我们在介绍中讨论过的如何生成的网格。这与在[2.x.60]中使用的加载网格的模式相同，尽管那里是用不同的文件格式（UCD而不是MSH）编写的。
* 

* 
* [1.x.77]
* 
* [1.x.78] [1.x.79]
 

* 
* 在这里，我们首先创建两个三角形，然后将它们合并成一个。 正如介绍中所讨论的，必须确保共同界面的顶点位于相同的坐标。
* 

* 
* [1.x.80]
* 
* [1.x.81] [1.x.82].
 

* 
* 在这个函数中，我们移动一个网格的顶点。这比人们通常想象的要简单：如果你用[2.x.61]询问一个单元格的第[2.x.62]个顶点的坐标，它并不只是提供这个顶点的位置，实际上是对存储这些坐标的位置的一个引用。然后我们可以修改存储在那里的值。
* 

* 
* 所以这就是我们在这个函数的第一部分所做的。我们创建一个几何形状为[2.x.63]的正方形，在原点处有一个半径为0.25的圆孔。然后我们在所有单元格和所有顶点上循环，如果一个顶点的[2.x.64]坐标等于1，我们就把它向上移动0.5。
* 

* 
* 请注意，这种程序通常不会这样工作，因为通常会多次遇到相同的顶点，而且可能会移动它们不止一次。它在这里起作用是因为我们根据顶点的几何位置来选择我们要使用的顶点，一个顶点被移动过一次，以后就不会再有这种测试。解决这个问题的一个更普遍的方法是保留一个[2.x.65]的那些我们已经移动过的顶点索引（我们可以用[2.x.66]获得，并且只移动那些索引还不在这个集合中的顶点。
* 

* 
* [1.x.83]
* 
* 在第二步，我们将对网格进行两次细化。为了正确做到这一点，我们应该沿着以原点为中心的圆的表面在内部边界上放置新的点。幸运的是，[2.x.67]已经在内部边界上附加了一个Manifold对象，所以我们不需要做任何事情，只需要细化网格（参见[1.x.84]中一个完全可行的例子，我们[2.x.68]做[2.x.69]附加一个Manifold对象）。
* 

* 
* [1.x.85]
* 
* 如上所示，做事情有一个障碍。如果像这里显示的那样移动边界上的节点，由于内部的节点没有被移动，往往会导致内部的单元严重变形。在目前的情况下，这并不是一个很大的问题，因为当节点被移动时，网格并不包含任何内部节点。
* 
* - 这是粗略的网格，而且恰好所有的顶点都在边界上。还有一种情况是，我们在这里的移动，与平均单元尺寸相比，并没有过于夸张。然而，有时我们确实想把顶点移动一段距离，在这种情况下，我们也需要移动内部节点。一个自动完成的方法是调用函数[2.x.70]，该函数接收一组转换后的顶点坐标并移动所有其他的顶点，使生成的网格在某种意义上有一个小的变形。
* 

* 
*  
*  
* 

* 
* [1.x.86] [1.x.87]。
* 

* 
* 这个例子从前面的函数中获取初始网格，并简单地将其挤压到第三空间维度。
* 

* 
* [1.x.88]
* 
* [1.x.89] [1.x.90] * * [1.x.90]。
 

* 
* 这个例子和下一个例子首先创建一个网格，然后根据一个函数移动网格的每个节点，这个函数接收一个点并返回一个映射的点。在这个例子中，我们转换了[2.x.71] .
* 

* 
* [2.x.72]需要一个三角形和一个参数，这个参数可以像一个函数一样被调用，接收一个点并返回一个点。有不同的方式来提供这样一个参数。它可以是一个函数的指针；它可以是一个具有`operator()`的类的对象；它可以是一个lambda函数；或者它可以是任何通过[2.x.73]对象描述的东西。
* 

* 
* 决定性的是，更现代的方式是使用一个接受一个点并返回一个点的lambda函数，这就是我们在下面所做的。
* 

* 
* [1.x.91]
* 
* [1.x.92] [1.x.93].
 

* 
* 在第二个例子中，我们将使用映射[2.x.74]将原始网格中的点转换为新的网格。为了使事情更有趣，而不是像前面的例子那样在一个单一的函数中完成，我们在这里创建一个具有[2.x.75]的对象，这个对象将被[2.x.76]所调用。当然，这个对象实际上可能要复杂得多：这个对象可能有成员变量，在计算顶点的新位置方面起作用。
* 

* 
* [1.x.94]
* 
* [1.x.95] [1.x.96].
 

* 
* 在这最后一个例子中，我们创建了一个网格，然后通过随机扰动使其（内部）顶点变形。这不是你想在生产计算中做的事情（因为在具有 "很好形状 "的单元的网格上的结果通常比在[2.x.77]产生的变形单元上的结果要好，但这是一个有用的工具，用于测试离散化和代码，以确保它们不会因为网格碰巧是均匀结构和支持超级收敛特性而意外地工作。
* 

* 
* [1.x.97]
* 
* [1.x.98] [1.x.99]
 

* 
* 最后是主函数。这里没有什么可做的，只是调用我们上面写的所有各种函数。
* 

* 
* [1.x.100]
* [1.x.101][1.x.102] 。
* 

* 该程序产生一系列[2.x.78]的三角计算文件。这些方法在上面有讨论。
* 

* [1.x.103][1.x.104]。
* 

* 正如在介绍中提到的，使用这里讨论的方法创建一个粗略的网格仅仅是第一步。为了细化一个网格，三角计算需要知道在边、面和单元的中点上放置新的顶点。默认情况下，这些新的点会被放置在周围点的算术平均值上，但如果你需要的是没有被粗网格充分解决的弯曲边界，这并不是你想要的。例如，对于这个网格，中心孔应该是圆形的。
* [2.x.79] 
* 如果你简单地细化它，三角剖分类不能知道你想让孔是圆的还是八角形的。默认的做法是在现有的直线上放置新的点。经过两个网格细化步骤后，会产生以下的网格，这不是我们想要的。
* [2.x.80] 
* 需要做的是，你告诉三角计算，你实际上是想使用一个弯曲的几何体。要做到这一点需要三个步骤。
* 
* - 创建一个描述所需几何体的对象。这个对象将在细化三角测量的新点位置时被查询。如果在系统装配过程中使用了MappingQ或MappingQGeneric这样的高阶映射，它也将被用来计算形状函数值。 在deal.II中，Manifold类和继承自它的类（如PolarManifold和FlatManifold）执行这些计算。
* 
* - 通知Triangulation对象使用哪个Manifold类。默认情况下，一个Triangulation使用FlatManifold来进行所有的几何计算，它假设所有的单元格边缘都是直线，所有的四边形都是平的。你可以通过调用[2.x.81]函数将Manifold类附加到Triangulation上，该函数将[2.x.82]与Manifold对象关联。关于这一点的更多信息，请参见[2.x.83]"关于这个主题的词汇条"。
* 
* - 最后，你必须用正确的 [2.x.84] 标记单元格和单元格面。例如，你可以通过以下方式得到一个在直角坐标中带有弯曲单元的环形扇面（但在极坐标中是矩形）。
* [1.x.105]
* 现在，当网格被细化时，所有的单元格分割计算都将在极坐标中完成。
* GridGenerator命名空间中所有创建网格的函数都会将正确的Manifold对象附加到提供的Triangulation上：也就是说，对于这些函数，我们默认会得到正确的行为。然而，对于手工生成的网格，情况要有趣得多。
* 为了更详细地说明这个过程，让我们考虑一个由Yuhan Zhou创建的例子，作为2013年德克萨斯A&amp;M大学的一个学期项目的一部分。在一个CAD程序中，这个几何体看起来像这样。
* [2.x.85] 
* 在下文中，我们将指导你完成为这个几何体创建网格的整个过程，包括一些常见的陷阱，展示可能出错的东西。
* 第一步是创建一个粗略的网格，通过为每个截面创建一个2D粗略的网格，将它们挤压到第三个方向，然后将它们粘在一起。下面的代码使用之前描述的技术来完成这个工作。
* [1.x.106]
 
* 这将创建以下的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.86] .yuhan.8.png" alt="" width="400" height="355"> * 这个网格具有正确的总体形状。
* 这个网格有正确的大体形状，但是顶部的单元格现在是多边形的：线不再是沿着圆的，我们没有一个非常准确的原始几何的代表。下一步是教给域的顶部部分，它应该是弯曲的。换句话说，所有在顶部边界单元上进行的计算都应该在圆柱坐标而不是笛卡尔坐标中进行。我们可以通过创建一个CylindricalManifold对象并将其与上面的单元格相关联来做到这一点 [2.x.87] 。这样一来，当我们细化上面的单元格时，我们将沿着同心圆而不是直线来放置新的点。
* 在交易二中，我们用继承自Manifold的类来描述所有的几何体。默认的几何形状是笛卡尔式的，在FlatManifold类中实现。顾名思义，Manifold及其继承类提供了一种用微分几何的思想和术语来描述曲线和曲线单元的方法：例如，CylindricalManifold继承自ChartManifold，后者通过后拉和前推来描述一个几何体。一般来说，我们应该认为Triangulation类描述了一个域的拓扑结构（当然，除了存储顶点的位置之外），而Manifold类描述了一个域的几何结构（例如，一对顶点是否位于圆弧或直线上）。Triangulation将通过对与该单元相关的Manifold进行计算来细化单元，而不管该单元是否在边界上。换句话说：Manifold类不需要任何关于三角函数的边界在哪里的信息：由三角函数来查询正确的Manifold来计算一个单元。大多数Manifold函数（例如，[2.x.88]）对域本身一无所知，只是假设给它的点是沿着测度线的。在这种情况下，对于下面构建的圆柱形模子，节点线是沿着以[2.x.89]轴为中心的正交圆弧。
* 由于域的三个顶部部分都使用相同的测地线，我们将把中心在[2.x.91]线以上的所有单元都标记为圆柱性质。
* [1.x.107]
* 
* 通过这个代码，我们得到一个看起来像这样的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.92] .yuhan.9.png" title="" width="400" height="355">
* 这一变化修复了边界，但产生了一个新的问题：与圆柱体轴线相邻的单元格被严重扭曲了。我们应该使用直角坐标对这些中心单元进行计算以避免这个问题。沿着中心线的单元格都有一个面接触到线[2.x.93]，因此，为了实现这一点，我们回头将这些单元格上的[2.x.94]s覆盖为零（这是默认的）。
* [1.x.108]
* 
* 这给了我们以下的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.95] .yuhan.10.png" alt="" width="400" height="355">。
* 这给了我们一个很好的网格，每个圆心的单元仍然是笛卡尔式的，而边界周围的单元是沿着圆的。如果我们再细化两次，我们就能真正看到边界拟合网格的良好细节。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.96] .yuhan.11.png" alt="" width="400" height="355">。
* 

* [1.x.109][1.x.110] 。
* 

* [1.x.111][1.x.112]。
* 

* 对本教程中描述的以某种形式生成的网格指定不同的边界ID，以应用不同的边界条件，通常是有用的。
* 例如，你可能想为这个程序中的第一个网格的右边边界应用不同的边界条件。要做到这一点，需要遍历单元格和它们的面，并识别正确的面（例如，使用`cell->center()`查询单元格中心的坐标，如[2.x.97]，或者使用`cell->face(f)->get_boundary_id()`查询该单元格[2.x.98]的当前边界指示灯）。你可以使用`cell->face(f)->set_boundary_id()`来设置边界指标。你可以回顾一下[2.x.99]如何对网格进行迭代。
*[1.x.113][1.x.114]
* 

* 在流形上的计算，就像在[2.x.100]中所做的那样，需要一个嵌入到高维空间的表面网格。虽然有些网格可以用GridGenerator命名空间来构建，或者从文件中加载，但有时从体积网格中提取一个表面网格也是很有用的。
* 使用函数[2.x.101]来提取网格的表面元素。在一个三维网格上使用该函数(一个`Triangulation<3,3>`，例如来自`grid_4()`)，这将返回一个`Triangulation<2,3>`，你可以在 [2.x.102] 中使用。 也可以尝试提取`Triangulation<2,2>`的边界网格。
* 

* <!--
* 本教程可能的扩展。
* 
* - 用于收敛研究的非结构化网格数据库
* 
* - 如何删除或禁用网格内的一个单元
* 
* - >
* 

* [1.x.115][1.x.116] [2.x.103]。
* [0.x.1]

