include/deal.II-translator/A-tutorial/step-22_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22 ][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44]
* [2.x.3] 
* [1.x.45]
 

* 
* [1.x.46][1.x.47][1.x.48] 。
* 

* 本程序处理斯托克斯方程组，其非维度形式如下：[1.x.49] 。
* 其中[2.x.4]表示流体的速度，[2.x.5]是压力，[2.x.6]是外力，[2.x.7]是对称梯度的第二级张量；其分量定义为[2.x.8] 。
* 斯托克斯方程描述了缓慢移动的粘性流体的稳态运动，如蜂蜜、地幔中的岩石或其他惯性不起作用的情况。如果流体的运动速度足够快，与粘性摩擦相比，惯性力的作用非常明显，那么斯托克斯方程就不再有效了；考虑到惯性效应，就会导致非线性的纳维-斯托克斯方程。然而，在本教程中，我们将重点讨论更简单的斯托克斯系统。
* 请注意，在推导更一般的可压缩纳维-斯托克斯方程时，扩散被建模为应力张量的发散[1.x.50] 。
* 其中[2.x.9]是流体的黏度。在[2.x.10]的假设下（假设粘度恒定，并通过除以[2.x.11]使方程非立体化），并假设不可压缩性（[2.x.12]），从上面的公式来看：[1.x.51] 。
* 一个不同的公式使用拉普拉斯算子（[2.x.13]）而不是对称梯度。这里的一个很大的区别是，速度的不同分量并不耦合。如果你假设解决方案[2.x.14]具有额外的不规则性（第二偏导存在并且是连续的），那么这些公式是等价的：[1.x.52] 。
* 这是因为[2.x.15]中的[2.x.16]的第1个条目是由：[1.x.53]给出的。
* 如果你不能假设上述的规律性，或者你的粘度不是一个常数，这个等价关系就不再成立。因此，我们决定在本教程中坚持使用更准确的物理学上的对称张量公式。
* 

* 为了得到很好的解决，我们将不得不在方程中加入边界条件。一旦我们讨论方程的微弱形式，哪些边界条件是容易做到的，就会变得很清楚。
* 这里所涉及的方程属于矢量值问题的范畴。对这一主题的概述可以在[2.x.17]模块中找到。
* 

*[1.x.54][1.x.55]
* 

* 方程的弱形式可以通过向量形式写成[1.x.56]得到。
* 从左边开始与矢量值测试函数[2.x.18]形成点积，并在域[2.x.19]上进行积分，得出以下方程组：[1.x.57]
* 这对所有测试函数[2.x.20]都必须成立。
* 一般来说，一个好的经验法则是，如果一个人[1.x.58]减少公式中任何变量的导数，那么一个人[1.x.59]实际上是用部分积分来做。这是由[1.x.60]的理论引起的，特别是强和[1.x.61]之间的区别）。我们已经为拉普拉斯方程做了这样的工作，在那里我们通过部分积分第二导数来获得弱的表述，即在测试和试算函数上都只有一个导数。
* 在当前情况下，我们对第二项进行分项积分：[1.x.62] 。
* 同样地，我们对第一项进行分项积分，得到[1.x.63] 。
* 两个张量之间的标量乘积被定义为[1.x.64] 。
* 利用这一点，我们现在已经把对变量的要求降低到对[2.x.21]的第一次导数和对[2.x.22]完全没有导数。
* 因为像[2.x.23]这样的一般张量和[2.x.24]这样的对称张量之间的标量积等于两者的对称形式之间的标量积，我们也可以把上面的双线性形式写成：[1.x.65] 。
* 我们将在下一节中处理边界项，但它已经从域项[1.x.66]中清除了。
* 斯托克斯方程产生了一个对称的双线性形式，因此也产生了一个对称的（如果是不确定的）系统矩阵。
* 

* [1.x.67][1.x.68] 。
* 

* [2.x.25] ( [2.x.26] ) 
* 刚刚得出的弱形式立即为我们提供了施加边界条件的不同可能性。[2.x.27] [2.x.28] Dirichlet速度边界条件。在一个部分[2.x.29]，我们可以对速度施加迪里希特条件[2.x.30] 。
* [1.x.69]
* 因为检验函数[2.x.31]来自解变量的切线空间，我们有[2.x.32]在[2.x.33]上，因此有[1.x.70] 。
* 换句话说，像往常一样，强加的边界值不会出现在弱形式中。
* 值得注意的是，如果我们在整个边界上施加Dirichlet边界值，那么压力就只能确定到一个常数。这方面的算法实现将使用类似于在[2.x.34]中看到的工具。
* [2.x.35] 诺伊曼型或自然边界条件。在边界的其余部分[2.x.36]，让我们把边界条款重新写成如下。   [1.x.71]
* 换句话说，在边界的诺伊曼部分，我们可以规定总应力的值。   [1.x.72]
* 如果边界被细分为Dirichlet和Neumann部分[2.x.37]，这就导致了以下的弱形式。   [1.x.73]
* 
* 

* [2.x.38] 罗宾型边界条件。罗宾式边界条件是迪里切特和诺依曼边界条件的混合体。它们将读作[1.x.74] 。
*有一个等级2的张量（矩阵） [2.x.39] 。相关的弱形式是[1.x.75] 。
* 
* [2.x.40] 局部边界条件。有可能通过只对速度的某些分量强制执行Dirichlet和Neumann边界条件来结合它们中的每一个。例如，施加人工边界条件的一种方法是要求流动垂直于边界，即切向分量[2.x.41]为零，从而约束速度的[2.x.42]-1分量。剩下的分量可以通过要求法向应力的法向分量为零来约束，产生以下一组边界条件。   [1.x.76]
* 
* 另一种情况是希望流向[1.x.77]而不是垂直于边界（在deal.II中，[2.x.43]函数可以帮你做到这一点）。这种情况经常发生在自由边界的问题上（例如，在河流或湖泊的表面，如果流动的垂直力不足以使表面实际变形），或者如果边界对流体没有施加明显的摩擦力（例如，在地幔和地核的界面上，两种流体因密度不同而相遇，但它们的粘度都很小，不会对彼此产生很大的切向应力）。   在公式中，这意味着[1.x.78]。
*第一个条件（需要强加）固定速度的一个分量，第二个条件（将在弱的形式下强制执行）固定其余的两个分量。[2.x.44] 
* 尽管有这么多的可能性，我们在本教程中只使用迪里切特和（同质）诺伊曼边界条件。
* 

*[1.x.79][1.x.80]
* 

* 如上所述，在[2.x.45]和[2.x.46]上使用狄里希特和诺伊曼边界条件的方程的弱形式是这样的：找到[2.x.47]，以便[1.x.81] 。
*对于所有测试函数[2.x.48]。
*这些方程代表一个对称的[1.x.82]。众所周知，只有当我们寻找解决方案的函数空间满足某些条件时，解决方案才存在，这些条件通常被称为Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件。上面的连续函数空间满足这些条件。然而，当我们将方程离散化，用有限维空间的有限元函数取代连续变量和检验函数时[2.x.49]，我们必须确保[2.x.50]也满足LBB条件。这与我们在[2.x.51]中要做的事情相似。
* 对于斯托克斯方程，有许多可能的选择来确保有限元空间与LBB条件兼容。一个简单而准确的选择是[2.x.52]，即对速度使用比压力高一阶的元素。
* 这就导致了以下的离散问题：找到[2.x.53]，使[1.x.83]在所有测试函数中都能得到满足。
* 对于所有测试函数[2.x.54]。与这个问题相关的线性系统的组装遵循[2.x.55]"[2.x.56]"、[2.x.57]中使用的相同路线，并在[2.x.58]模块中详细解释。
* 

* 
* [1.x.84][1.x.85] 。
* 

* 离散方程的弱形式自然导致速度场和压力场节点值的以下线性系统：[1.x.86] 。
* 与[2.x.59]和[2.x.60]一样，我们将通过形成Schur补数来解决这个方程组，即首先找到[1.x.87]的解[2.x.61]，然后是[1.x.87]的解。
* 然后是[1.x.88]。
* 我们这样做的方式与我们在之前的教程中所做的差不多，也就是说，我们再次使用相同的类[2.x.62]和[2.x.63]。然而，有两个显著的区别。
* [2.x.64] [2.x.65] 首先，在混合拉普拉斯方程中，我们必须处理如何对舒尔补数[2.x.66]进行预处理的问题，该补数在光谱上等同于压力空间上的拉普拉斯算子（因为[2.x.67 ]代表梯度算子，[2.x.68]代表其邻接算子[2.x.69]，而[2.x.70]代表身份（直到材料参数[2.x.71]为止），因此[2.x.72]类似于[2.x.73]）。因此，他们的矩阵对于小的网格尺寸来说条件很差，我们不得不为Schur补码想出一个精心设计的预处理方案。
* [2.x.74] 其次，每次我们与[2.x.75]相乘时，我们必须用他们的矩阵[2.x.76]来解决。然而，这并不特别困难，因为质量矩阵总是有很好的条件的，所以使用CG和一点点预处理就可以简单地反转。[2.x.77]换句话说，[2.x.78]的内部求解器的预处理很简单，而[2.x.79]的外部求解器的预处理很复杂。
* 这里，情况几乎完全相反。差异源于这样一个事实，即舒尔补码的核心矩阵不是来自身份算子，而是来自拉普拉斯算子的一个变体，[2.x.80]（其中[2.x.81]是对称梯度），作用于一个矢量场。在研究这个问题时，我们主要遵循D.Silvester和A.Wathen的论文："稳定的斯托克斯系统的快速迭代解决第二部分。使用一般块状先决条件"。(SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367），可在线查阅[1.x.89].主要是，Schurcomplement的核心矩阵的差异有两个后果。
* [2.x.82] [2.x.83] 首先，它使外部预处理变得简单：Schur补码对应于压力空间上的算子[2.x.84]；忘记我们处理的是对称梯度而不是常规梯度的事实，Schur补码是类似[2.x.85]的东西，即使在数学上不是完全简洁的，在光谱上也等同于身份算子（一个启发式的说法是将算子换成[2.x.86] ）。事实证明，用CG方法直接解决这个Schur补数并不容易：在没有预设条件的情况下，Schur补数矩阵的条件数取决于最大和最小单元的大小比，而且仍然需要50-100次CG迭代。然而，有一个简单的解决办法：用压力空间上的质量矩阵进行预处理，我们就可以减少到5-15次CG迭代，几乎不受网格结构的影响（看看这个程序的[1.x.90]，可以看到CG迭代的数量确实没有随着网格的细化而改变）。
* 因此，除了我们已经有的东西之外，我们需要的是压力变量的质量矩阵，我们将把它存储在一个单独的对象中。
* 

* 
* [2.x.87] 虽然与[2.x.88]中讨论的混合拉普拉斯情况相比，外部预处理程序变得简单了，但内部求解器的问题却变得更加复杂。在混合拉普拉斯微分法中，舒尔补码的形式为 [2.x.89] 。因此，每当我们与Schur补码相乘时，我们必须解决线性系统[2.x.90]；然而，这并不太复杂，因为压力空间上的质量矩阵[2.x.91]是有条件的。
* 

* 另一方面，对于我们在这里考虑的斯托克斯方程，舒尔补码是[2.x.92]，其中矩阵[2.x.93]与拉普拉斯算子有关（实际上，它是对应于双线性形式[2.x.94]的矩阵）。因此，用[2.x.95]求解要复杂得多：矩阵的条件很差，我们知道我们需要多次迭代，除非我们有一个非常好的预处理程序。更糟糕的是，我们每次与舒尔补码相乘时都要用[2.x.96]求解，使用上述的预处理程序需要5-15次。
* 因为我们必须多次用[2.x.97]求解，所以多花一点时间为这个矩阵创建一个好的预处理程序是值得的。所以我们要做的是：如果在2d中，我们使用第二个预处理程序，即对矩阵进行直接稀疏LU分解。这是用SparseDirectUMFPACK类实现的，它使用UMFPACK直接求解器来计算分解。要使用它，你必须建立支持UMFPACK的deal.II（这是默认的）；参见[1.x.91]的说明。有了它，内解器在一次迭代中就能收敛。
* 在2D中，我们可以做这样的事情，因为即使是合理的大问题，也很少有超过100,000个未知数，而且每行的非零点相对较少。此外，2D中矩阵的带宽是[2.x.98]，因此是中等的。对于这样的矩阵，稀疏因子可以在几秒钟内计算完成。作为参考，计算一个大小为[2.x.99]、带宽为[2.x.100]的矩阵的稀疏因子需要[2.x.101]次操作。在2D中，这需要[2.x.102]；尽管这比例如组装线性系统需要[2.x.103]的复杂度要高，但计算分解的常数非常小，直到我们发现大量未知数的百分比在100,000以上，它才会成为整个程序中的主导因素。)
* 情况在3D中发生了变化，因为在那里我们很快就有了更多的未知数，而且矩阵的带宽（决定了稀疏LU因子中非零项的数量）是[2.x.104]，而且每行也有更多的条目。这使得使用像UMFPACK这样的稀疏直接求解器的效率很低：只有在问题规模为10,000到100,000个未知数时，才能用合理的时间和内存资源进行稀疏分解计算。
* 在这种情况下，我们所做的是使用一个不完整的LU分解（ILU）作为条件器，而不是实际计算完整的LU因子。正如它所发生的，deal.II有一个类可以做到这一点。SparseILU。计算ILU所需要的时间只取决于稀疏矩阵中非零项的数量（或者说我们愿意填入LU因子，如果这些因子比矩阵中的要多），但与矩阵的带宽无关。因此，这也是一个可以有效地在三维中计算的操作。另一方面，根据定义，一个不完整的LU分解并不代表矩阵的精确逆[2.x.105]。因此，用ILU进行预处理仍然需要一次以上的迭代，而不像用稀疏直接求解器进行预处理。因此，内部求解器在与舒尔补码相乘时将花费更多时间：这是一个不可避免的折衷。[2.x.106] 
* 在下面的程序中，我们将利用SparseILU和SparseDirectUMFPACK类具有非常相似的接口，可以互换使用的事实。我们所需要的是一个开关类，根据维度的不同，提供一个类型，即上面提到的两个类中的任何一个。这就是我们如何做到的。
* [1.x.92]
 
*从这里开始，我们可以引用类型<code>typename [2.x.107]，并自动得到正确的preconditioner类。由于这两个类的接口很相似，我们将能够在所有地方使用相同的语法来互换使用它们。
* 

*[1.x.93][1.x.94]
* 

* 上面的讨论显示了由斯托克斯方程产生的线性系统可以被解决的一种*方式，而且由于教程程序是教学工具，这是有意义的。但这是解决这个方程组的方法吗？
* 答案是否定的。上面已经指出了这种方法的主要瓶颈，那就是我们必须反复求解舒尔补数内的[2.x.108]的线性系统，由于我们没有一个好的舒尔补数的预处理程序，这些求解就不得不经常发生。一个更好的方法是使用块状分解，这是基于Silvester和Wathen[2.x.109]的观察，并在[2.x.110]中做了更详细的解释。下面在本程序的结果部分的[1.x.95]一节中讨论了这种替代方法的实施。
* 

* [1.x.96][1.x.97] 。
* 

* 以上，我们声称线性系统具有[1.x.98]的形式。
* 也就是说，特别是在矩阵的右下方有一个零块。这样我们就可以把舒尔补数写成[2.x.111]。但这并不完全正确。
* 想一想，如果对某些压力变量有约束（见[2.x.112]"自由度的约束 "文件模块），例如因为我们使用自适应细化网格和连续压力有限元，所以有悬挂的节点，会发生什么。导致这种约束的另一个原因是压力的迪里希边界条件。然后，AffineConstraints类在将矩阵的局部贡献复制到全局线性系统中时，会将对应于受限自由度的行和列清零，并在对角线上放一个正条目。(你可以认为这个条目是一个简单的条目，尽管实际上它是一个与其他矩阵条目相同数量级的值。) 换句话说，右下角区块其实根本不是空的：它在对角线上有几个条目，每个受限的压力自由度都有一个，对我们要解决的线性系统的正确描述是，它的形式是[1.x.99] 。
*其中[2.x.113]是零矩阵，但受限自由度的对角线正项除外。那么，正确的舒尔补码实际上就是矩阵[2.x.114]，而不是上面所描述的那个。
* 思考这个问题使我们首先意识到，现在的舒尔补码是不确定的，因为[2.x.115]是对称的和正定的，而[2.x.116]是正半定的，将后者减去前者可能不再是正定的。这很烦人，因为我们不能再在这个真正的舒尔补数上使用共轭梯度法。也就是说，我们可以在[2.x.117]中解决这个问题，即简单地将负*值放在受限压力变量的对角线上
* 
* 因为我们实际上只是把一些非零的东西放到了对角线上，以确保得到的矩阵不是奇异的；我们真的不在乎这个条目是正还是负。因此，如果[2.x.118]的对角线上的条目是负的，那么[2.x.119]将再次成为不对称和正定矩阵。
* 但是，其次，下面的代码实际上并没有做这些事。我只是用错误的舒尔补码[2.x.120]来解决线性系统，完全忽略了这个问题。为什么会这样呢？为了理解为什么会这样，回顾一下，当把局部贡献写进全局矩阵时，[2.x.121]把对应于受限自由度的行和列清零。这意味着[2.x.122]有一些零行，[2.x.123]零列。[2.x.125]的非零条目将正好适合于这些零对角线位置，并确保[2.x.126]是可逆的。不这样做，严格来说，意味着[2.x.127]仍然是单数。它在非约束压力自由度子集上是对称的和正定的，而在约束压力上只是一个零矩阵。为什么共轭梯度法对这个矩阵有效？因为[2.x.128]也确保了与矩阵的这些零行相对应的右手边条目也是*的。
零，也就是说，右手边是兼容的。
* 这意味着，无论这些受限压力自由度的解向量的值是多少，这些行的残差总是为零，而且，如果考虑到CG算法的内部操作，就永远不会对解向量产生任何更新。换句话说，尽管矩阵是奇异的，但CG算法只是忽略了*这些行。这只是因为这些自由度与线性系统的其他部分完全解耦（因为整个行和相应的列都是零）。在求解过程结束时，求解向量中的约束压力值仍然与我们开始调用求解器时一模一样；当我们在CG求解器完成后调用[2.x.129]时，它们最终被正确的值覆盖。
* 这个讨论的结果是，假设大矩阵的右下角块为零是有点简化了，但仅仅是这样做实际上并没有导致任何值得解决的实际问题。
* 

*[1.x.100][1.x.101]
* 

* 我们在下面实现的域、右手边和边界条件与地球物理学中的一个问题有关：在那里，人们想计算大洋中裂缝下地球内部的岩浆流场。裂缝是两个大陆板块非常缓慢地漂移开来的地方（每年最多几厘米），在地壳上留下一个裂缝，里面充满了来自下面的岩浆。在不试图完全现实的情况下，我们通过解决以下一组方程和边界条件来模拟这种情况[2.x.130]：[1.x.102] 。
*其他地方使用自然边界条件[2.x.131]。换句话说，在顶面的左边部分，我们规定流体以速度[2.x.132]随大陆板向左移动，在顶面的右边部分向右移动，并在其他地方施加自然流动条件。如果我们在2d中，描述基本上是相同的，例外的是我们省略了上述所有矢量的第二部分。
* 正如在[1.x.103]中所显示的那样，流场将从下面拉出物质，并将其移到域的左端和右端，这是所期望的。速度边界条件的不连续性将在顶面中心产生一个压力奇点，将材料一直吸到顶面，以填补材料在此位置向外运动所留下的缺口。
* 

*[1.x.104][1.x.105]
* 

* [1.x.106][1.x.107] *[1.x.107]
* 

* 在以前的所有教程程序中，我们仅仅使用AffineConstraints对象来处理悬挂节点约束（[2.x.133]除外）。然而，该类也可以用来实现Dirichlet边界条件，正如我们将在本程序中展示的那样，通过固定一些节点值[2.x.134] 。请注意，这些是不均匀的约束，我们必须特别注意这点。我们要实现这一点的方法是，首先通过使用调用将边界值读入AffineConstraints对象中。
* [1.x.108]
* 
* 非常类似于我们之前制作边界节点列表的方式（注意，我们只在边界标志为1的边界上设置迪里希特条件）。边界值的实际应用是由AffineConstraints对象直接处理的，没有任何额外的干扰。
* 然后我们可以像以前一样进行，即通过填充矩阵，并在约束对象上调用一个浓缩函数，其形式为
* [1.x.109]
* 
* 注意，我们在系统矩阵和系统右侧同时调用这个函数，因为解决不均匀约束需要对矩阵条目和右侧的知识。不过，出于效率的考虑，我们选择了另一种策略：所有收集在AffineConstraints对象中的约束都可以在将本地数据写入全局矩阵的过程中得到解决，方法是使用调用
* [1.x.110]
* 
* 这一技术在[2.x.135]教程程序中进一步讨论。我们在这里需要知道的是，这个函数同时做了三件事：它将局部数据写入全局矩阵，并将悬挂的节点约束分配出去，另外还实现了（非均质的）迪里切特边界条件。这很好，不是吗？
* 我们可以得出结论，AffineConstraints类提供了一个替代使用[2.x.136]来实现Dirichlet边界条件的方法。
* 

* [1.x.111][1.x.112][1.x.113] 。
* 通常，稀疏矩阵包含大量的元素，当我们要开始进行线性求解时，这些元素实际上是零。这种元素是在我们消除约束条件或实现迪里希特条件时引入的，在这种情况下，我们通常会删除受约束行和列中的所有条目，即把它们设为零。对于本教程程序中所考虑的三维应用，存在于稀疏模式中但并不真正包含任何信息的那部分元素，可以达到矩阵中元素总数的四分之一。请记住，矩阵-向量乘积或前置条件器对稀疏矩阵的所有元素（甚至那些为零的元素）进行操作，这是我们在这里要避免的低效率。
* 直接解决约束自由度的一个好处是，我们可以避免在我们的稀疏矩阵中出现大部分将为零的条目&mdash；我们在构建矩阵时不需要约束条目（与传统算法相反，传统算法是先填充矩阵，然后才解决约束）。这将在形成矩阵-向量乘积时节省内存和时间。我们要做的是将约束信息传递给生成稀疏模式的函数，然后设置一个<tt>false</tt>参数，指定我们不打算使用约束条目。
* [1.x.114]
* 顺便说一下，这个函数也避免了对稀疏模式的<tt>condense()</tt>函数的调用。
* 

* [1.x.115][1.x.116] 。
* 

* 下面开发的程序已经看到了很多的TLC。我们在剖析工具（主要是[1.x.117]的cachegrind和callgrindtools，以及KDE[1.x.118]的visualization程序）下反复运行它，看看瓶颈在哪里。这已经得到了回报：通过这种努力，如果考虑到细化周期0到3的运行时间，该程序的速度已经提高了四倍，将CPU指令的总执行数量从869,574,060,348减少到199,853,005,625。对于更高的细化水平，收益可能更大，因为一些不是[2.x.137]的算法已经被取消了。
* 基本上，目前程序中有两种算法不随自由度数量的增加而线性变化：自由度的重新编号（即[2.x.138]，和线性求解器（即[2.x.139]）。对于第一个算法，虽然自由度的重新排序可能不是线性扩展，但它是整个算法不可缺少的一部分，因为它极大地提高了稀疏ILU的质量，很容易弥补计算重新编号所花费的时间；DoFRenumberingnamespace的文档中显示了图表和时间，也强调了下面选择的Cuthill-McKee reorderingalgorithm的原因。
* 至于线性求解器：如上所述，我们在这里的实现使用的是Schur补码公式。这不一定是最好的选择，但展示了交易中的各种重要技术。关于哪种求解器最好的问题在本程序的[1.x.119]中再次讨论，并附有显示备选求解器和其结果比较的代码。
* 除此以外，在本程序的创建过程中，还测试和改进了许多其他算法。例如，在建立稀疏模式时，我们最初使用了一个（现在已经不存在了）BlockCompressedSparsityPatternobject，它一次增加一个元素；然而，它的数据结构对于我们在3D中的离散化所产生的每行大量非零条目适应性很差，导致了一个二次方行为。取代deal.II中的内部算法，一次设置许多元素，并使用BlockCompressedSimpleSparsityPattern（截至2015年初，它又被BlockDynamicSparsityPattern取代）作为一个更好的适应性数据结构，消除了这个瓶颈，代价是内存消耗略高。同样，SparseILU类中分解步骤的实现也非常低效，已经被一个快10倍的步骤所取代。甚至SparseILU的vmult函数也得到了改进，节省了大约20%的时间。在这里和那里都做了小的改进。此外，AffineConstraints对象被用来消除稀疏矩阵中大量最终为零的条目，见[1.x.120]。
* 这里显示了在细化周期0到3的三维过程中，在程序的不同地方花费了多少CPU指令的概况。
* [2.x.140] 
* 可以看出，在这个细化水平上，大约四分之三的指令数花在实际求解上（左边的[2.x.141]调用，中间的[2.x.142]调用用于Schurcomplement求解，还有一个方框代表[1.x.121]求解中与SparseILU和SparseMatrix的乘法）。大约五分之一的指令用于矩阵装配和稀疏ILU计算（右下角的方框），其余的用于其他方面。由于[2.x.143]中的浮点运算通常比矩阵组装中的许多逻辑运算和查表要长得多，所以矩阵组装所占用的运行时间的比例实际上大大低于指令的比例，这在我们在结果部分的比较中会很明显。
* 对于更高的细化水平，代表求解器的方框以及右上角源自重排算法的蓝色方框将以牺牲程序的其他部分为代价而增长，因为它们的规模不是线性的。在这个中等的细化水平上（3168个单元和93176个自由度），线性求解器已经占了大约四分之三的指令，这是一个很好的迹象，说明这个程序中使用的大多数算法都是经过良好调整的，加速程序的主要改进很可能不是来自手工优化的个别方面，而是通过改变求解器的算法。我们将在下面的结果讨论中也讨论这一点。
* 最后一点，作为参考，下面的图片也显示了在优化这个程序的早期阶段，概况是怎样的。
* [2.x.144] 
* 如上所述，这个版本的运行时间大约是第一个配置文件的四倍，其中稀疏ILU分解占用了大约30%的指令数，而操作早期低效的DynamicSparsityPattern大约占10%。这两个瓶颈后来都被完全消除了。
* 

* [1.x.122] [1.x.123].
* [1.x.124] [1.x.125].
 

* 
* 像往常一样，我们从包括一些著名的文件开始。
* 

* 
* [1.x.126]
* 
* 然后我们需要包括稀疏直接求解器UMFPACK的头文件。
* 

* 
* [1.x.127]
* 
* 这包括不完全LU因子化的库，它将被用作三维的预处理程序。
 

* 
* [1.x.128]
* 
* 这是C++语言。
* 

* 
* [1.x.129]
* 
* 和所有的程序一样，包含了命名空间dealii。
* 

* 
* [1.x.130]
* 
* [1.x.131] [1.x.132]。
 

* 
* 正如介绍中所解释的，我们将分别对两个和三个空间维度使用不同的预处理程序。我们通过使用空间维度作为模板参数来区分它们。关于模板的细节，请参见[2.x.145]。我们不打算在这里创建任何预处理对象，我们所做的只是创建一个持有确定预处理类的本地别名的类，这样我们就可以以独立于维度的方式编写我们的程序。
* 

* 
* [1.x.133]
* 
* 在二维中，我们将使用一个稀疏的直接求解器作为预处理程序。
* 

* 
* [1.x.134]
* 
* 而三维中的ILU预处理，由SparseILU调用。
* 

* 
* [1.x.135]
* 
* [1.x.136] [1.x.137]。
 

* 
* 这是对[2.x.146]的改编，所以主类和数据类型与那里使用的几乎相同。唯一的区别是我们有一个额外的成员 [2.x.147] ，用于预处理Schur补码，以及一个相应的稀疏模式 [2.x.148] 。此外，我们没有依赖LinearOperator，而是实现了我们自己的InverseMatrix类。  
* 在这个例子中，我们还使用了自适应网格细化，其处理方式与 [2.x.149] 类似。根据介绍中的讨论，我们也将使用AffineConstraints对象来实现Dirichlet边界条件。因此，我们改变了名称 [2.x.150] 。
* 

* 
* [1.x.138]
* 
* 这一条是新的：我们将使用一个所谓的共享指针结构来访问预处理程序。共享指针本质上只是指针的一种方便形式。几个共享指针可以指向同一个对象（就像普通的指针一样），但是当最后一个指向前提器对象的共享指针对象被删除时（例如，如果一个共享指针对象超出了范围，如果它是一个成员的类被销毁，或者如果指针被分配到一个不同的前提器对象），那么指向的前提器对象也被销毁。这确保了我们不必手动跟踪有多少地方仍在引用一个前置条件器对象，它永远不会产生内存泄漏，也不会产生一个指向已被销毁对象的悬空指针。
* 

* 
* [1.x.139]
* 
* [1.x.140] [1.x.141].
 

* 
* 如同[2.x.151]和其他大多数例子程序一样，下一个任务是定义PDE的数据：对于斯托克斯问题，我们将在部分边界上使用自然边界值（即同质诺伊曼型），对于这些边界我们不需要做任何特殊处理（同质性意味着弱形式中的相应项只是零），而在边界的其余部分使用速度的边界条件（狄里奇型），如介绍中所述。  
* 为了强制执行速度上的Dirichlet边界值，我们将像往常一样使用[2.x.152]函数，这要求我们写一个具有与有限元一样多分量的函数对象。换句话说，我们必须在[2.x.153]-空间上定义函数，但我们在插值边界值时要过滤掉压力分量。
* 

* 
* 下面的函数对象是介绍中描述的边界值的表示。
* 

* 
* [1.x.142]
* 
* 我们为右手边实现了类似的函数，对于目前的例子来说，右手边只是简单的零。
* 

* 
* [1.x.143]
* 
* [1.x.144] [1.x.145].
 

* 
* 线性求解器和预处理器在介绍中已经广泛讨论过了。在这里，我们创建将被使用的各自对象。
* 

* 
* [1.x.146] [1.x.147] [2.x.154]类表示逆矩阵的数据结构。与[2.x.155]不同，我们用一个类来实现，而不是用辅助函数inverse_linear_operator()，我们将把这个类应用于不同种类的矩阵，这些矩阵需要不同的预处理程序（在[2.x.156]中，我们只对质量矩阵使用非同一性预处理程序）。矩阵和预处理器的类型通过模板参数传递给这个类，当创建[2.x.157]对象时，这些类型的矩阵和预处理器对象将被传递给构造函数。成员函数[2.x.158]是通过求解一个线性系统得到的。
* 

* 
* [1.x.148]
* 
* 这就是[2.x.159]函数的实现。
* 

* 
* 在这个类中，我们对解算器的控制使用了一个相当大的容忍度。这样做的原因是，这个函数使用得非常频繁，因此，任何使CG求解中的残差变小的额外努力都会使求解更加昂贵。请注意，我们不仅将该类作为Schur补数的预处理程序，而且在形成拉普拉斯矩阵的逆时也使用该类；因此，该类直接对解本身的精度负责，所以我们也不能选择太大的容差。
* 

* 
* [1.x.149]
* 
* [1.x.150] [1.x.151]
 

* 
* 这个类实现了介绍中讨论的Schur补码。它与 [2.x.160] 相类似。 不过，我们现在用一个模板参数[2.x.161]来调用它，以便在指定逆矩阵类的各自类型时访问它。作为上述定义的结果，声明[2.x.162]现在包含了上述预处理类的第二个模板参数，这也影响到[2.x.163]。
* 

* 
* [1.x.152]
* 
* [1.x.153] [1.x.154].
 

 
* [1.x.155] [1.x.156].
 

* 
* 这个类的构造函数看起来与 [2.x.164] 的构造函数非常相似。构造函数初始化了多项式阶数、三角形、有限元系统和dof处理器的变量。矢量速度分量的基础多项式函数的阶数为[2.x.165]，压力的阶数为[2.x.166]。 这就得到了LBB稳定元素对[2.x.167]，通常被称为Taylor-Hood元素。  
* 注意，我们用MeshSmoothing参数初始化三角形，这可以确保单元的细化是以PDE解的近似保持良好的方式进行的（如果网格过于非结构化就会出现问题），详见[2.x.168]的文档。
* 

* 
* [1.x.157]
 
* [1.x.158] [1.x.159].
 

* 
* 给定一个网格，该函数将自由度与之关联，并创建相应的矩阵和向量。在开始的时候，它还释放了指向预处理对象的指针（如果此时共享的指针指向任何东西的话），因为在这之后肯定不会再需要它了，在装配矩阵之后必须重新计算，并且将稀疏矩阵从它们的稀疏模式对象中解开。  
* 然后我们进行自由度的分配和重新编号。为了使ILU预处理程序（三维）有效地工作，重要的是以这样的方式列举自由度，以减少矩阵的带宽，或者也许更重要的是：以这样的方式使ILU尽可能地接近于真正的LU分解。另一方面，我们需要保留在[2.x.169]和[2.x.170]中已经看到的速度和压力的块结构。这要分两步完成。首先，对所有的道夫进行重新编号，以提高ILU，然后我们再一次按组件重新编号。由于[2.x.171]没有触及单个块内的重新编号，所以第一步的基本重新编号仍然存在。至于如何对自由度进行重新编号以改善ILU：deal.II有许多算法试图找到排序以改善ILU，或减少矩阵的带宽，或优化其他方面。DoFRenumbering命名空间显示了我们在本教程程序中基于这里讨论的测试案例而获得的几种算法的结果比较。在这里，我们将使用传统的Cuthill-McKee算法，该算法已经在之前的一些教程程序中使用。 在[1.x.160]中我们将更详细地讨论这个问题。
* 

* 
* 与以前的教程程序相比，还有一个变化。没有理由对[2.x.172]的速度成分进行单独排序。事实上，与其先列举所有[2.x.173]-velocities，再列举所有[2.x.174]-velocities，等等，我们希望把所有速度放在一起，只在速度（所有分量）和压力之间进行区分。默认情况下，[2.x.175]函数不是这样做的：它把每个矢量分量分开处理；我们要做的是把几个分量分成 "块"，并把这个块结构传递给该函数。因此，我们分配一个有多少个元素的向量[2.x.176]，并描述所有速度分量对应于块0，而压力分量将构成块1。
* 

* 
* [1.x.161]
* 
* 现在是迪里希特边界条件的实现，这在介绍中的讨论后应该是很明显的。所有的变化是这个函数已经出现在设置函数中，而我们习惯于在一些装配程序中看到它。在我们设置网格的下面，我们将把施加Dirichlet边界条件的顶部边界与边界指标1联系起来。 我们必须将这个边界指标作为第二个参数传递给下面的插值函数。 不过，还有一件事。 描述Dirichlet条件的函数是为所有分量定义的，包括速度和压力。然而，Dirichlet条件只为速度而设置。 为此，我们使用一个只选择速度分量的ComponentMask。通过指定我们想要的特定分量，从有限元中获得该分量掩码。由于我们使用自适应细化网格，仿生约束对象需要首先填充由DoF处理程序生成的悬挂节点约束。注意这两个函数的顺序；我们首先计算悬挂节点约束，然后将边界值插入约束对象。这确保了我们在有悬挂节点的边界上尊重H<sup>1</sup>一致性（在三个空间维度上），悬挂节点需要支配Dirichlet边界值。
* 

* 
* [1.x.162]
 
* 与[2.x.177]相类似，我们计算各个部件中的道夫。我们可以用与那里相同的方式来做，但我们想在我们已经用于重新编号的块结构上进行操作。函数 [2.x.178] 的作用与 [2.x.179] 相同，但现在通过 [2.x.180] 分成了速度和压力块。
* 

* 
* [1.x.163]
 
* 下一个任务是为我们将创建的系统矩阵分配一个稀疏模式，为预处理矩阵分配一个稀疏模式。我们可以用与[2.x.181]相同的方式来做这件事，即通过[2.x.182]直接建立一个SparsityPattern类型的对象，但是，有一个重要的理由不这样做。在3D中，函数[2.x.183]为各个道夫之间的耦合产生了一个保守但相当大的数字，因此，最初为创建矩阵的稀疏性模式提供的内存太多
* 
*--实际上，对于中等规模的三维问题，初始的稀疏模式甚至无法放入大多数系统的物理内存中，也可参见[2.x.184]中的讨论。相反，我们首先建立临时对象，使用不同的数据结构，不需要分配更多的内存，但不适合作为SparseMatrix或BlockSparseMatrix对象的基础；在第二步，我们再将这些对象复制到BlockSparsityPattern类型的对象中。这与我们在 [2.x.185] 和 [2.x.186] 中所做的完全相似。特别是，我们利用了这样一个事实，即我们永远不会写入系统矩阵的[2.x.187]块，而这是唯一需要为预处理矩阵填充的块。    
* 所有这些都是在新范围内完成的，这意味着一旦信息被复制到[2.x.189]，[2.x.188]的内存将被释放。
* 

* 
* [1.x.164]
* 
* 最后，系统矩阵、前导矩阵、解决方案和右侧向量是由块结构创建的，与 [2.x.190] 中的方法类似。
* 

* 
* [1.x.165]
* 
* [1.x.166] [1.x.167].
 

* 
* 装配过程遵循[2.x.191]和引言中的讨论。我们使用众所周知的缩写来表示持有本单元的局部矩阵、右手和自由度的全局编号的数据结构。
* 

* 
* [1.x.168]
* 
* 接下来，我们需要两个对象，作为FEValues对象的提取器。它们的使用在关于 [2.x.192] vector_valued 的报告中做了详细解释。
* 

* 
* [1.x.169]
* 
* 作为对[2.x.193]和[2.x.194]的扩展，我们包括了一些优化，使这个特殊问题的装配速度大大加快。这些改进是基于这样的观察：当我们像[2.x.195]那样做时，我们做了几次计算，次数太多：对称梯度实际上在每个正交点有[2.x.196]个不同的值，但我们从FEValues对象中提取[2.x.197]次
* 
* - 对于[2.x.198]的循环和[2.x.199]的内循环都是如此。在3D中，这意味着评估它[2.x.200]次而不是[2.x.201]次，这是一个不小的差别。    
* 所以我们在这里要做的是，在开始对单元上的道夫进行循环之前，在正交点得到一个秩-2张量的向量（类似的还有压力上的发散和基函数值）来避免这种重复计算。首先，我们创建各自的对象来保存这些值。然后，我们开始在所有单元上进行循环，并在正交点上进行循环，在那里我们首先提取这些值。我们在这里还实现了一个优化：本地矩阵（以及全局矩阵）将是对称的，因为所有涉及的操作都是相对于[2.x.202]和[2.x.203]对称的。这可以通过简单地运行内循环而不是到[2.x.204]，即外循环的索引来实现。
* 

* 
* [1.x.170]
* 
* 现在最后是系统矩阵和我们用于预处理程序的矩阵的双线性形式。回顾一下，这两个的公式是

* 
* [1.x.171]
* 和

* 
* [1.x.172]
*，其中[2.x.205]和[2.x.206]是[2.x.207]th形状函数的速度和压力成分。然后，上述各种术语在以下实施中很容易被识别。
* 

* 
* [1.x.173]
* 
* 注意，在上述（1）的实现中，`operator*`被重载用于对称张量，产生两个张量之间的标量乘积。                
* 对于右手边，我们利用形状函数只在一个分量中不为零的事实（因为我们的元素是原始的）。 我们不是将代表形状函数i的dim+1值的张量与整个右手边的向量相乘，而是只看唯一的非零分量。函数[2.x.208]将返回这个形状函数所处的分量（0=x速度，1=y速度，2=2d中的压力），我们用它来挑选出右手边向量的正确分量来相乘。
* 

* 
* [1.x.174]
* 
* 在我们将局部数据写入全局矩阵之前（同时使用AffineConstraints对象来应用Dirichlet边界条件并消除悬挂的节点约束，正如我们在介绍中讨论的那样），我们必须注意一件事。由于对称性，我们只建立了一半的局部矩阵，但我们要保存完整的矩阵，以便使用标准函数进行解算。这是通过翻转指数来实现的，以防我们指向本地矩阵的空部分。
* 

* 
* [1.x.175]
* 
* 在我们要解决这个线性系统之前，我们为速度-速度矩阵生成一个预处理程序，即系统矩阵中的[2.x.209]。如上所述，这取决于空间维度。由于[2.x.210]别名所描述的两个类具有相同的接口，因此无论我们想使用稀疏直接求解器还是ILU，都不需要做任何不同的事情。
* 

* 
* [1.x.176]
* 
* [1.x.177] [1.x.178].
 

* 
* 经过前面介绍中的讨论和各自类的定义，[2.x.211]函数的实现是相当直接的，其方式与[2.x.212]类似。首先，我们需要一个[2.x.213]类的对象，代表矩阵A的逆。正如在介绍中所描述的那样，在[2.x.214]类的内部预处理器的帮助下，生成了逆。
* 

* 
* [1.x.179]
 
* 这与[2.x.215]中一样。我们生成 Schur 补数的右手边 [2.x.216] 和一个代表各自线性运算的对象 [2.x.217] ，现在有一个模板参数表示预处理器
* 
* - 按照该类的定义。
* 

* 
* [1.x.180]
 
* 解算器调用的常规控制结构被创建...
* 

* 
* [1.x.181]
* 
* 现在是对舒尔补码的预处理。正如介绍中所解释的，预处理是由压力变量的质量矩阵来完成的。      
* 实际上，求解器需要有[2.x.218]形式的预调节器，所以我们需要创建一个反操作。我们再次使用[2.x.219]类的对象，它实现了求解器需要的[2.x.220]操作。 在这种情况下，我们必须对压力质量矩阵进行反转。正如在早期的教程程序中已经证明的那样，质量矩阵的反转是一个相当便宜和简单的操作（与拉普拉斯矩阵等相比）。带有ILU预处理的CG方法在5-10步内收敛，这与网格大小无关。 这正是我们在这里所做的。我们选择另一个ILU预处理，并通过相应的模板参数将其带入InverseMatrix对象。 然后在逆矩阵的vmult操作中调用一个CG求解器。      
* 另一种方法是选择因子为1.2的SSOR预处理器，这种方法的构建成本较低，但事后需要更多的迭代。它需要大约两倍的迭代次数，但其生成的成本几乎可以忽略不计。
* 

* 
* [1.x.182]
 
* 有了舒尔补码和高效的预处理程序在手，我们可以用通常的方法解决压力的相应方程（即解向量中的块0）。
* 

* 
* [1.x.183]
 
* 在这第一个求解步骤之后，为了实现一致的压力场，必须将悬挂的节点约束分布到求解中。
* 

* 
* [1.x.184]
 
* 如[2.x.221]，我们最后需要求解速度方程，在这里我们插入压力方程的解。这只涉及我们已经知道的物体
* 
* 所以我们只需将[2.x.222]乘以[2.x.223]，减去右边的部分，再乘以[2.x.224]的逆数。最后，我们需要将悬空节点的约束分布在一起，以获得一个一致的流场。
* 

* 
* [1.x.185]
* 
* [1.x.186] [1.x.187] [1.x.187].
 

* 
* 下一个函数是生成图形输出。在这个例子中，我们将使用VTK文件格式。 我们给问题中的各个变量附上名字：[2.x.225]速度的组成部分和[2.x.226]压力。  
* 并非所有的可视化程序都有能力将单个矢量分量分组为一个矢量，以提供矢量图；特别是对于一些基于VTK的可视化程序，这一点是成立的。在这种情况下，在包含数据的文件中应该已经描述了组件的逻辑分组为矢量的情况。换句话说，我们需要做的是为我们的输出编写者提供一种方法，让他们知道有限元的哪些分量在逻辑上形成一个矢量（在[2.x.227]空间维度上有[2.x.228]分量），而不是让他们假设我们只是有一堆标量场。 这是用[2.x.229]命名空间的成员实现的：和文件名一样，我们创建一个矢量，其中第一个[2.x.230]分量指的是速度，并被赋予标签[2.x.231]我们最后推一个标签[2.x.232]来描述压力变量的分组情况。
* 

* 
* 然后函数的其余部分与[2.x.233]中的相同。
* 

* 
* [1.x.188]
* 
* [1.x.189] [1.x.190].
 

* 
* 这是[2.x.234]类中最后一个有趣的函数。 正如它的名字所示，它获取问题的解决方案并在需要的地方细化网格。其过程与[2.x.235]中的相应步骤相同，不同的是我们只根据压力的变化进行细化，也就是说，我们用ComponentMask类型的掩码对象调用Kelly误差估计器，选择我们感兴趣的压力的单一标量分量（我们通过指定我们想要的分量从有限元类得到这样一个掩码）。此外，我们没有再次粗化网格。
* 

* 
* [1.x.191]
* 
* [1.x.192] [1.x.193]。
* 

* 
* 斯托克斯类的最后一步和往常一样，是生成初始网格的函数，并按各自的顺序调用其他函数。  
* 我们从一个大小为[2.x.236]（2D）或[2.x.237]（3D）的矩形开始，在[2.x.238]中分别放置为[2.x.239]或[2.x.240] 。在每个方向上以相等的网格大小开始是很自然的，所以我们在第一个坐标方向上将初始矩形细分四次。为了将创建网格所涉及的变量的范围限制在我们实际需要的范围内，我们将整个块放在一对大括号之间。
* 

* 
* [1.x.194]
* 
* 边界指标1被设置为所有受Dirichlet边界条件约束的边界，即位于最后一个坐标方向上的0的面。详见上面的例子描述。
* 

* 
* [1.x.195]
 
* 然后我们在第一次求解之前应用一个初始细化。在三维中，会有更多的自由度，所以我们在那里细化得更少。
* 

* 
* [1.x.196]
 
* 正如在[2.x.241]中首次看到的那样，我们在不同的细化级别上循环细化（除了第一个循环），设置自由度和矩阵，组装，求解和创建输出。
* 

* 
* [1.x.197]
* 
* [1.x.198] [1.x.199]
 

* 
* 主函数与 [2.x.242] 中相同。我们将元素度数作为参数传递，并在著名的模板槽中选择空间维度。
* 

* 
* [1.x.200]
* [1.x.201][1.x.202][1.x.203] 。
* 

* [1.x.204][1.x.205]。
* 

* [1.x.206][1.x.207] * [1.x.206][1.x.207]。
 

* 在[2.x.243]函数中空间维度设置为2的情况下运行程序，会产生以下输出（在 "释放模式 "下，[2.x.244] ）。
* [1.x.208]
* 
* 上述整个计算在一台相当快的（以2015年的标准）机器上需要大约2秒钟。
* 我们立即看到的是，（外部）迭代的数量并没有随着我们细化网格而增加。这证实了导言中的说法，即用质量矩阵对舒尔补码进行预处理，确实可以得到一个与身份矩阵频谱相等的矩阵（即其特征值上下受限，与网格大小或单元的相对大小无关）。换句话说，质量矩阵和Schur补码在光谱上是等价的。
* 在下面的图片中，我们展示了程序中前六个细化步骤的网格。 观察网格是如何在解决方案迅速变化的区域内被细化的。在上边界，我们有Dirichlet边界条件，即
* 
在上边界，我们的迪里希特边界条件在左半部分是*-，在右半部分是1，所以在[2.x.245]处有一个突然的变化。同样，在两个上角的数据中，也有从Dirichlet到Neumann的变化，所以那里也需要细化。
* [2.x.246] 
* 最后，下面是一个流场的图。它显示了流体随着上边界的移动而被来自下方的物质所取代。
* [2.x.247] 
* 该图使用了基于VTK的可视化程序（在这种情况下是VisIt）的能力来显示矢量数据；这是我们将使用中的有限元的速度分量定为矢量分量的集合，而不是在本教程程序的[2.x.248]功能中的独立标量分量的结果。
* 

* 
* [1.x.209][1.x.210] 。
* 

* 在3D中，程序的屏幕输出看起来像这样。
* [1.x.211]
* 
* 我们再次看到，随着我们对网格的细化，外部迭代的次数并没有增加。然而，计算时间明显增加：对于上述每个迭代，分别需要0.14秒、0.63秒、4.8秒、35秒、2分33秒和13分12秒。这种运行时间的整体超线性（未知数的数量）增加是由于我们的内部求解器不是[2.x.249]：一个简单的实验表明，随着我们不断细化网格，反转速度-速度块的ILU-条件化CG迭代的平均数量[2.x.250]增加。
* 我们将解决如何改进我们的求解器[1.x.212]的问题。
* 至于图形输出，在求解过程中产生的网格看起来如下。
* [2.x.251] 
* 同样，它们基本上显示了由边界条件引入的奇异点的位置。计算出的矢量场构成了一个有趣的图形。
* [2.x.252] 
* 这里显示的等值线也是压力变量的等值线，显示了不连续速度边界条件点的奇异性。
* 

* 
* [1.x.213][1.x.214] 。
* 

* 正如在生成稀疏模式时解释的那样，在使用不完全LU分解这样的预处理程序时，记住自由度的编号是很重要的。使用刚度矩阵中的非零元素的分布可以很好地说明这一点。
* 如果我们不对自由度重新编号（即不使用[2.x.253]，而是使用[2.x.254]来确保自由度被适当地排序到矩阵和向量的相应块中），那么在二维的第一次自适应解析之后，我们会得到以下图像。
* [2.x.255] 
* 为了生成这样的图，你必须在设置步骤的末尾插入一段代码，如以下内容。
* [1.x.215]
* 
* 可以清楚地看到，非零项几乎分布在整个矩阵中。 这使得用ILU进行预处理的效率很低。ILU生成的高斯消元(LU分解)没有填充元素，这意味着更多的暂定填充元素会导致对完整分解的近似度更低。
* 在这个方案中，我们因此选择了一种更先进的成分重新编号法。 用[2.x.256]进行重新编号，并将成分归入速度和压力，产生以下输出。
* [2.x.257] 
* 很明显，情况有了很大的改善。大多数元素现在都集中在矩阵中（0,0）块的对角线周围。对其他区块也有类似的效果。在这种情况下，ILU分解将更接近于全LU分解，这提高了预处理程序的质量。值得注意的是，稀疏直接求解器UMFPACK在实际生成稀疏LU分解之前，会对方程进行一些内部重新编号；这个过程导致了与我们从Cuthill-McKee算法中得到的模式非常相似）。
* 最后，我们想仔细看看三维的稀疏模式。我们只展示了矩阵的(0,0)块，也是在一次适应性细化之后。除了矩阵大小增加的事实之外，还可以看到矩阵中多了很多条目。此外，即使是优化后的重新编号，也会有相当数量的暂定填充元素。这说明了为什么UMFPACK在3D中不是一个好的选择。
* 
* - 一个完整的分解需要许多新的条目，而这些条目最终将无法装入物理内存（RAM）。
* [2.x.258] 
* 

* 
* [1.x.216][1.x.217] 。
* 

* [1.x.218][1.x.219][1.x.220] 。
* 我们在计算结果一节中看到，外迭代的数量并不取决于网格的大小，从可扩展性的角度来看，这是最佳的。然而，这并不适用于整个求解器，如上所述：在生成矩阵[2.x.259]和质量矩阵[2.x.260]的逆时，我们没有研究内部迭代的数量。当然，这在二维情况下是没有问题的，我们用直接求解器对[2.x.261]进行预处理，逆矩阵结构的[2.x.262]操作将在一个单一的CG步骤中收敛，但这在三维情况下发生变化，我们只使用ILU预处理器。 在那里，反演[2.x.263]所需的预处理CG步骤的数量随着网格的细化而增加，每个[2.x.264]操作在上述细化步骤中平均涉及大约14、23、36、59、75和101次内部CG迭代。另一方面，在二维和三维中，应用反压力质量矩阵的迭代次数总是在5次左右）。 总而言之，大部分工作都是花在反复解决具有相同矩阵[2.x.265]的线性系统上。让这看起来更糟糕的是，我们实际上是在反转一个矩阵，该矩阵的大小约为整个系统矩阵的95%，并且代表了sparsitypattern中85%的非零项。因此，自然的问题是，在计算块状系统的解时，用矩阵[2.x.266]解约15次的线性系统是否合理。
* 当然，答案是，我们可以用其他一些（大部分时间更好的）方法来做。然而，必须指出的是，像手头这样的不确定系统对线性代数的要求确实比我们在早期教程程序中看到的标准椭圆问题高得多。如果与类似规模的椭圆问题相比，其改进仍不令人满意。无论如何，我们将在下面介绍一些对线性求解器的改进，我们将在[2.x.267]程序中用附加选项重新考虑这一讨论。
* [1.x.221][1.x.222][1.x.223]改善线性求解过程速度的第一个尝试是选择一个Dof重排序，使ILU更接近于全LU分解，这在代码中的注释中已经提到。DoFRenumbering命名空间比较了斯托克斯方程的道夫重新编号的几种选择。关于计算时间的最佳结果是通过调用[2.x.268]找到的，通过该程序，内部求解器需要相当少的操作，例如，在第4周期对[2.x.269]进行反演时，大约有62次CG迭代，而标准Cuthill-McKee算法大约有75次。另外，在第4周期，对[2.x.270]的调用的计算时间从17分钟减少到11分钟。然而，King的排序（以及由[2.x.271]命名空间提供的一般排序）有一个严重的缺点
* 
* - 它比构建中的交易版本使用更多的内存，因为它作用于抽象图形，而不是由三角化提供的几何图形。在目前的情况下，重新编号需要大约5倍的内存，这就产生了一个在三维中具有120万个未知数的最后周期的不可行的算法。
*[1.x.224][1.x.225]
* 另一个改善情况的想法是选择一个能使(0,0)矩阵[2.x.272]的CG在与esh无关的迭代次数中收敛的再调节器，例如10到30。我们已经在[2.x.273]中看到了这样的候选方案：多网格。
* [1.x.226][1.x.227] 。
* [1.x.228]即使在[2.x.274]中有一个很好的预处理程序，我们仍然需要反复求解同一个线性系统（虽然有不同的右手边），以使舒尔补码的解法得到验证。我们这里要讨论的方法是如何将内部迭代和外部迭代结合起来。如果我们坚持计算舒尔补码，就没有其他的可能性了。
* 另一种方法是一次性攻击块系统，并使用近似的Schur补码作为有效的预处理程序。这个想法是这样的。如果我们找到一个块状预处理程序[2.x.275]，使得矩阵[1.x.229]是简单的。
* 是简单的，那么使用该预处理程序的迭代求解器将在少数迭代中收敛。使用舒尔补码[2.x.276]，我们发现[1.x.230]*似乎是很好的选择。
*似乎是一个很好的选择，因为[1.x.231]。
* 这就是引言中提到的Silvester和Wathen的论文所采取的方法（除了Silvester和Wathen的用户不考虑预处理）。在这种情况下，基于Krylov的迭代方法只有在应用[2.x.277]和[2.x.278]的精确求逆器时才会一步到位，因为所有的特征值都是1（这种方法的迭代次数受不同特征值的限制）。下面，我们将讨论如何为这个问题选择一个适当的求解器。首先，我们要仔细研究一下预处理程序的实现。
* 由于[2.x.279]的目的只是作为一个预处理程序，我们将使用舒尔补码[2.x.280]和矩阵[2.x.281]的逆的近似值。因此，舒尔补集将由压力质量矩阵[2.x.282]近似，我们使用[2.x.283]的预处理器（周围没有反矩阵类）来近似[2.x.284]。
* 这里有一个实现块状Schurcomplement预处理的类。根据上面的推导，对块向量的[2.x.285]操作可以通过三个连续的操作来指定。
* [1.x.232]
* 
* 由于我们现在对整个块系统进行操作，我们必须忍受一个缺点：我们需要对整个块系统而不是较小的压力空间进行求解器的迭代。
* 现在我们转向我们应该对块系统使用哪种求解器的问题。第一个观察结果是，产生的预处理矩阵不能用CG求解，因为它既不是正定也不是对称的。
* deal.II库实现了几个适合手头问题的求解器。一个选择是求解器[2.x.286]"BiCGStab"，它被用于解决[2.x.287]中的非对称平流问题。第二种选择，也就是我们要选择的，是[2.x.288]"GMRES"（广义最小残差）。这两种方法都有其优点和缺点
* 
* - 在有些问题上，两种方法中的一种明显优于另一种，反之亦然。[1.x.233]关于GMRES方法的文章给出了一个比较性的介绍。
* 对于我们的具体问题和[2.x.289]的ILU预处理程序，我们当然需要在大问题尺寸的块系统上进行数百次迭代（我们不会打败CG！）。实际上，这不利于GMRES。在GMRES迭代过程中，Krylov向量的基础被陆续建立起来，并对这些向量进行一些运算。这个基础上的向量越多，需要的操作和内存就越多。操作的数量以[2.x.290]的形式扩展，内存以[2.x.291]的形式扩展，其中[2.x.292]是Krylov基中的向量数量，[2.x.293]是（块）矩阵的大小。为了不让这些需求过度增长，deal.II将基的大小[2.x.294]默认为30个向量。这种GMRES方法的实现被称为GMRES(k)，默认为[2.x.295]。我们通过这一限制所获得的，即对操作和内存需求的约束，将被我们使用不完整的基来弥补。
* 
* - 这将增加所需的迭代次数。
* 另一方面，当需要多次迭代时，BiCGStab不会变慢（一次迭代只使用前面一个步骤的结果，而不是像GMRES那样使用所有的步骤）。除了BiCGStab由于需要两个矩阵-向量乘积（相比之下，CG或GMRES只需要一个），所以每一步的成本更高之外，还有一个主要原因使得BiCGStab不适合这个问题：预处理程序通过使用InverseMatrix类来应用压力质点矩阵的逆向。由于对矢量的反矩阵应用只是以近似的方式进行（精确的反矩阵太昂贵），这也会影响求解器。在BiCGStab的情况下，由于这种扰动，Krylov向量将不会是正交的。虽然这对于少量的步骤（最多50步）来说并不重要，但是当这些扰动在迭代的粗大过程中增长到相当大的程度时，就会破坏求解器的性能。
* 我们用BiCGStab做了一些实验，发现它在细化周期3之前比GMRES快（在3D中），但在周期4和5时变得非常慢（甚至比原来的Schur补码还慢），所以在这种情况下，该求解器是没有用的。对逆矩阵类选择一个更严格的容忍度（[2.x.296]而不是[2.x.297]）使BiCGStab在第4周期也表现良好，但没有改变在非常大的问题上的失败。
* 当然，GMRES也会受到近似求逆的影响，但它对正交性不敏感，而且在大问题上也保持了相对较好的性能，见下面的结果。
* 说到这里，我们来看看用[2.x.298]临时向量实现GMRES的求解器调用。
* [1.x.234]
* 
* 我们用BlockVector模板调用求解器，以使GMRES能够对块状向量和矩阵进行操作。还要注意的是，在我们将信息复制到另一个矩阵之后，我们需要将系统矩阵中的（1,1）块设置为零（我们将压力质量矩阵保存在那里，这不是问题的组成部分）。
* 除了两个选项的解决方案之外，我们还检查这两个变体的解决方案是否接近（即这个解决方案确实与我们之前的解决方案相同），并计算矢量差的无穷大。
* 让我们先看看二维的结果。
* [1.x.235]
* 
* 我们看到，块状舒尔补码预处理求解器和舒尔补码本身在求解时间上没有很大差别。原因很简单：我们用直接求解作为[2.x.300]的前置条件。
* 
* 所以我们不能指望通过避免内部迭代获得任何收益。我们看到，GMRES的迭代次数略有增加，但总的来说，两种选择是相当相似的。
* 画面当然会在三维中发生变化。
* [1.x.236]
* 
* 在这里，块状预处理求解器明显优于Schurcomplement，但是当网格点越多，优势越小。这是因为GMRES(k)与CG相比，在问题大小上的扩展性更差，正如我们前面所讨论的。 尽管如此，对于中等规模的问题，3-6倍的改进是相当令人印象深刻的。
* 

* [1.x.237][1.x.238] 。
* 这个问题的终极线性求解器可以想象为[2.x.301]的最佳预处理器（例如多网格）和上面描述的块状预处理器的组合，这是[2.x.302]和[2.x.303]教程程序（我们使用代数多网格方法）和[2.x.304]（我们使用几何多网格方法）中采取的方法。
* 

* [1.x.239][1.x.240] 。
* 另一个可以考虑的可能性是不设置块系统，而是一次性解决速度和压力系统。可以选择用UMFPACK直接求解（二维）或用ILU预处理的GMRES（三维）。这应该是很直接的尝试。
* 

* 
* [1.x.241][1.x.242] 。
* 

* 该程序当然也可以作为计算更有趣的情况下的流量的基础。编写这个程序的最初动机是希望它能成为一些地球物理流动问题的起点，例如在大陆板块漂移分离的地方（例如大洋中脊）岩浆的运动。当然，在这样的地方，几何形状比上面的例子更复杂，但这并不难适应。
* 例如，通过使用以下对边界值函数的修改
* [1.x.243]
*和以下方式生成网格作为域[2.x.305]。
* [1.x.244]
*然后我们得到断层线是弯曲的图像。[2.x.306] 
* 

* [1.x.245][1.x.246] [2.x.307] 。
* [0.x.1]

