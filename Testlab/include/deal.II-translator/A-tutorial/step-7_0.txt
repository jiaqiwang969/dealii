include/deal.II-translator/A-tutorial/step-7_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
*[1.x.28][1.x.29][1.x.30] 。
 

* 在本方案中，我们将主要考虑两个方面。[2.x.2] [2.x.3] 验证程序的正确性和生成收敛表； [2.x.4] 赫尔姆霍兹方程的非均质诺伊曼边界条件。[2.x.5] 除了这些主题，还将展示各种改进和技巧。
* 

*[1.x.31][1.x.32]
* 

* 可能从来没有一个不复杂的有限元程序从一开始就能正常工作。因此，有必要找到方法来验证一个计算出的解是否正确。通常，这可以通过选择模拟的设置来完成，这样我们就可以知道准确的连续解，并评估连续解和计算的离散解之间的差异。如果这个差值以正确的收敛顺序收敛为零，这已经是一个很好的正确性指示，尽管可能还有其他的误差源存在，而这些误差对总误差的贡献很小，或者是更高的顺序。在有限元模拟的背景下，这种通过选择适当的右手边和边界条件来选择解决方案的技术通常被称为[1.x.33]。
* 在这个例子中，我们不会去研究系统软件验证的理论，这是一个非常复杂的问题。相反，我们将展示deal.II在这方面可以提供的工具。这基本上是围绕着一个单一的函数的功能，[2.x.6]这个函数计算一个给定的连续函数和一个有限元场在每个单元上的各种规范之间的差异。当然，像任何其他积分一样，我们只能用正交公式来评估这些规范；因此，正确的正交公式的选择对于准确评估误差至关重要。这一点对于[2.x.7]准则尤其适用，我们只在正交点评估数值解和精确解的最大偏差；那么就不应该尝试使用正交公式，其评估只发生在[超级收敛](https://en.wikipedia.org/wiki/Superconvergence)可能发生的点上，例如最低阶高斯正交公式的高斯点，对于该矩阵的装配中的积分是正确的（例如，对于线性元素，不要使用QGauss(2)正交公式）。事实上，这通常也是对其他规范的良好建议：如果你的正交点偶然被选在由于超级收敛而导致误差特别小的位置，那么计算出来的误差看起来会比实际情况小得多，甚至可能表明收敛阶数更高。因此，我们将选择一个不同的正交公式来整合这些误差准则，而不是用于组装线性系统。
* 函数[2.x.8]对三角形的每个单元[2.x.9]进行所需规范的评估，并返回一个持有每个单元数值的向量。从局部值中，我们可以得到全局误差。例如，如果所有单元[2.x.12]的元素[2.x.11]的向量[2.x.10]包含局部[2.x.13]准则[2.x.14]，那么[1.x.34]就是全局[2.x.15]误差[2.x.16] 。
* 在程序中，我们将展示如何评估和使用这些量，并在网格细化过程中监测它们的值。当然，我们必须选择手头的问题，以便我们能够明确地说明解决方案和它的导数，但由于我们要评估程序的正确性，这只是合理。如果我们知道程序对一个（或者，如果想真正确定：许多）特别选择的右手边产生了正确的解决方案，我们可以相当有信心，它也会对我们不知道确切数值的问题计算出正确的解决方案。
* 除了简单地计算这些数量之外，我们还将展示如何从这个程序生成的数据中生成漂亮的格式化表格，并自动计算收敛率等。此外，我们还将比较不同的网格细化策略。
* 

* [1.x.35][1.x.36] 。
* 

* 本例程序的第二个完全不相关的主题是使用非同质边界条件。这些条件包括在使用边界积分的变异形式中，我们必须在组装右手边的矢量时进行数值评估。
* 在我们进行编程之前，让我们简单看一下数学公式。我们要解决的方程是亥姆霍兹方程，"带有漂亮的符号"：[1.x.37]在与[2.x.18]的正方形[2.x.17]上，在边界[2.x.20]的部分[2.x.19]上由迪里希特边界条件[1.x.38]增加，在其余部分[2.x.21]上由诺伊曼条件[1.x.39]增加。 我们说这个方程有 "好的符号"，因为算子[2.x.23]与同位[2.x.24]和[2.x.25]是一个正定算子；[1.x.40]是[2.x.26]，是建立时间-谐波过程的结果。如果[2.x.27]很大，算子就不是正定的，这就导致了各种问题，我们不需要在这里讨论。该算子也可能不是可逆的
* 
* - 即方程没有唯一的解
* 
如果[2.x.28]恰好是[2.x.29]的一个特征值，则该方程没有唯一的解 *）。)
* 因为我们想验证我们的数字解[2.x.30]的收敛性，我们需要一个设置，以便我们知道精确的解[2.x.31]。这就是 "人造解法 "的作用。为此，让我们选择一个函数[1.x.41]，其中指数的中心[2.x.32]为[2.x.33]、[2.x.34]和[2.x.35]，而半宽被设置为[2.x.36]。然后制造方法说：选择
* [1.x.42]
* 有了这个特殊的选择，我们推断原来问题的解决方案当然是[2.x.37]。换句话说，通过以特定的方式选择方程的右边和边界条件，我们已经为自己制造了一个我们知道其解决方案的问题。这使我们能够计算出我们的数字解决方案的误差。在下面的代码中，我们用[2.x.39]类来表示[2.x.38]，其他类将用来表示[2.x.40]和[2.x.41] 。
* 使用上述定义，我们可以陈述该方程的弱表述，其内容为：为所有测试函数[2.x.43]找到[2.x.42]，从而找到[1.x.43]。边际项[2.x.44]是通过部分积分和使用[2.x.45]对[2.x.46]和[2.x.47]对[2.x.48]出现的。因此，在离散公式中，我们用来建立全局矩阵和右手边向量的单元矩阵和向量看起来是这样的：[1.x.44] 。
* 由于域积分的生成已经在前面的例子中展示过多次，这里只对等高线积分的生成感兴趣。它的工作原理如下：对于域积分，我们有一个[2.x.49]类，它提供了形状值和梯度，以及雅各布行列式和其他信息，并指定了单元格中的正交点；同样，还有一个[2.x.50]类，为单元格面上的积分执行这些任务。我们向它提供一个流形的正交公式，该流形的维度比域的维度小一，以及我们想要进行积分的单元格和其表面的数字。然后，该类将计算该面的正交点的值、梯度、法向量、权重等，然后我们可以以与域积分相同的方式使用这些值。下面的程序显示了这样做的细节。
* 

* [1.x.45][1.x.46] 。
 

* 除了上面概述的数学主题外，我们还想用这个程序来说明良好编程实践的一个方面，即命名空间的使用。在为deal.II库编程时，我们非常注意不要为类和全局函数使用过于通用的名称，例如[2.x.51]等。此外，我们把所有的东西都放在命名空间[2.x.52]里。但是当一个人写的应用程序不是给别人使用的时候，就不一定会注意这么多了。如果你遵循[2.x.53]到[2.x.54]的编程风格，这些函数最终会出现在全局命名空间中，不幸的是，很多其他东西也在那里（基本上是C语言提供的所有东西，以及你通过头文件从操作系统得到的所有东西）。更糟糕的是，C语言的设计者在避免通用名称方面也不总是很谨慎；例如，符号<code>j1,jn</code>被定义在C头文件中（它们表示贝塞尔函数）。
* 为了避免不同函数或变量的名称发生冲突时产生的问题（通常会出现混乱的错误信息），好的做法是将你所做的一切放到[1.x.47]中。按照这种风格，我们将在程序的顶部打开一个名字空间[2.x.55]，将deal.II名字空间导入其中，将本程序特有的一切（除了[2.x.56]，它必须在全局名字空间中）放入其中，并且只在文件的底部关闭它。换句话说，这个程序的结构是这样的
* [1.x.48]
* 我们将在整个deal.II教程的剩余部分遵循这一方案。
* 

* [1.x.49] [1.x.50]
* [1.x.51] [1.x.52].
 

* 
* 这些第一个包含文件在以前的例子中都已经处理过了，所以我们不再解释其中的内容。
* 

* 
* [1.x.53]
* 
* 在这个例子中，我们将不使用DoFHandler类默认使用的编号方案，而是使用Cuthill-McKee算法重新编号。正如在[2.x.57]中已经解释过的，必要的函数被声明在以下文件中。
* 

* 
* [1.x.54]
 
* 然后我们将展示一个小技巧，我们可以确保对象在使用过程中不被删除。为此，deal.II有一个SmartPointer辅助类，它在这个文件中声明。
* 

* 
* [1.x.55]
* 
* 接下来，我们要使用介绍中提到的函数[2.x.58]，我们要使用一个ConvergenceTable，在运行过程中收集所有重要的数据，并在最后以表格形式打印出来。这些数据来自于以下两个文件。
* 

* 
* [1.x.56]
* 
* 最后，我们需要使用FEFaceValues类，它与FEValues类在同一个文件中声明。
* 

* 
* [1.x.57]
 
* 在我们继续实际实现之前的最后一步是打开一个命名空间[2.x.59]，我们将把所有的东西都放进去，正如在介绍的最后所讨论的那样，并把命名空间[2.x.60]的成员导入其中。
* 

* 
* [1.x.58]
* 
* [1.x.59] [1.x.60]。
 

* 
* 在实现实际求解的类之前，我们首先声明和定义一些代表右手边和求解类的函数类。由于我们要将数值得到的解与精确的连续解进行比较，我们需要一个代表连续解的函数对象。另一方面，我们需要右手边的函数，而这个函数当然与解共享一些特征。为了减少如果我们必须同时改变两个类中的某些东西而产生的依赖性，我们将两个函数的共同特征移到一个基类中。  
* 解（正如介绍中所解释的，我们选择三个指数之和）和右手边的共同特征是：指数的数量，它们的中心，以及它们的半宽。我们在以下类别中声明它们。由于指数的数量是一个编译时的常数，我们使用一个固定长度的[2.x.61]来存储中心点。
* 

* 
* [1.x.61]
* 
* 表示中心和指数宽度的变量刚刚被声明，现在我们还需要给它们赋值。在这里，我们可以展示另一个小小的模板魔法，即我们如何根据维度给这些变量分配不同的值。我们在程序中只使用2维的情况，但我们展示1维的情况是为了阐述一个有用的技术。  
* 首先，我们为1d情况下的中心赋值，我们将中心等距离地放在
* 
* - /3，0，和1/3。这个定义的<code>template &lt;&gt;</code>头显示了一个明确的专业化。这意味着，这个变量属于一个模板，但我们不是向编译器提供一个模板，让它通过用一些具体的值来替代[2.x.62]来专门化一个具体的变量，而是自己提供一个专门化，在这个例子中是[2.x.63] 。如果编译器在模板参数等于1的地方看到对这个变量的引用，它就知道它不需要通过替换[2.x.64]从模板中生成这个变量，而是可以立即使用下面的定义。
* 

* 
* [1.x.62]
* 
* 同样地，我们可以为[2.x.65]提供一个明确的特殊化。我们将2d情况下的中心放置如下。
* 

* 
* [1.x.63]
* 
* 还需要给指数的半宽指定一个值。我们希望对所有维度使用相同的值。在这种情况下，我们只需向编译器提供一个模板，它可以通过用一个具体的值替换[2.x.66]来生成一个具体的实例。
* 

* 
* [1.x.64]
* 
* 在声明和定义了解和右手的特征后，我们可以声明代表这两者的类。它们都代表连续函数，所以它们都派生于Function&lt;dim&gt;基类，而且它们也继承了SolutionBase类中定义的特征。  
* 实际的类是在下面声明的。请注意，为了计算数值解与连续解在L2和H1（半）规范下的误差，我们必须提供精确解的值和梯度。这比我们在以前的例子中所做的要多，在以前的例子中，我们所提供的只是一个或一列点的值。幸运的是，Function类也有用于梯度的虚拟函数，所以我们可以简单地重载Function基类中各自的虚拟成员函数。请注意，一个函数在[2.x.67]空间维度上的梯度是一个大小为[2.x.68]的向量，即一个等级为1、维度为[2.x.69]的张量。就像其他很多东西一样，该库提供了一个合适的类。这个类的一个新特点是，它明确地使用了张量对象，之前在 [2.x.70] 和 [2.x.71] 中作为中间词出现。张量是标量（等级为零的张量）、向量（等级为一的张量）和矩阵（等级为二的张量）以及高维对象的概括。张量类需要两个模板参数：张量等级和张量维度。例如，在这里我们使用等级为一的张量（向量），维度为[2.x.72]项）。虽然这比使用Vector的灵活性要差一些，但当编译时知道向量的长度时，编译器可以生成更快的代码。此外，指定一个秩为一、维数为[2.x.73]的张量，可以保证张量具有正确的形状（因为它是内置于对象本身的类型中的），所以编译器可以为我们抓住大多数与尺寸有关的错误。
* 

* 
* [1.x.65]
* 
* 精确解类的值和梯度的实际定义是根据它们的数学定义，不需要过多解释。  
* 唯一值得一提的是，如果我们访问依赖于模板的基类的元素（在本例中是SolutionBase&lt;dim&gt;的元素），那么C++语言就会强迫我们写[2.x.74] ，对于基类的其他成员也是如此。如果基类不依赖模板，C++就不需要[2.x.75]的限定。这一点的原因很复杂，C++书籍会在[1.x.66]这句话下解释，在deal.II的FAQ中也有很长的描述。
* 

* 
* [1.x.67]
 
* 同样，这也是对解的梯度的计算。 为了从指数的贡献中积累梯度，我们分配了一个对象[2.x.76]，它表示秩[2.x.77]和维[2.x.78]的张量的数学量。它的默认构造函数将其设置为只包含零的向量，所以我们不需要明确关心其初始化。  
* 请注意，我们也可以把对象的类型取为Point&lt;dim&gt;而不是Tensor&lt;1,dim&gt;。等级1的张量和点几乎是可以交换的，而且只有非常细微的数学含义不同。事实上，Point&lt;dim&gt;类是由Tensor&lt;1,dim&gt;类派生出来的，这就弥补了它们的相互交换能力。它们的主要区别在于它们在逻辑上的含义：点是空间中的点，比如我们要评估一个函数的位置（例如，见这个函数的第一个参数的类型）。另一方面，秩1的张量具有相同的变换属性，例如，当我们改变坐标系时，它们需要以某种方式旋转；然而，它们不具有点所具有的相同内涵，只是比坐标方向所跨越的空间更抽象的对象。事实上，梯度生活在 "对等 "空间中，因为它们的分量的维度不是长度，而是一个超过长度的维度）。
* 

* 
* [1.x.68]
* 
* 对于梯度，注意它的方向是沿着（x-x_i），所以我们把这个距离向量的倍数加起来，其中的因子是由指数给出。
* 

* 
* [1.x.69]
* 
* 除了代表精确解的函数外，我们还需要一个函数，在组装离散化的线性方程组时，我们可以用它作为右手。这可以通过下面的类和其函数的定义来完成。请注意，这里我们只需要函数的值，而不是它的梯度或高阶导数。
* 

* 
* [1.x.70]
* 
* 右手边的值是由解的负拉普拉斯加上解本身给出的，因为我们要解决亥姆霍兹方程。
* 

* 
* [1.x.71]
* 
* 第一个贡献是拉普拉斯。
* 

* 
* [1.x.72]
* 
* 而第二个是解决方案本身。
* 

* 
* [1.x.73]
* 
* [1.x.74] [1.x.75]。
 

* 
* 然后我们需要一个做所有工作的类。除了它的名字，它的接口与前面的例子基本相同。  
* 不同之处之一是，我们将在几种模式下使用这个类：用于不同的有限元，以及用于自适应和全局细化。全局细化还是自适应细化的决定是通过在类的顶部声明的枚举类型传达给该类的构造函数的。然后，构造函数接收一个有限元对象和细化模式作为参数。  
* 除了[2.x.79]函数外，其余的成员函数与之前一样。在解被计算出来后，我们对它进行一些分析，比如计算各种规范的误差。为了实现一些输出，它需要细化周期的编号，因此得到它作为参数。
* 

* 
* [1.x.76]
* 
* 现在是这个类的数据元素。在我们在以前的例子中已经使用过的变量中，只有有限元对象不同。这个类的对象所操作的有限元被传递给这个类的构造函数。它必须存储一个指向有限元的指针，供成员函数使用。现在，对于本类来说，这没有什么大不了的，但由于我们想在这些程序中展示技术而不是解决方案，我们将在这里指出一个经常出现的问题
* 
* - 当然也包括正确的解决方案。    
* 考虑以下在所有例子程序中出现的情况：我们有一个三角形对象，我们有一个有限元对象，我们还有一个DoFHandler类型的对象，它同时使用前两个对象。这三个对象的寿命与其他大多数对象相比都相当长：它们基本上是在程序开始时或外循环时设置的，并在最后被销毁。问题是：我们能否保证DoFHandler使用的两个对象的寿命至少与它们被使用的时间相同？这意味着DoFHandler必须对其他对象的销毁情况有一定的了解。    
* 我们将在这里展示库是如何设法发现对一个对象仍有活动的引用，并且从使用对象的角度来看，该对象仍然活着。基本上，该方法是沿着以下思路进行的：所有受到这种潜在危险的指针的对象都是来自于一个叫做Subscriptor的类。例如，Triangulation、DoFHandler和FiniteElement类的一个基类都派生于Subscriptor。后面这个类并没有提供太多的功能，但是它有一个内置的计数器，我们可以订阅这个计数器，因此这个类的名字就叫 "订阅器"。每当我们初始化一个指向该对象的指针时，我们可以增加它的使用计数器，而当我们移开指针或不再需要它时，我们再减少计数器。这样，我们就可以随时检查有多少个对象还在使用该对象。此外，该类需要知道一个指针，它可以用来告诉订阅对象它的无效性。    
* 如果一个从Subscriptor类派生出来的对象被销毁，它也必须调用Subscriptor类的析构函数。在这个析构器中，我们使用存储的指针告诉所有订阅对象关于该对象的失效。当对象出现在移动表达式的右侧时，也会发生同样的情况，也就是说，在操作后它将不再包含有效的内容。在试图访问被订阅的对象之前，订阅类被期望检查存储在其相应指针中的值。    
* 这正是SmartPointer类正在做的事情。它基本上就像一个指针一样，也就是说，它可以被取消引用，可以被分配给其他指针，等等。除此之外，当我们试图解除引用这个类所代表的指针时，它使用上面描述的机制来找出这个指针是否是悬空的。在这种情况下，会抛出一个异常。    
* 在本例程序中，我们希望保护有限元对象，避免因某种原因导致所指向的有限元在使用中被破坏的情况。因此，我们使用了一个指向有限元对象的SmartPointer；由于有限元对象在我们的计算中实际上从未改变，我们传递了一个const FiniteElement&lt;dim&gt; 作为SmartPointer类的模板参数。请注意，这样声明的指针是在构造求解对象时被分配的，并在销毁时被销毁，所以对有限元对象销毁的锁定贯穿了这个HelmholtzProblem对象的生命周期。
* 

* 
* [1.x.77]
* 
* 倒数第二个变量存储了传递给构造函数的细化模式。由于它只在构造函数中设置，我们可以声明这个变量为常数，以避免有人不由自主地设置它（例如，在 "if "语句中，==偶然被写成=）。
* 

* 
* [1.x.78]
* 
* 对于每个细化级别，一些数据（如单元格的数量，或数值解的L2误差）将被生成，并在之后打印出来。TableHandler可以用来收集所有这些数据，并在运行结束后以简单文本或LaTeX格式的表格输出。在这里，我们不仅使用TableHandler，还使用了派生类ConvergenceTable，它还可以评估收敛率。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81]
 

 
* [1.x.82] [1.x.83].
 

* 
* 在这个类的构造函数中，我们只设置作为参数传递的变量，并将DoF处理程序对象与三角形（不过目前是空的）相关联。
* 

* 
* [1.x.84]
* 
* [1.x.85] [1.x.86]
 

* 
* 下面的函数设置了自由度、矩阵和向量的大小等等。它的大部分功能在以前的例子中已经展示过了，唯一的区别是在第一次分配自由度后立即进行重新编号的步骤。  
* 只要你使用库中的一种算法，重编自由度并不难。它只需要一行代码。这方面的一些更多信息可以在 [2.x.80] 中找到。  
* 但是请注意，当你对自由度进行重新编号时，你必须在分配自由度后立即进行，因为诸如悬空节点、稀疏模式等都取决于重新编号所改变的绝对数。  
* 我们在这里介绍重新编号的原因是，它是一个相对便宜的操作，但往往有一个有利的效果。虽然CG迭代本身与自由度的实际排序无关，但我们将使用SSOR作为一个预处理程序。SSOR会经过所有的自由度，并做一些取决于之前发生的操作；因此，SSOR操作并不独立于自由度的编号，而且众所周知，它的性能会通过使用重新编号技术得到改善。一个小实验表明，确实如此，例如，用这里使用的Q1程序进行自适应细化的第五个细化周期的CG迭代次数，在没有重编号的情况下为40次，而在重编号的情况下为36次。在这个程序的所有计算中，一般都可以观察到类似的节省。
* 

* 
* [1.x.87]
* 
* [1.x.88] [1.x.89].
 

* 
* 为手头的问题组装方程组，主要是像以前的例子程序一样。然而，有些事情还是发生了变化，所以我们对这个函数进行了相当广泛的评论。  
* 在函数的顶部，你会发现通常的各种变量声明。与以前的程序相比，重要的是我们希望解决的问题也是双二次元的，因此必须使用足够精确的正交公式。此外，我们需要计算面的积分，即[2.x.81]维的对象。那么，面的正交公式的声明就很直接了。
* 

* 
* [1.x.90]
* 
* 然后我们需要一些对象来评估正交点上的形状函数的值、梯度等。虽然看起来用一个对象来做域积分和面积分应该是可行的，但有一个微妙的区别，因为域积分的权重包括域中单元的度量，而面积分的正交需要低维流形中面的度量。在内部，这两个类都植根于一个共同的基类，它完成了大部分工作，并为域积分和界面积分提供了相同的接口。    
* 对于亥姆霍兹方程的双线性形式的域积分，我们需要计算值和梯度，以及正交点的权重。此外，我们需要实细胞上的正交点（而不是单位细胞上的正交点）来评估右手边的函数。我们用来获取这些信息的对象是之前讨论过的FEValues类。    
* 对于面积分，我们只需要形状函数的值，以及权重。我们还需要实心单元上的法向量和正交点，因为我们要从精确解对象中确定Neumann值（见下文）。给我们提供这些信息的类被称为FEFaceValues。
* 

* 
* [1.x.91]
 
* 然后我们需要一些从以前的例子中已经知道的对象。一个表示右手边函数的对象，它在单元格上正交点的值，单元格矩阵和右手边，以及单元格上自由度的指数。    
* 请注意，我们将对右手边对象进行的操作只是查询数据，而绝不会改变对象。因此我们可以声明它 [2.x.82] 。
* 

* 
* [1.x.92]
* 
* 最后我们定义一个表示精确解函数的对象。我们将用它来计算边界上的诺伊曼值。通常情况下，我们当然会用一个单独的对象来计算，特别是由于精确解通常是未知的，而诺伊曼值是规定的。然而，我们将有点偷懒，使用我们已经有的信息。当然，现实生活中的程序会在这里采取其他方式。
* 

* 
* [1.x.93]
* 
* 现在是所有单元格的主循环。这与以前的例子基本没有变化，所以我们只对有变化的地方进行评论。
* 

* 
* [1.x.94]
* 
* 第一件改变的事情是双线性形式。它现在包含来自亥姆霍兹方程的附加项。
* 

 
* [1.x.95]
* 
* 然后是右手边的第二个项，即等值线积分。首先我们要找出这个单元格的面与边界部分Gamma2的交点是否为非零。为此，我们对所有面进行循环，检查其边界指示器是否等于[2.x.83]，这是我们在下面的[2.x.84]函数中为组成Gamma2的边界部分指定的值。(边界指示器的默认值是[2.x.85]，所以只有在我们明确设置的情况下，面的指示器才能等于[2.x.86]。)
* 

* 
* [1.x.96]
* 
* 如果我们进入这里，那么我们已经找到了一个属于Gamma2的外部面。接下来，我们必须计算形状函数的值和其他我们在计算轮廓积分时需要的数量。这是用[2.x.87]函数完成的，我们已经从FEValue类中知道了。
* 

* 
* [1.x.97]
* 
* 然后我们可以通过对所有正交点的循环来进行积分。              
* 在每个正交点上，我们首先计算法线导数的值。我们使用精确解的梯度和从[2.x.88]对象中得到的当前正交点处的面的法向量来进行计算。然后用它来计算这个面对右手边的额外贡献。
* 

* 
* [1.x.98]
* 
* 现在我们有了本单元的贡献，我们可以把它转移到全局矩阵和右边的向量中，就像之前的例子一样。
* 

* 
* [1.x.99]
* 
* 同样的，消除和处理边界值的方法在前面已经展示过了。    
* 但我们注意到，现在我们插值边界值的边界指标（用[2.x.89]的第二个参数表示）不再代表整个边界。相反，它是我们没有指定其他指标的那部分边界（见下文）。因此，边界上不属于Gamma1的自由度被排除在边界值的插值之外，就像我们希望的那样。
* 

* 
* [1.x.100]
* 
* [1.x.101] [1.x.102].
 

* 
* 解决方程组的方法和以前一样。
* 

* 
* [1.x.103]
* 
* [1.x.104] [1.x.105]。
 

* 
* 现在是做网格细化的函数。根据传递给构造函数的细化模式，我们进行全局或适应性细化。  
* 全局细化很简单，所以没有什么可评论的。 在适应性细化的情况下，我们使用的函数和类与前面的例子程序相同。请注意，我们可以将诺伊曼边界与迪里切特边界区别对待，事实上在这里也应该这样做，因为我们在部分边界上有诺伊曼边界条件，但是由于我们在这里没有描述诺伊曼值的函数（我们只是在组装矩阵时从精确解中构造这些值），我们省略了这个细节，尽管以严格正确的方式做这些并不难添加。  
* 在开关的最后，我们有一个看起来稍微有点奇怪的默认情况：一个[2.x.90]条件。由于[2.x.91]宏在条件为假的时候会引发一个错误，这意味着只要我们碰到这个语句，程序就会被中止。这是故意的。现在我们只实现了两种细化策略（全局性和适应性），但有人可能想增加第三种策略（例如，具有不同细化标准的适应性），并在决定细化模式的枚举中增加第三个成员。如果不是switch语句的默认情况，这个函数会简单地运行到结束而不做任何事情。这很可能不是原意。因此，在deal.II库中，你会发现一个防御性的编程技术，那就是总是有默认的中止案例，以确保在switch语句中列出案例时没有考虑的值最终被抓住，并迫使程序员添加代码来处理它们。我们还将在下面的其他地方使用同样的技术。
* 

* 
* [1.x.106]
* 
* [1.x.107] [1.x.108]。
 

* 
* 最后，我们想在计算出解决方案后对其进行处理。为此，我们用各种（半）准则对误差进行积分，并生成表格，以后用来以漂亮的格式显示对连续解的收敛情况。
* 

* 
* [1.x.109]
* 
* 我们的第一个任务是计算误差准则。为了整合计算出的数值解和连续解之间的差异（由本文件顶部定义的Solution类描述），我们首先需要一个向量来保存每个单元的误差准则。由于16位数的精度对这些数量来说并不那么重要，我们通过使用[2.x.92]而不是[2.x.93]值来节省一些内存。    
* 下一步是使用库中的一个函数，计算每个单元的L2准则的误差。 我们必须将DoF处理程序对象、保存数值解的节点值的向量、作为函数对象的连续解、它应将每个单元上的误差准则放入的向量、计算该准则的正交规则以及要使用的准则类型传递给它。这里，我们使用高斯公式，在每个空间方向上有三个点，并计算L2规范。    
* 最后，我们想得到全局L2规范。这当然可以通过对每个单元上的规范的平方求和，并取该值的平方根来得到。这相当于取每个单元上的规范向量的l2（小写[2.x.94]）规范。
* 

* 
* [1.x.110]
* 
* 通过同样的程序，我们得到H1半规范。我们重新使用[2.x.95]矢量，因为在计算了上面的[2.x.96]变量之后，它不再被使用。全局[2.x.97]半正态误差的计算方法是：取每个单元的误差的平方之和，然后取它的平方根。
* 
*--这种操作是由[2.x.98]方便地执行的。
* 

* 
* [1.x.111]
* 
* 最后，我们计算出最大法线。当然，我们实际上不能计算出域中误差总体*点的真正最大值，而只能计算出有限的评估点上的最大值，为了方便起见，我们仍然称之为 "正交点"，并以正交类型的对象表示，尽管我们实际上没有进行任何积分。    
* 然后就是我们想在哪些点上精确地进行评估的问题。事实证明，我们得到的结果相当敏感地取决于所使用的 "正交 "点。还有一个超融合的问题。在某些网格上，对于多项式程度[2.x.99]，有限元解决方案在节点点以及Gauss-Lobatto点上特别精确，比随机选择的点要精确得多。(见[2.x.100]和第1.2节的讨论和参考文献，以了解更多这方面的信息)。换句话说，如果我们有兴趣找到最大的差值[2.x.101]，那么我们应该看一下[2.x.102]，这些点特别不属于这种 "特殊 "的点，而且我们特别不应该用`QGauss(fe->degree+1)`来定义我们的评估位置。相反，我们使用一个特殊的正交规则，该规则是通过梯形规则迭代有限元的度数乘以2再加上每个空间方向的1而得到的。请注意，QIterated类的构造函数需要一个一维正交规则和一个数字，这个数字告诉它在每个空间方向重复这个规则的频率。    
* 使用这个特殊的正交规则，我们就可以尝试找到每个单元的最大误差。最后，我们通过调用[2.x.103]来计算每个单元上的L无穷大误差的全局L无穷大误差。
* 

* 
* [1.x.112]
* 
* 在所有这些误差被计算出来后，我们最后写一些输出。此外，我们通过指定列的键和值将重要的数据添加到TableHandler中。 注意，没有必要事先定义列的键值
* 
* - 只需添加值即可，列将按照第一次添加值的顺序被引入到表中。
* 

* 
* [1.x.113]
 
* [1.x.114] [1.x.115].
 

* 
* 和以前的例子程序一样，[2.x.104]函数控制执行的流程。基本布局与以前的例子一样：在连续细化的网格上有一个外循环，在这个循环中首先是问题的设置，组装线性系统，求解，和后处理。  
* 主循环的第一个任务是创建和细化网格。这和以前的例子一样，唯一不同的是我们想把边界的一部分标记为诺伊曼型，而不是迪里希型。  
*为此，我们将使用以下惯例。属于Gamma1的面将有边界指示器[2.x.105]（这是默认的，所以我们不需要明确设置），属于Gamma2的面将使用[2.x.106]作为边界指示器。 为了设置这些值，我们在所有单元格上循环，然后在给定单元格的所有面上循环，检查它是否是我们想用Gamma2表示的边界的一部分，如果是，则将其边界指示器设置为[2.x.107] 。在本程序中，我们认为左边和底部的边界是Gamma2。我们通过询问一个面的中点的x或y坐标（即向量分量0和1）是否等于该边界的一部分来确定该面的边界。
* 
* - ，我们必须给一些小的回旋余地，因为比较浮点数是不稳定的，这些浮点数在中间计算中会被舍去。  
* 值得注意的是，我们必须在这里对所有单元进行循环，而不仅仅是活动单元。原因是在细化时，新创建的面会继承其父面的边界指标。如果我们现在只设置活动面的边界指示器，粗化一些单元并在以后细化它们，它们将再次拥有我们没有修改的父单元的边界指示器，而不是我们想要的那个。因此，我们必须改变Gamma2上所有单元的面的边界指标，无论它们是否处于活动状态。另外，我们当然也可以在最粗的网格上完成这项工作（即在第一个细化步骤之前），之后再细化网格。
* 

* 
* [1.x.116]
 
* 接下来的步骤在以前的例子中已经知道了。这主要是每个有限元程序的基本设置。
 

 
* [1.x.117]
* 
* 在这一连串的函数调用中，最后一步通常是对一个人感兴趣的量的计算解进行评估。这是在下面的函数中完成的。由于该函数产生的输出显示了当前细化步骤的编号，因此我们将这个编号作为一个参数传递。
* 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120] * [1.x.120].
 

* 
* 在最后一次迭代之后，我们在最好的网格上输出解决方案。这是用下面的语句序列完成的，我们在以前的例子中已经讨论过了。第一步是生成一个合适的文件名（这里称为[2.x.108]，因为我们想以VTK格式输出数据；我们添加前缀以区分该文件名与下面其他输出文件的文件名）。在这里，我们通过网格细化算法来增加名称，和上面一样，我们要确保在添加了另一种细化方法而没有通过下面的switch语句来处理时，我们会中止程序。
* 

* 
* [1.x.121]
* 
* 我们用一个后缀来增加文件名，表示我们在计算中使用的有限元。为此，有限元基类将每个坐标变量中形状函数的最大多项式程度存储为一个变量[2.x.109]，我们在切换语句中使用（注意，双线性形状函数的多项式程度实际上是2，因为它们包含术语[2.x.110]；但是，每个坐标变量中的多项式程度仍然只有1）。我们再次使用同样的防御性编程技术来防止多项式阶数有意外值的情况，在switch语句的默认分支中使用[2.x.111]这个成语。
* 

* 
* [1.x.122]
* 
* 一旦我们有了输出文件的基本名称，我们就为VTK输出添加一个合适的扩展名，打开一个文件，并将解决方案向量添加到将进行实际输出的对象中。
* 

* 
* [1.x.123]
* 
* 现在像以前一样建立中间格式是下一步。我们在这里再介绍一下deal.II的一个特点。其背景如下：在这个函数的一些运行中，我们使用了双曲线有限元。然而，由于几乎所有的输出格式都只支持双线性数据，所以数据只写成了双线性，信息因此而丢失。 当然，我们不能改变图形程序接受其输入的格式，但我们可以用不同的方式来写数据，这样我们就能更接近于四次方近似中的信息。例如，我们可以把每个单元写成四个子单元，每个子单元都有双线数据，这样我们在三角图中的每个单元都有九个数据点。当然，图形程序将显示这些数据仍然只有双线性，但至少我们又给出了一些我们拥有的信息。    
* 为了允许每个实际的单元格写一个以上的子单元，[2.x.112]函数接受一个参数（默认是[2.x.113]，这就是为什么你在以前的例子中没有看到这个参数）。这个参数表示每个空间方向上的每个单元应被细分为多少个子单元来输出。例如，如果你给出[2.x.114]，这将导致2D中的4个单元和3D中的8个单元。对于二次元元素，每个空间方向的两个子单元显然是正确的选择，所以这就是我们所选择的。一般来说，对于多项式阶数的元素[2.x.115]细分，元素的顺序也是按照上述方式确定的。    
* 有了这样生成的中间格式，我们就可以实际编写图形输出了。
* 

* 
* [1.x.124]
* 
* [1.x.125] [1.x.126]。
* 

* 
* 在图形输出之后，我们还想从我们在 [2.x.116] 中进行的误差计算中生成表格。在那里，我们用每个细化步骤的单元格数量以及不同规范的误差来填充一个表格对象。
* 

* 
* 为了使这些数据有更好的文本输出，人们可能想设置输出时写入数值的精度。我们使用3位数，这通常对误差规范来说是足够的。默认情况下，数据是以定点符号写入的。然而，对于人们希望看到的科学符号的列，另一个函数调用设置[2.x.117] ，导致数字的浮点表示。
* 

* 
* [1.x.127]
* 
* 对于输出到LaTeX文件的表格，默认的列的标题是作为参数给[2.x.118]函数的键。要想拥有不同于默认的TeX标题，你可以通过以下函数调用来指定它们。注意，"\\"被编译器简化为"\"，因此真正的TeX标题是，例如，"[2.x.119] -error"。
* 

* 
* [1.x.128]
* 
* 最后，表格中每一列的默认LaTeX格式是`c'（居中）。要指定一个不同的（如 "右"），可以使用以下函数。
 

* 
* [1.x.129]
* 
* 在这之后，我们终于可以把表写到标准输出流[2.x.120]（在多写了一行空行之后，使事情看起来更漂亮）。注意，文本格式的输出是非常简单的，而且标题可能不会直接打印在特定的列上面。
* 

* 
* [1.x.130]
 
* 该表也可以被写进LaTeX文件。 在调用 "latex filename "和例如 "xdvi filename "后，可以查看（很好的）格式化的表格，其中filename是我们现在要写入输出的文件名。我们构建文件名的方法和以前一样，但有一个不同的前缀 "error"。
* 

* 
* [1.x.131]
* 
* [1.x.132] [1.x.133]。
 

* 
* 在全局细化的情况下，可能会对输出收敛率感兴趣。这可以通过ConvergenceTable提供的比常规TableHandler的功能来实现。然而，我们只为全局细化做了这个工作，因为对于自适应细化来说，确定类似收敛顺序的东西是比较麻烦的。在此过程中，我们还展示了一些可以用表来做的其他事情。
* 

* 
* [1.x.134]
* 
* 第一件事是，人们可以将个别的列组合在一起，形成所谓的超级列。从本质上讲，这些列保持不变，但被分组的那些列会得到一个贯穿于一个组中所有列的标题。例如，让我们把 "周期 "和 "单元格 "两列合并成一个名为 "n单元格 "的超级列。
* 

* 
* [1.x.135]
* 
* 接下来，没有必要总是输出所有的列，或者按照它们在运行过程中最初被添加的顺序。选择和重新排列列的工作方式如下（注意，这包括超级列）。
* 

* 
* [1.x.136]
 
* 对于ConvergenceTable在这之前发生的一切，使用一个简单的TableHandler即可。事实上，ConvergenceTable是由TableHandler派生出来的，但它提供了自动评估收敛率的额外功能。例如，下面是我们如何让表计算减少率和收敛率（收敛率是减少率的二进制对数）。
* 

* 
* [1.x.137]
* 
* 每个函数调用都会产生一个额外的列，与原始列（在我们的例子中是 "L2 "和 "H1 "列）合并成一个超级列。
* 

* 
* 最后，我们想再次写下这个收敛图，首先写到屏幕上，然后以LaTeX格式写到磁盘上。文件名还是按照上面的结构。
* 

* 
* [1.x.138]
* 
* 在进入[2.x.121]之前的最后一步是关闭命名空间[2.x.122]，我们已经把这个程序所需要的东西都放进去了。
* 

* 
* [1.x.139]
* 
* [1.x.140] [1.x.141]
 

* 
* 主函数主要和以前一样。唯一不同的是，我们求解三次，一次是Q1和适应性细化，一次是Q1元素和全局细化，一次是Q2元素和全局细化。
* 

* 
* 因为我们在下面为两个空间维度实例化了几个模板类，所以我们通过在函数的开头声明一个常数来表示空间维度的数量，使其更加通用。如果你想在1d或2d中运行程序，那么你只需要改变这个实例，而不是下面的所有用法。
* 

* 
* [1.x.142]
* 
* 现在是对主类的三次调用。每个调用都被封锁在大括号中，以便在封锁结束后，在我们进入下一个运行之前销毁各自的对象（即有限元和HelmholtzProblem对象）。这就避免了变量名称的冲突，也确保了在三次运行中的一次结束后立即释放内存，而不是只在[2.x.123]块的末尾释放。
* 

* 
* [1.x.143]
* [1.x.144][1.x.145] 。
* 

* 
* 该程序产生两种输出。第一种是输出文件 [2.x.124] 、 [2.x.125] 和 [2.x.126] 。我们在这里以三维视图的形式展示后者。
 

* [2.x.127] 
 

* 
* 

* 其次，程序不仅将表写入磁盘，而且在运行时也写入屏幕。输出结果如下（请记住，标记为"[2.x.128]"的列实际上显示的是错误的[2.x.129][1.x.146]范围，而不是完整的[2.x.130]范围）。
* 

* 
* [1.x.147]
* 
* 

* 我们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。可以清楚地看到Q1和Q2元素在[2.x.131]半规范下的线性和二次收敛率，以及[2.x.132]规范下的二次和三次收敛率。
* 

* 
* 

* 最后，该程序还生成了LaTeX版本的表格（此处未显示），这些表格被写入一个文件中，以便可以复制粘贴到LaTeX文件中。
* 

* [1.x.148][1.x.149] 。
* 

* 我们在上面所展示的是如何以一些不同的规范来确定错误[2.x.133]的大小。我们这样做的主要原因是我们对测试我们的解决方案是否能转换*感兴趣。但是从工程的角度来看，这个问题往往更实际：我必须把我的网格做得多细才能使误差 "足够小"？换句话说，如果在上表中，[2.x.134]的半规范已经减少到`4.121e-03'，这是否足以让我们在蓝图上签字，宣布我们的数值模拟显示桥梁足够坚固？
* 在实践中，我们很少遇到这种情况，因为我通常不能将数值解[2.x.135]与精确解[2.x.136]进行比较。
* 
* - 如果我知道[2.x.137]，我就不必计算[2.x.138]。但是，即使我可以，一般要问的问题是。`4.121e-03`是什么*？解决方案会有物理单位，比如说公斤-米-平方，我在域上积分一个以上述单位为平方的函数，然后取其平方根。因此，如果领域是二维的，[2.x.139]的单位是公斤-米-立方。那么问题来了。[2.x.140]的单位是千克-米-立方吗？这取决于你要模拟的是什么。如果你是一个天文学家，习惯于以太阳质量为单位的质量和以光年为单位的距离，那么是的，这是一个小得惊人的数字。但如果你是做原子物理的，那就不是：这并不小，而且你的误差肯定也不够小；你需要一个更细的网格。
* 换句话说，当我们看这些数字的时候，我们通常需要与一个 "尺度 "进行比较。一种方法是不看绝对*误差[2.x.141]的任何规范，而是看
*相对*误差[2.x.142]。如果这个比率是[2.x.143]，那么你就知道，平均*来说，[2.x.144]和[2.x.145]之间的差异是0.001%。
* 
* - 可能对工程而言足够小。
* 我们如何计算[2.x.146]？我们只需要做一个整体单元的积分循环，在这些单元上做正交点，然后把东西加起来，最后取平方根。但有一个更简单的方法经常使用。你可以调用
* [1.x.150]
* 这将计算出[2.x.147]。另外，如果你特别聪明，不喜欢创建 "零向量"，你可以用这个方法，如果网格不是太粗，那么就用[2.x.148]，我们可以通过调用[2.x.149]计算。
* [1.x.151]
* 在这两种情况下，我们只需要像在程序中一样，通过调用[1.x.152]将单元网格的向量合并为一个全局准则。
* [1.x.152]
* 
* 

* 
* [1.x.153][1.x.154] 。
* 

* [1.x.155][1.x.156]。
* 

* 继续运行具有高阶元素的程序（[2.x.150] , [2.x.151] , ...）。你会注意到，代码中的几个部分的断言将被触发（例如，在为数据输出生成文件名时）。你可能必须解决这些问题，但要使程序正常工作应该不是很困难。
* [1.x.157][1.x.158] 。
* 

* 是Q1还是Q2更好？自适应细化与全局细化如何？比较它们的一个（有点不公平但很典型的）指标是看误差与未知数的函数。
* 要看到这一点，创建一个对数风格的图，未知数在[2.x.152]轴上，[2.x.153]误差在[2.x.154]轴上。你可以为[2.x.155]和[2.x.156]添加参考线，并检查全局和适应性细化是否遵循这些参考线。如果我们做一个（并非完全不合理的）假设，即对于一个好的线性求解器，计算工作与未知数[2.x.157]的数量成正比，那么很明显，[2.x.158]的误差减少大大优于[2.x.159]形式的减少：也就是说，与使用全局细化相比，自适应细化以更少的计算工作给我们带来了期望的误差水平。这不是一个特别令人惊讶的结论，但是值得在实践中检查这些假设。
* 当然，更公平的比较是在[2.x.160]轴上绘制运行时间（先切换到释放模式！）而不是未知数的数量。如果你通过对每个精炼步骤进行计时（例如，使用Timer类），将运行时间与未知数的数量作对比，你会发现线性求解器并不完美
* 
* - 其运行时间的增长速度与线性系统的大小不成正比
* 
* - 挑选一个更好的线性求解器可能适合这种比较。
* 

* [1.x.159][1.x.160] [2.x.161] 。
* [0.x.1]

