include/deal.II-translator/A-tutorial/step-67_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* 
* [2.x.4] 
* [1.x.29]
* [1.x.30][1.x.31][1.x.32] 。
 

* 这个教程程序使用显式时间积分器求解流体动力学的欧拉方程，其无矩阵框架应用于空间的高阶非连续Galerkin离散化。关于欧拉系统的细节和另一种隐式方法，我们也参考了[2.x.5]的教程程序。你可能还想看看[2.x.6]中解决这些方程的其他方法。
* 

* [1.x.33][1.x.34] 。
* 

* 欧拉方程是一个守恒定律，描述了可压缩无iscid气体的运动，[1.x.35]其中解矢量的[2.x.7]分量为[2.x.8] 。这里，[2.x.9]表示流体密度，[2.x.10]表示流体速度，[2.x.11]表示气体的能量密度。速度不是直接求出的，而是变量[2.x.12]，即线性动量（因为它是保留量）。
* 欧拉通量函数，一个[2.x.13]矩阵，定义为[1.x.36]，其中[2.x.14]是[2.x.15]的身份矩阵，[2.x.16]是外积；其组成部分分别表示质量、动量和能量通量。右面的强制由[1.x.37]给出，其中矢量[2.x.17]表示重力方向和大小。然而，它也可以表示作用于流体的任何其他单位质量的外力。例如，想想外部电场对带电粒子所施加的静电力）。
* 这三组方程，第二组涉及[2.x.18]成分，描述了质量、动量和能量的守恒。压力不是决议变量，但需要通过其他变量的 "闭合关系 "来表达；我们在此选择适合由两个原子组成的分子的气体的关系，在中等温度下，由[2.x.19]和常数[2.x.20]给出。
* 

*[1.x.38][1.x.39] 。
* 

* 对于空间离散化，我们使用高阶不连续Galerkin（DG）离散化，使用形式为[1.x.40]的解扩展，这里，[2.x.21]表示[2.x.22]的基函数，以矢量形式书写，不同成分的形状函数分开，[2.x.23]分别经过密度、动量和能量变量。在这种形式下，空间依赖性包含在形状函数中，时间依赖性包含在未知系数中 [2.x.24] 。与连续有限元方法中一些形状函数跨越元素边界的情况不同，在DG方法中，形状函数是单个元素的局部，从一个元素到下一个元素是不连续的。从一个单元到其相邻单元的解决方案的连接是由下面规定的数值通量来实现的。这允许一些额外的灵活性，例如，在数值方法中引入方向性，例如，上卷。
* DG方法是解决传输特性问题的流行方法，因为它们结合了低分散误差和可控的耗散，在极少解决的尺度上。这使得它们在流体动力学领域的模拟中特别有吸引力，因为在这个领域中，需要代表广泛的活动尺度，而不充分解决的特征很容易干扰重要的良好解决的特征。此外，高阶DG方法非常适用于现代硬件的正确实施。同时，DG方法也不是银弹。特别是当解出现不连续（冲击）时，如欧拉方程在某些流动状态下的典型情况，高阶DG方法往往会出现振荡解，就像不使用通量或坡度限制器的所有高阶方法一样。这是[1.x.41]的结果，即任何线性的总变差（TVD）方案（如基本的DG离散化）最多能达到一阶精度。换句话说，由于DG方法的目标是高阶精度，它们不能对产生冲击的解进行TVD。尽管有些人声称DG方法中的数值通量可以控制耗散，但这一点价值有限，除非[1.x.42]问题中的冲击与单元边界一致。任何穿过单元内部的冲击都会因为高阶多项式而再次产生震荡成分。在有限元和DG领域，存在许多不同的方法来处理冲击，例如在有问题的单元上引入人工扩散（使用基于解的模态分解的有问题单元指标），在子网格上转换为耗散性低阶有限体积方法，或者增加一些限制性程序。考虑到这种情况下的充分可能性，再加上相当大的实施难度，我们在此不讨论带有明显冲击的欧拉方程体系，而是集中讨论带有波状现象的亚声速流动体系。对于一个能很好地处理冲击的方法（但每个未知数的成本更高），我们参考了[2.x.25]的教程程序。
* 对于DG公式的推导，我们将欧拉方程与测试函数[2.x.26]相乘，并在单个单元上进行积分[2.x.27]，从而得到[1.x.43] 。
* 然后我们对第二项进行分项积分，将分歧从解槽移到测试函数槽，并产生元素边界上的积分：[1.x.44]在表面积分中，我们将项[2.x.28]替换为项[2.x.29]，数值通量。数值通量的作用是连接相邻元素上的解，并弱化了解的连续性。这保证了PDE的全局耦合反映在离散化上，尽管单元上有独立的基函数。通过将数值通量定义为来自内部面两侧的解的函数[2.x.30]和[2.x.32]，包括与邻居的连接性。我们要求的一个基本属性是，数值通量需要是[1.x.45]。也就是说，我们希望所有的信息（即质量、动量和能量）在一个面上离开一个单元时，都能完整地进入邻近的单元，反之亦然。这可以表示为[2.x.33]，也就是说，数值通量从任何一边都评估为相同的结果。结合数值通量乘以所考虑的表面上的单位外法向量的事实，该法向量从两边指向相反的方向，我们看到守恒被满足了。数值通量的另一个观点是作为一个单值的中间状态，从两边微弱地联系着解决方案。
* 有大量的数值通量函数可用，也称为Riemann求解器。对于欧拉方程，存在所谓的精确黎曼求解器
* 
* 意味着来自两边的状态以符合欧拉方程的方式沿着不连续点结合起来
* 
* 以及近似黎曼求解器，它违反了一些物理特性，并依靠其他机制来使方案总体上准确。近似黎曼求解器的优点是计算成本较低。大多数通量函数都起源于有限体积界，它们类似于单元（称为体积）内的多项式0度的DG方法。由于Euler算子的体积积分[2.x.34]对于恒定的解和检验函数会消失，所以数值通量必须完全代表物理算子，这也解释了为什么在该社区有大量的研究。对于DG方法，一致性是由单元内的高阶多项式保证的，这使得数值通量不再是一个问题，通常只影响收敛率，例如，对于度数为[2.x.39]的多项式，解是否转化为[2.x.35]、[2.x.36]或者[2.x.37]的准则。因此，数值流可以被看作是一种机制，用来选择更有利的耗散/分散特性，或者关于被分解和线性化的算子的极值特征，这影响到显式时间积分器中最大的可接受的时间步长。
* 在这个教程程序中，我们实现了两种通量的变体，可以通过程序中的开关来控制（当然，通过输入文件来控制它们的运行时间参数也很容易）。第一个通量是本地的Lax--Friedrichs通量[1.x.46] 。
* 在Lax--Friedrichs通量的原始定义中，使用了一个系数[2.x.40]（对应于信息在界面两边移动的最大速度），说明两个状态之间的差异，[2.x.41]被欧拉通量的最大特征值惩罚，即[2.x.42]，其中[2.x.43]是音速。在下面的实现中，我们对惩罚项进行了一些修改，因为无论如何惩罚都是近似的。我们使用
* [1.x.47]
* 额外的因子[2.x.44]降低了惩罚强度（这导致特征值的负实数部分减少，从而增加了允许的时间步长）。这种简化导致参数[2.x.45]的减少最多为2倍，因为[2.x.46]，最后一个不等式来自于杨氏不等式。
* 第二个数值通量是由Harten、Lax和van Leer提出的，称为HLL通量。它考虑到Eulerequations的不同传播方向，取决于声速。它利用一些中间状态 [2.x.47] 和 [2.x.48] 来定义两个分支 [2.x.49] 和 [2.x.50] 。关于中间状态[2.x.51]和[2.x.52]的定义，已经提出了几个变种。最初提出的变体采用密度平均的速度定义[2.x.53]。由于我们考虑的是没有冲击的欧拉方程，因此我们在本教程中简单地使用算术手段，[2.x.54]和[2.x.55]，以及[2.x.56]，而将其他变体留给可能的扩展。我们还注意到，HLL通量在文献中被扩展为所谓的HLLC通量，其中C代表表示接触不连续的能力。
* 在没有邻接状态[2.x.57]的边界，从边界条件中推导出合适的外部值是很常见的做法（详见关于DG方法的一般文献）。在本教程中，我们考虑了三种类型的边界条件，即[1.x.49]，其中所有成分都是规定的；[1.x.50][1.x.51]，其中我们不规定外部解，因为流场正在离开域，而是使用内部值；我们仍然需要规定能量，因为欧拉通量中还有一个传入特征；[1.x.52]和[1.x.53]，描述了一个无穿透配置：[1.x.54]
*解的多项式展开最后被插入到弱形式中，测试函数被基础函数所取代。这就得到了一个空间上离散、时间上连续的非线性系统，该系统具有有限数量的不可知系数 [2.x.58] , [2.x.59] 。关于DG方法中多项式度数的选择，截至2019年，文献中并没有就何种多项式度数最有效达成共识，这个决定取决于问题的性质。高阶多项式可以确保更好的收敛率，因此对[1.x.55]解的中高精确度要求来说是比较好的。同时，自由度所在的体积与表面的比率随着高阶的增加而增加，这使得数值通量的影响变弱，通常会减少耗散。然而，在大多数情况下，解决方案是不平滑的，至少与可以承受的分辨率相比是不平滑的。例如，在不可压缩流体力学、可压缩流体力学以及与之相关的波传播课题中就是如此。在这个前渐进制度中，误差大约与数值分辨率成正比，而其他因素，如分散误差或耗散行为变得更加重要。非常高阶的方法往往被排除在外，因为它们有更多的限制性CFL条件，与未知数的数量相比，它们在表示复杂几何形状时也不那么灵活。因此，在实践中，2到6之间的多项式度数是最受欢迎的，例如，见[2.x.60]中的效率评估和其中引用的参考文献。
*[1.x.56][1.x.57]
* 

* 为了在时间上进行离散，我们略微重新排列弱的形式，并在所有单元上求和：[1.x.58]其中[2.x.61]贯穿所有基函数，从1到[2.x.62] 。
* 我们现在用[2.x.63]表示质量矩阵的条目[2.x.64]，用[1.x.59]表示评价欧拉算子右边的算子，给定一个与全局未知数矢量和使用中的有限元相关的函数[2.x.65]。这个函数[2.x.66]是明确地随时间变化的，因为在边界上评估的数值通量将涉及边界上某些部分的随时间变化的数据[2.x.67]、[2.x.68]和[2.x.69]，这取决于边界条件的分配情况。有了这个符号，我们可以把空间上的离散、时间上的连续系统紧凑地写成[1.x.60]，其中我们还冒昧地用[2.x.70]表示全局解向量（除了相应的有限元函数之外）。等价地，上述系统的形式为[1.x.61] 。
* 对于用高阶非连续Galerkinmethods离散的双曲系统，该系统的显式时间积分非常流行。这是因为质量矩阵[2.x.71]是块对角线（每个块只对应于定义在同一单元上的同类变量），因此很容易倒置。在每个时间步骤中
* 
* - 或Runge--Kutta方案的阶段
* 
* 只需要使用给定的数据评估一次微分算子，然后应用质量矩阵的逆向。另一方面，对于隐式时间步进，人们首先要对方程进行线性化，然后迭代解决线性系统，这涉及到几个残差评估和至少十几个线性化算子的应用，正如在[2.x.72]教程程序中所展示的那样。
* 当然，显式时间步进的简单性是有代价的，即所谓的Courant-Friedrichs-Lewy（CFL）条件带来的条件稳定性。它规定时间步长不能大于离散化微分算子的最快信息传播速度。用更现代的术语来说，传播速度对应于离散算子的最大特征值，反过来又取决于网格大小、多项式程度[2.x.73]和欧拉算子的物理特性，即[2.x.74]相对于[2.x.75]的线性化的特征值。在这个程序中，我们将时间步长设定为：[1.x.62] 。
*在所有正交点和所有单元中取最大值。无维数[2.x.76]表示Courant数，可以选择最大稳定数[2.x.77]，其值取决于所选择的时间步长方法及其稳定性。用于多项式缩放的功率[2.x.78]是启发式的，代表最接近1到8的多项式度数，例如，见[2.x.79] 。在更高的度数限制下，[2.x.80]，[2.x.81]的比例更准确，与通常用于内部惩罚方法的逆向估计有关。关于公式中使用的[1.x.63]网格尺寸[2.x.82]和[2.x.83]，我们注意到，对流传输是有方向性的。因此，一个合适的比例是使用速度方向上的元素长度[2.x.84]。下面的代码从参考单元到实际单元的Jacobian的倒数推导出这个比例，也就是说，我们接近[2.x.85] 。相反，声波具有各向同性的特点，这就是为什么我们使用最小的特征尺寸，由[2.x.86]的最小奇异值代表，用于声学缩放 [2.x.87] 。最后，我们需要添加对流和声学限制，因为欧拉方程可以以速度传输信息 [2.x.88] 。
* 在这个教程程序中，我们使用了[1.x.64]的一个特定变体，一般来说，它使用以下更新程序，从时间[2.x.90]的状态[2.x.89]到新时间[2.x.91]的[2.x.92]：[1.x.65 ]在[2.x.95]阶段方案中，向量[2.x.93]、[2.x.94]是对算子在某个中间状态的评价，用于通过某种线性组合来定义步骤结束值[2.x.96]。这个方案中的标量系数[2.x.97]、[2.x.98]和[2.x.99]是这样定义的，即满足高阶方案的某些条件，最基本的就是[2.x.100]。参数通常以所谓的[1.x.66]的形式收集，该参数收集了定义该方案的所有系数。对于一个五阶段方案，它看起来像这样：[1.x.67] 。
* 在本教程中，我们使用了显式Runge--Kutta方法的一个子集，即所谓的低存储Runge--Kutta方法（LSRK），它假定了系数的额外结构。在参考文献[2.x.101]使用的变体中，假设使用Butcher tableaus ofthe form[1.x.68]，有了这样的定义，对[2.x.102]的更新共享存储与中间值的信息[2.x.103]。从[2.x.104]和[2.x.105]开始，每个[2.x.106]阶段的更新简化为[1.x.69]除了被连续更新的向量[2.x.107]，这个方案只需要两个辅助向量，即保存微分算子评价的向量[2.x.108]，以及保存微分算子应用的右手边的向量[2.x.109]。在随后的阶段[2.x.110]中，值[2.x.111]和[2.x.112]可以使用相同的存储。
* 低存储量变体的主要优点是一方面减少了内存消耗（如果必须在内存中容纳非常多的未知数，持有所有的[2.x.113]来计算后续的更新，对于[2.x.114]来说已经是一个极限，在5到8之间
* 
*-记得我们使用的是显式方案，所以我们不需要存储任何通常比几个向量大得多的矩阵），而另一个是减少的内存访问。在这个程序中，我们对后一个方面特别感兴趣。由于运算符评估的成本只是使用交易二中的优化的无矩阵方法从内存中流出输入和输出向量的一小部分，我们必须考虑向量更新的成本，低存储量的变体可以提供两倍于传统的显式Runge--Kutta方法的吞吐量，因为这个原因，例如，见[2.x.115]中的分析。
* 除了参考文献[2.x.116]中的三阶、四阶和五阶精度的三种变体外，我们还使用了[2.x.117]中针对声学设置优化的七阶精度变体。声学问题是欧拉方程亚声速体系的有趣方面之一，其中可压缩性导致了声波的传递；通常，人们使用围绕背景状态的线性化欧拉方程或围绕固定框架的声波方程的进一步简化。
* 

*[1.x.70][1.x.71]
* 

* 这个程序中使用的主要成分是我们用来评估算子 [2.x.118] 和反质量矩阵 [2.x.119] 的快速无矩阵技术。实际上，[1.x.72]这个术语有点名不副实，因为我们是在处理一个非线性算子，而不是将这个算子线性化，而这个算子又可以用矩阵表示。然而，正如[2.x.120]和[2.x.121]中所显示的，积分的法估值已成为流行的疏散矩阵-向量乘积的替代方法，我们在交易二中创造了这个基础设施[1.x.73]，就是出于这个原因。此外，反质量矩阵确实是以无矩阵方式应用的，详见下文。
* 无矩阵的基础设施使我们能够快速评估弱形式的积分。其成分是将解系数快速插值为正交点的值和导数，在正交点上进行点对点运算（在这里我们实现了上述的微分算子），以及与所有测试函数相乘并在正交点上进行求和。第一和第三部分使用了和因子化，并在[2.x.122]教程中对单元积分和[2.x.123]对面积分进行了广泛的讨论。唯一不同的是，我们现在处理的是一个[2.x.124]分量系统，而不是以前教程程序中的标量系统。在代码中，所有的变化是FEEvaluation和FEFaceEvaluation类的一个模板参数，即设置分量的数量。对向量的访问和以前一样，都由评价器透明地处理。我们还注意到，下面的代码中选择的带有单个评价器的变体并不是唯一的选择
* 
* 我们也可以为独立的组件[2.x.125]、[2.x.126]和[2.x.127]使用单独的评估器；考虑到我们对所有组件的处理是相似的（也反映在我们将方程陈述为一个向量系统的方式上），这在这里会更加复杂。和以前一样，FEEvaluation类通过结合对几个单元（和面）的操作提供了显式的矢量化，涉及的数据类型称为矢量数组。由于这种类型的算术运算是重载的，所以我们不必太在意它，除了通过函数接口对函数进行评估，我们需要同时为几个正交点的位置提供特定的[1.x.74]评估。
* 本程序中更大的变化是在正交点的操作。在这里，多分量评估器为我们提供了以前没有讨论过的返回类型。在[2.x.128]中，对于[2.x.129]的拉普拉斯，将返回一个标量（更准确地说，是一个矢量数组类型，因为跨单元的矢量化），现在它返回的类型是`张量<1,dim+2,矢量数组<Number>'。同样，梯度类型现在是`张量<1,dim+2,张量<1,dim,矢量化数组<Number>>`，其中外张量收集欧拉系统的`dim+2`分量，内张量收集不同方向的偏导数。例如，欧拉系统的flux[2.x.130]就属于这种类型。为了减少我们为拼写这些类型而写的代码量，我们尽可能使用C++的 "自动 "关键字。
* 从实现的角度来看，非线性并不是一个很大的困难。它是在我们表达欧拉弱形式的条款时自然引入的，例如以动量条款的形式 [2.x.131] 。为了得到这个表达式，我们首先从动量变量[2.x.133]推导出速度[2.x.132]。鉴于[2.x.134]和[2.x.136]一样，被表示为[2.x.135]度的多项式，速度[2.x.137]是参考坐标[2.x.138]的一个有理表达。当我们进行乘法[2.x.139]时，我们得到一个表达式，它是两个多项式的比值，多项式的度数[2.x.140]在总分母中，多项式的度数[2.x.141]在分母中。结合测试函数的梯度，对于仿生单元，即平行四边形/平行四边形，积分项在umerator中为[2.x.142]，在分母中为[2.x.143]。在这一点上，我们通常需要放弃对精确积分的坚持，而采取高斯（更确切地说，高斯-勒格朗德）正交所提供的任何精度。这种情况与拉普拉斯方程的情况类似，在这种情况下，积分项包含非王子单元上的有理表达式，而且也只是近似积分。由于这些公式都是对多项式进行精确积分，所以我们必须以积分误差的形式来处理[1.x.75]的问题。
* 虽然不准确的积分对椭圆问题来说通常是可以容忍的，但对双曲问题来说，不准确的积分会引起一些令人头痛的效应，这种效应称为[1.x.76]。这个术语来自于信号处理，表达了不适当的、过于粗糙的采样情况。就正交而言，不适当的采样意味着我们使用的正交点比准确采样可变系数积分所需的正交点要少。在DG文献中已经表明，对于[1.x.77]解析的模拟，混叠误差会在数值解析中引入非物理性的振荡。事实上，混叠主要影响的是粗略的分辨率。
* 
* - 而更细的网格在相同的方案下却很好。
* 
* 这并不奇怪，因为分辨率高的模拟往往在单元的长度尺度上是平滑的（即它们在较高的多项式度数上有很小的系数，被太少的正交点所遗漏，而在较低的多项式度数上的主要解贡献仍然被很好地捕捉到了
* 
* 这只是泰勒定理的一个结果）。) 为了解决这个问题，DG文献中提出了各种方法。一种技术是过滤，它可以抑制与较高多项式度数有关的解成分。由于所选择的节点基不是分级的，这就意味着要从节点基转化为分级基（例如，基于Legendre多项式的模态基），其中单元内的分量按多项式程度划分。在这个基础上，我们可以将与高度数相关的求解系数乘以一个小数，保持低度数不变（以避免破坏一致性），然后再转换回节点基础。然而，过滤器会降低该方法的准确性。另一个在某种意义上更简单的策略是使用更多的正交点来更准确地捕捉非线性项。每个坐标方向使用超过[2.x.144]个正交点有时被称为过度积分或一致积分。后者在不可压缩的Navier-Stokes方程的背景下最为常见，其中[2.x.145]非线性导致度数为[2.x.146]的多项式积分（当同时考虑测试函数时），只要元素的几何形状是仿生的，就可以用每个方向的[2.x.147]正交点准确积分。在非多项式积分的欧拉方程的背景下，选择就不太清楚了。根据各种变量的变化，[2.x.148]或[2.x.149]点（分别积分度为[2.x.150]或[2.x.151]的精确多项式）都很常见。
* 为了反映程序中正交选择的这种可变性，我们把正交点的数量作为一个变量来指定，就像多项式的度数一样，并注意到人们会根据流量配置做出不同的选择。默认选择是[2.x.152]点。
* 
* - 比最小可能的[2.x.153]点多了一点。FEEvaluation和FEFaceEvaluation类允许通过模板参数无缝地改变点的数量，这样程序就不会因此而变得更加复杂。
* 

* [1.x.78][1.x.79] 。
* 

* 最后一项内容是反质量矩阵的评估 [2.x.154] 。在具有显式时间积分的DG方法中，质量矩阵是块状对角线，因此很容易被反转。
* 
* - 我们只需要反转对角线块。然而，考虑到无矩阵的积分评估在成本上更接近于只访问向量，即使应用块对角矩阵（例如通过LU因子的数组）也会比评估[2.x.155]贵几倍，仅仅是因为对于高阶有限元来说，仅仅存储和加载大小为`dofs_per_cell`x`dofs_per_cell的矩阵就很昂贵。由于这显然是不可取的，部分研究人员已经转向质量矩阵是对角线的基础，例如[1.x.80]正交Legendre基础，使用hierarchical多项式或Gaussianquadrature点上的Lagrange多项式（这只是利用Legendre信息的另一种方式）。虽然对角线特性对于变形元素来说是无效的，但是通过采取对角线质量矩阵而忽略其余部分（质量包络的变体，虽然不是[2.x.156]中使用的带有额外积分误差的变体）所产生的误差已经被证明不会改变离散化的准确性。高斯正交点中的拉格朗日基础有时也被称为同位设置，因为多项式的结点与正交点重合（="同位"），避免了一些内插操作。鉴于我们想在[2.x.157]中对非线性项使用更多的正交点，然而，collocationproperty已经消失。(更确切地说，在改变基础后，它仍然用于FEEvaluation和FEFaceEvaluation，见无矩阵论文 [2.x.158] )。
* 在这个教程程序中，我们使用拼合的思想来应用反质量矩阵，但有一个小小的转折。与其在高斯四分法的点上通过拉格朗日多项式使用拼合，我们更倾向于在高斯-洛巴特的点上使用传统的拉格朗日基础，因为这些使面积分的评估变得很便宜。这是因为对于高斯-洛巴特点，一些节点位于单元格的面上，而且不难证明，在任何给定的面上，唯一具有非零值的形状函数正是其节点实际上位于该面上的那些。当然，我们也可以像[2.x.159]那样使用高斯-洛巴特正交（有一些额外的积分误差），但我们不想牺牲精度，因为这些正交公式通常比一般高斯正交公式的阶数低。相反，我们使用参考文献[2.x.160]中描述的一个想法，其中提出为了应用反质量矩阵而改变基础。让我们用[2.x.161]来表示在正交点评估的形状函数矩阵，形状函数在矩阵的两边，正交点在列中。然后，单元格[2.x.162]上的质量矩阵由[1.x.81]给出。这里，[2.x.163]是对角线矩阵，以雅各布时间的行列式和正交权重（JxW）作为条目。矩阵[2.x.164]被构造为一维矩阵的克朗克积（张量积），例如在三维中为[1.x.82]，这是基础函数是一维形状函数的张量积，正交公式是一维正交公式的张量积的结果。对于多项式的数量等于正交点的数量的情况，[2.x.165]中的所有矩阵都是正方形的，而且克朗克积中[2.x.166]的成分也是正方形的。因此，我们可以对每个矩阵进行反转，形成整体的逆，[1.x.83]这个公式的结构与用和因子化技术对积分进行正向评价的步骤完全相同（即交易二的FEE评价和无矩阵框架）。因此，我们可以利用相同的代码路径，使用不同的插值矩阵，[2.x.167]而不是[2.x.168] 。
*类[2.x.169]实现了这个操作。它从有限元中包含的基(在这个例子中，FE_DGQ)改变为高斯正交点中的拉格朗日基。在这里，对角线质量矩阵的逆值可以被评估，这只是 "JxW "因子的逆值（即正交权重乘以从参考坐标到实坐标的Jacobian的行列式）。一旦这样做了，我们就可以回到标准的节点高斯-洛巴托基础。
* 这种应用反质量矩阵的特殊方式的优点是成本类似于质量矩阵的正向应用，比用超积分和面积分评估空间算子[2.x.170]更便宜。(我们将在[1.x.84]中用详细的时序信息证明这一点。)事实上，它是如此便宜，以至于在大多数现代体系结构上，它受到读取源向量、读取对角线和写入目标向量的带宽的限制。用于结果部分的硬件可以使计算的速度至少比从内存中提取向量的速度快一倍。
* 

*[1.x.85][1.x.86]
* 

* 在这个教程程序中，我们实现了两个测试案例。第一个案例是限于两个空间维度的融合测试。它运行一个所谓的各向异性漩涡，它通过一个背景流场进行传输。第二个案例使用了一个更令人兴奋的设置。我们使用[2.x.171]函数，从一个浸泡在通道中的圆柱体开始。在这里，我们在马赫数为[2.x.172]的亚音速初始场，在[2.x.173]方向有一个恒定的速度。在顶壁和底壁以及圆柱体上，我们施加一个无穿透（即切向流动）的条件。与初始条件相比，这种设置迫使气流重新定向，从而产生一个远离圆柱体的大声波。在上游方向，声波的传播速度较慢（因为它必须与迎面而来的气体对抗），包括密度和压力的不连续。在下游方向，由于声音的传播和流体的流动方向相同，传输速度较快，这在一定程度上抹去了不连续的现象。一旦声波击中上下壁，声音就会被反射回来，形成一些漂亮的形状，如下图[1.x.87]所示。
* 

* [1.x.88] [1.x.89]。
* 包含的文件与以前的无矩阵教程程序[2.x.174]、[2.x.175]和[2.x.176]相似。
* 

* 
* [1.x.90]
* 
* 以下文件包括CellwiseInverseMassMatrix数据结构，我们将用它来进行质量矩阵反演，这是本教程程序唯一的新包含文件。
* 

* 
* [1.x.91]
* 
* 与其他无矩阵教程程序类似，我们在文件的顶部收集所有控制程序执行的参数。除了我们想要运行的维度和多项式程度，我们还指定了我们想要用于欧拉方程中的非线性项的高斯正交公式中的点数。此外，我们指定了随时间变化的问题的时间间隔，并实现了两个不同的测试案例。第一个是二维的分析解，而第二个是介绍中描述的围绕圆柱体的通道流。根据测试案例，我们还改变了运行模拟的最终时间，以及一个变量`output_tick`，它指定了我们要在哪些时间间隔内写入输出（假设tick大于时间步长）。
* 

* 
* [1.x.92]
 
* 接下来是时间积分器的一些细节，即用公式[2.x.177]来衡量时间步长的Courant数，以及选择一些低存储量的Runge-Kutta方法。我们指定Runge--Kutta方案每级的Courant数，因为这对不同级数的方案给出了一个更现实的数字成本表达。
* 

* 
* [1.x.93]
 
* 最终，我们选择了空间离散化的一个细节，即单元间面的数值通量（黎曼求解器）。对于这个程序，我们实现了Lax--Friedrichs通量和Harten--Lax--van Leer(HLL)通量的一个修正变量。
* 

* 
* [1.x.94]
* 
* [1.x.95] [1.x.96]
 

* 
* 我们现在定义了一个具有测试案例0的精确解的类，以及一个具有测试案例1的通道背景流场的类。鉴于欧拉方程是一个在[2.x.179]维度上有[2.x.178]个方程的问题，我们需要告诉函数基类关于正确的分量数量。
* 

* 
* [1.x.97]
 
* 就实际实现的函数而言，分析性的测试案例是一个等熵涡旋案例（例如参见Hesthaven和Warburton的书，第209页第6.6节的例6.1），它满足欧拉方程，右侧的力项为零。考虑到这个定义，我们返回密度、动量或能量，这取决于所要求的成分。请注意，密度的原始定义涉及一些表达式的[2.x.180]-次方。由于[2.x.181]在某些系统上的实现相当慢，我们用对数加指数（以2为底）来代替它，这在数学上是等价的，但通常优化得更好。与[2.x.182]相比，这个公式对于非常小的数字来说，在最后一位数上可能会失去准确性，但是我们还是很高兴，因为小数字映射到接近1的数据。  
* 对于通道测试案例，我们简单地选择密度为1，[2.x.183]方向的速度为0.4，其他方向的速度为0，以及对应于根据背景速度场测量的1.3声速的能量，根据关系[2.x.184]计算。
* 

* 
* [1.x.98]
* 
* [1.x.99] [1.x.100] 。
 

* 
* 接下来的几行实现了一些低存储量的Runge--Kutta方法的变体。这些方法有特定的布彻表，系数为[2.x.185]和[2.x.186]，如介绍中所示。如同Runge--Kutta方法中的惯例，我们可以从这些系数中推导出时间步长[2.x.187]。这种方案的主要优点是每个阶段只需要两个向量，即解的累积部分[2.x.188]（在最后一个阶段后的新时间[2.x.190]保持解[2.x.189]），在各阶段被评估的更新向量[2.x.191]，加上一个向量[2.x.192]以保持运算器的评估。这样的Runge--Kutta设置减少了内存存储和内存访问。由于内存带宽通常是现代硬件上的性能限制因素，当微分算子的评估得到很好的优化时，性能可以比标准的时间积分器得到改善。考虑到传统的Runge--Kutta方案可能允许稍大的时间步长，因为更多的自由参数允许更好的稳定性，这也是事实。  
* 在本教程中，我们集中讨论Kennedy, Carpenter和Lewis(2000)的文章中定义的低存储方案的几个变体，以及Tselios和Simos(2007)描述的一个变体。还有一大系列的其他方案，可以通过额外的系数集或稍微不同的更新公式来解决。  
* 我们为这四种积分器定义了一个单一的类，用上述的枚举来区分。对每个方案，我们再将[2.x.193]和[2.x.194]的向量填充到类中的给定变量。
* 

* 
* [1.x.101]
* 
* 首先是Kennedy等人（2000）提出的三阶方案。虽然它的稳定区域明显小于其他方案，但它只涉及三个阶段，所以它在每个阶段的工作方面非常有竞争力。
* 

* 
* [1.x.102]
 
* 下一个方案是四阶的五级方案，也是在Kennedy等人（2000）的论文中定义的。
* 

* 
* [1.x.103]
 
* 以下是针对声学问题明确导出的七级四阶方案。它在四阶方案中兼顾了虚数特征值的精度，并结合了一个大的稳定区域。由于DG方案在最高频率之间是耗散的，这不一定转化为每级可能的最高时间步长。在本教程方案的背景下，数值通量在耗散中起着至关重要的作用，因此也是最大的稳定时间步长。对于修改后的Lax--Friedrichs通量，如果只考虑稳定性，该方案在每级步长方面与`stage_5_order_4`方案相似，但对于HLL通量来说，效率稍低。
* 

* 
* [1.x.104]
* 
* 这里包括的最后一个方案是Kennedy等人（2000）提出的五阶九级方案。它是这里使用的方案中最精确的，但更高的精度等级牺牲了一些稳定性，所以每级的步长归一化后比四阶方案要小。
* 

* 
* [1.x.105]
 
* 时间积分器的主要功能是通过各阶段，评估算子，为下一次评估准备[2.x.195]向量，并更新解向量 [2.x.196] 。我们把工作交给所涉及的`pde_operator`，以便能够把Runge--Kutta设置的矢量操作与微分算子的评估合并起来，以获得更好的性能，所以我们在这里所做的就是委托矢量和系数。    
* 我们单独调用第一阶段的算子，因为我们在那里需要稍作修改的参数。我们从旧的解决方案[2.x.197]而不是[2.x.198]向量中评估解决方案，所以第一个参数是`solution'。我们在这里让阶段向量[2.x.199]也持有评估的临时结果，因为它不用于其他方面。对于所有后续阶段，我们使用向量`vec_ki`作为第二个向量参数来存储运算符的求值结果。最后，当我们处于最后阶段时，我们必须跳过对向量[2.x.200]的计算，因为没有系数[2.x.201]可用（也不会被使用）。
* 

* 
* [1.x.106]
* 
* [1.x.107] [1.x.108] * * [1.x.108]。
 

* 
* 在下面的函数中，我们实现了与欧拉方程有关的各种特定问题的运算。每个函数都作用于我们在解向量中持有的守恒变量向量[2.x.202]，并计算各种派生量。  
* 首先是速度的计算，我们通过除以[2.x.204]从动量变量[2.x.203]中得出。这里需要注意的是，我们用关键字`DEAL_II_ALWAYS_INLINE`来装饰所有这些函数。这是一个特殊的宏，映射到一个编译器专用的关键字，告诉编译器永远不要为这些函数创建一个函数调用，而是将实现[1.x.109]移到它们被调用的地方。这对性能至关重要，因为我们对其中一些函数的调用达到了数百万甚至数十亿次。例如，我们既使用速度来计算通量，也使用速度来计算压力，而这两个地方都要在每个单元的每个正交点进行评估。确保这些函数是内联的，不仅可以确保处理器不必执行跳转指令进入函数（以及相应的返回跳转），而且编译器可以在调用函数的地方之后的代码中重新使用一个函数的上下文的中间信息。(我们注意到，编译器通常很善于自己找出哪些函数要内联。这里有一个地方，编译器可能会也可能不会自己想出来，但我们可以肯定的是，内联是一个胜利。)   
* 我们应用的另一个技巧是为反密度设置一个单独的变量 [2.x.205] 。这使得编译器只对通量进行一次除法，尽管除法在多个地方被使用。由于除法的费用大约是乘法或加法的10到20倍，避免多余的除法对性能至关重要。我们注意到，由于四舍五入的影响，在浮点运算中，先取反数，后与之相乘并不等同于除法，所以编译器不允许用标准的优化标志来交换一种方式。然而，以正确的方式编写代码也不是特别困难。  
* 总而言之，所选择的策略是总是内联和仔细定义昂贵的算术运算，这使得我们可以写出紧凑的代码，而不需要将所有的中间结果传递出去，尽管要确保代码映射到优秀的机器代码。
* 

* 
* [1.x.110]
* 
* 下一个函数使用公式[2.x.206]从保守变量矢量计算压力。如上所述，我们使用`euler_velocity()`函数中的速度。注意，我们需要在这里指定第一个模板参数`dim`，因为编译器无法从张量的参数中推导出它，而第二个参数（数字类型）可以自动推导出来。
* 

* 
* [1.x.111]
 
* 这里是欧拉通量函数的定义，也就是实际方程的定义。考虑到速度和压力（编译器的优化将确保只做一次），考虑到引言中所述的方程，这是直截了当的。
* 

* 
* [1.x.112]
* 
* 接下来的函数是一个简化数值通量实现的助手，实现了张量的张量（具有非标准的外维尺寸`dim + 2`，所以deal.II的张量类提供的标准重载在此不适用）与另一个相同内维的张量的作用，即一个矩阵-向量乘积。
* 

* 
* [1.x.113]
* 
* 这个函数实现了数值通量（黎曼解算器）。它从一个界面的两边获得状态，并获得法向量，从解的一边 [2.x.207] 面向解 [2.x.208] 。在依赖片断恒定数据的有限体积方法中，数值通量是核心成分，因为它是唯一输入物理信息的地方。在DG方法中，由于元素内部的多项式和那里使用的物理通量，数值通量就不那么核心了。由于在连续解的极限中，两边的数值一致的高阶插值，数值通量可以被看作是对两边解的跳跃的控制，以弱化连续性。必须认识到，在存在冲击的情况下，仅靠数值通量是无法稳定高阶DG方法的，因此任何DG方法都必须与进一步的冲击捕捉技术相结合，以处理这些情况。在本教程中，我们重点讨论了欧拉方程在亚声速体系中的波状解，在这种情况下，我们的基本方案是足够的。  
* 尽管如此，数值通量对整个方案的数值耗散起着决定性作用，并影响到显式Runge-Kutta方法的可接受的时间步长。我们考虑两种选择，一种是改良的Lax-Friedrichs方案，另一种是广泛使用的Harten-Lax-van Leer（HLL）通量。对于这两种变体，我们首先需要得到界面两侧的速度和压力，并评估物理欧拉通量。  
* 对于局部Lax--Friedrichs通量，定义为[2.x.209]，其中因子[2.x.210]给出最大波速，[2.x.211]为声速。在这里，考虑到通量对解的影响较小，出于计算效率的考虑，我们选择该表达式的两个修改。对于上述因子[2.x.212]的定义，我们需要取四个平方根，两个用于两个速度规范，两个用于两侧的声速。因此，第一个修改是宁可使用[2.x.213]作为最大速度的估计（如介绍中所示，它与实际最大速度最多相差2倍）。这使得我们可以从最大速度中抽出平方根，并且只需进行一次平方根计算就可以了。第二个修改是进一步放宽参数[2.x.214]--它越小，耗散系数就越小（与[2.x.215]中的跳跃相乘，最终可能会导致耗散变小或增大）。这使我们能够将频谱纳入显式Runge--Kutta积分器的稳定区域，并具有更大的时间步长。然而，我们不能使耗散太小，因为否则假想的特征值会越来越大。最后，目前的保守公式在[2.x.216]的极限中不是能量稳定的，因为它不是偏斜对称的，在这种情况下需要额外的措施，如分裂形式的DG方案。  
* 对于HLL通量，我们遵循文献中的公式，通过一个参数[2.x.217]引入Lax--Friedrichs的两个状态的额外加权。它是由欧拉方程的物理传输方向得出的，以当前的速度方向和声速为准。对于速度，我们在此选择一个简单的算术平均数，它足以满足危险情况和材料参数的适度跳跃。  
* 由于数值通量在弱式中是与法向量相乘的，所以我们对方程中的所有项都用法向量乘以结果。在这些乘法中，上面定义的 "运算器*"能够实现类似于数学定义的紧凑符号。  
* 在这个和下面的函数中，我们使用变量后缀`_m`和`_p`来表示从[2.x.218]和[2.x.219]得出的量，即在观察相邻单元时，相对于当前单元的 "这里 "和 "那里 "的值。
* 

* 
* [1.x.114]
* 
* 这个和下一个函数是辅助函数，提供紧凑的评估调用，因为多个点通过VectorizedArray参数被分批放在一起（详见[2.x.220] 教程）。这个函数用于亚音速外流边界条件，我们需要将能量分量设置为一个规定值。下一个函数请求所有分量上的解，用于流入边界，其中解的所有分量都被设置。
* 

* 
* [1.x.115]
 
* [1.x.116] [1.x.117] * [1.x.117].
 

* 
* 这个类实现了欧拉问题的评估器，类似于 [2.x.221] 或 [2.x.222] 的 `LaplaceOperator` 类。由于本算子是非线性的，不需要矩阵接口（交给预处理程序），我们跳过了无矩阵算子中的各种`vmult`函数，只实现了`apply`函数以及`apply`与上述低存储Runge-Kutta时间积分器所需的矢量更新的组合（称为`perform_stage`）。此外，我们还增加了三个涉及无矩阵例程的函数，即根据元素中的速度和声速计算时间步长的估计值（与实际时间步长的Courant数相结合），一个用于解决方案的投影（专门针对DG情况的[2.x.223]），以及一个用于计算与可能的分析解决方案或与某些背景状态的规范相对应的误差。  
* 本课的其余部分与其他无矩阵教程相似。正如介绍中所讨论的，我们提供了一些函数，允许用户在由[2.x.224]变量标记的领域边界的不同部分传递各种形式的边界条件，以及可能的体力。
* 

* 
* [1.x.118]
 
* 对于欧拉算子的初始化，我们设置了类中包含的MatrixFree变量。这可以通过给定一个描述可能的弯曲边界的映射以及一个描述自由度的DoFHandler对象来完成。由于我们在这个教程程序中使用的是不连续的Galerkin离散化，没有对解场施加强烈的约束，所以我们不需要传入AffineConstraints对象，而是使用一个假的来构建。关于正交，我们要选择两种不同的方式来计算基础积分。第一种是灵活的，基于模板参数`n_points_1d`（将被分配到本文件顶部指定的`n_q_points_1d`值）。更精确的积分是必要的，以避免由于欧拉算子中的可变系数而产生的混叠问题。第二个不太精确的正交公式是一个基于`fe_degree+1`的严密公式，需要用于反质量矩阵。虽然该公式仅在仿生元素形状上提供了精确的反，而在变形元素上则没有，但它能够通过张量积技术快速反转质量矩阵，这对于确保整体的最佳计算效率是必要的。
* 

* 
* [1.x.119]
 
* 随后的四个成员函数是必须从外部调用的，以指定各种类型的边界。对于一个流入的边界，我们必须以密度 [2.x.225] 、动量 [2.x.226] 和能量 [2.x.227] 来指定所有成分。考虑到这些信息，我们将函数和各自的边界ID一起存储在这个类别的地图成员变量中。同样，我们对亚音速外流边界（我们也要求一个函数，用来检索能量）和壁面（无穿透）边界进行处理，在壁面上我们施加零法线速度（不需要函数，所以我们只要求边界ID）。对于目前的DG代码来说，边界条件只作为弱形式的一部分被应用（在时间积分期间），设置边界条件的调用可以出现在对这个类的`reinit()`调用之前或之后。这与连续有限元代码不同，后者的边界条件决定了被送入MatrixFree初始化的AffineConstraints对象的内容，因此需要在无矩阵数据结构的初始化之前设置。  
* 在四个函数中的每一个中添加的检查是用来确保边界条件在边界的各个部分是相互排斥的，也就是说，用户不会意外地将一个边界既指定为流入边界，又指定为例如亚声速流出边界。
* 

* 
* [1.x.120]
* 
* [1.x.121] [1.x.122]
 

* 
* 现在我们开始研究欧拉问题的局部评价器。评估器相对简单，并遵循 [2.x.228] 、 [2.x.229] 或 [2.x.230] 中的内容。第一个明显的区别是，我们使用的FEE估值具有非标准的正交点数量。以前我们总是将正交点的数量设置为等于多项式度数加1（确保在仿生元素形状上的精确积分），现在我们将正交点的数量设置为一个单独的变量（例如多项式度数加多项式度数的二分之一或三分之一），以更准确地处理非线性项。由于评估器通过模板参数输入了适当的循环长度，并在变量[2.x.231]中保留了整个单元格中的正交点数量，我们现在自动对更准确的公式进行操作，而无需进一步修改。  
* 第二个区别是由于我们现在评估的是一个多分量系统，而不是之前考虑的标量系统。无矩阵框架提供了几种处理多成分情况的方法。这里显示的变体是利用一个嵌入了多个分量的FEEvaluation对象，由第四个模板参数`dim + 2`指定欧拉系统中的分量。因此，[2.x.232]的返回类型不再是一个标量（这将返回一个VectorizedArray类型，收集几个元素的数据），而是一个`dim+2`组件的Tensor。该功能与标量的情况类似；它由一个基类的模板专业化处理，称为FEEvaluationAccess。另一个变体是使用几个FEEvaluation对象，一个标量对象用于密度，一个带`dim`分量的矢量值对象用于动量，另一个标量评价器用于能量。为了确保这些分量指向解决方案的正确部分，FEEvaluation的构造函数在所需的MatrixFree字段之后需要三个可选的整数参数，即多DoFHandler系统的DoFHandler编号（默认取第一个），如果有多个Quadrature对象，则取正交点的编号（见下文），第三个参数是矢量系统的分量。由于我们有一个单一的矢量来表示所有的分量，我们将使用第三个参数，并将其设置为`0`表示密度，`1`表示矢量值的动量，`dim+1`表示能量槽。FEEvaluation然后在[2.x.233]和[2.x.234]或更紧凑的[2.x.235]和[2.x.236]调用中选择适当的解向量子范围。  
*当涉及到体力向量的评估时，出于效率的考虑，我们对两种情况进行了区分。如果我们有一个常数函数（从[2.x.237]中导出，我们可以在正交点的循环外预先计算出数值，并简单地在所有地方使用该数值。对于一个更通用的函数，我们反而需要调用我们上面提供的`evaluate_function()`方法；这个路径更昂贵，因为我们需要访问与正交点数据相关的内存。  
* 其余的部分沿用其他教程的程序。由于我们已经在单独的`euler_flux()`函数中实现了欧拉方程的所有物理学，我们在这里所要做的就是调用这个函数，给定在正交点评估的当前解，由`phi.get_value(q)`返回，并告诉FEEvaluation对象排队，通过形状函数的梯度（这是一个外部`dim+2`分量的张量，每个张量持有一个`dim`分量的[2.x.238 ] 欧拉通量的分量）。) 最后值得一提的是，在我们得到一个外部函数的情况下，我们通过测试函数`phi.submit_value()`的值来排队测试数据的顺序。我们必须在调用`phi.get_value(q)'之后进行，因为`get_value()'（读取解决方案）和`submit_value()'（排队等待测试函数的乘法和正交点的求和）访问同一个底层数据域。这里很容易实现没有临时变量`w_q`，因为值和梯度之间没有混合。对于更复杂的设置，我们必须首先复制出例如正交点的值和梯度，然后通过[2.x.239]和[2.x.240]再次排队等待结果。   
* 最后，我们提到我们没有使用这个函数的第一个MatrixFree参数，它是对[2.x.241]的回调，接口规定了现在的参数列表，但是由于我们在一个成员函数中，MatrixFree对象已经作为`data`变量可用，我们坚持使用它以避免混淆。
* 

* 
* [1.x.123]
* 
* 下一个函数涉及到内部面的积分计算，我们需要来自面的两个相邻单元的评估器。我们将变量`phi_m`与解分量[2.x.242]相关联，将变量`phi_p`与解分量[2.x.243]相关联。我们在FEFaceEvaluation的构造函数中通过第二个参数来区分两边，`true`代表内侧，`false`代表外侧，内侧和外侧表示相对于法向量的方向。  
* 注意调用[2.x.244]和[2.x.245]结合了对向量和因式分解部分的访问。这种合并操作不仅节省了一行代码，而且还包含了一个重要的优化。鉴于我们在Gauss-Lobatto正交公式的点上使用拉格朗日多项式的节点基础，[2.x.246]中只有[2.x.247]的基础函数在每个面上评估为非零。因此，评估器只访问了向量中的必要数据，而跳过了被零乘的部分。如果我们首先读取向量，我们就需要从向量中加载所有的数据，因为孤立的调用不知道后续操作中需要哪些数据。如果随后的[2.x.248]调用要求数值和导数，确实需要每个分量的所有[2.x.249]向量条目，因为所有基函数的正常导数都是非零的。  
* 评估器的参数以及程序与单元格评估相似。由于非线性项的存在，我们再次使用更精确的（过度）积分方案，指定为列表中第三个模板参数。在正交点上，我们再去找我们的自由函数来计算数值通量。它从两边（即[2.x.250]和[2.x.251]）接收在正交点评估的解决方案，以及到负边的法向量。正如上面所解释的，数值通量已经乘以来自减法侧的法向量了。我们需要转换符号，因为在引言中导出的弱形式中，边界项带有一个减号。然后，通量在负号和正号上都被排队测试，由于正号上的法向量与负号上的法向量正好相反，所以要调换符号。
* 

* 
* [1.x.124]
* 
* 对于位于边界的面，我们需要施加适当的边界条件。在这个教程程序中，我们实现了上述的四种情况。第五种情况，即超音速流出条件，将在下面的 "结果 "部分讨论）。不连续的Galerkin方法对边界条件的施加不是作为约束条件，而只是弱化。因此，各种条件是通过找到一个适当的[1.x.125]量[2.x.252]来施加的，然后交给也用于内部面的数值通量函数。实质上，我们 "假装 "域外的状态，如果那是现实，PDE的解将满足我们想要的边界条件。  
* 对于墙的边界，我们需要对动量变量施加一个无正态通量的条件，而对于密度和能量，我们使用的是诺伊曼条件 [2.x.253] 和 [2.x.254] 。为了实现无正态通量条件，我们将外部数值设置为内部数值，并减去壁面法线方向的2倍速度，即法线矢量方向的速度。  
* 对于流入边界，我们只是将给定的Dirichlet数据[2.x.255]作为边界值。另一种方法是使用[2.x.256] ，即所谓的镜像原理。  
* 外流的施加本质上是一个诺伊曼条件，即设置[2.x.257] 。对于亚音速流出的情况，我们仍然需要为能量施加一个值，我们从各自的函数中得出。对于[1.x.126]的情况，即在Neumann部分有动量通入域的情况，需要一个特殊的步骤。根据文献（这一事实可以通过适当的能量论证得出），我们必须改用流入部分的通量的另一种变体，见Gravemeier, Comerford, Yoshihara, Ismail, Wall, "A novel formulation for Neumann inflow conditions in biomechanics", Int. J. Numer. Meth. 生物医学。Eng., vol. 28 (2012). 这里，动量项需要再次添加，这相当于去除动量变量上的通量贡献。我们在后处理步骤中这样做，而且只适用于我们都处于外流边界且法向量与动量（或等同于速度）之间的点积为负的情况。由于我们在SIMD矢量化时一次处理几个正交点的数据，因此我们在这里需要明确地循环SIMD数组的条目。  
* 在下面的实现中，我们在正交点的层面上检查各种类型的边界。当然，我们也可以将决定权移出正交点循环，将整个面作为同类处理，这就避免了在正交点的内循环中进行一些地图/集合查找。然而，效率的损失并不明显，所以我们在这里选择了更简单的代码。还要注意的是，最后的 "else "子句会捕捉到这样的情况：边界的某些部分没有通过[2.x.258]被分配任何边界条件。
* 

* 
* [1.x.127]
* 
* 下一个函数实现了质量矩阵的逆运算。在介绍中已经广泛讨论了算法和原理，所以我们在这里只讨论[2.x.259]类的技术问题。它所做的操作与质量矩阵的正向评估类似，只是有一个不同的插值矩阵，代表逆[2.x.260]因子。这些代表了从指定的基础（在这种情况下，高斯--洛巴托正交公式点中的拉格朗日基础）到高斯正交公式点中的拉格朗日基础的改变。在后者的基础上，我们可以应用点的逆向`JxW`因子，即正交权重乘以从参考坐标到实坐标的映射的雅各布系数。一旦完成了这一操作，基数将再次变回节点高斯-洛巴托基数。所有这些操作都由下面的 "apply() "函数完成。我们需要提供的是要操作的局部场（我们通过FEEvaluation对象从全局向量中提取），并将结果写回质量矩阵操作的目标向量。  
* 需要注意的一点是，我们在FEEvaluation的构造函数中添加了两个整数参数（可选），第一个是0（在多DoFHandler系统中选择DoFHandler；在这里，我们只有一个），第二个是1，用于进行正交公式选择。由于我们将正交公式0用于非线性项的过度积分，我们将公式1与默认的[2.x.261]（或变量名称中的`fe_degree+1`）点用于质量矩阵。这导致了对质量矩阵的平方贡献，并确保了精确的积分，正如介绍中所解释的。
* 

* 
* [1.x.128]
* 
* [1.x.129] [1.x.130].
 

* 
* 现在我们来看看实现欧拉算子整体评估的函数，即[2.x.262]，调用上面介绍的局部评估器。这些步骤在前面的代码中应该是清楚的。需要注意的一点是，我们需要调整与边界各部分相关的函数中的时间，以便在边界数据随时间变化的情况下与方程一致。然后，我们调用[2.x.263]来执行单元和面的积分，包括在`src`向量中进行必要的ghost数据交换。该函数的第七个参数，"true"，指定我们要在开始向其累积积分之前，将 "dst "向量作为循环的一部分归零。这个变体比在循环之前明确调用`dst = 0.;`要好，因为归零操作是在矢量的子范围内完成的，其部分是由附近的积分写入的。这加强了数据的定位，并允许缓存，节省了向量数据到主内存的一次往返，提高了性能。循环的最后两个参数决定了哪些数据被交换：由于我们只访问一个面的形状函数的值，这是典型的一阶双曲问题，并且由于我们有一个节点基础，节点在参考元素表面，我们只需要交换这些部分。这又节省了宝贵的内存带宽。  
* 一旦应用了空间算子[2.x.264]，我们需要进行第二轮，应用反质量矩阵。这里，我们称之为[2.x.265]，因为只有单元积分出现。单元循环比全循环更便宜，因为只访问与本地拥有的单元相关的自由度，这只是DG离散化的本地拥有的自由度。因此，这里不需要鬼魂交换。  
* 在所有这些函数周围，我们设置了定时器范围来记录计算时间，以统计各部分的贡献。
* 

* 
* [1.x.131]
 
* 让我们转到做Runge--Kutta更新的整个阶段的函数。它调用[2.x.266]，然后对向量进行一些更新，即`next_ri = solution + factor_ai k_i`和`solution += factor_solution k_i`。与其通过向量接口执行这些步骤，我们在此提出一个替代策略，在基于缓存的架构上速度更快。由于向量所消耗的内存往往比缓存所能容纳的要大得多，所以数据必须有效地来自缓慢的RAM内存。这种情况可以通过循环融合来改善，即在一次扫描中对`next_ki`和`solution`进行更新。在这种情况下，我们将读取两个向量`rhs`和`solution`并写入`next_ki`和`solution`，而在基线情况下，至少有4次读取和两次写入。在这里，我们更进一步，当质量矩阵反转在向量的某一部分完成后，立即执行循环。 [2.x.267]提供了一种机制，在单元格的循环第一次接触到一个向量条目之前，附加一个[2.x.268]（我们在这里没有使用，但是例如用于向量的归零），以及在循环最后接触到一个条目之后调用第二个[2.x.269]。回调的形式是给定向量上的一个范围（就MPI宇宙中的本地索引编号而言），可以由`local_element()`函数处理。  
* 对于这第二个回调，我们创建一个在范围上工作的lambda，并在这个范围上写入各自的更新。理想情况下，我们会在本地循环之前添加`DEAL_II_OPENMP_SIMD_PRAGMA`，以建议编译器对这个循环进行SIMD并行化（这意味着在实践中，我们要确保我们在循环内使用的指针的索引范围之间没有重叠，也称为别名）。事实证明，在写这篇文章的时候，GCC 7.2无法编译lambda函数中的OpenMP pragma，所以我们在下面注释了这个pragma。如果你的编译器比较新，你应该可以再次取消注释这些行。  
* 注意，当我们不需要更新`next_ri`向量时，我们为最后的Runge--Kutta阶段选择了不同的代码路径。这个策略带来了相当大的速度提升。在40核机器上，默认矢量更新时，逆质量矩阵和矢量更新需要60%以上的计算时间，而在更优化的变体中，这一比例约为35%。换句话说，这是一个大约三分之一的速度提升。
* 

* 
* [1.x.132]
* 
* 在讨论了处理推进解的一个时间步长的函数的实现之后，现在让我们转向实现其他辅助性操作的函数。具体来说，这些是计算投影、评估误差和计算单元上信息传输速度的函数。  
* 其中第一个函数基本上等同于[2.x.270]，只是速度快得多，因为它是专门针对DG元素的，不需要设置和解决线性系统，因为每个元素都有独立的基函数。我们在这里展示代码的原因，除了这个非关键操作的小幅提速之外，还因为它展示了[2.x.271]提供的额外功能。   
* 投影操作的工作原理如下。如果我们用[2.x.272]表示在正交点评估的形状函数矩阵，在单元格[2.x.273]上的投影是一个形式为[2.x.274]的操作，其中[2.x.275]是包含雅各布系数乘以正交权重（JxW）的对角线矩阵，[2.x.276]是单元格质量矩阵，[2.x.277]是要投影到正交点的领域评估。实际上，矩阵[2.x.278]通过张量积有额外的结构，如介绍中所解释的）。这个系统现在可以等效地写成[2.x.279] 。现在，项[2.x.280]和[2.x.281]相抵消，导致最后的表达式[2.x.282] 。这个操作由[2.x.283]实现。这个名字来自于这个投影只是乘以[2.x.284]，一个从高斯正交点的节点基到给定的有限元基的基数变化。请注意，我们调用[2.x.285]将结果写入矢量，覆盖之前的内容，而不是像典型的积分任务那样将结果累积起来。
* 
* - 我们可以这样做，因为对于不连续的Galerkin离散，每个向量条目都只有一个单元的贡献。
* 

* 
* [1.x.133]
* 
* 下一个函数再次重复了deal.II库提供的功能，即[2.x.286] 我们在这里展示了明确的代码，以强调跨多个单元的矢量化是如何工作的，以及如何通过该接口积累结果。回顾一下，每个[1.x.134]的矢量化数组持有来自不同单元的数据。通过对当前MPI进程所拥有的所有单元批的循环，我们就可以填充一个结果的VectorizedArray；为了得到一个全局的总和，我们需要进一步去对SIMD阵列中的条目进行求和。然而，这样的程序并不稳定，因为SIMD数组事实上可能并不持有其所有通道的有效数据。当本地拥有的单元的数量不是SIMD宽度的倍数时，就会发生这种情况。为了避免无效数据，我们必须在访问数据时明确地跳过那些无效的通道。虽然人们可以想象，我们可以通过简单地将空车道设置为零（从而不对总和做出贡献）来使其工作，但情况比这更复杂。如果我们要从动量中计算出一个速度呢？那么，我们就需要除以密度，密度为零。
* 
* - 结果将是NaN，并污染了结果。当我们在单元格批次中循环时，使用函数[2.x.287]给我们提供有效数据的通道数，累积有效SIMD范围内的结果，就可以避免这种陷阱。它在大多数单元上等于[2.x.288]，但如果与SIMD宽度相比，单元数有余数，则在最后一个单元批上可能更少。
* 

* 
* [1.x.135]
* 
* EulerOperator类的最后一个函数用于估计传输速度，由网格大小缩放，这与设置显式时间积分器的时间步长有关。在欧拉方程中，有两种传输速度，即对流速度[2.x.289]和声波的传播，其声速[2.x.290]相对于介质的运动速度[2.x.291] 。  
*在时间步长的公式中，我们感兴趣的不是这些绝对速度，而是信息穿过一个单元所需的时间。对于与介质一起传输的信息，[2.x.292]是由网格大小缩放的，所以最大速度的估计可以通过计算[2.x.293]得到，其中[2.x.294]是实域到参考域的转换的雅各布系数。请注意，[2.x.295]返回的是反转和转置的雅各布，代表从实数到参考坐标的公因子项，所以我们不需要再次转置。我们在下面的代码中把这个极限存储在变量`convective_limit`中。  
* 声音的传播是各向同性的，所以我们需要考虑到任何方向的网格大小。然后，适当的网格大小比例由[2.x.296]的最小奇异值给出，或者，等同于[2.x.297]的最大奇异值。请注意，当忽略弯曲的单元时，可以用单元顶点之间的最小距离来近似这个量。为了得到Jacobian的最大奇异值，一般的策略是使用一些LAPACK函数。由于我们在这里所需要的是一个估计值，我们可以避免将一个向量数组的张量分解成几个矩阵的麻烦，并进入一个（昂贵的）没有向量的特征值函数，而是使用应用于[2.x.298]的幂方法的几次迭代（在下面的代码中为五次）。这种方法的收敛速度取决于最大特征值与次大特征值的比率以及初始猜测，即所有1的矢量。这可能表明，我们在接近立方体形状的单元上得到缓慢的收敛，在这种情况下，所有的长度几乎都是一样的。然而，这种缓慢的收敛意味着结果将位于两个最大的奇异值之间，而这两个奇异值无论如何都是接近最大值的。在所有其他情况下，收敛将是快速的。因此，我们可以只在这里硬编码5次迭代，并确信结果是好的。
* 

* 
* [1.x.136]
* 
* 与前面的函数类似，我们必须确保只在一个单元格批次的有效单元格上积累速度。
* 

* 
* [1.x.137]
* 
* [1.x.138] [1.x.139]。
 

* 
* 该类将EulerOperator类与时间积分器和通常的全局数据结构（如FiniteElement和DoFHandler）相结合，以实际运行欧拉问题的模拟。  
* 成员变量是一个三角形、一个有限元、一个映射（用于创建高阶曲面，见例如[2.x.299]）和一个描述自由度的DoFHandler。此外，我们还保留了上面描述的EulerOperator的一个实例，它将在积分方面做所有繁重的工作，以及一些用于时间积分的参数，如当前时间或时间步长。  
* 此外，我们使用一个PostProcessor实例来向输出文件写入一些额外的信息，这与 [2.x.300] 中的做法类似。DataPostprocessor类的接口很直观，要求我们提供关于需要评估的信息（通常只有解的值，除了Schlieren图，我们只在二维中启用它是有意义的），以及被评估的东西的名称。请注意，也可以通过可视化程序（如ParaView）中的计算器工具来提取大部分信息，但在写输出的时候就已经做了，这要方便得多。
* 

* 
* [1.x.140]
* 
* 对于字段变量的主要评估，我们首先检查数组的长度是否等于预期值（长度`2*dim+4`或`2*dim+5`是由我们在下面的get_names()函数中指定的名字的大小得出）。然后我们在所有的评估点上循环，填充相应的信息。首先，我们填写密度[2.x.301]、动量[2.x.302]和能量[2.x.303]的原始解变量，然后计算得出速度[2.x.304]、压力[2.x.305]、声速[2.x.306]，以及显示[2.x.307]的Schlieren图，如果它被启用。参见[2.x.308]中的另一个例子，我们创建了一个Schlieren图）。
* 

* 
* [1.x.141]
* 
* 对于数量的解释，我们有标量密度、能量、压力、声速和Schlieren图，以及动量和速度的向量。
* 

* 
* [1.x.142]
* 
* 关于必要的更新标志，我们只需要所有量的值，但Schlieren图除外，它是基于密度梯度的。
* 

* 
* [1.x.143]
* 
* 这个类的构造函数并不令人惊讶。我们设置了一个基于 "MPI_COMM_WORLD "通信器的并行三角形，一个具有 "dim+2 "分量的密度、动量和能量的矢量有限元，一个与底层有限元相同程度的高阶映射，并将时间和时间步长初始化为零。
* 

* 
* [1.x.144]
* 
* 作为一个网格，本教程程序实现了两个选项，取决于全局变量`testcase`。对于分析变量（`testcase==0`），域是[2.x.309]，域的周围都有Dirichlet边界条件（流入）。对于`testcase==1`，我们将域设置为矩形箱中的圆柱体，来自于Sch&auml;fer和Turek(1996)的不可压缩粘性流动的流过圆柱体测试案例。在这里，我们有更多种类的边界。通道左侧的流入部分是给定的流入类型，为此我们选择了一个恒定的流入轮廓，而我们在右侧设置了一个亚声速的流出。对于圆柱体周围的边界（边界id等于2）以及通道壁（边界id等于3），我们使用壁的边界类型，即无正态流。此外，对于三维圆柱体，我们还在垂直方向上增加了一个重力。有了基础网格（包括由[2.x.310]设置的流形），我们就可以执行指定数量的全局细化，从DoFHandler中创建未知编号，并将DoFHandler和Mapping对象交给EulerOperator的初始化。
* 

* 
* [1.x.145]
* 
* 在下文中，我们输出了一些关于这个问题的统计数据。因为我们经常会出现相当多的单元格或自由度，所以我们希望用逗号来分隔每一组的三位数来打印它们。这可以通过 "locales "来实现，尽管这种工作方式并不特别直观。 [2.x.311]对此有稍微详细的解释。
* 

* 
* [1.x.146]
* 
* 对于输出，我们首先让欧拉算子计算出数值结果的误差。更确切地说，对于分析解的情况，我们计算与分析结果的误差，而对于第二个测试情况，我们计算与密度和能量恒定的背景场以及[2.x.312]方向的恒定速度的偏差。  
* 下一步是创建输出。这与[2.x.313]中的做法类似：我们让上面定义的后处理器控制大部分的输出，除了我们直接写的原始场。对于分析解的测试案例，我们还对分析解进行了另一次投影，并打印出该场和数值解之间的差异。一旦我们定义了所有要写的量，我们就建立输出的补丁。与[2.x.314]类似，我们通过设置适当的标志来创建一个高阶VTK输出，这使我们能够可视化高多项式度的场。最后，我们调用[2.x.315]函数，将结果写入给定的文件名。这个函数使用了特殊的MPI并行写设施，通常比其他大多数教程程序中使用的标准库的[2.x.316]变体对并行文件系统更加优化。`write_vtu_in_parallel()`函数的一个特别好的特点是，它可以将所有MPI行列的输出合并到一个文件中，使得没有必要有一个所有此类文件的中央记录（即 "pvtu "文件）。  
* 对于并行程序来说，查看单元格在处理器之间的划分往往是有启发的。为此，我们可以向[2.x.317]传递一个数字向量，其中包含与当前处理器拥有的活动单元一样多的条目；然后这些数字应该是拥有这些单元的处理器的等级。例如，这样一个向量可以从[2.x.318]中获得。另一方面，在每个MPI进程中，DataOut将只读取那些对应于本地拥有的单元的条目，这些条目当然都有相同的值：即当前进程的等级。矢量的其余条目中的内容实际上并不重要，因此我们可以用一个廉价的技巧逃脱。我们只是用当前MPI进程的等级来填补我们给[2.x.319]的向量的所有*值。关键是在每个进程上，只有对应于本地拥有的单元格的条目会被读取，而忽略其他条目中的（错误的）值。事实上，每个进程提交的向量中，正确的条目子集是正确的，这一点就足够了。
* 

* 
* [1.x.147]
* 
* [2.x.320]函数将所有的碎片放在一起。它首先调用创建网格和设置数据结构的函数，然后初始化时间积分器和低存储积分器的两个临时向量。我们称这些向量为`rk_register_1`和`rk_register_2`，并使用第一个向量表示[2.x.321]，第二个向量表示[2.x.322]，在介绍中概述的Runge-Kutta方案的公式中。在我们开始时间循环之前，我们通过[2.x.323]函数计算时间步长。为了便于比较，我们将那里得到的结果与最小网格尺寸进行比较，并将它们打印到屏幕上。在本教程程序中，对于接近统一的声速和速度，预测的有效网格尺寸将是接近的，但如果缩放比例不同，它们可能会有所不同。
* 

* 
* [1.x.148]
 
* 现在我们准备开始时间循环，我们一直运行到时间达到预期的结束时间。每隔5个时间步骤，我们就计算一个新的时间步骤的估计值
* 
* - 由于解决方案是非线性的，在模拟过程中调整数值是最有效的。如果Courant数选择得过于激进，模拟通常会在时间步长为NaN时爆炸，所以在这里很容易发现。有一点需要注意的是，由于不同的时间步长选择的相互作用，四舍五入的误差可能会传播到前几位数，从而导致略有不同的解决方案。为了降低这种敏感性，通常的做法是将时间步长四舍五入或截断到几位数，例如在这种情况下是3。如果当前时间接近规定的输出 "刻度 "值（如0.02），我们也会写出输出。在时间循环结束后，我们通过打印一些统计数据来总结计算，这主要由[2.x.324]函数完成。
* 

* 
* [1.x.149]
* 
* main()函数并不令人惊讶，它遵循了以前所有MPI程序中的做法。当我们运行一个MPI程序时，我们需要调用`MPI_Init()`和`MPI_Finalize()`，我们通过[2.x.325]数据结构来完成。注意，我们只用MPI来运行程序，并将线程数设置为1。
* 

* 
* [1.x.150]
* [1.x.151][1.x.152] 。
* 

* [1.x.153][1.x.154]。
 

* 在有40个进程的机器上以默认设置运行该程序，产生以下输出。
* [1.x.155]
* 
* 程序输出显示，所有的错误都很小。这是由于我们使用了一个相对较细的[2.x.326]单元的网格，并使用5度的多项式来求得一个平滑的解决方案。一个有趣的模式显示在时间步长上：虽然在时间5之前是0.0069，但在后来的时间里增加到0.0096。一旦涡流在声速之上有一些运动（因此传播速度较快），在时间5和6.5之间离开计算域，步长就会增加。在这之后，气流只是在同一方向上是均匀的，与之前均匀速度被涡旋覆盖的状态相比，气体的最大速度有所下降。我们的时间步长公式认识到了这种效应。
* 最后一块输出显示了关于程序各个部分时间的详细信息；它通过显示最快和最慢的处理器所花费的时间以及平均时间来分解这些信息。
* 
* 总结显示，1283个时间步骤在1.02秒内完成（看所有MPI进程的平均时间），而11个文件的输出又花了0.96秒。将每个时间步骤分解成五个Runge-Kutta阶段，每次评估的计算时间为0.16毫秒。这种高性能是无矩阵评估器的典型表现，也是显式时间积分对隐式求解器非常有竞争力的原因，特别是对于大规模模拟。程序运行结束时的计算时间分类显示，[2.x.327]中的积分评估贡献了大约0.92秒，反质量矩阵的应用贡献了0.06秒。此外，对时间步长计算的运输速度的估计又贡献了0.05秒的计算时间。
* 如果我们再使用三个级别的全局细化和总共940万个DoF，最终的统计数据如下（对于修改后的Lax--Friedrichs通量，[2.x.328]，和同一系统的40个核心的双插槽Intel Xeon Gold 6230）。
* [1.x.156]
* 
* 每个时间步长，解算器现在需要0.02秒，大约是147k未知数的小问题的25倍。鉴于该问题涉及64倍的未知数，计算时间的增加并不令人惊讶。由于我们也做了8倍的时间步骤，理论上计算时间应该增加512倍。实际增加的是205秒/1.02秒=202。这是因为由于通信开销的原因，小问题的规模不能充分利用40个核心。如果我们研究一下每个时间步长的操作细节，这一点就很清楚了。带有近邻通信的差分算子[2.x.329]的评估时间从0.92秒到127秒，也就是说，增加了138倍。另一方面，应用反质量矩阵和向量更新的成本，完全不需要在MPI进程之间通信，增加了1195倍。这一增长超过了512的理论系数，因为对于较大的尺寸，操作受限于RAM内存的带宽，而对于较小的尺寸，所有的向量都可以进入CPU的缓存。这些数字表明，质量矩阵评估和矢量更新部分几乎消耗了Runge--Kutta阶段的40%的时间。
* 
* - 尽管使用了低存储量的Runge--Kutta积分器和合并矢量操作! 尽管对[2.x.330]算子使用了过度积分。对于更简单的微分算子和更昂贵的时间积分器，花费在质量矩阵和矢量更新部分的比例也可以达到70%。如果我们以每秒处理的DoF和Runge--Kutta阶段计算一个吞吐量数字，我们得到[1.x.157]这个吞吐量数字非常高，因为简单地将一个向量复制到另一个向量的运行速度只有大约10,000 MDoFs/s。
* 如果我们进入下一个更大的尺寸，有3770万个DoFs，总体模拟时间为2196秒，其中1978秒用于分步。L_h算子的运行时间增加了9.3倍（1179秒对127秒），反质量矩阵和向量更新增加了10.3倍（797对77.5秒）。这种非最佳运行时间增长的原因可以追溯到给定硬件上的缓存效应（40MB的二级缓存和55MB的三级缓存）。虽然不是所有的相关数据都适合940万DoF的缓存（一个向量需要75MB，我们有三个向量加上MatrixFree中的一些额外数据），但还是有能力容纳一个半向量。考虑到现代的缓存比天真的最近使用的策略更复杂（在这种情况下，由于数据是以类似于流的方式使用的，我们几乎没有重复使用），我们可以假设，在940万DoF的情况下，确实有相当一部分数据可以从缓存中交付。对于更大的情况，即使有最佳的缓存，也只有不到10%的数据可以放入缓存中，而且会有相关的性能损失。
* 

*[1.x.158][1.x.159]
* 

* 对于修改后的Lax--Friedrichs通量和测量动量变量的误差，我们得到以下收敛表（密度和能量变量的收敛率是非常相似的）。
* [2.x.331] 
* 如果我们改用Harten-Lax-van Leer通量，其结果如下。[2.x.332] 
* 表格显示，我们对两种数值通量都得到了最佳[2.x.333]收敛率。对于[2.x.334]的Lax--Friedrichs通量，误差略小，但对于[2.x.335]的情况则相反；无论如何，在这个测试案例中的差异是相对小的。
* 对于[2.x.336]，我们在最细的网格上的两个通量都达到了[2.x.337]的舍入精度。还要注意的是，误差是绝对的，域长为[2.x.338]，所以相对误差低于[2.x.339]。HLL通量在最高度数上要好一些，这是由于Lax--Friedrichs通量的轻微不准确造成的。Lax--Friedrichs通量对离开域的溶液设置了一个Dirichletcondition，这导致了一个小的人工反射，这在Lax--Friedrichs通量中被强调了。除此之外，我们看到数值通量的影响是很小的，因为元素内部的多项式部分才是通量的主要动力。当试图用高阶DG设置来接近更具挑战性的设置时，通量的有限影响也会产生影响。以[2.x.340]的参数和网格为例，一旦高质部分接近边界，我们在两种通量下都会得到振荡（这反过来会使密度变成负值，使溶液爆炸），这与低阶有限体积情况相反（[2.x.341]）。因此，任何导致溶液中出现冲击的情况都需要某种形式的限制性或人工耗散。对于另一种选择，见[2.x.342]的教程程序。
* 

*[1.x.166][1.x.167]
* 

* 对于通道中圆柱体周围流动的测试案例，我们需要将第一行代码改为
* [1.x.168]
* 这个测试案例从一个马赫数为0.31的恒定速度和恒定的初始密度的背景场开始；流动将不得不围绕一个圆柱体形式的障碍物。由于我们在圆柱体壁上施加了一个穿透条件，最初迎面撞上圆柱体的气流必须重新排列，这就产生了一个大的声波。下面的图片显示了在全局细化为5级的二维情况下，使用102,400个具有多项式5度的单元和1470万个自由度的所有4个求解变量在0.1、0.25、0.5和1.0时的压力情况（左上至右下）。在时间0.25时，声波已经到达顶壁和底壁并反射到内部。从下壁和上壁反射波的不同距离，我们可以看到Sch&auml;fer-Turek测试案例[2.x.343]所代表的轻微不对称性，圆柱体上方的空间比下方要大一些。在后来的时间里，画面更加混乱，到处都是许多声波。
* [2.x.344] 
* 下一张图片显示了在时间1.0时，从通道入口向出口看，在相同的分辨率下，压力的高程图。
* 
* -在这里，我们可以看到大量的反射。在图中，可以看到两种类型的波。较大振幅的波对应的是初始不连续性撞击墙壁时发生的各种反射，而与元素大小相似的小振幅波则对应的是数值伪影。它们起源于方案的有限分辨率，并在不连续点穿越高阶多项式的元素时出现。这种效应可以通过提高分辨率来治愈。除此以外，丰富的波浪结构是高阶DG方法的传输精度的结果。
* [2.x.345] 
* 在2级全局细化和1,600个单元的情况下，40个MPI进程的网格和网格划分情况如下。
* [2.x.346] 
* 当我们在40个核心上运行具有4级全局细化的代码时，我们得到以下输出。
* [1.x.169]
* 
* 这里显示的各种数量的准则是对背景场（即初始条件）的偏差[2.x.347]、[2.x.348]和[2.x.349]。运行时间的分布总体上与前一个测试案例相似。唯一略有不同的是，与反质量矩阵和矢量更新相比，[2.x.350]中花费的时间比例较大。这是因为几何体是变形的，矩阵自由框架需要从内存中加载额外的几何体数组，这些数组在仿生网格情况下被压缩。
* 将全局细化的数量增加到5，输出就变成了。
* [1.x.170]
* 
* 对性能的影响与分析性测试案例相似
* 
* - 理论上，计算时间应该增加8倍，但我们实际上看到时间步骤增加了11倍（219.5秒对2450秒）。这可以追溯到缓存，小的情况下大部分都适合于缓存。一个有趣的效果，是典型的混合了本地通信（积分[2.x.351]）和全局通信（运输速度的计算）的程序，有一些负载不平衡，可以通过查看分别遇到不同阶段的最小和最大时间的MPI等级来观察。排名0报告了 "rk时间步入总数 "部分的最快吞吐量。同时，对于 "计算传输速度 "部分，它似乎是最慢的，比平均水平慢2倍，与较快的等级相比，几乎是4倍。由于后者涉及全局通信，我们可以将这部分的缓慢归因于本地Runge--Kutta阶段在这个等级上进展较快，需要等待其他处理器赶上。然而，无矩阵框架在位于通道出口的affine和Cartesiancells上更快，因为MPI等级较低的单元被分配到这些单元。另一方面，报告Runga--Kutta阶段最高运行时间的等级32拥有靠近圆柱体的弯曲单元，对于这些单元不可能有数据压缩。为了提高吞吐量，我们可以在划分[2.x.352]对象时给不同的单元类型分配不同的权重，甚至可以测量几个时间步骤的运行时间，然后尝试重新平衡。
* 在346,000个Runge--Kutta阶段中，对于1470万DoFs的测试案例，每个Runge--Kutta阶段的吞吐量可以计算到2085 MDoFs/s，比上面报告的2360 MDoFs/s的笛卡尔网格吞吐量稍微慢一些。
* 最后，如果我们增加一个额外的细化，我们记录了以下输出。
* [1.x.171]
* 
* "rk time stepping total "部分对应的是2010 MDoFs/s的吞吐量。执行139k时间步长的总体运行时间为20k秒（5.7小时），即每秒7个时间步长。
* 
* - 对于有近6000万个未知数来说，这还不算太坏。通过在计算中加入更多的核，可以实现更多的吞吐量。
* 

* [1.x.172][1.x.173] 。
 

* 将通道测试案例切换到3D，并进行3次全局细化，其输出结果为
* [1.x.174]
* 
* 物理学与二维案例相似，由于引力的作用，在z方向有轻微的运动。在这种情况下，每个Runge--Kuttastage的吞吐量是[1.x.175] 。
* 由于[2.x.353]项的计算比较昂贵，所以吞吐量比二维情况下要低。这是由于 "度数+2 "点的过度积分和更大比例的面积分（更差的体积-表面比率）以及更昂贵的通量计算。如果我们只考虑反质量矩阵和矢量更新的部分，我们记录到等熵涡旋的2D案例的吞吐量为4857 MDoFs/s，有3770万个未知数，而3D案例的吞吐量为4535 MDoFs/s。性能是相似的，因为这两种情况实际上都受到内存带宽的限制。
* 如果我们进行四级全局细化，我们需要增加进程的数量以适应内存中的所有内容。
* 
* - 在这种情况下，计算需要大约350GB的RAM内存。另外，通过增加额外的资源，完成35k个时间步长所需的时间也变得更加可以忍受。因此，我们使用了6个节点，每个节点有40个内核，从而形成了一个有240个MPI进程的计算。
* [1.x.176]
* 这个模拟有近20亿个未知数
* 
这个模拟有将近20亿个未知数 * --确实是一个相当大的计算，但每个时间步长仍然只需要大约1.5秒。
* 

* [1.x.177][1.x.178]
* 

* 这里介绍的代码可以直接扩展到自适应网格，给定适当的指标来设置细化标志。[1.x.179]已经实现了声波方程背景下类似求解器的大规模apaptivity。然而，在目前的情况下，适应性的好处往往仅限于靠近声波起源的早期时间和效果，因为波最终会反射和衍射。这就导致了到处都是陡峭的梯度，类似于湍流，以及或多或少的全球精炼的网格。
* 另一个我们在结果部分没有讨论的主题是不同时间积分方案的比较。该程序提供了四种流动存储Runga--Kutta积分器的变体，每一种都有轻微不同的精度和稳定性行为。在这里实现的方案中，高阶方案提供了额外的精度，但在违反CFL条件之前，每级的步长效率略低。一个有趣的扩展是将这里提出的低存储变量与标准的Runge--Kutta积分器进行比较，或者使用与质量矩阵运算分开运行的矢量运算并比较性能。
* 

*[1.x.180][1.x.181]
* 

* 正如介绍中所提到的，本程序中所采用的修正的Lax--Friedrichs通量和HLL通量只是欧拉方程文献中大量数值通量中的两种变体。一个例子是HLLC通量（Harten-Lax-van Leer-Contact）通量，它增加了HLL通量中缺少的稀疏波的影响，或Roe通量。正如介绍中所提到的，数值通量对高阶危险系数模型的影响是值得商榷的（与低阶离散化的情况不同）。
* 为了提高求解器的稳定性，一个相关的改进是也要考虑空间积分项。上面使用的相当天真的实现方式的一个缺点是，原欧拉方程的能量守恒（在没有冲击的情况下）仅能维持到离散化误差。如果解决方案的分辨率不足，离散化误差会引起数值能量的增加，最终导致离散化的不稳定。这是因为欧拉方程中的项的不精确的数值积分，其中包含有理非线性和来自弯曲单元的高阶内容。摆脱这一困境的方法是所谓的倾斜对称公式，见[2.x.354]的简单变体。倾斜对称意味着在弱式中切换解[2.x.355]和检验函数[2.x.356]的作用，除了一些边界项外，产生原始量的精确负值。在离散设置中，挑战在于当积分只被近似计算时也要保持这种偏斜对称性（在连续情况下，偏斜对称性是部分积分的结果）。偏斜对称的数值方案平衡了保守形式的空间导数[2.x.357]和对某些[2.x.358]的对偶形式的贡献。准确的条款取决于方程和积分公式，在某些情况下，可以通过特殊的倾斜对称有限差分方案来理解。
* 要想开始，有兴趣的读者可以看看https://github.com/kronbichler/advection_miniapp，在那里用deal.II对一个简单的平流方程实现了歪斜对称DG公式。
* [1.x.182][1.x.183] 。
* 

* 正如介绍中所提到的，随着马赫数的增加，欧拉方程的求解会产生冲击，这就需要额外的机制来稳定方案，例如以限制器的形式。除了实际实施限制器或人工粘性方法外，主要的挑战是如何平衡计算，因为限制有问题的单元的振荡所涉及的额外计算会使它们比没有限制的普通DG单元更昂贵。此外，更好地处理不连续的额外数值通量也是一种选择。
* 超音速流动的一个必要条件是适当的边界条件。与介绍中讨论的并在程序中实现的亚音速流出边界不同，超音速流出边界的所有特征都是外在的，所以我们不想规定任何外部数据，[1.x.184] 。
* 在代码中，我们将简单地添加额外的语句
* [1.x.185]
* 在`local_apply_boundary_face()`函数中。
* [1.x.186][1.x.187] 。
* 

* 当对欧拉解的兴趣主要在于声波的传播时，围绕背景状态，即一个给定的密度、速度和能量（或压力）场，将欧拉方程线性化，并只计算对这些场的变化，往往是有意义的。这就是航空声学的广泛领域的设定。即使有时对分辨率的要求大大降低，但由于线性化产生了额外的条款，实施起来也会更加复杂。从代码的角度来看，在算子评估中，我们还需要使代码具备线性化的状态。这一信息可以通过分析函数（根据正交点的位置进行评估）或通过类似于解决方案的矢量来提供。基于该向量，我们将创建一个额外的FEE评价对象，从它那里读取并提供正交点的场值。如果背景速度为零，密度为常数，线性化的欧拉方程就会进一步简化，可以等效地写成声波方程的形式。
* 在声音传播的背景下，一个挑战往往是边界条件的定义，因为计算域需要是有限的，而实际模拟往往跨越无限的（或至少是大得多的）物理域。传统的Dirichlet或Neumann边界条件会引起声波的反射，最终传播到感兴趣的区域，破坏了解决方案。因此，各种非反射边界条件或海绵层的变体，通常以[1.x.188]的形式出现。
* 
* - 在这里，溶液被阻尼而没有反射
* 
* - 是常见的。
* 

* [1.x.189][1.x.190]
* 

* 如[2.x.360]所述，本教程程序中提出的求解器也可以通过增加粘性项扩展到可压缩的Navier--Stokes方程。为了尽量保持这里获得的性能，尽管有额外的椭圆项的成本，例如通过内部罚款方法，我们可以像[2.x.361]教程程序中那样，将基础从FE_DGQ切换到FE_DGQHermite。
* 

* [1.x.191][1.x.192] 。
* 

* 在本教程中，我们使用了以面为中心的循环。在这里，单元和面的积分在不同的循环中处理，导致对结果向量的多次写入访问，这在现代硬件上是比较昂贵的，因为写入操作通常也会导致隐含的读操作。另一方面，以元素为中心的循环是处理一个单元并直接连续处理其所有的2D面。尽管这种循环意味着通量必须计算两次（对于一个内部面的每一面），但结果向量只需访问一次的事实可能是
* 
* - 而事实上，所产生的算法是没有竞赛条件的，因此完全适用于共享内存。
* 
* - 已经带来了性能上的提升。如果你对这些高级的话题感兴趣，你可以看看[2.x.362]，在那里我们对前面的教程进行了修改，以便我们可以使用这些功能。
* 

* [1.x.193][1.x.194] [2.x.363] 。
* [0.x.1]

