include/deal.II-translator/A-tutorial/step-15_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15 ][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30]
* [2.x.2] 
*[1.x.31] [2.x.3] 。
 

* [1.x.32][1.x.33][1.x.34] 。
* 

* [1.x.35][1.x.36] * [1.x.35][1.x.36]。
* 

* 本程序涉及一个非线性椭圆偏微分方程的例子，即[最小表面方程](https://en.wikipedia.org/wiki/Minimal_surface)。你可以想象这个方程的解描述一个肥皂膜所跨越的表面，这个肥皂膜被一个封闭的金属环所包围。我们想象一下，这根线不仅仅是一个平面的环，而且是弯曲的。肥皂膜的表面张力将使该表面变成最小表面。最小表面方程的解描述了这种形状，并以金属丝的垂直位移为边界条件。为了简单起见，我们在这里假设曲面可以写成图形[2.x.4]，尽管很明显，要构造出钢丝弯曲的情况并不难，因为在这种情况下，曲面只能局部地被构造成图形，而不是全局地。
* 因为这个方程是非线性的，我们不能直接解决它。相反，我们必须使用牛顿的方法来迭代计算解决方案。
* [2.x.5] ( [2.x.6] ) 
* 

* 
* [1.x.37][1.x.38] 。
* 

* 在经典的意义上，该问题以下列形式给出。
* 

*  
* [1.x.39]
* 
* [2.x.7]是我们通过将导线的位置投射到[2.x.8]空间得到的域。在这个例子中，我们选择[2.x.9]作为单位盘。
* 如上所述，我们用牛顿方法解决这个方程，我们从[2.x.11]个近似解中计算出[2.x.10]个近似解，并使用阻尼参数[2.x.12]来获得更好的全局收敛行为。
* [1.x.40]
* 用[1.x.41]和[2.x.13]的F的导数在[2.x.14]的方向：[1.x.42] 。
* 通过运动找出[2.x.15]是什么，我们发现我们必须在每一个牛顿步骤中解决一个线性椭圆PDE，[2.x.16]是以下的解。
* [1.x.43]
* 为了解决最小表面方程，我们必须重复解决这个方程，每个牛顿步骤一次。要解决这个问题，我们必须看一下这个问题的边界条件。假设[2.x.17]已经有了正确的边界值，那么牛顿更新[2.x.18]应该有零边界条件，以便在添加两者之后有正确的边界条件。 在第一个牛顿步骤中，我们从解[2.x.19]开始，牛顿更新仍然需要向解[2.x.20]提供正确的边界条件。
* 

* 总而言之，我们必须在第一步用边界条件[2.x.21]来解决上面的PDE，在接下来的所有步骤中用[2.x.22]来解决。
* [2.x.23] 在某种意义上，人们可能会说，如果程序已经实现了[2.x.24]，那么还必须实现[2.x.25]就是重复的。像往常一样，重复会诱发错误，我们希望能避免它。虽然我们没有在这个程序中探讨这个问题，但我们会在下面的[1.x.44]部分的末尾再来讨论这个问题，特别是在[2.x.26]中。
* 

* [1.x.45][1.x.46] 。
* 

* 从上面的强表述开始，我们通过用测试函数[2.x.27]乘以PDE的两边，并对两边进行部分积分，得到弱表述。 [1.x.47]这里的解[2.x.28]是[2.x.29]中的一个函数，受制于上面讨论的边界条件。把这个空间缩小到一个有基数[2.x.30]的有限维空间，我们可以写出这个解。
* [1.x.48]
* 使用基函数作为测试函数并定义[2.x.31]，我们可以重写弱的公式。
* [1.x.49]
* 其中解[2.x.32]是由系数[2.x.33]给出的。这个线性方程组可以改写为： * [1.x.50] 。
* [1.x.50]
* 其中矩阵[2.x.34]的条目由以下方式给出。
* [1.x.51]
* 右手边[2.x.35]由以下内容给出。
* [1.x.52]
 

* [1.x.53][1.x.54] 。
* 

* 与上述牛顿步骤相对应的矩阵可以重新表述，以更好地显示其结构。稍微改写一下，我们可以得到它的形式[1.x.55]，其中矩阵[2.x.36]（在[2.x.38]空间维度上大小为[2.x.37]）由以下表达式给出：[1.x.56 另一方面，[2.x.41]也是正定的，这使[2.x.42]具有相同的属性。这可以通过注意到向量[2.x.43]是[2.x.44]的特征向量，其特征值为[2.x.45]，而所有与[2.x.47]垂直的向量[2.x.46]和彼此都是特征向量，其特征值为[2.x.48]。因为所有的特征值都是正的，所以[2.x.49]是正定的，[2.x.50]也是。因此，我们可以使用CG方法来解决牛顿步骤。（矩阵[2.x.51]是对称和正定的这一事实不应该让人惊讶。它来自于对一个算子的导数，而这个算子又来自于对一个能量函数的导数：最小表面方程只是最小化了一些非二次元的能量。因此，作为标量能量的二阶导数矩阵，牛顿矩阵必须是对称的，因为与[2.x.52]th和[2.x.53]th自由度有关的导数显然应该相减。同样，如果能量函数是凸的，那么第二导数的矩阵必须是正定的，上面的直接计算只是重申了这一点。)
* 然而，值得注意的是，在[2.x.54]变大的问题中，正定性会退化。换句话说，如果我们简单地将所有边界值乘以2，那么一阶[2.x.55]和[2.x.56]也将被乘以2，但结果是[2.x.57]的最小特征值会变小，矩阵会变得更加不稳定。更具体地说，对于[2.x.58]，我们有[2.x.59]而[2.x.60]；因此，[2.x.61]的条件数，也就是[2.x.62]的条件数的一个乘法因子，会像[2.x.63]一样增长）。用目前的程序可以很简单地验证，将目前程序中使用的边界值乘以越来越大的数值，会导致问题最终无法用我们这里使用的简单预设条件的CG方法解决。
* 

*[1.x.57][1.x.58]
* 

* 如上所述，牛顿方法是通过计算一个方向[2.x.64]，然后以步长[2.x.66]执行更新[2.x.65]。一般来说，对于强非线性模型，如果我们总是选择[2.x.67]，牛顿方法就不会收敛，除非我们从足够接近非线性问题的解[2.x.69]的初始猜测[2.x.68]开始。在实践中，我们并不总是有这样的初始猜测，因此采取完整的牛顿步骤（即使用[2.x.70]）往往是不可行的。
* 因此，一个常见的策略是，当迭代[2.x.71]离解[2.x.72]还很远时，在前几步使用较小的步长，随着我们的接近，使用较大的[2.x.73]值，直到我们最终可以开始使用全步[2.x.74]，因为我们已经足够接近解。当然，问题是如何选择[2.x.75]。基本上有两种广泛使用的方法：线条搜索法和信任区域法。
* 在这个程序中，我们简单地选择步长等于0.1。这确保了在手头的测试案例中，我们确实得到了收敛，尽管很明显，由于没有最终恢复到全步长，我们放弃了使牛顿方法如此吸引人的快速、二次收敛。显然，如果这个程序是为了解决更多的现实问题，那么这一点最终是必须解决的。我们将在[1.x.59]中进一步评论这个问题，并在[2.x.76]中使用一个更好的方法。
* 

*[1.x.60][1.x.61]
* 

* 总的来说，我们这里的程序在许多方面与[2.x.77]并无不同。主类的布局本质上是相同的。另一方面，[2.x.78]函数中的驱动算法是不同的，工作方式如下。[2.x.79] [2.x.80] 从函数[2.x.81]开始，以这样的方式修改它，使[2.x.82]的值沿边界等于正确的边界值[2.x.83]（这发生在[2.x.84]）。设[2.x.85] . [2.x.86] 
* [2.x.87] 通过在[2.x.90]上解决带有边界条件[2.x.89]的系统[2.x.88]来计算牛顿更新。[2.x.91] 
* [2.x.92] 计算一个步长 [2.x.93] 。在这个程序中，我们总是设置 [2.x.94] 。为了便于以后的扩展，这发生在一个自己的函数中，即在 [2.x.95] 中。 (总是选择 [2.x.96] 的策略当然不是最优的)
* 
* - 我们应该选择一个适用于给定搜索方向的步长
* 
* - 但要做到这一点需要做一些工作。最后，我们把这类事情留给外部软件包。 [2.x.97]就是这样做的）。) [2.x.98] 
* [2.x.99] 解决方案的新近似值由 [2.x.100] 给出。[2.x.101] 
* [2.x.102] 如果[2.x.103]是5的倍数，那么细化网格，将解[2.x.104]转移到新的网格中，并设置[2.x.105]的值，以便沿边界有[2.x.106]（同样在[2.x.107]）。请注意，这并不是自动保证的，即使在网格细化之前我们就已经有了[2.x.108]，因为网格细化会在网格中增加新的节点，当我们把旧的解决方案带到新的网格时，必须把旧的解决方案插值到新的节点。我们通过插值选择的数值可能接近于精确的边界条件，但一般来说，并不是正确的数值。[2.x.109] 
* [2.x.110] 设置[2.x.111]并转到第二步。[2.x.112] [2.x.113]. 
* 我们解决的测试案例选择如下。我们寻求在单位盘[2.x.114]上找到最小曲面的解决方案，该曲面沿边界达到[2.x.115]的值。
* 

* [1.x.62] [1.x.63]。
* [1.x.64] [1.x.65]。
 

* 
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
* 

* 
* [1.x.66]
* 
* 我们将在牛顿迭代之间使用自适应网格细化。要做到这一点，我们需要能够在新的网格上使用解决方案，尽管它是在旧的网格上计算出来的。SolutionTransfer类将解决方案从旧网格转移到新网格。
* 

* 
*  

* 
* [1.x.67]
* 
* 然后我们为这个程序打开一个命名空间，并将dealii命名空间的所有内容导入其中，就像以前的程序一样。
* 

* 
* [1.x.68]
* 
* [1.x.69] [1.x.70].
 

* 
* 该类模板与 [2.x.116] 中的基本相同。 增加了三个内容。
* 

* 
* 
* - 有两个解决方案向量，一个用于牛顿更新 [2.x.117] ，另一个用于当前迭代 [2.x.118] 。
* 

* 
 
* - [2.x.119]函数需要一个参数，表示这是否是第一次被调用。不同的是，第一次我们需要分配自由度并将[2.x.120]的解向量设置为正确的大小。在接下来的时间里，这个函数是在我们已经完成了这些步骤，作为细化网格的一部分之后被调用的 [2.x.121] 。
* 

* 
* 
* - 然后我们还需要新的函数。 [2.x.122]负责正确设置解向量的边界值，这在介绍的最后已经讨论过了。 [2.x.123]是一个计算非线性（离散）残差准则的函数。我们用这个函数来监测牛顿迭代的收敛性。该函数以步长[2.x.124]为参数来计算[2.x.125]的残差。这是人们通常需要的步长控制，尽管我们在这里不会使用这个功能。最后，[2.x.126]计算每个牛顿迭代中的步长[2.x.127]。正如介绍中所讨论的，我们在这里使用一个固定的步长，并把实现一个更好的策略作为一个练习。( [2.x.128]的做法不同。它只是在整个求解过程中使用了一个外部软件包，而一个好的直线搜索策略是该软件包提供的一部分）。)
* 

* 
*  

* 
* [1.x.71]
* 
* [1.x.72] [1.x.73]。
 

* 
* 边界条件的实现就像在 [2.x.129] 中一样。 它被选择为 [2.x.130] 。
* 

* 
*  

* 
* [1.x.74]
* 
* [1.x.75] [1.x.76]。
 

* 
* [1.x.77] [1.x.78].
 

* 
* 该类的构造函数和析构函数与前几篇教程中的相同。
* 

* 
*  

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81]。
 

* 
* 在setup-system函数中，我们总是设置有限元方法的变量。与[2.x.131]有相同的区别，因为在那里我们在每个细化循环中都要从头开始求解PDE，而在这里我们需要把以前的网格的解放到当前的网格上。因此，我们不能只是重置解向量。因此，传递给这个函数的参数表明我们是否可以分布自由度（加上计算约束）并将解向量设置为零，或者这在其他地方已经发生过了（具体来说，在[2.x.132]）。
* 

* 
*  

* 
* [1.x.82]
 
* 该函数的其余部分与 [2.x.133] 中相同。
* 

* 
*  

* 
* [1.x.83]
 
* [1.x.84] [1.x.85]。
 

* 
* 这个函数的作用与前面的教程相同，当然，现在矩阵和右手边的函数取决于上一次迭代的解。正如介绍中所讨论的，我们需要使用牛顿更新的零边界值；我们在这个函数的结尾处计算它们。  
* 该函数的顶部包含通常的模板代码，设置允许我们在正交点评估形状函数的对象，以及本地矩阵和向量的临时存储位置，以及在正交点的上一个解的梯度。然后，我们开始在所有单元中进行循环。
* 

* 
* [1.x.86]
* 
* 对于线性系统的组装，我们必须在正交点上获得前一个解的梯度值。有一个标准的方法：[2.x.134]函数接收一个代表定义在DoFHandler上的有限元场的向量，并评估这个场在FEValues对象最后被重新初始化的单元的正交点的梯度。然后将所有正交点的梯度值写入第二个参数中。
* 

* 
* [1.x.87]
* 
* 有了这个，我们就可以对所有的正交点和形状函数进行积分循环。 在刚刚计算了正交点上旧解的梯度之后，我们就可以计算这些点上的系数[2.x.135]。 然后，系统本身的组装看起来与我们一贯的做法相似，除了非线性项之外，将结果从局部对象复制到全局对象中也是如此。
* 

* 
* [1.x.88]
* 
* 最后，我们从系统中移除挂起的节点，并对定义牛顿更新的线性系统应用零边界值 [2.x.136] 。
* 

* 
* [1.x.89]
* 
* [1.x.90] [1.x.91].
 

* 
* 求解函数和以往一样。在求解过程的最后，我们通过设置[2.x.137]来更新当前的解决方案。
* 

* 
* [1.x.92]
* 
* [1.x.93] [1.x.94] 。
 

* 
* 这个函数的第一部分与[2.x.138]中的内容相同 ... 然而，在细化网格之后，我们必须将旧的解决方案转移到新的解决方案中，这一点我们要借助SolutionTransfer类来完成。这个过程稍微有点复杂，所以让我们详细描述一下。
* 

* 
* [1.x.95]
 
* 然后我们需要一个额外的步骤：比如说，如果你标记了一个比它的邻居多精炼一次的单元，而这个邻居没有被标记为精炼，那么我们最终会在一个单元界面上跳出两个精炼级别。 为了避免这些情况，库将默默地也要对邻居单元进行一次细化。它通过在实际进行细化和粗化之前调用[2.x.139]函数来实现。 这个函数标志着一组额外的单元格进行细化或粗化，以执行像单悬节点规则这样的规则。 调用此函数后，被标记为细化和粗化的单元格正是那些将被实际细化或粗化的单元格。通常情况下，你不需要用手去做这件事[2.x.140]为你做这件事)。然而，我们需要初始化SolutionTransfer类，它需要知道最终将被粗化或细化的单元集，以便存储旧网格的数据并转移到新网格。因此，我们用手调用这个函数。
* 

* 
* [1.x.96]
* 
* 有了这个方法，我们用现在的DoFHandler初始化一个SolutionTransfer对象，并将解决方案向量附加到它上面，然后在新的网格上进行实际的细化和自由度的分配
* 

* 
* [1.x.97]
* 
* 最后，我们找回插值到新网格上的旧解。由于SolutionTransfer函数实际上并不存储旧的解决方案的值，而是索引，我们需要保留旧的解决方案向量，直到我们得到新的内插值。因此，我们将新的数值写入一个临时的向量中，之后才将其写入解决方案向量对象中。
* 

* 
* [1.x.98]
* 
* 在新的网格上，有不同的悬空节点，我们必须在丢弃对象的先前内容后，重新计算这些节点的约束。为了安全起见，我们还应该确保当前解决方案的向量条目满足悬挂节点的约束条件（关于为什么要这样做，请看SolutionTransfer类的文档讨论）。我们可以通过明确地调用`hanging_node_constraints.distribution(current_solution)`来做到这一点；我们省略这一步，因为这将在下面调用`set_boundary_values()`的最后发生，而且没有必要做两次。
* 

* 
* [1.x.99]
* 
* 一旦我们有了内插的解决方案和所有关于悬挂节点的信息，我们必须确保我们现在的[2.x.141]实际上具有正确的边界值。正如在介绍的最后所解释的那样，即使细化前的解具有正确的边界值，也不会自动出现这种情况，因此我们必须明确地确保它现在具有。
* 

* 
* [1.x.100]
* 
* 我们通过更新所有剩余的数据结构来结束这个函数，向[2.x.142]表明这不是第一次了，它需要保留解向量的内容。
* 

* 
* [1.x.101]
* 
* [1.x.102] [1.x.103]。
 

* 
* 下一个函数确保解向量的条目尊重我们问题的边界值。 在细化了网格之后（或者刚刚开始计算），边界上可能会出现新的节点。这些节点的数值是在`refine_mesh()`中从之前的网格中简单插值出来的，而不是正确的边界值。这一点可以通过将当前解决方案矢量的所有边界节点明确设置为正确的值来解决。  
* 但有一个问题我们必须注意：如果我们有一个悬挂的节点紧挨着一个新的边界节点，那么它的值也必须被调整以确保有限元场保持连续。这就是这个函数最后一行的调用所做的。
* 

* 
* [1.x.104]
* 
* [1.x.105] [1.x.106].
 

* 
* 为了监测收敛性，我们需要一种方法来计算（离散）残差的规范，即在介绍中讨论的向量[2.x.143]与[2.x.144]的规范。事实证明，（尽管我们在当前版本的程序中没有使用这个功能）在确定最佳步长时需要计算残差[2.x.145]，因此这就是我们在这里实现的：该函数将步长[2.x.146]作为一个参数。原有的功能当然是通过传递一个零作为参数来获得。  
* 在下面的函数中，我们首先为残差设置一个向量，然后为评估点设置一个向量 [2.x.147] 。接下来是我们用于所有积分操作的模板代码。
* 

* 
* [1.x.107]
 
* 实际的计算与[2.x.148]中的差不多。我们首先评估[2.x.149]在正交点的梯度，然后计算系数[2.x.150]，然后将其全部插入残差公式中。
* 

* 
* [1.x.108]
* 
* 在这个函数的最后，我们还必须处理悬挂节点的约束和边界值的问题。关于后者，我们必须将所有对应于位于边界的自由度的条目的残差向量元素设置为零。原因是，由于那里的解的值是固定的，它们当然不是 "真正的 "自由度，因此，严格来说，我们不应该在残差向量中为它们集合条目。然而，正如我们一直所做的那样，我们想在每个单元上做完全相同的事情，因此我们并不想在上面的积分中处理某个自由度是否位于边界的问题。相反，我们将简单地在事后将这些条目设置为零。为此，我们需要确定哪些自由度实际上属于边界，然后在所有这些自由度上进行循环，并将剩余条目设置为零。这发生在以下几行中，我们已经在[2.x.151]中看到了使用DoFTools命名空间的适当函数。
* 

* 
* [1.x.109]
* 
* 在函数的最后，我们返回残差的规范。
* 

* 
* [1.x.110]
* 
* [1.x.111] [1.x.112]。
 

* 
* 正如介绍中所讨论的，如果我们总是采取全步，即计算[2.x.152]，牛顿方法经常不能收敛。相反，我们需要一个阻尼参数（步长） [2.x.153] 并设置 [2.x.154] 。这个函数就是用来计算 [2.x.155] 的。  
* 在这里，我们干脆总是返回0.1。这当然是一个次优的选择：理想情况下，人们希望的是，当我们越来越接近解决方案时，步长变为1，这样我们就可以享受牛顿方法的快速二次收敛。我们将在下面的结果部分讨论更好的策略，[2.x.156]也涉及这方面的内容。
* 

* 
* [1.x.113]
 
* [1.x.114] [1.x.115]。
 

* 
* 从`run()`调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与以前的教程中所使用的完全相同。
* 

* 
* [1.x.116]
* 
* [1.x.117] [1.x.118]。
 

* 
* 在运行函数中，我们建立第一个网格，然后有牛顿迭代的顶层逻辑。  
* 正如介绍中所描述的，领域是围绕原点的单位盘，其创建方式与[2.x.157]中所示相同。网格被全局细化了两次，后来又进行了几次自适应循环。  
* 在开始牛顿循环之前，我们还需要做一些设置工作。我们需要创建基本的数据结构，并确保第一个牛顿迭代已经有了正确的边界值，这在介绍中已经讨论过了。
* 

* 
* [1.x.119]
* 
* 牛顿迭代接下来开始。我们一直迭代到上一次迭代结束时计算的残差（准则）小于[2.x.158]，正如在 "do { ... } while "循环结束时检查的那样。} while "循环的末尾进行检查。因为我们没有一个合理的值来初始化这个变量，我们只是使用可以表示为 "双数 "的最大值。
* 

* 
* [1.x.120]
* 
* 在每个网格上，我们正好做五个牛顿步骤。我们在这里打印初始残差，然后在这个网格上开始迭代。        
* 在每一个牛顿步骤中，首先要计算系统矩阵和右手边，然后我们存储右手边的准则作为残差，以便在决定是否停止迭代时进行检查。然后我们求解线性系统（该函数也会更新[2.x.159]），并在这个牛顿步骤结束时输出残差的准则。        
* 在这个循环结束后，我们还以图形的形式输出当前网格上的解，并增加网格细化循环的计数器。
* 

* 
* [1.x.121]
* 
* [1.x.122] [1.x.123]
* 

* 
* 最后是主函数。这遵循了所有其他主函数的方案。
* 

* 
* [1.x.124]
* [1.x.125][1.x.126] 。
 

* 
* 该程序的输出看起来如下。
* [1.x.127]
* 
* 很明显，这个方案收敛了，即使不是非常快。我们将在下面讨论加速该方法的策略。
* 我们可以在每一组五次牛顿迭代之后，即在每一个我们对其进行近似的网格上，将解决方案可视化。这就产生了以下一组图像。
* [2.x.160] 
* 可以清楚地看到，每次细化后的解决方案都能使曲面最小化。解决方案收敛到一个想象中的肥皂泡，它位于一个像边界一样弯曲的线环内。同样可以看出，每次细化后的边界是如何被平滑的。在粗略的网格上，边界看起来并不像正弦，而网格越细越像。
* 网格主要是在边界附近被细化，在那里解的增减很强烈，而在域的内部被粗化，在那里没有什么有趣的事情发生，因为解没有什么变化。这里显示的是第九种解决方案和网格。
* [2.x.161] 
* 

* 
* [1.x.128][1.x.129][1.x.130] 。
* 

* 该程序显示了一个非线性静止问题的求解器的基本结构。然而，它的收敛速度并不特别快，原因很简单。
* 
* 该程序总是采取0.1的步长。这就排除了快速的二次收敛，而牛顿方法通常都是选择这种方法。
* 
* - 它没有将非线性迭代与网格细化迭代联系起来。
* 很明显，一个更好的程序必须解决这两点。我们将在下面讨论。
* 

* [1.x.131][1.x.132] 。
* 

* 牛顿方法有两个众所周知的特性。
* 
* - 它不可能从任意选择的起点收敛。相反，一个起点必须足够接近解决方案以保证收敛。然而，我们可以通过使用[1.x.133] 0< [2.x.162] 的阻尼迭代来扩大牛顿方法的收敛区域。
* 
* - 如果(i)步长选择为[2.x.163]，它表现出快速的二次收敛，并且(ii)事实上它在选择步长时确实收敛了。
* 这两个观察的结果是，一个成功的策略是在初始迭代中选择[2.x.164]，直到迭代足够接近，可以用全步长收敛，在这一点上，我们希望切换到[2.x.165] 。问题是如何以自动的方式选择[2.x.166]，以满足这些标准。
* 我们不想在这里回顾关于这个主题的文献，只是简单地提到有两种基本的方法来解决这个问题：回溯线搜索和信任区域方法。前者更广泛地用于部分微分方程，基本上做了以下工作。
* 
* - 计算一个搜索方向
* 
* - 看看[2.x.167]与[2.x.168]产生的残差是否比[2.x.169]单独产生的残差 "大大缩小"。
* 
* - 如果是，则取[2.x.170]。
* 
* - 如果不是，试试用[2.x.171]的残余量是否 "大大减少"。
* 
* - 如果是，那么就采取[2.x.172] .
* 
* - 如果不是，试试用[2.x.173]是否 "大大缩小 "了残差。
* 
* - 等等。当然，我们可以选择其他因素[2.x.174]，而不是上面选择的[2.x.175]，为[2.x.176] 。很明显，"回溯 "一词的来源是：我们尝试一个长的步骤，但如果这不起作用，我们就尝试一个更短的步骤，而且是越来越短的步骤，等等。函数[2.x.177]的编写方式正是为了支持这种使用情况。
* 我们是否接受一个特定的步长[2.x.178]，取决于我们如何定义 "相当小"。有许多方法可以做到这一点，但在不详细说明的情况下，我们只需提到最常见的方法是使用沃尔夫和阿米约-戈尔德斯坦条件。对于这些，我们可以证明以下几点。
* 
* - 总有一个步长[2.x.179]可以满足条件，也就是说，只要问题是凸的，迭代就不会被卡住。
* 
* - 如果我们足够接近解决方案，那么条件允许[2.x.180]，从而实现二次收敛。
* 我们在此不再赘述，而是将这种算法的实现作为一个练习。然而，我们注意到，如果实施正确，那么通常可以看到，大多数合理的非线性问题可以在5到15次牛顿迭代中解决，达到工程精度&mdash；比我们目前版本的程序所需要的要少得多。
* 关于全球化方法的更多细节，包括回溯，可以在 [2.x.181] 和 [2.x.182] 中找到。
* 然而，非常值得一提的是，在实践中，高效非线性求解器的实现与高效有限元方法的实现一样复杂。我们不应该试图通过自己实现所有的必要步骤来重新发明车轮。在[2.x.183]函数中已经有了大量的拼图，可以用来实现这个目的。但是，相反，就像在deal.II这样的库中构建有限元求解器一样，我们应该在[SUNDIALS](https://computing.llnl.gov/projects/sundials)这样的库中构建非线性求解器。事实上，deal.II有与SUNDIALS的接口，特别是通过[2.x.184]类与它的非线性求解器子包KINSOL的接口。将目前的问题建立在该接口上并不困难。
* 
* - 事实上，这就是[2.x.185]的作用。
* 

* 
* [1.x.134][1.x.135] 。
* 

* 我们目前对每个网格正好做了5次迭代。但这是最优的吗？我们可以提出以下问题。
* 
* - 也许在初始网格上做更多的迭代是值得的，因为那里的计算很便宜。
* 
* - 另一方面，我们不希望在每个网格上做太多的迭代：是的，我们可以在每个网格上把残差赶到零，但这只意味着非线性迭代误差远远小于离散化误差。
* 
* - 我们应该用更高还是更低的精度来解决每个牛顿步骤中的线性系统？
* 归根结底，这归结为我们需要将当前网格上的离散化误差与我们希望在特定网格上通过牛顿迭代实现的非线性残差，以及我们希望在每个牛顿迭代中通过CG方法实现的线性迭代联系起来。
* 如何做到这一点，也不是完全微不足道的，我们再次把它作为一个未来的练习。
* 

* 
* [1.x.136][1.x.137] 。
* 

* 正如在介绍中所概述的，当解决形式为[1.x.138]的非线性问题时，我们使用牛顿迭代，要求我们反复解决线性偏微分方程 
* [1.x.139]
* 这样我们就可以计算出更新 
* [1.x.140]
*与牛顿步骤的解决方案[2.x.186]。对于这里的问题，我们可以用手计算导数[2.x.187]，并得到[1.x.141]，但这已经是一个相当大的表达式，无论是操作还是实现都很麻烦。在某种意义上，它也是重复的。如果我们在代码的某个地方实现了[2.x.188]，那么[2.x.189]就不是一个独立的信息，而是，至少在原则上，计算机应该能够自己推断出来的东西了。也就是说，如果我们只需要实现[2.x.190]，而[2.x.191]是以某种方式隐含地完成的，那不是很好吗？这实际上是可能的，并以 "自动区分 "的名义运行。 [2.x.192]概括地讨论了这个概念，[2.x.193]说明了如何在实践中应用这个概念来解决我们在这里考虑的问题。
* 

* [1.x.142][1.x.143] [2.x.194] 。
* [0.x.1]

