include/deal.II-translator/A-tutorial/step-12b_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12]
*[1.x.13][1.x.14][1.x.15] 。


* 这是[2.x.4]的一个变体，唯一的变化是我们使用了MeshWorker框架和预制的LocalIntegrator辅助类，而不是使用FEInterfaceValues来组装面的术语。
* 这个框架在实践中如何使用的细节将作为本教程程序的一部分加以解释。
*[1.x.16][1.x.17]
*

* 我们在这里解决的问题与 [2.x.5] 中的问题相同。
*

* [1.x.18] [1.x.19]。
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
*


* [1.x.20]
*
* 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过
*
* - 正如你在以前的教程程序中所看到的那样
*
* - 用户与有限元类的交互并不多：它们被传递给[2.x.6]和[2.x.7]对象，仅此而已。
*


* [1.x.21]

* 我们将使用最简单的求解器，称为Richardson迭代，它表示简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。
*


* [1.x.22]
*
* 我们将使用梯度作为细化指标。
*


* [1.x.23]
*
* 这里有新的包含文件，用于使用MeshWorker框架。第一个包含类[2.x.8]，它为局部积分器提供了局部和全局自由度之间的映射。在第二个文件中，我们发现一个类型为[2.x.10]的对象，它主要是对一组FEValues对象的封装。文件<tt>meshworker/simple.h</tt>包含了将局部集成数据组装成只包含一个矩阵的全局系统的类。最后，我们将需要在所有的网格单元和面上运行循环的文件。
*


* [1.x.24]
*
* 就像所有的程序一样，我们在完成这一部分时要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不加前缀。
*


* [1.x.25]
*
* [1.x.26] [1.x.27].
* 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。
*


* [1.x.28]
*
* 鉴于流动方向，单位方格[2.x.11]的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右侧边界上规定了值0。该函数在流出边界上的值将不会在DG方案内使用。
*


* [1.x.29]
*
* 最后，一个计算并返回风场的函数 [2.x.12] 。正如介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置[2.x.13]分量（即为零），而该函数在目前的实现中不能用于1D。
*


* [1.x.30]
*
* [1.x.31] [1.x.32].
* 在这个准备工作之后，我们继续进行本程序的主类，称为AdvectionProblem。它基本上是 [2.x.14] 的主类。我们没有AffineConstraints对象，因为在DG离散中没有悬挂节点约束。
*

*
* 主要的区别只出现在集合函数的实现上，因为在这里，我们不仅需要覆盖面上的通量积分，我们还使用MeshWorker接口来简化涉及的循环。
*


* [1.x.33]
*
* 此外，我们想使用1度的DG元素（但这只在构造函数中指定）。如果你想使用不同度数的DG方法，整个程序保持不变，只需在构造函数中用所需的多项式度数替换1。
*


* [1.x.34]

* 接下来的四个成员代表要解决的线性系统。  [2.x.15]是由[2.x.16]产生的，在[2.x.17]中计算，用于确定[2.x.18]中非零元素的位置。
*


* [1.x.35]
*
* 最后，我们必须提供集合单元格、边界和内表面条款的函数。在MeshWorker框架中，所有单元的循环和大部分操作的设置都将在这个类之外完成，所以我们所要提供的只是这三个操作。他们将在中间对象上工作，首先，我们在这里定义了交给本地整合函数的信息对象的别名，以使我们的生活更轻松。
*


* [1.x.36]
*
* 下面的三个函数是在所有单元和面的通用循环中被调用的。它们是进行实际积分的函数。     
* 在我们下面的代码中，这些函数并不访问当前类的成员变量，所以我们可以将它们标记为[2.x.19]，并简单地将这些函数的指针传递给MeshWorker框架。然而，如果这些函数想要访问成员变量（或者需要超出下面指定的参数），我们可以使用lambda函数的设施来为MeshWorker框架提供对象，这些对象就像拥有所需的参数数量和类型，但实际上已经绑定了其他参数。
*


* [1.x.37]
*
* 我们从构造函数开始。[2.x.20]的构造器调用中的1是多项式的度数。
*


* [1.x.38]
*
* 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。
*


* [1.x.39]
*
* 我们从生成稀疏性模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到[2.x.21]，可以被丢弃。
*

*
* 为了建立DG离散化的稀疏模式，我们可以调用类似于[2.x.22]的函数，它被称为[2.x.23]。
*


* [1.x.40]

* 最后，我们设置了线性系统的所有组成部分的结构。
*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是将这一切交给MeshWorker框架。为了做到这一点，我们只需要定义局部的集成函数，并使用命名空间[2.x.24]中的一个类来构建全局系统。
*


* [1.x.44]
*
* 这是一个神奇的对象，它知道关于数据结构和局部集成的一切。  这是一个在函数[2.x.25]中做工作的对象，它被下面的[2.x.26]隐含地调用。在我们提供指针的函数完成局部积分后，[2.x.27]对象将这些分布到全局稀疏矩阵和右手边的向量中。
*


* [1.x.45]
*
* 首先，我们初始化正交公式和工作者基类中的更新标志。对于正交，我们采取安全策略，使用QGauss公式，其点数比使用的多项式度数高一个。由于单元格、边界和内部面的正交率可以独立选择，所以我们必须把这个值交给三次。
*


* [1.x.46]
*
* 这些是我们在整合系统时需要的数值类型。它们被添加到用于单元格、边界和内部面以及内部邻居面的标志中，这是由四个[2.x.28]值强制的。
*


* [1.x.47]
*
* 在准备好<tt>info_box</tt>中的所有数据后，我们初始化其中的FEValues对象。
*


* [1.x.48]
*
* 到目前为止创建的对象帮助我们在每个单元和面做局部的整合。现在，我们需要一个对象来接收整合后的（本地）数据，并把它们转发给装配程序。
*


* [1.x.49]
*
* 现在，我们必须创建汇编对象，并告诉它，把本地数据放在哪里。这些将是我们的系统矩阵和右手边的数据。
*


* [1.x.50]
*
* 最后，在所有活动单元上进行积分循环（由第一个参数决定，它是一个活动迭代器）。     
* 正如在类声明中声明局部积分函数时的讨论中所指出的，集合积分器类所期望的参数实际上不是函数指针。相反，它们是可以像函数一样被调用的对象，有一定数量的参数。因此，我们也可以在这里传递具有适当的operator()实现的对象，或者如果本地集成器是，例如，非静态成员函数，则可以传递lambda函数。
*


* [1.x.51]
*
* [1.x.52] [1.x.53]。


*
* 这些是给上面所说的[2.x.29]的函数。它们计算单元格和面对系统矩阵和右手边的局部贡献。
*


* [1.x.54]
*
* 首先，让我们从[2.x.30]中检索这里使用的一些对象。注意，这些对象可以处理更复杂的结构，因此这里的访问看起来比看起来更复杂。
*


* [1.x.55]
*
* 有了这些对象，我们像往常一样继续进行局部积分。首先，我们在正交点上循环，计算当前点的平流矢量。
*


* [1.x.56]
*
* 我们解决的是一个同质方程，因此在单元项中没有显示出右手。  剩下的就是整合矩阵条目。
*


* [1.x.57]
*
* 现在对边界项也是如此。注意，现在我们使用FEValuesBase，即FEFaceValues和FESubfaceValues的基类，以便获得法向量。
*


* [1.x.58]

* 最后，内部面的条款。这里的区别是，我们收到两个信息对象，每个与面相邻的单元都有一个，我们组装了四个矩阵，每个单元一个，两个用于来回耦合。
*


* [1.x.59]
*
* 对于正交点、权重等，我们使用第一个参数的FEValuesBase对象。
*


* [1.x.60]
*
* 对于额外的形状函数，我们必须询问邻居FEValuesBase。
*


* [1.x.61]

* 然后我们得到对四个局部矩阵的引用。字母u和v分别指的是试验和测试函数。%的数字表示由info1和info2提供的单元。按照惯例，每个信息对象中的两个矩阵指的是各自单元上的试验函数。第一个矩阵包含该单元的内部耦合，而第二个矩阵包含单元之间的耦合。
*


* [1.x.62]
*
* 这里，按照前面的函数，我们会有局部的右手边向量。幸运的是，界面条款只涉及解决方案，右手边没有收到任何贡献。
*


*


* [1.x.63]
*
* 这个词我们已经看过了。
*


* [1.x.64]
*
* 我们另外组装了[2.x.31]这个术语。
*


* [1.x.65]

* 这个我们也已经看过了。
*


* [1.x.66]

* 而这是另一个新的。  [2.x.32] :
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。
* 对于这个简单的问题，我们使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预调节器相结合，该预调节器使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状高斯-赛德尔预处理（见PreconditionBlockSOR类，放松=1）会做得更好。
*


* [1.x.70]
*
* 这里我们创建了预处理程序。
*


* [1.x.71]
*
* 然后将矩阵分配给它，并设置正确的块大小。
*


* [1.x.72]
*
* 在这些准备工作之后，我们就可以启动线性求解器了。
*


* [1.x.73]
*
* 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由[2.x.33]类完成的，它计算近似梯度的方式类似于本教程[2.x.35]中描述的[2.x.34]。事实上，[2.x.36]类是在[2.x.38]的[2.x.37]类之后开发的。与 [2.x.39] 中的讨论相关，这里我们考虑 [2.x.40] 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在[2.x.41]中，而只在[2.x.42]中（或者，更准确地说：在[2.x.43]中，即在方向[2.x.44]中的导数是可平方整除的函数空间）。
*


* [1.x.74]
*
* [2.x.45]类将梯度计算为浮点精度。这就足够了，因为它们是近似的，只作为细化的指标。
*


* [1.x.75]
*
* 现在计算出了近似的梯度
*


* [1.x.76]
*
*并且它们被单元格按系数[2.x.46]进行缩放。
*


* [1.x.77]
*
* 最后他们作为细化指标。
*


* [1.x.78]
*
* 该程序的输出包括自适应细化网格的eps文件和gnuplot格式的数值解。
*


* [1.x.79]

* 首先将网格写成eps格式。
*


* [1.x.80]

* 然后以gnuplot格式输出解决方案。
*


* [1.x.81]

* 下面的[2.x.47]函数与之前的例子类似。
*


* [1.x.82]

* 下面的[2.x.48]函数与之前的例子也类似，不需要注释。
*


* [1.x.83]
*[1.x.84][1.x.85]


*
* 这个程序的输出与[2.x.49]非常相似，我们在此不重复输出。
* 我们展示了在初始网格上的解决方案，经过两个和五个自适应细化步骤后的网格。
* [2.x.50] [2.x.51] [2.x.52].
*

* 然后我们再次展示最终的网格（经过5个细化步骤）和解决方案，这一次有一个更好的三维渲染（使用[2.x.53]函数和基于VTK的VisIt可视化程序获得），更好地显示了细化网格上跳跃的清晰度和解决方案沿界面的过冲和欠冲现象。
* [2.x.54] [2.x.55]
*

* 最后我们展示一个3D计算的图。
* [2.x.56]
*

*[1.x.86][1.x.87][1.x.88]


* 关于进一步扩展的想法，请参见见 [2.x.57] 。
*

* [1.x.89][1.x.90] [2.x.58] 。
* [0.x.1]

