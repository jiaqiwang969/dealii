include/deal.II-translator/A-tutorial/step-52_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13 ][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25]
* [2.x.2] 
* [1.x.26]
* [2.x.3] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考[1.x.27]中关于如何做的说明。
* [1.x.28][1.x.29][1.x.30]
* 

* 这个程序展示了如何使用Runge-Kutta方法来解决一个与时间有关的问题。它解决了在[2.x.4]中首先讨论的热方程的一个小变化，但由于这个程序的目的只是演示使用更先进的方法与deal.II的时间步进算法相连接，所以只解决了一个均匀细化网格上的简单问题。
* 

* [1.x.31][1.x.32] 。
* 

* 在这个例子中，我们解决了中子输运方程的单组时间依赖的扩散近似（时间依赖的多组扩散见[2.x.5]）。这是一个关于中子如何在高散射介质中移动的模型，因此它是时间依赖性扩散方程的一个变体
* 
* 我们假设介质是不允许的，因此，中子通量满足以下方程：[1.x.33]。
*由适当的边界条件增强。这里，[2.x.7]是中子的速度（为简单起见，我们假设它等于1，这可以通过简单地缩放时间变量来实现），[2.x.8]是扩散系数，[2.x.9]是吸收截面，[2.x.10]是一个源。因为我们只对时间依赖性感兴趣，我们假设[2.x.11]和[2.x.12]是恒定的。
* 由于本程序只打算演示如何使用先进的时隙算法，我们将只寻找相对简单的问题的解决方案。具体来说，我们要在一个正方形域[2.x.13]上寻找解，其形式为[1.x.34] 。
* 通过使用二次有限元，我们可以在任何特定的时间精确地表示这个函数，所有的误差都是由于时间微分造成的。我们这样做是因为这样就很容易观察到我们将要考虑的各种时间步进方案的收敛顺序，而不需要将空间和时间误差分开。
* 我们施加了以下边界条件：[2.x.14]和[2.x.15]的同质Dirichlet条件，[2.x.16]和[2.x.17]的同质Neumann条件。我们选择源项，以便相应的解实际上是上述形式：[1.x.35] 。
* 因为解是时间上的正弦，我们知道精确的解满足[2.x.18].因此，时间[2.x.19]的误差只是数值解的规范，即[2.x.20]，而且特别容易评估。在代码中，我们评估[2.x.21]的节点值的规范，而不是相关空间函数的[2.x.23]规范，因为前者更容易计算；然而，在均匀网格上，两者只是由一个常数相关，我们可以因此观察时间收敛顺序，要么。
* 

*[1.x.36][1.x.37]
* 

* 在deal.II中实现的Runge-Kutta方法假设要解决的方程可以写成：[1.x.38] 。
* 另一方面，当使用有限元时，离散化的时间导数总是导致左手边存在一个质量矩阵。考虑到如果上式中的解向量[2.x.24]实际上是一个形式[1.x.39]的变量的节点系数向量[2.x.25]，这一点就很容易看出。
*与空间形状函数[2.x.26]，然后将形式为[1.x.40]的方程乘以测试函数。
*用测试函数，对[2.x.27]进行积分，代入[2.x.28]并将测试函数限制在上面的[2.x.29]，那么这个空间离散化方程的形式为[1.x.41] 。
*其中[2.x.30]是质量矩阵，[2.x.31]是[2.x.32]的空间离散化版本（其中[2.x.33]通常是空间衍生物出现的地方，但鉴于我们只考虑时间衍生物，这一点目前还不太关心）。换句话说，如果我们写成[1.x.42]，这种形式符合上述的一般方案。
* 
* Runk-Kutta方法是一种时间步进方案，通过特定的一步法对[2.x.34]进行近似。它们通常被写成[1.x.43]的形式。
* 其中对于上面的右手边的形式[1.x.44]。
* 这里[2.x.35]、[2.x.36]和[2.x.37]是已知的系数，用于识别你要使用的特定Runge-Kutta方案，而[2.x.38]是使用的时间步长。Runge-Kutta类的不同时间步长方法在级数[2.x.39]和系数[2.x.40]、[2.x.41]和[2.x.42]上有所不同，但由于可以查找这些系数的列表值，所以很容易实现。这些表格通常被称为Butcher tableaus）。
* 在编写本教程时，deal.II中实现的方法可以分为三类。[2.x.43] [2.x.44] 显式Runge-Kutta；为了使一个方法成为显式，必须在上述定义[2.x.45]的公式中，[2.x.46]不出现在右手边上。换句话说，这些方法必须满足[2.x.47] 。[2.x.48] 嵌入式（或自适应）Runge-Kutta；我们将在下面讨论其特性。[2.x.49] 隐式Runge-Kutta；这类方法需要解决上述阶段[2.x.50]的可能非线性系统，即它们至少有[2.x.51]个阶段 [2.x.52] 。[2.x.53] 许多众所周知的时间步进方案，通常不与Runge或Kutta的名字联系在一起，事实上，它们也可以用这些类别来表达。它们通常代表了这些家族的最低阶成员。
* 

*[1.x.45][1.x.46]
* 

* 这些方法，只需要一个函数来评估[2.x.54]，但不需要（作为隐式方法）来解决涉及[2.x.55]的[2.x.56]的方程。与所有显式时间步长方法一样，当选择的时间步长过大时，它们会变得不稳定。
* 这类著名的方法包括正向欧拉、三阶Runge-Kutta和四阶Runge-Kutta（通常缩写为RK4）。
* 

* [1.x.47][1.x.48] 。
* 

* 这些方法同时使用低阶和高阶方法来估计误差，并决定是否需要缩短或增加时间步长。术语 "嵌入 "是指低阶方法不需要对函数进行额外的评估[2.x.57]，而是重复使用那些必须为高阶方法计算的数据。换句话说，它基本上是免费的，我们得到的误差估计是使用高阶方法的一个副产品。
* 这类方法包括Heun-Euler、Bogacki-Shampine、Dormand-Prince（Matlab中的ode45，通常缩写为RK45，表示这里使用的低阶和高阶方法分别为4阶和5阶Runge-Kutta方法）、Fehlberg和Cash-Karp。
* 在撰写本文时，只有嵌入式显式方法得到了实现。
* 

*[1.x.49][1.x.50]
* 

* 隐式方法要求在每个（子）时间步中解决[2.x.58]和[2.x.59]形式的（可能是非线性）系统。在内部，这是用牛顿式方法完成的，因此，它们要求用户提供能够评估[2.x.60]和[2.x.61]或等同于[2.x.62]的函数。
* 这个运算符的特殊形式是由于每个牛顿步骤都需要解决一个形式的方程。
* [1.x.51]
*对于某些（给定的）[2.x.63]。无论时间步长如何，隐式方法始终是稳定的，但过大的时间步长当然会影响解的[1.x.52]，即使数值解仍然是稳定和有界的。
* 这类方法包括后退欧拉法、隐式中点法、Crank-Nicolson法和两阶段SDIRK法（"单对角隐式Runge-Kutta "的简称，这个术语是用来表示定义时间步长方法的对角线元素[2.x.64]都是相等的；这个特性使得牛顿矩阵[2.x.65]可以在各阶段之间重复使用，因为[2.x.66]每次都相同）。
* 

*[1.x.53][1.x.54]。
* 

* 通过将我们的模型问题的解决方案扩展为总是使用形状函数[2.x.67]并写出[1.x.55]。
* 我们立即得到扩散方程的空间离散化版本，即[1.x.56] 。
* 其中[1.x.57]为
* 参见[2.x.68]和[2.x.69]以了解我们是如何到达这里的。由于当前问题所选择的边界条件，边界项是不必要的。为了使用Runge-Kutta方法，我们将其改写如下：[1.x.58] 。
* 在代码中，我们将需要能够评估这个函数[2.x.70]及其导数，[1.x.59] 。
* 
* 

*[1.x.60][1.x.61]。
* 

* 为了简化问题，域是二维的，网格是均匀细化的（不需要调整网格，因为我们使用二次无限元，而且精确的解是二次的）。从一个二维域到一个三维域并不十分困难。然而，如果你打算解决更复杂的问题，其中网格必须进行调整（例如，在[2.x.71]中的做法），那么记住以下问题是很重要的。
* [2.x.72] [2.x.73] 当网格被改变时，你需要将解决方案投射到新的网格。当然，在每个时间步长中，所使用的网格应该是相同的，这个问题是由于Runge-Kutta方法在每个时间步长中对方程进行多次评估而产生的。[2.x.74] 每次改变网格时，你都需要更新质量矩阵和它的逆值。[2.x.75] 这些步骤的技术可以通过查看 [2.x.76] 随时获得。
* 

* [1.x.62] [1.x.63] 。
* [1.x.64][1.x.65] 。
 

* 
* 像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。
* 

* 
* [1.x.66]
* 
* 这是唯一一个新的包含文件：它包括所有的Runge-Kutta方法。
* 

* 
* [1.x.67]
 
* 下一步就像以前所有的教程程序一样。我们把所有的东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。
* 

* 
* [1.x.68]
* 
* [1.x.69] [1.x.70].
 

* 
* 下一块是主类的声明。这个类中的大多数函数并不新鲜，在以前的教程中已经解释过了。唯一有趣的函数是 [2.x.77] 和 [2.x.78] 评估扩散方程， [2.x.79] ，在给定时间和给定 [2.x.80] 。 [2.x.81] 在给定的时间和给定的[2.x.84]和[2.x.85]下，评估[2.x.82]或等同于[2.x.83] 。当使用隐式方法时，需要这个函数。
* 

* 
* [1.x.71]
* 
* 接下来的三个函数分别是显式方法、隐式方法和嵌入式显式方法的驱动。嵌入显式方法的驱动函数返回执行的步数，鉴于它只接受作为参数传递的时间步数作为提示，但内部计算了最佳时间步数本身。
* 

* 
* [1.x.72]
* 
* 我们选择二次有限元，我们初始化参数。
* 

* 
* [1.x.73]
* 
* [1.x.74] [1.x.75] 现在，我们创建约束矩阵和稀疏模式。然后，我们初始化这些矩阵和解决方案的向量。
* 

* 
* [1.x.76]
* 
* [1.x.77] [1.x.78] 在这个函数中，我们计算 [2.x.86] 和质量矩阵 [2.x.87] 。然后使用直接求解器对质量矩阵进行反演；然后[2.x.88]变量将存储质量矩阵的反值，这样[2.x.89]就可以使用该对象的[2.x.90]函数应用于一个矢量。在内部，UMFPACK并没有真正存储矩阵的逆，而是存储它的LU因子；应用逆矩阵就相当于用这两个因子做一次正解和一次逆解，这与应用矩阵的显式逆具有相同的复杂性）。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81].   
* 在这个函数中，计算出给定时间和给定点的方程的源项。
* 

* 
* [1.x.82]
* 
* [1.x.83] [1.x.84] 。  
* 接下来，我们在给定的时间[2.x.91]和给定的矢量[2.x.92]评估扩散方程的弱形式。换句话说，正如介绍中所述，我们评估 [2.x.93] 。为此，我们必须将矩阵[2.x.94]（之前计算并存储在变量[2.x.95]中）应用于[2.x.96]，然后添加源项，我们像通常那样进行积分。(如果你想节省几行代码，或者想利用并行积分的优势，可以用[2.x.97]来进行积分。) 然后将结果乘以[2.x.98] 。
* 

* 
* [1.x.85]
* 
* [1.x.86] [1.x.87] 。  
* 我们计算 [2.x.99] 。这要分几个步骤进行。
* 

* 
* 
* - 计算 [2.x.100] 。
* 

* 
* 
* - 反转矩阵，得到[2.x.101]。
* 

* 
* 
* - 计算[2.x.102]。
* 

* 
* 
* - 计算 [2.x.103] 。
* 

* 
* 
* - 返回z。
* 

* 
* [1.x.88]
 
* ［1.x.89］ ［1.x.90   
* 下面的函数会在vtu文件中输出由时间步长和时间步长方法名称索引的解。当然，所有的时间步长方法的（精确）结果应该是一样的，但这里的输出至少可以让我们对它们进行比较。
* 

* 
* [1.x.91]
* 
* [1.x.92] [1.x.93].   
* 这个函数是所有显式方法的驱动。在顶部，它初始化了时间步长和解决方案（通过将其设置为零，然后确保边界值和悬挂节点约束得到尊重；当然，对于我们在这里使用的网格，悬挂节点约束实际上并不是一个问题）。然后调用[2.x.104]，执行一个时间步骤。时间是通过一个DiscreteTime对象来存储和增加的。  
* 对于显式方法，[2.x.105]需要评估[2.x.106]，即，它需要[2.x.107]。因为[2.x.108]是一个成员函数，它需要被绑定到[2.x.109]。在每个进化步骤之后，我们再次应用正确的边界值和悬挂节点约束。  
* 最后，每隔10个时间步骤就会输出解决方案。
* 

* 
* [1.x.94]
 
* [1.x.95] [1.x.96] 这个函数等同于[2.x.110]，但是对于隐式方法。当使用隐式方法时，我们需要评估[2.x.111]和[2.x.112]，为此我们使用之前介绍的两个成员函数。
* 

* 
* [1.x.97]
* 
* [1.x.98] [1.x.99] 这个函数是嵌入式显式方法的驱动。它需要更多的参数。
* 

* 
* 
* - coarsen_param：当误差低于阈值时，乘以当前时间步长的系数。
* 

* 
* 
* - refine_param: 当误差高于阈值时，乘以当前时间步长的系数。
* 

* 
* 
* - min_delta: 可接受的最小的时间步长。
* 

* 
* 
* - max_delta: 可接受的最大时间步长。
* 

* 
* 
* - refine_tol: 完善时间步长的阈值。
* 

* 
* 
* - coarsen_tol：阈值，低于此阈值的时间步长将被粗化。  
* 嵌入式方法使用一个猜测的时间步长。如果使用这个时间步长的误差太大，时间步长将被缩小。如果误差低于阈值，则在下一个时间步长中会尝试更大的时间步长。 [2.x.113]是由嵌入方法产生的猜测时间步长。总之，时间步长有可能以三种方式修改。
* 

* 
* 
* - 在[2.x.114]内减少或增加时间步长 
* 

* 
* 
* - 使用计算出的 [2.x.115] 。
* 

* 
* 
* - 自动调整最后一个时间步骤的步长，以确保模拟在[2.x.116]处精确结束。这种调整是在DiscreteTime实例中处理的。
* 

* 
* [1.x.100]
* 
* [1.x.101] [1.x.102].   
* 以下是该程序的主要功能。在顶部，我们创建网格（一个[0,5]x[0,5]的正方形）并对其进行四次细化，得到一个有16乘16单元的网格，共256个。 然后我们将边界指示器设置为1，用于边界中[2.x.117]和[2.x.118]的部分。
* 

* 
* [1.x.103]
* 
* 接下来，我们设置线性系统并为其填充内容，以便在整个时间步进过程中使用它们。
* 

* 
* [1.x.104]
 
* 最后，我们使用命名空间TimeStepping中实现的几种Runge-Kutta方法来解决扩散问题，每次都在结束时输出误差。(正如介绍中所解释的，由于精确解在最后时间为零，所以误差等于数值解，只需取解向量的[2.x.119]准则就可以计算出来)。
* 

* 
* [1.x.105]
* 
* [1.x.106] [1.x.107]
 

* 
* 下面的[2.x.120]函数与前面的例子类似，不需要注释。
* 

* 
* [1.x.108]
* [1.x.109][1.x.110] 。
* 

* 这个程序的重点不在于显示特定的结果，而在于显示它是如何完成的。这一点我们已经通过讨论上面的代码证明过了。因此，该程序的输出相对较少，只包括控制台输出和以VTU格式给出的可视化的解决方案。
* 控制台输出包含错误和一些方法所执行的步骤数。
* [1.x.111]
* 
* 正如预期的那样，高阶方法给出了（更）准确的解决方案。我们还看到，（相当不准确的）Heun-Euler方法增加了时间步骤的数量，以满足公差。另一方面，其他嵌入式方法使用的时间步数比规定的要少得多。
* 

* [1.x.112][1.x.113] [2.x.121]。
* [0.x.1]

