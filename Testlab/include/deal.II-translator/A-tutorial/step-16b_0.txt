include/deal.II-translator/A-tutorial/step-16b_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17]
* [2.x.2]
* [1.x.18][1.x.19][1.x.20] 。


* 这是[2.x.3]的一个变体，唯一的变化是我们使用MeshWorker框架和预制的LocalIntegrator辅助类，而不是手动组装矩阵。
* 这个框架在实践中如何使用的细节将作为本教程程序的一部分来解释。
*[1.x.21][1.x.22]
*

* 我们在这里解决的问题与 [2.x.4] 中的问题相同。
*

* [1.x.23] [1.x.24]。
* [1.x.25][1.x.26] 。
*

*
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
*


* [1.x.27]
*
* 这些，现在，是多级方法所必需的包括。第一个声明了如何处理多网格方法中每一级的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更低的层次。
*

*
* 其余的包括文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学。
*


* [1.x.28]
*
* 最后我们包括MeshWorker框架。这个框架通过其函数loop()和integration_loop()，自动在单元格上进行循环，并将数据组装成向量、矩阵等。它自动服从约束。由于我们必须建立几个矩阵，并且必须注意几组约束，这将使我们省去很多麻烦。
*


* [1.x.29]
*
* 为了节省精力，我们使用了在以下文件中找到的预先实现的拉普拉斯。
*


* [1.x.30]
*
* 这就是C++。
*


* [1.x.31]
*
* [1.x.32] [1.x.33]。


*
* [2.x.5]希望有一个类能够提供在单元格和边界及内部面的积分功能。这是由下面的类来完成的。在构造函数中，我们告诉循环应该计算单元格积分（"真"），但不应该计算边界和内部面的积分（两个 "假"）。因此，我们只需要一个单元格函数，而不需要面的函数。
*


* [1.x.34]

* 接下来是每个单元上的实际积分器。我们解决一个泊松问题，在右半平面的系数为1，在左半平面的系数为十分之一。
*

*
* [2.x.6]的基类[2.x.7]包含了可以在这个局部集成器中填充的对象。在MeshWorker框架内，有多少对象被创建是由装配器类决定的。在这里，我们测试一下，比如说需要一个矩阵[2.x.8] 矩阵是通过[2.x.9]来访问的，它的第一个参数是矩阵的编号。第二个参数只用于对面的积分，当每个测试函数使用两个矩阵时。那么，第二个具有指标 "true "的矩阵将以相同的索引存在。
*

*
* [2.x.10]提供了一个或几个FEValues对象，下面这些对象被[2.x.11]或[2.x.12]使用，因为我们只组装一个PDE，所以这些对象中也只有一个索引为0。
*

*
*此外，我们注意到这个积分器的作用是计算多级预处理的矩阵，以及全局系统的矩阵和右手边。由于系统的汇编器需要一个额外的向量，[2.x.13]是返回一个非零值。相应地，我们在这个函数的结尾处填充了一个右手边的向量。由于LocalResults可以处理多个BlockVector对象，但我们在这里又是在最简单的情况下，我们将信息输入到零号向量的零块中。
*


* [1.x.35]
*
* [1.x.36] [1.x.37]。


*
* 这个主类与 [2.x.14] 中的类基本相同。就成员函数而言，唯一增加的是[2.x.15]函数，该函数组装了对应于中间层的离散运算符的矩阵。
*


* [1.x.38]
*
* 以下成员是多网格方法的基本数据结构。前两个表示稀疏模式和多级层次结构中各个层次上的矩阵，非常类似于上面的全局网格的对象。     
* 然后我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，如[2.x.16]"多网格论文 "中详细介绍的。     
* 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints类似，但在每个层次上。
*


* [1.x.39]
*
* [1.x.40] [1.x.41]。


*
* 关于三角结构的构造函数只有一个简短的评论：按照惯例，deal.II中所有自适应细化的三角结构在单元之间的面的变化不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在可能连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。
* [2.x.17]
* 这可以通过在三角化类的构造函数中传递[2.x.18]标志来实现。
*


* [1.x.42]
*
* [1.x.43] [1.x.44]。


*
* 除了只是在DoFHandler中分配自由度之外，我们在每一层都做同样的事情。然后，我们按照之前的程序在叶网中设置系统。
*


* [1.x.45]
*
* 多网格约束必须被初始化。他们也需要知道边界值，所以我们也在这里传递[2.x.19]。
*


* [1.x.46]
*
* 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏度模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是[2.x.20] 。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。
*


* [1.x.47]

* 现在，我们必须在每个层次上提供一个矩阵。为此，我们首先使用[2.x.21]函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，见[2.x.22]模块），然后把它复制到我们真正想要的那个层次上。下一步是用这些稀疏模式初始化两种层次矩阵。     
* 值得指出的是，界面矩阵只有位于较粗和较细的网格界面上的自由度的条目。因此，它们甚至比我们的多网格层次结构中的各个层次的矩阵还要稀疏。如果我们更关心内存的使用（可能还有我们与这些矩阵相乘的速度），我们应该对这两种矩阵使用不同的稀疏性模式。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* 下面的函数将线性系统装配在网格的最细层次上。由于我们想在下面的层次装配中重用这里的代码，我们使用局部积分器类LaplaceIntegrator，而将循环留给MeshWorker框架。因此，这个函数首先设置了这个框架所需的对象，即
*


*
* - 一个[2.x.23]对象，它将提供单元格上正交点的所有所需数据。这个对象可以看作是FEValues的扩展，提供更多的有用信息。
*


*
* - 一个[2.x.24]对象，它一方面扩展了单元格迭代器的功能，同时也为其基类LocalResults中的返回值提供了空间。
*


*
* - 一个汇编程序，在此为整个系统。这里的 "简单 "是指全局系统没有一个块状结构。
*


*
* - 本地集成器，实现了实际的形式。   
* 在循环将所有这些组合成一个矩阵和一个右手边之后，还有一件事要做：集合器将矩阵的行和列的受限自由度不做处理。因此，我们在对角线上放一个一，使整个系统摆好。1这个值或任何固定的值都有一个好处，那就是它对矩阵的频谱的影响很容易理解。由于相应的特征向量形成了一个不变的子空间，所选择的值不会影响Krylov空间求解器的收敛性。
*


* [1.x.51]
*
* [1.x.52] [1.x.53]。


*
* 下一个函数是建立线性算子（矩阵）的函数，该算子定义了每一层网格上的多重网格方法。积分的核心与上面的相同，但是下面的循环会遍历所有已存在的单元，而不仅仅是活动的单元，而且结果必须输入到正确的层次矩阵中。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数和之前的函数的区别只在于汇编器的设置和循环中不同的迭代器。另外，最后对矩阵的修复也是比较复杂的。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* 这是另外一个在支持多栅求解器（或者说，事实上，我们使用多栅方法的前提条件）方面有明显不同的函数。   
* 让我们首先建立多层次方法的两个组成部分：层次间的转移算子和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束条件和MGConstrainedDoFs对象，该对象知道各层的边界条件和不同细化层之间接口的自由度，可以从具有层自由度的DoFHandler对象建立这些转移操作的矩阵。   
* 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。
*


* [1.x.57]
*
* 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上进行平滑处理。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或求解器方法的少量迭代（如CG或GMRES）。[2.x.25]和MGSmootherPrecondition类提供了对这两种平滑器的支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。     
* 最后一步是用我们的水平矩阵初始化平滑器对象并设置一些平滑参数。[2.x.26]函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在目前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对[2.x.27]的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对[2.x.28]对象的构造函数调用中设置更多选项。     
* 最后一步的结果是我们使用SOR方法作为平滑器的事实
*
* - 这不是对称的
*
* - 但我们使用共轭梯度迭代（这需要一个对称的预处理程序）下面，我们需要让多级预处理程序确保我们得到一个对称的算子，即使是非对称的平滑器。
*


* [1.x.58]
*
* 下一个准备步骤是，我们必须将我们的水平矩阵和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法以后将使用转置算子进行后一种操作，允许我们用已经建立的矩阵初始化该算子的上下两个版本。
*


* [1.x.59]

* 现在，我们已经准备好设置V-循环算子和多级预处理。
*


* [1.x.60]
*
* 有了这些，我们终于可以用通常的方法来解决线性系统了。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。


*
* 以下两个函数在解决方案计算完成后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与[2.x.29]中的函数几乎没有变化，除了一个小的区别：我们以VTK格式生成输出，以使用今天更现代的可视化程序，而不是[2.x.30]编写时的那些。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 和上面的几个函数一样，这几乎是对[2.x.31]中相应函数的复制。唯一的区别是对[2.x.32]的调用，它负责形成我们在多网格方法中需要的每一级矩阵。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这又是与 [2.x.33] 中的函数相同。
*


* [1.x.70]
* [1.x.71][1.x.72] 。


* 如[2.x.34]，在最细的网格上，解决方案看起来像这样。
* [2.x.35]
* 与[2.x.36]相比，输出的格式略有不同，但功能相同，显示了相同的收敛特性：<pre> [2.x.37] 0DEAL:: 活动单元数：20DEAL:: 自由度数：25（通过级别：8，25） [2.x.38]值0.510691 [2.x.39] 步骤6值4.59193e-14 [2.x.40] 1DEAL:: 活动单元数：44DEAL:: 自由度数：55（通过级别：8，25，45） [2.x.41]值0.440678 [2.x.42] 第8步值1.99419e-13 [2.x.43] 2DEAL::活动单元数：86DEAL::自由度数：105（按级别：8、25、69、49） [2.x.44] 值0.371855 [2.x.45] 第9步值1.13984e-13 [2.x.46] 3DEAL:: 活动单元数：170DEAL:: 自由度数：200（按级别：8、25、77、174） [2.x.47] 值0.318967 [2.x.48] 第9步值2.62112e-13 [2.x.49] 4DEAL:: 活动单元数：332DEAL:: 自由度数：388（按级别：8, 25, 86, 231, 204） [2.x.50] 值0.276534 [2.x.51] 第10步值1.69562e-13 [2.x.52] 5DEAL:: 活动单元数: 632DEAL:: 自由度数: 714 (按级别: 8, 25, 89, 231, 514, 141) [2.x.53] 值 0.215300 [2.x.54] 步骤10值 6.47463e-13 [2.x.55] 6DEAL:: 活动单元数: 1202DEAL:: 自由度数: 1332 (按级别: 8, 25, 89, 282, 771, 435, 257) [2.x.56] 值 0.175848 [2.x.57] 步骤 10 值 1.80664e-13 [2.x.58] 7DEAL:: 活动单元数：2288DEAL:: 自由度数：2511（按级别：8，25，89，318，779，1420，829，30） [2.x.59] 值0.136724 [2.x.60] 第11步值9.73331e-14</pre>。
*

* [1.x.73][1.x.74] [2.x.61] 。
* [0.x.1]

