include/deal.II-translator/A-tutorial/step-12_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15]
* [2.x.2] 
* [1.x.16]
* [1.x.17][1.x.18][1.x.19] 。
* 

* [1.x.20][1.x.21] * [1.x.20][1.x.21]。
 

* 本例专门介绍了[2.x.3]不连续Galerkin方法[2.x.4]，简称为DG方法。它包括以下内容。2.x.5] [2.x.6] 用DG方法对线性平流方程进行离散化。  [2.x.7] 使用FEInterfaceValues组装跳跃项和单元间界面的其他表达。  [2.x.8] 使用[2.x.9] [2.x.10] 组合系统矩阵。
* 本程序特别关注的是DG方法的循环。这些问题特别复杂，主要是因为对于面的条款，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。[2.x.11]处理了单元和面的迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。脸部条款本身的整合，包括对自适应细化脸部的整合，是通过FEInterfaceValuesclass完成的。
* [1.x.22][1.x.23] 。
* 

* 本例中解决的模型问题是线性平流方程[1.x.24]，受域的边界[2.x.13]的流入部分的边界条件[1.x.25]的制约。 这里，[2.x.14]表示矢量场，[2.x.15]是（标量）解函数，[2.x.16]是边界值函数，[1.x.26]是域的边界流入部分，[2.x.17]表示边界[2.x.18]的单位外向法向。这个方程是本教程[2.x.19]中已经考虑的平流方程的保守版本。
* 

* 在每个单元[2.x.20]中，我们从左边乘以测试函数[2.x.21]，并通过部分积分得到：[1.x.27]当对所有单元[2.x.22]进行求和时，边界积分是在内部和外部面整体进行的，因此，有三种情况。[2.x.23] [2.x.24] 流入的外部边界（我们用给定的[2.x.26]替换[2.x.25]）。  [2.x.27] [2.x.28] 流出的外部边界。  [2.x.29] [2.x.30]内面（两边的积分变成了跳跃，我们使用上风速度）。  [2.x.31] [2.x.32]。
* 这里，跳跃定义为[2.x.33] ，其中上标指的是面的左（'+'）和右（'-'）值。上风值[2.x.34]被定义为[2.x.35]，如果[2.x.36]，否则为[2.x.37]。
* 因此，依赖网格的弱形式为：[1.x.28]这里，[2.x.38]是三角形的所有活动单元的集合，[2.x.39]是所有活动内部面的集合。这个公式被称为上风非连续Galerkin方法。
* 为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（另外两个项）。
* 

* 
*[1.x.29][1.x.30]
* 

* 我们在[2.x.41]上求解平流方程，[2.x.42]代表一个圆形的逆时针流场，[2.x.43]代表[2.x.44]，[2.x.45]代表[2.x.46] 。
* 我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解，并计算解的[2.x.47]准则。由于精确的解是0或1，我们可以用这个方法来衡量数值解的偏移量的大小。
* 

* [1.x.31] [1.x.32]。
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
* 

* 
* [1.x.33]
* 
* 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过
* 
* - 正如你在以前的教程程序中所看到的那样
* 
* - 用户与有限元类的交互并不多：它们被传递给[2.x.48]和[2.x.49]对象，仅此而已。
* 

* 
* [1.x.34]
* 
* FEInterfaceValues需要这个头来计算界面上的积分。
* 

* 
* [1.x.35]
* 
* 我们将使用最简单的求解器，称为Richardson迭代，它表示简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。
* 

* 
* [1.x.36]
* 
* 我们将使用梯度作为细化指标。
* 

* 
* [1.x.37]
* 
* 最后，新的包含文件用于使用MeshWorker框架中的Mesh_loop
* 

* 
* [1.x.38]
* 
* 就像所有的程序一样，我们在这一节结束时包括了所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不含前缀。
* 

* 
* [1.x.39]
* 
* [1.x.40] [1.x.41] 。  
* 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。
* 

* 
* [1.x.42]
* 
* 考虑到流动方向，单位方格[2.x.50]的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右边界上规定了值0。该函数在流出边界上的值将不会在DG方案内使用。
* 

* 
* [1.x.43]
 
* 最后，一个计算并返回风场的函数 [2.x.51] 。正如介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置[2.x.52]分量（即为零），而该函数在目前的实现中不能用于1D。
* 

* 
* [1.x.44]
* 
* [1.x.45] [1.x.46].   
* 以下对象是我们在调用[2.x.53]时使用的抓取和复制对象 新的对象是FEInterfaceValues对象，它的工作原理类似于FEValues或FEFacesValues，只是它作用于两个单元格之间的接口，并允许我们以我们的弱形式组装接口条款。
* 

* 
*  

* 
* [1.x.47]
* 
* [1.x.48] [1.x.49].   
* 在这个准备工作之后，我们继续进行这个程序的主类，称为AdvectionProblem。  
* 这一切对你来说应该是非常熟悉的。有趣的细节只有在实现集合函数的时候才会出现。
* 

* 
* [1.x.50]
* 
* 此外，我们要使用DG元素。
* 

* 
* [1.x.51]
* 
* 接下来的四个成员代表要解决的线性系统。 [2.x.54]是由[2.x.55]产生的，在[2.x.56]中计算，用于确定[2.x.57]中非零元素的位置。
* 

* 
* [1.x.52]
* 
* 我们从构造函数开始。[2.x.58]的构造器调用中的1是多项式的度数。
* 

* 
* [1.x.53]
* 
* 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。
* 

* 
* [1.x.54]
* 
* 我们从生成稀疏模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到[2.x.59]，可以被丢弃。
* 

* 
* 为了建立DG离散的稀疏模式，我们可以调用类似于[2.x.60]的函数，它被称为[2.x.61]。
* 

* 
* [1.x.55]
* 
* 最后，我们设置了线性系统的所有组成部分的结构。
* 

* 
* [1.x.56]
* 
* [1.x.57] [1.x.58]。
 

* 
* 这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是在调用[2.x.62]时包含逻辑，我们只需要指定在每个单元格、每个边界面和每个内部面应该发生什么。这三个任务是由下面的函数里面的lambda函数处理的。
* 

* 
*  

* 
* [1.x.59]
* 
* 这是每个单元格将被执行的函数。
* 

* 
* [1.x.60]
* 
* 我们解决的是一个同质方程，因此在单元格项中没有显示出右手。 剩下的就是整合矩阵条目。
* 

* 
* [1.x.61]
* 
* 这是为边界面调用的函数，包括使用FEFaceValues的正常积分。新的逻辑是决定该术语是进入系统矩阵（流出）还是进入右手边（流入）。
* 

* 
* [1.x.62]
* 
* 这是在内部面上调用的函数。参数指定了单元格、面和子面的指数（用于自适应细化）。我们只是将它们传递给FEInterfaceValues的reinit()函数。
* 

* 
* [1.x.63]
* 
* 下面的lambda函数将处理把数据从单元和面组件复制到全局矩阵和右手边。    
* 虽然我们不需要AffineConstraints对象，因为在DG离散中没有悬挂的节点约束，但我们在这里使用一个空对象，因为这允许我们使用其`copy_local_to_global`功能。
* 

* 
* [1.x.64]
* 
* 在这里，我们最后处理装配。我们传入ScratchData和CopyData对象，以及上面的lambda函数，并指定我们要对内部面进行一次装配。
* 

* 
* [1.x.65]
* 
* [1.x.66] [1.x.67]   
* 对于这个简单的问题，我们使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预调节器相结合，该预调节器使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状高斯-赛德尔预处理（见PreconditionBlockSOR类，放松=1）会做得更好。
* 

* 
* [1.x.68]
 
* 这里我们创建了预处理程序。
* 

* 
* [1.x.69]
* 
* 然后将矩阵分配给它，并设置正确的块大小。
 

* 
* [1.x.70]
* 
* 在这些准备工作之后，我们就可以启动线性求解器了。
* 

* 
* [1.x.71]
* 
* 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由[2.x.63]类完成的，它计算近似梯度的方式类似于本教程[2.x.65]中描述的[2.x.64]。事实上，[2.x.66]类是在[2.x.68]的[2.x.67]类之后开发的。与 [2.x.69] 中的讨论相关，这里我们考虑 [2.x.70] 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在[2.x.71]中，而只在[2.x.72]中（或者，更准确地说：在[2.x.73]中，即在方向[2.x.74]中的导数是可方整的函数空间）。
* 

* 
* [1.x.72]
* 
* [2.x.75]类计算梯度的精度为浮点。这就足够了，因为它们是近似的，只作为细化的指标。
* 

* 
* [1.x.73]
* 
* 现在，近似梯度被计算出来了
* 

* 
* [1.x.74]
* 
* 并且它们被单元格按系数[2.x.76]进行缩放。
 

* 
* [1.x.75]
* 
* 最后它们作为细化指标。
* 

* 
* [1.x.76]
* 
* 这个程序的输出包括一个自适应细化网格的vtk文件和数值解。最后，我们还用[2.x.77]计算了解的L-无穷大规范。
* 

* 
* [1.x.77]
* 
* 下面的[2.x.78]函数与之前的例子类似。
* 

* 
* [1.x.78]
* 
* 下面的[2.x.79]函数与以前的例子也类似，不需要注释。
* 

* 
* [1.x.79]
* [1.x.80][1.x.81] 。
* 

* 
* 这个程序的输出包括控制台输出和vtk格式的解决方案。
* [1.x.82]
* 
* 我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。
* [2.x.80] [2.x.81] [2.x.82]. 
* 最后我们展示一个三维计算的图。
* [2.x.83] 
* 

* [1.x.83][1.x.84][1.x.85] 。
 

* 在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的元素呢？当然，对于每一个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于传输方程来说是不稳定的，除非特别增加稳定项。然而，DG方法[1.x.86]则是稳定的。用目前的程序来说明这一点并不困难；事实上，只需要做以下一些小的修改就可以了。
* 
* 将元素改为FE_Q而不是FE_DGQ。
* 
* - 以与[2.x.84]完全相同的方式增加对悬挂节点约束的处理。
* 
* - 我们需要一个不同的求解器；[2.x.85]中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这个工作。
* 虽然上面显示了2d解，在界面上包含一些小尖峰，但是在网格细化下高度稳定，当使用连续元素时，结果看起来大不相同。
* [2.x.86] 
* 在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此，我们展示了一个范围为[2.x.87]的彩色图（当然，准确解的解值位于[2.x.88]）。在任何情况下，很明显，连续Galerkin解表现出振荡的行为，随着网格的细化越来越差。
* 如果人们出于某种原因想使用连续元素，有许多策略可以稳定cG方法。讨论这些方法超出了本教程的范围；例如，感兴趣的读者可以看一下[2.x.89]。
* 

* 
* [1.x.87][1.x.88][1.x.89] 。
* 

* 鉴于在这种情况下确切的解决方案是已知的，进一步扩展的一个有趣的途径是确认这个程序的收敛顺序。在目前的情况下，解是不光滑的，因此我们不能期望得到特别高的收敛阶数，即使我们使用更高阶元素。但是，即使解[1.x.90]是光滑的，该方程也不是椭圆的，因此并不清楚我们应该获得与最优插值估计相等的收敛阶数（例如，通过使用二次元，我们将获得[2.x.90]在[2.x.91]准则下的收敛）。
* 事实上，对于双曲方程，理论预测常常表明，最好的希望是比插值估计值低二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的替代方法），我们可以证明，对于度数为[2.x.92]的元素，在任意网格上的收敛顺序为[2.x.93]。虽然在均匀细化的网格上观察到的顺序经常是[2.x.94]，但我们可以构建所谓的Peterson网格，在这些网格上实际上达到了更差的理论约束。这应该是比较容易验证的，例如使用[2.x.95]函数。
* 一个不同的方向是观察运输问题的解决往往具有不连续性，因此我们[1.x.91]在每个坐标方向的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为[1.x.92]，是[2.x.96]的主题。
* 

* [1.x.93][1.x.94] [2.x.97] 。
* [0.x.1]

