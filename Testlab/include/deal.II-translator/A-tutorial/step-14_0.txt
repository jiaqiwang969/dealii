include/deal.II-translator/A-tutorial/step-14_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22 ][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43]
*[1.x.44][1.x.45][1.x.46] 。
* 

* [1.x.47][1.x.48]。
 

* Rolf Rannacher教授的海德堡小组，deal.II库的三位初始作者在他们的博士期间属于该小组，后来也有部分人属于该小组，自1990年代中期以来一直从事有限元离散化的适应性和误差估计。主要成就是开发了任意函数解的误差估计，以及用于其计算的最佳网格细化。
* 我们不会太详细地讨论这些概念的推导，但会在本例程序中实现主要的想法。对于一般概念的彻底介绍，我们可以参考Becker和Rannacher的开创性工作[2.x.2]，[2.x.3]，以及同一作者在Acta Numerica[2.x.4]上的概述文章；前者介绍了拉普拉斯方程一般函数输出的误差估计和适应性的概念，而后者给出了许多概念在大量其他更复杂方程上的应用实例。关于个别类型方程的应用，也可参见贝克尔[2.x.5]、[2.x.6]、坎沙特[2.x.7]、[2.x.8]、苏特梅尔[2.x.9]的出版物。 ] , [2.x.10] , [2.x.11] , [2.x.12] , Bangerth [2.x.13] , [2.x.14] , [2.x.15] , [2.x.16] , 和 Hartmann [2.x.17] , [2.x.18] , [2.x.19] 。所有这些工作，从Becker和Rannacher的原始介绍到对特定方程的个别贡献，后来都在Bangerth和Rannacher的书中进行了总结，其中包括所有这些主题，见[2.x.20]。
* 

* 其基本思想如下：在应用中，人们通常对解本身不感兴趣，而是对它的某些方面感兴趣。例如，在流动问题的模拟中，人们可能想知道浸在流体中的物体的升力或阻力；我们想知道的是这个量的最佳精度，而描述方程的其余解是否得到很好的解决并不是主要兴趣。同样，在弹性方面，人们可能想知道某些点的应力值，以猜测关节的最大负荷值是否安全，比如说。或者，在辐射转移问题中，平均通量强度是有意义的。
* 在刚才列举的所有情况中，我们感兴趣的是解的函数[2.x.21]的评估，而不是各地的[2.x.22]的值。由于精确的解决方案[2.x.23]是不可用的，只有它的数字近似值[2.x.24]，所以问计算值[2.x.25]是否在精确值[2.x.26]的一定范围内是明智的，也就是说，我们想约束关于这个函数的误差，[2.x.27]。
* 为了简化论述，我们假设感兴趣的量[2.x.28]以及方程都是线性的，我们将特别展示具有同质狄里奇边界条件的拉普拉斯方程的推导，尽管这一概念更为普遍。对于这种一般情况，我们参考上面列出的参考文献。 我们的目标是获得误差的界限，[2.x.29] 。为此，让我们用[2.x.30]表示对偶问题的解，定义如下：[1.x.49]其中[2.x.31]是与微分方程相关的双线性形式，测试函数从相应的解空间中选择。然后，作为特殊的检验函数[2.x.32]的误差，我们有[1.x.50]，通过Galerkin正交性，我们可以将其改写为[1.x.51]，其中[2.x.33]可以以我们认为方便的方式从离散检验空间选择。
* 具体来说，对于拉普拉斯方程，误差标识为[1.x.52]，因为我们不仅要用这个公式来计算误差，还要细化网格，所以我们需要将上面的表达式改写为单元的总和，然后每个单元的贡献可以作为这个单元的误差指标。因此，我们将标量积分成每个单元的条款，并对每个条款进行分项积分：[1.x.53] 。
* 接下来，我们利用[2.x.34]，对于拉普拉斯方程的解，其解足够平滑，[2.x.35]几乎到处都是连续的。
* 
* 因此，在单元格上涉及[2.x.36]的条款与相邻单元格上的条款相抵消，其中法向量具有相反的符号。(不过[2.x.37]的情况并非如此。)在域的边界，没有邻接单元可以抵消这个项，权重[2.x.38]可以选择为零，整个项就消失了。
* 因此，我们有[1.x.54]。
* 在最后一步，注意当取[2.x.39]的法向导数时，我们是指从单元格的这一边取的这个量的值（对于通常的拉格朗日元素，导数在边上不是连续的）。然后我们通过将[2.x.40]单元的一半边缘积分与相邻单元[2.x.41]交换来重写上述公式，得到[1.x.55] 。
* 对于相邻单元的法向量，我们有[2.x.42]，我们通过[1.x.56]定义法向导数的跳跃，并在将离散函数[2.x.43]（现在仍然是任意的）设定为对偶解的点插值后得到最终形式，[2.x.44] ：[1.x.57] 。
* 
* 这样，我们就得到了关于任意（线性）函数的有限元离散化误差的精确表示 [2.x.45] 。它的结构是一个加权形式的残差估计，因为[2.x.46]和[2.x.47]都是在精确解上消失的单元和边缘残差，而[2.x.48]是表示某个单元上的残差对给定函数的评估有多重要的权重。此外，它是一个单元的量，所以我们可以把它作为一个网格细化的标准。问题是：如何评价它？毕竟，评估需要了解对偶解[2.x.49]，它带有我们想知道的最准确的量的信息。
* 在一些非常特殊的情况下，这个对偶解是已知的。例如，如果函数[2.x.50]是点评价，[2.x.51]，那么对偶解必须满足[1.x.58]，右边是狄拉克三角函数，而对偶解是关于点[2.x.52]的格林函数。对于简单的几何形状，这个函数是分析上已知的，我们可以把它插入到误差表示公式中。
* 然而，我们不想把自己限制在这种特殊情况下。相反，我们将以数值方式计算对偶解，并以某种数值方式获得的[2.x.54]近似[2.x.53]。我们注意到，使用与初解[2.x.56]相同的方法来计算这个近似值[2.x.55]是不够的，因为这样[2.x.57]和整体误差估计将是零。相反，近似值[2.x.58]必须来自比原始有限元空间更大的空间。有多种方法可以获得这样的近似值（见所引用的文献），我们将选择用高阶有限元空间来计算它。虽然这当然不是最有效的方法，但它很简单，因为我们已经有了所有需要做的事情，而且它还允许进行简单的实验。对于更有效的方法，请再次参考给定的文献，特别是 [2.x.59] , [2.x.60] 。
* 至此，我们结束了对这个程序的数学方面的讨论，转而讨论实际的实现。
* 

* 
* [2.x.61] 如果你只关心计算误差，上面有两个步骤似乎没有必要：即(i)从[2.x.62]中减去[2.x.63]，和(ii)将积分拆成单元格之和并对每个单元格进行积分。事实上，这两个步骤根本没有改变[2.x.64]，因为在用[2.x.66]替换[2.x.65]之前，我们只考虑上面的相同点。换句话说，如果你只关心[1.x.59][2.x.67]，那么这些步骤是没有必要的。另一方面，如果你想将误差估计作为网格中每个单元的细化标准，那么就有必要(i)将估计值分解为单元的总和，(ii)以这样的方式按摩公式，使每个单元的贡献都与局部误差有关。(虽然上面的公式没有改变[1.x.60][2.x.68]的值，但它们改变了我们为每个单元[2.x.69]计算的值)。为此，我们希望以 "残差乘以双重权重 "的形式来写一切，其中 "残差 "是指随着近似度变得[2.x.70]越来越好而归于零的东西。例如，[2.x.71]这个量不是残差，因为它只是收敛于精确解的梯度（法向分量）。另一方面，[2.x.72]是一个残差，因为它收敛于[2.x.73] 。我们在开发[2.x.74]的最终形式时采取的所有步骤，实际上都是为了将最终形式变成一种形式，在离散解[2.x.75]收敛到[2.x.76]时，每个项都收敛为零。这样就可以把每个单元的贡献看作是一个 "误差指标"，也会收敛为零
* 
* - 因为它应该随着网格的细化而细化。
* 

* 
* [1.x.61][1.x.62] 。
* 

* [2.x.77] 示例程序在很大程度上建立在[2.x.78] 程序中已经使用的技术上。它对上面解释的双重加权残差估算器的实现是通过派生出第二个类，正确地称为[2.x.79]基类，并有一个类（[2.x.80]）再次连接这两个类，控制原始和双重问题的解决，然后使用两者来计算网格细化的误差指示器。
* 该程序延续了前面例子中的模块化概念，通过一个抽象的基类来实现对偶函数，描述兴趣量，并提供两个不同的函数来实现这个接口。因此，增加一个不同的兴趣量是很简单的。
* 一个更根本的区别是对数据的处理。一个常见的情况是，你开发了一个解决某个方程的程序，然后用不同的右手边、不同的域、不同的系数和边界值等来测试它。通常情况下，这些必须匹配，以便知道确切的解决方案，或者它们的组合是有意义的。
* 我们展示了一种可以通过简单而又非常灵活的方式来实现的方法。我们将把属于某个设置的所有东西放到一个类中，并围绕它提供一个小的C++砂浆，这样整个设置（域、系数、右手边等）就可以通过改变[2.x.81]中的某个[2.x.82]地方进行交换。
* 再往前走一点，我们还将所有描述程序如何工作的其他参数集中在一个地方，如有限元的顺序、最大自由度数、应在计算出的解上执行的评价对象，以及很快。这使得程序的配置更加简单，我们将在后面的程序中展示如何使用一个库类来处理通过读取输入文件来设置这些参数。总的来说，我们的目的是减少程序中想要改变某个参数时需要查找的地方，因为在实践中，人们会在程序的发展过程中忘记它们的位置。此外，把所有描述程序在某次运行中所做的事情的选项放到一个文件中（可以和结果一起存储），比在程序中的某个地方设置各种标志更有助于结果的重复性，因为在下次改变这个地方后，它们的确切数值就会被遗忘。
* 不幸的是，这个程序已经变得相当长了。虽然这无疑降低了它作为一个示例程序的作用，但我们认为它是开发其他类型问题程序的一个很好的起点，涉及到比这里处理的拉普拉斯方程不同的方程。此外，它显示了我们可以向你展示的关于我们的后验误差估计方法的一切，其结构应该使你能够简单地调整这种方法，以适应其他问题、其他函数、其他几何、系数等等。
* 作者认为，本程序是他在示例程序中的杰作，涉及到数学的复杂性，以及添加扩展的简单性。如果你使用这个程序作为你自己程序的基础，我们希望你能说明这一事实，并在由此产生的出版物中注明示例程序的作者Wolfgang Bangerth的名字，你的程序有相当一部分是由示例程序组成的。
* 

* [1.x.63] [1.x.64]。
* 从众所周知的事情开始......
* 

* 
* [1.x.65]
* 
* 最后一步和以前的所有程序一样。
* 

* 
* [1.x.66]
 
* [1.x.67] [1.x.68]。
 

* 
* 正如在介绍中提到的，该程序的重要部分只是从[2.x.83]的例子程序中拿过来的。因此，我们只对那些新的东西进行评论。  
* 首先，评估解决方案的框架没有改变，即基类是相同的，评估网格点上的解决方案的类也没有改变。
* 

* 
* [1.x.69]
* 
* [1.x.70] [1.x.71].
 

 
* [1.x.72]
* 
* [1.x.73] [1.x.74].
 

 
* [1.x.75]
* 
* [1.x.76] [1.x.77]。
 

* 
* 除了实现在一个点上求解的类之外，我们在这里提供一个在网格点上求梯度的类。由于一般情况下，有限元函数的梯度在一个顶点上是不连续的，所以我们在这里要稍微小心一点。我们要做的是在所有单元上循环，即使我们已经在一个单元上找到了这个点，并使用所有相邻单元上的顶点的梯度的平均值。    
* 鉴于[2.x.84]类的接口，这个类的声明没有提供什么惊喜，构造函数也没有。
* 

* 
* [1.x.78]
* 
* 更有趣的事情发生在进行实际评估的函数里面。
* 

* 
* [1.x.79]
* 
* 这一次用一些有用的东西来初始化返回值，因为我们要把一些贡献加起来，然后取平均值......
* 

* 
* [1.x.80]
* 
* ...然后有一些对象，其含义将在下面变得清晰...
 

 
* [1.x.81]
* 
* ...然后在所有单元格和它们的顶点上循环，并计算顶点被找到的频率。
* 

* 
* [1.x.82]
* 
* 现在事情不再那么简单了，因为我们不能像以前那样得到有限元场的梯度，我们只需要在一个顶点上挑选一个自由度。              
* 相反，我们必须评估这个单元上的有限元场，而且是在某一点。如你所知，在某一点上评估有限元场是通过[2.x.85]类完成的，所以我们使用该类。问题是：[2.x.86]对象需要给定一个正交公式，然后可以计算正交点的有限元量值。在这里，我们并不想做正交，我们只是想指定一些点!               
* 尽管如此，还是选择同样的方式：使用一个特殊的正交规则，点在顶点，因为这些是我们感兴趣的。适当的规则是梯形规则，所以这就是我们上面使用该规则的原因。              
*这样：在这个单元上初始化[2.x.87]对象。
* 

* 
* [1.x.83]
* 
* 并在顶点提取解矢量的梯度。
* 

* 
* [1.x.84]
* 
* 现在我们有了所有顶点的梯度，所以挑出属于评估点的那一个（注意顶点的顺序不一定和正交点的顺序一样）。
* 

* 
* [1.x.85]
* 
* 检查是否确实找到了评估点。
* 

* 
* [1.x.86]
* 
* 如果是这样，就把那里的梯度的X导数作为我们感兴趣的值，并增加计数器，表明我们向该变量添加了多少次。
 

* 
* [1.x.87]
* 
* 最后跳出最内层的循环，在当前单元的顶点上进行迭代，因为如果我们在一个顶点上找到了评估点，那么它就不可能在后面的顶点上。
* 

* 
* [1.x.88]
* 
* 现在我们已经循环了所有的单元和顶点，所以检查是否找到了这个点。
* 

* 
* [1.x.89]
* 
* 我们已经简单地将所有相邻单元的贡献相加，所以我们仍然要计算平均值。一旦完成，报告状态。
* 

* 
* [1.x.90]
* 
* [1.x.91] [1.x.92]。
 

* 
* 因为这个程序有一个更困难的结构（它除了计算一个原始解之外，还计算了一个对偶解），所以写出的解不再由一个评估对象来完成，因为我们想把两个解一次写进一个文件，这需要一些比评估类可用的信息。    
* 然而，我们也想看看生成的网格。这也可以通过一个这样的类来完成。它的结构类似于前面例子程序中的[2.x.88]类，所以我们在这里不做更详细的讨论。此外，这里所使用的一切都已经在以前的例子程序中使用过了。
* 

* 
* [1.x.93]
* 
* [1.x.94] [1.x.95]。
 

* 
* 接下来是实际的解算器类。同样，我们只讨论与之前程序的不同之处。
* 

* 
* [1.x.96]
* 
* [1.x.97] [1.x.98]。
 

* 
* 这个类几乎没有变化，只是多声明了两个函数。 [2.x.89]将用于从派生类计算的实际解决方案中生成输出文件，以及[2.x.90]函数，测试框架通过该函数将细化周期的编号设置为该类中的一个局部变量；该编号随后被用于生成解决方案输出的文件名。
* 

* 
* [1.x.99]
* 
* [1.x.100] [1.x.101].
 

* 
* 同样，[2.x.91]类也完全没有变化，因此将不进行讨论。
* 

* 
* [1.x.102]
* 
* 该类的其余部分基本上也是[2.x.92]的副本，包括使用WorkStream框架并行计算线性系统所需的数据结构和函数。
* 

* 
* [1.x.103]
* 
* 以下几个函数和构造函数是逐字复制自 [2.x.93] 。
 

 
* [1.x.104]
* 
* 现在是实现线性系统类中动作的函数。首先，构造函数将所有的数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬空节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成了一个线程，所以我们在这里不使用[2.x.94]类，而是直接使用创建的一个任务对象来等待这个特定任务的退出。这个方法与我们在上面[2.x.95]中使用的方法大致相同。    
* 注意，获取[2.x.96]函数的地址有点麻烦，因为实际上有三个这个名字的函数，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符[2.x.97]会返回一组值（所有具有该名称的函数的地址），然后选择正确的函数是下一步的事情。如果上下文决定采取哪一个（例如通过分配给一个已知类型的函数指针），那么编译器可以自己来做，但是如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时[2.x.98]（简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。
* 

* 
* [1.x.105]
* 
* 启动一个辅助任务，然后在主线程上继续进行
* 

* 
* [1.x.106]
* 
* 等待副线任务完成后再继续进行
* 

* 
* [1.x.107]
 
* [1.x.108] [1.x.109]。
 

* 
* [2.x.99]类除了实现[2.x.100]函数外，也基本没有变化。我们在这个程序中保留了[2.x.101]类，然后它们可以依赖这个函数的默认实现，这个函数只是输出原始解。实现双重加权误差估计的类将自行重载这个函数，以同时输出双重解。
* 

* 
* [1.x.110]
* 
* [1.x.111] [1.x.112].
 

* 
* 对于以下两个班级，与上述大多数班级的情况相同：班级是按原样从前面的例子中抽取的。
* 

* 
* [1.x.113]
* 
* [1.x.114] [1.x.115]。
 

* 
* 这个类是前一个类的变种，它允许用一些函数来加权我们从库的凯利指标中得到的细化指标。我们包括这个类，因为这个例子程序的目标是展示自动细化标准，即使是复杂的输出量，如点值或应力。如果我们不解决一个对偶问题并计算其中的权重，我们很可能会想给指标一个手工制作的权重，以说明我们要评估这些数量的事实。这个类接受这样一个加权函数作为其构造函数的参数。
* 

* 
* [1.x.116]
* 
* 现在，这里有一个主函数，包括加权。
* 

* 
* [1.x.117]
* 
* 首先通过库中已经实现的方法为所有单元格计算一些基于残差的误差指标。我们在这里计算的具体内容在该类的文档中有更详细的描述。
* 

* 
* [1.x.118]
 
* 接下来用给与构造函数的值来衡量指标向量中的每个条目，在单元格中心进行评估。我们需要将结果写入对应于当前单元的向量条目中，我们可以通过使用[2.x.102]询问单元在所有活动单元中的索引来获得这个结果（实际上，对于我们在循环中处理的第一个单元，这个索引是0，第二个单元是1，等等，我们也可以使用一个整数计数器来跟踪这个索引；但是使用[2.x.103]使之更加明确）。
* 

* 
* [1.x.119]
* 
* [1.x.120] [1.x.121] [1.x.121]。  
* 在这个示例程序中，我们使用的数据集与前一个相同，但由于可能有人想用不同的边界值和右手函数或在不同的网格上运行程序，我们展示了一个简单的技术来做到这一点。为了更加清晰，我们进一步将所有与方程数据有关的东西都打包到一个自己的命名空间中。  
* 基本假设是这是一个研究项目，在那里我们经常有一些测试案例，由一个域、一个右手边、边界值、可能是一个指定的系数和一些其他参数组成。当从一个例子转移到另一个例子时，它们常常同时变化。使处理这样的问题描述参数集变得简单是以下的目标。  
* 基本上，这个想法是这样的：让我们为每一组数据都有一个结构，在这个结构中，我们把描述一个测试案例的所有东西都打包：这里，这些是两个子类，一个叫[2.x.104]，用于精确解的边界值，一个叫[2.x.105] ，然后是生成粗网格的方法。由于前面的例子程序的解看起来像弯曲的山脊，所以我们在这里用这个名字来表示包围的类。请注意，两个内层类的名称对于所有包围的测试案例类必须是相同的，同时我们将维度模板参数附加到包围类而不是内层类，以使进一步的处理更简单。 从语言的角度来看，用命名空间来封装这些内部类会比用结构来封装更好。然而，命名空间不能作为模板参数给出，所以我们使用一个结构来允许第二个对象从其给定的参数中选择。当然，封闭的结构除了它所声明的类之外，没有任何成员变量，还有一个静态函数来生成粗略的网格；一般来说，它永远不会被实例化)。  
* 这个想法是这样的（现在是时候也简单看看下面的代码了）：我们可以为边界值和右手边生成对象，只需将外层类的名字作为模板参数给一个类，我们在这里称之为[2.x.106]，然后它就为内部类创建对象。在这种情况下，为了得到所有描述弧形山脊解决方案的特征，我们将简单地生成一个[2.x.107]的实例，而我们需要知道的关于该解决方案的一切都将是该对象的静态成员变量和函数。  
* 在这种情况下，这种方法可能看起来是多余的，但是一旦某种设定不仅有迪里希特边界值和右手函数的特征，而且还有材料属性、诺伊曼值、不同的边界描述符等，就会变得非常方便。在这种情况下，[2.x.108]类可能由十几个对象组成，而每个描述符类（如下面的[2.x.109]类）都必须提供这些对象。然后，你会很高兴，只需在一个地方改变[2.x.110]类的模板参数，而不是在很多地方改变，就能从一组数据改变到另一组。  
* 有了这个不同测试案例的框架，我们就快完成了，但还有一件事：到现在，我们可以通过改变一个模板参数，静态地选择要选择的数据集。为了能够动态地做到这一点，也就是说，在运行时，我们需要一个基类。我们以明显的方式提供这个基类，见下文，用虚拟抽象函数。这迫使我们引入第二个模板参数[2.x.111]，我们需要这个基类（这可以用一些模板魔法来避免，但我们省略），但这就是全部。  
* 添加新的测试用例现在很简单，你不需要接触框架类，只需要一个类似于[2.x.112]的结构。
* 

* 
* [1.x.122]
* 
* [1.x.123] [1.x.124].
 

* 
* 基于上述描述，[2.x.113]类然后看起来如下。为了允许用这个类来使用[2.x.114]类，我们从[2.x.115]类派生出来。
* 

* 
* [1.x.125]
* 
* 现在是派生类，按照上面的解释，接受模板参数。    
* 这里我们把数据元素打包成私有变量，并允许通过基类的方法来访问它们。
* 

* 
* [1.x.126]
* 
* 我们必须为上述类的静态成员变量提供定义。
* 

* 
* [1.x.127]
* 
* 还有成员函数的定义。
 

* 
* [1.x.128]
 
* [1.x.129] [1.x.130]。
 

* 
* 用于描述[2.x.116]问题的边界值和右手边的类已经在[2.x.117]示例程序中使用，然后像这样。
* 

* 
* [1.x.131]
* 
* [1.x.132] [1.x.133]。
 

* 
* 这个例子程序是在为一个关于自适应有限元方法和基于对偶性的误差估计的讲座提供实践课程时写的。对于这些课程，我们有一个练习，要求在一个中心有方孔的正方形域上求解右方恒定的拉普拉斯方程，边界值为零。由于这个问题的属性在这里的实现特别简单，所以让我们来做。由于练习的编号是2.3，所以我们冒昧地把这个名字也保留下来，作为课的名称。
* 

* 
* [1.x.134]
* 
* 我们需要一个类来表示问题的边界值。在这种情况下，这很简单：它是零函数，所以甚至不需要声明一个类，只需要一个别名。
* 

* 
* [1.x.135]
* 
* 第二，一个表示右手边的类。因为它们是常数，所以只要把库中相应的类子类化就可以了。
 

* 
* [1.x.136]
* 
* 最后是一个生成粗略网格的函数。这在这里有些复杂，请看下面的内容。
* 

* 
* [1.x.137]
* 
* 如上所述，这个例子的网格是正方形[-1,1]^2，其中有正方形[-1/2,1/2]^2作为孔。我们将粗略的网格创建为4乘以4的单元，中间的四个单元缺失。要了解网格的具体样子，最简单的方法可能是先看一下本教程程序的 "结果 "部分。一般来说，如果你想了解更多关于创建网格的信息，无论是像我们在这里所做的那样从头开始，还是使用其他技术，你都应该看一下 [2.x.118] 。    
* 当然，这个例子可以扩展到三维，但由于这个函数不能以独立于维度的方式编写，我们选择不在这里实现它，而只是对dim=2的模板进行专业化处理。如果你编译3d的程序，你会从链接器中得到一个信息，即这个函数没有为3d实现，需要提供。    
* 对于这个几何体的创建，库中没有预定义的方法。在这种情况下，几何体还是很简单的，可以用手来创建，而不是用网格发生器。
* 

* 
* [1.x.138]
* 
* 我们首先定义空间维度，以便让函数中那些实际上与维度无关的部分使用这个变量。如果你以后以这个为起点来实现这个网格的三维版本，那就更简单了。下一步是要有一个顶点的列表。这里，它们是24个（5乘以5，中间的省略）。最好的办法是在这里画一个草图。
* 

* 
* [1.x.139]
 
* 接下来，我们要定义单元格和它们所包含的顶点。
* 

* 
* [1.x.140]
* 
* 再次，我们从中生成一个C++矢量类型，但这次是通过在单元格上循环来实现的（是的，这很无聊）。此外，我们将所有单元格的材料指标设置为零。
* 

* 
* [1.x.141]
* 
* 最后将所有这些信息传递给库，以生成一个三角形图。最后一个参数可以用来将三角形的某些面的非零边界指标的信息传递给库，但是我们在这里并不希望这样，所以我们给出一个空对象。
* 

* 
* [1.x.142]
* 
* 因为我们希望这个例子中的评估点（3/4,3/4）是一个网格点，所以我们在全局上细化一次。
* 

* 
* [1.x.143]
* 
* [1.x.144] [1.x.145].   
* 你现在已经读完了这个框架，你可能会想，为什么我们没有选择直接把实现某种设置的类（比如[2.x.119]类）作为派生自[2.x.120]的类来实现。事实上，我们可以很好地这样做。唯一的原因是，这样我们就必须在[2.x.121]类中为解决方案和右手边的类设置成员变量，以及重载基类的抽象函数来访问这些成员变量的成员函数。[2.x.122]类的唯一原因是让我们不必再重申这些成员变量和函数，这些都是所有这些类所必须的。在某种程度上，这里的模板机制只是提供了一种方法，为一些依赖于外部量的函数提供默认的实现，因此不能用正常的虚拟函数来提供，至少在没有模板的帮助下不能。  
* 然而，可能有很好的理由来实际实现从[2.x.123]派生的类，例如，如果解或右手边的类需要带参数的构造函数，而[2.x.124]类无法提供。在这种情况下，子类化是一个值得考虑的策略。对于特殊情况的其他可能性是派生自[2.x.125]，其中[2.x.126]表示一个类，甚至明确地专门化[2.x.127] 。后者允许透明地使用[2.x.128]类用于其他设置的方式，但对特殊参数采取特殊行动。  
* 赞成这里采取的方法的最后一个意见是：我们无数次发现，当开始一个项目时，参数的数量（通常是边界值，右侧，粗略的网格，就像这里一样）很小，测试案例的数量也很小。然后，人们一开始就把它们手工编码成一些[2.x.129]的语句。随着时间的推移，项目的增长，测试用例的数量也在增长。[2.x.130]语句的数量也随之增长，它们的长度也是如此，人们开始想办法考虑不可能的例子，其中域、边界值和右手边不再适合在一起，并且开始失去对整个结构的概述。事实证明，把属于某个测试用例的所有东西都封装到一个自己的结构中是值得的，因为它把属于一个测试用例的所有东西都放在一个地方。此外，它允许把这些东西都放在一个或多个文件中，这些文件只用于测试用例和它们的数据，而不需要把它们的实际实现与程序的其他部分联系起来。
* 

* 
*  
*  
* [1.x.146] [1.x.147].
 

* 
* 和程序的其他部分一样，我们把所有需要描述对偶函数的东西都放到一个自己的命名空间中，并定义一个抽象的基类，为解决对偶问题的类提供其工作所需的接口。  
* 然后我们将实现两个这样的类，用于评估一个点的值和该点的解的导数。对于这些函数，我们已经有了相应的评估对象，所以它们是互补的。
* 

* 
* [1.x.148]
* 
* [1.x.149] [1.x.150].
 

* 
* 首先从对偶函数的基类开始。因为对于线性问题来说，对偶问题的特征只在右手边起作用，所以我们只需要提供一个函数来组装给定离散化的右手边。
* 

* 
* [1.x.151]
* 
* [1.x.152] [1.x.153]
 

* 
* 作为第一个应用，我们考虑对应于在一个给定的点上对解的值进行评估的函数，我们再次假设这个点是一个顶点。除了接受和存储评估点的构造函数之外，这个类只包括实现组装右手边的函数。
* 

* 
* [1.x.154]
 
* 至于做这个类的主要目的，组装右手边，让我们首先考虑一下什么是必要的。对偶问题的右手边是一个值的向量J(phi_i)，其中J是误差函数，phi_i是第i个形状函数。这里，J是在点x0处的评价，即J(phi_i)=phi_i(x0)。    
*现在，我们已经假定评价点是一个顶点。因此，对于我们在这个程序中可能使用的通常的有限元，我们可以想当然地认为在这样一个点上正好有一个形状函数是不为零的，特别是有一个值为1。因此，我们将右手边的向量设置为全零，然后寻找与该点相关的形状函数，并将右手边向量的相应值设置为1。
* 

* 
* [1.x.155]
* 
* 所以，首先把所有东西都设为零......
* 

* 
* [1.x.156]
* 
* ...然后在单元格上循环，在顶点中找到评估点（或非常接近顶点的地方，由于浮点舍入，可能会出现这种情况）。
* 

* 
* [1.x.157]
* 
* 好的，找到了，所以设置相应的条目，然后离开函数，因为我们已经完成了。
* 

* 
* [1.x.158]
* 
* 最后，一个理智的检查：如果我们以某种方式来到这里，那么我们一定是错过了评估点，所以无条件地引发一个异常。
* 

* 
* [1.x.159]
* 
* [1.x.160] [1.x.161].
 

* 
* 作为第二个应用，我们再次考虑在一个点上对解的x导数进行评估。同样，这个类的声明和它的构造函数的实现也不是太有趣。
* 

* 
* [1.x.162]
* 
* 有趣的是这个函数的实现：这里，J(phi_i)=d/dx phi_i(x0)。    
* 我们可以像实现各自的评价对象那样，在这个评价点上取每个形状函数phi_i的梯度的平均值。然而，我们采取了一个略微不同的方法：我们简单地取该点周围所有单元格的平均值。哪些单元[2.x.131]是评估点，这个问题取决于网格宽度，包括那些单元的中点到评估点的距离小于单元的直径的单元。    
* 在这些单元的面积/体积上取梯度的平均值，可以得到一个非常接近于梯度的点评估结果的对偶解。从理论上讲，这并没有明显改变方法，这一点很容易证明。
* 

* 
* [1.x.163]
 
* 同样，首先将所有条目设置为零。
* 

* 
* [1.x.164]
* 
* 用正交公式初始化一个[2.x.132]对象，有正交点数量和形状函数的缩写......
* 

* 
* [1.x.165]
* 
* ...并有两个对象，用来存储单元上自由度的全局指数，以及正交点上形状函数的梯度值。
* 

* 
* [1.x.166]
* 
* 最后有一个变量，我们将通过对这些单元上的单位函数进行积分，将这些单元的面积/体积加起来。
* 

* 
* [1.x.167]
* 
* 然后在所有单元上开始循环，并选择那些与评估点足够接近的单元。
* 

* 
* [1.x.168]
* 
* 如果我们找到了这样的单元，然后初始化[2.x.133]对象，并整合每个形状函数梯度的x分量，以及总面积/体积的单位函数。
* 

* 
* [1.x.169]
 
* 如果我们有局部贡献，将它们分配到全局矢量。
* 

* 
* [1.x.170]
* 
* 在我们对所有的单元进行循环后，通过确保它们的体积不为零，来检查我们是否找到了任何单元。如果不是，那么结果将是错误的，因为这时的右手边应该仍然是零，所以抛出一个异常。
* 

* 
* [1.x.171]
* 
* 最后，我们现在只整合了形状函数的梯度，而没有取其平均值。我们通过除以我们所整合的体积的尺度来解决这个问题。
* 

* 
* [1.x.172]
* 
* [1.x.173] [1.x.174]。
 

 
* [1.x.175]
 
* [1.x.176] [1.x.177].
* 

* 
* 与上面的[2.x.134]类相同，我们现在实现一个[2.x.135]。它具有所有相同的特征，唯一的区别是它不接受表示右手边对象的函数对象，而现在接受一个[2.x.136]对象，它将集合对偶问题的右手边向量。这个类的其余部分是相当琐碎的。    
* 由于原始解算器和对偶解算器将使用相同的三角形，但不同的离散，现在很清楚为什么我们将[2.x.137]类变成了虚拟类：因为最终类将从[2.x.138]以及[2.x.139]实例中派生，我们是不是应该将继承标记为虚拟。因为在许多应用中，基类会存储更多的信息，而不仅仅是需要在原始和对偶求解器之间共享的三角关系，所以我们通常不希望使用两个这样的基类。
* 

* 
* [1.x.178]
* 
* [1.x.179] [1.x.180].
* 

* 
* 这里终于出现了本程序的主类，即实现对偶加权残差估计器的类。它连接了原始和对偶求解器类，用于计算原始和对偶解，并实现了误差表示公式，用于误差估计和网格细化。    
* 这个类的前几个函数大多是对基类各自函数的覆盖。
* 

* 
* [1.x.181]
* 
* 在私有部分，我们有两个函数是用来调用原始基类和双基类的[2.x.140]函数。这两个函数将被本类的[2.x.141]函数并行调用。
* 

* 
* [1.x.182]
* 
* 然后声明活动单元格迭代器的缩写，以避免我们不得不重复写这个冗长的名字。
* 

* 
*  

* 
* [1.x.183]
* 
* 接下来，声明一个数据类型，我们将用它来存储面孔对误差估计器的贡献。我们的想法是，我们可以计算从两个单元格中的每一个到这个面的面项，因为从两边看时它们是一样的。我们要做的是，根据下面解释的一些规则，只计算一次，由相邻的两个单元负责计算。然后，我们将每个面的贡献存储在一个映射面与它们的值的地图中，并且只通过第二次在单元格上循环并从地图上抓取值来收集每个单元格的贡献。      
* 这个地图的数据类型在此声明。
* 

* 
* [1.x.184]
 
* 在计算单元和面的误差估计时，我们需要一些辅助对象，如[2.x.142]和[2.x.143]函数，但也需要一些临时对象来存储原始和对偶解的值和梯度，例如。这些字段在三个函数中是需要的，这三个函数分别在单元格上做积分，以及规则和不规则面。      
* 有三种合理的方式来提供这些字段：第一，作为需要它们的函数的局部变量；第二，作为这个类的成员变量；第三，作为参数传递给该函数。      
* 这三种替代方法都有缺点：第三种是它们的数量不可忽略，会使调用这些函数成为一项冗长的事业。第二种方法的缺点是不允许并行化，因为计算误差估计值的线程必须各自拥有这些变量的副本，所以包围类的成员变量将不起作用。第一种方法虽然直接，但有一个微妙但重要的缺点：我们会反复调用这些函数，也许是成千上万次；现在证明，从堆中分配向量和其他需要内存的对象在运行时间上是很昂贵的，因为当涉及到几个线程时，内存分配很昂贵。因此，只分配一次内存，并尽可能频繁地回收这些对象是明显更好的做法。      
* 该怎么做呢？我们的答案是使用第三种策略的一个变种。事实上，这正是WorkStream概念所要做的（我们已经在上面介绍了它，但也请看[2.x.144]）。为了避免我们必须给这些函数十几个参数，我们将所有这些变量打包成两个结构，一个用于单元格的计算，另一个用于面的计算。然后，这两个结构被加入到WeightedResidualScratchData类中，该类将作为WorkStream概念的 "划痕数据 "类。
* 

* 
* [1.x.185]
* 
* [2.x.145] 一般来说，既要有抓取对象，又要有复制对象。在这里，由于与我们在[2.x.146]中讨论计算梯度的近似值时类似的原因，我们实际上不需要一个 "拷贝数据 "结构。既然WorkStream坚持要有一个这样的结构，我们就声明一个空的结构，除了存在之外什么都不做。
* 

* 
* [1.x.186]
* 
* 关于误差估计器的评估，我们有一个驱动函数，使用[2.x.147]在每个单元上调用第二个函数。
* 

* 
* [1.x.187]
* 
* 然后我们有一些函数对误差表示公式进行实际积分。它们将分别处理单元格内部、没有悬挂节点的面和有悬挂节点的面的条款。
* 

* 
* [1.x.188]
* 
* 在这个类的实现中，我们首先有[2.x.148]成员类的构造函数，以及[2.x.149]构造函数。它们只是将字段初始化为正确的长度，所以我们不必过多地讨论它们。
* 

* 
* [1.x.189]
* 
* 接下来的五个函数是很无聊的，因为它们只是把它们的工作转交给基类。第一个函数并行地调用原始和对偶求解器，而解的后处理和检索自由度的数量则由原始类完成。
* 

* 
* [1.x.190]
* 
* 现在，变得更加有趣了：[2.x.150]函数要求误差估计器计算单元的误差指标，然后使用其绝对值进行网格细化。
* 

* 
* [1.x.191]
* 
* 首先调用计算单元间和全局误差的函数。
 

* 
* [1.x.192]
* 
* 然后注意，只有当所有的指标都是正数时，为细化或粗化做标记的单元才会起作用，以便于它们的比较。因此，去掉所有这些指标上的符号。
* 

* 
* [1.x.193]
* 
* 最后，我们可以选择不同的细化策略。这里默认的是细化那些误差指标最大、占总误差80%的单元，而我们则粗化那些指标最小、占总误差2%的单元。
* 

* 
* [1.x.194]
* 
* 由于我们想同时输出原始解和对偶解，我们重载了[2.x.151]函数。这个函数唯一有趣的特点是，原始解和对偶解是在不同的有限元空间上定义的，这不是[2.x.152]类所期望的格式。因此，我们必须将它们转移到一个共同的有限元空间。由于我们只想从质量上看到这些解，所以我们要争夺将对偶解内插到（较小的）原始空间。对于插值，有一个库函数，它接收一个包括悬挂节点约束的AffineConstraints对象。其余的都是标准的。
* 

* 
* [1.x.195]
* 
* 添加我们想要输出的数据向量。把它们都加进去，[2.x.153]函数可以处理你想写到输出的多少个数据向量。
 

* 
* [1.x.196]
* 
* [1.x.197] [1.x.198]。
 

* 
* [1.x.199] [1.x.200]。    
* 至于误差估计的实际计算，让我们从驱动这一切的函数开始，即调用那些实际工作的函数，并最终收集结果。
* 

* 
* [1.x.201]
 
* 计算误差的第一个任务是设置向量，表示原始解，以及权重(z-z_h)=(z-I_hz)，两者都在我们计算了对偶解的有限元空间中。为此，我们必须将原始解内插到对偶有限元空间，并将计算出的对偶解内插到原始有限元空间。幸运的是，库中提供了向更大或更小的有限元空间插值的函数，所以这一点基本是显而易见的。      
* 首先，让我们为原始解做这件事：它被单元内插到我们已经解决了对偶问题的有限元空间中：但是，还是像[2.x.154]函数中那样，我们首先需要创建一个AffineConstraints对象，包括悬挂节点约束，但这次是对偶有限元空间。
* 

* 
* [1.x.202]
 
* 然后为了计算数值逼近的对偶解z插值到原始解的有限元空间并从z中减去：使用[2.x.155]函数，在对偶解的元素空间中得到(z-I_hz)。
* 

* 
* [1.x.203]
* 
* 请注意，这可能会更有效率，因为这些约束条件已经在之前为原始问题组装矩阵和右手边以及写出对偶解时使用过了。我们把这方面的程序优化作为一个练习。
* 

* 
* 在计算了对偶权重之后，我们现在开始计算原始解的单元和面的残差。首先，我们在面的迭代器和面的跳跃项对误差估计器的贡献之间建立一个映射。原因是我们只计算了一次面的跳跃项，并希望在第二次循环所有单元时才收集它们。      
* 我们已经用一个值来初始化这个地图，即
* 
* e20，因为如果出了问题，我们因某种原因无法计算某个面的值，这个值会在结果中脱颖而出。其次，这个初始化已经使[2.x.156]对象分配了它可能需要的所有对象。这一点很重要，因为我们将从并行线程写进这个结构，如果地图需要分配内存，从而重塑其数据结构，那么这样做就不是线程安全的。换句话说，初始化使我们不必在线程每次写入（和修改）该地图的结构时通过互斥来同步。
* 

* 
* [1.x.204]
 
* 然后把它全部交给[2.x.157]来并行计算所有单元的估计值。
* 

* 
* [1.x.205]
* 
* 一旦错误贡献被计算出来，就把它们加起来。对于这一点，请注意单元项已经设置好了，只有边缘项需要收集。因此，在所有的单元和它们的面中循环，确保每个面的贡献都在那里，然后把它们加起来。只需要减去一半的跳跃项，因为另一半会被邻近的单元格拿走。
* 

* 
* [1.x.206]
* 
* [1.x.207] [1.x.208].
 

* 
* 接下来我们有一个函数，它被调用来估计单个单元的误差。如果库被配置为使用多线程，该函数可能被多次调用。下面是它的内容。
* 

* 
* [1.x.209]
* 
* 由于WorkStream的缘故，即使没有使用，估计_on_one_cell也需要一个CopyData对象。下一行对这个未使用的变量的警告保持沉默。
* 

* 
* [1.x.210]
* 
* 每个单元的第一个任务是计算该单元的单元残差贡献，并将其放入[2.x.158]变量中。
* 

* 
* [1.x.211]
* 
* 在计算完单元项之后，转向面项。为此，在当前单元格的所有面上进行循环，看看是否需要对其进行计算。
* 

* 
* [1.x.212]
 
* 首先，如果这个面是边界的一部分，那么就没有什么可做的。然而，为了在汇总单元格的面的贡献时使事情变得简单，我们把这个面输入对误差贡献为零的面的列表中。
* 

* 
* [1.x.213]
* 
* 接下来，请注意，由于我们想在每个面上只计算一次跳跃项，尽管我们访问它两次（如果它不在边界），我们必须定义一些规则，谁负责在一个面上计算。          
* 首先，如果相邻的单元格与这个单元格在同一层次上，也就是说，既不进一步细化，也不进一步粗化，那么这个层次中索引较低的单元格就负责计算。换句话说：如果另一个单元的指数较低，那么就跳过这个面的工作。
* 

* 
* [1.x.214]
* 
* 同样地，如果这个单元和它的邻居在细化程度上有差异，我们总是从较粗的单元开始工作。因此，如果相邻的单元比现在的单元细化程度低，那么就什么都不做，因为当我们访问粗略的单元时，我们对子面进行整合。
* 

* 
* [1.x.215]
 
* 现在我们知道我们在这里负责，所以实际上是计算面的跳跃项。如果这个面是一个规则的面，即另一边的单元格既不比这个单元格粗也不比这个单元格细，那么就调用一个函数，如果另一边的单元格进一步细化，那么就用另一个函数。请注意，另一边的单元格更粗的情况不可能发生，因为我们在上面已经决定，当我们传递到另一个单元格时，我们会处理这种情况。
* 

* 
* [1.x.216]
* 
* [1.x.217] [1.x.218].
 

* 
*至于误差贡献的实际计算，首先转向单元项。
* 

* 
* [1.x.219]
* 
* 要做的工作就是看了误差估计公式后显得很自然：首先得到单元残差的正交点的数值解的右手边和拉普拉斯。
* 

* 
* [1.x.220]
* 
* ...然后得到对偶权重...
* 

* 
* [1.x.221]
* 
* ...最后建立所有正交点的总和，并将其存储在当前单元格中。
* 

 
* [1.x.222]
* 
* [1.x.223] [1.x.224].
 

* 
* 另一方面，误差估计的边缘项的计算并不那么简单。首先，我们必须区分有悬挂节点和无悬挂节点的面。因为它是简单的情况，我们首先考虑一个面上没有悬挂节点的情况（我们称之为 "常规 "情况）。
* 

* 
* [1.x.225]
 
* 第一步是得到本单元上有限元场的正交点的梯度值。为此，初始化[2.x.159]对象，对应于面的这一侧，并使用该对象提取梯度。
* 

* 
* [1.x.226]
* 
* 第二步是在面的另一侧的正交点提取有限元解的梯度，即从相邻的单元提取。      
* 为此，在之前做一个理智的检查：确保邻居确实存在（是的，如果邻居不存在，我们就不应该来这里，但是在复杂的软件中会有bug，所以最好检查一下），如果不是这样就会出现错误。
* 

* 
* [1.x.227]
* 
* 如果我们有了这个，那么我们就需要找出相邻单元格的哪个面，也就是说，[2.x.160]这个单元格是本面后面单元格的邻居。为此，有一个函数，我们将结果放入一个变量，名称为[2.x.161] 。
* 

* 
* [1.x.228]
* 
* 然后定义一个相邻单元的缩写，在该单元上初始化[2.x.162]对象，并提取该单元上的梯度。
* 

* 
* [1.x.229]
* 
* 现在我们有了这个单元和邻近单元的梯度，通过将梯度中的跳跃与法向量相乘来计算跳跃残差。
* 

* 
* [1.x.230]
* 
* 接下来得到这个面的双重权重。
* 

* 
* [1.x.231]
* 
* 最后，我们要计算跳跃残差、对偶权重和正交权重的总和，以得到这个面的结果。
 

* 
* [1.x.232]
* 
* 仔细检查这个元素是否已经存在，并且没有被写入......
* 

* 
* [1.x.233]
* 
* ...然后在指定的位置存储计算值。请注意，存储的值并不包含错误表示中出现的因子1/2。原因是，如果我们在三角形的所有面上进行循环，这个项实际上没有这个因子，但只有当我们把它写成所有单元和每个单元的所有面的总和时才会出现；因此我们两次访问同一个面。我们通过使用这个因子来考虑到这一点
* 
* - /2以后，当我们对每个单元的贡献进行单独求和时，就会考虑到这一点。
* 

* 
* [1.x.234]
* 
* [1.x.235] [1.x.236]。
 

* 
* 我们仍然缺少有悬空节点的面的情况。这就是这个函数中所涉及的内容。
* 

* 
* [1.x.237]
* 
* 首先还是两个缩写，以及一些一致性检查，以确定该函数是否只在它应该被调用的面上被调用。
 

* 
* [1.x.238]
* 
* 然后找出当前单元格是相邻单元格的哪个邻居。注意，我们将对这个相邻单元的子女进行操作，但他们的方向与他们的母亲相同，也就是说，邻居的方向是相同的。
* 

* 
* [1.x.239]
 
* 然后简单地对所有的子面做我们在前面的函数中对一个面所做的一切，现在。
* 

* 
* [1.x.240]
* 
* 再从一些检查开始：得到一个指向当前子面后面的单元格的迭代器，并检查其面是否是我们所考虑的子面。如果不是这样，那么上面调用的[2.x.163]函数就会有错误，或者是
* 
* - 更糟糕
* 

* 
* 
* - 库中的某些函数没有遵守关于单元格、它们的孩子和它们的面的一些基本假设。在任何情况下，即使这个断言不应该被触发，谨慎一点也无妨，在优化模式的计算中，这个断言无论如何都会被删除。
* 

* 
* [1.x.241]
* 
* 现在开始工作，首先在界面的这一侧再次得到解的梯度。
* 

* 
* [1.x.242]
 
* 然后在另一边。
 

* 
* [1.x.243]
 
*，最后建立跳跃残差。由于这次我们从另一个单元格中取法向量，所以与另一个函数相比，还原了第一项的符号。
* 

* 
* [1.x.244]
* 
* 然后得到双重权重。
* 

* 
* [1.x.245]
* 
* 最后，总结这个子面的贡献，并将其设置在全局图中。
* 

* 
* [1.x.246]
* 
* 一旦所有子面的贡献被计算出来，就循环计算所有的子面，把它们和母面一起收集起来，以便以后收集单元格的误差项时简单使用。再次进行安全检查，确保子面的条目已经被计算出来，并且不带有无效的值。
* 

* 
* [1.x.247]
 
* 最后将该值存储在父面。
* 

* 
* [1.x.248]
* 
* [1.x.249] [1.x.250].
 

* 
* 在前面的例子程序中，我们已经有两个函数用来驱动在随后的更细的网格上进行求解的过程。我们在这里进行了扩展，允许向这些函数传递一些参数，并将所有这些参数放入框架类。  
* 你会注意到，这个程序是由许多小部分组成的（评估函数、实现各种细化方法的求解器类、不同的对偶函数、不同的问题和数据描述），这使得程序的扩展相对简单，但也允许通过用一个部分替换另一个部分来解决大量不同的问题。我们通过在下面的框架类中声明一个结构来反映这种灵活性，该结构持有一些参数，可以设置这些参数来测试这个程序的各个部分的组合，并且可以用简单的方法在各种问题和离散度上进行测试。
* 

* 
* [1.x.251]
* 
* 首先，我们声明两个缩写，以便简单使用各自的数据类型。
* 

* 
* [1.x.252]
* 
* 然后我们有一个结构，它声明了所有可能被设置的参数。在该结构的默认构造函数中，这些值都被设置为默认值，以供简单使用。
* 

* 
* [1.x.253]
 
* 首先允许输入分片多项式的度数，原始和对偶问题将被离散化。对于原始问题，它们默认为（双，三）线性分解函数，对于对偶问题，默认为（双，三）二次函数。如果选择了一个不需要解决对偶问题的细化准则，对偶有限元度的值当然会被忽略。
* 

* 
* [1.x.254]
 
* 然后有一个描述问题类型的对象，即右手边、领域、边界值等。这里需要的指针默认为Null指针，也就是说，你必须在这个对象的实际实例中设置它，才能使它发挥作用。
* 

* 
* [1.x.255]
* 
* 因为我们允许使用不同的细化标准（全局细化，通过凯利误差指标细化，可能有一个权重，以及使用双重估计器），定义一些枚举值，随后定义一个该类型的变量。它将默认为[2.x.164] 。
* 

* 
* [1.x.256]
* 
* 接下来是一个描述双重函数的对象。只有在选择双重加权残差细化时才需要它，并且默认为一个空指针。
* 

* 
* [1.x.257]
 
* 然后是一个评估对象的列表。其默认值为空，即没有评价对象。
* 

* 
* [1.x.258]
* 
* 接下来是一个函数，它被用作[2.x.165]类的权重。这个指针的默认值是零，但是如果你想使用[2.x.166]细化标准，你必须把它设置为其他的值。
* 

* 
* [1.x.259]
* 
* 最后，我们有一个变量，表示我们允许（原始）离散化的最大自由度数。如果超过这个数值，我们将停止解算和间歇性网格细化的过程。其默认值为20,000。
* 

* 
* [1.x.260]
 
* 最后是这个类的默认构造函数。
* 

* 
* [1.x.261]
* 
* 驱动程序框架类只有一个方法，它断断续续地调用求解器和网格细化，并在中间做一些其他的小任务。由于它不需要除了给它的参数之外的数据，我们把它变成静态的。
* 

* 
* [1.x.262]
 
* 至于实现，首先是参数对象的构造函数，将所有的值设置为默认值。
* 

* 
* [1.x.263]
* 
* 然后是驱动整个过程的函数。
* 

* 
* [1.x.264]
* 
* 首先从给定的数据对象中创建一个三角图。
* 

* 
* [1.x.265]
* 
* 然后是一组有限元素和适当的正交公式。
 

* 
* [1.x.266]
 
* 接下来，选择一个实现不同细化标准的类。
* 

* 
* [1.x.267]
* 
* 现在所有的对象都到位了，运行主循环。停止的标准在循环的底部实现。    
* 在这个循环中，首先设置新的循环数，然后解决问题，输出它的解，对它应用评估对象，然后决定我们是否要进一步细化网格并在这个网格上再次求解，或者跳出循环。
* 

* 
* [1.x.268]
* 
* 循环运行后，对屏幕进行清理。
* 

* 
* [1.x.269]
* 
* [1.x.270] [1.x.271].
 

* 
* 这里最后是主函数。它通过指定一组用于模拟的参数（多项式度数、评估和对偶函数等）来驱动整个过程，并将它们打包成一个结构传给上面的框架工作类。
* 

* 
* [1.x.272]
* 
* 在此描述我们要解决的问题，将一个描述符对象传递给做其他工作的函数。
* 

* 
* [1.x.273]
* 
* 首先设置我们希望使用的细化标准。
* 

* 
* [1.x.274]
* 
* 这里，我们也可以使用[2.x.167]或[2.x.168] 。请注意，所给出的关于对偶有限元、对偶函数等信息只对给定的细化准则选择很重要，否则就会被忽略。
* 

* 
* 然后设置原始问题和对偶问题的多项式程度。我们在这里选择双线性和双二次方的问题。
 

 
* [1.x.275]
 
* 然后设置测试案例的描述，即域、边界值和右手边。这些都是预先打包在类中的。我们在这里采取 [2.x.169] 的描述，但你也可以使用 [2.x.170] 。
* 

* 
* [1.x.276]
* 
* 接下来首先设置一个二元函数，然后设置一个评价对象的列表。我们默认选择在一个评价点对值进行评价，由评价和二元函数类命名空间中的[2.x.171]类代表。你也可以设置[2.x.172]类来代替评价点的值的x-derivative。      
* 请注意，双功能和评价对象应该匹配。然而，你可以给你想要的评价函数，所以你可以在每一步之后让点值和导数都得到评价。 一个这样的附加评价是在每一步中输出网格。
* 

* 
* [1.x.277]
* 
* 设置最大的自由度数，之后我们希望程序停止进一步细化网格。
* 

* 
* [1.x.278]
* 
* 最后将描述符对象传递给一个函数，用它来运行整个解决方案。
* 

* 
* [1.x.279]
* 
* 捕获异常以提供有关失败的信息。
* 

* 
* [1.x.280]
* [1.x.281][1.x.282] 。
* 

* [1.x.283][1.x.284] 。
 

* 
* 这个程序提供了大量的可能性来进行游戏。因此，我们只能展示所有可能的结果中的一小部分，在这个程序的帮助下可以获得这些结果。然而，我们鼓励你通过改变主程序中的设置来尝试。在这里，我们先简单地让它运行，不做任何修改。
* [1.x.285]
 
* 

* 首先，让我们看看程序的实际计算结果。在第七个网格上，原始和双重数值解看起来是这样的（使用的颜色方案旨在唤起科罗拉多州白雪皑皑的山脉，这个程序的原作者现在把它叫做家）。[2.x.173]显然，左下角的区域对于右上角的点值评估是如此不重要，以至于网格在那里完全没有被细化，尽管解决方案在该单元的内角有奇异点 由于右手边和领域的对称性，解决方案实际上应该像右上角的所有四个角一样，但是涉及到对偶解决方案的网格细化标准选择了不同的细化方式
* 
* - 因为我们说过，我们真正关心的只是右上方某处的一个函数值。
* 

* 
* 下面是一些在细化周期0,2,4（顶行）和5,7,8（底行）产生的网格。
* [2.x.174] 
* 注意解决角部奇异点和解决评估点周围的微妙的相互作用。手工生成这样的网格将是相当困难的，因为这将涉及到定量地判断四个角奇点中的哪一个应该被解决，并设置与评估点附近的权重。
* 

* 
* 该程序会打印出点值和这个数量的估计误差。通过推断，我们可以猜测准确的数值接近0.0334473，正负0.0000001（注意，我们只从22000个（原始）自由度中得到几乎6位有效数字。这个数字不能单独从函数的值中得到，但我使用了一个假设，即误差估计器大部分是精确的，并将计算值与估计的误差进行推算，以得到真实值的近似值。用更多自由度的计算表明，这个假设确实是有效的。
* 

* 
* 从计算的结果中，我们可以生成两个图形：一个是显示误差[2.x.175]（将外推值视为正确）在点值中的收敛性，以及我们将计算值[2.x.176]和估计误差eta相加得到的值（如果误差估计器[2.x.177]是精确的，那么值[2.x.178]将等于精确的点值，而且这个量的误差将总是零；然而，由于误差估计器只是一个
* 
* - 好
* 
* - 对真实误差的近似值，我们只能通过这个方法来减少误差的大小）。) 在这张图中，我们还指出了复杂度[2.x.179]，以表明在这种情况下，网格细化器是最优的。第二张图比较了真实误差和估计误差，显示两者实际上非常接近，即使对于点值这样一个复杂的量。
* 

* [2.x.180] 
* 

* [1.x.286][1.x.287] 。
* 

* 
* 由于我们在使用由对偶加权误差估计器驱动的网格细化时接受了相当多的努力（用于解决对偶问题，以及评估误差表示），因此值得询问这种努力是否成功。为此，我们首先比较了不同网格细化标准下的误差水平。要产生这些数据，只需改变主程序中网格细化准则变量的值。结果如下（对于Kelly指标中的权重，我们选择了函数[2.x.181]，其中[2.x.182]是到评估点的距离；可以证明，如果我们忽略边界的影响，这是最佳的权重）。
* [2.x.183] 
* 

* 
* 检查这些数字，我们看到对于全局细化，误差与[2.x.184]成正比，而对于二重估计器[2.x.185]。一般来说，我们看到双重加权误差估计器比其他细化指标更好，至少在与那些具有类似规则行为的指标相比时是如此。凯利指标产生的误差较小，但在画面上的跳动相当不规则，误差的符号有时也会改变。因此，它的行为不允许将结果外推到更大的N值。此外，如果信任双重加权误差估计器的误差估计，可以通过将估计的误差加入计算值来改进结果。就可靠性而言，加权估计器因此比凯利指标更好，尽管后者有时会产生更小的误差。
* 

* 
* [1.x.288][1.x.289] 。
* 

* 
* 除了评估某一点上的解的值之外，该程序还提供了评估某一点上的X-导数的可能性，并且还可以为此定制网格细化。要让程序计算这些数量，只需将主函数中出现的两个[2.x.186]替换为[2.x.187]，然后让程序运行。
* [1.x.290]
* 
* 

* 
* 解决方案看起来与之前的大致相同（确切的解决方案当然是[2.x.188]与[2.x.189]相同，只是网格发生了一些变化），但现在的整体解决方案是不同的。评估点周围的特写显示了这一点。[2.x.190] 这一次，细化周期0、5、6、7、8和9的网格看起来像这样。
* [2.x.191] 
* 注意与我们在点评估中获得的网格相比，这些网格是不对称的。这是由于域和初解可能是围绕对角线对称的，但[2.x.192]的导数不是，后者进入了细化准则。
* 

* 
* 然后，将感兴趣的数量的实际计算值（即在一个点上的解决方案的X导数）与一个参考值进行比较是很有趣的。
* 
* - .0528223...正负0.0000005。我们通过在更细的网格上计算得到这个参考值，大约有13万个单元。回顾一下，如果在最佳情况下，误差是[2.x.193]，那么采用10倍于此的网格，我们的结果会多出一个数字。
* 

* 
* 在下图的左边部分，你再次看到了误差向这个外推值的收敛，而在右边你看到了真实和估计误差的比较。
* [2.x.194] 
* 在初始阶段，真实误差改变了它的符号，估计误差再次与它相当匹配。还请注意，当使用估计的误差来修正[2.x.195]的计算值时，误差有了戏剧性的改善。
* 

* 
* [1.x.291][1.x.292]。
* 

* 
* 如果我们不选择[2.x.196]数据集，而是在主函数中选择[2.x.197]，并选择[2.x.198]作为评估点，那么我们就可以重新进行前面例子程序的计算，以比较在双重加权误差估计器帮助下获得的结果是否比我们之前的结果更好。
* 

* 
* 首先，经过9个自适应细化周期后，分别用点评估和导数评估细化标准得到的网格看起来是这样的。
* [2.x.199] 
* 在网格中仍然可以看到解的特征，但是由于解是光滑的，对偶解的奇异性完全支配了网格细化准则，并导致强烈集中的网格。第七次细化步骤后的解看起来像下面这样。
* [2.x.200] 
* 显然，在某些地方的解更差，但是网格细化过程中应该注意到这些地方对计算点值并不重要。
* 

* 
* 

* 下一步是比较新的(基于对偶性的)网格细化标准和旧的标准. 这些是结果:
* [2.x.201] 
* 

* 
* 结果是，嗯，有点混合。首先，Kelly指示器因其不稳定的行为而不合格，多次改变误差的符号，并且在网格细化的情况下误差不断增加。双重加权误差估计器的误差呈单调下降，比加权凯利和全局精简要好，但幅度没有预期的那么大。这是因为全局细化可以利用评估点周围网格的规则结构，这导致了点误差的更好收敛顺序。然而，如果我们的网格不是局部矩形的，例如因为我们必须接近弯曲的边界，或者如果系数不是恒定的，那么全局细化网格的这种优势就会消失，而基于对偶性的估计器的良好性能就会保持。
* 

* 
* 

* [1.x.293][1.x.294] 。
 

* 
* 这里的结果并没有太清楚地表明加权误差估计方法在网格细化方面比其他网格细化标准（如Kelly指标）的优越性。这是由于所显示的应用相对简单。如果你还不相信这种方法确实有优势，请你浏览一下引言中提到的文献，其中提供了大量的例子，双加权方法可以将必要的数值工作减少几个数量级，使之成为计算某些数量的合理精度的唯一方法。
* 

* 
* 除了你可能对其作为网格细化标准提出的反对意见外，考虑到对一个人可能想要计算的量的误差的准确认识是非常有用的，因为我们可以在对精度满意的时候停止计算。使用更传统的方法，很难得到任意量的精确估计，也许除了能量规范的误差，我们将不能保证我们计算的结果满足对其精度的任何要求。另外，正如对点值和导数的评价所显示的那样，误差估计可以用来推断结果，从而在我们想知道的数量上产生更高的精度。
* 

* 
* 抛开这些数学上的考虑，我们试图以模块化的方式编写程序，这样实现另一个测试案例，或另一个评估和双功能就很简单了。我们鼓励你把这个程序作为你自己实验的基础，并进行一些小的尝试。
* 

* [1.x.295][1.x.296] [2.x.202]。
* [0.x.1]

