include/deal.II-translator/A-tutorial/step-47_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34]
* [2.x.2] 
* [1.x.35]
* [1.x.36][1.x.37][1.x.38] 。
 

* 本程序涉及[1.x.39]。
* [1.x.40]
* 这个方程出现在薄结构的建模中，如体育场的屋顶。当然，这些物体在现实中是三维的，具有较大的横向范围与垂直厚度的长宽比，但人们通常可以通过对内力在垂直方向上的变化作出假设，将这些结构非常精确地建模为二维的。这些假设导致了上面的公式。
* 该模型通常有两种不同的类型，取决于施加什么样的边界条件。第一种情况。
* [1.x.41]
* 对应于薄结构的边缘连接到高度为[2.x.3]的墙顶，这样作用在结构上的弯曲力为[2.x.4]；在大多数物理情况下，我们会有[2.x.5]，对应于结构只是坐在墙顶。
* 在边界值的第二种可能情况下，我们将有
* [1.x.42]
* 这相当于一个 "夹紧 "的结构，非零的[2.x.6]意味着与水平面有一定的角度。
* 正如拉普拉斯方程的迪里切特和诺依曼边界条件一样，当然也可以在边界的一部分有一种边界条件，而在另一部分有另一种边界条件。
* 

*[1.x.43][1.x.44]
* 

* 该方程的基本问题是，它需要解的四次方。在我们在[2.x.7]、[2.x.8]和其他几个教程中处理的拉普拉斯方程的情况下，一个人乘以一个测试函数，进行积分，通过部分积分，最后在测试函数和试验函数上都只得到一个导数
* 
* - 这是对全局连续的函数可以做的，但在单元间的界面上可能有结点。导数可能不是在界面上定义的，但那是在一个低维流形上（因此不会显示在积分值中）。
* 但是对于双调方程来说，如果按照同样的程序，用整个域（即所有单元的联盟）的积分来计算，最终会有两个导数在测试函数和试用函数上。如果使用通常的片断多项式函数，并在单元格界面上有结点，则第一个导数将产生一个不连续的梯度，第二个导数将在界面上撤消θ函数。
* 
* 但由于测试函数和试验函数的二次导数都产生了德尔塔函数，我们将尝试整合两个德尔塔函数的乘积。例如，在1d中，[2.x.9]是通常的线性 "帽子函数"，我们会得到这样的积分
* [1.x.45]
* 其中[2.x.10]是定义形状函数[2.x.11]的节点位置，[2.x.12]是网格大小（假定为均匀的）。问题是，积分中的delta函数是用以下关系定义的
* [1.x.46]
* 但这只有在以下情况下才有效：(i) [2.x.13]实际上在[2.x.14]处定义良好，以及(ii)它是有限的。另一方面，一个积分的形式为
* [1.x.47]
*是没有意义的。类似的推理可以适用于2d和3ds的情况。
* 换句话说。这种试图在整个域上进行积分然后再通过部分积分的方法是行不通的。
* 历史上，数值分析家试图通过发明 "C<sup>1</sup>连续 "的有限元来解决这个问题，也就是说，使用的形状函数不仅是连续的，而且还有连续的一导数。这是诸如Argyriselement、Clough-Tocher元素和其他元素的领域，这些元素都是在20世纪60年代末开发的。从二十一世纪的角度来看，它们的结构只能说是怪异的。如果想使用一般的网格，它们的实现也是非常麻烦的。因此，它们在很大程度上已经失去了作用，目前deal.II并不包含这些形状函数的实现。
* 

* [1.x.48][1.x.49] 。
* 

* 那么，如何解决这些问题呢？这取决于边界条件。如果有第一组边界条件，即，如果方程是
* [1.x.50]
* 那么下面的窍门就会起作用（至少如果域是凸的，见下文）。就像我们通过引入第二个变量从常规拉普拉斯方程得到[2.x.15]的混合拉普拉斯方程一样，我们可以在这里引入一个变量[2.x.16]，然后可以用下面的 "混合 "系统代替上面的方程。
* [1.x.51]
* 换句话说，我们最终得到的实质上是[2.x.17]的两个耦合拉普拉斯方程系统，每个方程都有迪里希勒型边界条件。我们知道如何解决这样的问题，使用[2.x.18]或[2.x.19]的技术为这个系统构造良好的求解器和预处理器应该不是很困难。因此，这个案例的处理非常简单。
* [2.x.20] 值得指出的是，这只适用于边界有角的域，如果该域也是凸形的话
* 
*--换句话说，如果没有重入角的话。 这听起来是一个相当随意的条件，但考虑到以下两个事实，它是有意义的。原始双调方程的解必须满足 [2.x.21] 。另一方面，上面的混合系统重述表明，[2.x.22]和[2.x.23]都满足[2.x.24]，因为这两个变量只解决一个泊松方程。换句话说，如果我们想保证混合问题的解[2.x.25]也是原来的偏谐方程的解，那么我们需要能够以某种方式保证[2.x.26]的解实际上比只是[2.x.27]更平滑。这一点可以作如下论证。对于凸域，[1.x.52]意味着，如果右侧[2.x.28]，那么[2.x.29]如果域是凸的并且边界足够光滑。(如果域的边界足够光滑，这也可以保证
* 
* - 但边界没有角的域在现实生活中并不十分实用）。)  我们知道[2.x.30]，因为它解决了方程[2.x.31]，但我们仍然留下了边界凸性的条件；我们可以证明多边形、凸形域在这种情况下足以保证[2.x.32]（光滑有界的凸形域将导致[2.x.33]，但我们不需要这么多规则性）。另一方面，如果域不是凸的，我们不能保证混合系统的解在[2.x.34]中，因此可能得到一个不能等于原始双调方程的解。
* 更复杂的情况是，如果我们有 "钳制 "的边界条件，也就是说，如果方程看起来像这样。
* [1.x.53]
* 混合系统的相同技巧在这里不起作用，因为我们最终会对[2.x.35]设定迪里切特和诺伊曼边界条件，但对[2.x.36]则没有。
* 

* 在20世纪90年代和21世纪初，这一难题的解决方案随着非连续加尔金法的出现而到来。与使用[1.x.55]形状函数处理拉普拉斯方程一样，我们可以使用[1.x.56]（而不是[2.x.37]连续）形状函数的方案，通过惩罚不连续的大小来获得每个形状函数上有一个导数的方程的方案，从而获得一个每个形状函数上有两个导数的方案。与拉普拉斯方程的内部惩罚（IP）方法类似，这个用于双调方程的方案通常被称为[2.x.38]IP（或C0IP）方法，因为它使用[2.x.39]（连续但不可连续微分的）形状函数和内部惩罚公式。
* 

*[1.x.57][1.x.58]。
* 

* 我们以SusanneBrenner和Li-Yeng Sung在 "C [2.x.41] Interior Penalty Methodfor Linear Four Order Boundary Value Problems on polygonaldomains"[2.x.42]一文中提出的[2.x.40]IP方法为基础，该方法是针对具有 "钳制 "边界条件的双谐波方程提出的。
* 如前所述，该方法依赖于使用[2.x.43]Lagrange有限元，其中[2.x.44]的连续性要求被放宽并被内部惩罚技术取代。为了推导这个方法，我们考虑一个[2.x.45]形状函数[2.x.46]，它在[2.x.47]上消失。我们引入符号[2.x.48]作为[2.x.49]的所有面的集合，[2.x.50]作为边界面的集合，而[2.x.51]作为内部面的集合，以便在下面进一步使用。 的高阶导数在每个界面[2.x.53]上有两个值（由两个单元[2.x.54]共享），我们通过在[2.x.55]上定义以下单值函数来应对这一不连续性。
* [1.x.59]
*用于[2.x.56]（即用于梯度和次导数矩阵），其中[2.x.57]表示指向[2.x.58]的单位向量法线，从[2.x.59]指向[2.x.60]。在文献中，这些函数分别被称为 "跳跃 "和 "平均 "操作。
* 为了得到[2.x.61]的IP近似值[2.x.62]，我们用[2.x.63]乘以双谐波方程，然后对[2.x.64]进行积分。如上所述，我们不能用这些形状函数对[2.x.65]的所有部分进行积分，但我们可以对每个单元单独进行积分，因为形状函数只是每个单元的多项式。因此，我们首先在每个网格单元[2.x.66]上使用下面的分部分项积分公式。
* [1.x.60]
* 在这一点上，我们有两个选择。我们可以对域项的[2.x.67]再进行一次积分，得到
* [1.x.61]
* 由于各种原因，这被证明是一个对我们的目的无用的变化。
* 相反，我们所做的是承认[2.x.68]，我们可以将这些操作重新排序为[2.x.69]，通常写成[2.x.70]，以表明这是第二导数的 "黑森 "矩阵。通过这样的排序，我们现在可以整合发散，而不是梯度算子，我们得到以下结果。
* [1.x.62]
* 这里，冒号表示对其左边和右边的矩阵指数的双重收缩，即两个张量之间的标量乘积。两个向量[2.x.71]的外积产生了矩阵[2.x.72]。
* 然后，我们对所有单元格[2.x.73]进行求和，并考虑到这意味着每个内部面在求和中出现两次。因此，如果我们把所有的东西分成细胞内部的积分之和和细胞界面的单独之和，我们就可以使用上面定义的跳跃和平均运算符。还有两个步骤。首先，由于我们的形状函数是连续的，形状函数的梯度可能是不连续的，但是连续性保证了实际上只有梯度的法向分量在各面是不连续的，而切向分量是连续的。第二，当网格大小为零时，所产生的离散公式是不稳定的，为了得到一个稳定的公式，收敛到正确的解，我们需要添加以下条款。
* [1.x.63]
* 然后，在对出现的情况进行抵消后，我们得到以下双调子方程的C0IP表述：找到[2.x.74]，使[2.x.75]在[2.x.76]上，并且
* [1.x.64]
*其中
* [1.x.65]
*和
* [1.x.66]
* 这里，[2.x.77]是惩罚参数，它既弱化了边界条件的执行力
* [1.x.67]
*在边界界面[2.x.78]上，也确保在极限[2.x.79]中，[2.x.80]收敛为[2.x.81]连续函数。 [2.x.82]被选择为足够大，以保证方法的稳定性。我们将在下面的程序中讨论我们的选择。
* 

*[1.x.68][1.x.69]。
* 在多边形域上，双调方程的弱解[2.x.83]存在于[2.x.84]中，其中[2.x.85]是由[2.x.86]的角的内角决定的。例如，只要[2.x.87]是凸的，[2.x.88]；[2.x.89]可能小于1，如果域有重心的角，但如果所有内角之一接近[2.x.92]，[2.x.90]就接近于[2.x.91] 。
* 现在假设[2.x.93]的IP解[2.x.94]被[2.x.95]的形状函数以多项式程度[2.x.96]所近似。那么，上述的解算就会产生下面所讨论的收敛率。
* 

* [1.x.70]
* 理想情况下，我们希望在 "能量准则 "中测量收敛性 [2.x.97] 。然而，这并不可行，因为同样，离散解[2.x.98]并没有两个（弱）导数。相反，我们可以定义一个离散([2.x.99] IP)半规范，"等同于 "能量规范，如下所示。
* [1.x.71]
* 
* 在这个半规范中，上面提到的论文中的理论得出，我们可以期望
* [1.x.72]
* 与我们所知道的拉普拉斯方程的通常离散化的收敛率一样。
* 当然，只有在精确解足够光滑的情况下，这才是真的。事实上，如果[2.x.100]中有[2.x.101]，[2.x.102]中有[2.x.103]，那么[2.x.104]IP方法的收敛率为[2.x.105]。换句话说，只有在解非常平滑的情况下，才能期望达到最佳收敛率[2.x.106]；如果(i)域是凸的，有足够平滑的边界，以及(ii)[2.x.107]，这种情况就会发生。当然，在实践中，解决方案是什么就是什么（与我们选择的多项式程度无关），那么最后一个条件可以等同于说，如果[2.x.109]也不大，那么选择[2.x.108]大就肯定没有意义。换句话说，[2.x.110]的唯一合理选择是[2.x.111]，因为更大的多项式度数不会导致更高的收敛顺序。
* 就本程序而言，我们有点懒得去实际实现这个等价的语义准则。
* 
* 尽管这并不难，而且会成为一个很好的练习。相反，我们将在程序中简单地检查一下 "破碎的"[2.x.112]语义规范是什么？
* [1.x.73]
*产生的结果。从理论上看，这个准则的收敛率当然不会比[2.x.113]的收敛率高[1.x.74]，因为它只包含必要条件的一个子集，但至少可以想象到它会更好。还有一种情况是，即使程序中存在一个错误，我们也能得到最佳收敛率，而这个错误只会在[2.x.114]中出现的额外条款中显示出次优的收敛率。但是，人们可能希望，如果我们在破碎规范和下面讨论的规范中得到最优速率，那么这个程序确实是正确的。结果部分将证明我们在所有所述的规范中都得到了最优率。
* 

* [1.x.75]
* 在[2.x.115]规范中的最佳收敛率是[2.x.116]提供的[2.x.117]。更多细节可以在 [2.x.118] 的定理4.6中找到。
* 在下面的程序中，默认是选择[2.x.119]。在这种情况下，该定理并不适用，事实上，人们只能得到[2.x.120]而不是[2.x.121]，我们将在结果部分展示。
* 

* [1.x.76]
* 鉴于我们在最好的情况下期望[2.x.122]等同于[2.x.123]半规则的规范，以及[2.x.125]规范的[2.x.124]，我们可能会问在[2.x.126]半规则中会发生什么，这是与其他两个规范的中间位置。一个合理的猜测是，我们应该期待[2.x.127]。可能在某个地方有一篇论文证明了这一点，但是我们也验证了这个猜想在实验中是真实的。
* 

* 
* [1.x.77][1.x.78] 。
* 

* 我们注意到，[2.x.128]IP方法对具有其他边界条件的双谐波方程的推导是这样的
* 
* - 例如，对于第一组边界条件，即[2.x.129]和[2.x.130]的[2.x.131]的边界条件 
* 
* 可以通过对书中[2.x.132]和[2.x.133]的适当修改得到。
* 

* [1.x.79][1.x.80] 。
* 

* 最后一步要描述的是这个程序解决的问题。一如既往，三角函数既是一个好的选择，也是一个坏的选择，因为它不在任何我们可以寻求解的多项式空间中，同时又比实数解通常更平滑（在这里，它在[2.x.135]中，而实数解通常只在[2.x.136]左右的凸多边形域中，如果域不是凸的，则在[2.x.137]和[2.x.138]之间）。但是，由于我们没有办法用相对简单的公式来描述现实问题的解决方案，我们只是用下面的方法，在域[2.x.139]的单位平方上。
* [1.x.81]
* 因此，我们需要选择以下条件作为边界条件。
* [1.x.82]
* 右手边很容易计算为
* [1.x.83]
* 该程序有类[2.x.140]和[2.x.141]，对这些信息进行编码。
* 

* [1.x.84] [1.x.85]。
* [1.x.86] [1.x.87].
 

* 
* 前面几个include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。该程序的主要结构与例如[2.x.142]的结构非常相似，因此我们包含了许多相同的头文件。
* 

* 
*  

* 
* [1.x.88]
 
* 两个最有趣的头文件将是这两个。
* 

* 
* [1.x.89]
* 
* 其中第一个文件负责提供FEInterfaceValues类，该类可用于评估单元间界面的形状函数（或其梯度）的跳跃或平均值等数量。这个类在评估C0IP公式中出现的惩罚项时相当有用。
* 

* 
*  
*  
* 

 
* [1.x.90]
 
* 在下面的命名空间中，让我们定义精确解，我们将与数值计算的解进行比较。它的形式是[2.x.143]（只实现了2d的情况），该命名空间还包含一个对应于产生该解的右手边的类。
* 

* 
* [1.x.91]
 
* [1.x.92] [1.x.93]   
* 以下是本教程程序的主要类别。它具有许多其他教程程序的结构，其内容和后面的构造函数应该没有什么特别令人惊讶的地方。
* 

* 
* [1.x.94]
 
* 接下来是创建初始网格（一次精炼的单元格）和设置每个网格的约束、向量和矩阵的函数。同样，这两个函数与以前的许多教程程序基本没有变化。
* 

* 
* [1.x.95]
* 
* [1.x.96] [1.x.97] 。  
* 下面的代码更有趣。它们都与线性系统的装配有关。虽然组装单元格内部条款的难度不大
* 
* - 这在本质上就像拉普拉斯方程相应项的装配，你已经在[2.x.144]或[2.x.145]中看到了这是如何工作的，比如说
* 
* - 困难在于公式中的惩罚项。这需要在单元格的界面上评估形状函数的梯度。因此，至少需要使用两个FEFaceValues对象，但如果其中一个面是自适应细化的，那么实际上需要一个FEFaceValues和一个FESubfaceValues对象；我们还需要跟踪哪些形状函数在哪里，最后我们需要确保每个面只被访问一次。所有这些对于我们真正想要实现的逻辑（即双线性形式中的惩罚项）来说都是一笔不小的开销。因此，我们将使用FEInterfaceValues类。
* 
* - deal.II中的一个辅助类，它允许我们抽象出两个FEFaceValues或FESubfaceValues对象，直接访问我们真正关心的东西：跳跃、平均数等。  
* 但这还没有解决我们的问题，即当我们在所有单元格和它们的所有面中循环时，必须跟踪我们已经访问过哪些面。为了使这个过程更简单，我们使用了[2.x.146]函数，它为这个任务提供了一个简单的接口：基于WorkStream命名空间文档中概述的想法，[2.x.147]需要三个函数对单元、内部面和边界面进行工作。这些函数在scratch对象上工作以获得中间结果，然后将其计算结果复制到copy数据对象中，由copyer函数将其复制到全局矩阵和右侧对象中。  
* 下面的结构就提供了这种方法所需的从头开始和复制对象。你可以查阅WorkStream命名空间以及[2.x.148]"多处理器的并行计算 "模块，以了解更多关于它们通常如何工作的信息。
* 

* 
* [1.x.98]
 
* 更有趣的部分是我们实际组装线性系统的地方。从根本上说，这个函数有五个部分。
 

* 
* 
* - 定义`cell_worker'λ函数，这是一个定义在`assemble_system()'函数中的小函数，它将负责计算单个单元的局部积分。它将在 "ScratchData "类的副本上工作，并将其结果放入相应的 "CopyData "对象。
* 

* 
* 
* - `face_worker'lambda函数的定义，它将对单元格之间界面上的所有项进行积分。
* 

* 
* 
* - 定义了`boundary_worker`函数，对位于域的边界上的单元面做同样的工作。
* 

* 
* 
* - `copier`函数的定义，负责将前面三个函数为单个单元格放入复制对象的所有数据复制到全局矩阵和右侧。  
* 第五部分是我们把所有这些都集中在一起。  
* 让我们轮流浏览一下这些组装所需的每一块。
* 

* 
* [1.x.99]
 
* 第一个部分是`cell_worker`，它在细胞内部进行装配。它是一个（lambda）函数，接受一个单元（输入）、一个scratch对象和一个拷贝对象（输出）作为参数。它看起来像许多其他教程程序的装配函数，或者至少是在所有单元上的循环主体。    
*我们在这里整合的术语是单元格的贡献

* 
* [1.x.100]
* 对全局矩阵的贡献，以及

* 
* [1.x.101]
* 到右手边的向量。    
* 我们使用与组装[2.x.149]时相同的技术来加速该函数。我们不在最里面的循环中调用`fe_values.shape_hessian(i, qpoint)`，而是创建一个变量`hessian_i`，在循环中对`i`进行一次评估，在循环中对`j`重新使用如此评估的值。为了对称，我们对变量`hessian_j`也做了同样的处理，尽管它确实只用了一次，而且我们可以在计算两个项之间标量乘积的指令中留下对`fe_values.shape_hessian(j,qpoint)`的调用。
* 

* 
* [1.x.102]
* 
* 下一个构建模块是在网格的每个内部面组装惩罚项。正如在[2.x.150]的文档中所描述的，这个函数收到的参数表示一个单元和它的相邻单元，以及（对于这两个单元中的每一个）我们需要整合的面（和可能的子面）。同样，我们也得到了一个Scratch对象，以及一个用于放置结果的copy对象。    
* 这个函数本身有三个部分。在顶部，我们初始化FEInterfaceValues对象，并创建一个新的[2.x.151]对象来存储我们的输入。这将被推到`copy_data.face_data`变量的末尾。我们需要这样做，因为我们对一个给定单元进行积分的面（或子面）的数量因单元而异，而且这些矩阵的大小也不同，取决于面或子面相邻的自由度。正如[2.x.152]文档中所讨论的，每次访问一个新的单元时，复制对象都会被重置，所以我们推到`copy_data.face_data()`末尾的内容实际上就是后来的`copier`函数在复制每个单元的贡献到全局矩阵和右侧对象时所能看到的全部内容。
* 

* 
* [1.x.103]
* 
* 第二部分涉及到确定惩罚参数应该是什么。通过观察双线性形式中各种项的单位，很明显，惩罚必须具有[2.x.153]的形式（即一个超过长度尺度的惩罚），但应该如何选择无维数[2.x.154]并不是先验的。从拉普拉斯方程的不连续Galerkin理论来看，人们可能猜想正确的选择是[2.x.155]是正确的选择，其中[2.x.156]是所用有限元的多项式程度。我们将在本程序的结果部分更详细地讨论这个选择。      
* 在上面的公式中，[2.x.157]是单元格[2.x.158]的大小。但这也不是很直接的事情。如果使用高度拉伸的单元格，那么一个更复杂的理论说，[2.x.159]应该被单元格[2.x.160]的直径取代，该直径是有关边缘方向的法线。 事实证明，在deal.II中有一个函数用于此。其次，当从一个面的两个不同侧面看时，[2.x.161]可能是不同的。      
* 为了安全起见，我们取这两个值的最大值。我们将注意到，如果使用自适应网格细化产生的悬空节点，这个计算有可能需要进一步调整。
* 

* 
* [1.x.104]
 
* 最后，像往常一样，我们在正交点和指数`i`和`j`上循环，把这个面或子面的贡献加起来。然后将这些数据存储在上面创建的`copy_data.face_data`对象中。至于单元格工作者，如果可能的话，我们将平均数和跳跃的评估从循环中拉出来，引入局部变量来存储这些结果。然后组件只需要在最里面的循环中使用这些局部变量。关于这段代码实现的具体公式，回顾一下，双线性形式的接口条款如下。

* 
* [1.x.105]
* 
* 

* 
* [1.x.106]
* 
* 第三部分是对处于边界的面做同样的装配。当然，想法和上面一样，唯一不同的是，现在有惩罚条款也进入了右手边。    
* 和以前一样，这个函数的第一部分只是设置了一些辅助对象。
* 

* 
* [1.x.107]
* 
* 积极地，因为我们现在只处理与面相邻的一个单元（因为我们在边界上），惩罚因子[2.x.162]的计算大大简化了。
* 

* 
* [1.x.108]
* 
* 第三块是条款的组合。由于这些条款包含了矩阵和右手边的条款，所以现在稍微有点麻烦了。前者与上面所说的内部面完全相同，如果我们只是适当地定义跳跃和平均（这就是FEInterfaceValues类的作用）。后者需要我们评估边界条件[2.x.163]，在当前情况下（我们知道确切的解决方案），我们从[2.x.164]中计算出来。然后，要添加到右侧向量的项是 [2.x.165] 。
* 

* 
* [1.x.109]
* 
* 第四部分是一个小函数，它将上面的单元格、内部和边界面装配程序产生的数据复制到全局矩阵和右手向量中。这里真的没有什么可做的。我们分配单元格矩阵和右侧贡献，就像我们在其他几乎所有的教程程序中使用约束对象那样。然后，我们还必须对面矩阵的贡献做同样的处理，这些贡献已经获得了面（内部和边界）的内容，并且`面_工作`和`边界_工作`已经添加到`copy_data.face_data`数组中。
* 

* 
* [1.x.110]
* 
* 在设置了所有这些之后，剩下的就是创建一个scratch和copy数据对象，并调用[2.x.166]函数，然后翻阅所有的单元格和面，调用它们各自的worker，然后是copyer函数，将东西放入全局矩阵和右侧。作为一个额外的好处，[2.x.167]以并行方式完成所有这些工作，使用你的机器恰好有多少个处理器核心。
* 

* 
* [1.x.111]
* 
* [1.x.112] [1.x.113]。  
* 到此为止，演出基本上结束了。其余的函数并不太有趣或新颖。第一个函数只是用一个直接求解器来求解线性系统（也见[2.x.168] ）。
* 

* 
* [1.x.114]
 
* 下一个函数评估了计算出的解和精确解之间的误差（在这里是已知的，因为我们选择了右手边和边界值的方式，所以我们知道相应的解）。在下面的前两个代码块中，我们计算了[2.x.169]准则和[2.x.170]半准则的误差。
* 

* 
* [1.x.115]
* 
* 现在也计算一下[2.x.171]半规范误差的近似值。实际的[2.x.172]半规范要求我们对解[2.x.173]的二阶导数进行积分，但考虑到我们使用的拉格朗日形状函数，[2.x.174]当然在单元间的界面上有结点，因此二阶导数在界面上是奇异的。因此，我们实际上只对单元的内部进行积分，而忽略了界面的贡献。这不是*一个与问题的能量准则等价的准则，但仍然给了我们一个关于误差收敛速度的概念。    
* 我们注意到，我们可以通过定义一个等同于能量准则的准则来解决这个问题。这将涉及到不仅要像我们下面所做的那样将细胞内部的积分相加，而且还要为[2.x.175]的导数在界面上的跳跃添加惩罚项，并对这两种项进行适当的缩放。我们将把这个问题留给以后的工作。
* 

* 
* [1.x.116]
 
* 同样无趣的是生成图形输出的函数。它看起来和 [2.x.176] 中的一模一样，比如说。
* 

* 
* [1.x.117]
* 
* `run()`函数的情况也是如此。就像在以前的程序中一样。
* 

* 
* [1.x.118]
* 
* [1.x.119] [1.x.120]。
 

* 
* 最后是 "main() "函数。同样，这里没有什么可看的。它看起来和以前的教程程序中的一样。有一个变量，可以选择我们要用来解方程的元素的多项式程度。因为我们使用的C0IP公式要求元素的度数至少为2，所以我们用一个断言来检查，无论为多项式度数设置什么都是有意义的。
* 

* 
* [1.x.121]
* [1.x.122][1.x.123] 。
* 

* 我们在运行程序时，使用介绍中讨论过的右手和边界值。我们用[2.x.179], [2.x.180], 和[2.x.181]元素来测试这个设置，我们可以通过`main()`函数中的`fe_degree`变量来改变这些元素。通过网格精简，[2.x.182]的收敛率、[2.x.183]的近似值收敛率和[2.x.184]的近似值收敛率对于[2.x.186]应该是2、2、1左右（如介绍中所讨论的[2.x.187]的规范次优）；对于[2.x.188]是4、3、2；而对于[2.x.189]是5、4、3。
* 从文献中，并不清楚惩罚参数[2.x.190]应该是什么。例如，[2.x.191]指出它需要大于1，并选择了[2.x.192]。FEniCS/Dolphin教程选择了它为[2.x.193]，见https://fenicsproject.org/docs/dolfin/1.6.0/python/demo/documented/biharmonic/python/documentation.html。 [2.x.194]使用的[2.x.195]值大于Kirchhoff板的元素所属的边数（见第4.2节）。这表明也许[2.x.196]、[2.x.197]太小了；另一方面，[2.x.198]的值也是合理的，其中[2.x.199]是多项式的度。最后一个选择是人们期望通过比较拉普拉斯方程的不连续Galerkin公式来实现的(例如，见[2.x.200]和[2.x.201]中的讨论)。 但是我们应该检查一下[2.x.202]的值是多少，我们将在下面进行；改变[2.x.203]在`assemble_system()`定义的两个`face_worker`和`boundary_worker`函数中很容易。
* 

* [1.x.124][1.x.125][1.x.126][1.x.127]
* 

* 我们用不同的细化网格运行代码，得到以下收敛率。
* [2.x.204] 我们可以看到，[2.x.205]的收敛率约为2，[2.x.206] -seminorm收敛率约为2，而[2.x.207] -seminorm收敛率约为1。
* 

* [1.x.128][1.x.129][1.x.130][1.x.131]
* 

* 
* [2.x.208] 我们可以看到，[2.x.209]的收敛率约为4，[2.x.210] -seminorm收敛率约为3，[2.x.211] -seminorm收敛率约为2.当然，这与我们的理论预期相符。
* 

* [1.x.132][1.x.133][1.x.134][1.x.135]
* 

* [2.x.212] 我们可以看到[2.x.213]规范收敛率约为5，[2.x.214] -seminorm收敛率约为4，[2.x.215] -seminorm收敛率约为3。在最细的网格上，[2.x.216] 规范收敛率比我们的理论预期小很多，因为线性求解器由于舍弃而成为限制因素。当然，在这种情况下，[2.x.217]误差也已经非常小了。
* 

* [1.x.136][1.x.137][1.x.138][1.x.139]
* 

* 为了与上述结果进行比较，现在让我们也考虑一下我们简单地选择[2.x.218] 的情况。
* [2.x.219] 虽然[2.x.220]的规范收敛率或多或少符合理论预期，但[2.x.222] -seminorm和[2.x.223] -seminorm似乎并没有像预期那样收敛。 鉴于[2.x.227]对于[2.x.228]元素来说已经太小了，如果用[2.x.229]元素重复实验，结果更加令人失望，这可能并不令人惊讶。我们又一次只得到了2、1、0的收敛结果。
* 
* 然而，也许令人惊讶的是，当使用[2.x.231]元素时，人们获得了或多或少的预期收敛顺序。无论如何，这种不确定性表明[2.x.232]充其量是一个有风险的选择，在最坏的情况下是一个不可靠的选择，我们应该选择[2.x.233]更大。
* 

* [1.x.140][1.x.141][1.x.142][1.x.143]
* 

* 由于[2.x.234]显然太小，人们可能猜想[2.x.235]实际上可能效果更好。以下是在这种情况下得到的结果。
* [2.x.236] 在这种情况下，收敛率或多或少符合理论预期，但与[2.x.237]的结果相比，变化更大。同样，我们可以对[2.x.238]和[2.x.239]元素重复这种实验。在这两种情况下，我们都会发现我们获得了大致上的预期收敛率。那么，更有趣的是比较误差的绝对大小。在上表中，对于[2.x.240]情况，最细网格上的误差在[2.x.241]和[2.x.242]情况之间是可比的，而对于[2.x.243]，[2.x.244]的误差比[2.x.245]大很多。对于[2.x.246]的情况也是如此。
* 

* [1.x.144][1.x.145] 。
* 

* 关于应该使用哪种 "合理 "的惩罚参数选择的结论是，[2.x.247]会产生预期的结果。因此，这就是目前编写的代码所使用的。
* 

* [1.x.146][1.x.147] 。
* 

* 这个程序有许多明显的扩展是有意义的。
* 
* - 该程序使用一个正方形域和一个均匀的网格。真正的问题不是这样的，我们应该在其他形状的域上验证收敛性，特别是在弯曲的边界上。人们也可能对使用自适应网格细化来解决规则性较差的区域感兴趣。
* 
* - 从更多的理论角度来看，上面的收敛结果只使用了 "破碎的"[2.x.248]半规范[2.x.249]，而不是 "等效的 "规范[2.x.250] 。这足以让我们相信，这个程序并没有从根本上被破坏。然而，测量我们有理论结果的实际规范的误差可能是有趣的。例如，使用FEInterfaceValues类与[2.x.251]结合，实现这一补充应该不会太困难，其精神与我们用于装配线性系统的精神相同。
* 

* [1.x.148] [1.x.149]。
* 

* 类似于实施中解决的 "夹持 "边界条件，我们将推导出[2.x.252]IP有限元方案，用于简单支撑的板。
* [1.x.150]
* 我们用测试函数[2.x.253]乘以偏谐方程，并对[2.x.254]进行积分，得到。
* [1.x.151]
* 
* 在所有单元格[2.x.255]上求和，因为[2.x.256]的法线方向在两个单元格和[2.x.257]共享的每条内边上指向相反方向。
* [1.x.152]
*根据单元格界面上的跳跃定义。
* [1.x.153]
* 我们把域的内部面和边界面分开。
* [1.x.154]
*其中[2.x.259]是内部面的集合。 这使我们得出 
* [1.x.155]
* 
*为了使离散问题对称化和稳定化，我们加入了对称化和稳定化项。 我们最终得到双调方程的[2.x.260]IP有限元方案：找到[2.x.261]，使[2.x.262]对[2.x.263]和 
* [1.x.156]
*其中 
* [1.x.157]
*和 
* [1.x.158]
* 这个边界案例的实现与 "钳制 "版本类似，只是在系统装配时不再需要`边界_工人'，并且根据配方改变右手边。
* 

* [1.x.159][1.x.160] [2.x.264] 。
* [0.x.1]

