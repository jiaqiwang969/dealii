include/deal.II-translator/A-tutorial/step-51_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.4] 
* [1.x.39]
* [1.x.40][1.x.41][1.x.42] 。
* 

* 本教程程序介绍了对流-扩散方程的混合非连续Galkerin方法的实现。
* [1.x.43][1.x.44] 。
* 

* 反对使用非连续Galerkin元素的一个常见论点是，在隐式系统中必须解决大量的全局耦合自由度。 这是因为，与连续有限元不同，在典型的非连续元中，每个顶点都有一个自由度[1.x.45]，而不是只有一个，同样，边和面也是如此。 作为未知数增长速度的一个例子，考虑FE_DGPMonomial基础：每个标度解分量都由[2.x.5]度的多项式表示，每个元素有[2.x.6]个自由度。通常情况下，一个元素的所有自由度都与相邻元素的所有自由度相耦合。 由此产生的离散方程很快就会产生非常大的线性系统，特别是对于2或3维的方程系统。
*[1.x.46][1.x.47]
* 为了减轻解决这些大型线性系统的计算成本，Cockburn和同事们提出了可混合的非连续Galerkin（HDG）方法（见Nguyen和Peraire最近发表的HDG概述文章中的参考文献[2.x.7]）。
* HDG方法通过使用Dirichlet-to-Neumann映射制定数学问题来实现这一目标。 偏微分方程首先被写成一阶系统，然后通过DG方法将每个场离散化。 在这一点上，网格骨架上的单值 "跟踪 "值，即元素面，被视为独立的未知量。这在离散表述中产生的未知量分为两类。
* 
* - 面未知数，只与面的两侧的单元未知数耦合。
* 
* - 单元未知数，只与定义在同一单元内的单元和面的未知数耦合。最重要的是，一个单元的内部自由度不会与另一个单元的任何内部自由度相耦合。
* Dirichlet-to-Neumann地图的概念允许以下求解过程。[2.x.8] [2.x.9] 使用局部元素内部数据来强制执行三角结构的诺依曼条件。 然后，全局问题是求解轨迹值，这是唯一全局耦合的未知数。  [2.x.10] 使用已知的骨架值作为Dirichlet数据来求解局部元素级的解决方案。 这被称为 "局部求解器"，是一个[1.x.48]逐个元素的求解过程。[2.x.11] 
*[1.x.49][1.x.50]
* 上述程序也有一个线性代数的解释--被称为[1.x.51]--被Guyan在连续有限元[2.x.12]和Fraeijs de Veubeke在混合方法[2.x.13]的背景下利用来减少全球线性系统的大小。在后一种情况下（混合公式），系统的减少是通过使用不连续的通量与引入额外的辅助变量[1.x.52]来实现的，该变量近似于每个元素边界上的未知数的轨迹。这个过程被称为混合化，并通过类比，是Cockburn、Gopalakrishnan和Lazarov在2009年引入的局部不连续Galerkin方法[2.x.14]的原因，随后他们的合作者又开发了这种方法，最终被称为[1.x.53]（HDG）方法。
* 让我们把与HDG问题相关的完整线性系统写成一个块状系统，离散DG（单元内部）变量[2.x.15]为第一块，骨架（面）变量[2.x.16]为第二块：[1.x.54] 。
* 我们现在的目标是用类似于[2.x.18]的Schur补足法来消除[2.x.17]块，这将导致以下两个步骤：[1.x.55] 。
* 重点是[2.x.19]的存在不是问题，因为[2.x.20]是一个块对角线矩阵，每个块对应一个单元，因此很容易反转。与其他单元的耦合是由骨架变量上的矩阵[2.x.21]和[2.x.22]引入。[2.x.23]的块对角性以及[2.x.24]和[2.x.25]的结构使我们能够逐元反转矩阵[2.x.26]（迪里希勒问题的局部解）并从[2.x.28]中减去[2.x.27]。因此，Dirichlet-to-Neumannmap概念的步骤对应于[2.x.29] [2.x.30]构建Schur互补矩阵[2.x.31]和右手边[2.x.32] [1.x.56 ]并以通常的方式将贡献插入全局跟踪矩阵，[2.x.33]求解舒尔互补系统[2.x.34]，[2.x.35]使用第二个方程求解[2.x.36]，给出[2.x.37] 。[2.x.38] 
* 

* [1.x.57][1.x.58] 。
* 对传统DG方法的另一个批评是，近似通量的转换是次优的。 局部HDG解决方案可以被证明是收敛的[2.x.39]，即以最优顺序收敛。 此外，超级收敛特性可以用来对新的近似解进行后处理，以[2.x.40]的速率收敛。
* 

*[1.x.59][1.x.60] 。
* 

* 可混合的非连续Galerkin方法只是解决非连续Galerkin方法问题的一种方法。另一个想法是所谓的 "弱Galerkin "方法。它在[2.x.41]中进行了探讨。
* 

* [1.x.61][1.x.62] 。
* 

* 本例中使用的HDG公式取自[2.x.42] [1.x.63][1.x.64][1.x.65] 。
* 我们考虑域[2.x.43]上的对流-扩散方程，其边界为Dirichlet边界[2.x.44]和Neumann边界[2.x.45] ：[1.x.66]
* 
* 引入辅助变量[2.x.46]，将上述方程改写为一阶系统：[1.x.67] 。
* 
* 我们将这些方程乘以权重函数[2.x.47]，并对每个元素[2.x.48]进行部分积分，得到：[1.x.68] 。
* 
* 带帽子的条款表示数值轨迹（通常也被称为数值通量）。 它们是对元素边界上的内部值的近似。 为了确保守恒，这些项必须是任何给定元素边缘的单值[2.x.49]，尽管对于不连续的形状函数，当然可能有来自界面附近单元的多个值。我们通过使用以下形式的迹线消除数值迹线[2.x.50]：[1.x.69]
* 
* 变量[2.x.51]是作为一个额外的独立变量引入的，是我们最终建立一个全局耦合线性系统的变量。如上所述，它被定义在元素面上，并且在面与面的交汇处（2D中的顶点，3D中的边和顶点），从一个面到另一个面是不连续的。
* 局部稳定参数[2.x.55]对HDG解的稳定性和准确性有影响；进一步的讨论见文献。据报道，稳定参数为1是给出最佳结果的选择。趋向于无穷大的稳定参数[2.x.56]禁止在元素边界上的解决方案的跳跃，使HDG解决方案接近于连续有限元素的近似值。在下面的程序中，我们选择稳定参数为[1.x.70] 。
* 我们将扩散[2.x.57]和扩散长度尺度设置为[2.x.58] 。
* HDG方法中的轨迹/骨架变量在元素面上是单值的。 因此，它们必须强有力地代表[2.x.59]上的迪里希特数据。 这意味着[1.x.71]。
* 其中等号实际上是指边界函数[2.x.61]对面变量空间的[2.x.60]投影（例如面的线性函数）。然后，这个约束被应用于骨架变量[2.x.62]，使用非均质约束的方法[2.x.63]。
* 将三角结构中所有元素的分量相加，强制执行数值通量的法向分量，并对由[2.x.64]加权的方程进行部分积分，我们得出问题的最终形式：找到[2.x.65]，以便
* [1.x.72]
 
* 未知数[2.x.66]被称为局部变量；它们被表示为标准DG变量。 未知数[2.x.67]是骨架变量，在网格的一维表面（面）上有支持。
* 我们用[2.x.68]表示所有单元的积分之和，[2.x.69]表示所有单元的所有面的积分，也就是说，内部面被访问两次，每边一次，并有相应的法向量。当结合共享一个面的两个元素的贡献时，上述方程产生了DG方法中熟悉的条款，在单元格边界上有跳跃的解。
* 在上述方程中，标量变量[2.x.70]的空间[2.x.71]被定义为在每个单元上为张量多项式[2.x.72]且在单元边界上不连续的函数空间[2.x.73]，即由[2.x.74]描述的空间。梯度或通量变量的空间[2.x.75]是一个矢量元素空间，其中每个分量都是局部多项式且不连续 [2.x.76] 。在下面的代码中，我们将这两个局部部分收集在一个FES系统中，其中第一个[2.x.77]二维分量表示梯度部分，最后一个标量分量对应于标量变量。对于骨架分量[2.x.78]，我们定义了一个由不连续的张量积多项式组成的空间，该空间活在元素面上，在deal.II中由FE_FaceQ类实现。这个空间在其他方面与FE_DGQ相似，即解函数在两个相邻的面之间不连续，也可参见下面的结果部分来说明。
* 在上面给出的弱形式中，我们可以注意到以下的耦合模式。[2.x.79] [2.x.80] 矩阵[2.x.81] 由局部-局部耦合项组成。 当局部加权函数[2.x.82]与局部求解项[2.x.83]相乘时就会产生这些耦合项。因为这些元素是不连续的，所以[2.x.84]是块对角线的。  [2.x.85] 矩阵[2.x.86]代表局部面的耦合。 这些是具有加权函数[2.x.87]的条款，乘以骨架变量[2.x.88] 。  [2.x.89] 矩阵[2.x.90]代表面-局域耦合，它涉及加权函数[2.x.91]乘以局域解[2.x.92] 。  [2.x.93] 矩阵[2.x.94]是面-面耦合；条款涉及[2.x.95]和[2.x.96] 。[2.x.97] 
* [1.x.73][1.x.74] 。
 

* HDG方法的一个特点是，它们通常允许构建一个丰富的解决方案，以提高精确度。这种后处理方法以逐个元素的方式获取HDG解决方案，并将其结合起来，从而在使用度数为[2.x.99]的多项式时可以获得[2.x.98]级的精度。要做到这一点，有两个必要因素。[2.x.100] [2.x.101] 计算的解决方案梯度[2.x.102] 以最佳速度收敛，即[2.x.103] 。  [2.x.104] 解的标量部分的单元平均，[2.x.105] ，以[2.x.106]的速度超级收敛。[2.x.107] 
* 现在我们引入一个新的变量[2.x.108]，通过在约束条件[2.x.111]下最小化单元[2.x.109]的表达式来找到它。这个约束是必要的，因为最小化函数并不能确定[2.x.112]的常数部分。这就转化为以下方程组：[1.x.75] 。
* 
* 由于我们在第二组方程中用张量多项式空间中的整套基函数来测试[2.x.113]，这是一个过度确定的系统，方程比未知数多一个。我们在下面的代码中通过省略其中的一个方程来解决这个问题（因为拉普拉斯的行在代表一个常数函数时是线性依赖的）。正如我们将在下面看到的，这种形式的后处理给出了所希望的超级收敛结果，其比率为[2.x.114]。 应该注意的是，在构建[2.x.115]时有一些自由度，这种从梯度中提取信息的最小化方法并不是唯一的方法。特别是，这里定义的后处理方案在任何意义上都不满足对流-扩散方程。作为替代方案，上面引用的Nguyen, Peraire和Cockburn的论文提出了另一个更复杂的对流-扩散公式，该公式也可以将通量变量后处理为[2.x.116]-符合的变体，并在扩散较小时更好地代表局部对流-扩散算子。我们把更复杂的后处理的实现作为一个可能的扩展留给感兴趣的读者。
* 请注意，对于矢量值问题，后处理的工作原理是类似的。我们只需为每个向量分量的平均值分别设置约束，并使用梯度作为主要信息来源。
*[1.x.76][1.x.77]
* 

* 在这个教程程序中，我们考虑的测试案例与 [2.x.117] 中的几乎一样。计算域是[2.x.118]，确切的解决方案对应于[2.x.119]中的解决方案，除了一个缩放比例。我们使用以下源中心[2.x.120]的指数[2.x.121] [2.x.122] 一维：[2.x.123] , [2.x.124] 二维：[2.x.125] , [2.x.126] 三维：[2.x.127] 。[2.x.128] 
* 有了精确的解决方案，我们就可以选择右手边的强制力和诺伊曼边界条件，这样就可以得到这个解决方案（制造的解决方案技术）。在这个例子中，我们选择扩散等于1，对流为[1.x.78]注意，对流是无发散的，[2.x.129] 。
*[1.x.79][1.x.80] 。
* 

* 除了实现上述方程，下面的实现还提供了以下特点。[2.x.130] [2.x.131] WorkStream使局部求解器并行化。Workstream已在 [2.x.132] 中详细介绍。  [2.x.133] 从跟踪中重构本地DG解。  [2.x.134] 对解进行后处理以实现超融合。  [2.x.135] 用于直接输出全局骨架解的DataOutFaces。[2.x.136] 
 

* [1.x.81] [1.x.82]。
* [1.x.83] [1.x.84].
 

* 
* 大多数deal.II的include文件在以前的例子中已经涉及，没有注释。
* 

* 
* [1.x.85]
* 
* 然而，我们确实为这个例子准备了几个新的包含文件。第一个定义了三角形面上的有限元空间，我们称其为 "骨架"。这些有限元在元素内部没有任何支持，它们代表的是在每个模数一的表面上有一个单一的值的多项式，但在模数二的表面上允许有不连续。
* 

* 
* [1.x.86]
* 
* 我们包含的第二个新文件定义了一种新的稀疏矩阵类型。 常规的[2.x.137]类型存储了所有非零条目的索引。 [2.x.138]则利用了DG解的耦合性质。 它存储了一个指定大小的矩阵子块的索引。 在HDG背景下，这个子块大小实际上是由骨架解字段定义的每个面的自由度数量。这使得矩阵的内存消耗减少了三分之一，并且在求解器中使用矩阵时也会有类似的速度提升。
* 

* 
* [1.x.87]
* 
* 这个例子的最后一个新的包括涉及到数据输出。 由于我们在网格的骨架上定义了一个有限元场，所以我们希望能将这个解决方案的实际情况可视化。DataOutFaces正是这样做的，它的界面与我们熟悉的DataOut几乎一样，但输出的数据只有模拟的二维1数据。
* 

* 
* [1.x.88]
 
* 我们首先将所有的类放入自己的命名空间。
* 

* 
* [1.x.89]
* 
* [1.x.90] [1.x.91] 。  
* 分析解的结构与 [2.x.139] 中的结构相同。有两个例外。首先，我们也为三维情况创建了一个解决方案，其次，我们对解决方案进行了缩放，因此对于解决方案宽度的所有值，其规范都是统一的。
* 

* 
* [1.x.92]
* 
* 这个类实现了一个函数，标量解和其负梯度被收集在一起。这个函数在计算HDG近似的误差时使用，它的实现是简单地调用Solution类的值和梯度函数。
* 

* 
* [1.x.93]
 
* 接下来是对流速度的实现。如介绍中所述，我们选择的速度场在二维是[2.x.140]，在三维是[2.x.141]。这就给出了一个无发散的速度场。
* 

* 
* [1.x.94]
* 
* 我们实现的最后一个函数是人造解的右手边。它与[2.x.142]非常相似，不同的是我们现在有一个对流项而不是反应项。由于速度场是不可压缩的，即[2.x.143]，对流项简单读作[2.x.144] 。
* 

* 
* [1.x.95]
* 
* [1.x.96] [1.x.97] 。
 

* 
* HDG的求解程序与 [2.x.145] 的程序密切相关。主要区别在于使用了三套不同的DoFHandler和FE对象，以及ChunkSparseMatrix和相应的解决方案向量。我们还使用WorkStream来实现多线程的局部求解过程，利用局部求解器令人尴尬的并行性质。对于WorkStream，我们定义了对单元格的本地操作和复制到全局矩阵和向量的函数。我们这样做既是为了装配（装配要运行两次，一次是在我们生成系统矩阵时，另一次是在我们从骨架值计算元素内部解时），也是为了后处理，在后处理中我们提取一个在高阶收敛的解。
* 

* 
* [1.x.98]
* 
* 用于组装和解决原始变量的数据。
* 

* 
* [1.x.99]
* 
* 对解决方案进行后处理以获得[2.x.146]是一个逐个元素的过程；因此，我们不需要组装任何全局数据，也不需要声明任何 "任务数据 "供WorkStream使用。
* 

* 
* [1.x.100]
* 
* 以下三个函数被WorkStream用来做程序的实际工作。
* 

* 
* [1.x.101]
* 
* "局部 "解是每个元素的内部。 这些代表原始解场 [2.x.147] 以及辅助场 [2.x.148] 。
* 

* 
* [1.x.102]
* 
* 新的有限元类型和相应的[2.x.149]被用于耦合元素级局部解的全局骨架解。
* 

* 
* [1.x.103]
* 
* 如介绍中所述，HDG解可以通过后处理达到[2.x.150]的超收敛率。 后处理的解是一个不连续的有限元解，代表每个单元内部的原始变量。 我们定义了一个程度为[2.x.151]的FE类型来表示这个后处理的解，我们只在构造后用于输出。
* 

* 
* [1.x.104]
 
* 与骨架相对应的自由度强烈地强制执行Dirichlet边界条件，就像在连续Galerkin有限元方法中一样。我们可以通过AffineConstraints对象以类似的方式强制执行边界条件。此外，悬挂节点的处理方式与连续有限元的处理方式相同。对于只在面定义自由度的面元素，这个过程将精炼面的解设置为与粗略面的表示相吻合。    
* 请注意，对于HDG来说，消除悬空节点并不是唯一的可能性&mdash；就HDG理论而言，我们也可以使用精炼侧的未知数，并通过精炼侧的跟踪值表达粗略侧的局部解。然而，这样的设置在deal.II环路方面不容易实现，没有进一步分析。
* 

* 
* [1.x.105]
 
* ChunkSparseMatrix类的用法与通常的稀疏矩阵类似。你需要一个ChunkSparsityPattern类型的稀疏模式和实际的矩阵对象。在创建稀疏模式时，我们只需要额外传递局部块的大小。
* 

* 
* [1.x.106]
* 
* 与 [2.x.152] 相同。
* 

 
* [1.x.107]
* 
* [1.x.108] [1.x.109]。
 

* 
* [1.x.110] [1.x.111] 构造函数与其他例子中的相似，除了处理多个DoFHandler和FiniteElement对象。请注意，我们为局部DG部分创建了一个有限元系统，包括梯度/通量部分和标量部分。
* 

* 
* [1.x.112]
* 
* [1.x.113] [1.x.114] HDG解的系统设置方式与其他大多数教程程序类似。 我们小心翼翼地用我们所有的DoFHandler对象来分配道夫。 [2.x.153]和[2.x.154]对象与全局骨架解决方案一起。
* 

* 
* [1.x.115]
* 
* 在创建块状稀疏模式时，我们首先创建通常的动态稀疏模式，然后设置块状大小，这等于一个面的道夫数，当把它复制到最终的稀疏模式时。
* 

* 
* [1.x.116]
* 
* [1.x.117] [1.x.118] 接下来是定义并行装配的本地数据结构。第一个结构[2.x.155]包含了被写入全局矩阵的本地向量和矩阵，而ScratchData包含了我们在本地装配中需要的所有数据。这里有一个变量值得注意，即布尔变量[2.x.156] trace_reconstruct。正如介绍中提到的，我们分两步解决HDG系统。首先，我们为骨架系统创建一个线性系统，通过舒尔补码[2.x.157] 将局部部分浓缩到其中。然后，我们用骨架的解来解决局部部分。对于这两个步骤，我们需要两次元素上的相同矩阵，我们希望通过两个装配步骤来计算。由于大部分的代码是相似的，我们用相同的函数来做这件事，但只是根据我们在开始装配时设置的一个标志在两者之间切换。由于我们需要将这一信息传递给本地工作程序，所以我们在任务数据中存储一次。
* 

* 
* [1.x.119]
* 
* [1.x.120] [1.x.121] [2.x.158] 包含WorkStream中每个线程的持久性数据。 FEValues、矩阵和矢量对象现在应该很熟悉了。 有两个对象需要讨论。 [2.x.159] int> > fe_local_support_on_face` 和 [2.x.160] int> > fe_support_on_face`。 这些用于指示所选择的有限元是否对与[2.x.161]相关的局部部分和骨架部分[2.x.162]的参考单元的特定面有支持（非零值）。 我们在构造函数中提取这一信息，并对我们工作的所有单元存储一次。 如果我们不存储这一信息，我们将被迫在每个单元上装配大量的零项，这将大大降低程序的速度。
* 

* 
* [1.x.122]
* 
* [1.x.123] [1.x.124] [2.x.163] 包含WorkStream在对局部解进行后处理时使用的数据 [2.x.164] 。 它与 [2.x.165] 类似，但要简单得多。
 

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127] [2.x.166]函数类似于[2.x.167]上的函数，其中正交公式和更新标志被设置，然后[2.x.168]被用来以多线程的方式进行工作。 [2.x.169] 输入参数用于决定我们是求全局骨架解（假）还是局部解（真）。  
* 对于汇编的多线程执行，有一点值得注意的是，`assemble_system_one_cell()`中的局部计算会调用BLAS和LAPACK函数，如果这些函数在deal.II中可用的话。因此，底层的BLAS/LAPACK库必须支持同时来自多个线程的调用。大多数实现都支持这一点，但有些库需要以特定方式构建以避免问题。例如，在BLAS/LAPACK调用内部没有多线程的情况下编译的OpenBLAS需要在构建时将一个名为`USE_LOCKING'的标志设置为true。
* 

* 
* [1.x.128]
* 
* [1.x.129] [1.x.130] HDG程序的真正工作是由 [2.x.170] 汇编局部矩阵 [2.x.171] 在这里完成，同时还有全局矩阵的局部贡献 [2.x.172] 。
* 

* 
* [1.x.131]
* 
* 为Dof_handler_local构建迭代器，用于FEValues的reinit函数。
* 

* 
* [1.x.132]
* 
* 我们首先计算对应于局部-局部耦合的[2.x.173]矩阵（在介绍中称为矩阵[2.x.174]）的单元内部贡献，以及局部右手向量。 我们在每个正交点存储基函数、右手边值和对流速度的值，以便快速访问这些场。
* 

* 
* [1.x.133]
 
* 面项被集合在所有元素的所有面上。这与更传统的DG方法相反，在组装过程中，每个面只被访问一次。
* 

* 
* [1.x.134]
* 
* 在求解局部变量时需要已经得到的[2.x.175]值。
* 

* 
* [1.x.135]
* 
* 这里我们计算介绍中讨论的稳定参数：由于扩散是1，并且扩散长度尺度被设定为1/5，它只是导致扩散部分的贡献为5，而对流部分的贡献则是通过元素边界的居中方案中的对流大小。
* 

* 
* [1.x.136]
* 
* 我们存储非零流量和标量值，利用我们在[2.x.176]中创建的support_on_face信息。
* 

* 
* [1.x.137]
* 
* 当 [2.x.177] 我们准备为骨架变量 [2.x.178] 组装系统时。如果是这种情况，我们必须组装所有与问题相关的局部矩阵：局部-局部，局部-面部，面部-局部，以及面部-面部。 面-面矩阵被存储为[2.x.179]，这样就可以通过[2.x.180]copy_local_to_global将其组装到全局系统中。
* 

* 
* [1.x.138]
* 
* 注意face_no-local矩阵的符号。 我们在组装时否定了这个符号，这样我们就可以在计算舒尔补数时使用[2.x.181]的加法。
* 

* 
* [1.x.139]
* 
* 这最后一项是将[2.x.182]项的贡献添加到本地矩阵中。相对于上面的面矩阵，我们在两个装配阶段都需要它。
* 

* 
* [1.x.140]
* 
* 当[2.x.183]我们在逐个元素的基础上求解局部解。 局部右手边的计算是通过用计算值[2.x.186]trace_values替换[2.x.184]计算中的基函数[2.x.185]tr_phi。 当然，现在矩阵的符号是减号，因为我们已经把所有的东西移到了方程的另一边。
* 

* 
* [1.x.141]
* 
* 一旦完成了所有局部贡献的组装，我们必须：(1)组装全局系统，或者(2)组装全局系统。(1)组装全局系统，或者(2)计算局部解值并保存。无论哪种情况，第一步都是对局部-局部矩阵进行反转。
* 

* 
* [1.x.142]
* 
* 对于(1)，我们计算舒尔补码，并将其添加到[2.x.187]cell_matrix，介绍中的矩阵[2.x.188]。
* 

* 
* [1.x.143]
* 
* 对于(2)，我们只是求解(ll_matrix).(solution_local) = (l_rhs)。因此，我们用[2.x.189]乘以我们已经倒置的局部-局部矩阵，并用[2.x.190]函数来存储结果。
* 

* 
* [1.x.144]
* 
* [1.x.145] [1.x.146] 如果我们处于解的第一步，即[2.x.191]，那么我们将局部矩阵集合到全局系统。
* 

* 
* [1.x.147]
* 
* [1.x.148] [1.x.149] 通过使用带有身份预处理的BiCGStab求解器来解决骨架解。
* 

* 
* [1.x.150]
* 
* 一旦我们求出了骨架解，我们就可以以逐个元素的方式求出局部解。 我们通过重新使用相同的[2.x.192]函数来做到这一点，但将[2.x.193]切换为真。
* 

* 
* [1.x.151]
* 
* [1.x.152] [1.x.153]。
 

* 
* 后处理方法有两个目的。首先，我们要在度数为[2.x.194]的元素空间中构造一个后处理的标量变量，我们希望它能在阶[2.x.195]收敛。这又是一个逐个元素的过程，只涉及标量解以及局部单元上的梯度。为了做到这一点，我们引入了已经定义好的从头开始的数据以及一些更新标志，并运行工作流来并行地做这件事。  
* 其次，我们要计算离散化误差，就像我们在 [2.x.196] 中所做的那样。整体程序与调用[2.x.197]相似，区别在于我们如何计算标量变量和梯度变量的误差。在[2.x.198]中，我们通过计算[2.x.199]或[2.x.200]的贡献来做到这一点。在这里，我们有一个DoFHandler，计算了这两个贡献，并按其矢量分量排序，[2.x.201]为梯度，[2.x.202]为标量。为了计算它们的值，我们用一个ComponentSelectFunction来计算它们中的任何一个，再加上上面介绍的[2.x.203]SolutionAndGradient类，它包含了它们中任何一个的分析部分。最终，我们还计算了后处理的解决方案的L2-误差，并将结果添加到收敛表中。
* 

* 
* [1.x.154]
* 
* [1.x.155] [1.x.156]   
* 这是为后处理所做的实际工作。根据介绍中的讨论，我们需要设置一个系统，将DG解的梯度部分投影到后处理变量的梯度上。此外，我们还需要将新的后处理变量的平均值设置为等于标量DG解在该单元上的平均值。  
* 从技术上讲，梯度的投影是一个有可能填满我们的[2.x.204]乘以[2.x.205]矩阵的系统，但它是单数（所有行的总和将是零，因为常数函数的梯度为零）。因此，我们拿掉一行，用它来强加标量值的平均值。我们为标量部分挑选第一行，尽管我们可以为[2.x.206]元素挑选任何一行。然而，如果我们使用FE_DGP元素，第一行将对应常数部分，删除例如最后一行将得到一个奇异系统。这样一来，我们的程序也可以用于这些元素。
* 

* 
* [1.x.157]
* 
* 在集合了所有的项之后，我们又可以继续解决这个线性系统。我们对矩阵进行反转，然后将反转结果乘以右手边。另一种方法（在数值上更稳定）是只对矩阵进行因式分解，然后应用因式分解。
* 

* 
* [1.x.158]
* 
* [1.x.159] [1.x.160] 我们有三组我们想输出的结果：局部解、后处理的局部解和骨架解。前两个结果都 "活 "在元素体积上，而后者则活在三角形的一维表面上。 我们的[2.x.207]函数将所有的局部解决方案写入同一个vtk文件，尽管它们对应于不同的DoFHandler对象。 骨架变量的图形输出是通过使用DataOutFaces类完成的。
* 

* 
* [1.x.161]
* 
* 我们首先定义本地解决方案的名称和类型，并将数据添加到[2.x.208]。
 

* 
* [1.x.162]
 
* 我们添加的第二个数据项是后处理的解决方案。在这种情况下，它是一个属于不同DoFHandler的单一标量变量。
* 

* 
* [1.x.163]
 
* [2.x.209]类的工作原理类似于[2.x.210]，它定义了三角形骨架上的解决方案。 我们在此将其视为如此，其代码与上面的类似。
* 

* 
* [1.x.164]
* 
* [1.x.165] [1.x.166].
 

* 
* 我们为HDG实现了两种不同的细化情况，就像在[2.x.211]中一样：adaptive_refinement 和 global_refinement。 global_refinement选项每次都会重新创建整个三角形。这是因为我们想使用比一个细化步骤更细的网格序列，即每个方向2、3、4、6、8、12、16、...个元素。
* 

* 
* adaptive_refinement模式使用[2.x.212]来对标量局部解中的非规则区域给出一个体面的指示。
* 

* 
* [1.x.167]
 
* 就像在[2.x.213]中一样，我们将其中两个面的边界指标设置为1，在这里我们要指定诺伊曼边界条件而不是迪里希特条件。由于我们每次在全局细化时都会重新创建三角形，所以在每个细化步骤中都会设置标志，而不仅仅是在开始时。
* 

* 
* [1.x.168]
* 
* [1.x.169] [1.x.170] 这里的功能与[2.x.214] 基本相同。我们在10个周期中循环，在每个周期中细化网格。 在最后，收敛表被创建。
* 

* 
* [1.x.171]
 
* 与[2.x.215]相比，收敛表有一个微小的变化：由于我们没有在每个周期内以系数2来细化我们的网格（而是使用了2, 3, 4, 6, 8, 12, ...的序列），我们需要告诉收敛率评估关于这一点。我们通过设置单元格数量作为参考列，并额外指定问题的维度来实现这一目的，这为单元格数量和网格大小之间的关系提供了必要的信息。
* 

* 
* [1.x.172]
 
* 现在是对主类的三个调用，完全类似于 [2.x.216] 。
* 

* 
* [1.x.173]
* [1.x.174][1.x.175] 。
* 

* [1.x.176][1.x.177]。
 

* 我们首先看一下程序在二维运行时产生的输出。在下面的四张图片中，我们显示了多项式度数[2.x.217]的解决方案和程序的第2、3、4和8周期。在这些图中，我们将内部数据（DG部分）和骨架部分（[2.x.218]）生成的数据叠加到同一图中。我们不得不生成两个不同的数据集，因为细胞和面孔代表了不同的几何实体，而这些实体的组合（在同一个文件中）在VTK输出的deal.II中是不支持的。
* 这些图像显示了HDG的明显特征：单元格的解（coloredsurfaces）在单元格之间是不连续的。骨架变量上的解决方案位于面孔上，将局部部分联系在一起。骨架解在面与面之间的顶点上是不连续的，尽管它的值沿着同一坐标方向的线相当接近。骨架解可以被解释为两边之间的橡胶弹簧，它可以平衡解的跳跃（或者说，通量[2.x.219]）。从左上角的图片可以看出，大体解经常出现过冲和欠冲，而骨架变量确实是对精确解的一个更好的近似；这就解释了为什么我们可以通过后处理步骤得到一个更好的解。
* 随着网格的细化，单元格之间的跳跃变得很小（我们代表一个平滑的解决方案），骨架解决方案接近内部部分。对于第8周期，两个变量没有明显的区别。我们还看到边界条件是如何被弱化的，内部变量并不完全满足边界条件。在下边界和左边界，我们设置了诺伊曼边界条件，而在右边界和上边界，我们设置了迪里切特条件。
* [2.x.220] 
* 接下来，我们看一下后处理的解决方案，还是在周期2、3、4和8。这是一个不连续的解决方案，局部由二阶多项式描述。虽然在第二周期的网格上，解决方案看起来不是很好，但在第三和第四周期，它看起来要好得多。正如下面的收敛表所示，我们发现它也更快地收敛到了理论解。
* [2.x.221] 
* 最后，我们看一下[2.x.222]在第二周期的解。尽管只有64个单元的粗网格，但后处理的解在质量上与第8周期4,096个单元的线性解（未进行后处理）相似。这清楚地表明了高阶方法在平滑解方面的优越性。
* [2.x.223] 
*[1.x.178][1.x.179]
 

* 当程序运行时，它还会输出有关各步骤的信息和收敛表，并在最后列出各部分的误差。在2D中，收敛表看起来如下。
* [1.x.180]
* 
* 

* 人们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。在[2.x.224]准则下，标量变量和梯度变量的Q1元素的二次收敛率是明显的，在[2.x.225]准则下，后处理的标量变量的三次收敛率也是如此。请注意HDG解决方案的这一独特特征。在典型的连续有限元中，阶[2.x.226]的解的梯度只以[2.x.227]的速率收敛，而实际的解则是[2.x.228]。即使有限元的超级收敛结果也是可用的（例如Zienkiewicz和Zhu首次提出的超级收敛补丁恢复），但这些通常只限于结构化网格和其他特殊情况。对于Q3 HDG变量，标量变量和梯度在四阶收敛，后处理的标量变量在五阶收敛。
* 同样的收敛率在三维中也被观察到。
* [1.x.181]
* 
* [1.x.182][1.x.183] 。
* 

* [1.x.184][1.x.185]。
 

* 收敛表验证了导言中所述的预期收敛率。现在，我们想展示一下HDG方法与通常的有限元（连续Galkerin）方法在本教程的问题上的计算效率的快速比较。当然，在实践中，HDG方法与连续有限元相比，在传输为主的问题上的稳定性也很重要，这是在光滑解析解的问题上所看不到的。在下面的图片中，我们比较了[2.x.229]的误差与自由度数的函数（左）和线性求解器花费的计算时间（右），连续有限元（CG）和本教程中介绍的混合非连续Galerkin方法的两个空间维度。相对于教程中我们只使用无条件的BiCGStab，下面的图中显示的时间使用了[2.x.230]中的Trilinos代数多网格预处理器 对于HDG部分，为了在最细的层次上利用矩阵中的块状结构，使用了跟踪变量的ChunkSparseMatrix的封装器。
* [2.x.231] 
* 图中的结果显示，HDG方法在[2.x.232]时比连续无限元慢，对立方体元素的速度差不多，对六阶元素则更快。然而，我们在上面看到，HDG方法实际上产生的解比原始变量所表示的更准确。因此，在下面两幅图中，我们反而显示了HDG的后处理解的误差（例如用[2.x.233]表示）。现在我们看到，对于[2.x.234]和[2.x.235]来说，在相同的工作量下，HDG有明显的优势，对于[2.x.236]来说，质量也差不多。
* [2.x.237] 
* 由于HDG方法实际上产生了如[2.x.238]那样的收敛结果，我们应该将其与具有相同渐进收敛行为的连续Galerkinsolution进行比较，即具有程度[2.x.239]的FE_Q。如果我们这样做，我们会得到下面的收敛曲线。我们看到带有二阶多项式的CG又明显优于带有线性的HDG。然而，HDG对高阶的优势依然存在。
* [2.x.240] 
* 这些结果与一般DG方法的特性一致。最佳性能通常不是在线性元素上实现的，而是在稍高的阶数上实现的，通常在[2.x.241]左右。这是因为对于不连续的解来说，有太多的解住在表面上，因此当元素是线性的时候，就会出现浮点--表面效应。换句话说，尽管DG方法专注于不连续的（因此似乎是低精度的）解的表示，但在使用相对高阶的时候往往是最有效的。
* [1.x.186][1.x.187] 。
* 

* 现在我们用三维显示同样的数字：第一行显示了自由度数和计算时间与标量变量[2.x.242]中的[2.x.243]误差的关系，对于阶数为[2.x.244]的CG和HDG，第二行显示了后处理的HDG解决方案而不是原始解决方案，第三行比较了后处理的HDG解决方案和阶数为[2.x.245]的CG。在三维中，体积-表面效应使得HDG的成本较高，对于任何尺度的线段，CG的解决方案显然比HDG更好。对于立方体，HDG和CG的质量相似，而对于六阶多项式，HDG又更有效率。我们也可以使用FE_DGP和FE_FaceP的组合来代替（FE_DGQ, FE_FaceQ），它们不使用[2.x.246]度的张量积多项式，而是使用[1.x.188]度的Legendre多项式[2.x.247]。在给定的网格尺寸下，FE_FaceP的骨架变量自由度较少，但解的质量（误差与自由度数量）与FE_FaceQ的结果非常相似。
* [2.x.248] 
* 关于效率比较的最后一点说明。我们试图使用通用的解析矩阵结构和类似的求解器(两者的最佳AMG预处理器都没有对AMG参数进行特别的调整)，以便在一个玩具例子中对两种方法的成本与精度进行公平的描述。然而，应该注意的是，连续有限元的几何多网格（GMG）比[2.x.249]和[2.x.250]快4到5个系数。截至2019年，研究界仍在开发HDG的最佳复杂度迭代求解器。此外，CG可用的其他实施方面，如[2.x.251]中所示的快速无矩阵方法，使高阶连续元素更具竞争力。同样，本教程的作者也不清楚是否可以对HDG做出类似的改进。我们参考[1.x.189]中的最新效率评估。
* 

* [1.x.190][1.x.191] 。
* 

* 正如在介绍中已经提到的，一种可能性是实现文献中讨论的另一种后处理技术。
* 第二个没有做得很好的项目与这个程序的性能有关，这当然是实际应用中的一个问题（也要权衡(H)DG方法对传输主导问题的更好的解决质量）。让我们来看看这个教程程序的计算时间和各个部分的份额。
* [2.x.252] 
* 从表中可以看出，解算器和汇编的调用在程序的运行时间中占主导地位。这也清楚地表明了哪里的改进是最有意义的。
* [2.x.253] [2.x.254] 更好的线性求解器。我们使用的是BiCGStab迭代求解器，没有预设条件，迭代次数随着问题大小的增加而增加（Q1元素和全局细化的迭代次数小的时候是35次，大的时候增加到701次）。为了做得更好，例如可以使用Trilinos的代数多网格预处理程序，或者像[1.x.192]中讨论的一些更高级的变体。对于以扩散为主的问题，比如目前的问题，只要我们不与MPI并行工作，就可以设计这样一个求解器，在最细的层次上使用更高效的ChunkSparseMatrix的矩阵-向量积。对于MPI并行化的计算，可以使用一个标准的[2.x.255]。
* [2.x.256] 通过预先组装不从一个单元到另一个单元变化的部分（那些既不包含可变系数也不包含映射依赖项的部分）来加速组装。[2.x.257] 
* 

* [1.x.193][1.x.194] [2.x.258]。
* [0.x.1]

