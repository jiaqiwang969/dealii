include/deal.II-translator/A-tutorial/step-8_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17]
*[1.x.18][1.x.19][1.x.20] 。
 

* 
* 在现实生活中，大多数偏微分方程实际上是方程组。因此，解通常是向量值的。deal.II库支持这类问题（见[2.x.2]模块中的大量文档），我们将表明，这大多是相当简单的。唯一比较复杂的问题是在组装矩阵和右手边，但这些也很容易理解。
* [2.x.3] 
* 它们是拉普拉斯方程的扩展，有一个矢量值的解，描述了一个受力的刚体在每个空间方向的位移。当然，这个力也是矢量值的，也就是说，在每一个点上，它都有一个方向和一个绝对值。
* 人们可以用多种方式来写弹性方程。其中[2.x.4]是每一点的向量值位移，[2.x.5]是力，[2.x.6]是一个等级4的张量（即，它有四个索引），编码应力-应变关系。
* 
* 本质上，它代表了[1.x.23]中的Hookes定律，将位移与力联系起来。 在许多情况下，如果我们想模拟的物体的变形是由不同的材料组成的，[2.x.7]将取决于[2.x.8]。
* 虽然上述方程的形式是正确的，但这并不是它们通常的推导方式。事实上，位移的梯度[2.x.9]（一个矩阵）没有物理意义，而它的对称版本[1.x.24]却有，通常被称为 "应变"。这里和下文中，[2.x.10] 。我们还将使用[1.x.25]，即只要同一指数在方程中出现两次，就意味着对该指数求和；但是，我们将不区分上部和下部的指数。首先显示的形式等同于这种形式，因为张量[2.x.11]具有某些对称性，即[2.x.12]，因此[2.x.13]。
* 当然，我们也可以把这些方程写成组件形式：[1.x.27] 。
* 在许多情况下，我们知道所考虑的材料是各向异性的，在这种情况下，通过引入两个系数[2.x.14]和[2.x.15]，系数张量减少为[1.x.28] 。
* 然后，弹性方程可以改写成更简单的形式：[1.x.29]，各自的双线性形式是[1.x.30]，或者也可以把第一项写成分量的和：[1.x.31] 。
*[2.x.16]如上所述，如果位移较小，我们可以假设[1.x.32]有效，上述方程一般被认为是对三维物体位移的正确描述。在这种情况下，上面的指数[2.x.17]都在集合[2.x.18]上运行（或者，在C++源中，在[2.x.19]上）。然而，按照目前的情况，程序是在二维运行的，虽然上面的方程在这种情况下也有数学意义，但它们只能描述一个真正的二维实体。特别是，它们不是对[2.x.20]方向上无限大的体的横截面的适当描述；这与其他许多二维方程相反，这些方程可以通过假设体在[2.x.22]方向上具有无限大的范围和解函数不依赖于[2.x.23]坐标而得到。另一方面，也有二维弹性模型的方程；例如，见维基百科关于[1.x.33]、[1.x.34]和[1.x.35]的文章。
* 但让我们回到最初的问题。我们如何为这样一个方程组装矩阵？在[2.x.24]模块的文档中给出了一个很长的答案，其中有许多不同的选择。从历史上看，下面显示的解决方案是该库早期唯一可用的方案。事实证明，它也是最快的。另一方面，如果百分之几的计算时间并不重要，还有比下面讨论的更简单、更直观的方法来组装线性系统，但这些方法直到本教程首次编写后几年才可用；如果你对它们感兴趣，可以看看[2.x.25]模块。
* 让我们回到如何组装线性系统的问题上来。我们首先需要了解一些关于在矢量值有限元情况下形状函数如何工作的知识。基本上，这归结为以下几点：让[2.x.26]为标量有限元的形状函数数量，我们在此基础上建立矢量元素（例如，我们将对矢量值有限元的每个分量使用双线性函数，所以标量有限元是[2.x.27]元素，我们在以前的例子中已经使用过，而在两个空间维度中使用[2.x.28]）。此外，让[2.x.29]成为矢量元素的形状函数的数量；在两个空间维度中，我们需要[2.x.30]矢量的每个分量的形状函数，所以[2.x.31]。然后，矢量元素的[2.x.32]个形状函数具有[1.x.36]的形式，其中[2.x.33]是[2.x.34]个单位矢量，[2.x.35]是告诉我们[2.x.36]的哪个分量是非零的函数（对于每个矢量形状函数，只有一个分量是非零，其他都是零）。 [2.x.37]描述了形状函数的空间依赖性，它被认为是标量元素的第[2.x.38]个形状函数。当然，虽然[2.x.39]的范围是[2.x.40]，但函数[2.x.41]和[2.x.42]的范围分别是[2.x.43]（在二维）和[2.x.44]。
* 例如（尽管这个形状函数的顺序并不保证，你也不应该依赖它），下面的布局可以被库使用：[1.x.37] 。
* 在这里[1.x.38][1.x.39]。
* 除了非常罕见的情况，你不需要知道标量元素的哪个形状函数[2.x.45]属于矢量元素的一个形状函数[2.x.46]。因此，让我们定义[1.x.40]，我们可以把向量形状函数写成[1.x.41]，现在你可以安全地忘记函数[2.x.47]，至少在这个例子程序的其余部分。
* 现在使用这个矢量形状函数，我们可以将离散的有限元解写成[1.x.42]，标量系数[2.x.48]。如果我们定义一个模拟函数[2.x.49]作为测试函数，我们可以把离散问题写成如下。寻找系数[2.x.50]，以便[1.x.43]。
* 如果我们把双线性形式的定义和[2.x.51]和[2.x.52]的表示插入这个公式：[1.x.44]
* 我们注意到，在这里和下文中，指数[2.x.53]在空间方向上运行，即[2.x.54] ，而指数[2.x.55]在自由度上运行。
* 因此，单元格[2.x.56]上的局部刚度矩阵有以下条目：[1.x.45]，其中[2.x.57]现在是局部自由度，因此[2.x.58].在这些公式中，我们总是取矢量形状函数[2.x.59]的一些分量，当然，它们是如下给出的（见其定义）：[1.x.46]，克朗克符号[2.x.60] 。由于这个原因，我们可以删除一些对[2.x.61]和[2.x.62]的和：[1.x.47] 。
* 
* 同样地，单元格[2.x.63]对右手边矢量的贡献是[1.x.48] 。
* 
* 这就是我们将实现局部刚度矩阵和右侧向量的形式。
* 作为最后的说明：在[2.x.64]示例程序中，我们将重新审视这里提出的弹性问题，并将展示如何在一个计算机集群上并行解决它。由此产生的程序将能够以更高的精度解决这个问题，而且如果需要的话，效率更高。此外，在[2.x.65]，[2.x.66]"[2.x.67]"，以及其他一些后来的教程程序中，我们将回顾一些矢量值问题，并展示一些技术，这些技术可能使其更容易实际通过上面显示的所有东西，与[2.x.68]等。
* 

* [1.x.49] [1.x.50]。
* [1.x.51] [1.x.52]。
 

* 
* 像往常一样，前几个include文件已经是众所周知的了，所以我们不会对它们作进一步评论。
* 

* 
* [1.x.53]
* 
* 在这个例子中，我们需要矢量值的有限元。对这些的支持可以在下面的include文件中找到。
* 

* 
* [1.x.54]
* 
* 我们将从常规的Q1元素组成向量值的有限元素，这些元素可以在这里找到，像往常一样。
* 

* 
* [1.x.55]
* 
* 这又是C++。
* 

* 
* [1.x.56]
* 
* 最后一步和以前的程序一样。特别是，就像在[2.x.69]中一样，我们把这个程序所特有的一切都打包到一个自己的命名空间中。
* 

* 
* [1.x.57]
* 
* [1.x.58] [1.x.59].
 

* 
* 主类除了名称外，与[2.x.70]的例子相比几乎没有变化。  
* 唯一的变化是为[2.x.71]变量使用了一个不同的类。我们现在使用的不是FE_Q这样具体的有限元类，而是一个更通用的类，FESystem。事实上，FESystem本身并不是一个真正的有限元，因为它没有实现自己的形状函数。相反，它是一个可以用来将其他几个元素堆叠在一起形成一个矢量值的有限元的类。在我们的例子中，我们将组成[2.x.72]对象的矢量值元素，如下所示，在这个类的构造函数中。
* 

* 
* [1.x.60]
* 
* [1.x.61] [1.x.62].
 

* 
* 在进入主类的实现之前，我们声明并定义描述右手边的函数。这一次，右手边是向量值，就像解决方案一样，所以我们将更详细地描述为此所需的变化。  
* 为了防止出现返回向量先前没有被设置为正确大小的情况，我们对这种情况进行了测试，否则将在函数的开始部分抛出一个异常。请注意，强制要求输出参数已经具有正确的大小是deal.II中的一个惯例，并且几乎在所有地方都强制执行。原因是，否则我们将不得不在函数开始时检查，并可能改变输出向量的大小。这很昂贵，而且几乎总是不必要的（对函数的第一次调用会将向量设置为正确的大小，随后的调用只需要做多余的检查）。此外，如果我们不能依赖向量已经具有正确大小的假设，那么检查和可能调整向量的大小是一个不能被删除的操作；这与Assert调用是一个契约，如果程序是在优化模式下编译的，那么Assert调用将被完全删除。  
* 同样，如果由于某种意外，有人试图在只有一个空间维度的情况下编译和运行程序（在这种情况下，弹性方程没有什么意义，因为它们还原为普通的拉普拉斯方程），我们在第二个断言中终止程序。然而，该程序在三维空间中也能正常工作。
* 

* 
* [1.x.63]
* 
* 该函数的其余部分实现了计算力值。我们将使用一个位于(0.5,0)和(-0.5,0)点周围的两个小圆圈（或球体，在3D中）的X方向的恒定（单位）力，以及位于原点周围的Y方向的力；在3D中，这些中心的Z分量也是零。    
* 为此，让我们首先定义两个对象来表示这些区域的中心。请注意，在构建点对象的时候，所有的分量都被设置为零。
* 

* 
* [1.x.64]
* 
* 如果[2.x.73]处于围绕这些点之一的半径为0.2的圆（球）中，那么将X方向的力设置为1，否则为0。
* 

* 
* [1.x.65]
* 
* 同样地，如果[2.x.74]在原点附近，那么将y方向的力设置为1，否则为0。
* 

* 
* [1.x.66]
* 
* [1.x.67] [1.x.68]。
 

 
* [1.x.69] [1.x.70]。
 

* 
* 以下是主类的构造函数。如前所述，我们想构造一个由多个标量有限元组成的矢量值有限元（即，我们想构造矢量值元素，使其每个矢量成分由一个标量元素的形状函数组成）。当然，我们想堆积在一起的标量有限元的数量等于解函数的分量数量，由于我们考虑每个空间方向的位移，所以是[2.x.75]。FESystem类可以处理这个问题：我们传递给它我们想组成系统的有限元，以及它的重复频率。
* 

* 
*  

* 
* [1.x.71]
* 
* 事实上，FESystem类还有几个构造函数，可以进行更复杂的操作，而不仅仅是将几个相同类型的标量有限元堆叠在一起，我们将在后面的例子中了解这些可能性。
* 

* 
*  
*  
* [1.x.72] [1.x.73].
 

* 
* 设置方程组与[2.x.76]例子中使用的函数相同。DoFHandler类和这里使用的所有其他类都完全知道我们要使用的有限元是矢量值的，并对有限元本身的矢量值进行了处理。(事实上，他们不知道，但这不需要困扰你：因为他们只需要知道每个顶点、直线和单元有多少个自由度，而且他们不问这些自由度代表什么，即考虑的有限元是矢量值的，还是例如在每个顶点有几个自由度的标量Hermite元)。
* 

* 
* [1.x.74]
* 
* [1.x.75] [1.x.76]
 

* 
* 这个程序中最大的变化是创建矩阵和右手边，因为它们是取决于问题的。我们将一步一步地完成这个过程 [2.x.77] ，因为它比以前的例子要复杂一些。  
* 然而，这个函数的前几部分和以前一样：设置一个合适的正交公式，为我们使用的（矢量值的）有限元以及正交对象初始化一个FEValues对象，并声明一些辅助数组。此外，我们还声明了永远相同的两个缩写。 [2.x.78] 和 [2.x.79] 。每个单元的自由度数量，我们现在显然是从组成的有限元中询问，而不是从底层的标量Q1元中询问。这里，它是[2.x.80]乘以Q1元素每单元的自由度数，尽管这不是我们需要关心的明确知识。
* 

* 
* [1.x.77]
* 
* 正如之前的例子所显示的那样，我们需要一个地方来存储一个单元上所有正交点的系数值。在目前的情况下，我们有两个系数，lambda和mu。
* 

* 
* [1.x.78]
* 
* 好吧，我们也可以省略上面的两个数组，因为我们将对lambda和mu使用常数系数，可以这样声明。它们都代表函数总是返回常量值1.0。尽管我们可以在矩阵的组合中省略各自的系数，但为了演示，我们在这里使用它们。
* 

* 
* [1.x.79]
* 
* 和上面的两个常量函数一样，我们将在每个单元格中只调用一次函数right_hand_side，以使事情更简单。
* 

* 
* [1.x.80]
* 
* 现在我们可以开始对所有单元格进行循环。
* 

* 
* [1.x.81]
 
* 接下来我们得到正交点上的系数值。同样，对于右手边的情况也是如此。
* 

* 
* [1.x.82]
* 
* 然后把局部刚度矩阵的条目和右手边的矢量组合起来。这几乎是一对一地遵循本例介绍中描述的模式。 为数不多的评论之一是，我们可以使用下面的[2.x.83]函数调用来计算数字[2.x.81]，即形状函数[2.x.82]的唯一非零向量分量的索引。        
*（通过访问[2.x.85]函数返回值的[2.x.84]变量，你可能已经猜到其中有更多的内容。事实上，该函数返回一个[2.x.86]int，无符号int[2.x.87]，其中第一个元素是[2.x.88]，第二个元素是介绍中也指出的值[2.x.89]，即这个形状函数在这个组件中所有非零的形状函数中的索引，即介绍中的字典[2.x.90]。然而，这并不是我们通常感兴趣的数字）。)         
* 有了这些知识，我们就可以把局部矩阵的贡献集合起来。
* 

* 
* [1.x.83]
* 
* 第一个项是[2.x.91] 。注意，[2.x.92]返回正交点q_point处第i个形状函数唯一非零分量的梯度。梯度的分量[2.x.93]是第i个形状函数的唯一非零向量分量相对于comp(i)th坐标的导数，由附加的括号访问。
* 

* 
* [1.x.84]
* 
* 第二个项是[2.x.94] 。我们不需要访问梯度的具体分量，因为我们只需要计算两个梯度的标量乘积，这个问题由<tt>operator*</tt>的重载版本负责，就像之前的例子一样。                        
* 注意，通过使用<tt>?:</tt>操作符，我们只在<tt>component_i</tt>等于<tt>component_j</tt>的情况下才这样做，否则会加上一个零（编译器会将其优化掉）。
* 

* 
* [1.x.85]
* 
* 汇编右手边的内容也和介绍中讨论的一样。
 

* 
* [1.x.86]
* 
* 从局部自由度到全局矩阵和右手向量的转移并不取决于所考虑的方程，因此与之前所有的例子相同。
* 

* 
* [1.x.87]
* 
* [1.x.88] [1.x.89]
 

* 
* 解算器并不关心方程组的来源，只要它保持正定和对称（这是使用CG解算器的要求），而该系统确实是这样的。因此，我们不需要改变任何东西。
* 

* 
* [1.x.90]
* 
* [1.x.91] [1.x.92]。
 

* 
* 对网格进行细化的函数与[2.x.95]的例子相同。正交公式再次适应于线性元素。请注意，误差估计器默认情况下是将从有限元解的所有分量中得到的估计值相加，也就是说，它使用所有方向的位移，权重相同。如果我们希望网格只适应x方向的位移，我们可以给函数传递一个额外的参数，告诉它这样做，而不考虑其他所有方向的位移作为误差指标。然而，对于目前的问题，似乎应该考虑所有的位移成分，而且权重相同。
* 

* 
* [1.x.93]
* 
* [1.x.94] [1.x.95].
 

* 
* 输出的情况主要是在以前的例子中已经显示过了。唯一的区别是，求解函数是矢量值的。DataOut类会自动处理这个问题，但我们必须给求解向量的每个分量一个不同的名字。  
* 要做到这一点，[2.x.96]函数需要一个字符串的向量。由于分量的数量与我们工作的维数相同，我们使用下面的[2.x.97]语句。  
* 我们注意到，一些图形程序对变量名称中允许的字符有限制。因此，deal.II只支持所有程序都支持的这些字符的最小子集。基本上，这些字符是字母、数字、下划线和其他一些字符，但特别是没有空格和减号/横线。否则该库会抛出一个异常，至少在调试模式下是这样。  
* 在列出了1d、2d和3d的情况后，如果我们遇到一个我们没有考虑到的情况，让程序死亡是一种很好的风格。记住，如果第一个参数中的条件不满足，Assert宏就会产生一个异常。当然，条件[2.x.98]永远不可能被满足，所以只要程序运行到默认语句，就会中止。
* 

* 
* [1.x.96]
* 
* 在为解向量的不同组成部分设置了名称之后，我们可以将解向量添加到计划输出的数据向量列表中。请注意，下面的函数需要一个字符串向量作为第二个参数，而我们在以前所有例子中使用的函数在那里接受一个字符串。(事实上，我们之前使用的函数会将单个字符串转换成只有一个元素的向量，并将其转发给另一个函数)。
* 

* 
* [1.x.97]
* 
* [1.x.98] [1.x.99]
 

* 
* [2.x.99]函数所做的事情与[2.x.100]中的相同，例如。这一次，我们使用平方[-1,1]^d作为域，在开始第一次迭代之前，我们对它进行了四次全局细化。  
* 细化的原因有点意外：我们使用QGauss正交公式，在每个方向上都有两个点用于整合右手边；这意味着每个单元上有四个正交点（在二维）。如果我们只对初始网格进行一次全局细化，那么在域上每个方向上就只有四个正交点。然而，右侧函数被选择为相当局部的，在这种情况下，纯属偶然，恰好所有的正交点都位于右侧函数为零的点上（用数学术语来说，正交点恰好在右侧函数的[1.x.100]之外的点上）。这样一来，用正交计算的右手向量将只包含零（尽管如果我们完全用积分计算右手向量的话，它当然会是非零的），方程组的解就是零向量，即一个处处为零的有限元函数。从某种意义上说，我们不应该对这种情况的发生感到惊讶，因为我们选择了一个完全不适合当前问题的初始网格。  
* 不幸的是，如果离散解是常数，那么KellyErrorEstimator类计算的误差指标对每个单元来说也是零，对[2.x.101]的调用将不会标记任何单元进行细化（如果每个单元的指示误差是零，为什么要这样做？因此，下一次迭代中的网格也将只由四个单元组成，同样的问题再次发生。  
* 结论需要是：虽然我们当然不会选择非常适合准确解决问题的初始网格，但我们至少必须选择它，使它有机会捕捉到解决方案的重要特征。在这种情况下，它需要能够看到右手边的情况。因此，我们进行了四次全局细化。当然，任何更大数量的全局细化步骤也是可行的）。
* 

* 
* [1.x.101]
* 
* [1.x.102] [1.x.103].
 

* 
* 在上面最后一行关闭了[2.x.102]的名字空间后，下面是程序的主要功能，又和[2.x.103]中一模一样（当然，除了改变了类的名字）。
* 

* 
* [1.x.104]
* [1.x.105][1.x.106] 。
* 

* 
* 关于这个程序的结果，除了看起来很好之外，没有什么可说的。所有图像都是用VisIt从程序写入磁盘的输出文件中制作的。前两张图片显示了[2.x.104]-和[2.x.105]-位移的标量分量。
* [2.x.106] 
* 

* 你可以清楚地看到在[2.x.108]和[2.x.109]周围的[2.x.107]-位移的来源，以及在原点的[2.x.110]-位移。
* 人们经常想做的是将位移显示为一个矢量场，也就是说，每个点的矢量都能说明位移的方向和大小。不幸的是，这就有点复杂了。为了理解这一点，请记住，我们刚刚将有限元定义为两个分量的集合（在[2.x.111]维度）。我们没有说过这不仅仅是一个压力和一个浓度（两个标量），而是说这两个分量实际上是一个向量值的量的一部分，即位移。如果没有这方面的知识，DataOut类就会假定我们打印的所有单个变量都是分离卡尔，而VisIt和Paraview就会忠实地假定它确实是这样的。换句话说，一旦我们把数据写成标量，这些程序中就没有任何东西可以让我们把这两个标量字段粘贴在一起作为一个向量字段。我们必须从根本上解决这个问题，即在 [2.x.112] 中。我们不会在这里这样做，而是让读者参考[2.x.113]程序，在那里我们展示了如何在一个更普遍的情况下这样做。尽管如此，我们还是忍不住要生成数据，以显示如果按照[2.x.114]中讨论的方式实施，会是什么样子。矢量场看起来是这样的（VisIt和Paraview随机选择几百个顶点来绘制矢量；从每个顶点绘制矢量会使图片无法阅读）。
* [2.x.115] 
* 

* 我们注意到，由于[2.x.118]和[2.x.119]的力相对于这些轴是对称的，所以人们可能直观地期望解决方案是关于[2.x.116]-和[2.x.117]轴的对称性。然而，作为一个矢量的力不是对称的，因此也不是解决方案。
* 

* [1.x.107][1.x.108] [2.x.120] 。
* [0.x.1]

