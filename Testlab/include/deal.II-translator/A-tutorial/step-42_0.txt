include/deal.II-translator/A-tutorial/step-42_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.3] 
*[1.x.39][1.x.40] 。
 

* 
* [1.x.41][1.x.42][1.x.43] 。
* 

* 这个例子是[2.x.4]的扩展，考虑的是三维接触问题，具有各向同性硬化的弹塑性材料行为。换句话说，它考虑的是，如果把一个刚性的障碍物推到三维体上（接触问题），变形受弹塑性材料法则（一种只能容纳一定最大应力的材料）支配，随着变形的累积而变硬。为了说明我们打算做什么，在讨论太多细节之前，让我们先看看解决方案是什么样子的（可变形体是一个立方体
* 
* -实际上只显示了一半的内容
* 
* - 障碍物对应于一个汉字，将在下面讨论）。)
* [2.x.5] 
* 

* 这个问题的描述意味着，与[2.x.6]相比，我们必须照顾到一个额外的非线性因素：物质行为。由于我们在这里考虑的是一个三维问题，我们还必须考虑到这样一个事实，即现在接触区是在可变形体的边界，而不是在内部。最后，与[2.x.7]相比，在处理线性系统和不等式约束时，我们还必须处理悬挂节点的问题，因为我们希望使用自适应网格；在后一种情况下，我们必须处理悬挂节点的约束还是不等式的约束更重要的优先次序。
* 由于在三维空间中很容易达到几百万个自由度，即使使用自适应网格细化，我们决定使用Trilinos和p4est来并行运行我们的代码，在[2.x.8]的框架上进行并行化。其他并行化的指针可以在[2.x.9]中找到。
* 

* [1.x.44][1.x.45] 。
* 

* 该问题的经典表述具有以下形式。
* [1.x.46]
* 这里，这些方程中的第一个定义了应变[2.x.10]和应力[2.x.11]之间的关系，即四阶顺应性张量[2.x.12]；[2.x.13]提供了应变的塑性成分，以确保应力不超过屈服应力。我们将只考虑各向同性的材料，对于这些材料，[2.x.14]可以用Lam&eacute;模量[2.x.15]和[2.x.16]表示，或者用体模量[2.x.17]和[2.x.18]表示。第二个方程是力平衡；我们将不考虑任何体力，因此假设[2.x.19] 。第三行的互补条件意味着如果[2.x.21]，则[2.x.20]，但如果且仅如果[2.x.23]，则[2.x.22]可能是一个非零张量，特别是在这种情况下，[2.x.24]必须指向[2.x.25]方向。不等式[2.x.26]是塑性材料只能支持有限的应力；换句话说，如果外力会导致应力[2.x.28]，而[2.x.29]会导致塑性变形[2.x.27]，它们就会发生反应。这种[1.x.47]的典型形式是[2.x.30]，其中[2.x.31]是张量的偏离部分，[2.x.32]表示Frobenius规范。
* 进一步的方程描述了在[2.x.33]上的固定的零位移，在可能出现接触的表面[2.x.34]上，障碍物施加的法向力[2.x.35]是向内的（障碍物对我们身体没有 "拉"），切向分量为零[2.x.36 最后一个条件也是一个互补条件，它意味着在[2.x.37]上，只有当身体与障碍物接触时，法向力才可能是非零的；第二部分描述了障碍物和身体的不可穿透性。
* 大多数材料
* 
* - 特别是金属
* 
* - 具有这样的特性：它们在变形后会出现一些硬化。换句话说，[2.x.38]随着变形而增加。实际上，导致硬化的不是弹性变形，而是塑性成分。有不同的构成律来描述这些材料行为。最简单的是线性各向同性硬化，由流动函数[2.x.39]描述。
* 

*[1.x.48][1.x.49] 。
* 

* 一般来说，处理不等式是相当笨拙的。在这里，我们必须处理两个问题：塑性和接触问题。正如在本页顶部提到的论文中详细描述的那样，至少可以重新表述塑性，使其看起来像一个非线性，然后我们可以用牛顿方法处理。这在数学上略显棘手，因为非线性不只是一些平滑的函数，而是在应力达到屈服应力的地方有结点；然而，对于这样的[1.x.50]函数，可以证明牛顿方法仍然收敛。
* 在不详细说明的情况下，我们也将摆脱应力作为一个独立变量，而只用位移[2.x.40]来工作。最终，这个重构的目标是我们希望最终得到一个对称的、正定的问题
* 
* - 如一个线性化的弹性问题，其空间可变系数由塑性行为产生。
* 
* - 需要在每个牛顿步骤中解决。我们希望如此，因为有高效和可扩展的方法来解决这样的线性系统，如用代数多重网格的CG预处理。这与类似于混合拉普拉斯的鞍点问题（见[2.x.41]）相反，如果我们继续使用包含位移和应力的混合公式，就会得到鞍点问题，对于这个问题，[2.x.42]已经提示了构建良好的求解器和预处理器是多么困难。
* 说到这里，让我们简单陈述一下重构后得到的问题（同样，细节可以在论文中找到）。找到一个位移[2.x.43]，以便
* [1.x.51]
*其中投影仪[2.x.44]被定义为
* [1.x.52]
* 而空间[2.x.45]是满足接触条件的所有位移的空间。
* [1.x.53]
* 
* 在实际代码中，我们将使用缩写[2.x.46] 。
* 鉴于这种表述，我们将应用两种技术。
* 
* - 运行一个牛顿方法来迭代出投影仪中的非线性。
* 
* - 为接触条件运行一个主动集方法，其方式与我们在 [2.x.47] 中所做的基本相同。
* 一个严格的方法是在我们迭代牛顿方法到收敛时保持活动集的固定（或者反过来：在进入下一次牛顿迭代前找到最终的活动集）。在实践中，事实证明，每次活动集迭代只做一个牛顿步骤就足够了，所以我们将同时迭代它们。我们还将每隔一段时间细化一下网格。
* 

*[1.x.54][1.x.55]
* 

* 如前所述，我们将采用牛顿方法来处理算子[2.x.48]的非线性问题，尽管该算子在严格意义上是不可微的。然而，它满足[1.x.56]的可微条件，这就足以让牛顿方法发挥作用。由此产生的方法被称为[1.x.57]，听起来令人印象深刻，但实际上只是将牛顿方法应用于具有适当 "导数 "的半光滑函数。
* 在当前情况下，我们将通过在每次迭代中求解[2.x.49]来运行我们的迭代，即以下方程（仍然是一个不等式，但已线性化）。
* [1.x.58]
*其中等级4的张量[2.x.50]由以下公式给出
* [1.x.59]
* 这个张量是[2.x.51]围绕[2.x.52]的（形式）线性化。对于我们这里考虑的线性各向同性材料，投影仪的体积和剪切成分由[1.x.60]给出。
* 其中[2.x.53]和[2.x.54]分别是等级为2和4的认同张量。
* 请注意，这个问题对应于一个线性弹性接触问题，其中[2.x.55]起到弹性张量[2.x.56]的作用。事实上，如果材料在某一点上没有塑性，那么[2.x.57] 。然而，在材料具有塑性的地方，[2.x.58]是一个空间变化的函数。在任何情况下，我们必须为牛顿迭代[2.x.59]求解的系统使我们更接近重写问题的目标，使我们能够使用著名的求解器和预处理器来处理椭圆系统。
* 作为对牛顿方法的最后说明，让我们提到，与牛顿方法一样，我们需要通过控制步长使其全球化。换句话说，虽然上面的系统求解的是[2.x.60]，但最终的迭代结果将是
* [1.x.61]
* 其中右侧括号中的差值代表了传统的牛顿方向，即[2.x.61]。我们将使用标准的直线搜索来确定[2.x.62]。
* 

* [1.x.62][1.x.63] 。
* 

* 这个在每个牛顿步骤中要解决的线性化问题基本上与[2.x.63]相似。唯一的区别在于接触区是在边界而不是在域内。但这没有进一步的后果，所以我们参考文献[2.x.64]，唯一的提示是[2.x.65]包含了接触边界[2.x.66]上的所有顶点的时间。如同那里，我们需要做的是保持自由度的一个子集的固定，导致额外的约束，可以写成鞍点问题。然而，正如论文中所讨论的，通过以适当的方式写这些约束，消除自由度之间的耦合，我们最终得到一组节点，基本上只是有Dirichlet值附加在它们身上。
* 

*[1.x.64][1.x.65]
* 

* 上述算法结合了阻尼半光滑牛顿法（我们用于非线性构成法）和半光滑牛顿法（用于接触）。它的工作原理如下。[2.x.67] [2.x.68] 初始化主动集和非主动集[2.x.69]和[2.x.70]，使得[2.x.71]和[2.x.72]和设置[2.x.73] 。这里，[2.x.74]是位于可能发生接触的域的表面的所有自由度的集合。起始值[2.x.75]满足我们的障碍条件，也就是说，我们将初始零位移投射到可行位移集合上。
* [2.x.76] 组建牛顿矩阵 [2.x.77] 和右手边 [2.x.78] 。这些对应于线性化的牛顿步骤，暂时忽略了接触不等式。
* [2.x.79] 找到满足以下条件的主-偶对 [2.x.80] 。

* 
* [1.x.66]
* 如同[2.x.81]，我们可以通过从第一个方程中消除[2.x.82]中的那些自由度来得到这个问题的解决方案，并得到一个线性系统[2.x.83] 。
* 

* 
* [2.x.84] 通过应用直线搜索和计算[2.x.86]和[2.x.87]的线性组合来减弱[2.x.85]的牛顿迭代。这需要找到一个[2.x.88]，以便[1.x.67]
* 满足[1.x.68]与[2.x.89]，除了(i)我们设置[2.x.91]的元素[2.x.90]，和(ii)对应悬挂节点的元素，我们以通常的方式消除。
* [2.x.92] 通过[1.x.69]定义新的活动和非活动集。
* [1.x.70]
 
* [2.x.93] 项目[2.x.94]，使其满足接触不等式，[1.x.71] 。
* 这里，[2.x.95]是[2.x.96]中的活性成分对间隙[1.x.72]的投影。
*其中[2.x.97]是[1.x.73]，表示障碍物与身体未位移配置的距离。
* [2.x.98] 如果[2.x.99]和[2.x.100]则停止，否则设置[2.x.101]并转到步骤（1）。这一步确保我们只有在找到正确的活动集和塑性已经迭代到足够的精度时才停止迭代。[2.x.102] 
* 在该算法的第3步中，矩阵[2.x.103]、[2.x.104]描述了位移和拉格朗日乘数（接触力）的基数的耦合，在我们的情况下它不是二次的，因为[2.x.105]只定义在[2.x.106]上，即可能发生接触的表面。如本文所示，我们可以选择[2.x.107]是一个每行只有一个条目的矩阵，（另见H&uuml;eber, Wohlmuth: A primal-dual activeset strategy for non-linear multibody contact problems, Comput. MECH.Engrg.194, 2005, pp. Engrg.194, 2005, pp.3147-3166）。向量[2.x.108]是由间隙[2.x.110][1.x.74]的合适近似值[2.x.109]定义的。]
* 
* 

* [1.x.75][1.x.76] 。
* 

* 由于我们的程序是在三维空间中运行的，所以程序所进行的计算是很昂贵的。因此，使用自适应网格细化是在可接受的运行时间内的一个重要步骤。为了使我们的生活更轻松，我们简单地选择已经在deal.II中实现的KellyErrorEstimator。我们把包含位移[2.x.111]的解决向量交给它。正如我们将在结果中看到的，它产生了一个相当合理的接触区和塑性的自适应网格。
* 

* [1.x.77][1.x.78] 。
* 

* 本教程基本上是[2.x.112]和[2.x.113]的混合体，但我们没有使用PETSc，而是让Trilinos库来处理线性代数的并行化问题（就像[2.x.114]中那样）。由于我们试图解决一个类似于[2.x.115]的问题，我们将使用同样的方法，但现在是并行的。
* 一个困难是如何处理来自Dirichlet条件的约束，悬挂的节点和接触产生的不平等条件。为此，我们创建了三个AffineConstraints类型的对象，它们描述了各种约束条件，我们将在每次迭代中适当地将它们组合起来。
* 与[2.x.116]相比，本程序有几个新的类。
* [2.x.117] [2.x.118] [2.x.119] 描述材料的塑性行为。
* [2.x.120] [2.x.121] 描述了一个球体，它作为障碍物被推入可变形的弹塑性体。 是用这个还是下一个类来描述障碍物，由输入参数文件决定。
* [2.x.122] [2.x.123] （和一个辅助类）是一个允许我们从文件中读入障碍物的类。在我们将在结果部分展示的例子中，这个文件将是[2.x.124]，并对应于显示力或功率的中文、日文或韩文符号的数据（见http://www.orientaloutpost.com/ : "这个词可以用于激励
* 
* - 它也可以指权力/运动/推动/力量。它可以是任何使你前进的内部或外部的东西。这是用中文表达动机的最安全的方式。如果你的听众是日本人，请看另一个关于动机的条目。这是日语和韩语中的一个词，但它的意思是 "动力 "或 "动能"（没有你可能正在寻找的动机的意思）"）。实质上，我们将假装有一个印章（即对应于平底障碍物的面具，没有中间高度的碎片），我们把它压在身体里。有关的符号看起来如下（也可参见本节顶部的图片，了解最终的结果是怎样的）。
* [2.x.125] [2.x.126]。
*除此之外，我们只对以下几个方面进行评论。[2.x.127] [2.x.128] 程序允许你通过参数文件从两个不同的粗略网格中选择。这些是立方体[2.x.129]或半球体，其开放面朝向正方向[2.x.130]。
* [2.x.131]在这两种情况下，我们将假定惯例，即可能与障碍物接触的边界部分具有边界指标一。对于这两种网格，我们假定这是一个自由表面，即身体要么在那里接触，要么没有力作用在它身上。对于半球体，弯曲部分的边界指标为零，我们在那里施加零位移。对于盒子，我们沿底部施加零位移，但允许沿边的垂直位移（尽管没有水平位移）。[2.x.132] 
* 

* [1.x.79] [1.x.80]。
* [1.x.81] [1.x.82] 这组包含文件在这个时候已经没有什么惊喜了。
* 

* 
* [1.x.83]
* 
* 最后，我们包括两个系统头文件，让我们为输出文件创建一个目录。第一个头文件提供了[2.x.133]的功能，第二个头文件让我们确定在[2.x.134]失败时发生了什么。
* 

* 
* [1.x.84]
* 
* [1.x.85] [1.x.86]。
 

* 
* 该类提供了一个构成法的接口，即应变 [2.x.135] 和应力 [2.x.136] 之间的关系。在这个例子中，我们使用的是具有线性、各向同性的硬化的弹塑性材料行为。这种材料的特点是杨氏模量 [2.x.137] ，泊松比 [2.x.138] ，初始屈服应力 [2.x.139] 和各向同性硬化参数 [2.x.140] 。 对于[2.x.141]我们得到完美的弹塑性行为。  
*正如描述这个程序的论文中所解释的，第一个牛顿步骤是用完全弹性材料模型来解决的，以避免同时处理两种非线性（塑性和接触）。为此，这个类有一个函数[2.x.142]，我们以后用它来简单地设置[2.x.143]为一个非常大的值
* 
* - 基本上保证了实际的应力不会超过它，从而产生一个弹性材料。当我们准备使用塑性模型时，我们使用相同的函数，将[2.x.144]设置回其适当的值。 由于这种方法，我们需要将[2.x.145]作为这个类的唯一非静态成员变量。
* 

* 
* [1.x.87]
* 
* ConstitutiveLaw类的构造函数为我们的可变形体设置所需的材料参数。弹性各向同性介质的材料参数可以用多种方式定义，如一对[2.x.146]（弹性模量和泊松数），使用Lam&eacute; 参数[2.x.147]或其他几种常用的约定。在这里，构造器采用[2.x.148]形式的材料参数描述，但由于这证明这些不是出现在塑性投影仪方程中的系数，我们立即将它们转换为更合适的体模和剪模的集合[2.x.149]。 此外，构造器将[2.x.150]（无任何塑性应变的屈服应力）和[2.x.151]（硬化参数）作为参数。在这个构造器中，我们还计算了应力-应变关系的两个主成分及其线性化。
* 

* 
* [1.x.88]
* 
* [1.x.89] [1.x.90].
 

* 
* 这是构成法的主成分。它计算四阶对称张量，根据上面给出的投影，当在一个特定的应变点上评估时，将应变与应力联系起来。我们需要这个函数来计算[2.x.152]中的非线性残差，我们将这个张量与正交点给出的应变相乘。计算遵循引言中列出的公式。在比较那里的公式和下面的实现时，记得[2.x.153]和[2.x.154] 。  
* 该函数返回正交点是否是塑性的，以便在下游对有多少正交点是塑性的，有多少是弹性的进行一些统计。
* 

* 
* [1.x.91]
* 
* [1.x.92] [1.x.93].
 

* 
* 该函数返回线性化的应力应变张量，围绕前一个牛顿步骤[2.x.155]的解线性化 [2.x.156] 。 参数[2.x.157]（通常表示为[2.x.158]）必须作为参数传递，并作为线性化点。该函数在变量stress_strain_tensor中返回非线性构成法的导数，在stress_strain_tensor_linearized中返回线性化问题的应力-应变张量。 参见[2.x.159]，该函数的使用情况。
* 

* 
* [1.x.94]
* 
* [1.x.95]   
* 下面的内容应该是比较标准的。我们需要边界强迫项（我们在此选择为零）和不属于接触面的边界部分的边界值（在此也选择为零）的类。
* 

* 
* [1.x.96]
* 
* [1.x.97] [1.x.98]
 

* 
* 下面这个类是可以从输入文件中选择的两个障碍物中的第一个。它描述了一个以位置[2.x.160]和半径[2.x.161]为中心的球体，其中[2.x.162]是可变形体的（平）表面的垂直位置。该函数的[2.x.163]返回给定[2.x.164]值的障碍物位置，如果该点实际位于球体下方，则返回一个大的正值，如果它位于球体的 "阴影 "之外，则不可能干扰变形。
* 

* 
* [1.x.99]
* 
* 前面的断言
* 

* 
* [1.x.100]
 
* [1.x.101] [1.x.102]。
 

* 
* 以下两个类描述了介绍中概述的障碍，即汉字。两个中的第一个，[2.x.165]负责从以pbm ascii格式存储的图片文件中读入数据。这个数据将被双线性插值，从而提供一个描述障碍物的函数。(下面的代码显示了如何通过在给定的数据点之间进行内插来构造一个函数。人们可以使用在本教程程序写完后引入的[2.x.166]，它正是我们在这里想要的，但看看如何用手来做是有启发的）。)     
* 我们从文件中读取的数据将存储在一个名为 obstacle_data 的双倍数 [2.x.167] 中。 这个向量构成了计算单片双线性函数的基础，作为一个多项式插值。我们将从一个文件中读取的数据由零（白色）和一（黑色）组成。    
* [2.x.168]变量表示[2.x.169]和[2.x.170]方向的像素之间的间距。 [2.x.171]是这些方向上每个像素的数量。  [2.x.172]返回图像在给定位置的值，由相邻的像素值插值而成。
* 

* 
* [1.x.103]
* 
* 该类的构造函数从给定的文件名中读入描述障碍物的数据。
* 

* 
* [1.x.104]
* 
* 以下两个函数返回坐标为[2.x.173]的给定像素的值，我们用定义在位置[2.x.174]的函数值来识别，在任意坐标[2.x.175]处，我们在两个函数中的第一个返回的点值之间做双线性插值。在第二个函数中，对于每个[2.x.176]，我们首先计算离[2.x.177]左下方最近的像素坐标的（整数）位置，然后计算这个像素内的坐标[2.x.178]。我们从下方和上方截断这两种变量，以避免在评估函数时超出其定义的范围而可能发生的舍入误差问题。
* 

* 
* [1.x.105]
* 
* 最后，这是一个实际使用上面的类的类。它有一个BitmapFile对象作为成员，描述障碍物的高度。如上所述，BitmapFile类将为我们提供一个掩码，也就是0或1的值（如果你要求的是像素之间的位置，则是在0和1之间插值的值）。这个类将其转化为高度，即低于可变形体表面的0.001（如果BitmapFile类在此位置报告为1）或高于障碍物的0.999（如果BitmapFile类报告为0）。那么下面的函数应该是不言自明的。
* 

* 
* [1.x.106]
* 
* 前面的断言
* 

* 
* [1.x.107]
* 
* [1.x.108] [1.x.109]。
 

* 
* 这是本程序的主类，提供描述非线性接触问题所需的所有函数和变量。它接近于[2.x.179]，但有一些额外的功能，如处理悬挂节点，牛顿方法，使用Trilinos和p4est进行并行分布式计算。处理悬空节点使生活变得有点复杂，因为我们现在需要另一个AffineConstraints对象。我们为接触情况下的主动集合方法创建一个牛顿方法，并处理构成法的非线性算子。  
* 这个类的总体布局与其他大多数教程程序非常相似。为了使我们的生活更容易一些，这个类从输入文件中读取一组输入参数。这些参数，使用ParameterHandler类，在[2.x.180]函数中声明（该函数是静态的，因此它可以在我们创建当前类型的对象之前被调用），然后一个已经用于读取输入文件的ParameterHandler对象将被传递给该类的构造函数。  
* 其余的成员函数大体上与我们在其他几个教程程序中看到的一样，尽管为当前的非线性系统增加了一些内容。我们将在下面进一步讨论它们的目的。
* 

* 
* [1.x.110]
* 
* 就成员变量而言，我们先用一个变量来表示这个程序运行的MPI宇宙，用一个流来让一个处理器产生输出到控制台（见[2.x.181] ），还有一个变量用来为程序的各个部分计时。
* 

* 
* [1.x.111]
 
* 下一组描述了网格和有限元空间。特别是，对于这个并行程序，有限元空间有与之相关的变量，表明哪些自由度存在于当前的处理器上（索引集，也见[2.x.182]和[2.x.183]文档模块），以及各种约束：那些由悬挂节点，由Dirichlet边界条件，以及由接触节点的活动集施加的约束。在这里定义的三个AffineConstraints变量中，第一个只包含悬挂节点的约束，第二个也包含与Dirichlet边界条件相关的约束，第三个则是这些约束加上接触约束。    
* 变量[2.x.184]包括那些由接触约束的自由度，我们用[2.x.185]来跟踪每个单元上应力等于屈服应力的正交点的分数。后者仅用于创建显示塑性区的图形输出，但不用于任何进一步的计算；该变量是该类的成员变量，因为该信息是作为计算残差的副产品计算的，但仅在很久之后才使用。(注意，该向量是一个长度等于[1.x.112]上活动单元数量的向量；它从未被用来在处理器之间交换信息，因此可以是一个常规的deal.II向量)。
* 

* 
* [1.x.113]
* 
* 下一个变量块对应的是解决方案和我们需要形成的线性系统。特别是，这包括牛顿矩阵和右手边；对应于残差（即牛顿右手边）但我们没有消除各种约束的向量，该向量用于确定在下一次迭代中需要约束哪些自由度；以及对应于介绍中简要提到并在随文讨论的[2.x.186]矩阵的对角线的向量。
* 

* 
* [1.x.114]
 
* 下一个块包含描述材料响应的变量。
* 

* 
* [1.x.115]
* 
* 然后是各种各样的其他变量，用于识别参数文件所选择的要求我们建立的网格，被推入可变形体的障碍物，网格细化策略，是否将解决方案从一个网格转移到下一个网格，以及要执行多少个网格细化循环。在可能的情况下，我们将这类变量标记为[2.x.187]，以帮助读者识别哪些变量以后可能会被修改，哪些可能不会被修改（输出目录是一个例外
* 
* - 它从未在构造函数之外被修改过，但在构造函数中冒号后面的成员初始化列表中初始化是很尴尬的，因为在那里我们只有一次机会来设置它；对于网格细化准则也是如此）。)
* 

* 
* [1.x.116]
* 
* [1.x.117] [1.x.118]
 

* 
* [1.x.119] [1.x.120]。
 

* 
* 让我们从声明可在输入文件中选择的运行时参数开始。这些值将在这个类的构造函数中读回，以初始化这个类的成员变量。
* 

* 
* [1.x.121]
* 
* [1.x.122] [1.x.123]
* 

* 
* 鉴于成员变量的声明以及从输入文件中读取的运行时参数的声明，这个构造函数中没有任何令人惊讶的地方。在正文中，我们初始化了网格细化策略和输出目录，如果需要的话，可以创建这样一个目录。
* 

* 
* [1.x.124]
* 
* 如果有必要，为输出创建一个新的目录。
* 

* 
* [1.x.125]
* 
* [1.x.126] [1.x.127]。
 

* 
* 下一个区块涉及到构建起始网格。我们将使用下面的辅助函数和[2.x.188]的第一个块来构造一个对应于半球形的网格。deal.II有一个函数可以创建这样的网格，但是它的位置和方向都是错误的，所以我们需要在使用它之前对它进行一些位移和旋转。  
*供以后参考，如[2.x.189]的文件中所述，半球体的平坦表面的边界指标为0，而其余部分的边界指标为1。
* 

* 
* [1.x.128]
 
* 因为我们将在下面附加一个不同的流形，所以我们立即清除默认的流形描述。
* 

* 
* [1.x.129]
* 
* 或者，创建一个超立方体网格。创建后，按如下方式分配边界指标。 [2.x.190] 换句话说，立方体的边的边界指标是8。底部的边界指标是6，顶部的指标是1。我们通过循环所有面的所有单元并查看单元中心的坐标值来设置这些指标，并在以后评估哪个边界将携带迪里希特边界条件或将受到潜在接触时利用这些指标。(在目前的情况下，网格只包含一个单元，它的所有面都在边界上，所以严格来说，所有单元的循环和查询一个面是否在边界上都是不必要的；我们保留它们只是出于习惯：这种代码可以在许多程序中找到，基本上都是这种形式。)
* 

* 
* [1.x.131]
* 
* [1.x.132] [1.x.133]
 

* 
* 谜题的下一块是设置DoFHandler，调整向量大小，并照顾其他各种状态变量，如索引集和约束矩阵。  
* 在下文中，每一组操作都被放入一个大括号封闭的块中，该块的顶部声明的变量正在进行计时（[2.x.191]变量的构造器开始计时部分，在块的末端调用的析构器再次停止计时）。
* 

* 
* [1.x.134]
 
* 最后，我们设置了稀疏性模式和矩阵。我们暂时（ab）用系统矩阵也建立（对角线）矩阵，在消除与障碍物接触的自由度时使用，但我们随后立即将牛顿矩阵设回零。
* 

* 
* [1.x.135]
* 
* [1.x.136] [1.x.137]
 

* 
* 这个函数是从前面的函数中分解出来的，它计算与迪里切特型边界条件相关的约束，并通过与来自悬挂节点的约束合并，将它们放入[2.x.192]变量中。  
* 正如介绍中所阐述的，我们需要区分两种情况。
* 

* 
* 
* - 如果域是一个盒子，我们将底部的位移设置为零，并允许沿侧面在Z方向的垂直运动。如[2.x.193]函数所示，前者对应于边界指标6，后者对应于8。
* 

* 
* 
* - 如果域是一个半球形，那么我们沿边界的弯曲部分施加零位移，与边界指标0相关。
* 

* 
* [1.x.138]
* 
* 内插解的所有分量
* 

* 
* [1.x.139]
* 
*插值解决方案的x-和y-分量（这是一个位掩码，所以应用运算器|）。
* 

* 
* [1.x.140]
* 
* [1.x.141] [1.x.142]。
 

* 
* 下一个辅助函数计算（对角线）质量矩阵，用于确定我们在接触算法中使用的主动集合方法的主动集合。这个矩阵是质量矩阵类型的，但是与标准质量矩阵不同，我们可以通过使用正交公式使其成为对角线（甚至在高阶元素的情况下），该公式的正交点与有限元的插值点所在的位置完全一致。我们通过使用QGaussLobatto正交公式来实现这一点，同时用一组从同一正交公式得出的插值点初始化有限元。该函数的其余部分相对简单：我们将得到的矩阵放入给定的参数中；因为我们知道矩阵是对角线的，所以只需在[2.x.194]而不是[2.x.195]上有一个循环即可。严格来说，我们甚至可以避免在正交点[2.x.196]处将形状函数的值与自身相乘，因为我们知道形状值是一个恰好有一个一的向量，当与自身相点时产生一。由于这个函数不是时间关键，为了清楚起见，我们添加了这个术语。
* 

* 
* [1.x.143]
* 
* [1.x.144] [1.x.145].
 

* 
* 以下函数是我们在[2.x.197]函数中每次牛顿迭代时调用的第一个函数。它的作用是将解决方案投射到可行集上，并更新接触或穿透障碍物的自由度的活动集。  
*为了实现这个功能，我们首先需要做一些记账工作。我们需要写进解决方案向量（我们只能用没有鬼魂元素的完全分布的向量来写），我们需要从各自的向量中读取拉格朗日乘数和对角线质量矩阵的元素（我们只能用确实有鬼魂元素的向量来写），所以我们创建各自的向量。然后我们还初始化约束对象，该对象将包含来自接触和所有其他来源的约束，以及一个包含所有属于接触的本地自由度的索引集的对象。
* 

* 
* [1.x.146]
* 
* 第二部分是对所有单元的循环，在这个循环中，我们看每一个定义了自由度的点，是否活动集条件为真，我们需要把这个自由度添加到接触节点的活动集上。正如我们一直所做的，如果我们想在单个点上评估函数，我们用一个FEValues对象（或者，这里是FEFaceValues对象，因为我们需要检查表面的接触）和一个适当选择的正交对象来做。我们通过选择定义在单元格面上的形状函数的 "支持点 "来创建这个面的正交对象（关于支持点的更多信息，请参见这个[2.x.198]"词汇表条目"）。因此，我们有多少个正交点就有多少个面的形状函数，在正交点上循环就相当于在面的形状函数上循环。有了这个，代码看起来如下。
* 

* 
* [1.x.147]
* 
* 在每个正交点（即位于接触边界上的自由度的每个支持点），我们再询问它是否是z-位移自由度的一部分，如果我们还没有遇到这个自由度（对于那些位于面之间的边缘的自由度可能发生），我们需要评估变形物体和障碍物之间的差距。如果活动集条件为真，那么我们在AffineConstraints对象中添加一个约束，下一次牛顿更新需要满足该约束，将解向量的相应元素设置为正确的值，并将索引添加到IndexSet对象中，该索引存储哪个自由度是接触的一部分。
* 

* 
* [1.x.148]
* 
* 在这个函数的最后，我们在处理器之间交换数据，更新[2.x.199]变量中那些被其他处理器写入的鬼魂元素。然后我们将Dirichlet约束和那些来自悬挂节点的约束合并到已经包含活动集的AffineConstraints对象中。我们通过输出主动约束自由度的总数来结束这个函数，对于这个自由度，我们对每个处理器所拥有的主动约束自由度的数量进行求和。这个本地拥有的受限自由度的数量当然是活动集和本地拥有的自由度集的交集的元素数量，我们可以通过在两个IndexSets上使用[2.x.200]得到。
* 

* 
* [1.x.149]
* 
* [1.x.150] [1.x.151]
 

* 
* 考虑到问题的复杂性，我们在每次牛顿迭代中要解决的线性系统的组合实际上是相当简单的，这可能会让人感到惊讶。下面的函数建立了牛顿的右手边和牛顿矩阵。它看起来相当简单，因为繁重的工作发生在对[2.x.201]的调用中，特别是在[2.x.202]中使用我们先前计算的约束条件。
* 

* 
* [1.x.152]
* 
* 在计算了应力-应变张量及其线性化之后，我们现在可以把矩阵和右手边的部分放在一起。在这两者中，我们需要线性化的应力-应变张量乘以[2.x.203]的对称梯度，即术语[2.x.204]，所以我们引入这个术语的缩写。回顾一下，该矩阵对应于随附出版物的符号中的双线性形式[2.x.205]，而右手边是[2.x.206]，其中[2.x.207]是当前的线性化点（通常是最后的解）。这可能表明，如果材料是完全弹性的，右手边将为零（其中[2.x.208]），但这忽略了一个事实，即右手边还将包含由于接触而产生的非均质约束的贡献。                  
* 接下来的代码块增加了由于边界力的贡献，如果有的话。
* 

* 
* [1.x.153]
* 
* [1.x.154] [1.x.155] * [1.x.155].
 

* 
* 以下函数计算给定当前解（或任何其他线性化点）的方程的非线性残差。这在线性搜索算法中是需要的，我们需要尝试先前和当前（试验）解的各种线性组合来计算当前牛顿步骤的（真实的、全局化的）解。  
* 也就是说，在略微滥用函数名称的情况下，它实际上做得更多。例如，它还计算对应于牛顿残差的向量，但没有消除受限自由度。我们需要这个向量来计算接触力，并最终计算出下一个活动集。同样，通过跟踪我们在每个单元上遇到的显示塑性屈服的正交点的数量，我们也可以计算出[2.x.209]矢量，随后我们可以输出这个矢量来可视化塑性区。在这两种情况下，作为线条搜索的一部分，这些结果是不必要的，因此我们可能会浪费少量的时间来计算它们。同时，无论如何，这些信息是作为我们在这里需要做的事情的自然副产品出现的，而且我们想在每个牛顿步骤结束时收集一次，所以我们不妨在这里做。  
* 这个函数的实际实现应该是相当明显的。
* 

* 
* [1.x.156]
* 
* [1.x.157] [1.x.158]。
 

* 
* 在我们讨论单个网格上的实际牛顿迭代之前的最后一块是线性系统的求解器。有几个复杂的问题使代码略显模糊，但大多数情况下，它只是设置然后求解。在这些复杂的问题中，包括。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
* 
* - 对于悬空节点，我们必须将[2.x.210]函数应用于newton_rhs。如果一个求解值为[2.x.211]的悬空节点有一个与障碍物接触的数值为[2.x.212]的邻居和一个没有接触的邻居[2.x.213]，这就有必要。因为前者的更新将是规定的，所以悬挂的节点约束将有一个不均匀性，看起来像 [2.x.214] 。所以右侧的相应条目是无意义的非零值。这些值我们必须设置为零。
* 

* 
* 
* - 与[2.x.215]一样，在求解或使用解决方案时，我们需要在有鬼元素和无鬼元素的向量之间进行洗牌。  
* 该函数的其余部分与[2.x.216]和[2.x.217]类似，只是我们使用BiCGStab求解器而不是CG。这是由于对于非常小的硬化参数[2.x.218]，线性系统变得几乎是半无限的，尽管仍然是对称的。BiCGStab似乎更容易处理这种线性系统。
* 

* 
* [1.x.159]
* 
* [1.x.160] [1.x.161].
 

* 
* 最后，这是一个在当前网格上实现阻尼牛顿方法的函数。有两个嵌套的循环：外循环用于牛顿迭代，内循环用于直线搜索，只有在必要时才会使用。为了获得一个好的和合理的起始值，我们在每个网格上的第一个牛顿步骤中解决一个弹性问题（如果我们在网格之间转移解决方案，则只在第一个网格上解决）。我们通过在这些迭代中将屈服应力设置为一个不合理的大值，然后在随后的迭代中将其设置回正确的值。  
* 除此以外，这个函数的顶部部分应该是相当明显的。我们将变量[2.x.219]初始化为可以用双精度数字表示的最负值，这样，比较当前残差是否小于上一步的残差，在第一步中总是会失败。
* 

* 
* [1.x.162]
 
* 在我们计算了当前牛顿步骤的试解[2.x.220]之后，情况就变得有点棘手了。我们处理的是一个高度非线性的问题，所以我们必须用直线搜索的方式来抑制牛顿方法。为了理解我们如何做到这一点，请回顾一下，在我们的公式中，我们在每一个牛顿步骤中计算一个试解，而不是在新旧解之间进行更新。由于解集是一个凸集，我们将使用直线搜索，尝试以前的解和试验解的线性组合，以保证阻尼解再次出现在我们的解集中。我们最多会应用5个阻尼步骤。        
* 我们使用直线搜索的时候有一些例外情况。首先，如果这是任何网格上的第一个牛顿步骤，那么我们就没有任何点来比较残差，所以我们总是接受一个完整的步骤。同样地，如果这是第一个网格上的第二个牛顿步骤（如果我们不在网格之间转移解决方案，则是任何网格上的第二个牛顿步骤），那么我们只用弹性模型计算了其中的第一个步骤（见上文我们如何将屈服应力σ设置为一个不合理的大值）。在这种情况下，第一个牛顿解是一个纯粹的弹性解，第二个牛顿解是一个塑性解，任何线性组合都不一定会位于可行的集合中
* 
* -所以我们就接受刚才的解。        
* 在这两种情况下，我们绕过直线搜索，只是在必要时更新残差和其他向量。
* 

* 
* [1.x.163]
 
* 最后一步是检查收敛情况。如果活动集在所有处理器上都没有变化，并且残差小于阈值[2.x.221] ，那么我们就终止在当前网格上的迭代。
* 

* 
* [1.x.164]
* 
* [1.x.165] [1.x.166] * * [1.x.165] * [1.x.166].
 

* 
* 如果你已经在deal.II教程中走了这么远，下面这个细化网格的函数应该不会再对你构成任何挑战。它对网格进行细化，可以是全局的，也可以是使用Kelly误差估计器的，如果这样要求的话，还可以将上一个网格的解转移到下一个网格。在后一种情况下，我们还需要再次计算活动集和其他数量，为此我们需要由[2.x.222]计算的信息。
* 

* 
* [1.x.167]
* 
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
* 

* 
* [1.x.168]
* 
* [1.x.169] [1.x.170].
 

* 
* 在我们到达[2.x.223]之前的其余三个函数都与生成输出有关。下面一个是尝试显示变形体的变形构造。为此，这个函数接收一个位移矢量场，通过先前计算的位移来移动网格（局部）的每个顶点。在生成图形输出之前，我们将以当前的位移场调用这个函数，在生成图形输出之后，我们将以负的位移场再次调用这个函数，以撤销对网格所做的改变。  
* 这个函数本身是非常简单明了的。我们所要做的就是跟踪我们已经接触过的顶点，因为我们在单元格上循环时多次遇到相同的顶点。
* 

* 
* [1.x.171]
* 
* [1.x.172] [1.x.173]
 

* 
* 接下来是我们用来实际生成图形输出的函数。这个函数有点繁琐，但实际上并不特别复杂。它在顶部移动网格（最后再把它移回来），然后计算沿接触面的接触力。我们可以通过取未处理的残差向量，并通过询问它们是否有与之相关的不均匀约束来确定哪些自由度对应于有接触的自由度（如随文所示）。像往常一样，我们需要注意的是，我们只能写进完全分布的向量（即没有鬼魂元素的向量），但当我们想产生输出时，我们需要的向量确实有所有局部相关自由度的鬼魂条目。
* 

* 
* [1.x.174]
* 
* 接触力的计算
* 

* 
* [1.x.175]
* 
* 在函数的其余部分，我们在每个处理器上生成一个VTU文件，以这个处理器的子域ID为索引。在第一个处理器上，我们还创建了一个[2.x.224]文件，对VTU文件的[1.x.176]进行索引，这样就可以一次性读取整个输出文件集。这些[2.x.225]被Paraview用来描述整个并行计算的输出文件。然后我们再为Paraview的竞争者--VisIt可视化程序做同样的事情，创建一个匹配的[2.x.226]文件。
* 

* 
* [1.x.177]
* 
* [1.x.178] [1.x.179]。
 

* 
* 这最后一个辅助函数通过计算接触面积上Z方向的接触压力的积分来计算接触力。为此，我们将所有不活动的Dofs的接触压力lambda设置为0（一个自由度是否是接触的一部分，就像我们在前一个函数中做的那样）。对于所有活动的自由度，lambda包含非线性残差（newton_rhs_uncondensed）和质量矩阵（diag_mass_matrix_vector）的相应对角线条目的商数。因为悬空节点出现在接触区的可能性不小，所以对分布式_lambda向量应用constraints_hanging_nodes.distribution很重要。
* 

* 
* [1.x.180]
 
* [1.x.181] [1.x.182].
* 

* 
* 和其他所有的教程程序一样，[2.x.227]函数包含整体逻辑。这里没有太多的内容：本质上，它在所有的网格细化循环中执行循环，在每个循环中，把事情交给[2.x.228]中的牛顿求解器在当前的网格上，并调用函数为如此计算的解决方案创建图形输出。然后输出一些关于运行时间和内存消耗的统计数据，这些数据是在这个网格的计算过程中收集的。
* 

* 
* [1.x.183]
* 
* [1.x.184] [1.x.185] * [1.x.184] [1.x.185].
* 

* 
* [2.x.229]的功能真的不多。看起来他们总是这样做。
* 

* 
* [1.x.186]
* [1.x.187][1.x.188] 。
* 

* 包含该程序的目录还包含一些输入参数文件，可用于创建各种不同的模拟。例如，用[2.x.230]参数文件（用球作为障碍物，用盒子作为领域）在16个核心上运行该程序，会产生这样的输出。
* [1.x.189]
 
* 每个周期末尾的表格显示了最近一次网格细化周期的计算时间（这些数字当然是针对产生该输出的机器的）和程序不同部分的调用次数，如装配或计算残差。上面的一些数字可以通过将解决方案从一个网格转移到另一个网格而得到改善，我们在这里没有使用这种方法。当然，你也可以通过使用更多的处理器来使程序运行得更快，特别是在后期的细化周期中：附带的论文显示了至少1000个内核的良好扩展性。
* 在一个典型的运行中，你可以观察到，在每一个细化步骤中，活动集
* 
* - 接触点
* 
* --首先被迭代出来。之后，牛顿方法只需要解决塑性问题。对于更细的网格，在最后4或5次牛顿迭代中可以观察到二次收敛。
* 我们不会在这里详细讨论每个输入文件的情况。相反，让我们只展示解决方案的图片（如果单元格的正交点为零，则省略域的左半部分，因为该单元格的塑性质量是有效的）。
* [2.x.231] 
* 图片显示了自适应细化，以及一个单元在与球接触过程中的塑化程度。请记住，我们考虑的是每个正交点的应力偏差部分的形式，看是否有弹性或塑性行为。蓝颜色意味着该单元只包含弹性正交点，与红色单元相比，所有正交点都是塑性的。
* 
* - 这里的网格是最细的
* 
* - 仔细观察可以看到由障碍物造成的凹陷。这就是[2.x.232]函数的结果。然而，由于我们在这里考虑的障碍物的压痕非常小，所以很难辨别这种效果；我们可以用计算出的位移的倍数来替换网格的顶点。
* 关于使用这个程序可以得到的结果的进一步讨论，见本页面顶部提到的出版物。
* 

* [1.x.190][1.x.191][1.x.192] 。
* 

* 像往常一样，有多种可能性来扩展这个程序。从算法的角度来看，这个程序在编写时已经尽可能地使用了接触质量、塑性非线性和线性求解器的最佳可用算法。然而，就更多的现实情况而言，人们还想用这个程序做一些事情。[2.x.233] [2.x.234] 将程序从静态扩展到准静态，也许可以通过选择后向欧拉模式进行时间离散化。一些理论结果可以在Jörg Frohne的博士论文中找到，[1.x.193]，德国锡根大学，2011。
* [2.x.235] 考虑有摩擦的接触问题也是一个有趣的进展。在几乎每个机械过程中，摩擦都有很大的影响。 为了模拟这种情况，我们必须考虑到接触面的切向应力。摩擦也给我们的问题增加了另一个不等式，因为只要切向应力不超过某个极限，物体和障碍物通常会粘在一起，超过这个极限，两个物体就会互相滑动。
* 如果我们已经模拟了摩擦性接触，下一步要考虑的是接触区的发热。由两个物体之间的摩擦引起的热量会提高可变形物体的温度，并引起一些材料参数的变化。
* [2.x.237] 对于接触和塑性，实施更精确的、与问题相适应的误差估计器可能是有意义的。[2.x.238] 
* 

* [1.x.194][1.x.195][2.x.239] 。
* [0.x.1]

