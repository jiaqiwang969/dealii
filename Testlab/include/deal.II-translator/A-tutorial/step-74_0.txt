include/deal.II-translator/A-tutorial/step-74_0.txt
[0.x.0]*
 [2.x.0] 
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
* [2.x.2] 
* [1.x.23]
* 

* [1.x.24][1.x.25][1.x.26] 。
* 

* [1.x.27][1.x.28]。
* 在本教程中，我们展示了FEInterfaceValues类的用法，该类是为集合非连续加尔金（DG）方法产生的面项而设计的。FEInterfaceValues类提供了一种简单的方法来获得形状函数和跨单元面解的跳跃和平均值。[2.x.3] [2.x.4] 泊松方程的SIPG方法，在[2.x.5]和[2.x.6]中已经使用过。  [2.x.7] 使用FEInterfaceValues组装面项，使用[2.x.8]组装系统矩阵，这与[2.x.9]类似。  [2.x.10] 使用误差估计器进行自适应网格细化。  [2.x.11] 两个测试案例：平滑函数的收敛测试和奇异解的适应性网格细化测试。[2.x.12] 
*[1.x.29][1.x.30]
* 在这个例子中，我们考虑泊松方程[1.x.31]受边界条件[1.x.32]的影响。为了简单起见，我们假设扩散系数[2.x.13]是常数。注意，如果[2.x.14]是不连续的，我们在计算单元面上的跳跃项时需要考虑到这一点。
* 我们用[2.x.15]表示网格，[2.x.16]是一个网格单元。内部和边界面的集合分别用[2.x.17]和[2.x.18]表示。让[2.x.19]和[2.x.20]是共享一个面[2.x.21]的两个单元，[2.x.22]是[2.x.23]的外法向量。那么跳跃运算符由 "这里减去那里 "公式给出，[1.x.33]和平均运算符分别为[1.x.34]。请注意，当[2.x.24]时，我们定义[2.x.25]和[2.x.26]。使用SIPG的离散化由以下弱式给出（更多细节可以在[2.x.27]和其中的参考资料中找到）。
* [1.x.35]
* 
* 

* [1.x.36][1.x.37]。
* 惩罚参数定义为 [2.x.28] ，其中 [2.x.29] 是与细胞面相关的局部长度尺度；这里我们选择细胞在面的法线方向的长度近似值。[2.x.30] ，其中[2.x.31]是与面相邻的两个单元[2.x.32]，我们计算出[2.x.33]。
* 在上述公式中，[2.x.34]是惩罚常数。为了确保离散矫捷性，惩罚常数必须足够大[2.x.35]。人们对于应该使用文献中提出的哪个公式并没有真正的共识。(这与[2.x.36]的 "结果 "部分所讨论的情况相似。)人们可以直接选择一个大的常数，而其他选择可以是[2.x.37]或[2.x.38]的倍数。在本代码中，我们遵循 [2.x.39] 并使用 [2.x.40] 。
* 

* [1.x.38][1.x.39] 。
* 在这个例子中，稍作修改，我们使用Karakashian和Pascal的误差估计器 [2.x.41] [1.x.40]，其中
* [1.x.41]
* 这里我们用[2.x.42]代替[2.x.43]来表示[2.x.44]的跳跃项（[2.x.45]和[2.x.46]的第一个项）。
*为了计算这个估计值，在每个单元格[2.x.47]中我们计算
* [1.x.42]
* 然后每个单元的误差估计的平方是[1.x.43]，[2.x.48]的系数是由于整体误差估计器只包括每个内部面一次，所以每个单元的估计器对相邻的两个单元都以一半的系数来计算。 注意我们计算[2.x.49]而不是[2.x.50]以简化实现。然后每个单元的误差估计方被存储在一个全局向量中，其[2.x.51]准则等于[2.x.52] 。
*[1.x.44][1.x.45] 。
* 在第一个测试问题中，我们使用二维的[2.x.53]的平滑制造解进行收敛测试
* [1.x.46]
* 和 [2.x.54] 。我们针对制造的解决方案计算误差并评估收敛率。
* 在第二个测试中，我们在二维的L形域[2.x.56]上选择了[2.x.55]。该解在极坐标中由[2.x.57]给出，它在原点有一个奇点。我们构建了一个误差估计器来检测有大误差的区域，根据这个估计器来自适应地细化网格。
* 

* [1.x.47] [1.x.48].
* 前面几个文件已经在前面的例子中介绍过了，因此不再进一步评论。
* 

* 
* [1.x.49]
* 
* 这里定义了不连续的有限元和FEInterfaceValues。
 

* 
* [1.x.50]
* 
* [1.x.51] [1.x.52] 这里我们定义了两个测试案例：平滑函数的收敛率和[2.x.58] 的l_singularity。
* 

* 
* [1.x.53]
 
* 收敛性测试的平滑解。
* 

* 
* [1.x.54]
* 
* 相应的平滑函数的右手边。
* 

* 
* [1.x.55]
* 
* 对应于函数[2.x.59]的右手边，我们假设扩散系数[2.x.60] 。
* 

* 
* [1.x.56]
* 
* [1.x.57] [1.x.58] 以下两个辅助函数分别用于计算[2.x.61]和[2.x.62]在一个面上的跳跃项。
* 

* 
* [1.x.59]
* 
* 这个函数计算了[2.x.63]的惩罚。
* 

* 
* [1.x.60]
* 
* [1.x.61] [1.x.62] 在下文中，我们为[2.x.64]定义了 "复制 "对象，它基本上与[2.x.65]相同。注意，这里没有定义 "Scratch "对象，因为我们用[2.x.66]代替。("复制 "和 "抓取 "对象的使用在WorkStream命名空间文档中有广泛的解释。
* 

* 
* [1.x.63]
* 
* [1.x.64] [1.x.65] 在这些准备工作之后，我们进行本程序的主类，称为`SIPGLaplace`。该类的整体结构与其他许多教程程序一样。主要的区别只出现在集合函数的实现上，因为我们使用FEInterfaceValues来集合面的条件。
* 

* 
* [1.x.66]
* 
* 该类的其余成员用于以下方面。
 

* 
* 
* - 用于存储每个单元的误差估计方和能量规范方的矢量。
* 

* 
* 
* - 在屏幕上打印收敛率和误差。
* 

* 
* 
* - 扩散系数[2.x.67]被设置为1。
* 

* 
* 
* - 存储要计算的测试案例的信息的成员。
* 

* 
* [1.x.67]
* 
* 这里的构造函数将测试案例作为输入，然后确定正确的解决方案和右手边的类。其余的成员变量以明显的方式进行初始化。
* 

* 
* [1.x.68]
* 
* [1.x.69] [1.x.70] 这里的装配函数与[2.x.68]和[2.x.69]中的相似。与手工装配不同的是，我们只需要专注于在每个单元格、每个边界面和每个内部面进行装配。单元和面的循环是由[2.x.70]自动处理的。   
* 该函数首先定义了一个局部（lambda）函数，用于整合单元项。
* 

* 
* [1.x.71]
* 
* 接下来，我们需要一个在边界上集合面积分的函数。
* 

* 
* [1.x.72]
 
* 最后，一个在内部面组装面积分的函数。为了重新初始化FEInterfaceValues，我们需要向FEInterfaceValues的reinit()函数传递单元格、面和子面指数（用于自适应细化）。
* 

* 
* [1.x.73]
* 
* 下面的lambda函数将把数据复制到全局矩阵和右手边。 虽然DG离散化中没有悬空节点约束，但我们定义了一个空的AffineConstraints对象，允许我们使用[2.x.71]功能。
* 

* 
* [1.x.74]
* 
* 从内部面组件复制数据到全局矩阵。
* 

* 
* [1.x.75]
* 
* 随着装配函数的定义，我们现在可以创建ScratchData和CopyData对象，并将它们与上面的lambda函数一起传递给 [2.x.72] 此外，我们需要指定我们要在内部面组装一次。
* 

* 
* [1.x.76]
* 
* [1.x.77] [1.x.78] 以下两个函数完全是标准的，没有难度。
* 

* 
* [1.x.79]
* 
* [1.x.80] [1.x.81] 这里的误差估计器的装配与全局矩阵和右前侧的装配很相似，可以由[2.x.73]框架处理。为了理解每个局部（lambda）函数的作用，首先回顾一下，局部单元残差的定义为 [2.x.74] 。
* 

* 
* [1.x.82]
* 
* 接下来计算边界项 [2.x.75] 。
* 

* 
* [1.x.83]
* 
* 最后是内部面条款 [2.x.76] 。
* 

* 
* [1.x.84]
* 
* 在计算了每个单元的局部贡献后，我们仍然需要一种方法将这些复制到全局向量中，该向量将容纳所有单元的误差估计。
* 

* 
* [1.x.85]
* 
* 在所有这些设置之后，让我们来做实际的工作。我们调整向量的大小，将结果写入其中，然后用[2.x.77]函数驱动整个过程。
* 

* 
* [1.x.86]
* 
* [1.x.87] [1.x.88] 接下来，我们用能量准则来评估准确性。这个功能类似于上面的误差估计器的集合。这里我们计算由[1.x.89]定义的能量准则的平方 因此，相应的误差是[1.x.90]
* 

* 
* [1.x.91]
* 
* 组装 [2.x.78] 。
* 

 
* [1.x.92]
* 
* 组装 [2.x.79] .
 

* 
* [1.x.93]
* 
* 组装 [2.x.80] .
* 

 
* [1.x.94]
 
* [1.x.95][1.x.96] 。
 

 
* [1.x.97]
* 
* [1.x.98] [1.x.99] 我们分别计算[2.x.81]准则、[2.x.82]半准则和能量准则的三个误差。这些误差将被打印到屏幕上，同时也被存储在一个表格中，该表格记录了这些误差是如何随着网格细化而衰减的，并且可以在程序的最后一步输出。
* 

* 
* [1.x.100]
* 
* [1.x.101] [1.x.102].
 

 
* [1.x.103]
* 
* 在运行了我们所有的计算之后，让我们告诉收敛表如何格式化它的数据并将其输出到屏幕。
* 

* 
* [1.x.104]
* 
* [1.x.105] [1.x.106] 下面的[2.x.83]函数与前面的例子也类似，不需要注释。
* 

* 
* [1.x.107]
* [1.x.108][1.x.109]。
* 

* 这个程序的输出包括控制台输出和vtu格式的解决方案。
* 在第一个测试案例中，当你运行该程序时，屏幕输出应该是以下样子。
* [1.x.110]
* 
* 当使用多项式度数为3的光滑情况时，收敛表将看起来像这样。[2.x.84] 
* 理论上，对于多项式度数[2.x.85]，在[2.x.86]规范和[2.x.87]半规范中的收敛顺序应该是[2.x.88]和[2.x.89]，分别。我们的数值结果与理论有很好的一致性。
* 在第二个测试案例中，当你运行程序时，屏幕输出应该是以下样子。
* [1.x.111]
* 
* 下图提供了一个L型域上这个测试案例的误差与自由度数的对数图。为了解释它，让[2.x.90]为自由度数，那么在均匀细化的网格上，[2.x.91]是二维的[2.x.92]阶。结合前面的理论结果，我们可以看到，如果解足够光滑，我们可以预期[2.x.93]准则的误差为[2.x.94]阶，[2.x.95]半准则的误差为[2.x.96]。在自适应细化的网格上，如我们在第二个测试案例中使用的网格，会不会得到与[2.x.97]的函数相同的行为，这并不是一个先决条件，但人们当然可以希望。事实上，从图中我们可以看出，带有自适应网格细化的SIPG产生了渐进式的那种希望的结果。
* [2.x.98] 
* 此外，我们观察到误差估计值的下降速度几乎与能量准则和[2.x.99]半准则的误差相同，并且比[2.x.100]的误差低一阶。这表明它有能力预测具有较大误差的区域。
* 虽然本教程侧重于实现，但[2.x.101]教程程序以无矩阵求解技术在计算时间上实现了一个高效的大规模求解器。注意，[2.x.102]教程目前不能与含有悬空节点的网格一起工作，因为多网格界面矩阵不那么容易确定，但这只是deal.II中缺少一些界面，没有什么根本原因。
* 

* [1.x.112][1.x.113] [2.x.103]. 
* [0.x.1]

