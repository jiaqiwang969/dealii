include/deal.II-translator/fe/fe_update_flags_0.txt
[0.x.0]*
 给予FEValues、FEFaceValues和FESubfaceValues的构造函数的枚举类型，告诉这些对象在每个网格单元上需要哪些数据。
* 以限制性的方式选择这些标志对于[2.x.0][2.x.1]和[2.x.2]的效率至关重要。因此，应该只选择实际需要的标志。相关的Mapping和FiniteElement有责任根据自己的要求添加额外的标志。例如，如果选择了#update_gradients，大多数有限元会添加#update_covariant_transformation。 默认情况下，所有标志都是关闭的，也就是说，不会进行重新初始化。
* 你可以用位数或运算符|(UpdateFlags,UpdateFlags)通过串联的方式选择多个标志。
* [1.x.0]
* 更多关于该类型在用户代码以及内部使用的信息可以在[2.x.3] "FEValues中UpdateFlags、Mapping和FiniteElement的相互作用 "和[2.x.4] "Mapping、FiniteElement和FEValues如何协同工作 "的文档模块中找到。

* 
* [0.x.1]*
   计算实空间单元上正交点的形状函数值。对于通常的拉格朗日元素，这些值等于单元格上正交点的形状函数值，但对于更复杂的元素，如FE_RaviartThomas元素，它们是不同的。 
* [0.x.2]*
   计算实单元坐标中形状函数的梯度。 
* [0.x.3]*
   计算实心单元坐标下的形状函数的二阶导数。 
* [0.x.4]*
   计算实心单元坐标中的形状函数的第三导数  
* [0.x.5]*
   切向矢量的矢量乘积，产生一个法向矢量，其长度对应于表面元素；可能比计算两者更有效。 
* [0.x.6]*
   计算实际单元坐标中的正交点位置。    FEValues对象将参考单元上的正交点位置作为构造函数的一个参数（通过Quadrature对象）。对于大多数有限元来说，知道参考单元上正交点的位置是评估形状函数、评估映射和其他事情所必需的。另一方面，如果你想在真实单元上的正交点位置[2.x.6]评估一个右手函数[2.x.5]，你需要将这个标志传递给FEValues构造函数，以确保你以后可以访问它们。    在DataPostprocessor的背景下，[2.x.7]将被更新。 
* [0.x.7]*
   计算实数单元上的正交权重，即正交规则的权重乘以从参考单元到实数单元的转换的雅各布定理。 
* [0.x.8]*
   计算法向量，可以是一个面，也可以是一个一维的单元。对任何其他对象设置这个标志都会引起一个错误。 
* [0.x.9]*
   计算从参考单元到实际单元的转换的雅各布系数。 
* [0.x.10]*
   计算变换的Jacobian的导数。 
* [0.x.11]*
   计算从参考单元到实数单元的变换的逆雅各布系数。 
* [0.x.12]*
   计算Mapping对向量进行反演变换所需的所有数值。对于像MappingCartesian这样的特殊映射，这可能比#update_inverse_jacobians更简单。 
* [0.x.13]*
   计算Mapping需要的所有值，以便对向量进行逆向变换。对于像MappingCartesian这样的特殊映射，这可能比#update_jacobians更简单。 
* [0.x.14]*
   计算由Mapping定义的变换的形状函数值。 
* [0.x.15]*
   计算由Mapping定义的变换的形状函数梯度。 
* [0.x.16]*
   计算每个正交点的体积元素。 
* [0.x.17]*
   计算向前推到实际单元坐标的变换的雅各布系数的导数。 
* [0.x.18]*
   计算变换的Jacobian的二次导数。 
* [0.x.19]*
   计算向前推至真实单元坐标的变换的雅各布系数的二阶导数。 
* [0.x.20]*
   计算变换的雅各布系数的第三导数。 
* [0.x.21]*
   计算向前推至实数单元坐标的变换的雅各布系数的第三导数。 
* [0.x.22]*
   结合Hdiv元素的Piola变换所需的标志。 
* [0.x.23]*
   需要进行映射计算的标志的组合  
* [0.x.24]*
 输出操作符，它将更新标志作为一组or'd文本值输出。
* [2.x.8] 

* 
* [0.x.25]*
 全局操作符，它返回一个对象，其中所有的位都被设置为第一或第二个参数中的设置。这个操作符的存在是因为如果它不存在，那么bit-or <tt>操作符|</tt>的结果将是一个整数，当我们试图将其分配给UpdateFlags类型的对象时，又会引发编译器警告。
* [2.x.9] 

* 
* [0.x.26]*
 全局操作符，它将第二个参数的位也设置在第一个参数中。
* [2.x.10] 

* 
* [0.x.27]*
 全局操作符，它返回一个对象，其中所有位都被设置在第一个和第二个参数中。这个操作符的存在是因为如果它不存在，那么位和<tt>操作符&</tt>的结果将是一个整数，当我们试图将其分配给UpdateFlags类型的对象时，会引发编译器警告。
* [2.x.11] 

* 
* [0.x.28]*
 全局操作符，如果第一个参数中的所有位没有在第二个参数中设置，则将其清除。
* [2.x.12] 

* 
* [0.x.29]*
 这个枚举定义用于存储当前单元与先前访问的单元的相似性。这些信息用于在调用方法[2.x.13]时重复使用数据（比如导数，如果一个单元格只是前一个单元格的翻译，则导数不会改变）。目前，这个变量只能识别一个平移和一个倒置的平移（如果dim<spacedim）。然而，这个概念使得在FEValues/FEFaceValues中添加额外的状态来检测这些相似性也变得容易。

* 
* [0.x.30]*
     除了平移或倒置的平移之外，单元格还存在一些差异。   
* [0.x.31]*
     这些单元格因翻译而不同。   
* [0.x.32]*
     这些单元格因倒置的平移而不同。   
* [0.x.33]*
     下一个单元格是无效的。   
* [0.x.34]*
     一个存储所有用于[2.x.14][2.x.15]和[2.x.16]对象中的映射相关数据的类。当[2.x.17]调用[2.x.18]时，这种对象将作为[1.x.1]的参数提供给某个单元、面或子面。        然后这里的数据将作为[1.x.2]参数在下面调用[2.x.19]时提供。        
* [2.x.20]     
* [0.x.35]*
       将所有向量初始化为正确的大小。     
* [0.x.36]*
       计算并返回这个对象的内存消耗（以字节为单位）的估计值。     
* [0.x.37]*
       在正交点存储一个权重乘以雅可比行列式的数组。每次调用reinit()时，这个函数都会被重置。雅可比行列式实际上是存储在这个类中的雅可比矩阵的倒数值，更多信息见这个类的一般文档。            然而，如果这个对象指的是FEFaceValues或FESubfaceValues对象，那么JxW_values对应的是面的变换的雅可比，而不是单元，也就是说，维度是面的量度，而不是体积的量度。在这种情况下，它是由边界形式，而不是由雅各布矩阵计算出来的。     
* [0.x.38]*
       正交点的雅各布矩阵的阵列。     
* [0.x.39]*
       雅各布矩阵在正交点的导数数组。     
* [0.x.40]*
       正交点上的反雅各布矩阵阵列。     
* [0.x.41]*
       正交点的雅各布矩阵的导数数组，向前推至实际单元坐标。     
* [0.x.42]*
       正交点的雅各布矩阵的二阶导数数组。     
* [0.x.43]*
       在正交点的雅各布矩阵的二阶导数数组，向前推至真实单元坐标。     
* [0.x.44]*
       正交点上的雅各布矩阵的第三导数数组。     
* [0.x.45]*
       在正交点的雅各布矩阵的三次导数数组，向前推至真实单元坐标。     
* [0.x.46]*
       正交点的数组。这个数组是在调用reinit()时设置的，包含实数元素上的正交点，而不是参考元素上的。     
* [0.x.47]*
       正交点的外向法向量列表。     
* [0.x.48]*
       正交点上的边界形式列表。     
* [0.x.49]*
     一个存储所有用于[2.x.21][2.x.22]和[2.x.23]对象中的形状函数相关数据的类。当[2.x.24]调用[2.x.25]时，这种对象将作为[1.x.3]参数给出。        
* [2.x.26]     
* [0.x.50]*
       将所有向量初始化为正确的大小。     
* [0.x.51]*
       计算并返回这个对象的内存消耗（以字节为单位）的估计值。     
* [0.x.52]*
       形状值的存储类型。矩阵中的每一行表示不同点上的单个形状函数的值，列是针对单个点的不同形状函数。            如果一个形状函数有一个以上的非零分量（在deal.II的字典中：它是非正数），那么我们为每个非零分量分配一行，并将随后的行向后移。 因此，如果整个有限元是原始的（即所有形状函数都是原始的），为一个形状函数查询正确的行是很简单的，因为那时形状函数的编号等于行的编号。否则，使用#shape_function_to_row_table数组来获得属于这个特定形状函数的第一行，并使用[2.x.27]函数在这个形状函数的所有行中导航，该函数告诉我们哪些组件是非零的，因此在目前讨论的数组中有一行。     
* [0.x.53]*
       梯度的存储类型。数据的布局与#ShapeVector数据类型相同。     
* [0.x.54]*
       同样，对于二阶导数也是如此。     
* [0.x.55]*
       而同样的情况也适用于三阶导数。     
* [0.x.56]*
       存储正交点的形状函数的值。关于这个字段中的数据布局，请参见数据类型的描述。     
* [0.x.57]*
       存储形状函数在正交点的梯度。      参见数据类型的描述，了解该字段的数据布局。     
* [0.x.58]*
       存储形状函数在正交点的二阶导数。 参见数据类型的描述，了解该字段的数据布局。     
* [0.x.59]*
       存储正交点上的形状函数的3次导数。 参见数据类型的描述，了解该字段的数据布局。     
* [0.x.60]*
       当被问及形状函数i的第c个向量分量的值（或梯度，或Hessian）时，我们需要在#shape_values、#shape_gradients和#shape_hessians数组中查找它。 问题是，在这个数组中，形状函数i的c分量的数据在哪里？这就是这个表的答案。            该表的格式如下。
* 
* - 它有dofs_per_cell乘以n_components条目。
* 
* - 对应于形状函数i，组件c的条目是[2.x.28] 。
* 
* - 存储在这个位置的值表示#shape_values和其他表格中所有正交点的对应基准点的行。            在一般情况下，矢量值的情况下，分量的数量大于1，但是对于一个给定的形状函数，并非所有的矢量分量都是非零的（例如，如果一个形状函数是原始的，那么正好有一个矢量分量是非零的，而其他的都是零）。对于这种零分量，#shape_values和friends没有一行。因此，对于形状函数i为零的向量分量，在当前表中的条目是[2.x.29] 另一方面，该表保证每个形状函数至少有一个有效的索引。特别是，对于原始有限元，每个形状函数正好有一个非零分量，因此对于每个i，在[2.x.30]范围内正好有一个有效索引。     
* [0.x.61]

