include/deal.II-translator/fe/fe_poly_tensor_0.txt
[0.x.0]*
 这个类提供了一个统一的框架，用于实现基于张量值的多项式空间的FiniteElement类，如PolynomialsBDM和PolynomialsRaviartThomas。在这一点上，它是张量值的FE_Poly类的等同物。
* 本质上，这个类所要求的是，派生类向它描述一个（矢量值）多项式空间，其中每个多项式都正好有[2.x.0]个矢量分量。提供这种实现的类都是从TensorPolynomialsBase类派生出来的，这些派生类型中的一个对象需要提供给这个类的构造函数。
* 

* [1.x.0]
* 这个类不是一个完全实现的FiniteElement类，但是实现了一些基于向量估值的多项式类的向量估值元素的共同特征。这里特别缺少的是关于节点值的拓扑位置的信息（即一个自由度在逻辑上是在顶点、边缘、面，还是在单元的内部
* 
* --这些信息决定了跨单元界面的相关形状函数的连续性属性），而派生类需要提供这些信息。
* 同样地，在许多情况下，节点函数取决于网格单元的形状，因为它们评估面的法向或切向分量。为了允许一系列的转换，引入了#mapping_kind这个变量。它需要在派生类的构造函数中设置。
* 任何派生类都必须决定要使用的多项式空间。 这个多项式空间应该简单地实现为一组矢量值的多项式，如PolynomialsBDM和PolynomialsRaviartThomas。 为了便于实现，多项式空间选择哪种基础对当前的类并不重要。
* 
* - 正如接下来所描述的，这个类处理了从多项式空间模板参数所选择的基础到我们内部要用于有限元计算的基础的转换。
* 

* [1.x.1]
* 在大多数情况下，描述多项式空间的类所使用的基，[2.x.1] ，并不符合我们想用于有限元描述的基，[2.x.2] 。相反，我们需要将有限元形状函数表达为多项式空间所提供的基础的线性组合。

* 
* [1.x.2]
* 这些展开系数[2.x.3]通常在派生类的构造函数中计算。为了方便，这个类一开始（除非另有告知，见下文），假定形状函数应该正是多项式空间所提供的。在派生类的构造函数中，我们通常会有如下形式的代码

* 
* [1.x.3]
* [2.x.4]函数更详细地解释了它到底计算什么，以及如何计算；无论如何，结果是[2.x.5]现在包含了扩展系数[2.x.6]，而且这块代码现在将矩阵设置为非零大小的事实向当前类的函数表明，当要求形状函数的值或导数时，它应该从那时起使用扩展的基础，[2.x.7]，而不再是原始，"原始 "基础 [2.x.8] 。
* 为了使这个方案奏效，必须确保在调用[2.x.10]时，[2.x.9]的大小为零；因此，对这个函数的调用不能被内联到最后一行
* 
* - 调用的结果确实需要存储在临时对象[2.x.11]中。
* 

* [1.x.4]
* 在大多数情况下，矢量值的基函数从参考单元映射到实际网格单元时必须进行转换。这些转换可以从MappingKind集合中选择，并存储在#mapping_kind中。因此，每个构造函数都应该包含这样一行。

* 
* [1.x.5]
*（在不需要映射的情况下）或使用MappingKind中定义的任何值，以适合你正在实现的元素。如果每个形状函数可以通过不同的映射来实现，那么[2.x.12]可以是一个元素数量与形状函数数量相同的向量。
* [2.x.13] TensorPolynomialsBase

 
* [2.x.14] 

* 
* [0.x.1]*
   构造函数。这个构造函数通过[2.x.15]函数对多项式对象进行深度拷贝，并存储一个指向该拷贝的指针。因此，调用网站可以简单地传递一个临时对象作为第一个参数。 
* [0.x.2]*
   拷贝构造函数。 
* [0.x.3]*
   计算形状函数[2.x.16]在给定正交点[2.x.17]的（标量）值。 
* [0.x.4]*
   计算（标量）形状函数[2.x.18]在给定正交点的梯度 [2.x.19] 由于该类代表的元素是矢量值，没有这样的标量值，因此该函数抛出了一个异常。 
* [0.x.5]*
   计算（标量）形状函数[2.x.20]在给定正交点的Hessian [2.x.21] 由于该类所代表的元素是矢量值，没有这样的标量值，因此该函数抛出一个异常。 
* [0.x.6]*
   用来将形状函数从参考单元映射到网格单元的映射类型。如果这个向量的长度为1，所有的形状函数都将采用相同的映射。如果向量的大小等于每个单元的有限元度数，那么每个形状函数将根据向量中的相应条目进行映射。 
* [0.x.7]*
   返回一个布尔值，当有限元使用单一映射时为真，当有限元使用多个映射时为假。 
* [0.x.8]*
   对于三维中非标准面的方向，面（四边形）上的道夫必须被置换，以便与正确的形状函数相结合，另外还可以改变符号。给定一个四边形上的局部dof[2.x.22]，如果该面有非标准的面朝向、面朝上或面朝下的旋转，则返回经过处理的形状函数的符号。在二维和一维中，没有必要进行包络，因此在这种情况下它没有任何作用。    permutation本身由界面类FiniteElement<dim>中实现的adjust_quad_dof_index_for_face_orientation返回。 
* [0.x.9]*
   对于三维中具有非标准面朝向的面，面（四边形）上的道夫不仅需要被移位，以便与正确的形状函数相结合。此外，他们可能会改变他们的符号。    这个类的构造函数用 "假 "值填充这个表，即根本没有符号变化。派生的有限元类必须用正确的值填充这个表，参见GeometryInfo<dim>中的文档和这个[2.x.23]"关于面朝向的词汇表条目"。    该表必须以有意义的方式填写在从FE_PolyTensor派生的有限元类中，因为包络模式和符号变化模式取决于有限元如何在面的局部道夫分布。一个例子是FE_RaviartThomas类中的函数`initialize_quad_dof_index_permutation_and_sign_change()`，它填补了这个表格。 
* [0.x.10]*
   返回有限元的MappingKind [2.x.24] 。 
* [0.x.11]注意：以下函数的定义被内联到类的声明中，因为我们在MS Visual Studio中否则会遇到编译器错误。
* [0.x.12]*
   FE_PolyTensor的独立于细胞的数据字段。在参考单元格上存储形状函数的值和它们的导数，以便以后使用。    所有表格的组织方式是，正交点[1.x.7]的形状函数[1.x.6]的值可以通过索引[1.x.8]来访问。 
* [0.x.13]*
     包含正交点的形状函数值的数组。每个形状函数都有一行，包含每个正交点的值。   
* [0.x.14]*
     以正交点为单位的形状函数梯度数组。每个形状函数有一行，包含每个正交点的值。   
* [0.x.15]*
     以正交点为单位的形状函数豫备数组。每个形状函数有一行，包含每个正交点的值。   
* [0.x.16]*
     用于中间计算的抓取数组    
* [0.x.17]*
   传递给构造函数的对象的副本，描述多项式空间。 
* [0.x.18]*
   应用于多项式[1.x.11]的节点值[1.x.10]的矩阵[1.x.9]的倒数。这个矩阵用于将#poly_space中提供的 "原始 "基础中的多项式转换为参考单元上的节点函数的对偶基础。    这个对象不是由FE_PolyTensor填充的，而是一个派生类允许重组基函数的机会。如果它留空，则使用#poly_space中的基础。 
* [0.x.19]*
   一个mutex，用来保护对下面的变量的访问。 
* [0.x.20]*
   如果一个形状函数是在一个点上计算的，我们必须计算所有的形状函数来应用#inverse_node_matrix。为了避免过多的开销，我们对点和函数值进行缓存，以便下次评估。 
* [0.x.21]*
   调用shape_value_component()后缓存的形状函数值。 
* [0.x.22]*
   调用shape_grad_component()后缓存的形状函数梯度。 
* [0.x.23]*
   在调用shape_grad_grad_component()后缓存形状函数的二阶导数。 
* [0.x.24]

