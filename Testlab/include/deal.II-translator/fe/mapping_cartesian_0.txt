include/deal.II-translator/fe/mapping_cartesian_0.txt
[0.x.0]*
 一个提供从参考单元到单元的映射的类，这些单元是轴平行的，即具有矩形（在2d中）或盒子（在3d中）的形状，边缘平行于坐标方向。因此，该类提供的功能等同于例如MappingQ为这类单元格提供的功能。然而，对单元格形状的了解使得这个类的效率大大提升。
* 具体来说，该映射是针对那些从参考坐标到实际单元的映射是沿坐标方向的缩放的单元。每个单元上从参考坐标[2.x.0]到实数坐标[2.x.1]的变换形式为

* 
* [1.x.0]
*在2d中，和

 
* [1.x.1]
* 在3D中，[2.x.2]是左下角的顶点，[2.x.3]是单元格沿轴线的延伸。
* 这个类是为了提高效率，它没有做大量的错误检查。如果你将这种映射应用于不符合上述要求的单元格，你会得到奇怪的结果。

* 
* [0.x.1]*
   返回[2.x.4]因为MappingCartesian保留了顶点位置。 
* [0.x.2]*
    [2.x.5] 参考单元和实数单元之间的映射点[2.x.6] 。  
* [0.x.3]*
    [2.x.7]   
* [0.x.4]*
    [2.x.8] 将张量从参考坐标转换为实坐标的函数 [2.x.9]   
* [0.x.5]*
    [2.x.10]   
* [0.x.6]*
    [2.x.11] 与FEValues的接口 [2.x.12].   
* [0.x.7]*
   存储映射的内部数据。见[2.x.13]的广泛描述。    这包括创建对象时计算一次的数据（在get_data()中），以及该类希望从调用fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()之间存储的数据，直到以后可能从有限元调用转化()等函数。后一类的成员变量被标记为 "可变"。 
* [0.x.8]*
     构造函数。   
* [0.x.9]*
     返回这个对象的内存消耗估计值（以字节为单位）。   
* [0.x.10]*
     我们在坐标方向上看到的最后一个单元的延伸，即[1.x.2], [1.x.3], [1.x.4]。   
* [0.x.11]*
     体积元素    
* [0.x.12]*
     所有正交点的矢量。特别是，所有面的所有点。   
* [0.x.13]*
    [2.x.14]   
* [0.x.14]*
   用传入的单元格的尺寸更新传入的InternalData对象的cell_extents字段。 
* [0.x.15]*
   如果传入的InternalData对象的UpdateFlags显示应该更新正交点，则计算这些正交点。    从fill_fe_values调用。 
* [0.x.16]*
   如果传入的InternalData对象的UpdateFlags说它们应该被更新，则计算正交点。    从fill_fe_face_values调用。 
* [0.x.17]*
   计算正交点，如果传入的InternalData对象的UpdateFlags说它们应该被更新。    从fill_fe_subface_values调用。 
* [0.x.18]*
   将InternalData中的正交点转换为实空间，在每个方向上用cell_extends缩放单位坐标。    从各种 maybe_update_*_quadrature_points 函数中调用。 
* [0.x.19]*
   如果传入的InternalData对象的UpdateFlags说它们应该被更新，则计算法向量。 
* [0.x.20]*
   由于这个映射的Jacobian是常数，所以Jacobian的所有导数都是相同的零。如果相应的更新标志说它们应该被更新，那么就把这些量填成零。 
* [0.x.21]

