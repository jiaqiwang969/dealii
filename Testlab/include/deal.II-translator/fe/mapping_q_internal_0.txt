include/deal.II-translator/fe/mapping_q_internal_0.txt
[0.x.0]*
   内部命名空间，用于实现MappingQ1特有的方法，特别是二维中从实数到单元格转换的明确公式。 
* [0.x.1]有两种方法可以从eta计算xi，但任何一种都可能有一个零分母。     
* [0.x.2]*
   内部命名空间，用于实现MappingQGeneric的方法，如映射的评估和实数与单元格之间的转换。 
* [0.x.3]*
     这个函数通过扩展张量积从1d支持点生成参考单元支持点。   
* [0.x.4]*
     这个函数是<tt>MappingQ<dim,spacedim></tt>的构造函数需要的，用于<tt>dim=</tt>2和3。        关于[2.x.0]的定义，请参考TransfiniteInterpolationManifold的描述。   
* [0.x.5]*
     这个函数被<tt>MappingQ<3></tt>的构造函数所需要。        关于[2.x.1]的定义，请参考TransfiniteInterpolationManifold的描述。   
* [0.x.6]*
     这个函数将compute_support_point_weights_on_{quad,hex}的输出收集到一个数据结构中。   
* [0.x.7]*
     收集各个维度的所有内部点。   
* [0.x.8]*
     使用在参考单元上的一个点上评估的形状函数的相对权重（并存储在data.shape_values中，通过data.shape(0,i)访问）和映射支持点的位置（存储在data.mapping_support_points中），计算该点在实际空间中的映射位置。   
* [0.x.9]*
     实现transform_real_to_unit_cell，类型为double或VectorizedArray<double>。   
* [0.x.10]*
     实现dim==spacedim-1的transform_real_to_unit_cell。   
* [0.x.11]*
     一个用于计算从实数到单位点的反映射的二次方近似的类，通过沿映射支持点的最小二乘法拟合。最小二乘法拟合很特别，因为这个近似是为MappingQGeneric的反函数构造的，它通常是一个有理函数。这允许通过简单的多项式插值对反映射进行非常便宜的评估，这可以作为将点从实坐标转化为单位坐标的更好的初始猜测，而不是仿射近似。        在单元格外的远处，这种近似对于非仿生单元格形状来说可能变得不准确。这必须从多项式与有理函数的拟合中预料到，并且由于最小二乘法拟合的区域，即单元格，被离开了。因此，在这些情况下要小心使用这个函数。   
* [0.x.12]*
       二次方近似中的基函数的数量。     
* [0.x.13]*
       构造函数。             [2.x.2] real_support_points 映射支持点在实空间的位置，由 [2.x.3] [2.x.4] unit_support_points 参考坐标 [2.x.5] 中支持点的位置，通过多项式映射到实空间的映射支持点。     
* [0.x.14]*
       复制构造函数。     
* [0.x.15]*
       评估二次函数的近似值。     
* [0.x.16]*
       为了保证良好的调节，我们需要对实空间中的点应用一个变换，这个变换是由一个移位向量normalization_shift（实空间中映射支持点的第一点）和一个称为`length_normalization`的反长度尺度作为前两点之间的距离计算的。     
* [0.x.17]*
       见上面`normalization_shift`的文档。     
* [0.x.18]*
       二次方近似中的系数向量。     
* [0.x.19]*
       如果由于支持点的数量不足而无法进行二次近似，我们就改用仿生近似，这种近似总是有效的，但精度较低。     
* [0.x.20]*
     如果正交公式是张量乘积，这是对 maybe_compute_q_points(), maybe_update_Jacobians() 和 maybe_update_jacobian_grads() 的替代。   
* [0.x.21]*
     计算第一个参数描述的对象上的正交点的位置（以及已经设置了映射支持点的单元），但只有在[2.x.6]参数的update_flags表明的情况下才会如此。   
* [0.x.22]*
     更新共变矩阵和逆变矩阵以及它们的行列式，对于存储在数据对象中描述的单元，但只有当[2.x.7]参数的update_flags表明是这样。        如果可能的话，如第一个参数所示，跳过该计算。   
* [0.x.23]*
     更新从单位到实数单元的转换的Hessian，即雅各布梯度。        如果可能的话，如第一个参数所示，跳过该计算。   
* [0.x.24]*
     更新从单位到实心单元的变换的Hessian，雅各布梯度，向前推到实心单元的坐标。        如果可能的话，如第一个参数所示，跳过该计算。   
* [0.x.25]*
     更新从单位到实心单元的转换的第三个导数，即雅各布式的斜率。        如果可能的话，如第一个参数所示，跳过该计算。   
* [0.x.26]*
     更新从单位到实数单元的变换的Hessian，雅各布Hessian梯度，向前推到实数单元坐标。        如果可能的话，跳过计算，如第一个参数所示。   
* [0.x.27]*
     更新从单位到实心单元转换的第四导数，即雅各布海森梯度。        如第一个参数所示，如果可能的话，跳过该计算。   
* [0.x.28]*
     更新从单位到实际单元的转换的Hessian梯度，即雅各布Hessians，向前推到实际单元坐标。        如果可能的话，如第一个参数所示，跳过计算。   
* [0.x.29]*
     根据[2.x.8]对象的更新标志中所要求的信息，计算fill_fe_face_values()和fill_fe_subface_values()函数所要求的各种信息。这个函数简单地统一了这两个函数所要做的工作。        得到的数据被放入[2.x.9]参数中。   
* [0.x.30]*
     以一种通用的方式完成[2.x.10]和[2.x.11]的工作，使用'data_set'来区分我们是在一个面（如果是的话，是哪一个）还是在子面上工作。   
* [0.x.31]*
     实现[2.x.12]的通用张量。   
* [0.x.32]*
     实现[2.x.13]的梯度。   
* [0.x.33]*
     实现[2.x.14]的豫章。   
* [0.x.34]*
     实现[2.x.15]的DerivativeForm参数。   
* [0.x.35]

