include/deal.II-translator/fe/fe_abf_0.txt
[0.x.0]*
 Arnold-Boffi-Falk（ABF）元素的实现，符合空间H<sup>div</sup>。这些元素在网格单元之间产生连续的法向分量的矢量场。
* 这些元素是基于Arnold, Boffi and Falk的文章：四边形H(div)有限元素，SIAM J. Numer. 分析。第42卷，第6期，第2429-2451页
* 在这篇文章中，作者证明了通常的RT元素以及BDM和其他提议的H(div)的有限维度子空间在任意的FE网格上不能正常工作。也就是说，在这些网格上收敛率会恶化。作为一个解决方案，作者提出了ABF元素，在本模块中实现。
* 这类元素没有实现在一维的情况下（<tt>spacedim != dim</tt>）。
* [2.x.0] 即使这个元素是为二维和三维空间实现的，节点值的定义也依赖于三维中一致方向的面。因此，在复杂的网格上应该注意。
* [1.x.0]
* [2.x.1] 与RT元素相关的 "插值 "算子的构造是这样的：插值和计算发散是互换的操作。我们从插值任意函数以及#限制矩阵中要求这一点。 这可以通过两种插值方案实现，FE_RaviartThomasNodal中的简化方案和这里的原始方案。
* [1.x.1]
* 在边缘或面上，[2.x.2]"节点值 "是内插函数的法线分量相对于RT多项式轨迹的矩。由于在一个边缘/面的度数为[1.x.2]的RT空间的法线轨迹是[1.x.3]的空间，因此相对于这个空间的矩被取走。
* [1.x.4]
* 高阶RT空间有内部节点。这些是相对于[1.x.5]中的函数在单元上的梯度所取的矩（这个空间是混合表述中RT<sub>k</sub>的匹配空间）。
* [1.x.6]
* 上面的节点值依赖于积分，这些积分将由正交规则本身计算出来。广义支持点是一组点，使这种正交能够以足够的精度进行。需要的点是每个面上的QGauss<sub>k+1</sub>以及单元内部的QGauss<sub>k</sub>（或者对于RT<sub>0</sub>来说没有）。更多信息请参见[2.x.3]"广义支持点的术语条目"。

* 
* [0.x.1]*
   程度为[2.x.4]的ABF元素的构造函数。  
* [0.x.2]*
   返回一个唯一标识有限元的字符串。该类返回<tt>FE_ABF<dim>(degree)</tt>，其中[2.x.5]和[2.x.6]由适当的值代替。 
* [0.x.3]*
   如果形状函数[2.x.8]在面的某处有非零函数值，该函数返回[2.x.7]。 现在，这只在一维的RT0中实现。否则，总是返回 [2.x.10] 。  
* [0.x.4]*
   ABF元素的顺序。最低阶的元素通常被称为RT0，尽管它们的形状函数是片状二次方程。 
* [0.x.5]*
   仅供内部使用。它的全称是[2.x.11]函数，它创建了[2.x.12]向量，在构造函数中需要传递给[2.x.13]FiniteElementData的构造函数。 
* [0.x.6]*
   初始化FiniteElement类的[2.x.14]字段，用插值权重（#boundary_weights和#interior_weights）填充表格。从构造函数中调用。    更多信息请参见[2.x.15]"广义支持点的词汇表条目"。 
* [0.x.7]*
   初始化从细化网格单元上的函数到父单元的插值。根据Raviart-Thomas元素的理念，这个限制算子弱地保留了一个函数的发散性。 
* [0.x.8]*
   与单元格无关的数据字段。    关于这个类的一般用途的信息，请参见基类的文档。 
* [0.x.9]*
     带有正交点的形状函数值的数组。每个形状函数都有一行，包含每个正交点的值。    由于形状函数是矢量值（有多少分量就有多少空间维度），所以值是一个张量。        在这个数组中，我们将形状函数的值存储在单元格上的正交点。然后，向实空间单元的转换只需与映射的雅各布系数相乘即可完成。   
* [0.x.10]*
     包含正交点的形状函数梯度的数组。每个形状函数都有一行，包含每个正交点的值。        我们将梯度存储在单元格的正交点上。然后我们只需要在访问实际单元格时应用转换（这是一个矩阵-向量乘法）。   
* [0.x.11]*
   这些是计算积分时乘以#generalized_face_support_points中的一个函数的系数。它们的组织方式是，每个广义面支持点有一行，面的每个自由度有一列。 
* [0.x.12]*
   用于内部自由度内插的预计算系数。这个表的原理与#boundary_weights的原理相同。只是，这个表有第三个坐标，用于评估组件的空间方向。 
* [0.x.13]*
   这些是计算积分时乘以#generalized_face_support_points中的一个函数的系数。它们的组织方式是，每个广义面支持点有一行，面的每个自由度有一列。 
* [0.x.14]*
   用于内部自由度内插的预计算系数。这个表的原理与#boundary_weights的原理相同。只是，这个表有第三个坐标，用于评估组件的空间方向。 
* [0.x.15]*
   初始化包络模式和符号变化模式。   
* [2.x.16]这个函数还没有完全填充正确的实现。它需要在未来的版本中统一实现，以便在包含有翻转面的单元格的网格上工作。 
* [0.x.16]

