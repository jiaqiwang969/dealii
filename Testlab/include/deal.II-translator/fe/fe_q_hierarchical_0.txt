include/deal.II-translator/fe/fe_q_hierarchical_0.txt
[0.x.0]*
 分层[2.x.0]形状函数的实现，产生连续的、程度为[2.x.1]的分片多项式的有限元空间。该类使用基于区间<tt>[0,1]</tt>上的分层基础[2.x.2]的张量积多项式实现，如果我们假设每个元素有一个单度，该张量积有限元适合构建一个[2.x.3]张量积有限元。
* 该类的构造函数取该有限元的度数[2.x.4]。
* 该类没有实现对一维的情况（<tt>spacedim != dim</tt>）。
* [1.x.0]
*构造函数创建一个TensorProductPolynomials对象，其中包括度数为[2.x.5]的多项式的张量积[2.x.6] 这个[2.x.7]TensorProductPolynomials对象提供形状函数的所有值和导数。
* [1.x.1]
* TensorProductPolynomials所代表的形状函数的原始排序是张量乘法的编号。然而，单元格上的形状函数被重新编号，从支持点在顶点的形状函数开始，然后是直线上的，四边形上的，最后是（对于三维）六边形上的。为了明确起见，这些编号列在下面。
* [1.x.2]
* [2.x.8]元素是多项式一度，因此，与FE_Q类中的[2.x.9]元素完全相同。特别是，形状函数的定义完全相同。
* [2.x.10] [2.x.11] 1D情况。 
* [1.x.3]
 
* [2.x.12] 二维情况。 
* [1.x.4]
 
* [2.x.13] 3D情况。 
* [1.x.5]
* 
* 自由度的支持点的各自坐标值如下。 [2.x.14] [2.x.15] 形状函数0。<tt>[0, 0, 0]</tt>; [2.x.16] 形状函数1：<tt>[1, 0, 0]</tt>; [2.x.17] 形状函数2：<tt>[0, 1, 0]</tt>; [2.x.18] 形状函数3：<tt>[1, 1, 0]</tt>; [2.x.19 ] 形状函数4：<tt>[0, 0, 1]</tt>; [2.x.20] 形状函数5：<tt>[1, 0, 1]</tt>; [2.x.21] 形状函数6：<tt>[0, 1, 1]</tt>; [2.x.22] 形状函数7：<tt>[1, 1, 1]</tt>; [2.x.23] [2.x.24] 
* 在2d中，这些形状函数看起来如下。 [2.x.25] 
* 

* [1.x.6] [2.x.26] [2.x.27] 1D情况。 
* [1.x.7]
 
* [2.x.28] 二维情况。 
* [1.x.8]
 
* [2.x.29] 3D情况。 
* [1.x.9]
* 中心顶点的编号为26。
* 自由度的支持点的各自坐标值如下。 [2.x.30] [2.x.31] 形状函数0。<tt>[0, 0, 0]</tt>; [2.x.32] 形状函数1：<tt>[1, 0, 0]</tt>; [2.x.33] 形状函数2：<tt>[0, 1, 0]</tt>; [2.x.34] 形状函数3：<tt>[1, 1, 0]</tt>; [2.x.35 ] 形状函数4：<tt>[0，0，1]</tt>; [2.x.36] 形状函数5：<tt>[1，0，1]</tt>; [2.x.37] 形状函数6：<tt>[0，1，1]</tt>; [2.x.38 ] 形状函数7：<tt>[1，1，1]</tt>; [2.x.39] 形状函数8：<tt>[0，1/2，0]</tt>; [2.x.40] 形状函数9：<tt>[1，1/2，0]</tt>; [2.x.41] 形状函数10：<tt>[1/2，0，0]</tt>; [2.x.42 ] 形状函数11：<tt>[1/2, 1, 0]/tt>; [2.x.43] 形状函数12：<tt>[0, 1/2, 1]/tt>; [2.x.44] 形状函数13：<tt>[1, 1/2, 1]/tt>; [2.x.45 ] 形状函数14：<tt>[1/2, 0, 1]</tt>; [2.x.46] 形状函数15：<tt>[1/2, 1, 1]</tt>; [2.x.47] 形状函数16：<tt>[0, 0, 1/2]</tt>; [2.x.48] 形状函数17：<tt>[1, 0, 1/2]</tt>; [2.x.49 ] 形状函数18：<tt>[0, 1, 1/2]/tt>; [2.x.50] 形状函数19：<tt>[1, 1, 1/2]/tt>; [2.x.51] 形状函数20：<tt>[0, 1/2, 1/2]/tt>; [2.x.52 ] 形状函数21：<tt>[1, 1/2, 1/2]/tt>; [2.x.53] 形状函数22：<tt>[1/2, 0, 1/2]/tt>; [2.x.54] 形状函数23：<tt>[1/2, 1/2]/tt>; [2.x.55 ] 形状函数24：<tt>[1/2, 1/2, 0]</tt>; [2.x.56] 形状函数25：<tt>[1/2, 1/2, 1]</tt>; [2.x.57] 形状函数26：<tt>[1/2, 1/2]</tt>; [2.x.58] [2.x.59] 
* 

* 在2d中，这些形状函数看起来如下（黑色平面对应于零；负的形状函数值可能不可见）。 [2.x.60] 
* 

* [1.x.10] [2.x.61] [2.x.62] 1D情况。 
* [1.x.11]
* 
* [2.x.63] 2D情况。 
* [1.x.12]
* [2.x.64] 
* 在2D中，这些形状函数看起来如下（黑色平面对应于零；负的形状函数值可能不可见）。 [2.x.65] 
* 

* [1.x.13] [2.x.66] [2.x.67] 1D情况。 
* [1.x.14]
 
* [2.x.68] 二维情况。 
* [1.x.15]
* [2.x.69] 
* 在2D中，这些形状函数看起来如下（黑色平面对应于零；负的形状函数值可能不可见）。 [2.x.70] 

* 
* [0.x.1]*
   度数为[2.x.71]的张量乘积多项式的构造函数   
* [0.x.2]*
   返回一个唯一标识有限元的字符串。该类返回<tt>FE_Q_Hierarchical<dim>(degree)</tt>，其中[2.x.72]和[2.x.73]度数由适当的值替换。 
* [0.x.3]*
   如果形状函数[2.x.75]在面[2.x.76]的某处有非零函数值，该函数返回[2.x.74]。  
* [0.x.4]*
    [2.x.77] 支持hp的函数 [2.x.78].   
* [0.x.5]*
   返回该元素是否以新的方式实现其悬挂节点约束，这必须用于使元素 "hp-compatible"。    对于FE_Q_Hierarchical类，结果总是为真（与元素的程度无关），因为它实现了hp-capability所需的完整功能集。 
* [0.x.6]*
   返回从给定的有限元内插到现在的矩阵。只支持FE_Q_Hierarchical之间的插值。 
* [0.x.7]*
   网格之间的嵌入矩阵。只支持各向同性的细化。 
* [0.x.8]*
   如果在一个顶点上，有几个有限元被激活，hp-code首先为这些FEs的自由度分配不同的全局索引。然后调用这个函数来找出其中哪些应该得到相同的值，从而可以得到相同的全局自由度指数。  因此，该函数返回当前有限元对象的自由度与[2.x.79]的自由度之间的相同性列表，后者是对代表在该特定顶点上活动的其他有限元之一的有限元对象的引用。该函数计算两个有限元对象的哪些自由度是相等的，这两个自由度的编号都在零和两个有限元的n_dofs_per_vertex()的相应值之间。每一对的第一个索引表示本元素的一个顶点自由度，而第二个是另一个有限元素的相应索引。 
* [0.x.9]*
   与上述相同，但对线而言。 
* [0.x.10]*
   同上，但对面而言。 
* [0.x.11]*
    [2.x.80] [2.x.81]   
* [0.x.12]*
   返回从一个元素的面插值到邻近元素的面的矩阵。矩阵的大小是<tt>source.dofs_per_face</tt>乘以<tt>this->dofs_per_face</tt>。    衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现从一个给定元素的内插，那么他们必须抛出一个类型为[2.x.82]的异常。  
* [0.x.13]*
   返回从一个元素的面内插到邻近元素的子面的矩阵。矩阵的大小是<tt>source.dofs_per_face</tt>乘以<tt>this->dofs_per_face</tt>。    衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现给定元素的插值，那么他们必须抛出一个<tt>ExcInterpolationNotImplemented</tt>类型的异常。 
* [0.x.14]*
   确定此对象的内存消耗（以字节为单位）的估计值。    这个函数是虚拟的，因为有限元对象通常是通过指向其基类的指针来访问的，而不是类本身。 
* [0.x.15]*
   对于度数为[2.x.83]<[2.x.84]的有限元，我们返回一个向量，将度数为[2.x.85]的FE上的编号映射到这个元素上的编号。 
* [0.x.16]*
   返回一个元素的常数模式的列表。对于这个元素，该列表由第一个顶点形状函数的真参数和其余的假参数组成。 
* [0.x.17]*
   仅供内部使用。它的全称是[2.x.86]函数，它创建了[2.x.87]向量，在构造函数内需要传递给[2.x.88]FiniteElementData的构造函数。 
* [0.x.18]*
   连续有限元中自由度的编号是分层次的，也就是说，我们首先按照三角形定义的顶点顺序对顶点自由度进行编号，然后按照顺序和尊重线的方向对线自由度进行编号，然后是四边形上的自由度，等等。    与1d分层多项式相关的道夫是以顶点为先（[2.x.89]和[2.x.90]），然后是线道夫（高阶多项式）。 2d和3d等级多项式通过张量乘积来源于1d等级多项式。在下文中，由此产生的dofs的编号将用`fe_q_hierarchical numbering`来表示。    这个函数构建了一个表格，其中fe_q_hierarchical索引中的每个自由度在分级编号中会有。    这个函数类似于[2.x.91]函数。然而，与上面定义的fe_q_hierarchical编号不同，lexicographic编号源于连续编号的自由度的张量积（就像对LagrangeEquidistant）。    假设输出参数的大小已经符合正确的大小，等于有限元的自由度数。 
* [0.x.19]*
   这是一个类似于前一个函数的函数，但对面进行工作。 
* [0.x.20]*
   初始化两个辅助字段，用于设置构造函数中的各种矩阵。 
* [0.x.21]*
   初始化悬挂节点的约束矩阵。从构造函数中调用。 
* [0.x.22]*
   初始化嵌入矩阵。从构造函数中调用。 
* [0.x.23]*
   初始化FiniteElement类的[2.x.92]字段。  从构造函数中调用。 
* [0.x.24]*
   初始化FiniteElement类的[2.x.93]字段。从构造函数中调用。 
* [0.x.25]*
   在第一个面上从lexicographic到形状函数编号的映射。 
* [0.x.26]

