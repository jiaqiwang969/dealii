include/deal.II-translator/fe/fe_raviart_thomas_0.txt
[0.x.0]*
 Raviart-Thomas（RT）元素的实现。Raviart-Thomas空间的设计是为了解决解只存在于空间[2.x.0]的问题，而不是更常用的空间[2.x.1]。换句话说，解决方案必须是一个矢量场，其发散是可平方整除的，但其梯度可能不是可平方整除的。这个空间（和这些元素）的典型应用是拉普拉斯方程的混合表述和相关情况，例如，见 [2.x.2] 。[2.x.3]中的函数的决定性特征是它们一般是不连续的
* 
* - 但如果你在2D中画一条线（或在3D中画一个面），那么矢量场的[1.x.0]分量必须在线（或面）上连续，尽管切向分量可能不是。因此，Raviart-Thomas元素的构造是这样的：（i）它是[2.x.4]"矢量值"，（ii）形状函数是不连续的，但（iii）每个形状函数所代表的矢量场的法向分量在单元面上是连续的。
* Raviart-Thomas元素的其他特性是：(i)它是[2.x.5]"非原始元素"；(ii)形状函数的定义使某些面的积分为零或一，而不是常见的某些点值为零或一的情况。然而，有一个FE_RaviartThomasNodal元素使用点值）。
* 我们遵循通常使用的
* 
* - 尽管很混乱
* 
* - RT元素的 "度 "的定义。具体来说，元素的 "度 "表示有限元空间中包含的[1.x.1]的多项式度，即使该空间可能包含更高多项式度的形状函数。因此，最低阶元素是FE_RaviartThomas(0)，即 "零度 "的Raviart-Thomas元素，尽管这个空间的函数一般是每个变量的一度多项式。这种 "度 "的选择意味着函数本身的近似顺序是[1.x.2]，就像通常的多项式空间一样。如此选择的编号意味着序列为[1.x.3]。
* 该类没有在二维一的情况下实现（<tt>spacedim != dim</tt>）。
* 

* [1.x.4]
* 与RT元素相关的[2.x.6]"插值 "算子的构造是，插值和计算发散是互换的操作。我们从插值任意函数以及#限制矩阵中要求这一点。 这可以通过两种插值方案实现，FE_RaviartThomasNodal中的简化方案和这里的原始方案。
* [1.x.5]
* 在边缘或面上，[2.x.7]"节点值 "是内插函数的法线分量相对于RT多项式轨迹的矩。由于在一个边缘/面的度数为[1.x.6]的RT空间的法线轨迹是空间[1.x.7]，因此相对于这个空间的矩。
* [1.x.8]
* 高阶RT空间有内部节点。这些是相对于[1.x.9]中的函数在单元上的梯度所取的矩（这个空间是混合表述中RT<sub>k</sub>的匹配空间）。
* [1.x.10]
* 上面的节点值依赖于积分，这些积分将由正交规则本身计算出来。广义支持点是一组点，使这种正交能够以足够的精度进行。需要的点是每个面上的QGauss<sub>k+1</sub>以及单元内部的QGauss<sub>k+1</sub>（或者对于RT<sub>0</sub>来说没有）。

* 
* [0.x.1]*
   度数为[2.x.8]的Raviart-Thomas元素的构造函数。  
* [0.x.2]*
   返回一个唯一标识有限元的字符串。该类返回<tt>FE_RaviartThomas<dim>(degree)</tt>，其中[2.x.9]和[2.x.10]用适当的值替换。 
* [0.x.3]*
   如果形状函数[2.x.12]在面的某处有非零函数值，该函数返回[2.x.11]。 现在，这只在一维的RT0中实现。否则，总是返回 [2.x.14] 。  
* [0.x.4]*
   返回元素的恒定模式列表。这个方法目前没有正确实现，因为它对所有元件都返回1。 
* [0.x.5]*
   仅供内部使用。它的全称是[2.x.15]函数，它创建了[2.x.16]向量，在构造函数中需要传递给[2.x.17] FiniteElementData的构造函数。 
* [0.x.6]*
   初始化FiniteElement类的[2.x.18]字段，用插值权重（#boundary_weights和#interior_weights）填充表格。从构造函数中调用。 
* [0.x.7]*
   初始化从细化网格单元上的函数到父单元的插值。根据Raviart-Thomas元素的理念，这个限制算子弱地保留了函数的发散性。 
* [0.x.8]*
   这些是计算积分时乘以#generalized_face_support_points中的一个函数的系数。它们的组织方式是，每个广义面支持点有一行，面的每个自由度有一列。    更多信息请参见[2.x.19]"广义支持点词汇表条目"。 
* [0.x.9]*
   用于内部自由度内插的预计算系数。此表的原理与#boundary_weights的原理相同。只是，这个表有第三个坐标，用于评估组件的空间方向。 
* [0.x.10]*
   填充基类中定义的必要表格，如fe.cc中声明的[2.x.20]。在非标准面、翻转（旋转+180度）或旋转（旋转+90度）的情况下，我们需要用正确的值来填充它。这些是以三个标志的形式给出的（face_orientation, face_flip, face_rotation），见GeometryInfo<dim>中的文档和这个[2.x.21]"关于面的方向的词汇条"。    [1.x.11] 一个面的道夫被连接到一个 [2.x.22] 矩阵，这里 [2.x.23] 。在我们的例子中，我们可以想象在一个四边形（面）上有以下的道夫。   
* [1.x.12]
* 我们有一个局部[2.x.24]，索引[2.x.25]在y方向上从0到[2.x.26]和[2.x.27]，<code>j = dof_index / n</code>（整数分割）。然后指数[2.x.28]和[2.x.29]可以用来计算偏移量。    对于我们的Raviart-Thomas元素的例子，这意味着如果开关是[2.x.30]，意味着我们首先将面旋转+90度（逆时针），然后再旋转+180度，但我们不翻转它，因为面有标准方向。翻转轴是指从面的左下角到右上角的对角线。有了这些标志，上面的配置就变成了。  
* [1.x.13]
* 请注意，排列组合的必要性取决于这三个标志的组合。    还有一种模式是，被烫的形状函数的符号变化取决于开关的组合。在上面的例子中，它将是    
* [1.x.14]
*符号变化的相关表格在FE_PolyTensor中声明。 
* [0.x.11]*
 Raviart-Thomas元素的节点函数定义为高斯点的点值。
* [1.x.15]
* 对于这个Raviart-Thomas元素，节点值不是相对于某些多项式的单元和面矩，而是正交点中的值。按照自由度编号的一般方案，根据单元格边缘的自然排序，边缘上的节点值排在前面，逐个边缘排列。内部自由度排在最后。
* 对于一个度数为[1.x.16]的RT元素，我们在每个面上选择[1.x.17]个高斯点。这些点在面的方向上是按字母顺序排列的。这样一来，处于[1.x.18]的法线分量就被唯一地确定了。此外，由于这个高斯公式在[1.x.19]上是精确的，这些节点值对应于RT-空间的精确积分矩。
* 在单元内部，矩是相对于各向异性的[1.x.20]空间而言的，其中测试函数在对应于所考虑的矢量分量的方向上低一度。这是通过使用各向异性的高斯公式进行积分来模仿的。
* [2.x.31] 目前的实现只针对笛卡尔网格。你必须使用MappingCartesian。
* [2.x.32] 即使这个元素是为二维和三维空间实现的，节点值的定义也依赖于三维中一致方向的面。因此，在复杂的网格上应该注意。
* 

* 
* [2.x.33] 存储在成员变量[2.x.34]中的度数比构造函数参数高一!

* 
* [0.x.12]*
   程度为[2.x.35]的Raviart-Thomas元素的构造函数。  
* [0.x.13]*
   返回一个唯一标识有限元的字符串。该类返回<tt>FE_RaviartThomasNodal<dim>(degree)</tt>，其中[2.x.36]和[2.x.37]度被适当的值取代。 
* [0.x.14]*
    [2.x.38] [2.x.39]。  
* [0.x.15]*
   仅供内部使用。它的全称是[2.x.40]函数，它创建了[2.x.41]向量，在构造函数中需要传递给[2.x.42]FiniteElementData的构造函数。 
* [0.x.16]*
   计算用于传递给基类构造函数的[2.x.43]字段的向量。 
* [0.x.17]*
   如果形状函数[2.x.45]在面的某处有非零的函数值，这个函数返回[2.x.44]。现在，这只在一维的RT0中实现。否则，总是返回 [2.x.47] 。  
* [0.x.18]*
   初始化[2.x.48]和[2.x.49]字段。从构造函数中调用。    更多信息请参见[2.x.50]"关于广义支持点的词汇表条目"。 
* [0.x.19]*
   初始化包络模式和符号变化模式。 
* [0.x.20]

