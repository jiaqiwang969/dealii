include/deal.II-translator/fe/mapping_fe_field_0.txt
[0.x.0]*
  [2.x.0] 使用MappingFEField<dim, spacedim, VectorType>代替。

* 
* [0.x.1]*
 MappingFEField是MappingQEulerian类的一个泛化，用于任意矢量有限元。两个主要的区别是，这个类使用绝对位置的矢量，而不是位移的矢量，而且它允许任意的有限元类型，而不是只有FE_Q。
* 该类有效地将拓扑结构与几何结构相分离，将所有的几何信息归结为FiniteElement矢量场的某些组件。用于几何学的分量可以在构造时任意选择。
* 我们的想法是将三角剖分视为一个参数配置空间，在此基础上构建一个任意的几何映射，使用deal.II库的工具：一个自由度矢量，一个与问题几何相关的DoFHandler，以及一个ComponentMask，告诉我们FiniteElement的哪些组件要用于映射。
* 通常，DoFHandler操作的有限元是由连续的FE_Q()（用于等参数离散）或FE_Bernstein()（用于等几何离散）对象构建的系统元（FESystem() ）。下面是一个例子。
* 

* 
* [1.x.0]
* 

* 
* [0.x.2]*
   构造函数。第一个参数是一个VectorType，指定域从参考到当前配置的转换。    一般来说，这个类将几何学与拓扑学解耦，允许用户定义仅在拓扑学上与底层三角结构等价的几何学，但其他方面可能是任意的。  与MappingQEulerian不同的是，传递给构造函数的FiniteElement字段被解释为一个绝对的几何配置，因此我们必须确保euler_vector实际代表一个有效的几何体（即没有倒置的单元或没有零体积的单元）。    如果底层的FiniteElement是FE_Q()的一个系统，并且euler_vector是用[2.x.1]初始化的，那么这个类在所有方面都与MappingQ()相同。    可选的ComponentMask参数可以用来指定FiniteElement的哪些组件要用于几何变换。如果在构造时没有指定掩码，那么将使用默认的掩码，这使得该类的工作方式与MappingQEulerian()相同，即假定FiniteElement的第一个间隔分量代表问题的几何形状。    请注意，如果指定了一个掩码，它的大小必须与底层的FiniteElement相匹配，并且它必须有完全间隔的非零元素，表明FiniteElement的组件（按顺序）将被用于几何。    如果传递了一个不兼容的掩码，就会抛出一个异常。 
* [0.x.3]*
   构造函数在多网格层上获取向量，而不是只获取活动单元。向量的向量应该有与三角形中的全局层次一样多的条目，并在每个层次上提供有效的数据，即长度兼容 [2.x.2] 这个构造函数的前提条件是[2.x.3]已经被调用。除了级别向量外，还需要提供与其他构造函数相同的参数。 
* [0.x.4]*
   用MGLevelObject代替[2.x.4]的构造函数，否则与上述相同。要求`euler_vector.max_level()+1`等于三角形中的全局级数。最小级别可以是0或更多&mdash; 它只需要在这里设置的内容和后来用于评估映射的内容之间保持一致。 
* [0.x.5]*
   复制构造函数。 
* [0.x.6]*
   返回一个指向当前对象副本的指针。然后，这个副本的调用者就拥有了它的所有权。 
* [0.x.7]*
   关于这个函数的目的，请参见[2.x.5]的文档。这个类中的实现总是返回[2.x.6]。  
* [0.x.8]*
   返回一个单元格的映射顶点。    这个映射忽略了它所关联的三角形的顶点，并根据构造时传递的[2.x.7]来构造顶点的位置。 
* [0.x.9]*
    [2.x.8] 参考单元和实数单元之间的映射点[2.x.9] 。  
* [0.x.10]*
    [2.x.10]   
* [0.x.11]*
    [2.x.11] 将张量从参考坐标转换为实坐标的函数 [2.x.12]   
* [0.x.12]*
       
* [0.x.13]*
   返回映射的程度，即传递给构造函数的值。 
* [0.x.14]*
   返回映射的ComponentMask，即哪些组件要用于映射。 
* [0.x.15]*
   异常情况  
* [0.x.16]*
    [2.x.14] 与FEValues的接口[2.x.15] 。  
* [0.x.17]*
   此映射的内部数据的存储。见[2.x.16]的广泛描述。    这包括在创建对象时（在get_data()中）计算一次的数据，以及该类希望从调用fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()之间存储的数据，直到以后可能从有限元调用转化()等函数。后一类成员变量与从头开始的数组一起被标记为 "可变"。 
* [0.x.18]*
     构造函数。   
* [0.x.19]*
     正交点的形状函数。形状函数是按张量积顺序排列的，所以顶点必须重新排序以获得变换。   
* [0.x.20]*
     正交点的形状函数。见上文。   
* [0.x.21]*
     形状函数在正交点的梯度。见上文。   
* [0.x.22]*
     形状函数在正交点的梯度。见上文。   
* [0.x.23]*
     形状函数在正交点的二阶导数。见上文。   
* [0.x.24]*
     形状函数在正交点的二阶导数。见上文。   
* [0.x.25]*
     形状函数在正交点的三次导数。见上文。   
* [0.x.26]*
     在正交点的形状函数的第四导数。见上文。   
* [0.x.27]*
     形状函数在正交点的四次导数。见上文。   
* [0.x.28]*
     形状函数在正交点的三次导数。见上文。   
* [0.x.29]*
     返回这个对象的内存消耗估计值（以字节为单位）。   
* [0.x.30]*
     形状函数的值。通过函数访问 [2.x.17] 计算一次。   
* [0.x.31]*
     形状函数导数的值。通过函数访问 [2.x.18] 计算一次。   
* [0.x.32]*
     形状函数二次导数的值。通过函数[2.x.19] second_derivative访问。        计算一次。   
* [0.x.33]*
     形状函数第三导数的值。通过函数[2.x.20] third_derivative访问。        计算一次。   
* [0.x.34]*
     形状函数第四导数的值。通过函数[2.x.21] fourth_derivative访问。        计算一次。   
* [0.x.35]*
     单位切向量。用于计算边界形式和法向量。        这个数组有[2.x.22]个条目。第一组[2.x.23]包含每个面的第一个切向的向量；第二组[2.x.24]条目包含第二个切向的向量（仅在三维中，因为每个面有两个切向），等等。        填充一次。   
* [0.x.36]*
     形状函数的数量。如果这是一个Q1的映射，那么它只是每个单元格的顶点数量。然而，因为还有派生类使用这个类（例如Mapping_Q()类），所以形状函数的数量也可能不同。   
* [0.x.37]*
     存储构造时给出的掩码。如果在构造时没有指定掩码，那么将使用默认的掩码，这使得该类与MappingQEulerian()的工作方式相同，即FiniteElement的第一个间隔分量被用于euler_vector和euler_dh。        如果指定了一个掩码，那么它必须与底层的FiniteElement相匹配，并且它必须有完全间隔的非零元素，表明FiniteElement的组件（按顺序）将被用于欧拉向量和欧拉道夫处理。   
* [0.x.38]*
     每个正交点的协方差变换的张量。    存储的矩阵是Jacobian G^{-1}，其中G = Jacobian^{t}     Jacobian，是地图的第一基本形式；如果dim=spacedim，那么它还原为Jacobian矩阵的转置，它本身存储在这个结构的[2.x.25]域中。        在每个单元格上计算。   
* [0.x.39]*
     每个正交点上的禁忌变换的张量。不变矩阵是变换的雅各布系数，即[2.x.26] 。        在每个单元上计算。   
* [0.x.40]*
     在每个正交点的雅各布系数的行列式。如果#update_volume_elements就会被填满。   
* [0.x.41]*
     供内部使用的辅助向量。   
* [0.x.42]*
     储存局部自由度的指数。   
* [0.x.43]*
     本地自由度的存储。   
* [0.x.44]*
    [2.x.27]   
* [0.x.45]*
   指定我们是在活动自由度上（用一个欧拉向量）还是在水平自由度上（通过一个欧拉向量的向量）访问未知数。 
* [0.x.46]*
   对移位矢量的参考。 
* [0.x.47]*
   指向映射向量所关联的DoFHandler的指针。 
* [0.x.48]*
   将单元格上的点[2.x.28]转换为实数单元格[2.x.30]上的点[2.x.29]，并返回[2.x.31] 这个函数被[2.x.32]调用，并被[2.x.33] transform_real_to_unit_cell_internal(牛顿反复)多次调用。    接收一个对[2.x.34]的引用，该引用必须已经包括[2.x.35]点的形状值和单元格的映射支持点。    这个[2.x.36]参数可以避免对[2.x.37]点的形状值进行多次计算，特别是对映射支持点进行多次计算。 
* [0.x.49]*
   通过牛顿迭代将实细胞上的点[2.x.38]转换为单元格[2.x.39]上的相应点。    取一个对[2.x.40]的引用，该引用假定是由[2.x.41]函数与[2.x.42]包括[2.x.43]update_transformation_values和[2.x.44]和一个点的正交所创建的，包括对变换的初始猜测[2.x.45 ] 因此，这个函数假定[2.x.46]mdata已经包括了变换的形状值和在[2.x.47][2.x.48]计算的梯度将被这个函数所改变。 
* [0.x.50]*
   更新内部自由度。 
* [0.x.51]*
   详细情况见基类的文档。 
* [0.x.52]在映射中使用哪些组件。 
* [0.x.53]*
   在FE空间和实空间的指数之间的映射。这个向量包含有限元空间的每个分量的一个索引。如果该索引是一个用于构建该元素的ComponentMask为false，那么将返回[2.x.49]，否则将返回实空间的分量。例如，如果我们使用ComponentMask(spacedim, true)构建映射，那么这个向量包含{0,1,2}在spacedim=3。 
* [0.x.54]*
   FEValues对象，用于查询参考配置中支持点的给定有限元场。 
* [0.x.55]*
   一个变量用于保护对fe_values变量的访问。 
* [0.x.56]

