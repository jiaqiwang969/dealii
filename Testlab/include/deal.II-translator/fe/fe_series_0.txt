include/deal.II-translator/fe/fe_series_0.txt
[0.x.0]*
 这个命名空间提供了计算参考元素上的解的扩展系列的函数。膨胀系数通常用于估计底层FiniteElement场的局部平滑性，以决定h-或p-适应性细化策略。

* 
* [0.x.1]*
   一个用于计算标量FE（或矢量FE的单一分量）场在参考元素上的傅里叶级数的扩展的类。  傅里叶级数的指数形式是基于指数函数集的完整性和赫米特正交性 [2.x.0] 。  例如在一维中，L2正交性条件为 [1.x.0] 注意 [2.x.1] 。    参考元素上的任意标量FE场可以在完整的正交指数基中展开为[1.x.1] 从基的正交性属性来看，可以得出[1.x.2] 正是这个复值展开系数，由这个类计算。请注意，[2.x.2] ，其中[2.x.3] 是实值的FiniteElement形状函数。  因此[2.x.4]，我们只需要计算[2.x.5]的正指数[2.x.6] 。 
* [0.x.2]*
     构造函数，初始化所有需要的数据结构。        [2.x.7]定义了每个方向上的系数数，[2.x.8]是将用于扩展的[2.x.9]，[2.x.10]是用于整合每个FiniteElement在[2.x.12]的扩展的[2.x.11]由于傅里叶扩展只能对标量场进行，这个类不能对矢量值的有限元操作，因此会抛出一个断言。然而，有限元场的每个分量可以分别被视为标量场，对其进行傅里叶展开也是可能的。为此，可选的参数[2.x.13]定义了每个有限元的哪个分量将被使用。    [2.x.14]的默认值只适用于标量FEs，在这种情况下，它表示唯一的分量将被分解。对于矢量FE，必须明确提供一个非默认值。   
* [0.x.3]*
     一个非默认的构造函数。[2.x.15]定义了每个方向的模数，[2.x.16]是将使用扩展的[2.x.17]，[2.x.18]是用于整合[2.x.20][2.x.21]中每个FiniteElement的扩展的[2.x.19] 使用不同的构造函数代替。   
* [0.x.4]*
     计算[2.x.22]中[2.x.23]给出的单元格矢量场，对应于FiniteElement的[2.x.24] 。   
* [0.x.5]*
     返回与[2.x.25]相关的有限元在所提供的[2.x.26]中每个坐标方向的系数数。    
* [0.x.6]*
     计算所有的转换矩阵，将有限元解转移到系列展开表示。        这些矩阵将通过调用calculate()按需生成，并存储起来供重复使用。通常情况下，这个操作会消耗大量的工作量。有了这个函数，所有的矩阵将被提前计算。    这样，我们就可以将其昂贵的生成与实际应用分开。   
* [0.x.7]*
     将此对象的所有转换矩阵写入一个流中，以便进行序列化。        因为它的任何一个变换矩阵对于一个给定的场景只需要生成一次，所以通常的做法是提前调用precalculate_all_transformation_matrices()来确定它们，并通过序列化保留它们。   
* [0.x.8]*
     从一个流中读取所有的变换矩阵，并为这个对象恢复它们。   
* [0.x.9]*
     测试两个系列扩展对象的相等。   
* [0.x.10]*
     注册的每个有限元在每个方向上的系数数 [2.x.27] 。    
* [0.x.11]*
      [2.x.28]为其计算变换矩阵。   
* [0.x.12]*
      [2.x.29]用于计算转换矩阵。   
* [0.x.13]*
     角度频率 [2.x.30] .    
* [0.x.14]*
     每个FiniteElement的变换矩阵。   
* [0.x.15]*
     用于存储未滚动系数的辅助向量。   
* [0.x.16]*
     应该使用FiniteElement的哪个分量来计算展开。   
* [0.x.17]*
   一个用于计算标量FE（或矢量FE的单个分量）场在参考元素上扩展为一系列Legendre函数的类。    Legendre函数是Legendre微分方程[1.x.3]的解，可以用Rodrigues公式[1.x.4]来表达，这些多项式相对于区间[2.x.31][1.x.5]的内积是正交的，是完整的。  在[2.x.33]上的[2.x.34]的正交多项式家族可以通过[1.x.6]构建。 参考元素[2.x.35]上的任意标量FE场可以在完全正交基础上展开为[1.x.7 ]从基的正交特性可以看出，[1.x.8]该类计算系数[2.x.36]使用[2.x.37]-维Legendre多项式，使用张量积规则从[2.x.38]构建。 
* [0.x.18]*
     构造函数，初始化所有需要的数据结构。        [2.x.39]定义了每个方向的系数数，[2.x.40]是将用于展开的[2.x.41]，[2.x.42]是用于整合[2.x.44]中每个FiniteElement的展开的[2.x.43]由于Legendre展开只能在标量场上进行，这个类不会对矢量值的有限元操作，因此会抛出一个断言。然而，有限元场的每个分量可以分别被视为标量场，对其进行Legendre扩展也是可能的。为此，可选的参数[2.x.45]定义了每个有限元的哪个分量将被使用。    默认值[2.x.46]只适用于标量FEs，在这种情况下，它表示唯一的分量将被分解。对于矢量FE，必须明确提供一个非默认值。   
* [0.x.19]*
     一个非默认的构造函数。[2.x.47]定义了每个方向的系数数，[2.x.48]是[2.x.49]，将对其进行扩展，[2.x.50]是用于整合[2.x.52][2.x.53]中每个FiniteElement的扩展的[2.x.51]使用一个不同的构造函数代替。   
* [0.x.20]*
     计算[2.x.54]中由[2.x.55]给出的单元向量场的[2.x.56]对应的FiniteElement。   
* [0.x.21]*
     返回与[2.x.57]相关的有限元在所提供的[2.x.58]中每个坐标方向的系数数。    
* [0.x.22]*
     计算所有的转换矩阵，将有限元解转移到系列展开表示。        这些矩阵将通过调用calculate()按需生成，并存储起来供重复使用。通常情况下，这个操作会消耗大量的工作量。有了这个函数，所有的矩阵将被提前计算。    这样，我们就可以将其昂贵的生成与实际应用分开。   
* [0.x.23]*
     将此对象的所有转换矩阵写入一个流中，以便进行序列化。        由于它的任何一个变换矩阵对于一个给定的场景只需要生成一次，通常的做法是提前调用precalculate_all_transformation_matrices()来确定它们，并通过序列化来保留它们。   
* [0.x.24]*
     从一个流中读取所有的变换矩阵，并为这个对象恢复它们。   
* [0.x.25]*
     测试两个系列扩展对象的相等。   
* [0.x.26]*
     注册的每个有限元在每个方向上的系数数 [2.x.59] 。    
* [0.x.27]*
      [2.x.60]将计算其变换矩阵。   
* [0.x.28]*
      [2.x.61] 用于计算转换矩阵。   
* [0.x.29]*
     每个FiniteElement的变换矩阵。   
* [0.x.30]*
     用于存储解卷系数的辅助向量。   
* [0.x.31]*
     应该使用FiniteElement的哪个分量来计算展开。   
* [0.x.32]*
   计算由[2.x.64]定义的[2.x.63]的子集的[2.x.62]为常数。返回一对谓词值的向量和计算出的子集规范的向量。     [2.x.65]应该返回一对[2.x.66]和<code>无符号int</code>。前者是一个标志，表明是否应该在计算中使用给定的TableIndices，而后者是指数的解卷值，根据这个指数将形成系数的子集。    只有那些大于[2.x.67]的系数才会被考虑。    
* [2.x.68] 只有以下[2.x.69]的值可以实现，并且在这种情况下是有意义的：均值、L1_norm、L2_norm、Linfty_norm。均值准则只适用于实值系数。 
* [0.x.33]*
   [2.x.70]的线性回归最小平方拟合。  输入向量的大小应该等于和大于1。返回的对子将包含[2.x.71]（第一）和[2.x.72]（第二）。 
* [0.x.34]

