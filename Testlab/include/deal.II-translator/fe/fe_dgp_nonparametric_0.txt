include/deal.II-translator/fe/fe_dgp_nonparametric_0.txt
[0.x.0]*
 在映射的正交点上评估的不连续有限元。
* 警告：这个类还不能正常工作。不要使用它!
* 这个有限元实现了完整的多项式空间，即[2.x.0] -维多项式的阶数[2.x.1] 。
* 多项式是没有映射的。因此，它们在任何网格单元上都是常数、线性、二次等。
* 由于多项式是在实际网格单元的正交点上评估的，所以没有网格转移和内插矩阵。
* 这个类的目的是实验性的，因此实现起来将是不完整的。
* 此外，该类没有对一维的情况（<tt>spacedim != dim</tt>）进行实现。
* 

* [1.x.0] 在2d中，这个元素的形状函数看起来如下。
* [1.x.1]
* [2.x.2] 
* [1.x.2]
* [2.x.3] 
 

* [1.x.3]
* [2.x.4] 
* 

* [1.x.4]
* [2.x.5] 
 

* [1.x.5] [2.x.6]。
 

* [1.x.6]
* 这个元素没有InternalData类，与所有其他元素不同，因为InternalData类是用来存储那些可以计算一次并多次重复使用的东西（比如参考单元上正交点的形状函数值）。然而，由于该元素没有被映射，这个元素没有任何可以在参考单元上计算的东西
* 
* - 一切都需要在真实单元上计算
* 
* 因此，在这样一个对象中没有我们想要存储的东西。因此，我们可以简单地使用[2.x.7]已经提供的成员，而不用在这个类的派生类中添加任何东西。

* 
* [0.x.1]*
   度数为[2.x.8]的张量乘积多项式的构造函数。  
* [0.x.2]*
   返回一个唯一标识有限元的字符串。该类返回<tt>FE_DGPNonparametric<dim>(degree)</tt>，其中[2.x.9]和[2.x.10]度数由适当的值代替。 
* [0.x.3]*
   这个函数旨在返回参考单元格上某一点的形状函数的值。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.11]这个函数抛出了一个[2.x.12]类型的异常。  
* [0.x.4]*
   这个函数旨在返回参考单元格上某一点的形状函数的值。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.13]这个函数抛出了一个[2.x.14]类型的异常。  
* [0.x.5]*
   这个函数的目的是返回一个形状函数在参考单元格上某一点的梯度。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.15]这个函数抛出了一个[2.x.16]类型的异常。  
* [0.x.6]*
   这个函数的目的是返回一个形状函数在参考单元格上某一点的梯度。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.17]这个函数抛出了一个[2.x.18]类型的异常。  
* [0.x.7]*
   这个函数的目的是返回参考单元上某一点的形状函数的Hessian。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.19]这个函数抛出了一个[2.x.20]类型的异常。  
* [0.x.8]*
   这个函数的目的是返回参考单元上某一点的形状函数的Hessian。然而，由于当前元素没有通过参考单元的映射来实现形状函数，参考单元上不存在形状函数。    因此，正如基类中相应的函数所讨论的，[2.x.21]这个函数抛出了一个[2.x.22]类型的异常。  
* [0.x.9]*
   返回该有限元的多项式程度，即传递给构造函数的值。 
* [0.x.10]*
   返回从一个元素的一个面插值到相邻元素的面的矩阵。矩阵的大小是<tt>source.dofs_per_face</tt>乘以<tt>this->dofs_per_face</tt>。    衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现从一个给定元素的内插，那么他们必须抛出一个类型为[2.x.23]的异常。  
* [0.x.11]*
   返回从一个元素的一个面插值到邻近元素的面的矩阵。矩阵的大小是<tt>source.dofs_per_face</tt>乘以<tt>this->dofs_per_face</tt>。    衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现从一个给定元素的内插，那么他们必须抛出一个类型为[2.x.24]的异常。  
* [0.x.12]*
    [2.x.25] 支持 hp [2.x.26] 的函数。  
* [0.x.13]*
   如果在一个顶点上，有几个有限元处于活动状态，hp代码首先为这些FEs的每个自由度分配不同的全局索引。然后调用这个函数来找出其中哪些应该得到相同的值，从而可以得到相同的全局自由度指数。  因此，该函数返回当前有限元对象的自由度与[2.x.27]的自由度之间的相同性列表，后者是对代表在该特定顶点上活动的其他有限元之一的有限元对象的引用。该函数计算两个有限元对象的哪些自由度是等价的，这两个自由度的编号都在0和两个有限元的n_dofs_per_vertex()的相应值之间。每一对的第一个索引表示本元素的一个顶点自由度，而第二个是另一个有限元素的相应索引。    作为一个不连续的元素，这种约束的集合当然是空的。 
* [0.x.14]*
   与hp_vertex_dof_indices()相同，只是该函数处理的是线上的自由度。    这是一个不连续的元素，这种约束的集合当然是空的。 
* [0.x.15]*
   与hp_vertex_dof_indices()相同，只是该函数处理的是四边形上的自由度。    这是一个不连续的元素，这种约束的集合当然是空的。 
* [0.x.16]*
   返回该元素是否以新的方式实现其悬挂节点约束，这必须用于使元素 "hp-compatible"。    对于FE_DGPNonparametric类，结果总是真（与元素的程度无关），因为它没有悬挂节点（是一个不连续的元素）。 
* [0.x.17]*
    [2.x.28] [2.x.29].   
* [0.x.18]*
    [2.x.30]   
* [0.x.19]*
   如果形状函数[2.x.32]在面的某处有非零函数值，该函数返回[2.x.31]。  
* [0.x.20]*
   确定这个对象的内存消耗（以字节为单位）的估计值。    这个函数是虚拟的，因为有限元对象通常是通过指向其基类的指针来访问的，而不是类本身。 
* [0.x.21]*
   准备内部数据结构并填入独立于单元的值。 
* [0.x.22]*
   仅供内部使用。它的全称是[2.x.34]函数，它创建了[2.x.35]向量，在构造函数内需要传递给[2.x.36]FiniteElementData的构造函数。 
* [0.x.23]*
   指向代表这里使用的多项式空间的对象的指针。 
* [0.x.24]

