include/deal.II-translator/fe/mapping_q_cache_0.txt
[0.x.0]*
 这个类以[2.x.0]函数的形式为MappingQ家族的对象实现了一个缓存策略，它被用于MappingQGeneric的所有操作中。映射的信息是由[2.x.1]函数预先计算出来的。
* 这个类的使用在 [2.x.2] 中有广泛的讨论。

* 
* [0.x.1]*
   构造函数。 [2.x.3]表示用于从参考单元映射到实数单元的多项式的度数。 
* [0.x.2]*
   复制构造器。 
* [0.x.3]*
   解构器。 
* [0.x.4]*
   clone()功能。有关文档，请参见[2.x.4]。  
* [0.x.5]*
   返回[2.x.5]，因为顶点位置的保存取决于交给 reinit() 函数的映射。 
* [0.x.6]*
   通过计算给定三角形的所有单元（在所有层次上）的映射支持点来初始化数据缓存。   
* [2.x.6]在底层三角图的信号[2.x.7]时，缓存失效。 
* [0.x.7]*
   通过计算给定三角形的所有单元（在所有层面）的映射支持点来初始化数据缓存。   
* [2.x.8] 缓存在底层三角图的信号[2.x.9]时失效。     [2.x.10] 使用上面的initialize()版本代替。 
* [0.x.8]*
   通过让作为参数的函数提供给定三角形的所有单元（在所有层面）的映射支持点来初始化数据缓存。该函数必须返回一个`Point<spacedim>`的向量，其长度与多项式空间的大小相同，[2.x.11] ，其中[2.x.12]是映射的多项式程度，而且必须按照映射或FE_Q对其点的排序，即首先是所有[2.x.13]的顶点，然后是线、四边形和六边形的点，按照通常的分层编号。除了给定的点的数量之外，没有尝试在内部验证这些点。   
* [2.x.14] 如果启用了多线程，这个函数将并行运行，多次调用传入的函数。因此，在[2.x.15]的情况下，用户代码必须确保该函数（通常是一个lambda）不会写进与其他线程共享的数据。   
* [2.x.16]缓存在底层三角化的信号[2.x.17]时被无效。 
* [0.x.9]*
   通过计算给定三角形的所有单元（在所有层次上）和给定[2.x.18]的映射支持点并通过函数[2.x.19]转换这些点来初始化数据缓存。 bool [2.x.20]表示函数[2.x.21]映射到绝对坐标。  如果参数设置为真，函数的返回值将被解释为相对变形，其结果最终将被添加到原始点上，用于本类最终使用的支持点。    这个函数调用前一个函数，所以上面列出的关于线程的评论也适用于此。   
* [2.x.22]缓存在底层三角函数的信号[2.x.23]时被废止。 
* [0.x.10]*
   与上述相同，但取一个[2.x.24]对象。 
* [0.x.11]*
   通过一个离散字段（由[2.x.25]和[2.x.26]指定，描述每个支持点的绝对或相对位置，初始化活动单元的数据缓存。   
* [2.x.27]通过使用这个函数进行重新初始化，这个类的行为就像MappingFEField（vector_describes_relative_displacement == false）或MappingQEulerian（vector_describes_relative_displacement == true），但内部的操作要高效得多。 
* [0.x.12]*
   通过一个描述每个支持点的绝对或相对位置的解决方案（由[2.x.28]和一组[2.x.29]在三角测量的所有层面上指定）来初始化所有非人工单元的数据缓存。   
* [2.x.30]通过使用这个函数进行重新初始化，这个类的行为就像MappingFEField（vector_describes_relative_displacement == false）或MappingQEulerian（vector_describes_relative_displacement == true），但内部的操作要高效得多。 
* [0.x.13]*
   返回缓存的内存消耗（以字节为单位）。 
* [0.x.14]*
   这是从基类MappingQGeneric中重写的主要函数。 
* [0.x.15]*
   调用initialize()时填充的点缓存。它被做成一个共享指针，以允许多个实例（通过clone()创建）共享这个缓存。 
* [0.x.16]*
   与[2.x.31]的连接，一旦这个类超出范围就必须被重置。 
* [0.x.17]*
   指定是否已经为层次上的单元设置了support_point_cache。 
* [0.x.18]

