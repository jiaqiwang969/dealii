include/deal.II-translator/base/parsed_convergence_table_0.txt
[0.x.0]*


* 
* [2.x.0] 
* 这个类简化了收敛表的构造，从参数文件中读取生成表格的选项。它提供了一系列的方法，可以用来计算给定参考精确解的误差，或者两个数值解之间的差异，或者任何其他自定义的误差计算，通过[2.x.1]对象给出。
* 这个类的一个使用例子是这样给出的

* 
* [1.x.0]
* 
* 上面的代码构造了一个ParsedConvergenceTable，它适用于标量问题，并将产生一个包含误差的`H1_norm`、`L2_norm`和`Linfty_norm`规范的误差表。
* 每当调用error_from_exact()或difference()方法时，这个类的实例会检查其参数，计算构造时给出的参数所指定的所有规范，可能通过参数文件修改，计算所有使用add_extra_column()方法指定的额外列条目，并写入收敛表的一行。
* 一旦你完成了计算，对output_table()的调用将在提供的流上生成一个格式化的收敛表，并将其发送到参数文件中指定的文件（如果有的话）。
* 只要稍加修改，同样的代码就可以用来估计混合或多物理场问题的误差，例如。

* 
* [1.x.1]
* 
* 上面的代码假设你正在解决一个有三个分量的斯托克斯问题。两个分量为矢量速度场`u`，一个分量为压力场`p`，并将产生一个误差表，其中包括速度场（前两个分量）的误差`H1`和`L2`规范以及压力场的`L2`误差。
* 你也可以调用`table.output_table()`，不加参数，只把表写到参数文件中指定的文件。
* 通过调用方法add_parameters()传递一个ParameterHandler对象，以下选项将被定义在给定的ParameterHandler对象中（在ParameterHandler对象的当前级别，即你用[2.x.2]方法输入的任何级别），并可以在运行时通过参数文件进行修改。

* 
* [1.x.2]
 
* 在使用这个类时，请引证

* 
* [1.x.3]
* 

* 
* [0.x.1]*
   ParsedConvergenceTable对象的最小构造函数。    组件的数量必须与用于计算误差的有限元空间的组件数量一致。如果一个分量的名称重复，那么它将被解释为一个矢量场，重复的分量的误差将被归为一组。    矢量[2.x.3]的大小必须与唯一分量名称的数量相匹配，并且可以包含零个或多个逗号分隔的标识符，用于计算每个分量的规范（关于可用的选项，请参见[2.x.4]的文档）。    例如，下面的构造函数  
* [1.x.4]
*将产生（如果参数文件未被触动）一个类似于以下的表格  
* [1.x.5]
* 请参阅其他构造函数，了解你可以改变的所有参数的文件。     [2.x.5] component_names 指定组件的名称； [2.x.6] list_of_error_norms 指定为每个独特的组件名称计算什么错误规范。 
* [0.x.2]*
   ParsedConvergenceTable的完整构造函数。     [2.x.7] component_names 组件的名称。重复的连续名称被解释为矢量值域的组件； [2.x.8] list_of_error_norms 为每个独特的组件名称指定要计算的误差准则； [2.x.9] exponent 在p-norms中使用的指数； [2.x.10] extra_columns 要添加的额外列。这些可以是 "单元格 "或 "道夫"； [2.x.11] rate_key 指定额外的列，我们将通过它来计算错误率。这个键可以是 "cell "或 "dofs "中的一个，或者，如果你通过add_extra_column()方法向表中添加额外的列，它可以是你添加的额外列之一； [2.x.12] rate_mode 指定计算错误率时要使用的比率模式。  这可能是 "reduction_rate"，"reduction_rate_log2"，或者 "none"。参见[2.x.13]的文档，了解每种模式的行为方式； [2.x.14] error_file_name 错误输出文件的名称（扩展名为txt, gpl, tex, 或 org）。如果与空字符串不同，比output_table()也会以从其扩展名推断出的格式写入该文件； [2.x.15] precision 写入错误时要使用多少位数； [2.x.16] compute_error 控制是否启用填充表。这个标志可以用来在运行时禁用任何错误计算；你用这个构造函数指定的参数可以通过调用add_parameters()方法写入ParameterHandler对象中。一旦你调用add_parameters()方法，以下选项将被定义在给定的ParameterHandler对象中，并且这个类的实例的参数将跟随你在运行时对ParameterHandler对象的修改。 
* [1.x.6]
   
* [0.x.3]*
   将这个类中的所有参数附加到参数处理程序的条目上 [2.x.17] 每当[2.x.18]的内容发生变化，这个类的参数就会被更新。 
* [0.x.4]*
   在错误表中添加一行，包含[2.x.19]和[2.x.20]函数之间的错误，在参数文件中指定的规范（s）。    如果你在这个调用中指定了一个[2.x.21]函数，那么这将用于计算加权误差。权重函数可以是一个标量函数（将用于所有组件），也可以是一个向量函数。  当它是一个矢量函数时，如果分量的数量与底层有限元空间的分量数量不一致，将触发一个断言。 
* [0.x.5]*
   和上面一样，有不同的映射。 
* [0.x.6]*
   通过在调用error_from_exact()或difference()时调用函数[2.x.23]，在表中添加一个额外的列（名称为[2.x.22]）。    你可以根据你的需要多次调用这个方法。如果[2.x.24]已经在之前的调用中使用过，那么以相同的名字调用这个方法将覆盖你之前指定的任何函数。如果你在这个调用中使用了一个lambda函数，请确保在lambda函数内部使用的变量在调用error_from_exact()或difference()之前一直有效。    确保在第一次调用error_from_exact()或difference()之前添加所有额外列。在你已经开始填充收敛表之后再向收敛表添加额外的列将会触发一个异常。    例如，这个方法可以用来计算时间步长的误差，例如。 
* [1.x.7]
*将产生一个类似于以下的表格  
* [1.x.8]
* 只要你使用以下参数文件（这里只显示非默认条目）。 
* [1.x.9]
* [2.x.25] column_name 要添加的列的名称； [2.x.26] custom_function %将被调用以填充给定条目的函数。你需要确保这个函数的范围在调用error_from_exact()或difference()之前是有效的； [2.x.27] compute_rate 如果设置为true，那么这个列将被包含在计算错误率的列的列表中。如果你想计算与这一列有关的错误率，你可能想把它设置为false。在这种情况下，你还应该在参数文件中指定[2.x.28]作为比率键。 
* [0.x.7]*
   同一矢量空间中两个解决方案之间的差异。 
* [0.x.8]*
   与上述相同，有一个非默认的映射。 
* [0.x.9]*
   将错误表写入[2.x.29]流（文本格式），以及（可能）写入参数中指定的文件流（格式由文件名扩展名推断）。 
* [0.x.10]*
   将错误表写到参数中指定的文件流中。    如果参数文件中的 "错误文件名 "选项被设置为空字符串，则不写输出。 
* [0.x.11]*
   向输出表添加速率。 
* [0.x.12]*
   解决方案组件的名称。 
* [0.x.13]*
   与上述相同，但只包含一次重复的成分名称。 
* [0.x.14]*
   每个独特组件名称的掩码。 
* [0.x.15]*
   向表中添加行时要调用的额外方法。 
* [0.x.16]*
   计算每个组件的错误类型。 
* [0.x.17]*
   在p-norm类型中使用的指数。 
* [0.x.18]*
   实际的表格  
* [0.x.19]*
   要添加到表中的额外列。 
* [0.x.20]*
   我们计算收敛率所涉及的列的名称。 
* [0.x.21]*
   收敛率模式。参见[2.x.30]的文件。 
* [0.x.22]*
   用于输出表格的精度。 
* [0.x.23]*
   写入文件时要使用的文件名。 
* [0.x.24]*
   计算错误。如果这是错误的，所有进行错误计算的方法都被禁用，不做任何事情。 
* [0.x.25]

