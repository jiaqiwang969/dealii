include/deal.II-translator/base/polynomials_piecewise_0.txt
[0.x.0]*
  [2.x.0] 多项式 [2.x.1] 

 
* [0.x.1]*
 一个命名空间，与描述1d多项式空间有关的类在其中被声明。

* 
* [0.x.2]*
   单位区间的分片一维多项式的定义。这个空间允许在单位区间的部分上描述插值多项式，类似于在细分元素上定义有限元基函数。这个类的主要目的是允许构造FE_Q_iso_Q1类的形状函数，该类在每个坐标方向上都有一些插值点，但不是用它们来做高阶多项式，而只是选择片状线性形状函数
* 
* - 实际上，它是一个[2.x.2]元素，定义在参考单元的细分上，并在这些子单元中的每一个上进行复制。    这个类不是从ScalarPolynomialsBase基类派生的，因为它实际上不是一个多项式
* 
* - 它是一个片状多项式。  然而，它与[2.x.3]类是接口兼容的，因此可以作为TensorProductPolynomials的模板参数。   
* [2.x.4]   
* [0.x.3]*
     拉格朗日多项式的构造函数，该区间是单位区间的一个子集。它使用一个多项式描述，与单位区间相比，子区间的大小、区间的总数（细分）、区间的当前索引以及多项式是否跨越到下一个区间（例如，如果它生活在两个相邻的区间上）。        如果区间数为1，则分片多项式的表现与通常的多项式完全相同。   
* [0.x.4]*
     返回该多项式在给定点的值，评估底层多项式。当超出给定的区间时，该多项式评估为零（当它跨过该区间时，可能是右边的下一个区间）。   
* [0.x.5]*
     返回多项式在<tt>x</tt>点的值和导数。 <tt>values[i], i=0,...,values.size()-1</tt>包括<tt>i</tt>的导数。因此，要计算的导数的数量由传递的向量的大小决定。        请注意，所有的导数在单位区间内部的区间边界（假设是精确的算术）评估为零，因为在这种情况下对于片状多项式来说没有唯一的梯度值。这并不总是需要的（例如，当评估元素边界上的梯度跳跃时），但是当没有意义时，用户有责任避免在这些点进行评估。   
* [0.x.6]*
     返回多项式在<tt>x</tt>点的值和导数。 <tt>values[i], i=0,...,n_derivatives</tt>包括<tt>i</tt>的导数。要计算的导数数量由[2.x.5]决定，[2.x.6]必须为[2.x.7]+1的值提供足够的空间。        请注意，所有导数在单位区间内部的区间边界（假设是精确算术）评估为零，因为在这种情况下，对于片状多项式没有唯一的梯度值。这并不总是需要的（例如，当评估元素边界上的梯度跳跃时），但是当没有意义时，用户有责任避免在这些点进行评估。   
* [0.x.7]*
     多项式的度数。这是底层基础多项式的度数。   
* [0.x.8]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入或读出到一个流中，以便进行序列化。   
* [0.x.9]*
     返回此对象的内存消耗估计值（以字节为单位）。   
* [0.x.10]*
     底层多项式对象，被缩放到一个子区间，并相应地进行连接。   
* [0.x.11]*
     一个存储单位区间被分成的区间数的变量。   
* [0.x.12]*
     一个存储当前多项式在区间范围内的索引的变量。   
* [0.x.13]*
     存储如果多项式跨越两个相邻的区间，即子区间中给出的区间和下一个区间。   
* [0.x.14]*
   在子区间上给定的度数和区间数的情况下，在单位区间的细分上生成一个完整的拉格朗日基础，并将其划分为更小的区间。 
* [0.x.15]

