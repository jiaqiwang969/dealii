include/deal.II-translator/base/scalar_polynomials_base_0.txt
[0.x.0]*
 该类为有限元多项式类提供了一个框架，用于从FE_Poly派生的有限元类。这个类型的对象（或者说从这个类派生出来的类型）作为成员变量存储在每个FE_Poly类型的对象中。
* [1.x.0]
* 任何派生类必须为在参考单元上评估的形状函数提供最基本的属性。这包括但不限于实现evaluation()、name()和clone()成员函数。这些函数对于存储派生类中的多项式如何在参考单元上的给定点进行评估的最基本信息是必要的。关于每个函数的更多信息可以在相应函数的文档中找到。
* 从这个类派生的一些类包括 [2.x.0] [2.x.1] <tt>PolynomialsAdini</tt> [2.x.2] <tt>PolynomialsRannacherTurek</tt> [2.x.3] <tt>PolynomialsP</tt> [2.x.4 ] <tt>PolynomialSpace</tt> [2.x.5] <tt>TensorProductPolynomials</tt> [2.x.6] <tt>TensorProductPolynomialsConst</tt> [2.x.7] <tt>TensorProductPolynomialsBubbles</tt> [2.x.8] 
* 

* 
* [2.x.9] 

 
* [0.x.1]*
   构造函数。这需要空间的度数，[2.x.10]来自有限元类，[2.x.11]是空间的多项式数目。 
* [0.x.2]*
   移动构造器。 
* [0.x.3]*
   复制构造函数。 
* [0.x.4]*
   虚拟解构器。确保这个类的指针被正确删除。 
* [0.x.5]*
   计算[2.x.12]的多项式的值和导数，向量的大小必须是零或者等于<tt>n()</tt>。 在第一种情况下，函数将不计算这些值。    如果你需要所有多项式的值或导数，那么使用这个函数，而不是使用任何<tt>compute_value</tt>, <tt>compute_grad</tt> 或 <tt>compute_grad_grad</tt> 函数，见下文，在所有张量积多项式上循环。 
* [0.x.6]*
   计算在单位点<tt>p</tt>上的<tt>i</tt>次多项式的值。    可以考虑用evaluate()代替。 
* [0.x.7]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的<tt>阶</tt>次导数。    可以考虑用evaluate()代替。     [2.x.13] order 导数的阶数。 
* [0.x.8]*
   计算<tt>i</tt>第1个多项式在单位点<tt>p</tt>的一阶导数。    可以考虑用evaluate()代替。 
* [0.x.9]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的二阶导数。    可以考虑用evaluate()代替。 
* [0.x.10]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的三阶导数。    可以考虑用evaluate()代替。 
* [0.x.11]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的第四导数。    可以考虑用evaluate()代替。 
* [0.x.12]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的梯度。    可以考虑用evaluate()代替。 
* [0.x.13]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的二阶导数（grad_grad）。    可以考虑用evaluate()代替。 
* [0.x.14]*
   返回多项式的数量。 
* [0.x.15]*
   返回这个类所代表的多项式的最高阶数。如果派生类的值与[2.x.14]不同，可以重写这个值。  
* [0.x.16]*
   一个虚拟的拷贝构造函数，这个函数返回多项式空间对象的一个拷贝。派生类需要在这个基类中覆盖这里的函数，并返回一个与派生类相同类型的对象。    库中的一些地方，例如FE_Poly的构造函数，需要在不知道其确切类型的情况下制作多项式空间的副本。  他们通过这个函数来实现。 
* [0.x.17]*
   返回空间的名称。 
* [0.x.18]*
   返回这个对象的内存消耗估计值（以字节为单位）。 
* [0.x.19]*
   此对象所代表的此函数的最高多项式程度。 
* [0.x.20]*
   此对象所代表的多项式的数量。 
* [0.x.21]

