include/deal.II-translator/base/memory_consumption_0.txt
[0.x.0]*
 这个命名空间提供了帮助确定对象所使用的内存量的函数。其目的不一定是要给出到最后一位的内存用量（[2.x.0]对象使用的内存是多少？），而是要帮助寻找内存瓶颈。
* 这个命名空间有一个成员函数memory_consumption()和大量的特殊化。根据函数的参数类型，有几种操作模式。
* [2.x.1] [2.x.2] 如果参数是一个基本的C++数据类型（如<tt>bool</tt>, <tt>float</tt>, <tt>double</tt>或任何一个整数类型），那么 memory_consumption() 只是返回其参数的<tt>sizeof</tt>。该库还提供了对一个[2.x.3]*[2.x.4]所占用的内存量的估计。
* [2.x.4] 对于既不是标准类型，也不是向量的对象，memory_consumption()将简单地调用同名的成员函数。这取决于数据类型的实现，以提供对所使用的内存量的良好估计。在这个函数中，对类的化合物使用[2.x.5]有助于获得这种估计。deal.II库中的大多数类都有这样一个成员函数。
* [2.x.6] 对于对象的向量和C++数组，memory_consumption()对所有条目进行递归调用，并将结果加入对象本身的大小。存在一些针对标准数据类型的优化特殊化。
* [2.x.7] 对于普通指针的向量，memory_consumption(T*)返回指针向量的大小，忽略对象的大小。
* [2.x.8] 
* [1.x.0]
* 这个名字空间中的函数和它所提供的功能依赖于这样的假设：在这个名字空间中，有一个函数<tt>memory_consumption(T)</tt>确定<tt>T</tt>类型的对象所使用的内存量，或者<tt>T</tt>类有一个这个名字的成员函数。虽然后者对deal.II中几乎所有的类都是如此，但我们只为最常见的数据类型实现了第一类函数，如基本类型、字符串、C++向量、C-style数组和C++对。因此，这些函数并不包括，例如，C++地图、列表等。如果你需要这样的函数，请随时实现它们，并将它们发送给我们，以便纳入。
* 

* 
* [2.x.9] Wells

* 
* [0.x.1]*
   计算一个基本类型的内存消耗。参见EnableIfScalar，讨论如何实现这一限制（SFINAE）。 
* [0.x.2]*
   估计一个对象的内存消耗。如果对<tt>T</tt>类型没有进一步的模板专门化（超过这个），那么这个函数返回成员函数<tt>t.memory_consumption()</tt>的值。 
* [0.x.3]*
   确定一个C风格的字符串所消耗的内存量。返回的值不包括指针的大小。这个函数只测量到（并包括）NUL字节；底层缓冲区可能更大。 
* [0.x.4]*
   确定一个[2.x.10]变量所消耗的内存字节数。 
* [0.x.5]*
   确定一个<tt>VectorizedArray</tt>变量所消耗的内存字节数。 
* [0.x.6]*
   确定一个[2.x.11]变量所消耗的内存的估计字节数。 
* [0.x.7]*
   通过调用每个条目的memory_consumption()，确定一个<tt>T</tt>类型的元素的[2.x.12]所消耗的内存字节量。    这个函数在向量的所有条目上循环，并对每个<tt>v[i]</tt>使用memory_consumption()确定其大小。如果条目的大小是恒定的，可能有另一个全局函数memory_consumption()用于这个数据类型，或者有一个该类的成员函数的名字返回一个恒定的值，编译器会解开这个循环，这样操作就很快了。如果数据元素的大小是可变的，例如它们自己做内存分配，那么这个操作必然会更加昂贵。    使用该算法，特别是所有元素的循环，也可以计算向量的向量、字符串的向量等的内存消耗，其中单个元素的大小可能有很大不同。    请注意，这个算法也考虑到了被这个向量分配但目前没有使用的元素的大小。    对于最常用的向量，有一些特殊的函数可以不通过循环来计算其大小。这也适用于bools向量的特殊情况。 
* [0.x.8]*
   通过对每个条目调用memory_consumption()，确定一个<tt>N</tt>类型<tt>元素的[2.x.13]所消耗的内存字节数。    这个函数循环遍历数组的所有条目，并对每个<tt>v[i]</tt>使用memory_consumption()确定其大小。如果条目的大小是恒定的，可能有另一个全局函数memory_consumption()用于该数据类型，或者有一个该类的成员函数的名字返回一个恒定的值，编译器会解开这个循环，这样操作就会很快。如果数据元素的大小是可变的，例如它们自己做内存分配，那么这个操作必然会更加昂贵。    使用该算法，特别是所有元素的循环，也可以计算向量数组、字符串数组等的内存消耗，其中单个元素的大小可能有很大不同。 
* [0.x.9]*
   估计一个C型数组所占用的内存量（以字节为单位）。  由于在这个库中，我们通常不在这种数组中存储简单的数据元素，如<tt>double</tt>s（而是使用[2.x.14]或deal.II <tt>Vector</tt>对象），我们不提供像[2.x.15]数组的特殊化，而是始终使用所有元素的循环。 
* [0.x.10]*
   确定一个向量的内存消耗的特殊化，这里是针对一个<tt>bool</tt>s的向量。    这是一个特殊情况，因为bool不是一个一个地存储，而是作为一个位域。 
* [0.x.11]*
   确定一对数值所消耗的内存字节数的估计值。 
* [0.x.12]*
   计算一个指针的内存消耗。   
* [2.x.16] 这个函数对于C风格的字符串是重载的；关于这种情况，请看该函数的文档。   
* [2.x.17] 这个函数返回指针的大小，而不是指向的对象的大小。 
* [0.x.13]*
   返回一个共享指针所使用的内存量。   
* [2.x.18]这将返回指针的大小，而不是所指向的对象的大小。 
* [0.x.14]*
   返回一个[2.x.19]对象所使用的内存量。   
* [2.x.20] 这将返回指针的大小，而不是指向的对象的大小。 
* [0.x.15]

