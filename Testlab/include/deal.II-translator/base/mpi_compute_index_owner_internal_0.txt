include/deal.II-translator/base/mpi_compute_index_owner_internal_0.txt
[0.x.0]*
       一个用于[2.x.0]和[2.x.1]的内部命名空间。      
* [0.x.1]*
         [2.x.2]的特殊化，用于设置字典，即使在IndexSet空间中有不属于任何进程的范围。               
* [2.x.3] 仅供内部使用。       
* [0.x.2]*
           构造函数。         
* [0.x.3]*
           [2.x.4]的实现           
* [0.x.4]*
           [2.x.5]的实现           
* [0.x.5]*
           实现[2.x.6]* [0.x.6]*           
* [0.x.6]*
         具有基本分区的字典类，以所有MPI等级都知道的固定大小的单一区间为单位，用于两阶段索引查找。       
* [0.x.7]*
           区间的最小颗粒大小。                    我们选择限制两阶段查找的区间的最小尺寸是考虑到以下两个相互冲突的目标。一方面，我们不希望字典中的区间变得太短。对于不均匀的未知数分布（有些等级有几千个未知数，有些则没有），查询的DoFs为
* 
-> 字典就涉及到从一个MPI行列向许多其他持有字典间隔的MPI行列发送，导致一些行列必须发送的消息数量过高。另外，较少的较长的区间通常在查找时更有效率。另一方面，范围大小过大会导致相反的效果，即在查找DoFs中，许多消息会进入一个特定的字典所有者中
* 
-> 字典。在目前的设置下，在每个MPI等级有1个DoF的情况下，我们最多得到64条消息进入一个MPI等级，这是很合理的低。同时，不均匀的分布可以用最多64条信息来处理，最高可达4096的系数。         
* [0.x.8]*
           一个向量，其条目数与当前进程的字典中的道夫一样多，每个条目包含该道夫的所有者在IndexSet `owned_indices`中的等级。这在索引查找中被查询到，所以我们保留一个扩展的列表。         
* [0.x.9]*
           一个排序的向量，包含出现在`actually_owning_ranks`中的MPI等级。         
* [0.x.10]*
           用于索引空间分割的每个MPI等级上的字典中的未知数。为了简化索引查询，不需要额外的通信，这个数字在所有MPI等级上都是一样的。         
* [0.x.11]*
           在字典中表示的全局索引空间的局部范围，由`dofs_per_process`、当前MPI等级和range_minimum_grain_size计算得出。         
* [0.x.12]*
           实际大小，计算为dofs_per_process的最小值和索引空间的可能终点。相当于`local_range.second
* 
* - local_range.first`.          
* [0.x.13]*
           索引空间的全局大小。         
* [0.x.14]*
           `owned_indices`索引集分布的等级数量。         
* [0.x.15]*
           一个stride，用于在MPI行列中更均匀地分配工作，以防止颗粒大小迫使我们的范围少于我们的处理器。         
* [0.x.16]*
           通过计算全局大小的分区来设置字典，并将本地拥有的范围的等级信息发送给字典部分的所有者。         
* [0.x.17]*
           使用`dofs_per_process`将全局dof索引转换为字典中的MPI等级。我们乘以`stride_small_size`，以确保在MPI等级上的平衡，由于晶粒大小。         
* [0.x.18]*
           给出一个任意处理器的MPI等级ID，返回该处理器的本地范围开始的索引偏移。         
* [0.x.19]*
           给出来自`actually_owning_ranks`的自有索引中的等级，这将返回`actually_owning_rank_list`中的等级索引。         
* [0.x.20]*
           从索引空间的全局大小和等级的数量计算分区。         
* [0.x.21]*
         在[2.x.8]和[2.x.9]的背景下，对[2.x.7]进行专业化处理，并增加有效载荷。       
* [0.x.22]*
           构造函数。         
* [0.x.23]*
           描述本地拥有的空间的索引空间。         
* [0.x.24]*
           在一个给定等级上是 "幽灵 "的指数，应该从 owned_indices中根据其所有者等级来查找。         
* [0.x.25]*
           底层的MPI通信器。         
* [0.x.26]*
           目前的MPI等级。         
* [0.x.27]*
           参与MPI通信器 "comm "的行列总数。         
* [0.x.28]*
           控制鬼魂所有者的起源是否也应该被存储。如果是，它将被添加到`requesters`中，并可以通过`get_requesters()`查询。         
* [0.x.29]*
           索引所有者计算的结果。对`indices_to_look_up`中包含的每个索引，这个向量包含`owned_indices`中所有者的MPI等级。         
* [0.x.30]*
           追踪请求的来源。该数据结构的布局如下。最外层的向量有与[2.x.10]一样多的条目，代表我们应该从现在的字典条目中送回给所有者的信息。然后，第二个向量收集了一个已请求数据的MPI等级列表，使用第一对条目中的等级和索引范围的列表作为第二条目。         
* [0.x.31]*
           处理请求的字典。         
* [0.x.32]*
           用于收集要查询的索引的数组，按字典中的等级排序。         
* [0.x.33]*
           存储从进程中传入数据的索引的字段。         
* [0.x.34]*
           实现[2.x.11]在request_buffer中添加特定索引的所有者（并跟踪谁请求了一个特定的索引，以防该信息也被需要）。         
* [0.x.35]*
           [2.x.12]的实现           
* [0.x.36]*
           [2.x.13]的实施           
* [0.x.37]*
           执行[2.x.14]。          
* [0.x.38]*
           执行[2.x.15]。          
* [0.x.39]*
           通过将共识算法运行期间积累的字典所有者方面的信息送回原始IndexSet中的所有者，来解决请求的来源。这需要一些点对点的通信。                     [2.x.16]从当前等级请求的处理器和相关指数范围的地图          
* [0.x.40]*
           在 "requesters "字段中存储索引请求。我们首先找出被请求的索引的所有者（使用`owner_index`中的猜测，因为我们通常可能在同一等级上连续查找几次，这避免了[2.x.17]中的二进制搜索 一旦我们知道所有者的等级，我们就用请求的等级的向量条目。在这里，我们利用了请求被逐级处理的事实，所以我们可以简单地在向量的末尾看看是否已经有一些数据被存储。最后，我们建立范围，再次利用索引列表被排序的特点，因此我们只需要在最后追加。         
* [0.x.41]

