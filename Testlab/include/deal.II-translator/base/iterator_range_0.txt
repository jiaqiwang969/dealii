include/deal.II-translator/base/iterator_range_0.txt
[0.x.0]*
 一个用来表示迭代器集合的类，可以用迭代器的范围来表示，其特征是有一个开始和一个结束的迭代器。正如C++中常见的那样，这些范围被指定为由一个开始迭代器和一个过去的结束迭代器定义的半开区间。
* 这个类的目的是让诸如Triangulation和DoFHandler这样的类能够使用当前类型的对象从诸如[2.x.0]这样的函数中返回单元格迭代器的范围，然后这样的对象可以被用于C++11支持的基于范围的for循环，也见[2.x.1] "C++11标准"。
* 例如，如果目标是在每个活动单元上设置用户标志，这样的循环可以是这样的。

* 
* [1.x.0]
* 换句话说，[2.x.2]对象是迭代器，而由[2.x.3]和类似函数返回的范围对象在概念上被认为是[1.x.1]。
* 当然，这个类也可以用来表示其他迭代器范围，使用不同种类的迭代器进入其他容器。
* 

* [1.x.2]
* 非正式地，C++11标准描述[1.x.3]的方式如下。一个[1.x.4]的形式是

* 
* [1.x.5]
* 其中[2.x.4]是一个容器或集合，等同于以下的循环。

* 
* [1.x.6]
* （精确的定义可以在这里找到：https://en.cppreference.com/w/cpp/language/range-for 。换句话说，编译器引入了一个临时变量，[1.x.7]超过了容器或集合的元素，而出现在基于范围的for循环中的原始变量[2.x.5]代表了这些迭代器的[1.x.8]状态
* 
* - 即集合的[1.x.9]。
* 在单元格上的循环中，我们通常希望保留循环变量是一个迭代器而不是一个值的事实。这是因为在deal.II中，我们从未实际使用过单元格迭代器的[1.x.10]：从概念上讲，它代表一个单元格，技术上它是由CellAccessor和DoFCellAccessor等类实现的，但这些类从未被明确使用。因此，我们所希望的是，像[2.x.6]这样的调用返回一个对象，该对象代表一个<code>{begin, begin+1, ..., end-1}</code>的[1.x.11]。这很方便地表示为半开区间[2.x.7] 。然后，基于范围的for循环中的循环变量将依次接受这些迭代器中的每一个。
* 

* [1.x.12]
* 为了表示上述所需的语义，这个类存储了给定模板类型的半开区间的迭代器[2.x.8]。其次，该类需要提供begin()和end()函数，如果你[1.x.13][2.x.9]的结果，你会得到[2.x.10]迭代器。此外，你必须能够递增由[2.x.11]返回的对象，以便[2.x.12] 。换句话说，[2.x.13]必须返回一个迭代器，该迭代器在被解除引用时返回一个模板类型的迭代器 [2.x.14] : 它是一个迭代器上的迭代器，其意义与你有一个指针进入一个指针数组相同。
* 这是以[2.x.15]类的形式实现的。
* 

* 
* [2.x.16] 

* 
* [0.x.1]*
   迭代器类型的类型定义，该类型在其他迭代器上进行迭代。 
* [0.x.2]*
   本类所代表的迭代器类型的类型定义。 
* [0.x.3]*
   默认构造函数。创建一个由两个默认构造的迭代器代表的范围。这个范围可能是空的（取决于迭代器的类型）。 
* [0.x.4]*
   构造函数。给出开始和结束迭代器，构造一个范围。     [2.x.17] begin 指向该范围的第一个元素的迭代器 [2.x.18] end 指向该范围所代表的最后一个元素的迭代器。 
* [0.x.5]*
   返回指向这个范围的第一个元素的迭代器。 
* [0.x.6]*
   返回指向此范围的第一个元素的迭代器。 
* [0.x.7]*
   返回指向此范围最后一个元素之后的元素的迭代器。 
* [0.x.8]*
   返回指向该范围最后一个元素之后的元素的迭代器。 
* [0.x.9]*
   表征该范围的开始和结束的迭代器。 
* [0.x.10]*
 一个实现迭代器上的迭代器的语义的类，在IteratorRange类的设计部分中讨论过。

* 
* [0.x.11]*
   对集合中的元素进行类型化定义，给它们一个更明显的名称。 
* [0.x.12]*
   构造函数。以这样的方式初始化这个迭代器-over-iterator，使其指向给定的参数。     [2.x.19] iterator 这个对象应该指向的一个迭代器。 
* [0.x.13]*
   去引用操作符。   [2.x.20] 当前指向的集合中的迭代器。 
* [0.x.14]*
   解除引用操作符。   [2.x.21] 当前指向的集合中的迭代器。 
* [0.x.15]*
   前缀增量运算符。将当前的迭代器移动到集合的下一个元素，并返回新的值。 
* [0.x.16]*
   后缀增量运算符。将当前的迭代器移动到集合的下一个元素，但返回迭代器的前一个值。 
* [0.x.17]*
   比较运算符 [2.x.22] i_o_i 另一个迭代器的迭代器。   [2.x.23] 返回当前迭代器是否指向一个与参数所代表的迭代器不同的对象。 
* [0.x.18]*
   隐式转换操作符。     [2.x.24] 当你调用这个转换操作符时（即，你将这个迭代器-over-iterators转换为我们当前指向的迭代器），你获得一个对这个底层迭代器的`const`引用。你真正能对这个结果做的唯一事情是取消引用本身：它可能指向一些有用的东西，但由于你不知道指向的对象在哪里，你不应该增加或减少你从这个操作符得到的迭代器。因此，返回的迭代器被标记为 "const"，因为这将防止你做任何其他事情，而不是取消引用它。 
* [0.x.19]*
   将该类标记为前向迭代器，并声明一些别名，这些别名是迭代器的标准，被算法用来查询它们所工作的迭代器的具体内容。 
* [0.x.20]*
   这个迭代器当前指向的对象。 
* [0.x.21]*
 给出开始和结束的迭代器，创建一个IteratorRange类型的对象。

* 
* [0.x.22]

