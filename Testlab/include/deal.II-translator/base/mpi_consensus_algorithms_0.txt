include/deal.II-translator/base/mpi_consensus_algorithms_0.txt
[0.x.0]*
     一个为动态稀疏通信模式设计的共识算法命名空间。       
* [2.x.0]     
* [0.x.1]*
       一个能够使用接口类的接口。实现的主要功能是返回此进程想要的数据的进程等级列表，并处理由ConsensusAlgorithm类发送/接收的消息的可选有效载荷。            有两种消息。
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
 
* - 发送/请求消息。一个由数据请求组成的消息，应该由另一个进程来回答。该消息被接收等级视为请求消息。
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
* 
* - recv消息。对发送/请求信息的回答。             [2.x.1] T1 要发送的向量元素的类型 [2.x.2] T2 要接收的向量元素的类型            
* [2.x.3] 由于消息的有效载荷是可选的，用户必须自己处理缓冲区。ConsensusAlgorithm类1）只提供对空向量（大小为0）的引用，要发送的数据可以被插入或读出，2）盲目地交流这些向量。     
* [0.x.2]*
         销毁器。       
* [0.x.3]*
          [2.x.4] 这个进程要发送请求的行列的向量。               
* [2.x.5] 这是唯一必须实现的方法，因为信息的有效载荷是可选的。       
* [0.x.4]*
         在对进程的请求中加入指定等级的有效载荷。                 [2.x.6] 进程的其他等级 [2.x.7] send_buffer 要发送的请求的一部分数据（可选）。               
* [2.x.8] 缓冲区是空的。在使用它之前，你必须设置它的大小。       
* [0.x.5]*
         准备好缓冲区，在这个缓冲区中保存着对指定等级的进程的请求的回答的有效载荷。最明显的任务是调整缓冲区的大小，因为当函数被调用时它是空的。                 [2.x.9] 进程的其他等级 [2.x.10] recv_buffer 要发送请求部分的数据（可选）。       
* [0.x.6]*
         准备一个缓冲区，在这个缓冲区中保存对具有指定等级的进程的请求的回答的有效载荷。                 [2.x.11] 进程的其他等级 [2.x.12] buffer_recv 收到的有效载荷（可选） [2.x.13] request_buffer 将作为请求的一部分发送的有效载荷（可选）。               
* [2.x.14] request_buffer是空的。在使用它之前，你必须设置它的大小。       
* [0.x.7]*
         将请求的答案的有效载荷处理给具有指定等级的进程。                 [2.x.15] 进程的其他等级 [2.x.16] recv_buffer 将发送请求的一部分数据（可选）。       
* [0.x.8]*
       一个基类，用于实现提出通信模式的任务，以动态稀疏的方式从其他进程中检索数据的算法。在计算机科学中，这通常被称为[1.x.0]。            动态稀疏在这里意味着。
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
* 
* - 当这个函数被调用时，其他进程还不知道它们必须回答请求。
* 

* 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 每个进程只需要与MPI通信器的一小部分进程进行通信。            当然，用户必须提供。
* 

* 
* 

 
* 

 
 

 
 

 
 

 
 

 
 
* - 一个交流者。
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 对于每个等级，这个进程应该与之通信的进程的等级列表。
* 

* 
* 

* 
 

 
 

 
 

 
 

 
 

 
* 
* - 打包/解包要发送/接收的数据的功能。            这个基类只介绍了实现这些目标的基本接口，而派生类实现了不同的算法来实际计算这种通信模式。      本段上面列表中的最后两个特征是在派生类中实现的 [2.x.17] [2.x.18] T1 要发送的向量元素的类型。       [2.x.19] T2 要接收的向量元素的类型。     
* [0.x.9]*
         解构器。       
* [0.x.10]*
         运行共识算法并返回请求的进程。       
* [0.x.11]*
         对用户提供的进程的引用。       
* [0.x.12]*
         MPI通信器。       
* [0.x.13]*
         如果工作支持MPI，则为缓存。       
* [0.x.14]*
         这个进程的等级。       
* [0.x.15]*
         通信器中的进程数。       
* [0.x.16]*
       该类实现了[2.x.20]基类的具体算法，仅使用点对点通信和单一的IBarrier。           
* [2.x.21] 该类紧跟 [2.x.22] 。由于那里显示的算法没有考虑有效载荷，这里对算法进行了修改，同步发送（Issend）被等效的Isend/Irecv所取代，其中Irecv接收请求（带有效载荷）的答案。             [2.x.23] T1 要发送的向量元素的类型。       [2.x.24] T2 要接收的向量元素的类型。     
* [0.x.17]*
         构造函数。                 [2.x.25] process 共识算法期间要运行的进程。         [2.x.26] comm MPI通信器        
* [0.x.18]*
         解构器。       
* [0.x.19]*
          [2.x.27] [2.x.28].         
* [0.x.20]*
         此进程要发送请求的进程列表。       
* [0.x.21]*
         用于发送请求的缓冲区。       
* [0.x.22]*
         用于发送请求的请求。       
* [0.x.23]*
         用于接收请求的答复的缓冲区。       
* [0.x.24]*
         用于接收请求的答复的请求。       
* [0.x.25]*
         用于发送请求的答案的缓冲区。       
* [0.x.26]*
         用于发送对请求的回答的请求。       
* [0.x.27]*
         向本进程发出请求的进程列表。       
* [0.x.28]*
         检查这个等级是否已经收到了所有的请求答案。       
* [0.x.29]*
         向所有其他等级发出信号，表明这个等级已经通过进入IBarrier收到了所有的请求答案。       
* [0.x.30]*
         检查所有等级是否已经收到所有的请求答案，即所有等级都已到达 "障碍"。       
* [0.x.31]*
         已收到另一个等级的请求信息：处理请求并发送答复。       
* [0.x.32]*
         开始通过ISend发送所有的请求，并对收到的回答信息发布IRecvs。       
* [0.x.33]*
         在所有等级都收到所有答案后，可以释放MPI数据结构，并对收到的答案进行处理。       
* [0.x.34]*
       这个类实现了[2.x.29]基类的一个具体算法，使用了两步方法。      在第一步中，源等级被确定，在第二步中，进行静态稀疏数据交换。           
* [2.x.30] 与NBX不同，该类将同一任务分成两个不同的步骤。在第一步中，确定所有要向该进程发送请求的进程。在第二步中，进行数据交换。然而，由于
* 
* - 在第二步中
* 
* - 现在很清楚有多少个请求要被回答，也就是说，当这个进程可以停止等待请求时，就不需要IBarrier了。           
* [2.x.31] 函数 [2.x.32] 用于确定源进程，它实现了 [2.x.33] 的PEX-算法。             [2.x.34] T1 要发送的向量的元素的类型。       [2.x.35] T2 要接收的向量元素的类型。     
* [0.x.35]*
         构造函数。                 [2.x.36] process 共识算法期间要运行的进程。         [2.x.37] comm MPI通信器        
* [0.x.36]*
         解构器。       
* [0.x.37]*
          [2.x.38] [2.x.39].         
* [0.x.38]*
         此进程要发送请求的进程等级列表。       
* [0.x.39]*
         希望向该进程发送请求的进程的等级列表。       
* [0.x.40]*
         用于发送请求的缓冲区。       
* [0.x.41]*
         用于接收请求的答案的缓冲区。       
* [0.x.42]*
         用于发送请求和接收请求答案的请求。       
* [0.x.43]*
         用于发送请求的答案的缓冲区。       
* [0.x.44]*
         用于发送请求的答案的请求。       
* [0.x.45]*
         向本进程发出请求的进程列表。       
* [0.x.46]*
         已收到来自另一等级的第1个请求信息：处理该请求并发送一个回答。       
* [0.x.47]*
         开始通过ISend发送所有请求，并对收到的应答信息发布IRecvs。       
* [0.x.48]*
         在所有的答案被交换后，可以释放MPI数据结构，并处理收到的答案。       
* [0.x.49]*
       上述类的串行回退，以允许独立于是否使用MPI进行编程。     
* [0.x.50]*
         构造函数。                 [2.x.40] 进程 在共识算法过程中运行的进程。         [2.x.41] comm MPI通信器（忽略）。       
* [0.x.51]*
          [2.x.42] [2.x.43].         
* [0.x.52]*
       一个类，根据MPI通信器中的进程数量，将其任务委托给其他[2.x.44]实现。对于少量的进程它使用PEX，对于大量的进程使用NBX。阈值取决于程序是以调试模式还是发布模式编译的。             [2.x.45] T1 要发送的向量元素的类型。       [2.x.46] T2 要接收的向量元素的类型。     
* [0.x.53]*
         构造函数。                 [2.x.47] process 共识算法期间要运行的进程。         [2.x.48] comm MPI通信器。       
* [0.x.54]*
         解构器。       
* [0.x.55]*
          [2.x.49] [2.x.50].                 
* [2.x.51] 函数调用被委托给另一个[2.x.52]实现。       
* [0.x.56]*
       该类使用用户提供的函数包装器实现了[2.x.53]。      这个类的优点是，用户不必编写自己的实现，而是可以直接注册lambda函数。     
* [0.x.57]*
         注册为实现Process的接口而应该被调用的函数。                 [2.x.54] function_compute_targets在`compute_targets'期间调用。         [2.x.55] function_create_request在`create_request`时被调用。         [2.x.56] 在 "answer_request "中调用 function_answer_request。         [2.x.57] 在 "prepare_buffer_for_answer "中调用 function_prepare_buffer_for_answer。         [2.x.58] 在 "read_answer "中调用 function_read_answer。       
* [0.x.58]*
          [2.x.59] [2.x.60].         
* [0.x.59]*
          [2.x.61] [2.x.62].         
* [0.x.60]*
          [2.x.63] [2.x.64] [2.x.64]。        
* [0.x.61]*
          [2.x.65] [2.x.66]         
* [0.x.62]*
          [2.x.67] [2.x.68]         
* [0.x.63]

