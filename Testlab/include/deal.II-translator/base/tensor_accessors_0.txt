include/deal.II-translator/base/tensor_accessors_0.txt
[0.x.0]*
 这个命名空间是一个在通用张量对象（任意等级）上工作的算法的集合。
* 在一个单独的命名空间中以通用方式实现这种功能的理由是
* 

* 
* 

* 
* 
* - 以方便代码的重用，从而避免代码的重复。
* 

* 
* 

* 
* 
* - 要有一个定义明确的接口，可以交换低级别的实现。
* 

* 一个张量对象有一个等级的概念，并允许索引操作符的等级-次数递归应用，例如，如果[2.x.0]是一个等级为4的张量对象，下面的访问是有效的。

* 
* [1.x.0]
* 
* deal.II对诸如[2.x.1] dim, Number>和[2.x.2] dim, Number>这样的递归对象有自己的实现。
* 在这个命名空间中实现的方法和算法，是完全通用的。更确切地说，它可以对嵌套的c-style数组进行操作，或者对具有最小接口的类类型[2.x.3]进行操作，该接口提供了一个本地别名[2.x.4]和一个索引操作符[2.x.5]，它返回一个[2.x.6]的（常量或非常量）引用 。

* 
* [1.x.1]
* 
* 这个命名空间提供了访问、重新排序和收缩此类对象的基元。
* 

* 
* [2.x.7] 

 
* [0.x.1]*
   这个类提供了一个本地别名[2.x.8]，表示用operator[](unsigned int)访问的结果类型。更准确地说，[2.x.9] value_type将是
* 

* 
* 

* 
* 

 
 

 
* 
* - [2.x.10] 如果T是一个提供别名的张量类[2.x.11]，并且没有const限定词。
* 

* 
* 

* 
 

 
 

 
* 
* - [2.x.12] 如果T是一个提供别名的张量类[2.x.13]，并且确实有一个const限定词。
* 

* 
* 

 
* 

 
 

 
* 
* - [2.x.14] 如果T是一个提供别名的张量类[2.x.15]，并且确实有一个const限定词。
* 

* 
* 

 
 

 
 

 
 
* - [2.x.16] 
 

* 
* 

* 
 

 
 

 
* 
* - [2.x.17]并且确实有一个const限定词。 
* [0.x.2]*
   这个类提供了一个本地别名[2.x.18]，在通过``operator[](unsigned int)``递归后的[2.x.20]别名相等。此外，恒定性通过ValueType类型特征得以保留，即，如果T是恒定的，ReturnType<rank，[2.x.21]也将是恒定的。 
* [0.x.3]*
   为等级为[2.x.23]的张量对象的引用[2.x.22]提供一个 "张量视图"，其中索引[2.x.24]被移到最后。作为一个例子，考虑一个dim=5空间维度的五阶张量，可以通过5个递归[2.x.25]的调用来访问。 
* [1.x.2]
* 索引1（第2个索引，计数从0开始）现在可以通过以下方式移到末尾  
* [1.x.3]
* [2.x.26]类型的用法完全是为了举例说明。这个函数实现的机制可用于相当普遍的张量类型 [2.x.27] 这个重排设施的目的是能够在两个（或多个）张量的任意索引上收缩。
* 

* 
* 

* 
 

 
 

 
* 
* - 将指数重新排序，铭记在心，并将其置于张量的末端
 

* 
 

 
 

 
 

 
* 
* - 使用下面的收缩函数，收缩张量的_最后一个元素。   
* [2.x.28] 这个函数返回一个由数组下标操作符[2.x.29]和描述其返回值的别名[2.x.30]组成的内部类对象。     [2.x.31] index 要移到最后的索引。索引从0开始计算，因此有效范围是[2.x.32] 。   [2.x.33] 秩 递归对象的秩 [2.x.34] [2.x.35] T 秩 [2.x.36] [2.x.37] 的递归对象必须提供一个本地别名 [2.x.38] 和一个索引操作符 [2.x.39] ，它返回一个 [2.x.40] 的（常量或非常量）引用.  
* [0.x.4]*
   返回一个数组类型[2.x.43]对象[2.x.44]所描述的[2.x.41]类型的一个子对象的引用（常量或非常量）。 例如。 
* [1.x.4]
* 这相当于 [2.x.45] 。     [2.x.46] T 一个等级为[2.x.47][2.x.48]的递归对象必须提供一个本地别名[2.x.49]和一个索引操作符[2.x.50]，它返回一个[2.x.51]的（常量或非常量）引用 。此外，它的张力等级必须等于或大于 [2.x.52] [2.x.53] ArrayType 一个类似数组的对象，例如 [2.x.54] 或 [2.x.55] ，至少存储 [2.x.56] 索引，可以通过 operator[]() 访问。 
* [0.x.5]*
   这个函数收缩两个递归对象[2.x.57]和[2.x.58]，并将结果存储在[2.x.59]中，收缩是在两个递归对象的_最后_[2.x.60]索引上完成的。    [1.x.5] 调用这个函数相当于编写以下低级代码。 
* [1.x.6]
* 与r = rank_1 + rank_2
* 
* - 2 no_contr, l = rank_1
* 
* - no_contr, l1 = rank_1, and c = no_contr.    
* [2.x.61] 类型[2.x.62] [2.x.63]和[2.x.64]必须具有rank rank_1 + rank_2
* 
* - 2 no_contr, rank_1, 或 rank_2，分别。很明显，no_contr必须小于或等于rank_1和rank_2。 
* [0.x.6]*
   三个递归对象的完全收缩。    [1.x.7] 调用此函数相当于编写以下低级代码。 
* [1.x.8]
     
* [2.x.65] 类型[2.x.66] [2.x.67]和[2.x.68]必须分别具有等级rank_1, rank_1 + rank_2, 和 rank_3。 [2.x.69]必须是一个标量类型。 
* [0.x.7]*
     一个内部使用的类型特质，允许嵌套应用函数reordered_index_view(T &t)。        问题是，在处理实际的张量类型时，我们必须通过引用返回子张量
* 
* - 但有时，特别是对于返回r值的StoreIndex和ReorderedIndexView，我们必须按值返回。   
* [0.x.8]

