include/deal.II-translator/base/multithread_info_0.txt
[0.x.0]*
 这个类提供了在多线程程序中可能有用的系统信息。 目前，这只是CPU的数量。如果deal.II在编译时支持多线程，一些函数将使用多个线程进行操作。目前该库同时支持基于线程和基于任务的并行性。 [2.x.0]描述了每种的不同用途。用于基于任务的并行方法的默认线程数由线程构件库自动选择。有关这方面的更多信息，请参见[2.x.1]。 基于线程的并行方法需要明确地创建线程，并且可能希望使用与系统中CPU数量相关的线程数量。推荐的线程数可以用[2.x.2]来查询，而系统中的内核数则由[2.x.3]返回。
* 

* 
* [2.x.4] 

* 
* [0.x.1]*
   构造函数。这个构造函数被删除，因为不需要构造这个类的实例（所有成员都是静态的）。 
* [0.x.2]*
   系统中CPU的数量。    这个内部调用[2.x.5]，但如果调用返回错误，则将结果设置为1。 
* [0.x.3]*
   返回要使用的线程数。这最初被设置为系统的核心数（见n_cores()），但可以通过set_thread_limit()和环境变量DEAL_II_NUM_THREADS进一步限制。 
* [0.x.4]*
   返回这个对象的内存消耗估计值，单位是字节。  这不是精确的（但通常会很接近），因为计算树的内存使用量（例如，[2.x.6]是困难的。 
* [0.x.5]*
   将要使用的最大线程数设置为环境变量DEAL_II_NUM_THREADS和给定参数（或其默认值）的最小值。这将影响到TBB的初始化。如果两者都没有给出，则使用TBB的默认值（基于系统中的核心数量）。    在你main()中的代码运行之前，这个例程会自动执行，并使用默认参数（使用静态构造函数）。它也被[2.x.7]执行。如果你有一个基于MPI的代码，使用[2.x.8]的构造函数的适当参数。 
* [0.x.6]*
   如果TBB使用单线程运行，则返回，要么是因为线程亲和性，要么是因为通过调用set_thread_limit来设置。这在PETScWrappers中使用，以避免使用非线程安全的接口。 
* [0.x.7]*
   确保多线程API被初始化。这通常不需要在usercode中调用。 
* [0.x.8]*
   从taskflow返回对全局Executor的引用。    该执行器被设置为使用n_threads()工作线程，你可以使用set_thread_limit()和DEAL_II_NUM_THREADS环境变量控制。 
* [0.x.9]*
   代表最大线程数的变量。 
* [0.x.10]*
   存储一个用N个工作者构建的任务流执行器（来自set_thread_limit）。 
* [0.x.11]

