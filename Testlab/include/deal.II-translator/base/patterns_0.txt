include/deal.II-translator/base/patterns_0.txt
[0.x.0]*
 一些作为ParameterHandler类的模式的类的命名空间。这些类实现了一个接口，用于检查输入文件中的参数是否符合某种模式，如 "是布尔值"、"整数值 "等。
* 

* 
* [2.x.0] 

* 
* [0.x.1]*
   用于声明通用接口的基类。这个类的目的主要是为了定义模式的接口，并强制派生类有一个<tt>clone</tt>函数。因此，用《设计模式》一书（Gamma et al.）的语言来说，它是一个 "原型"。 
* [0.x.2]*
     使这个类和所有派生类的析构器成为虚拟的。   
* [0.x.3]*
     如果给定的字符串与模式匹配，返回<tt>true</tt>。   
* [0.x.4]*
     可能的描述输出格式的列表。        大写字母的选择与[2.x.1]相似。    
* [0.x.5]*
       适合在所有内置继承类的静态公共成员函数中进行机器解析的简单文本。            最好是人类可读的，但机器解析更为关键。     
* [0.x.6]*
       易于人类阅读的纯文本格式，适合纯文本文档。     
* [0.x.7]*
       易于人类阅读的LaTeX格式，适合在手册中打印。     
* [0.x.8]*
     返回一个描述该模式的字符串。   
* [0.x.9]*
     返回一个指向该对象的精确拷贝的指针。这是必要的，因为我们想把这种类型的对象存储在容器中，我们需要复制对象而不知道它们的实际数据类型（我们只有指向基类的指针）。        由这个函数返回的对象的所有权被传递给这个函数的调用者。   
* [0.x.10]*
     确定这个对象的内存消耗（以字节为单位）的估计值。为了避免不必要的开销，我们不强迫派生类提供这个函数作为一个虚拟的重载函数，而是尝试把现在的对象投给已知的派生类之一，如果失败了，那么就取这个基类的大小来代替，并加上32字节（这个值是任意的，它应该考虑到虚拟函数表，和一些可能的数据元素）。由于周围通常没有几千个这种类型的对象，并且由于memory_consumption机制是用来找出许多兆字节范围内的内存的，这似乎是一个合理的近似值。        另一方面，如果你知道你的类大大偏离了这个假设，你仍然可以重载这个函数。   
* [0.x.11]*
   根据描述返回指向正确派生类的指针。 
* [0.x.12]*
     对指定的[2.x.3]的字符串[2.x.2]进行转义，使字符按预期出现。例如，像_这样的字符在LateX中不能按原样书写，必须转义为\_。   
* [0.x.13]*
   测试字符串是否是一个整数。如果构造函数给出了边界，那么给出的整数也需要在这些边界所指定的区间内。请注意，与C++标准库中的惯例不同，这个区间的两个边界都是包容的；原因是在大多数情况下，我们需要封闭的区间，但对于非整数值来说，这些只能用包容的边界来实现。因此，我们总是使用封闭区间来保持一致性。    如果给构造函数的上界小于下界，那么每个整数都是允许的。    如果一个值只能是正数并且小于一个合理的上限（例如要执行的细化步骤的数量），或者在许多其他情况下，给出边界可能是有用的。 
* [0.x.14]*
     最小的整数值。如果numeric_limits类可用，则使用此信息来获得极值，否则设置它，使该类理解为允许所有值。   
* [0.x.15]*
     最大的整数值。如果numeric_limits类可用，则使用此信息来获得极值，否则设置它，使该类理解为允许所有的值。   
* [0.x.16]*
     构造函数。可以指定一个有效参数必须在其范围内的界限。如果上界小于下界，那么就意味着整个整数集。默认值的选择是不对参数强制执行界限。        请注意，当前类型的对象所隐含的范围包括两个界限值，即[2.x.4]是一个允许的值，而不是像其他情况下经常做的那样表示一个半开的值。   
* [0.x.17]*
     如果字符串是一个整数且其值在指定范围内，则返回<tt>true</tt>。   
* [0.x.18]*
     返回对有效字符串预期匹配的模式的描述。如果向构造函数指定了边界，那么就把它们包括在这个描述中。   
* [0.x.19]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移到该函数的调用者。   
* [0.x.20]*
     如果描述的开始部分与description_init匹配，则创建一个新的对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.21]*
     下限的值。满足该类的[2.x.5]操作的数字必须等于这个值或者更大，如果区间的边界为有效范围。   
* [0.x.22]*
     上限的值。满足本类的[2.x.6]操作的数字必须等于这个值或更小，如果区间的边界为有效范围。   
* [0.x.23]*
     描述的初始部分    
* [0.x.24]*
   测试字符串是否为<tt>double</tt>。如果给构造函数设定了边界，那么给定的整数也需要在这些边界所指定的区间内。请注意，与C++标准库中的惯例不同，这个区间的两个边界都是包容的；原因是在大多数情况下，我们需要封闭的区间，但对于非整数值来说，这些只能用包容的边界来实现。因此，我们总是使用封闭区间来保持一致性。    如果给构造函数的上界小于下界，那么每个双精度数字都是允许的。    如果一个值只能是正数并且小于一个合理的上限（例如阻尼参数经常只有在0和1之间才是合理的），或者在许多其他情况下，给出边界可能是有用的。 
* [0.x.25]*
     用作默认值的最小双值，取自[2.x.7]。    
* [0.x.26]*
     用作默认值的最大双倍值，取自[2.x.8]。    
* [0.x.27]*
     构造函数。可以指定一个有效参数必须在的范围内。如果上界小于下界，那么就意味着整个双精度的数字集。默认值的选择使参数不受任何约束。   
* [0.x.28]*
     如果字符串是一个数字且其值在指定范围内，则返回<tt>true</tt>。   
* [0.x.29]*
     返回对有效字符串预期匹配的模式的描述。如果向构造函数指定了边界，那么就把它们包括在这个描述中。   
* [0.x.30]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移到该函数的调用者。   
* [0.x.31]*
     如果给定的[2.x.10]是一个有效的格式（例如通过调用现有对象的description()创建），则使用[2.x.9]在堆上创建一个新的对象，否则使用[2.x.11]。返回的对象的所有权被转移给这个函数的调用者，应该使用[2.x.12]释放它。    
* [0.x.32]*
     下限的值。满足该类的[2.x.13]操作的数字必须等于这个值，或者更大，如果区间的边界形成一个有效的范围。   
* [0.x.33]*
     上限的值。如果区间的边界形成一个有效的范围，满足该类的[2.x.14]操作的数字必须等于这个值或小于这个值。   
* [0.x.34]*
     描述的初始部分    
* [0.x.35]*
   测试字符串是否是像正则表达式一样给出的数值序列中的一个。例如，如果给构造函数的字符串是<tt>"red|blue|black"</tt>，那么[2.x.15]函数准确地返回<tt>true</tt>，如果该字符串是 "红色 "或 "蓝色 "或 "黑色"。管状符号周围的空格并不重要，并被消除。 
* [0.x.36]*
     构造函数。以给定的参数作为有效字符串的规范。   
* [0.x.37]*
     如果该字符串是传递给构造函数的描述列表中的一个元素，则返回<tt>true</tt>。   
* [0.x.38]*
     返回对有效字符串预期匹配的模式的描述。这里，这是传递给构造函数的有效字符串的列表。   
* [0.x.39]*
     返回当前对象的副本，它是在堆上新分配的。该对象的所有权被转移到该函数的调用者。   
* [0.x.40]*
     确定这个对象的内存消耗（以字节为单位）的估计值。   
* [0.x.41]*
     如果description的开头与description_init匹配，则创建一个新对象。 该对象的所有权将转移给该函数的调用者。   
* [0.x.42]*
     传递给构造函数的有效字符串的列表。我们不使这个字符串成为常量，因为我们在构造函数中对它进行了一定的处理。   
* [0.x.43]*
     描述的初始部分    
* [0.x.44]*
   这个模式匹配一个由逗号（或另一个字符串）隔开的值的列表，每个值都必须匹配给构造器的模式。  通过两个额外的参数，可以指定这个列表必须有的元素数量。如果没有指定，该列表可以有零个或更多的条目。 
* [0.x.45]*
     最大的整数值。如果numeric_limits类可用，则使用此信息获得极值，否则设置它，使此类理解为允许所有值。   
* [0.x.46]*
     构造函数。以给定的参数作为列表的有效元素的规范。        其他三个参数可以用来表示列表的最小和最大允许长度，以及作为列表元素之间分隔符的字符串。   
* [0.x.47]*
     返回内部存储的分隔符。   
* [0.x.48]*
     返回内部存储的基本模式。   
* [0.x.49]*
     复制构造函数。   
* [0.x.50]*
     如果字符串是一个以逗号分隔的字符串列表，其中每一个都与给构造函数的模式匹配，则返回<tt>true</tt>。   
* [0.x.51]*
     返回有效字符串预期匹配的模式的描述。   
* [0.x.52]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.53]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.54]*
     确定这个对象的内存消耗（以字节为单位）的估计值。   
* [0.x.55]*
      [2.x.16] 异常情况[2.x.17]。    
* [0.x.56]*
     异常情况。   
* [0.x.57]*
     列表中每个元素必须满足的模式的拷贝。   
* [0.x.58]*
     列表必须有的最小元素数。   
* [0.x.59]*
     列表必须有的最大元素数。   
* [0.x.60]*
     列表中各元素之间的分隔符。   
* [0.x.61]*
     描述的初始部分    
* [0.x.62]*
   这个模式匹配一个用逗号分隔的列表，每个列表表示一对键和值。key和value都必须与给构造函数的模式匹配。对于地图的每个条目，必须以 [2.x.18] 的形式输入参数。换句话说，一个地图的描述形式是<code>key1: value1, key2: value2, key3: value3, ...</code>。两个构造函数参数允许选择除逗号以外的对之间的分隔符，以及除冒号以外的键和值之间的分隔符。    通过两个额外的参数，可以指定这个列表必须有的元素数量。如果没有指定，地图可以有零个或多个条目。 
* [0.x.63]*
     最大的整数值。如果numeric_limits类可用，则使用此信息获得极值，否则设置它，使此类理解为允许所有值。   
* [0.x.64]*
     构造函数。以给定的参数作为列表的有效元素的规范。        其他四个参数可以用来表示列表的最小和最大的允许长度，以及用来划分map的对的分隔符和用来分隔key和value的符号。   
* [0.x.65]*
     复制构造函数。   
* [0.x.66]*
     如果字符串是一个逗号分隔的字符串列表，其中每个字符串都符合构造函数所给的模式，则返回<tt>true</tt>。   
* [0.x.67]*
     返回有效字符串预期匹配的模式的描述。   
* [0.x.68]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.69]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.70]*
     确定这个对象的内存消耗（以字节为单位）的估计值。   
* [0.x.71]*
     返回一个对关键模式的引用。   
* [0.x.72]*
     返回一个对值模式的引用。   
* [0.x.73]*
     返回地图条目的分隔符。   
* [0.x.74]*
     返回键值分离器。   
* [0.x.75]*
      [2.x.19] 异常情况 [2.x.20].     
* [0.x.76]*
     异常情况。   
* [0.x.77]*
     复制地图的每个键和每个值必须满足的模式。   
* [0.x.78]*
     列表必须有的最小元素数。   
* [0.x.79]*
     列表必须有的最大元素数。   
* [0.x.80]*
     列表中各元素之间的分隔符。   
* [0.x.81]*
     键和值之间的分隔符。   
* [0.x.82]*
     描述的初始部分    
* [0.x.83]*
   这个模式匹配任意类型的以冒号分隔的值。每个类型都必须与构造函数所给的模式相匹配。    下面是一个用法示例。   
* [1.x.0]
* 或者，如果你想利用[2.x.21]。    
* [1.x.1]
* 构造函数希望得到一个模式的向量，以及一个指定从字符串解析Tuple时要使用的分隔符的字符串。    默认的分隔符是冒号，这是因为一对元素实际上是一个有两个元素的元组。 
* [0.x.84]*
     构造函数。使用一个指向模式的唯一指针的向量来构造元组。         [2.x.22] patterns 元组的每个对象应该匹配的模式 [2.x.23] separator 用于限定每个元素的可选字符串 构建器。   
* [0.x.85]*
     构造函数。和上面一样，专门用于 const char。这是必要的，以避免编译器因下面提供的变量构造器而产生错误。   
* [0.x.86]*
     构造函数。从一个以上的PatternBase派生的类中创建一个Tuple。         [2.x.24] 分隔符 要使用什么分隔符。     [2.x.25] patterns 要使用的模式列表。   
* [0.x.87]*
     构造器。这是需要的，以允许用户直接指定分离器而不使用 [2.x.26] 因为我们支持纯变体模板版本，如果没有这个特殊化，编译器将以隐性错误失败。   
* [0.x.88]*
     构造函数。和上面一样，使用默认的分离器。         [2.x.27] patterns 要使用的模式列表    
* [0.x.89]*
     复制构造函数。   
* [0.x.90]*
     如果字符串是一个字符串的列表，其中每一个都与给构造函数的模式相匹配，则返回<tt>true</tt>。   
* [0.x.91]*
     返回对有效字符串预期匹配的模式的描述。   
* [0.x.92]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.93]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.94]*
     确定这个对象的内存消耗（以字节为单位）的估计值。   
* [0.x.95]*
     返回一个对元组中第i个模式的引用。   
* [0.x.96]*
     返回元组条目的分隔符。   
* [0.x.97]*
     复制存储在Tuple中的模式。   
* [0.x.98]*
     列表中元素之间的分隔符。   
* [0.x.99]*
     描述的初始部分。   
* [0.x.100]*
   这个类很像选择类，但它允许输入是一个逗号分隔的列表，每个值都必须在构造函数参数中给出。输入可以是空的，也可以包含多个值，而且逗号周围可以有任意数量的空格。当然，给构造函数的值中不允许有逗号。    例如，如果给构造函数的字符串是<tt>"ucd|gmv|eps"</tt>，那么以下是合法输入。"eps", "gmv, eps", 或者""。 
* [0.x.101]*
     构建器。 [2.x.28]是一个由"|"分隔的有效选项的列表。   
* [0.x.102]*
     如果字符串是传递给构造函数的描述列表中的一个元素，则返回<tt>true</tt>。   
* [0.x.103]*
     返回对有效字符串预期匹配的模式的描述。这里，这是传递给构造函数的有效字符串的列表。   
* [0.x.104]*
     返回当前对象的副本，它是在堆上新分配的。该对象的所有权被转移到该函数的调用者。   
* [0.x.105]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.106]*
     确定这个对象的内存消耗（以字节为单位）的估计值。   
* [0.x.107]*
      [2.x.29] 异常情况 [2.x.30]     
* [0.x.108]*
     异常情况。   
* [0.x.109]*
     传递给构造函数的有效字符串的列表。我们不使这个字符串成为常量，因为我们在构造函数中会对它进行一些处理。   
* [0.x.110]*
     描述的初始部分    
* [0.x.111]*
   测试该字符串是 "真 "还是 "假"。这被映射到选择类中。 
* [0.x.112]*
     构造函数。   
* [0.x.113]*
     返回对有效字符串预期匹配的模式的描述。   
* [0.x.114]*
     返回一个当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.115]*
     如果描述的开始部分与description_init匹配，则创建一个新的对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.116]*
     描述的初始部分    
* [0.x.117]*
   当测试一个字符串时总是返回<tt>true</tt>。 
* [0.x.118]*
     构造函数。(允许在这个类中至少有一个非虚拟函数，因为否则有时没有虚拟表被发出)。   
* [0.x.119]*
     如果字符串符合其约束条件，则返回<tt>true</tt>，即总是如此。   
* [0.x.120]*
     返回对有效字符串预期匹配的模式的描述。这里，这是一个字符串<tt>"[Anything]"</tt>。   
* [0.x.121]*
     返回当前对象的副本，该对象是在堆上新分配的。该对象的所有权被转移到该函数的调用者。   
* [0.x.122]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.123]*
     描述的初始部分    
* [0.x.124]*
   一个模式，可以用来指示一个参数何时打算成为一个文件的名称。就其本身而言，这个类并不检查在参数文件中给出的字符串是否真的对应于一个现有的文件（例如，它可能是一个你想写入输出的文件的名称）。因此，该类在功能上等同于Anything类。然而，它允许指定一个参数的[1.x.2]。给予构造函数的标志也允许指定该文件应该是一个输入或输出文件。    这个类存在的原因是为了支持编辑参数文件的图形用户界面。如果文件名应该代表一个输入文件，这些文件可以打开一个文件选择对话框。 
* [0.x.125]*
     文件可以被用于输入或输出。这可以在构造函数中通过选择标志<tt>类型</tt>来指定。   
* [0.x.126]*
       打开用于输入。     
* [0.x.127]*
       为输出而开放。     
* [0.x.128]*
     构造器。 文件的类型可以通过选择标志来指定。   
* [0.x.129]*
     如果字符串符合其约束条件，则返回<tt>true</tt>，即总是如此。   
* [0.x.130]*
     返回对有效字符串预期匹配的模式的描述。这里，这是一个字符串<tt>"[Filename]"</tt>。   
* [0.x.131]*
     返回当前对象的副本，它是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.132]*
     文件类型标志    
* [0.x.133]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将转移给该函数的调用者。   
* [0.x.134]*
     描述的初始部分    
* [0.x.135]*
   一个模式，可用于指示参数何时打算成为一个目录的名称。就其本身而言，这个类并不检查在参数文件中给出的字符串是否真的对应于一个现有的目录。因此在功能上，该类等同于Anything类。然而，它允许指定一个参数的[1.x.3]。    这个类存在的原因是为了支持编辑参数文件的图形用户界面。这些可以打开一个文件选择对话框来选择或创建一个目录。 
* [0.x.136]*
     构造函数。   
* [0.x.137]*
     如果字符串符合其约束条件，则返回<tt>true</tt>，即总是如此。   
* [0.x.138]*
     返回对有效字符串预期匹配的模式的描述。这里，这是一个字符串<tt>"[Filename]"</tt>。   
* [0.x.139]*
     返回当前对象的副本，它是在堆上新分配的。该对象的所有权被转移给该函数的调用者。   
* [0.x.140]*
     如果描述的开始部分与description_init匹配，则创建一个新对象。 该对象的所有权将被转移给该函数的调用者。   
* [0.x.141]*
     描述的初始部分    
* [0.x.142]*
   一些类和函数的命名空间，它们作用于值和模式，并允许从非基本类型转换为字符串，反之亦然。    这些工具的一个典型用法是在下面的例子中。   
* [1.x.4]
* Convert<T>被这个命名空间中的函数[2.x.31]使用。在内部，它使用[2.x.32]类来决定需要多少个不同的分隔符来将给定的类型转换为字符串。    例如，要写向量的向量，默认是使用", "作为第一个（内部）分隔符，而"; "作为第二个（外部）分隔符，即    
* [1.x.5]
* [2.x.33]和[2.x.34]兼容类型的分隔符根据列表和地图对象的等级来选择，使用数组[2.x.35]和[2.x.36] 它们目前被设置为。   
* [1.x.6]
* 当人们需要[2.x.37]和[2.x.38]类型的混合物时，它们的RankInfo是通过取Key和Value类型的vector_rank的最大值来计算的，因此，例如，可以有以下情况  
* [1.x.7]
* 支持一些非基本类型，比如Point()，或者 [2.x.39] 如果你希望支持更多的类型，你必须对Convert结构以及RankInfo结构进行专业化。   
* [2.x.40]   
* [0.x.143]*
     转换器类。这个类用于生成与给定类型相关的字符串和模式，以及从字符串转换到给定类型，反之亦然。        第二个模板参数在内部使用，以允许先进的SFINAE（替换失败不是错误）技巧，用于为任意的STL容器和映射专门化这个类。   
* [0.x.144]*
       返回一个[2.x.41]给Pattern，可以用来解释一个字符串为模板参数的类型，反之亦然。            虽然当前的函数（在一般的Convert模板中）被删除了，但它在Convert类模板的特殊化中被实现并可用于特定种类的模板参数[2.x.42] 。      
* [0.x.145]*
       返回一个包含变量s的文本版本的字符串。使用传递的模式来执行转换，或者创建并使用一个默认的模式。            虽然当前的函数（在一般的Convert模板中）被删除了，但它在Convert类模板的特殊化中被实现并可用于特定种类的模板参数[2.x.43] 。      
* [0.x.146]*
       使用给定的模式，将一个字符串转换为一个值。使用传递的模式来执行转换，或者创建并使用一个默认的模式。            虽然当前的函数（在一般的Convert模板中）被删除了，但它在Convert类模板的特殊类型的模板参数中被实现并可用 [2.x.44] 。      
* [0.x.147]*
     一个实用的函数，简化了对任意复杂类型的字符串的转换。        这个函数以默认模式调用方法[2.x.45]。下面是一个用法示例。       
* [1.x.8]
* 参见类[2.x.46]和辅助类[2.x.47]的文档，以了解输出STL容器类型时选择分隔符的方式的细节。   
* [0.x.148]*
     一个实用的函数，简化了从字符串到任意类型的转换。        这个函数以默认模式调用方法[2.x.48]。下面是一个用法示例。       
* [1.x.9]
* 参见类[2.x.49]和辅助类[2.x.50]的文档，以了解从字符串转换到容器类型时应该在字符串模式中使用的分隔符。        注意，变量[2.x.51]的当前内容被忽略了。它的类型是用来推断如何解释字符串的。如果字符串被成功解析，那么[2.x.52]将被设置为[2.x.53]的解析内容。    
* [0.x.149]*
      [2.x.54] 例外情况 [2.x.55] 。    
* [0.x.150]*
     异常情况。   
* [0.x.151]*
       存储关于给定类的等级类型的信息。            一个类的等级等于在一个字符串中唯一识别其元素所需的不同分隔符的数量。            这个类用于检测类T是否与[2.x.56]模式或与[2.x.57]模式兼容。            像Point()或[2.x.58]这样的对象是向量类，并且有vector_rank 1。基本类型，如 "int"、"unsigned int"、"double "等，具有vector_rank 0。 [2.x.59] [2.x.60] 一般来说，容器的等级等于1+所含类型的vector_rank。对于地图类型也是如此。            一个[2.x.61]=0的类要么是基本类要么是地图。一个[2.x.62]=0的类要么是一个List兼容类，要么是一个基本类型。            基本类型与[2.x.63]不兼容，但非基本类型，如Point()，或[2.x.64]则与List类型兼容。添加更多的兼容类型是为给定的类型添加此结构的特殊化问题。     
* [0.x.152]*
       使用给定的模式或默认模式，将字符串转换为数值。     
* [0.x.153]

