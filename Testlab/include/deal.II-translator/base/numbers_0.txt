include/deal.II-translator/base/numbers_0.txt
[0.x.0]*
   一个辅助类，指定指定数据类型Number的VectorizedArray的最大向量长度，用于给定的处理器架构和优化级别。    最大向量长度的值被用作VectorizedArray的默认模板参数，这样VectorizedArray<Number>就相当于VectorizedArray<Number, [2.x.0] 。    
* [2.x.1] 该类是不支持矢量化的数据类型的默认实现。     [2.x.2] Number 想找出硬件支持的向量的最大长度的基础数据类型。 
* [0.x.1]*
     任意类型的VectorizedArray的最大向量长度。   
* [0.x.2]*
   一个辅助类，指定数据类型`double`的VectorizedArray的最大向量长度，用于给定的处理器架构和优化级别。关于支持的最大向量长度的详细描述，请参见VectorizedArray的文档。 
* [0.x.3]*
     Double的VectorizedArray的最大向量长度。   
* [0.x.4]*
   一个辅助类，指定数据类型 "float "的VectorizedArray的最大向量长度，适用于给定的处理器架构和优化级别。关于支持的最大向量长度的详细描述，请参见VectorizedArray的文档。 
* [0.x.5]*
     VectorizedArray的最大向量长度为float。   
* [0.x.6]*
 用于声明通用常数的命名空间。由于<tt>math.h</tt>中的可用性并不总是被保证，我们把它们放在这里。由于这个文件被<tt>base/config.h</tt>所包含，它们对整个库是可用的。
* 这里定义的常量是有时在系统包含文件<tt>math.h</tt>中声明的<tt>M_XXX</tt>常量的一个子集，但没有前缀<tt>M_</tt>。
* 除此之外，我们声明<tt>invalid_unsigned_int</tt>为可表示的最大无符号整数；这个值在库中被广泛用作无效索引、无效数组大小的标记，以及类似的目的。

* 
* [0.x.7]*
   e  
* [0.x.8]*
   log_2 e  
* [0.x.9]*
   log_10 e  
* [0.x.10]*
   log_e 2  
* [0.x.11]*
   日志_e 10  
* [0.x.12]*
   圆周率  
* [0.x.13]*
   pi/2  
* [0.x.14]*
   圆周率/4  
* [0.x.15]*
   sqrt(2)  
* [0.x.16]*
   1/sqrt(2)  
* [0.x.17]*
   检查给定的类型是否可以在CUDA设备代码中使用。  如果不能，DEAL_II_CUDA_HOST_DEV需要在使用该类型的函数中被禁用。 
* [0.x.18]*
    [2.x.3] 不能在CUDA设备代码中使用。 
* [0.x.19]*
   如果给定值是一个有限的浮点数，即既不是正负无穷大，也不是NaN（不是一个数字），则返回[2.x.4]。    注意，这个函数的参数类型是 [2.x.5] 。换句话说，如果你给出一个非常大的<code>long double</code>类型的数字，这个函数可能会返回 [2.x.6] ，即使这个数字相对于 [2.x.7] 类型来说是有限的。 
* [0.x.20]*
   如果给定复数的实部和虚部是有限的，则返回 [2.x.8]。 
* [0.x.21]*
   如果给定复数的实部和虚部是有限的，返回[2.x.9]。 
* [0.x.22]*
   如果给定复数的实部和虚部是有限的，则返回 [2.x.10]。    如果实部或虚部是非常大的数字，就[2.x.11]而言是无限的，但就[2.x.12]而言是有限的，也可能无法正常工作。 
* [0.x.23]*
   返回两个数字是否互相相等。    对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.13]这个函数期望[2.x.14]可以投射到[2.x.15]的类型。  
* [0.x.24]*
   返回两个数字是否相互不相等。    对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.16]这个函数期望[2.x.17]可以投射到[2.x.18]的类型。  
* [0.x.25]*
   返回一个值是否等于零。    对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。 
* [0.x.26]*
   返回 [2.x.19] 是否小于 [2.x.20] 对于复杂的数据类型（例如一些自动可分的数字），此函数返回由输入参数存储的标量值的比较结果。   
* [2.x.21]这个函数期望[2.x.22]可以投射到[2.x.23]的类型。  
* [0.x.27]*
   返回[2.x.24]是否小于或等于[2.x.25]对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.26]这个函数期望[2.x.27]可投到[2.x.28]的类型。  
* [0.x.28]*
   返回[2.x.29]是否大于[2.x.30]对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.31]这个函数期望[2.x.32]可投到[2.x.33]的类型。  
* [0.x.29]*
   返回[2.x.34]是否大于或等于[2.x.35]对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.36]这个函数期望[2.x.37]可以投射到[2.x.38]的类型。  
* [0.x.30]*
   一个结构，连同其部分特殊化[2.x.39]>，提供了特质和成员函数，使得编写同时适用于实数类型和复数类型的模板成为可能。这个模板主要用于实现线性代数类，如向量和矩阵，对实数和复数都有效。 
* [0.x.31]*
     一个标志，指定给这个类的模板类型是复数还是实数。因为一般的模板是为非复数类型选择的，所以答案是[2.x.40] 。   
* [0.x.32]*
     对于这个数据类型，别名为相应的实数类型。由于一般模板是为所有不是[2.x.41]的特殊化的数据类型选择的，底层类型必须是实值，所以real_type等于底层类型。   
* [0.x.33]*
     返回给定数字的复数共轭值。因为如果number不是复数数据类型，就会选择一般的模板，这个函数只是返回给定的数字。       
* [2.x.42]这个函数也可以在CUDA设备代码中使用。   
* [0.x.34]*
     返回给定数字的绝对值的平方。由于一般模板选择的是不等于[2.x.43]的类型，这个函数只是返回给定数字的平方。       
* [2.x.44]如果模板类型可以在CUDA设备代码中使用，这个函数也同样适用。   
* [0.x.35]*
     返回一个数字的绝对值。   
* [0.x.36]*
   一般NumberTraits类的特殊化，如果底层数据类型为[2.x.45]，则提供相关信息。  
* [0.x.37]*
     一个标志，指定给这个类的模板类型是复数还是实数。由于一般模板的这种特殊化是为复杂类型选择的，所以答案是[2.x.46] 。   
* [0.x.38]*
     对于这个数据类型，别名为相应的实数类型。由于模板的这种特殊化是为数字类型选择的[2.x.47]，所以实数类型等于用于存储复数的两个分量的类型。   
* [0.x.39]*
     返回给定数的复数共轭值。   
* [0.x.40]*
     返回给定数的绝对值的平方。由于一般模板的这种特殊化是为等于[2.x.48]的类型选择的，这个函数返回一个数与它的复数共轭的乘积。   
* [0.x.41]*
     返回一个复数的绝对值。   
* [0.x.42]*
   测试是否有可能将一种数字类型转换为另一种。 
* [0.x.43]下面的结构需要在一些特殊的数字类型之间进行转换。  也可以参见tensor.h了解另一种特殊化。 
* [0.x.44]*
   返回两个数字是否相互相等。对于复杂的数据类型（例如一些自动可微分的数字），这个函数只返回输入值所存储的标量值是否相等。   
* [2.x.49]当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.45]*
   返回两个数字是否彼此相等。对于复杂的数据类型（例如一些自动可分的数字），这个函数只返回输入值所存储的标量值是否相等。   
* [2.x.50]当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.46]*
   返回两个数字是否彼此相等。对于复杂的数据类型（例如一些自动可微分的数字），这个函数只返回输入值存储的标量值是否相等。   
* [2.x.51]当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.47]*
   返回[2.x.52]是否小于[2.x.53]对于复杂的数据类型（例如一些自动可分的数字），这个函数返回输入参数存储的标量值的比较结果。   
* [2.x.54]当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.48]*
   返回[2.x.55]是否小于[2.x.56]对于复杂的数据类型（例如一些自动可分的数字），这个函数返回输入参数存储的标量值的比较结果。   
* [2.x.57]当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.49]*
   返回[2.x.58]是否小于[2.x.59]对于复杂的数据类型（例如一些自动可分的数字），该函数返回输入参数存储的标量值的比较结果。   
* [2.x.60] 当ADOL-C被编译为 "高级分支 "功能时，那么这个特殊化只用于断言和其他不影响计算最终结果的代码路径中。 
* [0.x.50]

